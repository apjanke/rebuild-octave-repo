# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1380986529 14400
#      Sat Oct 05 11:22:09 2013 -0400
# Branch classdef
# Node ID c702371ff6df692d02895450e92b9d98c5c92ef9
# Parent  20d1b911b4e78f4cf6c8222cd365e9c5243ef62f
# Parent  387ecd448b30d69498bfc6fba3ef92ac8e94ffcb
maint: periodic merge of default to classdef

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-5a51fb7777a9950502965a043a70bd6ca5e0498b gnulib-hg
+6057744acd2c71c069a4b171c5fe1ff0d86c9e5f gnulib-hg
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -73,8 +73,10 @@ df1aceb8f0bc6b5b5062907931cc663467f57d93
 858cbf6fc2ec1c232f5cf1d75dc344439b39a89c rc-3-6-4-1
 faefa1bea8ddae3cab170afdeab68d3d15c4e623 ss-3-7-2
 0000000000000000000000000000000000000000 ss-3-7-2
 23a7661e529ae9bfc91693618f8c314c31f695ca ss-3-7-2
 cc5a7d1233f3acea85648baeb754fc0e8f225225 rc-3-6-4-2
 b29b10fbb7448cdfe29322446e1a589e7fe1a40a release-3-6-4
 4e50bd2946d8563d3e201cc04b3ba0720c991b06 ss-3-7-4
 608e307b49149b32a6d09c2f06493d04d3af9be4 ss-3-7-5
+3a9efb68272df556dccb84c87933dd8238e88902 ss-3-7-6
+cc13924a4266fb0359f59fabdce11071e6051d48 ss-3-7-7
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -37,17 +37,16 @@ EXTRA_DIST = \
   INSTALL.OCTAVE \
   NEWS \
   README \
   CITATION \
   bootstrap \
   bootstrap.conf \
   build-aux/find-files-with-tests.sh \
   build-aux/mk-opts.pl \
-  build-aux/mkinstalldirs \
   build-aux/move-if-change \
   build-aux/OctJavaQry.class \
   etc/NEWS.1 \
   etc/NEWS.2 \
   etc/NEWS.3 \
   etc/OLD-ChangeLogs/ChangeLog \
   etc/OLD-ChangeLogs/ChangeLog.1 \
   etc/OLD-ChangeLogs/doc-ChangeLog \
@@ -141,16 +140,20 @@ ChangeLog:
 	(cd $(srcdir); hg log --style=build-aux/changelog.tmpl --prune=b0e60ad4ae26 --only-branch=`hg branch`; echo ""; echo "See the files in the directory etc/OLD-ChangeLogs for changes before 2011-04-19") > $@.t
 	mv $@.t $@
 .PHONY: ChangeLog
 
 octetc_DATA = \
   NEWS \
   CITATION
 
+doxyhtml:
+	$(MAKE) -C doc/doxyhtml doxyhtml
+.PHONY: doxyhtml
+
 DIRS_TO_MAKE = \
   $(localfcnfiledir) \
   $(localapifcnfiledir) \
   $(localverfcnfiledir) \
   $(localoctfiledir) \
   $(localapioctfiledir) \
   $(localveroctfiledir) \
   $(localarchlibdir) \
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -12,16 +12,26 @@ Summary of important user-visible change
     states that are set locally affect the current function and all
     functions called from the current scope.  The previous warning state
     is restored on return from the current function.  The "local"
     option is ignored if used in the top-level workspace.
 
 Summary of important user-visible changes for version 3.8:
 ---------------------------------------------------------
 
+ ** Octave now uses OpenGL graphics by default with FLTK widgets.  If
+    OpenGL libraries or FLTK widgets are not available when Octave is
+    built, gnuplot is used.  You may also choose to use gnuplot for
+    graphics by executing the command
+
+      graphics_toolkit ("gnuplot")
+
+    Adding this command to your ~/.octaverc file will set the default
+    for each session.
+
  ** Octave now supports nested functions with scoping rules that are
     compatible with Matlab.  A nested function is one declared and defined
     within the body of another function.  The nested function is only
     accessible from within the enclosing function which makes it one
     method for making private functions whose names do not conflict with those
     in the global namespace (See also subfunctions and private functions).
     In addition, variables in the enclosing function are visible within the
     nested function.  This makes it possible to have a pseudo-global variable
@@ -38,16 +48,77 @@ Summary of important user-visible change
         endfunction
       endfunction
 
       function nested3 (...)
         ...
       endfunction
     endfunction
 
+ ** Line continuations inside character strings have changed.
+
+    The sequence '...' is no longer recognized as a line continuation
+    inside a character string.  A backslash '\' followed by a newline
+    character is no longer recognized as a line continuation inside
+    single-quoted character strings.  Inside double-quoted character
+    strings, a backslash followed by a newline character is still
+    recognized as a line continuation, but the backslash character must
+    be followed *immediately* by the newline character.  No whitespace or
+    end-of-line comment may appear between them.
+
+ ** Backslash as a continuation marker outside of double-quoted strings
+    is now deprecated.
+
+    Using '\' as a continuation marker outside of double quoted strings
+    is now deprecated and will be removed from a future version of
+    Octave.  When that is done, the behavior of
+
+      (a \
+       b)
+
+    will be consistent with other binary operators.
+
+ ** Redundant terminal comma accepted by parser
+
+    A redundant terminal comma is now accepted in matrix
+    definitions which allows writing code such as 
+
+    [a,...
+     b,...
+     c,...
+    ] = deal (1,2,3)
+
+ ** Octave now has limited support for named exceptions
+
+    The following syntax is now accepted:
+
+      try
+        statements
+      catch exception-id
+        statements
+      end
+
+    The exception-id is a structure with the fields "message" and
+    "identifier".  For example
+
+      try
+        error ("Octave:error-id", "error message");
+      catch myerr
+        printf ("identifier: %s\n", myerr.identifier);
+        printf ("message:    %s\n", myerr.message);
+      end_try_catch
+
+    When classdef-style classes are added to Octave, the exception-id
+    will become an MException object.
+
+ ** Warning IDs renamed:
+
+    Octave:array-as-scalar => Octave:array-to-scalar
+    Octave:array-as-vector => Octave:array-to-vector
+
  ** 'emptymatch', 'noemptymatch' options added to regular expressions.
 
     With this addition Octave now accepts the entire set of Matlab options
     for regular expressions.  'noemptymatch' is the default, but 'emptymatch'
     has certain uses where you need to match an assertion rather than actual
     characters.  For example, 
 
     regexprep ('World', '^', 'Hello ', 'emptymatch')
@@ -62,43 +133,79 @@ Summary of important user-visible change
     
     regexprep (str, '\t', '\n')
 
     would search the variable str for a TAB character (escape sequence \t)
     and replace it with a NEWLINE (escape sequence \n).  Previously the
     expression would have searched for a literal '\' followed by 't' and
     replaced the two characters with the sequence '\', 'n'.
 
- ** Redundant terminal comma accepted by parser
+ ** A TeX parser has been implemented for the FLTK toolkit and is the default
+    for any text object including titles and axis labels.  The TeX parser is
+    supported only for display on a monitor, not for printing.
 
-    A redundant terminal comma is now accepted in matrix
-    definitions which allows writing code such as 
+    A quick summary of features:
 
-    [a,...
-     b,...
-     c,...
-    ] = deal (1,2,3)
+    Code         Feature     Example             Comment
+    -----------------------------------------------------------------
+    _            subscript   H_2O                formula for water
+    ^            exponent    y=x^2               formula for parabola
+    \char        symbol      \beta               Greek symbol beta
+    \fontname    font        \fontname{Arial}    set Arial font
+    \fontsize    fontsize    \fontsize{16}       set fontsize 16
+    \color[rgb]  fontcolor   \color[rgb]{1 0 1}  set magenta color 
+    \bf          bold        \bfBold Text        bold font
+    \it          italic      \itItalic Text      italic font
+    \sl          slanted     \slOblique Text     slanted font
+    \rm          normal      \bfBold\rmNormal    normal font
+    {}           group       {\bf Bold}Normal    group objects
+                             e^{i*\pi} = -1      complex example
 
- ** Warning IDs renamed:
+ ** The m-files in the plot directory have been overhauled.
 
-    Octave:array-as-scalar => Octave:array-to-scalar
-    Octave:array-as-vector => Octave:array-to-vector
+    The plot functions now produce output that is nearly visually compatible
+    with Matlab.  Plot performance has also increased, dramatically for some
+    functions such as comet and waitbar.  Finally, the documentation for most
+    functions has been updated so it should be clearer both how to use a
+    function and when a function is appropriate.
 
  ** The m-files in the image directory have been overhauled.
 
     The principal benefit is that Octave will now no longer automatically
     convert images stored with integers to doubles.  Storing images as uint8
     or uint16 requires only 1/8 or 1/4 the memory of an image stored using
     doubles.  For certain operations, such as fft2, the image must still be
     converted to double in order to work.
 
     Other changes include fixes to the way indexed images are read from a
     colormap depending on the image class (integer images have a -1 offset to
     the colormap row number).
 
+ ** The imread and imwrite functions have been completely rewritten.
+
+    The main changes relate to the alpha channel, support for reading and
+    writing of floating point images, implemented writing of indexed images,
+    and appending images to multipage image files.
+
+    The issues that may arise due to backwards incompatibility are:
+
+      * imwrite no longer interprets a length of 2 or 4 in the third dimension
+        as grayscale or RGB with alpha channel (a length of 4 will be saved
+        as a CMYK image).  Alpha channel must be passed as separate argument.
+
+      * imread will always return the colormap indexes when reading an indexed
+        image, even if the colormap is not requested as output.
+
+      * transparency values are now inverted from previous Octave versions
+        (0 is for completely transparent instead of completely opaque).
+
+    In addition, the function imformats has been implemented to expand
+    reading and writing of images of different formats through imread
+    and imwrite.
+
  ** The colormap function now provides new options--"list", "register",
     and "unregister"--to list all available colormap functions, and to
     add or remove a function name from the list of known colormap
     functions.  Packages that implement extra colormaps should use these
     commands with PKG_ADD and PKG_DEL statements.
 
  ** strsplit has been modified to be compatible with Matlab.  There
     are two instances where backward compatibility is broken.
@@ -120,21 +227,21 @@ Summary of important user-visible change
 
       strsplit ("1 2, 3", ", ")
       ans = 
       {
        [1,1] = 1 2
        [1,2] = 3
       }
 
-    (2) By default, Matlab treats consecutive delimiters are as a single
+    (2) By default, Matlab treats consecutive delimiters as a single
     delimiter.  By default, Octave's legacy behavior was to return an
     empty string for the part between the delmiters.
 
-    Where the legacy behavior is desired, the call to strsplit() may be
+    Where legacy behavior is desired, the call to strsplit() may be
     replaced by ostrsplit(), which is Octave's original implementation of
     strsplit().
 
  ** The datevec function has been extended for better Matlab compatibility.
     It now accepts string inputs in the following numerical formats: 12, 21,
     22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
     In addition, the default for formats which do not specify a date is
     January 1st of the current year.  The previous default was the current day,
@@ -143,18 +250,23 @@ Summary of important user-visible change
  ** The error function and its derivatives has been extended to accept complex
     arguments.  The following functions now accept complex inputs:
 
     erf  erfc  erfcx   
 
     In addition two new error functions erfi (imaginary error function) and
     dawson (scaled imaginary error function) have been added.
 
- ** The default name of the Octave crash dump file is now called
-    octave-workspace instead of octave-core.
+ ** The glpk function has been modified to reflect changes in the GLPK
+    library.  The "round" and "itcnt" options have been removed.  The
+    "relax" option has been replaced by the "rtest" option.  The numeric
+    values of error codes and of some options have also changed.
+
+ ** The default name of the Octave crash dump file is now 
+    "octave-workspace" instead of "octave-core".
 
  ** A citation command has been added to display information on how to
     cite Octave and packages in publications.  The package system will
     look for and install CITATION files from packages.
 
  ** The java package from Octave Forge is now part of core Octave.  The
     following new functions are available for interacting with Java
     directly from Octave:
@@ -171,29 +283,33 @@ Summary of important user-visible change
     are now available (provided that Octave is compiled with support for
     Java enabled):
 
       helpdlg    listdlg   questdlg
       inputdlg   msgbox    warndlg
 
  ** Other new functions added in 3.8.0:
 
-      base64_decode               ellipke         lines      
-      base64_encode               erfcinv         polyeig                   
-      betaincinv                  erfi            readline_re_read_init_file
-      built_in_docstrings_file    expint          readline_read_init_file 
-      cmpermute                   findfigs        rgbplot               
-      cmunique                    fminsearch      save_default_options  
-      colorcube                   gallery         shrinkfaces           
-      copyobj                     gco             splinefit             
-      dawson                      hdl2struct      stemleaf           
-      dblist                      history_save    strjoin             
-      debug_jit                   importdata      struct2hdl          
-      doc_cache_create            iscolormap      tetramesh           
-      ellipj                      jit_enable      waterfall  
+      atan2d                     erfi             lines
+      base64_decode              expint           linsolve
+      base64_encode              findfigs         missing_component_hook
+      betaincinv                 flintmax         polyeig
+      built_in_docstrings_file   fminsearch       prefdir
+      cmpermute                  gallery          preferences
+      cmunique                   gco              readline_re_read_init_file
+      colorcube                  hdl2struct       readline_read_init_file
+      copyobj                    history_save     rgbplot
+      dawson                     imformats        save_default_options
+      dblist                     importdata       shrinkfaces
+      debug_jit                  isaxes           splinefit
+      desktop                    iscolormap       stemleaf
+      doc_cache_create           isequaln         strjoin
+      ellipj                     jit_debug        struct2hdl
+      ellipke                    jit_enable       tetramesh
+      erfcinv                    jit_startcnt     waterfall
 
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    setstr
       autocov    fstat                 krylovb      strerror
@@ -202,35 +318,41 @@ Summary of important user-visible change
       cquad      is_duplicate_entry    saveimage            
       
     The following functions have been deprecated in Octave 3.8 and will
     be removed from Octave 3.12 (or whatever version is the second major
     release after 3.8):
 
       default_save_options    java_set                  
       gen_doc_cache           java_unsigned_conversion  
-      java_convert_matrix     javafields                
-      java_debug              javamethods               
-      java_get                re_read_readline_init_file
-      java_invoke             read_readline_init_file   
-      java_new                saving_history            
-      
+      isequalwithequalnans    javafields                
+      java_convert_matrix     javamethods               
+      java_debug              re_read_readline_init_file
+      java_get                read_readline_init_file   
+      java_invoke             saving_history            
+      java_new           
+
     The following keywords have been deprecated in Octave 3.8 and will
     be removed from Octave 3.12 (or whatever version is the second major
     release after 3.8):
 
       static
 
     The following configuration variables have been deprecated in Octave
     3.8 and will be removed from Octave 3.12 (or whatever version is the
     second major release after 3.8):
 
       CC_VERSION  (now GCC_VERSION)
       CXX_VERSION (now GXX_VERSION)
 
+    The internal class <Octave_map> has been deprecated in Octave 3.8 and will
+    be removed from Octave 3.12 (or whatever version is the second major
+    release after 3.8).  Replacement classes are <octave_map> (struct array)
+    or <octave_scalar_map> for a single structure.
+
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.  If a pre-compiled
     package does not exist for your system, you can find PCRE sources
     at http://www.pcre.org
 
  ** The ARPACK library is no longer distributed with Octave.
diff --git a/bootstrap b/bootstrap
--- a/bootstrap
+++ b/bootstrap
@@ -1,15 +1,15 @@
 #! /bin/sh
 # Print a version string.
-scriptversion=2012-07-19.14; # UTC
+scriptversion=2013-08-15.22; # UTC
 
 # Bootstrap this package from checked-out sources.
 
-# Copyright (C) 2003-2012 Free Software Foundation, Inc.
+# Copyright (C) 2003-2013 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -135,30 +135,31 @@ po_download_command_format=\
 "rsync --delete --exclude '*.s1' -Lrtvz \
  'translationproject.org::tp/latest/%s/' '%s'"
 
 # Fallback for downloading .po files (if rsync fails).
 po_download_command_format2=\
 "wget --mirror -nd -q -np -A.po -P '%s' \
  http://translationproject.org/latest/%s/"
 
+# Prefer a non-empty tarname (4th argument of AC_INIT if given), else
+# fall back to the package name (1st argument with munging)
 extract_package_name='
-  /^AC_INIT(/{
-     /.*,.*,.*, */{
-       s///
-       s/[][]//g
-       s/)$//
+  /^AC_INIT(\[*/{
+     s///
+     /^[^,]*,[^,]*,[^,]*,[ []*\([^][ ,)]\)/{
+       s//\1/
+       s/[],)].*//
        p
        q
      }
-     s/AC_INIT(\[*//
-     s/]*,.*//
+     s/[],)].*//
      s/^GNU //
      y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
-     s/[^A-Za-z0-9_]/-/g
+     s/[^abcdefghijklmnopqrstuvwxyz0123456789_]/-/g
      p
   }
 '
 package=$(sed -n "$extract_package_name" configure.ac) \
   || die 'cannot find package name in configure.ac'
 gnulib_name=lib$package
 
 build_aux=build-aux
@@ -200,74 +201,66 @@ copy=false
 # Or set it to 'auto' to make this script select which to use based
 # on which version control system (if any) is used in the source directory.
 vc_ignore=auto
 
 # Set this to true in bootstrap.conf to enable --bootstrap-sync by
 # default.
 bootstrap_sync=false
 
-# Don't use git to update gnulib sources. We keep gnulib under a
-# Mercurial subrepository instead
-use_git=false
-GNULIB_SRCDIR=gnulib-hg
+# Use git to update gnulib sources
+use_git=true
 
 # find_tool ENVVAR NAMES...
 # -------------------------
 # Search for a required program.  Use the value of ENVVAR, if set,
 # otherwise find the first of the NAMES that can be run (i.e.,
 # supports --version).  If found, set ENVVAR to the program name,
 # die otherwise.
 #
 # FIXME: code duplication, see also gnu-web-doc-update.
 find_tool ()
 {
   find_tool_envvar=$1
   shift
   find_tool_names=$@
   eval "find_tool_res=\$$find_tool_envvar"
   if test x"$find_tool_res" = x; then
-    for i
-    do
+    for i; do
       if ($i --version </dev/null) >/dev/null 2>&1; then
-       find_tool_res=$i
-       break
+        find_tool_res=$i
+        break
       fi
     done
-  else
-    find_tool_error_prefix="\$$find_tool_envvar: "
   fi
-  test x"$find_tool_res" != x \
-    || die "one of these is required: $find_tool_names"
-  ($find_tool_res --version </dev/null) >/dev/null 2>&1 \
-    || die "${find_tool_error_prefix}cannot run $find_tool_res --version"
+  if test x"$find_tool_res" = x; then
+    warn_ "one of these is required: $find_tool_names;"
+    die   "alternatively set $find_tool_envvar to a compatible tool"
+  fi
   eval "$find_tool_envvar=\$find_tool_res"
   eval "export $find_tool_envvar"
 }
 
-# Find sha1sum, named gsha1sum on MacPorts, and shasum on Mac OS X 10.6.
-find_tool SHA1SUM sha1sum gsha1sum shasum
-
 # Override the default configuration, if necessary.
 # Make sure that bootstrap.conf is sourced from the current directory
 # if we were invoked as "sh bootstrap".
 case "$0" in
   */*) test -r "$0.conf" && . "$0.conf" ;;
   *) test -r "$0.conf" && . ./"$0.conf" ;;
 esac
 
 # Extra files from gnulib, which override files from other sources.
 test -z "${gnulib_extra_files}" && \
   gnulib_extra_files="
-        $build_aux/install-sh
-        $build_aux/mdate-sh
-        $build_aux/texinfo.tex
-        $build_aux/depcomp
-        $build_aux/config.guess
-        $build_aux/config.sub
+        build-aux/install-sh
+        build-aux/mdate-sh
+        build-aux/texinfo.tex
+        build-aux/depcomp
+        build-aux/config.guess
+        build-aux/config.sub
         doc/INSTALL
 "
 
 if test "$vc_ignore" = auto; then
   vc_ignore=
   test -d .git && vc_ignore=.gitignore
   test -d CVS && vc_ignore="$vc_ignore .cvsignore"
 fi
@@ -303,55 +296,55 @@ done
 
 $use_git || test -d "$GNULIB_SRCDIR" \
   || die "Error: --no-git requires --gnulib-srcdir"
 
 if test -n "$checkout_only_file" && test ! -r "$checkout_only_file"; then
   die "Bootstrapping from a non-checked-out distribution is risky."
 fi
 
-# Ensure that lines starting with ! sort last, per gitignore conventions
-# for whitelisting exceptions after a more generic blacklist pattern.
-sort_patterns() {
-  sort -u "$@" | sed '/^!/ {
-    H
-    d
-  }
-  $ {
-    P
-    x
-    s/^\n//
-  }' | sed '/^$/d'
+# Strip blank and comment lines to leave significant entries.
+gitignore_entries() {
+  sed '/^#/d; /^$/d' "$@"
 }
 
-# If $STR is not already on a line by itself in $FILE, insert it,
-# sorting the new contents of the file and replacing $FILE with the result.
-insert_sorted_if_absent() {
+# If $STR is not already on a line by itself in $FILE, insert it at the start.
+# Entries are inserted at the start of the ignore list to ensure existing
+# entries starting with ! are not overridden.  Such entries support
+# whitelisting exceptions after a more generic blacklist pattern.
+insert_if_absent() {
   file=$1
   str=$2
   test -f $file || touch $file
-  echo "$str" | sort_patterns - $file | cmp -s - $file > /dev/null \
-    || { echo "$str" | sort_patterns - $file > $file.bak \
-      && mv $file.bak $file; } \
-    || die "insert_sorted_if_absent $file $str: failed"
+  test -r $file || die "Error: failed to read ignore file: $file"
+  duplicate_entries=$(gitignore_entries $file | sort | uniq -d)
+  if [ "$duplicate_entries" ] ; then
+    die "Error: Duplicate entries in $file: " $duplicate_entries
+  fi
+  linesold=$(gitignore_entries $file | wc -l)
+  linesnew=$( { echo "$str"; cat $file; } | gitignore_entries | sort -u | wc -l)
+  if [ $linesold != $linesnew ] ; then
+    { echo "$str" | cat - $file > $file.bak && mv $file.bak $file; } \
+      || die "insert_if_absent $file $str: failed"
+  fi
 }
 
 # Adjust $PATTERN for $VC_IGNORE_FILE and insert it with
-# insert_sorted_if_absent.
+# insert_if_absent.
 insert_vc_ignore() {
   vc_ignore_file="$1"
   pattern="$2"
   case $vc_ignore_file in
   *.gitignore)
     # A .gitignore entry that does not start with '/' applies
     # recursively to subdirectories, so prepend '/' to every
     # .gitignore entry.
     pattern=$(echo "$pattern" | sed s,^,/,);;
   esac
-  insert_sorted_if_absent "$vc_ignore_file" "$pattern"
+  insert_if_absent "$vc_ignore_file" "$pattern"
 }
 
 # Die if there is no AC_CONFIG_AUX_DIR($build_aux) line in configure.ac.
 found_aux_dir=no
 grep '^[	 ]*AC_CONFIG_AUX_DIR(\['"$build_aux"'\])' configure.ac \
     >/dev/null && found_aux_dir=yes
 grep '^[	 ]*AC_CONFIG_AUX_DIR('"$build_aux"')' configure.ac \
     >/dev/null && found_aux_dir=yes
@@ -465,17 +458,17 @@ check_versions() {
           warn_ "Error: '$app' not found or not from Automake-NG"
           ret=1
           continue
         } ;;
     esac
     if [ "$req_ver" = "-" ]; then
       # Merely require app to exist; not all prereq apps are well-behaved
       # so we have to rely on $? rather than get_version.
-      $app --version >/dev/null 2>&1
+      $app --version >/dev/null 2>&1 </dev/null
       if [ 126 -le $? ]; then
         warn_ "Error: '$app' not found"
         ret=1
       fi
     else
       # Require app to produce a new enough version string.
       inst_ver=$(get_version $app)
       if [ ! "$inst_ver" ]; then
@@ -499,16 +492,22 @@ check_versions() {
 print_versions() {
   echo "Program    Min_version"
   echo "----------------------"
   printf %s "$buildreq"
   echo "----------------------"
   # can't depend on column -t
 }
 
+# Find sha1sum, named gsha1sum on MacPorts, shasum on Mac OS X 10.6.
+# Also find the compatible sha1 utility on the BSDs
+if test x"$SKIP_PO" = x; then
+  find_tool SHA1SUM sha1sum gsha1sum shasum sha1
+fi
+
 use_libtool=0
 # We'd like to use grep -E, to see if any of LT_INIT,
 # AC_PROG_LIBTOOL, AM_PROG_LIBTOOL is used in configure.ac,
 # but that's not portable enough (e.g., for Solaris).
 grep '^[	 ]*A[CM]_PROG_LIBTOOL' configure.ac >/dev/null \
   && use_libtool=1
 grep '^[	 ]*LT_INIT' configure.ac >/dev/null \
   && use_libtool=1
@@ -547,17 +546,17 @@ if ! printf "$buildreq" | check_versions
   else
     die "Please install the prerequisite programs"
   fi
 fi
 
 echo "$0: Bootstrapping from checked-out $package sources..."
 
 # See if we can use gnulib's git-merge-changelog merge driver.
-if test -d .git && (git --version) >/dev/null 2>/dev/null ; then
+if $use_git && test -d .git && (git --version) >/dev/null 2>/dev/null ; then
   if git config merge.merge-changelog.driver >/dev/null ; then
     :
   elif (git-merge-changelog --version) >/dev/null 2>/dev/null ; then
     echo "$0: initializing git-merge-changelog driver"
     git config merge.merge-changelog.name 'GNU-style ChangeLog merge driver'
     git config merge.merge-changelog.driver 'git-merge-changelog %O %A %B'
   else
     echo "$0: consider installing git-merge-changelog from gnulib"
@@ -570,23 +569,27 @@ cleanup_gnulib() {
   rm -fr "$gnulib_path"
   exit $status
 }
 
 git_modules_config () {
   test -f .gitmodules && git config --file .gitmodules "$@"
 }
 
-gnulib_path=$(git_modules_config submodule.gnulib.path)
-test -z "$gnulib_path" && gnulib_path=gnulib
+if $use_git; then
+  gnulib_path=$(git_modules_config submodule.gnulib.path)
+  test -z "$gnulib_path" && gnulib_path=gnulib
+fi
 
-# Get gnulib files.
+# Get gnulib files.  Populate $GNULIB_SRCDIR, possibly updating a
+# submodule, for use in the rest of the script.
 
 case ${GNULIB_SRCDIR--} in
 -)
+  # Note that $use_git is necessarily true in this case.
   if git_modules_config submodule.gnulib.url >/dev/null; then
     echo "$0: getting gnulib files..."
     git submodule init || exit $?
     git submodule update || exit $?
 
   elif [ ! -d "$gnulib_path" ]; then
     echo "$0: getting gnulib files..."
 
@@ -597,18 +600,18 @@ case ${GNULIB_SRCDIR--} in
     git clone $shallow git://git.sv.gnu.org/gnulib "$gnulib_path" ||
       cleanup_gnulib
 
     trap - 1 2 13 15
   fi
   GNULIB_SRCDIR=$gnulib_path
   ;;
 *)
-  # Use GNULIB_SRCDIR as a reference.
-  if test -d "$GNULIB_SRCDIR"/.git && \
+  # Use GNULIB_SRCDIR directly or as a reference.
+  if $use_git && test -d "$GNULIB_SRCDIR"/.git && \
         git_modules_config submodule.gnulib.url >/dev/null; then
     echo "$0: getting gnulib files..."
     if git submodule -h|grep -- --reference > /dev/null; then
       # Prefer the one-liner available in git 1.6.4 or newer.
       git submodule update --init --reference "$GNULIB_SRCDIR" \
         "$gnulib_path" || exit $?
     else
       # This fallback allows at least git 1.5.5.
@@ -624,22 +627,29 @@ case ${GNULIB_SRCDIR--} in
           || exit $?
       fi
     fi
     GNULIB_SRCDIR=$gnulib_path
   fi
   ;;
 esac
 
+# $GNULIB_SRCDIR now points to the version of gnulib to use, and
+# we no longer need to use git or $gnulib_path below here.
+
 if $bootstrap_sync; then
   cmp -s "$0" "$GNULIB_SRCDIR/build-aux/bootstrap" || {
     echo "$0: updating bootstrap and restarting..."
+    case $(sh -c 'echo "$1"' -- a) in
+      a) ignored=--;;
+      *) ignored=ignored;;
+    esac
     exec sh -c \
       'cp "$1" "$2" && shift && exec "${CONFIG_SHELL-/bin/sh}" "$@"' \
-      -- "$GNULIB_SRCDIR/build-aux/bootstrap" \
+      $ignored "$GNULIB_SRCDIR/build-aux/bootstrap" \
       "$0" "$@" --no-bootstrap-sync
   }
 fi
 
 gnulib_tool=$GNULIB_SRCDIR/gnulib-tool
 <$gnulib_tool || exit $?
 
 # Get translations.
@@ -677,21 +687,20 @@ update_po_files() {
   langs=$(cd $ref_po_dir && echo *.po | sed 's/\.po//g')
   test "$langs" = '*' && langs=x
   for po in $langs; do
     case $po in x) continue;; esac
     new_po="$ref_po_dir/$po.po"
     cksum_file="$ref_po_dir/$po.s1"
     if ! test -f "$cksum_file" ||
         ! test -f "$po_dir/$po.po" ||
-        ! $SHA1SUM -c --status "$cksum_file" \
-            < "$new_po" > /dev/null; then
+        ! $SHA1SUM -c "$cksum_file" < "$new_po" > /dev/null 2>&1; then
       echo "$me: updated $po_dir/$po.po..."
       cp "$new_po" "$po_dir/$po.po" \
-          && $SHA1SUM < "$new_po" > "$cksum_file"
+          && $SHA1SUM < "$new_po" > "$cksum_file" || return
     fi
   done
 }
 
 case $SKIP_PO in
 '')
   if test -d po; then
     update_po_files po $package || exit
@@ -886,30 +895,31 @@ bootstrap_post_import_hook \
 # requirement, but it should be ok.  Ignore any failure, which is fine,
 # since this is only a convenience to help developers avoid the relatively
 # unusual case in which a symlinked-to .m4 file is git-removed from gnulib
 # between successive runs of this script.
 find "$m4_base" "$source_base" \
   -depth \( -name '*.m4' -o -name '*.[ch]' \) \
   -type l -xtype l -delete > /dev/null 2>&1
 
+# Invoke autoreconf with --force --install to ensure upgrades of tools
+# such as ylwrap.
+AUTORECONFFLAGS="--verbose --install --force -I $m4_base $ACLOCAL_FLAGS"
+
 # Some systems (RHEL 5) are using ancient autotools, for which the
 # --no-recursive option had not been invented.  Detect that lack and
 # omit the option when it's not supported.  FIXME in 2017: remove this
 # hack when RHEL 5 autotools are updated, or when they become irrelevant.
-no_recursive=
 case $($AUTORECONF --help) in
-  *--no-recursive*) no_recursive=--no-recursive;;
+  *--no-recursive*) AUTORECONFFLAGS="$AUTORECONFFLAGS --no-recursive";;
 esac
 
 # Tell autoreconf not to invoke autopoint or libtoolize; they were run above.
-echo "running: AUTOPOINT=true LIBTOOLIZE=true " \
-    "$AUTORECONF --verbose --install $no_recursive -I $m4_base $ACLOCAL_FLAGS"
-AUTOPOINT=true LIBTOOLIZE=true \
-    $AUTORECONF --verbose --install $no_recursive -I $m4_base $ACLOCAL_FLAGS \
+echo "running: AUTOPOINT=true LIBTOOLIZE=true $AUTORECONF $AUTORECONFFLAGS"
+AUTOPOINT=true LIBTOOLIZE=true $AUTORECONF $AUTORECONFFLAGS \
   || die "autoreconf failed"
 
 # Get some extra files from gnulib, overriding existing files.
 for file in $gnulib_extra_files; do
   case $file in
   */INSTALL) dst=INSTALL;;
   build-aux/*) dst=$build_aux/${file#build-aux/};;
   *) dst=$file;;
diff --git a/bootstrap.conf b/bootstrap.conf
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -44,16 +44,17 @@ gnulib_modules="
   getopt-gnu
   gettimeofday
   glob
   isatty
   largefile
   link
   lstat
   malloc-gnu
+  mbrtowc
   mkdir
   mkfifo
   mkostemp
   mktime
   nanosleep
   nproc
   open
   opendir
@@ -138,21 +139,24 @@ automake   1.9.6
 git        1.5.5
 tar        -
 "
 checkout_only_file=etc/HACKING
 gnulib_tool_option_extras="--libtool"
 gnulib_name="libgnu"
 source_base="libgnu"
 
-## Use --foreign since we auto-generate the AUTHORS file and the default
-## --gnu strictness level doesn't like it if the AUTHORS file is missing.
+# Don't use git to update gnulib sources. We keep gnulib under a
+# Mercurial subrepository instead.
+use_git=false
+GNULIB_SRCDIR=gnulib-hg
 
-AUTOMAKE="automake --foreign --warnings=no-portability"
-export AUTOMAKE
+# Don't check for translations since we don't have any in Octave yet.
+# This avoids the need for sha1sum or compatible utility in bootstrap.
+SKIP_PO=true
 
 bootstrap_post_import_hook ()
 {
   ## Check for files that automake --gnu would normally look for, except
   ## AUTHORS, which we autogenerate from the documentation files along
   ## with building the rest of Octave, and INSTALL, which is linked from
   ## gnulib/doc/INSTALL by the bootstrap script.
 
diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -235,17 +235,17 @@ sub process_data
 When called with no arguments, the names of all available options and\\n\\
 their current values are displayed.\\n\\
 Given one argument, return the value of the corresponding option.\\n\\
 When called with two arguments, \@code{$OPT_FCN_NAME} set the option\\n\\
 \@var{opt} to value \@var{val}.";
     }
 }
 
-#FIXME: What does this routine do?  And can it be simpler to understand?
+## FIXME: What does this routine do?  And can it be simpler to understand?
 sub get_min_match_len_info
 {
   my ($i, $j, $k);
 
   for ($i = 0; $i < $OPT_NUM; $i++)
     {
       for ($j = 0; $j < $MAX_TOKENS; $j++)
         {
@@ -919,17 +919,17 @@ DEFUN ($OPT_FCN_NAME, args, ,
 Options include\\n\\
 \\n\\
 \@table \@code\\n\\
 _END_EMIT_OPTIONS_FUNCTION_HDR_
 # FIXME: Add extra newline above
 
   for (my $i = 0; $i < $OPT_NUM; $i++)
     {
-      print '@item \"', $NAME[$i], '\"\n\\', "\n";
+      print '@item @qcode{\"', $NAME[$i], '\"}\n\\', "\n";
       print $DOC_ITEM[$i] if $DOC_ITEM[$i];
     }
 
   print <<"_END_EMIT_OPTIONS_FUNCTION_BODY_";
 \@end table\\n\\
 \@end deftypefn")
 {
   octave_value_list retval;
diff --git a/build-aux/mkinstalldirs b/build-aux/mkinstalldirs
deleted file mode 100755
--- a/build-aux/mkinstalldirs
+++ /dev/null
@@ -1,162 +0,0 @@
-#! /bin/sh
-# mkinstalldirs --- make directory hierarchy
-
-scriptversion=2009-04-28.21; # UTC
-
-# Original author: Noah Friedman <friedman@prep.ai.mit.edu>
-# Created: 1993-05-16
-# Public domain.
-#
-# This file is maintained in Automake, please report
-# bugs to <bug-automake@gnu.org> or send patches to
-# <automake-patches@gnu.org>.
-
-nl='
-'
-IFS=" ""	$nl"
-errstatus=0
-dirmode=
-
-usage="\
-Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
-
-Create each directory DIR (with mode MODE, if specified), including all
-leading file name components.
-
-Report bugs to <bug-automake@gnu.org>."
-
-# process command line arguments
-while test $# -gt 0 ; do
-  case $1 in
-    -h | --help | --h*)         # -h for help
-      echo "$usage"
-      exit $?
-      ;;
-    -m)                         # -m PERM arg
-      shift
-      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
-      dirmode=$1
-      shift
-      ;;
-    --version)
-      echo "$0 $scriptversion"
-      exit $?
-      ;;
-    --)                         # stop option processing
-      shift
-      break
-      ;;
-    -*)                         # unknown option
-      echo "$usage" 1>&2
-      exit 1
-      ;;
-    *)                          # first non-opt arg
-      break
-      ;;
-  esac
-done
-
-for file
-do
-  if test -d "$file"; then
-    shift
-  else
-    break
-  fi
-done
-
-case $# in
-  0) exit 0 ;;
-esac
-
-# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
-# mkdir -p a/c at the same time, both will detect that a is missing,
-# one will create a, then the other will try to create a and die with
-# a "File exists" error.  This is a problem when calling mkinstalldirs
-# from a parallel make.  We use --version in the probe to restrict
-# ourselves to GNU mkdir, which is thread-safe.
-case $dirmode in
-  '')
-    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
-      echo "mkdir -p -- $*"
-      exec mkdir -p -- "$@"
-    else
-      # On NextStep and OpenStep, the `mkdir' command does not
-      # recognize any option.  It will interpret all options as
-      # directories to create, and then abort because `.' already
-      # exists.
-      test -d ./-p && rmdir ./-p
-      test -d ./--version && rmdir ./--version
-    fi
-    ;;
-  *)
-    if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
-       test ! -d ./--version; then
-      echo "mkdir -m $dirmode -p -- $*"
-      exec mkdir -m "$dirmode" -p -- "$@"
-    else
-      # Clean up after NextStep and OpenStep mkdir.
-      for d in ./-m ./-p ./--version "./$dirmode";
-      do
-        test -d $d && rmdir $d
-      done
-    fi
-    ;;
-esac
-
-for file
-do
-  case $file in
-    /*) pathcomp=/ ;;
-    *)  pathcomp= ;;
-  esac
-  oIFS=$IFS
-  IFS=/
-  set fnord $file
-  shift
-  IFS=$oIFS
-
-  for d
-  do
-    test "x$d" = x && continue
-
-    pathcomp=$pathcomp$d
-    case $pathcomp in
-      -*) pathcomp=./$pathcomp ;;
-    esac
-
-    if test ! -d "$pathcomp"; then
-      echo "mkdir $pathcomp"
-
-      mkdir "$pathcomp" || lasterr=$?
-
-      if test ! -d "$pathcomp"; then
-	errstatus=$lasterr
-      else
-	if test ! -z "$dirmode"; then
-	  echo "chmod $dirmode $pathcomp"
-	  lasterr=
-	  chmod "$dirmode" "$pathcomp" || lasterr=$?
-
-	  if test ! -z "$lasterr"; then
-	    errstatus=$lasterr
-	  fi
-	fi
-      fi
-    fi
-
-    pathcomp=$pathcomp/
-  done
-done
-
-exit $errstatus
-
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "scriptversion="
-# time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-time-zone: "UTC"
-# time-stamp-end: "; # UTC"
-# End:
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -14,39 +14,43 @@ dnl Copyright (C) 1993-2012 John W. Eato
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, see
 ### <http://www.gnu.org/licenses/>.
 
 AC_PREREQ([2.62])
-AC_INIT([GNU Octave], [3.7.5], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.7.7+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2013-05-14"
+OCTAVE_RELEASE_DATE="2013-09-23"
 OCTAVE_COPYRIGHT="Copyright (C) 2013 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 dnl FIXME: We should auto-insert the Mercurial changeset ID into the
 dnl        AC_REVISION field whenever configure.ac is modified.
 dnl AC_REVISION($Revision: 1.603 $)
 AC_CONFIG_SRCDIR([libinterp/octave.cc])
 AC_CONFIG_HEADERS([config.h:config.in.h])
 AC_CONFIG_AUX_DIR([build-aux])
 AC_CONFIG_MACRO_DIR([m4])
 
-AM_INIT_AUTOMAKE([1.11 tar-ustar])
+AM_INIT_AUTOMAKE([1.11 foreign -Wno-portability -Wno-override tar-ustar subdir-objects])
+
+## Add the option to enable silent rules, available since Automake 1.11
+## and included by default starting with Automake 1.13.
+AM_SILENT_RULES
 
 OCTAVE_CANONICAL_HOST
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define to 1 if this is Octave.])
   
 AC_USE_SYSTEM_EXTENSIONS
 
 ### Make configure args available for other uses.
@@ -707,17 +711,17 @@ OCTAVE_CHECK_LIB(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
 ### Also define HAVE_ZLIB if libz is found.
 if test $octave_cv_lib_z = yes; then
   AC_DEFINE(HAVE_ZLIB, 1, [Define to 1 if ZLIB is available.])
 fi
 
-### Check for the LLVM library
+ ### Check for the LLVM library
 
 build_jit=no
 AC_ARG_ENABLE([jit],
   [AS_HELP_STRING([--enable-jit],
     [(EXPERIMENTAL) enable JIT compiler])],
   [if test "$enableval" = yes; then
      build_jit=yes
    fi],
@@ -737,43 +741,72 @@ if test $build_jit = yes; then
   if test -z "$LLVM_CONFIG"; then
     warn_llvm="llvm-config utility not found.  JIT compiler is disabled."
   else
     dnl Preset warning message in case compile fails
     warn_llvm="LLVM was not found or is to old.  JIT compiler is disabled."
 
     save_CPPFLAGS="$CPPFLAGS"
     save_CXXFLAGS="$CXXFLAGS"
+    save_LDFLAGS="$LDFLAGS"
 
     ## Use -isystem if available because we don't want to see warnings in LLVM
     LLVM_INCLUDE_FLAG=-I
     OCTAVE_CC_FLAG([-isystem .], [
       LLVM_INCLUDE_FLAG=-isystem
       AC_MSG_NOTICE([using -isystem for LLVM headers])])
 
     dnl Use -isystem so we don't get warnings from llvm headers
     LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
     LLVM_CXXFLAGS=
     LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
-    LLVM_LIBS=`$LLVM_CONFIG --libs`
+
+
+    LDFLAGS="$LDFLAGS $LLVM_LDFLAGS"
+    LLVM_SO=LLVM-`$LLVM_CONFIG --version`
+    AC_CHECK_LIB([$LLVM_SO], [LLVMBuildAdd], [LLVM_LIBS="-l$LLVM_SO"], [LLVM_LIBS=`$LLVM_CONFIG --libs`])
 
     dnl
     dnl Define some extra flags that LLVM requires in order to include headers.
     dnl Ideally we should get these from llvm-config, but llvm-config isn't
     dnl very helpful.
     dnl
     CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
     CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
     AC_LANG_PUSH(C++)
     AC_CHECK_HEADER([llvm/Support/TargetSelect.h], [
       warn_llvm=
       XTRA_CXXFLAGS="$XTRA_CXXFLAGS $LLVM_CXXFLAGS $LLVM_CPPFLAGS"])
+
+    have_function_h=no
+    AC_CHECK_HEADERS([llvm/IR/Function.h llvm/Function.h],
+                     [have_function_h=yes; break])
+    if test $have_function_h = no; then
+      warn_llvm="Missing LLVM file Function.h.  JIT compiler is disabled."
+    fi
+    have_irbuilder_h=no
+    AC_CHECK_HEADERS([llvm/Support/IRBuilder.h llvm/IR/IRBuilder.h \
+                      llvm/IRBuilder.h], [have_irbuilder_h=yes; break])
+    if test $have_irbuilder_h = no; then
+      warn_llvm="Missing LLVM file IRBuilder.h.  JIT compiler is disabled."
+    fi
+    have_llvm_data_h=no
+    AC_CHECK_HEADERS([llvm/Target/TargetData.h llvm/IR/DataLayout.h \
+                      llvm/DataLayout.h], [have_llvm_data_h=yes; break])
+    if test $have_llvm_data_h = no; then
+      warn_llvm="Missing LLVM file TargetData.h.  JIT compiler is disabled."
+    fi
+
+    OCTAVE_LLVM_FUNCTION_ADDATTRIBUTE_API
+    OCTAVE_LLVM_FUNCTION_ADDFNATTR_API
+    OCTAVE_LLVM_CALLINST_ADDATTRIBUTE_API
     AC_LANG_POP(C++)
     CPPFLAGS="$save_CPPFLAGS"
     CXXFLAGS="$save_CXXFLAGS"
+    LDFLAGS="$save_LDFLAGS"
   fi
 
   if test -z "$warn_llvm"; then
     AC_DEFINE(HAVE_LLVM, 1, [Define to 1 if LLVM is available.])
   else
     build_jit=no
     LLVM_CPPFLAGS=
     LLVM_CXXFLAGS=
@@ -858,17 +891,22 @@ AC_SUBST(FFT_DIR)
 ### Check for GLPK library and header.
 
 save_CPPFLAGS="$CPPFLAGS"
 save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIB(glpk, GLPK,
   [GLPK library not found.  The glpk function for solving linear programs will be disabled.],
-  [glpk/glpk.h glpk.h], [_glp_lpx_simplex])
+  [glpk/glpk.h glpk.h], [glp_simplex], [], [],
+  [warn_glpk=
+   OCTAVE_CHECK_LIB_GLPK_OK(
+    [TEXINFO_GLPK="@set HAVE_GLPK"
+    AC_DEFINE(HAVE_GLPK, 1, [Define to 1 if GLPK is available.])],
+    [warn_glpk="GLPK library found, but does not seem to work properly -- disabling glpk function"])])
 LIBS="$save_LIBS"
 CPPFLAGS="$save_CPPFLAGS"
 
 ### Checks for cURL header and library.
 
 save_CPPFLAGS="$CPPFLAGS"
 save_LIBS="$LIBS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
@@ -1036,16 +1074,20 @@ if test -n "$OPENGL_LIBS"; then
     min_ft2_version=9.03
     AC_MSG_CHECKING([for FreeType -- version >= $min_ft2_version])
     $PKG_CONFIG freetype2 --atleast-version=$min_ft2_version
     ac_status=$?
     if test $ac_status = 0; then
       AC_MSG_RESULT(yes)
       AC_DEFINE(HAVE_FREETYPE, 1, [Define to 1 if you have Freetype library.])
       XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FT2_CFLAGS"
+      save_LIBS="$LIBS"
+      LIBS="$FT2_LIBS $LIBS"
+      AC_CHECK_FUNCS([FT_Reference_Face])
+      LIBS="$save_LIBS"
     else
       AC_MSG_RESULT(no)
       warn_freetype="FreeType library not found.  Native graphics will be disabled."
     fi])
 
   if test -n "$warn_freetype"; then
     OCTAVE_CONFIGURE_WARNING([warn_freetype])
     native_graphics=no
@@ -1923,17 +1965,17 @@ AC_HEADER_DIRENT
 AC_HEADER_SYS_WAIT
 
 ## C headers
 
 dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
 AC_CHECK_HEADERS([curses.h direct.h dlfcn.h floatingpoint.h fpu_control.h])
 AC_CHECK_HEADERS([grp.h ieeefp.h inttypes.h locale.h memory.h ncurses.h])
 AC_CHECK_HEADERS([poll.h pthread.h pwd.h sunmath.h sys/ioctl.h])
-AC_CHECK_HEADERS([sys/param.h sys/poll.h sys/resource.h ])
+AC_CHECK_HEADERS([sys/param.h sys/poll.h sys/resource.h])
 AC_CHECK_HEADERS([sys/select.h sys/utsname.h termcap.h])
 
 ## C++ headers
 
 AC_LANG_PUSH(C++)
 
 AC_CHECK_HEADERS([sstream])
 OCTAVE_UNORDERED_MAP_HEADERS
@@ -2035,17 +2077,17 @@ AM_PROG_CC_C_O
 
 gl_INIT
 
 ### Checks for functions and variables.
 
 dnl These checks define/undefine HAVE_FUNCNAME in config.h.
 dnl Code tests HAVE_FUNCNAME and either uses function or provides workaround.
 dnl Use multiple AC_CHECKs to avoid line continuations '\' in list
-AC_CHECK_FUNCS([canonicalize_file_name dup2])
+AC_CHECK_FUNCS([canonicalize_file_name ctermid dup2])
 AC_CHECK_FUNCS([endgrent endpwent execvp expm1 expm1f fork])
 AC_CHECK_FUNCS([getegid geteuid getgid getgrent getgrgid getgrnam])
 AC_CHECK_FUNCS([getpgrp getpid getppid getpwent getpwuid getuid])
 AC_CHECK_FUNCS([isascii kill])
 AC_CHECK_FUNCS([lgamma lgammaf lgamma_r lgammaf_r])
 AC_CHECK_FUNCS([log1p log1pf pipe])
 AC_CHECK_FUNCS([realpath resolvepath roundl])
 AC_CHECK_FUNCS([select setgrent setpwent siglongjmp strsignal])
@@ -2522,16 +2564,17 @@ do
     ;;
     mingw* | cygwin*)
       if test -n "$JAVA_CPPFLAGS"; then
         JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/win32"
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/win32"
       fi
       JAVA_LIBS=-ladvapi32
+      LDFLAGS="$LDFLAGS -Wl,--export-all-symbols"
     ;;
     *)
       if test -n "$JAVA_CPPFLAGS"; then
         JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/linux"
       else
         JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux"
       fi
     ;;
@@ -2596,28 +2639,36 @@ if test $build_gui = yes; then
       AC_MSG_WARN([Qt >= 4.0.0 not found -- disabling GUI])
       build_gui=no
     fi
   fi
 
   if test $build_gui = yes; then
     AC_CHECK_TOOLS(MOC, [moc-qt5 moc-qt4 moc])
     AC_CHECK_TOOLS(UIC, [uic-qt5 uic-qt4 uic])
-    AC_CHECK_TOOLS(RCC, [rcc])
+    AC_CHECK_TOOLS(RCC, [rcc-qt5 rcc-qt4 rcc])
     AC_CHECK_TOOLS(LRELEASE, [lrelease-qt5 lrelease-qt4 lrelease])
     if test -n "$MOC" && test -n "$UIC" && test -n "$RCC" && test -n "$LRELEASE"; then
       AC_DEFINE(HAVE_QT, 1, 
         [Define to 1 if Qt is available (libraries, developer header files, utility programs (moc, uic, rcc, and lrelease))])
     else
       AC_MSG_WARN([Qt utility programs moc, uic, rcc, and lrelease not found -- disabling GUI])
       build_gui=no
     fi
   fi
 
   if test $build_gui = yes; then
+    OCTAVE_CHECK_FUNC_QABSTRACTITEMMODEL_BEGINRESETMODEL
+    if test $octave_cv_func_qabstractitemmodel_beginresetmodel = no; then
+      AC_MSG_WARN([QAbstractItemModel::beginResetModel() not found -- disabling GUI])
+      build_gui=no
+    fi
+  fi
+
+  if test $build_gui = yes; then
     OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT
   fi
 
   if test $build_gui = yes; then
     ## Check for Qscintilla library which is used in the GUI editor. 
     AC_CACHE_CHECK([whether Qscintilla library is installed],
       [octave_cv_lib_qscintilla],
       [save_CPPFLAGS="$CPPFLAGS"
@@ -2707,16 +2758,17 @@ AC_OUTPUT_MAKE_DEFS
 AC_SUBST(ac_config_files)
 AC_SUBST(ac_config_headers)
 
 AC_CONFIG_FILES([
   oct-conf-post.h:oct-conf-post.in.h
   Makefile 
   doc/Makefile
   doc/doxyhtml/Makefile
+  doc/doxyhtml/Doxyfile
   doc/icons/Makefile
   doc/interpreter/Makefile
   doc/liboctave/Makefile
   doc/refcard/Makefile
   examples/Makefile
   libgnu/Makefile
   libgui/Makefile
   libinterp/Makefile
diff --git a/doc/doxyhtml/Doxyfile.in b/doc/doxyhtml/Doxyfile.in
new file mode 100644
--- /dev/null
+++ b/doc/doxyhtml/Doxyfile.in
@@ -0,0 +1,317 @@
+# -*- mode: conf; -*-
+
+# Doxyfile for Doxygen 1.7.1
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for GNU Octave.
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the
+# config file that follow. We don't use anything but ASCII, but
+# there's no problem using UTF-8 from now on
+
+DOXYFILE_ENCODING      = UTF-8
+
+# Who we are. :-)
+
+PROJECT_NAME           = "GNU Octave"
+
+PROJECT_BRIEF          =  "A high-level interpreted language, primarily intended for numerical computations, mostly compatible with Matlab"
+
+# The public stable API version (unrelated to the internal API
+# version).
+
+PROJECT_NUMBER         = @PACKAGE_VERSION@
+
+# Our logo!
+
+PROJECT_LOGO           = @top_srcdir@/doc/icons/octave-logo.png
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
+# base path where the generated documentation will be put.
+
+OUTPUT_DIRECTORY       = @abs_top_builddir@/doc
+
+# Create 4096 sub-directories (in 2 levels) under the output directory
+# of each output format and will distribute the generated files over
+# these directories. Enabling this option is useful for us, since
+# feeding doxygen a huge amount of source files would put all
+# generated files in the same directory would otherwise cause
+# performance problems for the file system.
+
+CREATE_SUBDIRS         = YES
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written.
+
+OUTPUT_LANGUAGE        = English
+
+# Include brief member descriptions after the members that are listed
+# in the file and class documentation (similar to JavaDoc). Set to NO
+# to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# Prepend the brief description of a member or function before the
+# detailed description. Note: if both HIDE_UNDOC_MEMBERS and
+# BRIEF_MEMBER_DESC are set to NO, the brief descriptions will be
+# completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# Doxygen will generate a detailed section even if there is only a brief
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# Show inherited members as if they were part of the current class
+
+INLINE_INHERITED_MEMB  = YES
+
+# Prepend the full path before files name in the file list and in the
+# header files.
+
+FULL_PATH_NAMES        = YES
+
+# Remove from the full path names the absolute prefix
+
+STRIP_FROM_PATH        = @top_srcdir@
+
+# Interpret the first line (until the first dot) of a JavaDoc-style
+# comment as the brief description (without needing the @brief
+# command).
+
+JAVADOC_AUTOBRIEF      = YES
+
+# Interpret the first line (until the first dot) of a Qt-style comment
+# as the brief descriptio (without needing the \brief command).
+
+QT_AUTOBRIEF           = NO
+
+# Undocumented member inherits the documentation from any documented
+# member that it re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
+# a new page for each member. If set to NO, the documentation of a member will
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+# We shouldn't have any tabs in the source code to begin with, however.
+
+TAB_SIZE               = 2
+
+# Figure out C++ stdlib classes without needing to parse those files.
+
+BUILTIN_STL_SUPPORT    = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# Assume all entities in documentation are documented, even if no
+# documentation was available.
+
+EXTRACT_ALL            = YES
+
+# Include all private members of a class.
+
+EXTRACT_PRIVATE        = YES
+
+# Include  all static members of a file.
+
+EXTRACT_STATIC         = YES
+
+# Include classes (and structs) defined locally in source files in the
+# documentation.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# We have very few namespaces, so show the ones we have
+
+SHOW_NAMESPACES        = YES
+
+# We don't use namespaces, but if we did, this would extract the
+# anonymous one.
+
+EXTRACT_ANON_NSPACES   = YES
+
+# Hide internal docs, those with the \internal command.
+
+INTERNAL_DOCS          = NO
+
+# Case-sensitive filenames
+
+CASE_SENSE_NAMES       = YES
+
+# List include files with double quotes in the documentation rather
+# than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = YES
+
+# Show members alphabetically
+
+SORT_MEMBER_DOCS       = YES
+
+# Also sort the brief descriptions
+
+SORT_BRIEF_DOCS        = YES
+
+# Put ctors first.
+
+SORT_MEMBERS_CTORS_1ST = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# On by default, but let's be explicit
+
+ENABLE_PREPROCESSING   = YES
+
+# Expand all macros
+
+MACRO_EXPANSION = YES
+EXPAND_ONLY_PREDEF = NO
+
+# So that features that are behind #ifdef HAVE_FOO macros get processed by Doxygen
+
+PREDEFINED = HAVE_ARPACK=1          \
+             HAVE_CHOLMOD=1         \
+             HAVE_CCOLAMD=1         \
+             HAVE_CURL=1            \
+             HAVE_CXSPARSE=1        \
+             HAVE_FFTW=1            \
+             HAVE_FFTW3=1           \
+             HAVE_FFTW3F=1          \
+             HAVE_FFTW3F_THREADS=1  \
+             HAVE_FFTW3_THREADS=1   \
+             HAVE_FREETYPE=1        \
+             HAVE_GLPK=1            \
+             HAVE_HDF5=1            \
+             HAVE_LLVM=1            \
+             HAVE_MAGICK=1          \
+             HAVE_OPENMP=1          \
+             HAVE_PCRE_H=1          \
+             HAVE_PCRE_COMPILE=1    \
+             HAVE_QHULL=1           \
+             HAVE_QRUPDATE=1        \
+             HAVE_QRUPDATE_LUU=1    \
+             HAVE_QT=1              \
+             HAVE_UMFPACK=1         \
+             HAVE_X_WINDOWS=1       \
+             HAVE_ZLIB=1
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# Which directories contain Octave source code
+
+INPUT                  = @top_srcdir@/src/ @top_srcdir@/liboctave/
+INPUT                 += @top_srcdir@/libinterp @top_srcdir@/libgui
+
+# Search subdirectories for input.
+
+RECURSIVE              = YES
+
+# Our examples.
+
+EXAMPLE_PATH           = @top_srcdir@/examples/
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank all files are included.
+
+EXAMPLE_PATTERNS       =
+
+# There are no extra C++ files in the examples subdir
+
+EXAMPLE_RECURSIVE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# Generate a list of source files will be generated.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Don't hide the special Doxygen comment blocks
+
+STRIP_CODE_COMMENTS    = NO
+
+# For each documented function, list all documented functions
+# referencing it.
+
+REFERENCED_BY_RELATION = YES
+
+# For each documented function all documented entities called/used by
+# that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# References link to documentation, not source code.
+
+REFERENCES_LINK_SOURCE = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# Generate HTML
+
+GENERATE_HTML          = YES
+
+# i.e. @abs_top_builddir@/doc/doxyhtml
+
+HTML_OUTPUT            = doxyhtml
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# No LaTeX
+
+GENERATE_LATEX         = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# Show undocumented relations
+
+HIDE_UNDOC_RELATIONS   = NO
+
+# Use dot from graphviz to generate class diagrams.
+
+HAVE_DOT               = YES
+
+# Remove intermediate dot files.
+
+DOT_CLEANUP            = YES
+
+# Some of our dependency graphs are really huge...
+
+DOT_GRAPH_MAX_NODES    = 100
\ No newline at end of file
diff --git a/doc/doxyhtml/Doxygen.cfg b/doc/doxyhtml/Doxygen.cfg
deleted file mode 100644
--- a/doc/doxyhtml/Doxygen.cfg
+++ /dev/null
@@ -1,267 +0,0 @@
-# -*- mode: conf; -*-
-
-# Doxyfile for Doxygen 1.7.1
-
-# This file describes the settings to be used by the documentation system
-# doxygen (www.doxygen.org) for GNU Octave.
-#
-# All text after a hash (#) is considered a comment and will be ignored
-# The format is:
-#       TAG = value [value, ...]
-# For lists items can also be appended using:
-#       TAG += value [value, ...]
-# Values that contain spaces should be placed between quotes (" ")
-
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-
-# This tag specifies the encoding used for all characters in the
-# config file that follow. We don't use anything but ASCII, but
-# there's no problem using UTF-8 from now on
-
-DOXYFILE_ENCODING      = UTF-8
-
-# Who we are. :-)
-
-PROJECT_NAME           = "GNU Octave"
-
-# The public stable API version (unrelated to the internal API
-# version).
-
-PROJECT_NUMBER         = 3.7
-
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
-# base path where the generated documentation will be put.
-
-OUTPUT_DIRECTORY       = doc/
-
-# Create 4096 sub-directories (in 2 levels) under the output directory
-# of each output format and will distribute the generated files over
-# these directories. Enabling this option is useful for us, since
-# feeding doxygen a huge amount of source files would put all
-# generated files in the same directory would otherwise cause
-# performance problems for the file system.
-
-CREATE_SUBDIRS         = YES
-
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all
-# documentation generated by doxygen is written.
-
-OUTPUT_LANGUAGE        = English
-
-# Include brief member descriptions after the members that are listed
-# in the file and class documentation (similar to JavaDoc). Set to NO
-# to disable this.
-
-BRIEF_MEMBER_DESC      = YES
-
-# Prepend the brief description of a member or function before the
-# detailed description. Note: if both HIDE_UNDOC_MEMBERS and
-# BRIEF_MEMBER_DESC are set to NO, the brief descriptions will be
-# completely suppressed.
-
-REPEAT_BRIEF           = YES
-
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
-# Doxygen will generate a detailed section even if there is only a brief
-# description.
-
-ALWAYS_DETAILED_SEC    = NO
-
-# Show inherited members as if they were part of the current class
-
-INLINE_INHERITED_MEMB  = YES
-
-# Prepend the full path before files name in the file list and in the
-# header files.
-
-FULL_PATH_NAMES        = YES
-
-# Interpret the first line (until the first dot) of a JavaDoc-style
-# comment as the brief description (without needing the @brief
-# command).
-
-JAVADOC_AUTOBRIEF      = YES
-
-# Interpret the first line (until the first dot) of a Qt-style comment
-# as the brief descriptio (without needing the \brief command).
-
-QT_AUTOBRIEF           = NO
-
-# Undocumented member inherits the documentation from any documented
-# member that it re-implements.
-
-INHERIT_DOCS           = YES
-
-# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
-# a new page for each member. If set to NO, the documentation of a member will
-# be part of the file/class/namespace that contains it.
-
-SEPARATE_MEMBER_PAGES  = NO
-
-# The TAB_SIZE tag can be used to set the number of spaces in a tab.
-# Doxygen uses this value to replace tabs by spaces in code fragments.
-# We shouldn't have any tabs in the source code to begin with, however.
-
-TAB_SIZE               = 2
-
-# Figure out C++ stdlib classes without needing to parse those files.
-
-BUILTIN_STL_SUPPORT    = YES
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-
-# Assume all entities in documentation are documented, even if no
-# documentation was available.
-
-EXTRACT_ALL            = YES
-
-# Include all private members of a class.
-
-EXTRACT_PRIVATE        = YES
-
-# Include  all static members of a file.
-
-EXTRACT_STATIC         = YES
-
-# Include classes (and structs) defined locally in source files in the
-# documentation.
-
-EXTRACT_LOCAL_CLASSES  = YES
-
-# We don't use namespaces, but if we did, this would extract the
-# anonymous one.
-
-EXTRACT_ANON_NSPACES   = YES
-
-# Hide internal docs, those with the \internal command.
-
-INTERNAL_DOCS          = NO
-
-# Case-sensitive filenames
-
-CASE_SENSE_NAMES       = YES
-
-# List include files with double quotes in the documentation rather
-# than with sharp brackets.
-
-FORCE_LOCAL_INCLUDES   = YES
-
-# Show members alphabetically
-
-SORT_MEMBER_DOCS       = YES
-
-# Also sort the brief descriptions
-
-SORT_BRIEF_DOCS        = YES
-
-# Put ctors first.
-
-SORT_MEMBERS_CTORS_1ST = YES
-
-# Show which directories the file is in.
-
-SHOW_DIRECTORIES       = YES
-
-# We don't have namespaces, so don't show them.
-
-SHOW_NAMESPACES        = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-
-# Which directories contain Octave source code
-
-INPUT                  = src/ liboctave/ libinterp/
-
-# Search subdirectories for input.
-
-RECURSIVE              = YES
-
-# Our examples.
-
-EXAMPLE_PATH           = examples/
-
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank all files are included.
-
-EXAMPLE_PATTERNS       =
-
-# There are no extra C++ files in the examples subdir
-
-EXAMPLE_RECURSIVE      = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-
-# Generate a list of source files will be generated.
-
-SOURCE_BROWSER         = YES
-
-# Setting the INLINE_SOURCES tag to YES will include the body
-# of functions and classes directly in the documentation.
-
-INLINE_SOURCES         = NO
-
-# Hide any special comment blocks from generated source code
-# fragments. Normal C and C++ comments will always remain visible.
-
-STRIP_CODE_COMMENTS    = YES
-
-# For each documented function, list all documented functions
-# referencing it.
-
-REFERENCED_BY_RELATION = YES
-
-# For each documented function all documented entities called/used by
-# that function will be listed.
-
-REFERENCES_RELATION    = YES
-
-# References link to documenation, not source code.
-
-REFERENCES_LINK_SOURCE = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-
-# Generate HTML
-
-GENERATE_HTML          = YES
-
-# i.e. doc/doxyhtml
-
-HTML_OUTPUT            = doxyhtml
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-
-# No LaTeX
-
-GENERATE_LATEX         = NO
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-
-# Show undocumented relations
-
-HIDE_UNDOC_RELATIONS   = NO
-
-# Use dot from graphviz to generate class diagrams.
-
-HAVE_DOT               = YES
-
-# Remove intermediate dot files.
-
-DOT_CLEANUP            = YES
-
diff --git a/doc/doxyhtml/Makefile.am b/doc/doxyhtml/Makefile.am
--- a/doc/doxyhtml/Makefile.am
+++ b/doc/doxyhtml/Makefile.am
@@ -16,17 +16,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 doxyhtml:
-	cd ../..; doxygen doc/doxyhtml/Doxygen.cfg 
+	doxygen Doxyfile
 
 EXTRA_DIST = \
-  Doxygen.cfg \
+  Doxyfile.in \
   Makefile.am \
   README
 
 maintainer-clean-local:
-	rm -rf `ls | $(GREP) -v Doxygen.cfg | $(GREP) -v Makefile.am | $(GREP) -v Makefile.in | $(GREP) -v README`
+	rm -rf `ls | $(GREP) -v Doxyfile | $(GREP) -v Makefile.am | $(GREP) -v Makefile.in | $(GREP) -v README`
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -25,17 +25,17 @@ TEXINFO_TEX = ../texinfo.tex
 ## Leading PATH_SEPARATOR required due to weak parsing by dvips (12/04/09)
 TEXINPUTS := "$(PATH_SEPARATOR)$(srcdir)$(PATH_SEPARATOR)$(TEXINPUTS)$(PATH_SEPARATOR)"
 export TEXINPUTS
 
 ## Include custom texmf.cnf necessary to run @seealso macro 
 TEXMFCNF := "..$(PATH_SEPARATOR)$(srcdir)/..$(PATH_SEPARATOR)$(TEXMFCNF)$(PATH_SEPARATOR)"
 export TEXMFCNF
 
-dist_man1_MANS = \
+dist_man_MANS = \
   mkoctfile.1 \
   octave-config.1 \
   octave.1
 
 ## The following files are included in the manual via the @EXAMPLEFILE macro.
 ## They are dependencies for the documentation.
 ## They must not be distributed from this directory.
 EXAMPLE_FILES = \
@@ -220,29 +220,29 @@ contributors.texi: contributors.in
 	mv $@-t $@
 
 ../../AUTHORS: preface.texi contributors.texi
 	rm -f AUTHORS
 	if [ "x$(srcdir)" != "x." ] && [ -f $(srcdir)/contributors.texi ] && [ ! -f contributors.texi ]; then \
 		cp $(srcdir)/contributors.texi contributors.texi; \
 		touch -r $(srcdir)/contributors.texi contributors.texi; \
 	fi
-	-$(MAKEINFO) -D AUTHORSONLY \
+	-$(MAKEINFO) -D AUTHORSONLY -I $(srcdir) \
 	  --no-validate --no-headers --no-split --output AUTHORS $<
 	mv AUTHORS ../../AUTHORS
 
 ../../BUGS: bugs.texi
 	rm -f BUGS
-	-$(MAKEINFO) -D BUGSONLY \
+	-$(MAKEINFO) -D BUGSONLY -I $(srcdir) \
 	  --no-validate --no-headers --no-split --output BUGS $<
 	mv BUGS ../../BUGS
 
 ../../INSTALL.OCTAVE: install.texi
 	rm -f INSTALL
-	-$(MAKEINFO) -D INSTALLONLY \
+	-$(MAKEINFO) -D INSTALLONLY -I $(srcdir) \
 	  --no-validate --no-headers --no-split --output INSTALL $<
 	mv INSTALL ../../INSTALL.OCTAVE
 
 
 undocumented_list:
 	rm -f $@
 	-$(PERL) $(srcdir)/doccheck/mk_undocumented_list > $@
 .PHONY: undocumented_list
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -29,24 +29,24 @@ each element when given a matrix argumen
 sin ([1, 2; 3, 4])
      @result{}  0.84147   0.90930
          0.14112  -0.75680
 @end group
 @end example
 
 @menu
 * Exponents and Logarithms::
-* Complex Arithmetic::          
-* Trigonometry::                
-* Sums and Products::           
-* Utility Functions::           
-* Special Functions::           
+* Complex Arithmetic::
+* Trigonometry::
+* Sums and Products::
+* Utility Functions::
+* Special Functions::
 * Rational Approximations::
 * Coordinate Transformations::
-* Mathematical Constants::      
+* Mathematical Constants::
 @end menu
 
 @node Exponents and Logarithms
 @section Exponents and Logarithms
 
 @DOCSTRING(exp)
 
 @DOCSTRING(expm1)
@@ -185,16 +185,17 @@ cos (pi/2)
 @DOCSTRING(tand)
 @DOCSTRING(secd)
 @DOCSTRING(cscd)
 @DOCSTRING(cotd)
 
 @DOCSTRING(asind)
 @DOCSTRING(acosd)
 @DOCSTRING(atand)
+@DOCSTRING(atan2d)
 @DOCSTRING(asecd)
 @DOCSTRING(acscd)
 @DOCSTRING(acotd)
 
 @node Sums and Products
 @section Sums and Products
 
 @DOCSTRING(sum)
@@ -306,17 +307,17 @@ cos (pi/2)
 @DOCSTRING(expint)
 
 @DOCSTRING(gamma)
 
 @DOCSTRING(gammainc)
 
 @DOCSTRING(legendre)
 
-@anchor{docXgammaln}
+@anchor{XREFgammaln}
 @DOCSTRING(lgamma)
 
 @node Rational Approximations
 @section Rational Approximations
 
 @DOCSTRING(rat)
 
 @DOCSTRING(rats)
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -20,23 +20,23 @@
 @chapter Getting Started
 
 This chapter explains some of Octave's basic features, including how to
 start an Octave session, get help at the command prompt, edit the
 command line, and write Octave programs that can be executed as commands
 from your shell.
 
 @menu
-* Invoking Octave from the Command Line::             
-* Quitting Octave::             
-* Getting Help::                
-* Command Line Editing::        
-* Errors::                      
-* Executable Octave Programs::  
-* Comments::                    
+* Invoking Octave from the Command Line::
+* Quitting Octave::
+* Getting Help::
+* Command Line Editing::
+* Errors::
+* Executable Octave Programs::
+* Comments::
 @end menu
 
 @node Invoking Octave from the Command Line
 @section Invoking Octave from the Command Line
 
 Normally, Octave is used interactively by running the program
 @samp{octave} without any arguments.  Once started, Octave reads
 commands from the terminal until you tell it to exit.
@@ -47,18 +47,18 @@ when it is finished.
 
 You can further control how Octave starts by using the command-line
 options described in the next section, and Octave itself can remind you
 of the options available.  Type @samp{octave --help} to display all
 available options and briefly describe their use (@samp{octave -h} is a
 shorter equivalent).
 
 @menu
-* Command Line Options::        
-* Startup Files::               
+* Command Line Options::
+* Startup Files::
 @end menu
 
 @node Command Line Options
 @subsection Command Line Options
 @cindex Octave command options
 @cindex command options
 @cindex options, Octave command
 
@@ -149,17 +149,17 @@ commands in the system or user startup f
 @code{info_program} function.
 
 @item  --interactive
 @itemx -i
 @cindex @code{--interactive}
 @cindex @code{-i}
 Force interactive behavior.  This can be useful for running Octave via a
 remote shell command or inside an Emacs shell buffer.  For another way
-to run Octave within Emacs, see @ref{Emacs Octave Support}.
+to run Octave within Emacs, @pxref{Emacs Octave Support}.
 
 @item --line-editing
 @cindex @code{--line-editing}
 Force readline use for command-line editing.
 
 @item --no-gui
 @cindex @code{--no-gui}
 Disable the graphical user interface (GUI) and use the command line
@@ -267,18 +267,18 @@ Octave:fopen-file-in-path
 Octave:function-name-clash
 Octave:load-file-in-path
 @end group
 @end example
 
 @noindent
 Note that this does not enable the @code{Octave:matlab-incompatible}
 warning, which you might want if you want to be told about writing code
-that works in Octave but not @sc{matlab} (@pxref{docXwarning},
-@pxref{docXwarning_ids}).
+that works in Octave but not @sc{matlab} (@pxref{XREFwarning,,warning},
+@ref{XREFwarning_ids,,warning_ids}).
 
 @item  --verbose
 @itemx -V
 @cindex @code{--verbose}
 @cindex @code{-V}
 Turn on verbose output.
 
 @item  --version
@@ -479,24 +479,24 @@ even @key{WINDOWS}.  If your terminal do
 can still type Meta characters using two-character sequences starting
 with @kbd{ESC}.  Thus, to enter @kbd{M-u}, you would type
 @key{ESC} @key{u}.  The @kbd{ESC} character sequences are also allowed on
 terminals with real Meta keys.  In the following sections, Meta
 characters such as @kbd{Meta-u} are written as @kbd{M-u}.
 
 
 @menu
-* Cursor Motion::               
-* Killing and Yanking::         
-* Commands For Text::           
-* Commands For Completion::     
-* Commands For History::        
-* Customizing readline::        
-* Customizing the Prompt::      
-* Diary and Echo Commands::     
+* Cursor Motion::
+* Killing and Yanking::
+* Commands For Text::
+* Commands For Completion::
+* Commands For History::
+* Customizing readline::
+* Customizing the Prompt::
+* Diary and Echo Commands::
 @end menu
 
 @node Cursor Motion
 @subsection Cursor Motion
 
 The following commands allow you to position the cursor.
 
 @table @kbd
@@ -525,17 +525,17 @@ Move backward a word.
 Move to the start of the line.
 
 @item C-e
 Move to the end of the line.
 
 @item C-l
 Clear the screen, reprinting the current line at the top.
 
-@item C-_
+@item  C-_
 @itemx C-/
 Undo the last action.  You can undo all the way back to an empty line.
 
 @item M-r
 Undo all changes made to this line.  This is like typing the `undo'
 command enough times to get back to the beginning.
 @end table
 
@@ -605,17 +605,17 @@ another line.
 @node Commands For Text
 @subsection Commands For Changing Text
 
 The following commands can be used for entering characters that would
 otherwise have a special meaning (e.g., @key{TAB}, @kbd{C-q}, etc.), or
 for quickly correcting typing mistakes.
 
 @table @kbd
-@item C-q
+@item  C-q
 @itemx C-v
 Add the next character that you type to the line verbatim.  This is
 how to insert things like @kbd{C-q} for example.
 
 @item M-@key{TAB}
 Insert a tab character.
 
 @item C-t
@@ -673,17 +673,17 @@ Octave, the most recent commands you hav
 specified by the variable @code{history_size}, are saved in a file.
 When Octave starts, it loads an initial list of commands from the file
 named by the variable @code{history_file}.
 
 Here are the commands for simple browsing and searching the history
 list.
 
 @table @kbd
-@item @key{LFD}
+@item  @key{LFD}
 @itemx @key{RET}
 Accept the current line regardless of where the cursor is.  If the line is
 non-empty, add it to the history list.  If the line was a history
 line, then restore the history line to its original state.
 
 @item C-p
 Move `up' through the history list.
 
@@ -1042,17 +1042,17 @@ A @dfn{comment} is some text that is inc
 of human readers, and which is NOT an executable part of the program.  
 Comments can explain what the program does, and how it works.  Nearly all
 programming languages have provisions for comments, because programs are
 typically hard to understand without them.
 
 @menu
 * Single Line Comments::
 * Block Comments::
-* Comments and the Help System::                    
+* Comments and the Help System::
 @end menu
 
 @node Single Line Comments
 @subsection Single Line Comments
 @cindex @samp{#}
 @cindex @samp{%}
 
 In the Octave language, a comment starts with either the sharp sign
@@ -1094,18 +1094,18 @@ function quick_countdown
   disp (1);
  #@}
   disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @noindent
-will produce a very quick countdown from '3' to 'Blast Off' as the
-lines "@code{disp (2);}" and "@code{disp (1);}" won't be executed.
+will produce a very quick countdown from @qcode{'3'} to @qcode{"Blast Off"} as
+the lines "@code{disp (2);}" and "@code{disp (1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
 (excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
diff --git a/doc/interpreter/bugs.txi b/doc/interpreter/bugs.txi
--- a/doc/interpreter/bugs.txi
+++ b/doc/interpreter/bugs.txi
@@ -47,18 +47,18 @@ of these are not Octave bugs per se---if
 But the result for a user may be like the result of a bug.
 
 Some of these problems are due to bugs in other software, some are
 missing features that are too much work to add, and some are places
 where people's opinions differ as to what is best.
 
 @menu
 * Actual Bugs::                 Bugs we will fix later.
-* Reporting Bugs::              
-* Service::                     
+* Reporting Bugs::
+* Service::
 @end menu
 
 @node Actual Bugs
 @appendixsec Actual Bugs We Haven't Fixed Yet
 
 @itemize @bullet
 @item
 Output that comes directly from Fortran functions is not sent through
@@ -100,17 +100,17 @@ Reporting a bug may help you by bringing
 it may not.  In any case, the principal function of a bug report is
 to help the entire community by making the next version of Octave work
 better.  Bug reports are your contribution to the maintenance of Octave.
 
 In order for a bug report to serve its purpose, you must include the
 information that makes it possible to fix the bug.
 
 @menu
-* Bug Criteria::                
+* Bug Criteria::
 * Bug Tracker::        Where to submit your bug report.
 * Bug Reporting::      How to report a bug effectively.
 * Sending Patches::    How to send a patch for Octave.
 @end menu
 
 @node Bug Criteria
 @appendixsubsec Have You Found a Bug?
 @cindex bug criteria
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -367,19 +367,19 @@ in.call1
        ans = last
 @end group
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 @cindex dynamic naming
 
-Besides the index operator ".", Octave can use dynamic naming "(var)" or the
-@code{struct} function to create structures.  Dynamic naming uses the string
-value of a variable as the field name.  For example:
+Besides the index operator @qcode{"."}, Octave can use dynamic naming
+@qcode{"(var)"} or the @code{struct} function to create structures.  Dynamic
+naming uses the string value of a variable as the field name.  For example:
 
 @example
 @group
 a = "field2";
 x.a = 1;
 x.(a) = 2;
 x
      @result{} x =
@@ -405,17 +405,17 @@ x
           a =  1
           long field with spaces (and funny char$) =  2
         @}
 @end group
 @end example
 
 @noindent
 The warning id @code{Octave:matlab-incompatible} can be enabled to warn
-about this usage.  @xref{docXwarning_ids}.
+about this usage.  @xref{XREFwarning_ids,,warning_ids}.
 
 More realistically, all of the functions that operate on strings can be used
 to build the correct field name before it is entered into the data structure.
 
 @example
 @group
 names = ["Bill"; "Mary"; "John"];
 ages  = [37; 26; 31];
@@ -479,22 +479,22 @@ individual field, you must wrap it in an
 the following example:
 
 @example
 @group
 struct ("field1", @{@{1, "one"@}@}, "field2", 2)
      @result{} ans =
         @{
           field1 =
-        
+
         @{
           [1,1] =  1
           [1,2] = one
         @}
-        
+
           field2 =  2
         @}
 @end group
 @end example
 
 @DOCSTRING(struct)
 
 The function @code{isstruct} can be used to test if an object is a
@@ -524,17 +524,18 @@ Other functions that can manipulate the 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
 @subsection Processing Data in Structures
 
 The simplest way to process data in a structure is within a @code{for}
 loop (@pxref{Looping Over Structure Elements}).  A similar effect can be
 achieved with the @code{structfun} function, where a user defined
-function is applied to each field of the structure.  @xref{docXstructfun}.
+function is applied to each field of the structure.
+@xref{XREFstructfun,,structfun}.
 
 Alternatively, to process the data in a structure, the structure might
 be converted to another type of container before being treated.
 
 @DOCSTRING(struct2cell)
 
 @node Cell Arrays
 @section Cell Arrays
@@ -581,38 +582,38 @@ c@{1@}
 As with numerical arrays several elements of a cell array can be
 extracted by indexing with a vector of indexes
 
 @example
 @group
 c@{1:2@}
      @result{} ans = a string
      @result{} ans =
-          
+
                0.593993   0.627732
                0.377037   0.033643
 @end group
 @end example
 
 The indexing operators can also be used to insert or overwrite elements
 of a cell array.  The following code inserts the scalar 3 on the
 third place of the previously created cell array
 
 @example
 @group
 c@{3@} = 3
      @result{} c =
-         
+
          @{
            [1,1] = a string
            [1,2] =
-         
+
               0.593993   0.627732
               0.377037   0.033643
-         
+
            [1,3] =  3
          @}
 @end group
 @end example
 
 Details on indexing cell arrays are explained in @ref{Indexing Cell Arrays}.
 
 In general nested cell arrays are displayed hierarchically as in the
@@ -634,33 +635,33 @@ iscell (3)
      @result{} ans = 0
 
 @end group
 @end example
 
 @DOCSTRING(iscell)
 
 @node Creating Cell Arrays
-@subsection Creating Cell Array
+@subsection Creating Cell Arrays
 
 The introductory example (@pxref{Basic Usage of Cell Arrays}) showed
 how to create a cell array containing currently available variables.
 In many situations, however, it is useful to create a cell array and
 then fill it with data. 
 
 The @code{cell} function returns a cell array of a given size, containing
 empty matrices.  This function is similar to the @code{zeros}
 function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
 c = cell (2,2)
      @result{} c =
-         
+
          @{
            [1,1] = [](0x0)
            [2,1] = [](0x0)
            [1,2] = [](0x0)
            [2,2] = [](0x0)
          @}
 @end group
 @end example
@@ -678,21 +679,20 @@ c1 = cell (3, 4, 5);
 c2 = cell ( [3, 4, 5] );
 size (c1)
      @result{} ans =
          3   4   5
 @end group
 @end example
 
 @noindent
-As can be seen, the @ref{docXsize, @code{size}} function also works
+As can be seen, the @ref{XREFsize,,size} function also works
 for cell arrays.  As do other functions describing the size of an
-object, such as @ref{docXlength, @code{length}}, @ref{docXnumel,
-@code{numel}}, @ref{docXrows, @code{rows}}, and @ref{docXcolumns,
-@code{columns}}.
+object, such as @ref{XREFlength,,length}, @ref{XREFnumel,, numel},
+@ref{XREFrows,,rows}, and @ref{XREFcolumns,,columns}.
 
 @DOCSTRING(cell)
 
 As an alternative to creating empty cell arrays, and then filling them, it
 is possible to convert numerical arrays into cell arrays using the
 @code{num2cell}, @code{mat2cell} and @code{cellslices} functions.
 
 @DOCSTRING(num2cell)
@@ -902,17 +902,17 @@ cell array of strings.
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
 
 Data that is stored in a cell array can be processed in several ways
 depending on the actual data.  The simplest way to process that data
 is to iterate through it using one or more @code{for} loops.  The same
 idea can be implemented more easily through the use of the @code{cellfun}
 function that calls a user-specified function on all elements of a cell
-array.  @xref{docXcellfun}.
+array.  @xref{XREFcellfun,,cellfun}.
 
 An alternative is to convert the data to a different container, such as
 a matrix or a data structure.  Depending on the data this is possible
 using the @code{cell2mat} and @code{cell2struct} functions.
 
 @DOCSTRING(cell2mat)
 
 @DOCSTRING(cell2struct)
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -350,17 +350,17 @@ static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
                   int num_pat, const std::string& name)
 @end group
 @end example
 
 @noindent
 The function name should start in column 1, and multi-line argument
 lists should be aligned on the first char after the open parenthesis.
-You should put a space after the left open parenthesis and after commas,
+You should put a space before the left open parenthesis and after commas,
 for both function definitions and function calls.
 
 Recommended indent is 2 spaces.  When indenting, indent the statement
 after control structures (like @code{if}, @code{while}, etc.).  If there
 is a compound statement, indent @emph{both} the curly braces and the
 body of the statement (so that the body gets indented by @emph{two}
 indents).  Example:
 
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -37,19 +37,19 @@ Clinton Chee
 Albert Chin-A-Young
 Carsten Clark
 Catalin Codreanu
 J. D. Cole
 Martin Costabel
 Michael Creel
 Jeff Cunningham
 Martin Dalecki
+Jacob Dawid
 Jorge Barros de Abreu
 Carlo de Falco
-Jacob Dawid
 Thomas D. Dean
 Philippe Defert
 Bill Denney
 Fabian Deutsch
 Christos Dimitrakakis
 Pantxo Diribarne
 Vivek Dogra
 John Donoghue
@@ -70,16 +70,17 @@ Torsten Finke
 Jose Daniel Munoz Frias
 Brad Froehle
 Castor Fu
 Eduardo Gallestey
 Walter Gautschi
 Klaus Gebhardt
 Driss Ghaddab
 Nicolo Giorgetti
+Arun Giridhar
 Michael D. Godfrey
 Michael Goffioul
 Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
 Steffen Groot
 Etienne Grossmann
@@ -135,16 +136,17 @@ Heine Kolltveit
 Ken Kouno
 Kacper Kowalik
 Daniel Kraft
 Aravindh Krishnamoorthy
 Oyvind Kristiansen
 Piotr Krzyzanowski
 Volker Kuhlmann
 Tetsuro Kurita
+Philipp Kutin
 Miroslaw Kwasniak
 Rafael Laboissiere
 Kai Labusch
 Claude Lacoursiere
 Walter Landry
 Bill Lash
 Dirk Laurie
 Maurice LeBrun
@@ -154,31 +156,31 @@ Timo Lindfors
 Benjamin Lindner
 Ross Lippert
 David Livings
 Sebastien Loisel
 Erik de Castro Lopo
 Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
+Colin Macdonald
 James Macnicol
 Jens-Uwe Mager
-Colin Macdonald
 Rob Mahurin
+Alexander Mamonov
 Ricardo Marranita
 Orestes Mas
 Axel Mathi
 Makoto Matsumoto
 Tatsuro Matsuoka
+Christoph Mayer
 Laurent Mazet
 G. D. McBain
-Alexander Mamonov
-Christoph Mayer
+Ronald van der Meer
 Jlio Hoffimann Mendes
-Ronald van der Meer
 Thorsten Meyer
 Petr Mikulik
 Mike Miller
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
 Hannes Mller
 Victor Munoz
@@ -217,21 +219,23 @@ Francesco Potort
 Konstantinos Poulios
 Jarno Rajahalme
 James B. Rawlings
 Eric S. Raymond
 Balint Reczey
 Joshua Redstone
 Lukas Reichlin
 Michael Reifenberger
+Jens Restemeier
 Anthony Richardson
 Jason Riedy
 E. Joshua Rigler
 Petter Risholm
 Matthew W. Roberts
+Peter Rosin
 Andrew Ross
 Fabio Rossi
 Mark van Rossum
 Joe Rothweiler
 Kevin Ruland
 Kristian Rumberg
 Ryan Rusaw
 Olli Saarela
@@ -267,33 +271,34 @@ Brett Stewart
 Doug Stewart
 Jonathan Stickel
 Judd Storrs
 Thomas Stuart
 Ivan Sutoris
 John Swensen
 Daisuke Takago
 Ariel Tankus
+Falk Tannhuser
+Duncan Temple Lang
 Matthew Tenny
+Kris Thielemans
 Georg Thimm
-Duncan Temple Lang
-Kris Thielemans
 Olaf Till
 Christophe Tournery
 Thomas Treichl
 Karsten Trulsen
 Frederick Umminger
 Utkarsh Upadhyay
-Daniel Wagenaar
 Stefan van der Walt
 Peter Van Wieren
 James R. Van Zandt
 Risto Vanhanen
 Gregory Vanuxem
 Ivana Varekova
+Daniel Wagenaar
 Thomas Walter
 Andreas Weber
 Olaf Weber
 Thomas Weber
 Rik Wehbring
 Bob Weigel
 Andreas Weingessel
 Martin Weiser
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -30,19 +30,19 @@ dynamically while Octave is running, so 
 all of Octave just to add a new type.  @xref{External Code Interface}, for
 more information about Octave's dynamic linking capabilities.
 @ref{User-defined Data Types} describes what you must do to define a
 new data type for Octave.
 
 @DOCSTRING(typeinfo)
 
 @menu
-* Built-in Data Types::         
-* User-defined Data Types::     
-* Object Sizes::                
+* Built-in Data Types::
+* User-defined Data Types::
+* Object Sizes::
 @end menu
 
 @node Built-in Data Types
 @section Built-in Data Types
 @cindex data types, built-in
 @cindex built-in data types
 
 The standard built-in data types are real and complex scalars and
@@ -65,21 +65,21 @@ use of the following functions.
 
 @DOCSTRING(swapbytes)
 
 @DOCSTRING(bitpack)
 
 @DOCSTRING(bitunpack)
 
 @menu
-* Numeric Objects::             
-* Missing Data::                
-* String Objects::              
-* Data Structure Objects::      
-* Cell Array Objects::          
+* Numeric Objects::
+* Missing Data::
+* String Objects::
+* Data Structure Objects::
+* Cell Array Objects::
 @end menu
 
 @node Numeric Objects
 @subsection Numeric Objects
 @cindex numeric constant
 @cindex numeric value
 
 Octave's built-in numeric objects include real, complex, and integer
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -38,17 +38,17 @@ debug mode.
 * Profiling::
 * Profiler Example::
 @end menu
 
 @node Entering Debug Mode
 @section Entering Debug Mode
 
 There are two basic means of interrupting the execution of an Octave
-script.  These are breakpoints @pxref{Breakpoints}, discussed in the next
+script.  These are breakpoints (@pxref{Breakpoints}), discussed in the next
 section and interruption based on some condition.
 
 Octave supports three means to stop execution based on the values set in
 the functions @code{debug_on_interrupt}, @code{debug_on_warning} and
 @code{debug_on_error}.
 
 @DOCSTRING(debug_on_interrupt)
 
@@ -236,18 +236,18 @@ and the profiler also records that it is
 
 @DOCSTRING(profshow)
 
 @DOCSTRING(profexplore)
 
 @node Profiler Example
 @section Profiler Example
 
-Below, we will give a short example of a profiler session.  See also
-@ref{Profiling} for the documentation of the profiler functions in
+Below, we will give a short example of a profiler session.
+@xref{Profiling}, for the documentation of the profiler functions in
 detail.  Consider the code:
 
 @example
 global N A;
 
 N = 300;
 A = rand (N, N);
 
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -11,29 +11,29 @@
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
 @c 
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
-@node Diagonal and Permutation Matrices 
+@node Diagonal and Permutation Matrices
 @chapter Diagonal and Permutation Matrices
 
 @menu
-* Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
-* Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
+* Basic Usage::          Creation and Manipulation of Diagonal/Permutation Matrices
+* Matrix Algebra::       Linear Algebra with Diagonal/Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
-* Example Code::         Some Examples of Usage
-* Zeros Treatment::      The Differences in Treatment of Zero Elements
+* Example Code::         Examples of Usage
+* Zeros Treatment::      Differences in Treatment of Zero Elements
 @end menu
 
 @node Basic Usage
-@section Creating and Manipulating Diagonal and Permutation Matrices
+@section Creating and Manipulating Diagonal/Permutation Matrices
 
 A diagonal matrix is defined as a matrix that has zero entries outside the main
 diagonal; that is, 
 @tex
 $D_{ij} = 0$ if $i \neq j$
 @end tex
 @ifnottex
 @code{D(i,j) == 0} if @code{i != j}.
@@ -205,17 +205,17 @@ such as @dfn{exp}.
 
 An explicit conversion to a full matrix can be requested using the built-in
 function @dfn{full}.  It should also be noted that the diagonal and permutation
 matrix objects will cache the result of the conversion after it is first
 requested (explicitly or implicitly), so that subsequent conversions will
 be very cheap.
 
 @node Matrix Algebra
-@section Linear Algebra with Diagonal and Permutation Matrices
+@section Linear Algebra with Diagonal/Permutation Matrices
 
 As has been already said, diagonal and permutation matrices make it
 possible to use efficient algorithms while preserving natural linear
 algebra syntax.  This section describes in detail the operations that
 are treated specially when performed on these special matrix objects.
 
 @menu
 * Expressions Involving Diagonal Matrices::
@@ -408,17 +408,17 @@ A permutation matrix can also be returne
 @dfn{lu} and @dfn{qr}, if a pivoted factorization is requested.
 
 The @dfn{sparse} function will convert a permutation matrix efficiently to a
 sparse matrix.
 The @dfn{find} function will also work efficiently with a permutation matrix,
 making it possible to conveniently obtain the permutation indices.
 
 @node Example Code
-@section Some Examples of Usage
+@section Examples of Usage
 
 The following can be used to solve a linear system @code{A*x = b}
 using the pivoted LU@tie{}factorization:
 
 @example
 @group
   [L, U, P] = lu (A); ## now L*U = P*A
   x = U \ L \ P*b;
@@ -431,18 +431,17 @@ This is one way to normalize columns of 
 @example
 @group
   s = norm (X, "columns");
   X /= diag (s);
 @end group
 @end example
 
 @noindent
-The same can also be accomplished with broadcasting
-(@pxref{Broadcasting}):
+The same can also be accomplished with broadcasting (@pxref{Broadcasting}):
 
 @example
 @group
   s = norm (X, "columns");
   X ./= s;
 @end group
 @end example
 
@@ -472,17 +471,17 @@ with Tikhonov regularization (ridge regr
   x = (S'*S + alpha^2 * eye (n)) \ (S' * b);
   ## transform to solution basis
   x = V*x;
 @end group
 @end example
 
 
 @node Zeros Treatment
-@section The Differences in Treatment of Zero Elements
+@section Differences in Treatment of Zero Elements
 
 Making diagonal and permutation matrices special matrix objects in their own
 right and the consequent usage of smarter algorithms for certain operations
 implies, as a side effect, small differences in treating zeros.
 The contents of this section applies also to sparse matrices, discussed in
 the following chapter.
 
 The IEEE standard defines the result of the expressions @code{0*Inf} and 
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -19,18 +19,18 @@
 @node Differential Equations
 @chapter Differential Equations
 
 Octave has built-in functions for solving ordinary differential equations,
 and differential-algebraic equations.
 All solvers are based on reliable ODE routines written in Fortran.
 
 @menu
-* Ordinary Differential Equations::  
-* Differential-Algebraic Equations::  
+* Ordinary Differential Equations::
+* Differential-Algebraic Equations::
 @end menu
 
 @cindex differential equations
 @cindex ODE
 @cindex DAE
 
 @node Ordinary Differential Equations
 @section Ordinary Differential Equations
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -24,16 +24,17 @@ APIs
 appdata
 approximant
 arg
 args
 ARMA
 arpack
 ascii
 Ashok
+ast
 async
 atan
 Attr
 AutoCAD
 Autoconf
 autocorrelations
 autocovariances
 autoload
@@ -48,16 +49,17 @@ autoscaled
 AutoScaling
 AWK
 awt
 backend
 Backends
 backends
 bartlett
 BaseValue
+basevalue
 Bateman
 BDF
 bdf
 betacdf
 betainv
 betaln
 betapdf
 betarnd
@@ -121,41 +123,46 @@ changesets
 Chaves
 chdir
 Chebyshev
 chisq
 chisquare
 chol
 Cholesky
 cholmod
+chromaticity
 chrominance
 cindex
 circ
 circshift
 circum
 classpath
 classpaths
 Clenshaw
 CLI
 clim
+climmode
 cloglog
+closerequestfcn
 clubsuit
 CMatrix
 cmd
 cmember
+CMYK
 cntrl
 codebases
 cof
 coffset
 colamd
 collectoutput
 colorbar
 colormap
 colormaps
 ColorOrder
+colororder
 colperm
 Comint
 Commandline
 commentstyle
 ComplexEqn
 cond
 condest
 conformant
@@ -178,28 +185,32 @@ csymamd
 ctranspose
 CTRL
 CTS
 cummax
 cummin
 cumprod
 cumsum
 cURL
+CurrentAxes
+CurrentFigure
 CurrentObject
+currentpoint
 Cuthill
 cxsparse
 Cygwin
 DAE
 DAEs
 daspk
 dasrt
 dassl
 dataset
 datasets
 datasource
+datenum
 datestr
 datestrings
 davis
 ddd
 dddd
 deallocate
 deallocated
 deconv
@@ -221,30 +232,33 @@ disp
 DisplayName
 DisplayNames
 displayrange
 dMatrix
 dmperm
 Dobkin
 docstrings
 dOmega
+doNotSpecify
 dotall
 dotexceptnewline
 Downarrow
 downarrow
 downdate
 dpi
 Driebeck
 dt
 Dt
 Dulmage
 Durbin
 dx
 dy
 EastOutside
+edgecolor
+Ei
 EIDORS
 eigenpairs
 eigenvector
 eigenvectors
 eigs
 Ekerdt
 elementwise
 Elfers
@@ -270,22 +284,24 @@ erfc
 erfi
 errno
 Errorbar
 errorbar
 Errorbars
 errorbars
 errordlg
 ErrorHandler
+ESC
 Esmond
 et
 etree
 etreeplot
 eval
 Executables
+Exif
 exitflag
 expcdf
 expinv
 exppdf
 exprnd
 extendedtext
 facecolor
 facevertexcdata
@@ -325,32 +341,36 @@ FreeBSD
 freespacing
 FreeType
 freetype
 frnd
 frob
 Frobenius
 Fs
 FSF
+fullpath
+fullpathext
 FunValCheck
 gamcdf
 gaminv
 gampdf
 gamrnd
 Gautschi
+gca
 gcbo
 GCC
 gcd
 ge
 GECOS
 genvarname
 geocdf
 geoinv
 geopdf
 geornd
+geotagging
 geq
 gesdd
 gesvd
 gfortran
 Ghostscript
 Ghostscript's
 gif
 GIF
@@ -382,16 +402,17 @@ gswin
 GUIs
 gunzipped
 gz
 gzip
 gzipped
 Hackbusch
 Hadamard
 Haddad
+HandleVisibility
 Hankel
 Hanning
 hardcode
 hardcoding
 Hauberg
 HDF
 hdf
 headerlines
@@ -422,16 +443,17 @@ Huhdanpaa
 hygecdf
 hygeinv
 hygepdf
 hygernd
 Hyndman
 Hypergeometric
 hypergeometric
 IEC
+ieee
 IEEE
 ifelse
 ifft
 ifftn
 ignorecase
 ij
 Im
 imag
@@ -452,42 +474,46 @@ interpderiv
 interpft
 interpn
 interpolant
 Interpolants
 interquartile
 inv
 involutory
 ipermute
+isdir
 ishandle
 ishghandle
 isolines
 isosurface
 isovalue
 isreal
 issparse
 isvector
 iter
 ith
 iy
 iz
 Jacobian
 Jacobians
 javaaddpath
 javamem
+jbig
 JIT
 jpeg
 JPEG
 jpg
 jvm
 JVM's
 Kac
 Kahan
+kendall
 keybindings
 keypress
+keypressfcn
 Kolmogorov
 kolmogorov
 Konrod
 Krishnamurthy
 kron
 kruskal
 Kruskal
 Krylov
@@ -500,16 +526,17 @@ laplace
 Larimore
 LaserJet
 Lauchli
 lceil
 ldiv
 ldivide
 ldots
 le
+leaveInPlace
 Leftarrow
 leftarrow
 Leftrightarrow
 leftrightarrow
 Lehmer
 Lehoucq
 leq
 Levinson
@@ -522,16 +549,18 @@ liboctave
 liboctinterp
 Libtool
 licensors
 lineanchors
 linefeeds
 linesearch
 linespec
 linespoints
+linestyle
+linewidth
 linkprop
 listdlg
 ListSize
 ListString
 literalspacing
 Liu
 LLVM
 LM
@@ -557,37 +586,44 @@ lt
 lu
 Lua
 luinc
 lvalue
 lvl
 lx
 ly
 lz
+lzma
+lzw
 Magnus
 Mahalanobis
 makefile
 makefiles
 makeinfo
 Mandriva
 MANOVA
 manova
+markeredgecolor
+markerfacecolor
+markersize
+markerstyle
 Marsaglia
 Maschhoff
 matchcase
 matlab
 Matsumoto
 MaxFunEvals
 maxima
 MaxIntervalCount
 MaxIter
 mcnemar
 McNemar's
 meansq
 Mendelsohn
+menubars
 Mersenne
 meshgrid
 meshgridded
 metafile
 Metafile
 metafiles
 Metafont
 mex
@@ -619,16 +655,17 @@ mput
 mrdivide
 msgbox
 MSYS
 mtimes
 Multi
 multi
 multibyte
 multiline
+multipage
 multipledelimsasone
 MultiSelect
 mxArray
 myclass
 myfun
 nabla
 namespace
 NAMESPACE
@@ -642,16 +679,17 @@ nbinrnd
 nd
 ndgrid
 ne
 Nelder
 neq
 Neudecker
 Neumann
 NeXT
+NextPlot
 nfev
 nfft
 Ng
 ni
 Nishimura
 NLP
 nnls
 nnz
@@ -683,42 +721,47 @@ octaverc
 ODEPACK
 OKString
 OLS
 onCleanup
 online
 OpenGL
 oplus
 Oppenheim
+Ord
 oregonator
 Orthogonalize
 oslash
 otimes
 OutputFcn
 outputfcn
 overridable
 paperorientation
 paperposition
+PaperPosition
 papersize
 paperunits
+PaperUnits
 parseparams
 Parter
 pbm
 PBM
 PBMplus
+pc
 pcg
 PCG
 pchip
 pcr
 pcre
 PCRE
 PCX
 pcx
 pdf
 PDF
+pearson
 pentadiagonal
 periodogram
 perp
 Petzold's
 PGF
 pgm
 PGMRES
 PHP
@@ -732,16 +775,18 @@ PointJet
 poisscdf
 poissinv
 poisspdf
 poissrnd
 polyderiv
 polyeig
 polyfit
 polyval
+pos
+POSDEF
 POSIX
 postorder
 PostScript
 Pothen
 powerset
 pre
 preconditioner
 premultiplied
@@ -791,42 +836,47 @@ randperm
 rangle
 ranlib
 ras
 Rawlings
 rceil
 rdivide
 Readline
 readline
+RECT
 recursing
 Redheffer
 reentrant
 regex
 regressor
 Reindent
 relicensing
 ren
 renderer
 repelems
+replacechildren
 repmat
 resampled
 resampling
 Resize
 resize
 resized
 resnorm
 resparsify
+restoreBG
+restorePrevious
 RET
 returnonerror
 rfloor
 rgb
 RGB
 Riccati
 Rightarrow
 rightarrow
+rle
 rline
 rmdir
 RMS
 rnd
 roffset
 Rosser
 Rossum
 rpath
@@ -891,16 +941,17 @@ sqrt
 sqrtm
 sr
 ss
 Stadlober
 stairstep
 Stallman
 startup
 Startup
+statinfo
 stdnormal
 stdout
 Stegun
 Stepleman
 stepsize
 STFT
 STL
 stochastically
@@ -936,16 +987,17 @@ subsasgn
 Subscripted
 subscripted
 subscripting
 subseteq
 subsindex
 subsref
 substring
 substrings
+subwindows
 SuiteSparse
 sumsq
 SunOS
 superiorto
 supradiagonal
 supset
 supseteq
 SV
@@ -972,73 +1024,83 @@ TextAlphaBits
 textfield
 textread
 textscan
 th
 ths
 tif
 Tikhonov
 TikZ
+Timestamp
 tinv
 Tisseur
 Tisseur's
 tmp
 Toeplitz
 tokenExtents
 TolF
 TolFun
 TolX
 toolkits
 Toolkits
+toplevel
 tp
 tpdf
 traceback
+TRANSA
 trapz
 treatasempty
 treelayout
 treeplot
 tridiagonal
+trimesh
 triplot
 trnd
+truecolor
+TrueColor
 Tsang
 Tukey
 tuples
 Tx
 txi
 typedefs
 TypicalX
 ub
 UB
 uchar
+UHESS
 UID
 uimenu
 uint
 uiputfile
 ulong
 Ultrix
 umfpack
 uminus
 Unary
 unary
 uncomment
 Uncomments
+unconvertible
 unformatted
 unidcdf
 unidinv
 unidpdf
 unidrnd
 unifcdf
 unifinv
 UniformOutput
 unifpdf
 unifrnd
 unimodal
 Uninstall
 uninstalled
 univariate
+unix
+unnorm
 unnormalized
 unpadded
 unpermuted
 unpivoted
 unregister
 unshare
 unsymmetric
 untabified
@@ -1067,16 +1129,17 @@ Villadsen
 voronoi
 Voronoi
 waitbar
 waitbars
 wallis
 warndlg
 Wathen
 WAV
+WayPoints
 wblcdf
 wblinv
 wblpdf
 wblrnd
 WebKit
 Weibull
 Welch
 welch
@@ -1087,19 +1150,23 @@ whos
 wienrnd
 Wikipedia
 wilcoxon
 Wilcoxon
 wildcard
 Wildcards
 wildcards
 Wilks
+windowbuttondownfcn
+windowbuttonmotionfcn
+windowbuttonupfcn
 windowstyle
 WinRand
 WIPO
+wireframe
 wp
 wspace
 xb
 xc
 xcorr
 xdigit
 xerrorbar
 xerrorbars
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -39,20 +39,20 @@ Finally, you can convince Octave to use 
 All functionality is provided by the Emacs Lisp package EOS (for ``Emacs
 Octave Support'').  This chapter describes how to set up and use this
 package.
 
 Please contact @email{Kurt.Hornik@@wu-wien.ac.at} if you have any questions
 or suggestions on using EOS.
 
 @menu
-* Installing EOS::              
-* Using Octave Mode::           
-* Running Octave from Within Emacs::  
-* Using the Emacs Info Reader for Octave::  
+* Installing EOS::
+* Using Octave Mode::
+* Running Octave from Within Emacs::
+* Using the Emacs Info Reader for Octave::
 @end menu
 
 @node Installing EOS
 @appendixsec Installing EOS
 
 The Emacs package EOS consists of the three files @file{octave-mod.el},
 @file{octave-inf.el}, and @file{octave-hlp.el}.  These files, or better
 yet their byte-compiled versions, should be somewhere in your Emacs
@@ -246,17 +246,17 @@ and return values which have to be enter
 @item C-c C-h
 Search the function, operator and variable indices of all info files
 with documentation for Octave for entries (@code{octave-help}).  If used
 interactively, the entry is prompted for with completion.  If multiple
 matches are found, one can cycle through them using the standard
 @samp{,} (@code{Info-index-next}) command of the Info reader.
 
 The variable @code{octave-help-files} is a list of files to search
-through and defaults to @code{'("octave")}.  If there is also an Octave
+through and defaults to @qcode{'("octave")}.  If there is also an Octave
 Local Guide with corresponding info file, say, @file{octave-LG}, you can
 have @code{octave-help} search both files by 
 @lisp
 (setq octave-help-files '("octave" "octave-LG"))
 @end lisp
 @noindent
 in one of your Emacs startup files.
 
@@ -385,17 +385,17 @@ about this command, add the line
 @lisp
 (autoload 'run-octave "octave-inf" nil t)
 @end lisp
 @noindent
 to your @file{.emacs} file.
 
 This will start Octave in a special buffer the name of which is
 specified by the variable @code{inferior-octave-buffer} and defaults to
-@code{"*Inferior Octave*"}.  From within this buffer, you can
+@qcode{"*Inferior Octave*"}.  From within this buffer, you can
 interact with the inferior Octave process `as usual', i.e., by entering
 Octave commands at the prompt.  The buffer is in Inferior Octave mode,
 which is derived from the standard Comint mode, a major mode for
 interacting with an inferior interpreter.  See the documentation for
 @code{comint-mode} for more details, and use @kbd{C-h b} to find out
 about available special keybindings.
 
 You can also communicate with an inferior Octave process from within
@@ -451,17 +451,17 @@ Default is @code{t}.
 
 If you send code and there is no inferior Octave process yet, it will be
 started automatically.
 
 The startup of the inferior Octave process is highly customizable.
 The variable @code{inferior-octave-startup-args} can be used for
 specifying command lines arguments to be passed to Octave on startup
 as a list of strings.  For example, to suppress the startup message and
-use `traditional' mode, set this to @code{'("-q" "--traditional")}.
+use `traditional' mode, set this to @qcode{'("-q" "--traditional")}.
 You can also specify a startup file of Octave commands to be loaded on
 startup; note that these commands will not produce any visible output
 in the process buffer.  Which file to use is controlled by the variable
 @code{inferior-octave-startup-file}.  If this is @code{nil}, the file
 @file{~/.emacs-octave} is used if it exists.
 
 And finally, @code{inferior-octave-mode-hook} is run after starting the
 process and putting its buffer into Inferior Octave mode.  Hence, if you
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -180,18 +180,18 @@ endfor
 
 @DOCSTRING(lasterr)
 
 It is also possible to assign an identification string to an error.
 If an error has such an ID the user can catch this error
 as will be shown in the next example.  To assign an ID to an error,
 simply call @code{error} with two string arguments, where the first
 is the identification string, and the second is the actual error.  Note
-that error IDs are in the format "NAMESPACE:ERROR-NAME".  The namespace
-"Octave" is used for Octave's own errors.  Any other string is available
+that error IDs are in the format @qcode{"NAMESPACE:ERROR-NAME"}.  The namespace
+@qcode{"Octave"} is used for Octave's own errors.  Any other string is available
 as a namespace for user's own errors.
 
 The next example counts indexing errors.  The errors are caught using the
 field identifier of the structure returned by the function @code{lasterror}.
 
 @example
 @group
 number_of_errors = 0;
@@ -325,35 +325,35 @@ to catch a warning using the @code{try} 
 It is however possible to access the last warning as a string using the
 @code{lastwarn} function.
 
 It is also possible to assign an identification string to a warning.
 If a warning has such an ID the user can enable and disable this warning
 as will be described in the next section.  To assign an ID to a warning,
 simply call @code{warning} with two string arguments, where the first
 is the identification string, and the second is the actual warning.  Note
-that warning IDs are in the format "NAMESPACE:WARNING-NAME".  The namespace
-"Octave" is used for Octave's own warnings.  Any other string is available
-as a namespace for user's own warnings.
+that warning IDs are in the format @qcode{"NAMESPACE:WARNING-NAME"}.  The
+namespace @qcode{"Octave"} is used for Octave's own warnings.  Any other string
+is available as a namespace for user's own warnings.
 
 @DOCSTRING(warning)
 
 @DOCSTRING(lastwarn)
 
 The functions distributed with Octave can issue one of the following
 warnings.
 
 @DOCSTRING(warning_ids)
 
 @node Enabling and Disabling Warnings
 @subsection Enabling and Disabling Warnings
 
 The @code{warning} function also allows you to control which warnings
 are actually printed to the screen.  If the @code{warning} function
-is called with a string argument that is either @code{"on"} or @code{"off"}
+is called with a string argument that is either @qcode{"on"} or @qcode{"off"}
 all warnings will be enabled or disabled.
 
 It is also possible to enable and disable individual warnings through
 their string identifications.  The following code will issue a warning
 
 @example
 @group
 warning ("example:non-negative-variable", 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -74,18 +74,18 @@ function result = newtroot (fname, x)
 
 endfunction
 @end example
 
 Note that this is only meant to be an example of calling user-supplied
 functions and should not be taken too seriously.  In addition to using a
 more robust algorithm, any serious code would check the number and type
 of all the arguments, ensure that the supplied function really was a
-function, etc.  @xref{Predicates for Numeric Objects}, for example,
-for a list of predicates for numeric objects, and see @ref{Status of
+function, etc.  @xref{Predicates for Numeric Objects},
+for a list of predicates for numeric objects, and @pxref{Status of
 Variables}, for a description of the @code{exist} function.
 
 @DOCSTRING(feval)
 
 A similar function @code{run} exists for calling user script files, that
 are not necessarily on the user path
 
 @DOCSTRING(run)
@@ -130,17 +130,17 @@ function save (file, name1, name2)
   save_var (f, name1, evalin ("caller", name1));
   save_var (f, name2, evalin ("caller", name2));
 endfunction
 @end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{create_data} function and @code{name1}
-is the string @code{"x"}, which evaluates simply as the value of @code{x}.
+is the string @qcode{"x"}, which evaluates simply as the value of @code{x}.
 
 You later want to load the values back from @code{mydata}
 in a different context:
 
 @example
 @group
 function process_data
   load mydata
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -27,24 +27,24 @@ an assignment operator.
 
 An expression can serve as a statement on its own.  Most other kinds of
 statements contain one or more expressions which specify data to be
 operated on.  As in other languages, expressions in Octave include
 variables, array references, constants, and function calls, as well as
 combinations of these with various operators.
 
 @menu
-* Index Expressions::           
-* Calling Functions::           
-* Arithmetic Ops::              
-* Comparison Ops::              
-* Boolean Expressions::         
-* Assignment Ops::              
-* Increment Ops::               
-* Operator Precedence::         
+* Index Expressions::
+* Calling Functions::
+* Arithmetic Ops::
+* Comparison Ops::
+* Boolean Expressions::
+* Assignment Ops::
+* Increment Ops::
+* Operator Precedence::
 @end menu
 
 @node Index Expressions
 @section Index Expressions
 
 @opindex (
 @opindex )
 @opindex :
@@ -380,18 +380,18 @@ For example, the following statement
 computes the singular value decomposition of the matrix @code{a} and
 assigns the three result matrices to @code{u}, @code{s}, and @code{v}.
 
 The left side of a multiple assignment expression is itself a list of
 expressions, and is allowed to be a list of variable names or index
 expressions.  See also @ref{Index Expressions}, and @ref{Assignment Ops}.
 
 @menu
-* Call by Value::               
-* Recursion::                   
+* Call by Value::
+* Recursion::
 @end menu
 
 @node Call by Value
 @subsection Call by Value
 
 In Octave, unlike Fortran, function arguments are passed by value, which
 means that each argument in a function call is evaluated and assigned to
 a temporary location in memory before being passed to the function.
@@ -428,17 +428,17 @@ argument had.  For example, given a func
 foo = "bar";
 fcn (foo)
 @end group
 @end example
 
 @noindent
 you should not think of the argument as being ``the variable
 @code{foo}.''  Instead, think of the argument as the string value,
-@code{"bar"}.
+@qcode{"bar"}.
 
 Even though Octave uses pass-by-value semantics for function arguments,
 values are not copied unnecessarily.  For example,
 
 @example
 @group
 x = rand (1000);
 f (x);
@@ -578,31 +578,31 @@ but it is computed without forming the i
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} .\ @var{y}
 @opindex .\
 Element-by-element left division.  Each element of @var{y} is divided
 by each corresponding element of @var{x}.
 
-@item @var{x} ^ @var{y}
+@item  @var{x} ^ @var{y}
 @itemx @var{x} ** @var{y}
 @opindex **
 @opindex ^
 Power operator.  If @var{x} and @var{y} are both scalars, this operator
 returns @var{x} raised to the power @var{y}.  If @var{x} is a scalar and
 @var{y} is a square matrix, the result is computed using an eigenvalue
 expansion.  If @var{x} is a square matrix, the result is computed by
 repeated multiplication if @var{y} is an integer, and by an eigenvalue
 expansion if @var{y} is not an integer.  An error results if both
 @var{x} and @var{y} are matrices.
 
 The implementation of this operator needs to be improved.
 
-@item @var{x} .^ @var{y}
+@item  @var{x} .^ @var{y}
 @itemx @var{x} .** @var{y}
 @opindex .**
 @opindex .^
 Element-by-element power operator.  If both operands are matrices, the
 number of rows and columns must both agree, or they must be
 broadcastable to the same shape.  If several complex results are
 possible, the one with smallest non-negative argument (angle) is taken.
 This rule may return a complex root even when a real root is also possible.
@@ -754,17 +754,17 @@ True if @var{x} is equal to @var{y}.
 @item @var{x} >= @var{y}
 @opindex >=
 True if @var{x} is greater than or equal to @var{y}.
 
 @item @var{x} > @var{y}
 @opindex >
 True if @var{x} is greater than @var{y}.
 
-@item @var{x} != @var{y}
+@item  @var{x} != @var{y}
 @itemx @var{x} ~= @var{y}
 @opindex !=
 @opindex ~=
 True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
@@ -791,17 +791,17 @@ function, not with the comparison operat
 @opindex >=
 @DOCSTRING(ge)
 
 @opindex >
 @DOCSTRING(gt)
 
 @DOCSTRING(isequal)
 
-@DOCSTRING(isequalwithequalnans)
+@DOCSTRING(isequaln)
 
 @opindex <=
 @DOCSTRING(le)
 
 @opindex <
 @DOCSTRING(lt)
 
 @opindex !=
@@ -818,18 +818,18 @@ function, not with the comparison operat
 @cindex boolean operators
 @cindex logical operators
 @cindex operators, logical
 @cindex and operator
 @cindex or operator
 @cindex not operator
 
 @menu
-* Element-by-element Boolean Operators::  
-* Short-circuit Boolean Operators::  
+* Element-by-element Boolean Operators::
+* Short-circuit Boolean Operators::
 @end menu
 
 @node Element-by-element Boolean Operators
 @subsection Element-by-element Boolean Operators
 @cindex element-by-element evaluation
 
 An @dfn{element-by-element boolean expression} is a combination of
 comparison expressions using the boolean
@@ -858,17 +858,17 @@ Here are descriptions of the three eleme
 Elements of the result are true if both corresponding elements of
 @var{boolean1} and @var{boolean2} are true.
 
 @item @var{boolean1} | @var{boolean2}
 @opindex |
 Elements of the result are true if either of the corresponding elements
 of @var{boolean1} or @var{boolean2} is true.
 
-@item ! @var{boolean}
+@item  ! @var{boolean}
 @itemx ~ @var{boolean}
 @opindex ~
 @opindex !
 Each element of the result is true if the corresponding element of
 @var{boolean} is false.
 @end table
 
 These operators work on an element-by-element basis.  For example, the
@@ -1038,17 +1038,17 @@ z = 1
 @end example
 
 @noindent
 After this expression is executed, the variable @code{z} has the value 1.
 Whatever old value @code{z} had before the assignment is forgotten.
 The @samp{=} sign is called an @dfn{assignment operator}.
 
 Assignments can store string values also.  For example, the following
-expression would store the value @code{"this food is good"} in the
+expression would store the value @qcode{"this food is good"} in the
 variable @code{message}:
 
 @example
 @group
 thing = "food"
 predicate = "good"
 message = [ "this " , thing , " is " , predicate ]
 @end group
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -99,41 +99,41 @@ native oct-file interface.  The C langua
 mex-file interface for compatibility with @sc{matlab}.  Fortran code is easiest
 to reach through the oct-file interface.
 
 Because many other languages provide C or C++ APIs it is relatively simple
 to build bridges between Octave and other languages.  This is also a way to
 bridge to hardware resources which often have device drivers written in C.
 
 @menu
-* Oct-Files::                   
-* Mex-Files::                   
-* Standalone Programs::         
+* Oct-Files::
+* Mex-Files::
+* Standalone Programs::
 @end menu
 
 @node Oct-Files
 @section Oct-Files
 @cindex oct-files
 @cindex mkoctfile
 @cindex oct
 
 @menu
-* Getting Started with Oct-Files::  
-* Matrices and Arrays in Oct-Files::  
-* Character Strings in Oct-Files::  
-* Cell Arrays in Oct-Files::    
-* Structures in Oct-Files::  
-* Sparse Matrices in Oct-Files::  
-* Accessing Global Variables in Oct-Files::  
-* Calling Octave Functions from Oct-Files::  
-* Calling External Code from Oct-Files::  
-* Allocating Local Memory in Oct-Files::  
-* Input Parameter Checking in Oct-Files::  
-* Exception and Error Handling in Oct-Files::  
-* Documentation and Test of Oct-Files::  
+* Getting Started with Oct-Files::
+* Matrices and Arrays in Oct-Files::
+* Character Strings in Oct-Files::
+* Cell Arrays in Oct-Files::
+* Structures in Oct-Files::
+* Sparse Matrices in Oct-Files::
+* Accessing Global Variables in Oct-Files::
+* Calling Octave Functions from Oct-Files::
+* Calling External Code from Oct-Files::
+* Allocating Local Memory in Oct-Files::
+* Input Parameter Checking in Oct-Files::
+* Exception and Error Handling in Oct-Files::
+* Documentation and Test of Oct-Files::
 @c * Application Programming Interface for Oct-Files::  
 @end menu
 
 @node Getting Started with Oct-Files
 @subsection Getting Started with Oct-Files
 
 Oct-files are pieces of C++ code that have been compiled with the Octave
 API into a dynamically loadable object.  They take their name from the file
@@ -300,71 +300,69 @@ Matrix a (2, 2)
 
 However, this constructor can only be used with matrix types.
 @end itemize
 
 These types all share a number of basic methods and operators.  Many bear
 a resemblance to functions that exist in the interpreter.  A selection of
 useful methods include
 
-@deftypefn  Method T& {operator ()} (octave_idx_type)
-@deftypefnx Method T& elem (octave_idx_type)
+@deftypefn  {Method} {T&} operator () (octave_idx_type)
+@deftypefnx {Method} {T&} elem (octave_idx_type)
 The @code{()} operator or @code{elem} method allow the values of the
 matrix or array to be read or set.  These can take a single argument,
 which is of type @code{octave_idx_type}, that is the index into the matrix or
 array.  Additionally, the matrix type allows two argument versions of the
 @code{()} operator and elem method, giving the row and column index of the
 value to obtain or set.
 @end deftypefn
 
 Note that these functions do significant error checking and so in some
 circumstances the user might prefer to access the data of the array or
 matrix directly through the @nospell{fortran_vec} method discussed below.
 
-@deftypefn Method octave_idx_type numel (void) const
+@deftypefn {Method} {} octave_idx_type numel (void) const
 The total number of elements in the matrix or array.
 @end deftypefn
 
-@deftypefn Method size_t byte_size (void) const
+@deftypefn {Method} {size_t} byte_size (void) const
 The number of bytes used to store the matrix or array.
 @end deftypefn
 
-@deftypefn Method dim_vector dims (void) const
+@deftypefn {Method} {dim_vector} dims (void) const
 The dimensions of the matrix or array in value of type dim_vector.
 @end deftypefn
 
-@deftypefn Method int ndims (void) const
+@deftypefn {Method} {int} ndims (void) const
 The number of dimensions of the matrix or array.  Matrices are 2-D,
 but arrays can be N-dimensional.
 @end deftypefn
 
-@deftypefn Method void resize (const dim_vector&)
+@deftypefn {Method} {void} resize (const dim_vector&)
 A method taking either an argument of type @code{dim_vector}, or in the
 case of a matrix two arguments of type @code{octave_idx_type} defining
 the number of rows and columns in the matrix.
 @end deftypefn
 
-@deftypefn Method T* fortran_vec (void)
+@deftypefn {Method} {T*} fortran_vec (void)
 This method returns a pointer to the underlying data of the matrix or
 array so that it can be manipulated directly, either within Octave or by
 an external library.
 @end deftypefn
 
 Operators such an @code{+}, @code{-}, or @code{*} can be used on the
 majority of the matrix and array types.  In addition there are a number of
 methods that are of interest only for matrices such as @code{transpose},
 @code{hermitian}, @code{solve}, etc.
 
 The typical way to extract a matrix or array from the input arguments of
 @w{@code{DEFUN_DLD}} function is as follows
 
 @example
-@group
 @EXAMPLEFILE(addtwomatrices.cc)
-@end group
 @end example
 
 To avoid segmentation faults causing Octave to abort this function
 explicitly checks that there are sufficient arguments available before
 accessing these arguments.  It then obtains two multi-dimensional arrays
 of type @code{NDArray} and adds these together.  Note that the array_value
 method is called without using the @code{is_matrix_type} type, and instead the
 error_state is checked before returning @code{A + B}.  The reason to
@@ -479,19 +477,17 @@ retval(0) = octave_value (ch, '"');
 @subsection Cell Arrays in Oct-Files
 
 Octave's cell type is also available from within oct-files.  A cell
 array is just an array of @code{octave_value}s, and thus each element of the
 cell array can be treated just like any other @code{octave_value}.  A simple
 example is
 
 @example
-@group
 @EXAMPLEFILE(celldemo.cc)
-@end group
 @end example
 
 Note that cell arrays are used less often in standard oct-files and so
 the @file{Cell.h} header file must be explicitly included.  The rest of the
 example extracts the @code{octave_value}s one by one from the cell array and
 returns them as individual return arguments.  For example:
 
 @example
@@ -579,23 +575,23 @@ to their similarity with the existing @c
 there are a few differences due the different nature of sparse objects,
 and these will be described.  First, although it is fundamentally
 possible to have N-dimensional sparse objects, the Octave sparse classes do
 not allow them at this time; All instances of the sparse classes
 must be 2-dimensional.  This means that @code{SparseMatrix} is actually
 more similar to Octave's @code{Matrix} class than its @code{NDArray} class.
 
 @menu
-* Array and Sparse Differences::  
-* Creating Sparse Matrices in Oct-Files::  
-* Using Sparse Matrices in Oct-Files::  
+* Array and Sparse Class Differences::
+* Creating Sparse Matrices in Oct-Files::
+* Using Sparse Matrices in Oct-Files::
 @end menu
 
-@node Array and Sparse Differences
-@subsubsection The Differences between the Array and Sparse Classes
+@node Array and Sparse Class Differences
+@subsubsection Array and Sparse Class Differences
 
 The number of elements in a sparse matrix is considered to be the number
 of non-zero elements rather than the product of the dimensions.  Therefore
 
 @example
 @group
 SparseMatrix sm;
 @dots{}
@@ -611,17 +607,17 @@ large matrices, where the product of the
 the representation of an unsigned int, then @code{numel} can overflow.
 An example is @code{speye (1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
-Extreme care must be take with the elem method and the "()" operator,
+Extreme care must be take with the elem method and the @qcode{"()"} operator,
 which perform basically the same function.  The reason is that if a
 sparse object is non-const, then Octave will assume that a
 request for a zero element in a sparse matrix is in fact a request
 to create this element so it can be filled.  Therefore a piece of
 code like
 
 @example
 @group
@@ -1196,17 +1192,17 @@ 1 / 0
 The warning for division by zero (and in fact all warnings) are disabled in the
 @code{unwinddemo} function.
 
 @node Documentation and Test of Oct-Files
 @subsection Documentation and Test of Oct-Files
 
 The documentation of an oct-file is the fourth string parameter of the
 @w{@code{DEFUN_DLD}} macro.  This string can be formatted in the same manner
-as the help strings for user functions (@ref{Documentation Tips}),
+as the help strings for user functions (@pxref{Documentation Tips}),
 however there are some issue that are particular to the formatting of
 help strings within oct-files.
 
 The major issue is that the help string will typically be longer than a
 single line of text, and so the formatting of long help strings needs to
 be taken into account.  There are several possible solutions, but the most
 common is illustrated in the following example,
 
@@ -1226,17 +1222,17 @@ than what they requested.\n\
 
 @noindent
 where, as can be seen, each line of text is terminated by @code{\n\}
 which is an embedded new-line in the string together with a C++ string
 continuation character.  Note that the final @code{\} must be the last
 character on the line.
 
 Octave also includes the ability to embed test and demonstration
-code for a function within the code itself (@ref{Test and Demo Functions}).
+code for a function within the code itself (@pxref{Test and Demo Functions}).
 This can be used from within oct-files (or in fact any file) with
 certain provisos.  First, the test and demo functions of Octave look
 for @code{%!} as the first two characters of a line to identify test
 and demonstration code.  This is a requirement for oct-files as well.
 In addition, the test and demonstration code must be wrapped in a comment
 block to avoid it being interpreted by the compiler.  Finally, the Octave
 test and demonstration code must have access to the original source code
 of the oct-file and not just the compiled code as the tests are stripped
@@ -1269,23 +1265,23 @@ between Octave and @sc{matlab} users.  H
 different, a mex-file can never have the same performance in Octave as
 the equivalent oct-file.  In particular, to support the manner in which
 variables are passed to mex functions there are a significant number of
 additional copies of memory blocks when calling or returning from a
 mex-file function.  For this reason, it is recommended that any new code
 be written with the oct-file interface previously discussed.
 
 @menu
-* Getting Started with Mex-Files::  
-* Working with Matrices and Arrays in Mex-Files::  
-* Character Strings in Mex-Files::  
-* Cell Arrays with Mex-Files::  
-* Structures with Mex-Files::  
-* Sparse Matrices with Mex-Files::  
-* Calling Other Functions in Mex-Files::  
+* Getting Started with Mex-Files::
+* Working with Matrices and Arrays in Mex-Files::
+* Character Strings in Mex-Files::
+* Cell Arrays with Mex-Files::
+* Structures with Mex-Files::
+* Sparse Matrices with Mex-Files::
+* Calling Other Functions in Mex-Files::
 @c * Application Programming Interface for Mex-Files::  
 @end menu
 
 @node Getting Started with Mex-Files
 @subsection Getting Started with Mex-Files
 
 The basic command to build a mex-file is either @code{mkoctfile --mex}
 or @code{mex}.  The first command can be used either from within Octave or from
@@ -1302,19 +1298,19 @@ Consider the following short example:
 @example
 @group
 @EXAMPLEFILE(myhello.c)
 @end group
 @end example
 
 The first line @code{#include "mex.h"} makes available all of the definitions
 necessary for a mex-file.  One important difference between Octave and
-@sc{matlab} is that the header file @code{"matrix.h"} is implicitly included
-through the inclusion of @code{"mex.h"}.  This is necessary to avoid a conflict
-with the Octave file @code{"Matrix.h"} for operating systems and compilers that
+@sc{matlab} is that the header file @qcode{"matrix.h"} is implicitly included
+through the inclusion of @qcode{"mex.h"}.  This is necessary to avoid a conflict
+with the Octave file @qcode{"Matrix.h"} for operating systems and compilers that
 don't distinguish between filenames in upper and lower case.
 
 The entry point into the mex-file is defined by @code{mexFunction}.  The
 function takes four arguments:
 
 @enumerate 1
 @item The number of return arguments (# of left-hand side args).
 
@@ -1512,19 +1508,17 @@ consecutive in any case.
 @subsection Cell Arrays with Mex-Files
 
 One can perform exactly the same operations on Cell arrays in mex-files
 as in oct-files.  An example that reduplicates the function of
 the @file{celldemo.cc} oct-file in a mex-file is given by @file{mycell.c}
 as shown below.
 
 @example
-@group
 @EXAMPLEFILE(mycell.c)
-@end group
 @end example
 
 @noindent
 The output is identical to the oct-file version as well.
 
 @example
 @group
 [b1, b2, b3] = mycell (@{1, [1, 2], "test"@})
@@ -1612,33 +1606,33 @@ a(2).f1 = "f21"; a(2).f2 = "f22";
 b = mystruct (a)
 @result{} field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
     b =
     @{
       this =
-    
+
       (,
         [1] = this1
         [2] = this2
         [3] = this3
         [4] = this4
       ,)
-    
+
       that =
-    
+
       (,
         [1] = that1
         [2] = that2
         [3] = that3
         [4] = that4
       ,)
-    
+
     @}
 @end example
 
 @node Sparse Matrices with Mex-Files
 @subsection Sparse Matrices with Mex-Files
 
 The Octave format for sparse matrices is identical to the mex format in
 that it is a compressed column sparse format.  Also in both, sparse
@@ -1732,19 +1726,17 @@ within a mex-file.
 
 The libraries Octave itself uses can be utilized in standalone
 applications.  These applications then have access, for example, to the
 array and matrix classes, as well as to all of the Octave algorithms.  The
 following C++ program, uses class Matrix from @file{liboctave.a} or
 @file{liboctave.so}.
 
 @example
-@group
 @EXAMPLEFILE(standalone.cc)
-@end group
 @end example
 
 @noindent
 mkoctfile can be used to build a standalone application with a
 command like
 
 @example
 @group
@@ -1761,19 +1753,17 @@ Note that the application @code{standalo
 against the Octave libraries and any Octave support libraries.  The above
 allows the Octave math libraries to be used by an application.  It does
 not, however, allow the script files, oct-files, or builtin functions of
 Octave to be used by the application.  To do that the Octave interpreter
 needs to be initialized first.  An example of how to do this can then be
 seen in the code
 
 @example
-@group
 @EXAMPLEFILE(embedded.cc)
-@end group
 @end example
 
 @noindent
 which, as before, is compiled and run as a standalone application with
 
 @example
 @group
 $ mkoctfile --link-stand-alone embedded.cc -o embedded
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -25,28 +25,28 @@
 
 Complicated Octave programs can often be simplified by defining
 functions.  Functions can be defined directly on the command line during
 interactive Octave sessions, or in external files, and can be called just
 like built-in functions.
 
 @menu
 * Introduction to Function and Script Files::
-* Defining Functions::          
-* Multiple Return Values::      
-* Variable-length Argument Lists::  
-* Ignoring Arguments::  
-* Variable-length Return Lists::  
-* Returning from a Function::   
-* Default Arguments::   
-* Function Files::              
-* Script Files::                
-* Function Handles Inline Functions and Anonymous Functions::
+* Defining Functions::
+* Multiple Return Values::
+* Variable-length Argument Lists::
+* Ignoring Arguments::
+* Variable-length Return Lists::
+* Returning from a Function::
+* Default Arguments::
+* Function Files::
+* Script Files::
+* Function Handles Anonymous Functions Inline Functions::
 * Commands::
-* Organization of Functions::   
+* Organization of Functions::
 @end menu
 
 @node Introduction to Function and Script Files
 @section Introduction to Function and Script Files
 
 There are seven different things covered in this section.
 @enumerate
 @item
@@ -109,17 +109,17 @@ on your terminal (assuming that it is po
 @group
 function wakeup
   printf ("\a");
 endfunction
 @end group
 @end example
 
 The @code{printf} statement (@pxref{Input and Output}) simply tells
-Octave to print the string @code{"\a"}.  The special character @samp{\a}
+Octave to print the string @qcode{"\a"}.  The special character @samp{\a}
 stands for the alert character (ASCII 7).  @xref{Strings}.
 
 Once this function is defined, you can ask Octave to evaluate it by
 typing the name of the function.
 
 Normally, you will want to pass some information to the functions you
 define.  The syntax for passing parameters to a function in Octave is
 
@@ -320,17 +320,17 @@ endfunction
 In this particular case, the two values could have been returned as
 elements of a single array, but that is not always possible or
 convenient.  The values to be returned may not have compatible
 dimensions, and it is often desirable to give the individual return
 values distinct names.
 
 It is possible to use the @code{nthargout} function to obtain only some
 of the return values or several at once in a cell array.
-@ref{Cell Array Objects}
+@xref{Cell Array Objects}.
 
 @DOCSTRING(nthargout)
 
 In addition to setting @code{nargin} each time a function is called,
 Octave also automatically initializes @code{nargout} to the number of
 values that are expected to be returned.  This allows you to write
 functions that behave differently depending on the number of values that
 the user of the function has requested.  The implicit assignment to the
@@ -397,17 +397,17 @@ For compatibility with @sc{matlab}, @cod
 @code{nargoutchk} are available which provide similar error checking.
 
 @DOCSTRING(nargchk)
 
 @DOCSTRING(narginchk)
 
 @DOCSTRING(nargoutchk)
 
-@anchor{docXvarargin} @anchor{docXvarargout}
+@anchor{XREFvarargin} @anchor{XREFvarargout}
 @node Variable-length Argument Lists
 @section Variable-length Argument Lists
 @cindex variable-length argument lists
 @cindex @code{varargin}
 
 Sometimes the number of input arguments is not known when the function
 is defined.  As an example think of a function that returns the smallest
 of all its input arguments.  For example:
@@ -732,17 +732,17 @@ will not change, so it doesn't have to c
 functions defined in those files are used.  This is normally a very good
 assumption and provides a significant improvement in performance for the
 function files that are distributed with Octave.
 
 If you know that your own function files will not change while you are
 running Octave, you can improve performance by calling
 @code{ignore_function_time_stamp ("all")}, so that Octave will
 ignore the time stamps for all function files.  Passing
-@code{"system"} to this function resets the default behavior.
+@qcode{"system"} to this function resets the default behavior.
 
 @c FIXME -- note about time stamps on files in NFS environments?
 
 @DOCSTRING(edit)
 
 @DOCSTRING(mfilename)
 
 @DOCSTRING(ignore_function_time_stamp)
@@ -1145,17 +1145,17 @@ An overloaded function of a class as in 
 
 @item Legacy Dispatch
 An overloaded function as defined by @code{dispatch}.
 
 @item Command-line Function
 A function that has been defined on the command-line.
 
 @item Autoload function
-A function that is marked as autoloaded with @xref{docXautoload}.
+A function that is marked as autoloaded with @xref{XREFautoload,,autoload}.
 
 @item A Function on the Path
 A function that can be found on the users load-path.  There can also be
 Oct-file, mex-file or m-file versions of this function and the precedence
 between these versions are in that order.
 
 @item Built-in function
 A function that is builtin to Octave itself such as @code{numel},
@@ -1261,21 +1261,21 @@ string might come from user input, or de
 known until the function is evaluated).
 
 Although Octave normally executes commands from script files that have
 the name @file{@var{file}.m}, you can use the function @code{source} to
 execute commands from any file.
 
 @DOCSTRING(source)
 
-@node Function Handles Inline Functions and Anonymous Functions
-@section Function Handles, Inline Functions, and Anonymous Functions
+@node Function Handles Anonymous Functions Inline Functions
+@section Function Handles, Anonymous Functions, Inline Functions
 @cindex handle, function handles
+@cindex anonymous functions
 @cindex inline, inline functions
-@cindex anonymous functions
 
 It can be very convenient store a function in a variable so that it
 can be passed to a different function.  For example, a function that
 performs numerical minimization needs access to the function that 
 should be minimized.
 
 @menu
 * Function Handles::
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -21,85 +21,84 @@ function geometryimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (! __have_feature__ ("QHULL")
-      && (strcmp (nm, "voronoi") || strcmp (nm, "griddata")
-          || strcmp (nm, "convhull") || strcmp (nm, "delaunay")
-          || strcmp (nm, "triplot")))
-    sombreroimage (nm, typ);
+      && any (strcmp (nm, {"voronoi", "griddata", "convhull", "delaunay", ...
+                           "triplot"})))
+    sombreroimage (nm, typ, d_typ);
   elseif (strcmp (typ, "txt"))
     image_as_txt (nm);
   elseif (strcmp (nm, "voronoi"))
-    rand("state",9);
-    x = rand(10,1);
-    y = rand(10,1);
+    rand ("state", 9);
+    x = rand (10, 1);
+    y = rand (10, 1);
     tri = delaunay (x, y);
     [vx, vy] = voronoi (x, y, tri);
     triplot (tri, x, y, "b");
     hold on;
     plot (vx, vy, "r");
     [r, c] = tri2circ (tri(end,:), x, y);
     pc = [-1:0.01:1];
-    xc = r * sin(pi*pc) + c(1);
-    yc = r * cos(pi*pc) + c(2);
+    xc = r * sin (pi*pc) + c(1);
+    yc = r * cos (pi*pc) + c(2);
     plot (xc, yc, "g-", "LineWidth", 3);
     axis([0, 1, 0, 1]);
     legend ("Delaunay Triangulation", "Voronoi Diagram");
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "triplot"))
     rand ("state", 2)
     x = rand (20, 1);
     y = rand (20, 1);
     tri = delaunay (x, y);
     triplot (tri, x, y);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "griddata"))
-    rand("state",1);
-    x=2*rand(1000,1)-1;
-    y=2*rand(size(x))-1;
-    z=sin(2*(x.^2+y.^2));
-    [xx,yy]=meshgrid(linspace(-1,1,32));
-    griddata(x,y,z,xx,yy);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    rand ("state", 1);
+    x = 2 * rand (1000,1) - 1;
+    y = 2 * rand (size (x)) - 1;
+    z = sin (2 * (x.^2 + y.^2));
+    [xx,yy] = meshgrid (linspace (-1,1,32));
+    griddata (x,y,z,xx,yy);
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "convhull"))
     x = -3:0.05:3;
     y = abs (sin (x));
     k = convhull (x, y);
-    plot (x(k),y(k),'r-',x,y,'b+');
+    plot (x(k),y(k),'r-', x,y,'b+');
     axis ([-3.05, 3.05, -0.05, 1.05]);
-    print (cstrcat (nm, ".", typ), d_typ) 
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "delaunay"))
     rand ("state", 1);
     x = rand (1, 10);
     y = rand (1, 10);
     T = delaunay (x, y);
     X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
     Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
     axis ([0, 1, 0, 1]);
-    plot(X, Y, "b", x, y, "r*");
-    print (cstrcat (nm, ".", typ), d_typ) 
+    plot (X,Y,"b", x,y,"r*");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "inpolygon"))
     randn ("state", 2);
     x = randn (100, 1);
     y = randn (100, 1);
     vx = cos (pi * [-1 : 0.1: 1]);
     vy = sin (pi * [-1 : 0.1 : 1]);
     in = inpolygon (x, y, vx, vy);
-    plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
+    plot (vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
     axis ([-2, 2, -2, 2]);
-    print (cstrcat (nm, ".", typ), d_typ) 
+    print ([nm "." typ], d_typ);
   else
     error ("unrecognized plot requested");
   endif
   hide_output ();
 endfunction
 
 function [r, c] = tri2circ (tri, xx, yy)
   x = xx(tri);
@@ -124,49 +123,42 @@ endfunction
 ## Use this function before plotting commands and after every call to
 ## print since print() resets output to stdout (unfortunately, gnpulot
 ## can't pop output as it can the terminal type).
 function hide_output ()
   f = figure (1);
   set (f, "visible", "off");
 endfunction
 
-function sombreroimage (nm, typ)
+function sombreroimage (nm, typ, d_typ)
   if (strcmp (typ, "txt"))
     fid = fopen (sprintf ("%s.txt", nm), "wt");
     fputs (fid, "+-----------------------------+\n");
     fputs (fid, "| Image unavailable because   |\n");
     fputs (fid, "| of a missing QHULL library. |\n");
     fputs (fid, "+-----------------------------+\n");
     fclose (fid);
     return;
   else ## if (!strcmp (typ, "txt"))
 
     hide_output ();
-    if (strcmp (typ, "eps"))
-      d_typ = "-depsc2";
-    else
-      d_typ = cstrcat ("-d", typ);
-    endif
 
-    x = y = linspace (-8, 8, 41)';
-    [xx, yy] = meshgrid (x, y);
-    r = sqrt (xx .^ 2 + yy .^ 2) + eps;
-    z = sin (r) ./ r;
+    [x, y, z] = sombrero ();
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics not available because octave was\\ncompiled without the QHULL library.");
     unwind_protect_cleanup
-      print (cstrcat (nm, ".", typ), d_typ);
+      print ([nm "." typ], d_typ);
       hide_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
-function image_as_txt(nm)
+function image_as_txt (nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
   fputs (fid, "\n");
   fputs (fid, "+---------------------------------+\n");
   fputs (fid, "| Image unavailable in text mode. |\n");
   fputs (fid, "+---------------------------------+\n");
   fclose (fid);
 endfunction
+
diff --git a/doc/interpreter/grammar.txi b/doc/interpreter/grammar.txi
--- a/doc/interpreter/grammar.txi
+++ b/doc/interpreter/grammar.txi
@@ -20,18 +20,18 @@
 @appendix Grammar and Parser
 @cindex grammar rules
 @cindex language definition
 
 This appendix will eventually contain a semi-formal description of
 Octave's language.
 
 @menu
-* Keywords::                    
-* Parser::                    
+* Keywords::
+* Parser::
 @end menu
 
 @node Keywords
 @section Keywords
 @cindex keywords
 
 The following identifiers are keywords, and may not be used as variable
 or function names:
@@ -73,14 +73,14 @@ In addition, there are three non-specifi
 periodic evaluation.  @code{remove_input_event_hook} will stop a user function
 from being evaluated periodically.
 
 @DOCSTRING(add_input_event_hook)
 
 @DOCSTRING(remove_input_event_hook)
 
 Finally, when the parser cannot identify an input token it calls a particular
-function to handle this.  By default, this is the function "unimplemented"
-which makes suggestions about possible Octave substitutes for @sc{matlab}
-functions.
+function to handle this.  By default, this is the internal function
+@qcode{"__unimplemented__"} which makes suggestions about possible Octave
+substitutes for @sc{matlab} functions.
 
 @DOCSTRING(missing_function_hook)
 
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -31,20 +31,20 @@ expected to take a long time a script ca
 Several utility functions make it possible to store private data for use with
 a GUI which will not pollute the user's variable space.
 
 Finally, a program written in Octave might want to have long term storage of
 preferences or state variables.  This can be done with user-defined
 preferences.
 
 @menu
-* I/O Dialogs::       
-* Progress Bar::       
-* GUI Utility Functions::       
-* User-Defined Preferences::       
+* I/O Dialogs::
+* Progress Bar::
+* GUI Utility Functions::
+* User-Defined Preferences::
 @end menu
 
 @node I/O Dialogs
 @section I/O Dialogs
 
 Simple dialog menus are available for choosing directories or files.  They
 return a string variable which can then be used with any command requiring
 a file name.
@@ -76,18 +76,22 @@ programs that do.  @strong{Warning:} The
 
 @DOCSTRING(uiresume)
 
 @DOCSTRING(waitfor)
 
 @node User-Defined Preferences
 @section User-Defined Preferences
 
+@DOCSTRING(getpref)
+
+@DOCSTRING(setpref)
+
 @DOCSTRING(addpref)
 
-@DOCSTRING(getpref)
+@DOCSTRING(rmpref)
 
 @DOCSTRING(ispref)
 
-@DOCSTRING(rmpref)
+@DOCSTRING(prefdir)
 
-@DOCSTRING(setpref)
+@DOCSTRING(preferences)
 
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -14,17 +14,17 @@
 @c 
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Image Processing
 @chapter Image Processing
 
-Since an image basically is a matrix Octave is a very powerful
+Since an image is basically a matrix, Octave is a very powerful
 environment for processing and analyzing images.  To illustrate
 how easy it is to do image processing in Octave, the following
 example will load an image, smooth it by a 5-by-5 averaging filter,
 and compute the gradient of the smoothed image.
 
 @example
 @group
 I = imread ("myimage.jpg");
@@ -33,30 +33,29 @@ S = conv2 (I, ones (5, 5) / 25, "same");
 @end group
 @end example
 
 @noindent
 In this example @code{S} contains the smoothed image, and @code{Dx}
 and @code{Dy} contains the partial spatial derivatives of the image.
 
 @menu
-* Loading and Saving Images::   
-* Displaying Images::           
-* Representing Images::         
-* Plotting on top of Images::   
-* Color Conversion::            
+* Loading and Saving Images::
+* Displaying Images::
+* Representing Images::
+* Plotting on top of Images::
+* Color Conversion::
 @end menu
 
 @node Loading and Saving Images
 @section Loading and Saving Images
 
 The first step in most image processing tasks is to load an image
-into Octave.  This is done using the @code{imread} function, which uses the
-@code{GraphicsMagick} library for reading.  This means a vast number of image
-formats is supported.  The @code{imwrite} function is the corresponding function
+into Octave which is done with the @code{imread} function.
+The @code{imwrite} function is the corresponding function
 for writing images to the disk.
 
 In summary, most image processing code will follow the structure of this code
 
 @example
 @group
 I = imread ("my_input_image.img");
 J = process_my_image (I);
@@ -72,16 +71,40 @@ imwrite (J, "my_output_image.img");
 
 It is possible to get information about an image file on disk, without actually
 reading it into Octave.  This is done using the @code{imfinfo} function which
 provides read access to many of the parameters stored in the header of the image
 file.
 
 @DOCSTRING(imfinfo)
 
+By default, Octave's image IO functions (@code{imread}, @code{imwrite},
+and @code{imfinfo}) use the @code{GraphicsMagick} library for their
+operations.  This means a vast number of image formats is supported
+but considering the large amount of image formats in science and
+its commonly closed nature, it is impossible to have a library
+capable of reading them all.  Because of this, the function
+@code{imformats} keeps a configurable list of available formats,
+their extensions, and what functions should the image IO functions
+use.  This allows to expand Octave's image IO capabilities by
+creating functions aimed at acting on specific file formats.
+
+While it would be possible to call the extra functions directly,
+properly configuring Octave with @code{imformats} allows to keep a
+consistent code that is abstracted from file formats.
+
+It is important to note that a file format is not actually defined by its
+file extension and that @code{GraphicsMagick} is capable to read and write
+more file formats than the ones listed by @code{imformats}.  What this
+means is that even with an incorrect or missing extension the image may
+still be read correctly, and that even unlisted formats are not necessarily
+unsupported.
+
+@DOCSTRING(imformats)
+
 @node Displaying Images
 @section Displaying Images
 
 A natural part of image processing is visualization of an image.
 The most basic function for this is the @code{imshow} function that
 shows the image given in the first input argument.
 
 @DOCSTRING(imshow)
@@ -176,17 +199,17 @@ colors with integer values of the red, g
 is a workaround for a limitation of gnuplot 4.0, that does not allow the color
 of line or patch objects to be set.  @code{gmap40} is chiefly useful to gnuplot
 4.0 users, and particularly in conjunction with the @var{bar}, @var{surf},
 and @var{contour} functions.
 
 @DOCSTRING(gmap40)
 
 The following three functions modify the existing colormap rather than
-replace it.   
+replace it.
 
 @DOCSTRING(brighten)
 
 @DOCSTRING(spinmap)
 
 @DOCSTRING(whitebg)
 
 The following functions can be used to manipulate colormaps.
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -20,16 +20,17 @@
 @c distribution, as well as in the Octave manual.
 
 @ifclear INSTALLONLY
 @node Installation
 @appendix Installing Octave
 @end ifclear
 
 @ifset INSTALLONLY
+@include macros.texi
 
 This file documents the installation of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation.
 
 @strong{Note}: This file is automatically generated from
@@ -174,17 +175,17 @@ Automake.
 @node External Packages
 @subsection External Packages
 
 The following external packages are required:
 
 @table @asis
 @item BLAS
 Basic Linear Algebra Subroutine library
-(@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
+(@url{http://www.netlib.org/blas}).  Accelerated @sc{blas} libraries such as
 ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
 better performance.
 
 @item LAPACK
 Linear Algebra Package (@url{http://www.netlib.org/lapack}).
 
 @item PCRE
 The Perl Compatible Regular Expression library (@url{http://www.pcre.org}).
@@ -200,17 +201,17 @@ Command-line editing library (@url{www.g
 If you wish to build Octave without GNU readline installed, you must use
 the @option{--disable-readline} option when running the configure script.
 
 The following external software packages are optional but recommended:
 
 @table @asis
 @item ARPACK
 Library for the solution of large-scale eigenvalue problems
-(@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
+(@url{http://forge.scilab.org/index.php/p/arpack-ng}).  @sc{arpack} is
 required to provide the functions @code{eigs} and @code{svds}.
 
 @item cURL
 Library for transferring data with URL syntax
 (@url{http://curl.haxx.se}).  cURL is required to provide the
 @code{urlread} and @code{urlwrite} functions and the @code{ftp} class.
 
 @item FFTW3
@@ -242,17 +243,17 @@ is currently the default graphics render
 
 @item GraphicsMagick++
 Image processing library (@url{http://www.graphicsmagick.org}).
 GraphicsMagick++ is used to provide the @code{imread} and @code{imwrite}
 functions.
 
 @item HDF5
 Library for manipulating portable data files
-(@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
+(@url{http://www.hdfgroup.org/HDF5}).  @sc{hdf5} is required for Octave's
 @code{load} and @code{save} commands to read and write HDF data files.
 
 @item LLVM
 Compiler framework, (@url{http://www.llvm.org}).  LLVM is required for
 Octave's experimental just-in-time (JIT) compilation for speeding up the
 interpreter.
 
 @item OpenGL
@@ -378,17 +379,17 @@ By default, configure looks for the best
 your system, including optimized implementations such as the free ATLAS
 3.0, as well as vendor-tuned libraries.  (The use of an optimized
 @sc{lapack} will generally result in several-times faster matrix
 operations.)  Use this option to specify a particular @sc{lapack}
 library that Octave should use.
 
 @item --with-magick=<lib>
 Select the library to use for image I/O@.  The two possible values are
-"GraphicsMagick" (default) or "ImageMagick".
+@qcode{"GraphicsMagick"} (default) or @qcode{"ImageMagick"}.
 
 @item --with-sepchar=<char>
 Use <char> as the path separation character.  This option can help when
 running Octave on non-Unix systems.
 
 @item --without-amd
 Don't use @sc{amd}, disable some sparse matrix functionality.
 
@@ -512,17 +513,17 @@ make CFLAGS=-O CXXFLAGS=-O LDFLAGS=
 @noindent
 instead of just @command{make}.
 
 @item
 If you encounter errors while compiling Octave, first check the list of
 known problems below to see if there is a workaround or solution for
 your problem.  If not,
 @ifclear INSTALLONLY
-see @ref{Trouble},
+@pxref{Trouble},
 @end ifclear
 @ifset INSTALLONLY
 see the file BUGS
 @end ifset
 for information about how to report bugs.
 
 @item
 Once you have successfully compiled Octave, run @code{make install}.
@@ -564,17 +565,17 @@ Executables to be run by Octave rather t
 @item @var{prefix}/lib/octave/@var{version}/oct/@var{arch}
 Object files that will be dynamically loaded.
 
 @item @var{prefix}/share/octave/@var{version}/imagelib
 Image files that are distributed with Octave.
 @end table
 @end itemize
 
-@node Compiling Octave with 64-bit Indexing  
+@node Compiling Octave with 64-bit Indexing
 @section Compiling Octave with 64-bit Indexing
 
 Note: the following only applies to systems that have 64-bit pointers.
 Configuring Octave with @option{--enable-64} cannot magically make a
 32-bit system have a 64-bit address space.
 
 On 64-bit systems, Octave is limited to (approximately) the following
 array sizes when using the default 32-bit indexing mode:
@@ -1059,12 +1060,12 @@ proper thing to do.
 If Octave is unable to find a header file because it is installed in a
 location that is not normally searched by the compiler, you can add the
 directory to the include search path by specifying (for example)
 @code{CPPFLAGS=-I/some/nonstandard/directory} as an argument to
 @code{configure}.  Other variables that can be specified this way are
 @env{CFLAGS}, @env{CXXFLAGS}, @env{FFLAGS}, and @env{LDFLAGS}.  Passing
 them as options to the configure script also records them in the
 @file{config.status} file.  By default, @env{CPPFLAGS} and @env{LDFLAGS}
-are empty, @env{CFLAGS} and @env{CXXFLAGS} are set to @code{"-g -O"} and
-@env{FFLAGS} is set to @code{"-O"}.
+are empty, @env{CFLAGS} and @env{CXXFLAGS} are set to @qcode{"-g -O"} and
+@env{FFLAGS} is set to @qcode{"-O"}.
 
 @end itemize
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -24,65 +24,65 @@
 * Multi-dimensional Interpolation::
 @end menu
 
 @node One-dimensional Interpolation
 @section One-dimensional Interpolation
 
 Octave supports several methods for one-dimensional interpolation, most
 of which are described in this section.  @ref{Polynomial Interpolation}
-and @ref{Interpolation on Scattered Data} describe further methods.
+and @ref{Interpolation on Scattered Data} describe additional methods.
 
 @DOCSTRING(interp1)
 
 There are some important differences between the various interpolation
-methods.  The 'spline' method enforces that both the first and second
+methods.  The @qcode{"spline"} method enforces that both the first and second
 derivatives of the interpolated values have a continuous derivative,
 whereas the other methods do not.  This means that the results of the
-'spline' method are generally smoother.  If the function to be
-interpolated is in fact smooth, then 'spline' will give excellent
+@qcode{"spline"} method are generally smoother.  If the function to be
+interpolated is in fact smooth, then @qcode{"spline"} will give excellent
 results.  However, if the function to be evaluated is in some manner
-discontinuous, then 'pchip' interpolation might give better results.
+discontinuous, then @qcode{"pchip"} interpolation might give better results.
 
 This can be demonstrated by the code
 
 @example
 @group
 t = -2:2;
 dt = 1;
 ti =-2:0.025:2;
 dti = 0.025;
 y = sign (t);
-ys = interp1 (t,y,ti,'spline');
-yp = interp1 (t,y,ti,'pchip');
+ys = interp1 (t,y,ti,"spline");
+yp = interp1 (t,y,ti,"pchip");
 ddys = diff (diff (ys)./dti) ./ dti;
 ddyp = diff (diff (yp)./dti) ./ dti;
 figure (1);
 plot (ti,ys,'r-', ti,yp,'g-');
-legend ('spline', 'pchip', 4);
+legend ("spline", "pchip", 4);
 figure (2);
 plot (ti,ddys,'r+', ti,ddyp,'g*');
-legend ('spline', 'pchip');
+legend ("spline", "pchip");
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:interpderiv1} and
 @ref{fig:interpderiv2}.
 
 @float Figure,fig:interpderiv1
 @center @image{interpderiv1,4in}
-@caption{Comparison of 'pchip' and 'spline' interpolation methods for a 
+@caption{Comparison of @qcode{"pchip"} and @qcode{"spline"} interpolation methods for a 
 step function}
 @end float
 
 @float Figure,fig:interpderiv2
 @center @image{interpderiv2,4in}
-@caption{Comparison of the second derivative of the 'pchip' and 'spline' 
+@caption{Comparison of the second derivative of the @qcode{"pchip"} and @qcode{"spline"} 
 interpolation methods for a step function}
 @end float
 @end ifnotinfo
 
 A simplified version of @code{interp1} that performs only linear
 interpolation is available in @code{interp1q}.  This argument is slightly
 faster than @code{interp1} as to performs little error checking.
 
@@ -102,19 +102,19 @@ points.  An example of the use of @code{
 
 @example
 @group
 t = 0 : 0.3 : pi; dt = t(2)-t(1);
 n = length (t); k = 100;
 ti = t(1) + [0 : k-1]*dt*n/k;
 y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-plot (ti, yp, 'g', ti, interp1 (t, y, ti, 'spline'), 'b', ...
-      ti, interpft (y, k), 'c', t, y, 'r+');
-legend ('sin(4t+0.3)cos(3t-0.1', 'spline', 'interpft', 'data');
+plot (ti, yp, "g", ti, interp1 (t, y, ti, "spline"), "b", ...
+      ti, interpft (y, k), "c", t, y, 'r+');
+legend ('sin(4t+0.3)cos(3t-0.1', "spline", "interpft", "data");
 @end group
 @end example
 
 @noindent
 @ifinfo
 which demonstrates the poor behavior of Fourier interpolation for non-periodic
 functions.
 @end ifinfo
@@ -123,19 +123,18 @@ which demonstrates the poor behavior of 
 functions, as can be seen in @ref{fig:interpft}.
 
 @float Figure,fig:interpft
 @center @image{interpft,4in}
 @caption{Comparison of @code{interp1} and @code{interpft} for non-periodic data}
 @end float
 @end ifnotinfo
 
-In additional the support function @code{spline} and @code{lookup} that
+In addition, the support functions @code{spline} and @code{lookup} that
 underlie the @code{interp1} function can be called directly.
-@ref{Finding Elements and Checking Conditions}
 
 @DOCSTRING(spline)
 
 @node Multi-dimensional Interpolation
 @section Multi-dimensional Interpolation
 
 There are three multi-dimensional interpolation functions in Octave, with
 similar capabilities.  Methods using Delaunay tessellation are described
@@ -144,34 +143,33 @@ in @ref{Interpolation on Scattered Data}
 @DOCSTRING(interp2)
 
 @DOCSTRING(interp3)
 
 @DOCSTRING(interpn)
 
 A significant difference between @code{interpn} and the other two
 multi-dimensional interpolation functions is the fashion in which the
-dimensions are treated.  For @code{interp2} and @code{interp3}, the 'y'
-axis is considered to be the columns of the matrix, whereas the 'x'
-axis corresponds to the rows of the array.  As Octave indexes arrays in
-column major order, the first dimension of any array is the columns, and
-so @code{interpn} effectively reverses the 'x' and 'y' dimensions. 
-Consider the example,
+dimensions are treated.  For @code{interp2} and @code{interp3}, the y-axis is
+considered to be the columns of the matrix, whereas the x-axis corresponds to
+the rows of the array.  As Octave indexes arrays in column major order, the
+first dimension of any array is the columns, and so @code{interpn} effectively
+reverses the 'x' and 'y' dimensions.  Consider the example,
 
 @example
 @group
 x = y = z = -1:1;
 f = @@(x,y,z) x.^2 - y - z.^2;
 [xx, yy, zz] = meshgrid (x, y, z);
 v = f (xx,yy,zz);
 xi = yi = zi = -1:0.1:1;
 [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-vi = interp3 (x, y, z, v, xxi, yyi, zzi, 'spline');
+vi = interp3 (x, y, z, v, xxi, yyi, zzi, "spline");
 [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-vi2 = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
+vi2 = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
 mesh (zi, yi, squeeze (vi2(1,:,:)));
 @end group
 @end example
 
 @noindent
 where @code{vi} and @code{vi2} are identical.  The reversal of the
 dimensions is treated in the @code{meshgrid} and @code{ndgrid} functions
 respectively.
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -21,63 +21,63 @@ function interpimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d", typ];
   endif
 
   if (strcmp (typ, "txt"))
     image_as_txt (nm);
   elseif (strcmp (nm, "interpft"))
     t = 0 : 0.3 : pi; dt = t(2)-t(1);
     n = length (t); k = 100;
     ti = t(1) + [0 : k-1]*dt*n/k;
     y = sin (4*t + 0.3) .* cos (3*t - 0.1);
     yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-    plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
-          ti, interpft (y, k), 'c', t, y, 'r+');
-    legend ('sin(4t+0.3)cos(3t-0.1)','spline','interpft','data');
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (ti, yp, "g", ti, interp1 (t, y, ti, "spline"), "b", ...
+          ti, interpft (y, k), "c", t, y, "r+");
+    legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpn"))
     x = y = z = -1:1;
     f = @(x,y,z) x.^2 - y - z.^2;
     [xx, yy, zz] = meshgrid (x, y, z);
     v = f (xx,yy,zz);
     xi = yi = zi = -1:0.1:1;
     [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-    vi = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+    vi = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
     mesh (zi, yi, squeeze (vi(1,:,:)));
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpderiv1"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
-    y = sign(t);
-    ys = interp1(t,y,ti,'spline');
-    yp = interp1(t,y,ti,'pchip');
-    plot (ti, ys,'r-', ti, yp,'g-');
-    legend('spline','pchip', 4);
-    print (cstrcat (nm, ".", typ), d_typ)
+    y = sign (t);
+    ys = interp1 (t,y,ti,"spline");
+    yp = interp1 (t,y,ti,"pchip");
+    plot (ti, ys,"r-", ti, yp,"g-");
+    legend ("spline","pchip", 4);
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpderiv2"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
-    y = sign(t);
-    ddys = diff(diff(interp1(t,y,ti,'spline'))./dti)./dti;
-    ddyp = diff(diff(interp1(t,y,ti,'pchip'))./dti)./dti;
-    plot (ti(2:end-1),ddys,'r*', ti(2:end-1),ddyp,'g+');
-    legend('spline','pchip');
-    print (cstrcat (nm, ".", typ), d_typ)
+    y = sign (t);
+    ddys = diff (diff (interp1 (t,y,ti,"spline"))./dti)./dti;
+    ddyp = diff (diff (interp1 (t,y,ti,"pchip"))./dti)./dti;
+    plot (ti(2:end-1),ddys,"r*", ti(2:end-1),ddyp,"g+");
+    legend ("spline", "pchip");
+    print ([nm "." typ], d_typ);
   endif
   hide_output ();  
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
@@ -98,8 +98,9 @@ endfunction
 function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
   fputs (fid, "\n");
   fputs (fid, "+---------------------------------+\n");
   fputs (fid, "| Image unavailable in text mode. |\n");
   fputs (fid, "+---------------------------------+\n");
   fclose (fid);
 endfunction
+
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -24,28 +24,28 @@ GNU Octave is a high-level language, pri
 computations.  It provides a convenient interactive command line 
 interface for solving linear and nonlinear problems numerically, and 
 for performing other numerical experiments.  It may also be used as a 
 batch-oriented language for data processing.
 
 GNU Octave is freely redistributable software.  You may redistribute 
 it and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation.  The GPL is included in 
-this manual in @ref{Copying}.
+this manual, @pxref{Copying}.
 
 This manual provides comprehensive documentation on how to install, 
 run, use, and extend GNU Octave.  Additional chapters describe how 
 to report bugs and help contribute code.
 
 This document corresponds to Octave version @value{VERSION}.
 
 @menu
-* Running Octave::              
-* Simple Examples::             
-* Conventions::                 
+* Running Octave::
+* Simple Examples::
+* Conventions::
 @end menu
 
 @node Running Octave
 @section Running Octave
 
 On most systems, Octave is started with the shell command 
 @samp{octave}.  Octave displays an initial message and then a prompt
 indicating it is ready to accept input.  You can begin typing Octave
@@ -369,17 +369,17 @@ commands using Emacs- or vi-style editin
 keybindings use Emacs-style commands.  For example, to recall the
 previous command, press @kbd{Control-p} (written @kbd{C-p} for
 short).  Doing this will normally bring back the previous line of input.
 @kbd{C-n} will bring up the next line of input, @kbd{C-b} will move
 the cursor backward on the line, @kbd{C-f} will move the cursor forward
 on the line, etc.
 
 A complete description of the command line editing capability is given
-in this manual in @ref{Command Line Editing}.
+in this manual, @pxref{Command Line Editing}.
 
 @subsection Help and Documentation
 
 Octave has an extensive help facility.  The same documentation that is
 available in printed form is also available from the Octave prompt,
 because both forms of the documentation are created from the same input
 file.
 
@@ -405,30 +405,30 @@ will display the help text for the @code
 Octave sends output that is too long to fit on one screen through a
 pager like @code{less} or @code{more}.  Type a @key{RET} to advance one
 line, a @key{SPC} to advance one page, and @key{q} to exit the pager.
 
 The part of Octave's help facility that allows you to read the complete
 text of the printed manual from within Octave normally uses a separate
 program called Info.  When you invoke Info you will be put into a menu
 driven program that contains the entire Octave manual.  Help for using
-Info is provided in this manual in @ref{Getting Help}.
+Info is provided in this manual, @pxref{Getting Help}.
 
 @node Conventions
 @section Conventions
 
 This section explains the notational conventions that are used in this
 manual.  You may want to skip this section and refer back to it later.
 
 @menu
-* Fonts::                       
-* Evaluation Notation::         
-* Printing Notation::           
-* Error Messages::              
-* Format of Descriptions::      
+* Fonts::
+* Evaluation Notation::
+* Printing Notation::
+* Error Messages::
+* Format of Descriptions::
 @end menu
 
 @node Fonts
 @subsection Fonts
 @cindex documentation fonts
 
 Examples of Octave code appear in this font or form: @code{svd (a)}.
 Names that represent variables or function arguments appear
@@ -527,33 +527,32 @@ fieldnames ([1, 2; 3, 4])
 error: fieldnames: wrong type argument 'matrix'
 @end group
 @end example
 
 @node Format of Descriptions
 @subsection Format of Descriptions
 @cindex description format
 
-Functions, commands, and variables are described in this manual in a 
+Functions and commands are described in this manual in a 
 uniform format.  The first line of a description contains the name of
 the item followed by its arguments, if any.
 @ifnottex
-The category---function, variable, or whatever---appears at the
+The category---function, command, or whatever---appears at the
 beginning of the line.
 @end ifnottex
 @iftex
-The category---function, variable, or whatever---is printed next to the
+The category---function, command, or whatever---is printed next to the
 right margin.
 @end iftex
 The description follows on succeeding lines, sometimes with examples.
 
 @menu
-* A Sample Function Description::  
-* A Sample Command Description::  
-* A Sample Variable Description::  
+* A Sample Function Description::
+* A Sample Command Description::
 @end menu
 
 @node A Sample Function Description
 @subsubsection A Sample Function Description
 @cindex function descriptions
 
 In a function description, the name of the function being described
 appears first.  It is followed on the same line by a list of parameters.
@@ -638,32 +637,8 @@ parentheses.  For example, here is the d
 @deftypefn  {Command} {} cd dir
 @deftypefnx {Command} {} chdir dir
 Change the current working directory to @var{dir}.  For example,
 @kbd{cd ~/octave} changes the current working directory to
 @file{~/octave}.  If the directory does not exist, an error message is
 printed and the working directory is not changed.
 @end deftypefn
 
-@node A Sample Variable Description
-@subsubsection A Sample Variable Description
-@cindex variable descriptions
-
-A @dfn{variable} is a name that can hold a value.  Although any variable
-can be set by the user, @dfn{built-in variables} typically exist
-specifically so that users can change them to alter the way Octave
-behaves (built-in variables are also sometimes called @dfn{user
-options}).  Ordinary variables and built-in variables are described
-using a format like that for functions except that there are no
-arguments.
-
-Here is a description of the imaginary variable
-@code{do_what_i_mean_not_what_i_say}.
-
-@defvr {Built-in Variable} do_what_i_mean_not_what_i_say
-If the value of this variable is nonzero, Octave will do what you
-actually wanted, even if you have typed a completely different and
-meaningless list of commands.
-@end defvr
-
-Other variable descriptions have the same format, but `Built-in
-Variable' is replaced by `Variable', for ordinary variables, or
-`Constant' for symbolic constants whose values cannot be changed.
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -21,29 +21,29 @@
 
 Octave supports several ways of reading and writing data to or from the
 prompt or a file.  The simplest functions for data Input and Output
 (I/O) are easy to use, but only provide limited control of how
 data is processed.  For more control, a set of functions modeled
 after the C standard library are also provided by Octave.
 
 @menu
-* Basic Input and Output::      
-* C-Style I/O Functions::       
+* Basic Input and Output::
+* C-Style I/O Functions::
 @end menu
 
 @node Basic Input and Output
 @section Basic Input and Output
 
 @c We could use a two-line introduction here...
 
 @menu
-* Terminal Output::             
-* Terminal Input::              
-* Simple File I/O::             
+* Terminal Output::
+* Terminal Input::
+* Simple File I/O::
 @end menu
 
 @node Terminal Output
 @subsection Terminal Output
 
 Since Octave normally prints the value of an expression as soon as it
 has been evaluated, the simplest of all I/O functions is a simple
 expression.  For example, the following expression will display the
@@ -279,35 +279,35 @@ make your programs easier to understand.
 
 @DOCSTRING(stdin)
 
 @DOCSTRING(stdout)
 
 @DOCSTRING(stderr)
 
 @menu
-* Opening and Closing Files::   
-* Simple Output::               
-* Line-Oriented Input::         
-* Formatted Output::            
-* Output Conversion for Matrices::  
-* Output Conversion Syntax::    
-* Table of Output Conversions::  
-* Integer Conversions::         
+* Opening and Closing Files::
+* Simple Output::
+* Line-Oriented Input::
+* Formatted Output::
+* Output Conversion for Matrices::
+* Output Conversion Syntax::
+* Table of Output Conversions::
+* Integer Conversions::
 * Floating-Point Conversions::
-* Other Output Conversions::    
-* Formatted Input::             
-* Input Conversion Syntax::     
-* Table of Input Conversions::  
-* Numeric Input Conversions::   
-* String Input Conversions::    
-* Binary I/O::                  
-* Temporary Files::             
-* EOF and Errors::              
-* File Positioning::            
+* Other Output Conversions::
+* Formatted Input::
+* Input Conversion Syntax::
+* Table of Input Conversions::
+* Numeric Input Conversions::
+* String Input Conversions::
+* Binary I/O::
+* Temporary Files::
+* EOF and Errors::
+* File Positioning::
 @end menu
 
 @node Opening and Closing Files
 @subsection Opening and Closing Files
 
 When reading data from a file it must be opened for reading first, and
 likewise when writing to a file.  The @code{fopen} function returns a
 pointer to an open file that is ready to be read or written.  Once all
@@ -697,18 +697,18 @@ the precision.  The exponent always cont
 The @samp{%g} and @samp{%G} conversions print the argument in the style
 of @samp{%e} or @samp{%E} (respectively) if the exponent would be less
 than -4 or greater than or equal to the precision; otherwise they use the
 @samp{%f} style.  Trailing zeros are removed from the fractional portion
 of the result and a decimal-point character appears only if it is
 followed by a digit.
 
 The following flags can be used to modify the behavior:
+@c Not @samp so we can have ' ' as an item.
 
-@c Not @samp so we can have ' ' as an item.
 @table @asis
 @item @samp{-}
 Left-justify the result in the field.  Normally the result is
 right-justified.
 
 @item @samp{+}
 Always include a plus or minus sign in the result.
 
@@ -972,19 +972,19 @@ more whitespace after having read someth
 
 For example, reading the input:
 
 @example
  hello, world
 @end example
 
 @noindent
-with the conversion @samp{%10c} produces @code{" hello, wo"}, but
+with the conversion @samp{%10c} produces @qcode{" hello, wo"}, but
 reading the same input with the conversion @samp{%10s} produces
-@code{"hello,"}.
+@qcode{"hello,"}.
 
 @node Binary I/O
 @subsection Binary I/O
 
 Octave can read and write binary data using the functions @code{fread}
 and @code{fwrite}, which are patterned after the standard C functions
 with the same names.  They are able to automatically swap the byte order
 of integer data and convert among the supported floating point formats
@@ -1003,17 +1003,17 @@ within Octave needs to access data.  Whe
 files will be deleted, so this step need not be executed manually.
 
 @DOCSTRING(mkstemp)
 
 @DOCSTRING(tmpfile)
 
 @DOCSTRING(tmpnam)
 
-@node EOF and Errors, File Positioning, Temporary Files, C-Style I/O Functions
+@node EOF and Errors
 @subsection End of File and Errors
 
 Once a file has been opened its status can be acquired.  As an example
 the @code{feof} functions determines if the end of the file has been
 reached.  This can be very useful when reading small parts of a file
 at a time.  The following example shows how to read one line at a time
 from a file until the end has been reached.
 
diff --git a/doc/interpreter/java.txi b/doc/interpreter/java.txi
--- a/doc/interpreter/java.txi
+++ b/doc/interpreter/java.txi
@@ -140,23 +140,23 @@ of dialog box.
 @node FAQ - Frequently asked Questions
 @section FAQ - Frequently asked Questions
 
 @menu
 * How to distinguish between Octave and Matlab?::
 * How to make Java classes available?::
 * How to create an instance of a Java class?::
 * How can I handle memory limitations?::
-* Which @TeX{} symbols are implemented in the dialog functions?::
+* Which @TeX{} symbols are implemented in dialog functions?::
 @end menu
 
 @c ------------------------------------------------------------------------
 @node How to distinguish between Octave and Matlab?
 @subsection How to distinguish between Octave and Matlab?
-@anchor{docXFAQ}
+@anchor{XREFFAQ}
 @c - index -
 @cindex Octave and @sc{matlab}, how to distinguish between
 @c - index -
 
 Octave and @sc{matlab} are very similar, but handle Java slightly different.
 Therefore it may be necessary to detect the environment and use the appropriate
 functions.  The following function can be used to detect the environment.  Due
 to the persistent variable it can be called repeatedly without a heavy
@@ -229,17 +229,17 @@ was started from).  If such a file is fo
 @item Next, Octave searches in the user's home directory.  If a file
 @file{javaclasspath.txt} exists here, its contents are appended to the static
 classpath (if any).  Thus, it is possible to build an initial static classpath
 on a 'per user' basis.
 
 @item Finally, Octave looks for a next occurrence of file
 @file{javaclasspath.txt} in the m-files directory where Octave Java functions 
 live.  This is where @file{javaclasspath.m} resides, usually something like
-@file{@env{OCTAVE_HOME}/share/octave/@env{OCTAVE_VERSION}/m/java/}.  You can
+@file{@w{@env{OCTAVE_HOME}}/share/octave/@w{@env{OCTAVE_VERSION}}/m/java/}.  You can
 find this directory by executing the command
 
 @example
 which javaclasspath
 @end example
 
 If this file exists here, its contents are also appended to the static
 classpath.  Note that the archives and class directories defined in this last
@@ -311,31 +311,31 @@ Passenger = javaObject ('package.FirstCl
 @c ------------------------------------------------------------------------
 @node How can I handle memory limitations?
 @subsection How can I handle memory limitations?
 @cindex memory, limitations
 
 In order to execute Java code Octave creates a Java Virtual Machine (JVM).
 Such a JVM allocates a fixed amount of initial memory and may expand this pool
 up to a fixed maximum memory limit.  The default values depend on the Java
-version (see @ref{docXjavamem,,javamem}).  The memory pool is shared by all
+version (@pxref{XREFjavamem,,javamem}).  The memory pool is shared by all
 Java objects running in the JVM@.  This strict memory limit is intended mainly
 to avoid that runaway applications inside web browsers or in enterprise servers
 can consume all memory and crash the system.  When the maximum memory limit is
 hit, Java code will throw exceptions so that applications will fail or behave
 unexpectedly.
 
 You can specify options for the creation of the JVM inside a file named
 @file{java.opts}.  This is a text file where you can enter lines containing
 @option{-X} and @option{-D} options handed to the JVM during initialization.
 
 The directory where the Java options file is located is specified by the
 environment variable @w{@env{OCTAVE_JAVA_DIR}}.  If unset the directory where
 @file{javaclasspath.m} resides is used instead (typically
-@file{@env{OCTAVE_HOME}/share/octave/@env{OCTAVE_VERSION}/m/java/}).  You can
+@file{@w{@env{OCTAVE_HOME}}/share/octave/@w{@env{OCTAVE_VERSION}}/m/java/}).  You can
 find this directory by executing
 
 @example
 which javaclasspath
 @end example
 
 The @option{-X} options allow you to increase the maximum amount of memory
 available to the JVM@.  The following example allows up to 256 Megabytes to
@@ -380,18 +380,18 @@ or in Octave:
 octave> javaMethod ('getProperty', 'java.lang.System', 'MyProperty');
 ans = 12.34
 @end group
 @end example
 
 @seealso{javamem}
 
 @c ------------------------------------------------------------------------
-@node Which @TeX{} symbols are implemented in the dialog functions?
-@subsection Which @TeX{} symbols are implemented in the dialog functions?
+@node Which @TeX{} symbols are implemented in dialog functions?
+@subsection Which @TeX{} symbols are implemented in dialog functions?
 @c - index -
 @cindex symbols, translation table
 @cindex @TeX{} symbols, translation table
 @cindex translation table for @TeX{} symbols
 @c - index -
 
 The dialog functions contain a translation table for @TeX{} like symbol codes.
 Thus messages and labels can be tailored to show some common mathematical
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -21,19 +21,19 @@
 
 This chapter documents the linear algebra functions of Octave.
 Reference material for many of these functions may be found in
 Golub and Van Loan, @cite{Matrix Computations, 2nd Ed.}, Johns Hopkins,
 1989, and in the @cite{@sc{lapack} Users' Guide}, SIAM, 1992.
 
 @menu
 * Techniques Used for Linear Algebra::
-* Basic Matrix Functions::      
-* Matrix Factorizations::       
-* Functions of a Matrix::       
+* Basic Matrix Functions::
+* Matrix Factorizations::
+* Functions of a Matrix::
 * Specialized Solvers::
 @end menu
 
 @node Techniques Used for Linear Algebra
 @section Techniques Used for Linear Algebra
 
 Octave includes a polymorphic solver, that selects an appropriate
 matrix factorization depending on the properties of the matrix itself. 
@@ -91,16 +91,18 @@ flag a non-Hermitian matrix.
 @DOCSTRING(eig)
 
 @DOCSTRING(givens)
 
 @DOCSTRING(planerot)
 
 @DOCSTRING(inv)
 
+@DOCSTRING(linsolve)
+
 @DOCSTRING(matrix_type)
 
 @DOCSTRING(norm)
 
 @DOCSTRING(null)
 
 @DOCSTRING(orth)
 
diff --git a/doc/interpreter/macros.texi b/doc/interpreter/macros.texi
--- a/doc/interpreter/macros.texi
+++ b/doc/interpreter/macros.texi
@@ -11,63 +11,78 @@
 @c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 @c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 @c for more details.
 @c 
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
-@c FIXME -- someday, we might replace this with @backslashchar, which
-@c has been added to Texinfo.
+@c The following macro marks words that aspell should ignore during
+@c spellchecking.  Within Texinfo it has no effect as it merely replaces
+@c the macro call with the argument itself.
+
+@macro nospell {arg}
+\arg\
+@end macro
 
-@macro xbackslashchar
-\\
+@c The following macro works around the Info/plain text expansion of @code{XXX}
+@c which is `XXX'.  This looks particularly bad when the macro body is 
+@c single or double-quoted text, such as a property value `"position"'
+@ifinfo
+@macro qcode{arg}
+\arg\
 @end macro
+@end ifinfo
+@ifnotinfo
+@macro qcode{arg}
+@code{\arg\}
+@end macro
+@end ifnotinfo
 
 @c The following macro is used for the on-line help system, but we don't
 @c want lots of `See also: foo, bar, and baz' strings cluttering the
 @c printed manual (that information should be in the supporting text for
 @c each group of functions and variables).
 @c
 @c Implementation Note:
 @c For TeX, @vskip produces a nice separation.
-@c For Texinfo '@sp 1' should work, but in practice produces ugly results
+@c For Texinfo, '@sp 1' should work, but in practice produces ugly results
 @c for HTML.  We use a simple blank line to produce the correct behavior. 
 
 @macro seealso {args}
 @iftex
 @vskip 2pt
 @end iftex
 @ifnottex
 
 @end ifnottex
-@ifinfo
-@noindent
-See also: \args\.
-@end ifinfo
 @ifnotinfo
 @noindent
 @strong{See also:} \args\.
 @end ifnotinfo
-@end macro
-
-@c The following macro marks words that aspell should ignore during
-@c spellchecking.  Within Texinfo it has no effect as it merely replaces
-@c the macro call with the argument itself.
-
-@macro nospell {arg}
-\arg\
+@ifinfo
+@noindent
+See also: \args\.
+@end ifinfo
 @end macro
 
 @c The following macro works around a situation where the Info/plain text
 @c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
 @c can be confusing if the code segment itself ends with a transpose operator.
 @ifinfo
-@macro xcode{arg}
+@macro tcode{arg}
 \arg\
 @end macro
 @end ifinfo
 @ifnotinfo
-@macro xcode{arg}
+@macro tcode{arg}
 @code{\arg\}
 @end macro
 @end ifnotinfo
+
+@c FIXME: someday, when Texinfo 5.X is standard, we might replace this with
+@c @backslashchar, which is a new addition to Texinfo.
+
+@macro xbackslashchar
+\\
+@end macro
+
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -22,20 +22,20 @@
 There are a number of functions available for checking to see if the
 elements of a matrix meet some condition, and for rearranging the
 elements of a matrix.  For example, Octave can easily tell you if all
 the elements of a matrix are finite, or are less than some specified
 value.  Octave can also rotate the elements, extract the upper- or
 lower-triangular parts, or sort the columns of a matrix.
 
 @menu
-* Finding Elements and Checking Conditions::  
-* Rearranging Matrices::        
-* Special Utility Matrices::    
-* Famous Matrices::             
+* Finding Elements and Checking Conditions::
+* Rearranging Matrices::
+* Special Utility Matrices::
+* Famous Matrices::
 @end menu
 
 @node Finding Elements and Checking Conditions
 @section Finding Elements and Checking Conditions
 
 The functions @code{any} and @code{all} are useful for determining
 whether any or all of the elements of a matrix satisfy some condition.
 The @code{find} function is also useful in determining which elements of
@@ -72,17 +72,17 @@ Note that in conditional contexts (like 
 
 @DOCSTRING(isnan)
 
 @DOCSTRING(isfinite)
 
 @DOCSTRING(common_size)
 
 @DOCSTRING(find)
-        
+
 @DOCSTRING(lookup)
 
 If you wish to check if a variable exists at all, instead of properties
 its elements may have, consult @ref{Status of Variables}.
 
 @node Rearranging Matrices
 @section Rearranging Matrices
 
@@ -119,17 +119,17 @@ its elements may have, consult @ref{Stat
 @DOCSTRING(sort)
 
 @DOCSTRING(sortrows)
 
 @DOCSTRING(issorted)
 
 @DOCSTRING(nth_element)
 
-@anchor{docXtriu}
+@anchor{XREFtriu}
 @DOCSTRING(tril)
 
 @DOCSTRING(vec)
 
 @DOCSTRING(vech)
 
 @DOCSTRING(prepad)
 
@@ -169,17 +169,17 @@ create vectors with evenly or logarithmi
 @DOCSTRING(rande)
 
 @DOCSTRING(randp)
 
 @DOCSTRING(randg)
 
 The generators operate in the new or old style together, it is not
 possible to mix the two.  Initializing any generator with
-@code{"state"} or @code{"seed"} causes the others to switch to the
+@qcode{"state"} or @qcode{"seed"} causes the others to switch to the
 same style for future calls.
 
 The state of each generator is independent and calls to different
 generators can be interleaved without affecting the final result.  For
 example,
 
 @example
 @group
@@ -203,17 +203,17 @@ for i = 1:100
   u(i) = rand ();
   n(i) = randn ();
 end
 @end group
 @end example
 
 @noindent
 produce equivalent results.  When the generators are initialized in
-the old style with @code{"seed"} only @code{rand} and @code{randn} are
+the old style with @qcode{"seed"} only @code{rand} and @code{randn} are
 independent, because the old @code{rande}, @code{randg} and
 @code{randp} generators make calls to @code{rand} and @code{randn}.
 
 The generators are initialized with random states at start-up, so
 that the sequences of random numbers are not the same each time you run
 Octave.@footnote{The old versions of @code{rand} and @code{randn}
 obtain their initial seeds from the system clock.} If you really do
 need to reproduce a sequence of numbers exactly, you can set the state
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -19,17 +19,17 @@ args = argv ();
 if (nargin < 2)
   error ("usage: mk_doc_cache OUTPUT-FILE DOCSTRINGS-FILE ...");
 endif
 
 output_file = args{1};
 docstrings_files = args(2:end);
 
 ## Special character used as break between DOCSTRINGS
-doc_delim = char (31);
+doc_delim = char (0x1d);
 
 ## Read the contents of all the DOCSTRINGS files into TEXT.
 ## It is more efficient to fork to shell for makeinfo only once on large data
 
 nfiles = numel (docstrings_files);
 text = cell (1, nfiles);
 for i = 1:nfiles
   file = docstrings_files{i};
@@ -43,21 +43,33 @@ for i = 1:nfiles
       ## containing macro definitions, for example).
       text{i} = tmp;
     else
       ## Strip off header lines
       [~, text{i}] = strtok (tmp, doc_delim);
     endif
   endif
 endfor
-text = [text{:}, doc_delim];
+text = [text{:}];
+
+## Strip Texinfo marker
+text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
 
-## Strip Texinfo markers and docstring separators.
-text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
-text = strrep (text, '@', "@@");
+## Add keywords and operators
+other_docstrings = [__keywords__; __operators__];
+for i = 1 : numel (other_docstrings)
+  name = other_docstrings{i};
+  ## Special handling of block comment operators such as '#{'
+  esc_name = regexprep (name, '([{}])', '@$1');
+  text = [text doc_delim esc_name get_help_text(name) "\n"];
+endfor
+text(end+1) = doc_delim;
+
+## Double '@' symbol for Texinfo
+text = strrep (text, [doc_delim "@"], [doc_delim "@@"]);
 
 ## Write data to temporary file for input to makeinfo
 [fid, name, msg] = mkstemp ("octave_doc_XXXXXX", true);
 if (fid < 0)
   error ("%s: %s\n", name, msg);
 endif
 fwrite (fid, text, "char");
 fclose (fid);
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
--- a/doc/interpreter/munge-texi.pl
+++ b/doc/interpreter/munge-texi.pl
@@ -1,17 +1,17 @@
 #!/usr/bin/perl -w
 
 # Validate program call
 die "usage: munge-texi TOP-SRCDIR DOCSTRING-FILE < file" if (@ARGV < 2);
 
 $top_srcdir = shift (@ARGV);
 
 # Constant patterns
-$doc_delim = qr/^\c_/;
+$doc_delim = qr/^\x{1d}/;
 $tex_delim = qr/\Q-*- texinfo -*-\E/;
 $comment_line = qr/^\s*(?:$|#)/;
 # Pre-declare hash size for efficiency
 keys(%help_text) = 1800;
 
 ################################################################################
 # Load DOCSTRINGS into memory while expanding @seealso references
 foreach $DOCSTRING_file (@ARGV)
@@ -56,17 +56,17 @@ TXI_LINE: while (<STDIN>)
     $docstring = $help_text{$func};
     if (! $docstring)
     {
       warn "no docstring entry for $func\n";
       next TXI_LINE;
     }
 
     $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-    $docstring =~ s/^$tex_delim$/\@anchor{docX$func}/m;
+    $docstring =~ s/^$tex_delim$/\@anchor{XREF$func}/m;
     print $docstring,"\n";
 
     next TXI_LINE;
   }
   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
   {
     $fname = "$top_srcdir/examples/$1";
     print '@verbatim',"\n";
@@ -105,17 +105,17 @@ sub extract_docstring
       ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
      
       $func_list = $arg_list;
       $func_list =~ s/\s+//gs;
       $repl = "";
       foreach $func (split (/,/, $func_list))
       {
         $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
-        $repl .= "\@ref{docX$func,,$func}, ";
+        $repl .= "\@ref{XREF$func,,$func}, ";
       }
       substr($repl,-2) = "";   # Remove last ', ' 
       $_ = "\@seealso{$repl}$rest_of_line";
     }
 
     $docstring .= $_;
   }
 
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -18,17 +18,17 @@
 
 @node Nonlinear Equations
 @chapter Nonlinear Equations
 @cindex nonlinear equations
 @cindex equations, nonlinear
 
 @menu
 * Solvers::
-* Minimizers::          
+* Minimizers::
 @end menu
 
 @node Solvers
 @section Solvers
 
 Octave can solve sets of nonlinear equations of the form
 @tex
 $$
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -24,17 +24,17 @@
 A @dfn{numeric constant} may be a scalar, a vector, or a matrix, and it
 may contain complex values.
 
 The simplest form of a numeric constant, a scalar, is a single number
 that can be an integer, a decimal fraction, a number in scientific
 (exponential) notation, or a complex number.  Note that by default numeric
 constants are represented within Octave in double-precision floating
 point format (complex constants are stored as pairs of double-precision
-floating point values).  It is however possible to represent real
+floating point values).  It is, however, possible to represent real
 integers as described in @ref{Integer Data Types}.  Here are some
 examples of real-valued numeric constants, which all have the same
 value:
 
 @example
 @group
 105
 1.05e+2
@@ -88,19 +88,19 @@ You may also use @samp{j}, @samp{I}, or 
 @DOCSTRING(complex)
 
 @menu
 * Matrices::
 * Ranges::
 * Single Precision Data Types::
 * Integer Data Types::
 * Bit Manipulations::
-* Logical Values:: 
+* Logical Values::
 * Promotion and Demotion of Data Types::
-* Predicates for Numeric Objects::  
+* Predicates for Numeric Objects::
 @end menu
 
 @node Matrices
 @section Matrices
 @cindex matrices
 
 @opindex [
 @opindex ]
@@ -299,17 +299,17 @@ significant figures for every value in a
 see all values in a matrix printed in a fixed point format, you can set
 the built-in variable @code{fixed_point_format} to a nonzero value.  But
 doing so is not recommended, because it can produce output that can
 easily be misinterpreted.
 
 @DOCSTRING(fixed_point_format)
 
 @menu
-* Empty Matrices::              
+* Empty Matrices::
 @end menu
 
 @node Empty Matrices
 @subsection Empty Matrices
 
 A matrix may have one or both dimensions zero, and operations on empty
 matrices are handled as described by Carl @nospell{de} Boor in @cite{An Empty
 Exercise}, SIGNUM, Volume 25, pages 2-6, 1990 and C. N. Nett and W. M.
@@ -354,17 +354,17 @@ s * [](mxn) = [](mxn) * s = [](mxn)
 By default, dimensions of the empty matrix are printed along with the
 empty matrix symbol, @samp{[]}.  The built-in variable
 @code{print_empty_dimensions} controls this behavior.
 
 @DOCSTRING(print_empty_dimensions)
 
 Empty matrices may also be used in assignment statements as a convenient
 way to delete rows or columns of matrices.
-@xref{Assignment Ops, ,Assignment Expressions}.
+@xref{Assignment Ops,,Assignment Expressions}.
 
 When Octave parses a matrix expression, it examines the elements of the
 list to determine whether they are all constants.  If they are, it
 replaces the list with a single matrix constant.
 
 @node Ranges
 @section Ranges
 @cindex range expressions
@@ -541,16 +541,18 @@ when converted.
 @DOCSTRING(int64)
 
 @DOCSTRING(uint64)
 
 @DOCSTRING(intmax)
 
 @DOCSTRING(intmin)
 
+@DOCSTRING(flintmax)
+
 @menu
 * Integer Arithmetic::
 @end menu
 
 @node Integer Arithmetic
 @subsection Integer Arithmetic
 
 While many numerical computations can't be carried out in integers,
@@ -611,20 +613,20 @@ example for @code{bitset} above passes t
 bits of the native floating point format representation of @code{10}.
 
 As the maximum value that can be represented by a number is important
 for bit manipulation, particularly when forming masks, Octave supplies
 the function @code{bitmax}.
 
 @DOCSTRING(bitmax)
 
-This is the double precision version of the functions @code{intmax},
+This is the double precision version of the function @code{intmax},
 previously discussed.
 
-Octave also includes the basic bitwise 'and', 'or' and 'exclusive or'
+Octave also includes the basic bitwise 'and', 'or', and 'exclusive or'
 operators.
 
 @DOCSTRING(bitand)
 
 @DOCSTRING(bitor)
 
 @DOCSTRING(bitxor)
 
@@ -834,9 +836,9 @@ variable.
 @DOCSTRING(isdefinite)
 
 @DOCSTRING(islogical)
 
 @DOCSTRING(isprime)
 
 If instead of knowing properties of variables, you wish to know which
 variables are defined and to gather other information about the
-workspace itself, see @ref{Status of Variables}.
+workspace itself, @pxref{Status of Variables}.
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -12,33 +12,38 @@
 % FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 % for more details.
 % 
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 \input texinfo
+
 @setfilename octave.info
 
 @include macros.texi
 
 @ifinfo
 @format
 START-INFO-DIR-ENTRY
 * Octave: (octave).           Interactive language for numerical computations.
 
 END-INFO-DIR-ENTRY
 @end format
 @end ifinfo
 
-@c Settings for printing on 8-1/2 by 11 inch paper:
-@c -----------------------------------------------
+@c Settings for printing on 8-1/2 by 11 inch paper (default):
+@c --------------------------------------------------------
 
 @setchapternewpage odd
+@c Fix TOC margins for printed manual
+@tex
+{\globaldefs = 1 \contentsrightmargin = 0pt}
+@end tex
 
 @c Settings for small book format:
 @c ------------------------------
 
 @ignore
 @smallbook
 @setchapternewpage odd
 @finalout
@@ -96,16 +101,17 @@ modified versions.
 @c this is a spacer column
 @tab
 @sp 8
 @titlefont{Free Your Numbers} 
 @end multitable 
 @author John W. Eaton
 @author David Bateman
 @author S@o{}ren Hauberg
+@author Rik Wehbring
 @page
 @vskip 0pt plus 1filll
 Copyright @copyright{} 1996, 1997, 1999, 2000, 2001, 2002, 2005, 2006,
 2007, 2011 John W. Eaton.
 
 This is the third edition of the Octave documentation, and is consistent
 with version @value{VERSION} of Octave.
 
@@ -136,178 +142,177 @@ 02110-1301--1307, USA.
 This manual documents how to run, install and port GNU Octave, as well
 as its new features and incompatibilities, and how to report bugs.
 It corresponds to GNU Octave version @value{VERSION}.
 @end ifnottex
 
 @c ------------------------------------------------------------------------
 
 @menu
-* Preface::                     
+* Preface::
 * Introduction::                A brief introduction to Octave.
-* Getting Started::             
-* Data Types::                  
-* Numeric Data Types::          
-* Strings::                     
-* Data Containers::             
-* Variables::                   
-* Expressions::                 
-* Evaluation::                  
+* Getting Started::
+* Data Types::
+* Numeric Data Types::
+* Strings::
+* Data Containers::
+* Variables::
+* Expressions::
+* Evaluation::
 * Statements::                  Looping and program flow control.
-* Functions and Scripts::       
-* Errors and Warnings::              
+* Functions and Scripts::
+* Errors and Warnings::
 * Debugging::
-* Input and Output::            
-* Plotting::                    
-* Matrix Manipulation::         
-* Arithmetic::                  
+* Input and Output::
+* Plotting::
+* Matrix Manipulation::
+* Arithmetic::
 * Linear Algebra::
 * Vectorization and Faster Code Execution::
 * Nonlinear Equations::
 * Diagonal and Permutation Matrices::
 * Sparse Matrices::
-* Numerical Integration::                  
-* Differential Equations::      
-* Optimization::                
-* Statistics::                  
-* Sets::                        
-* Polynomial Manipulations::    
+* Numerical Integration::
+* Differential Equations::
+* Optimization::
+* Statistics::
+* Sets::
+* Polynomial Manipulations::
 * Interpolation::
 * Geometry::
-* Signal Processing::           
-* Image Processing::            
-* Audio Processing::            
-* Object Oriented Programming::            
-* GUI Development::            
-* System Utilities::            
+* Signal Processing::
+* Image Processing::
+* Audio Processing::
+* Object Oriented Programming::
+* GUI Development::
+* System Utilities::
 * Java Interface:: 
 * Packages:: 
 * External Code Interface::
 * Test and Demo Functions::
-* Tips and Standards::                        
+* Tips and Standards::
 * Contributing Guidelines::
 * Obsolete Functions::
 * Trouble::                     If you have trouble installing Octave.
 * Installation::                How to configure, compile and install Octave.
-* Emacs Octave Support::                       
-* Grammar and Parser::                     
+* Emacs Octave Support::
+* Grammar and Parser::
 * Copying::                     The GNU General Public License.
 * Concept Index::               An item for each concept.
 * Function Index::              An item for each documented function.
 * Operator Index::              An item for each documented operator.
 
 @detailmenu
  --- The Detailed Node Listing ---
 
 Preface
 
-* Acknowledgements::            
+* Acknowledgements::
 * Citing Octave in Publications::
-* How You Can Contribute to Octave::  
-* Distribution::                
+* How You Can Contribute to Octave::
+* Distribution::
 
 Introduction
 
-* Running Octave::              
-* Simple Examples::             
-* Conventions::                 
+* Running Octave::
+* Simple Examples::
+* Conventions::
 
 Conventions
 
-* Fonts::                       
-* Evaluation Notation::         
-* Printing Notation::           
-* Error Messages::              
-* Format of Descriptions::      
+* Fonts::
+* Evaluation Notation::
+* Printing Notation::
+* Error Messages::
+* Format of Descriptions::
 
 Format of Descriptions
 
-* A Sample Function Description::  
-* A Sample Command Description::  
-* A Sample Variable Description::  
+* A Sample Function Description::
+* A Sample Command Description::
 
 Getting Started
 
-* Invoking Octave from the Command Line::             
-* Quitting Octave::             
-* Getting Help::                
-* Command Line Editing::        
-* Errors::                      
-* Executable Octave Programs::  
-* Comments::                    
+* Invoking Octave from the Command Line::
+* Quitting Octave::
+* Getting Help::
+* Command Line Editing::
+* Errors::
+* Executable Octave Programs::
+* Comments::
 
 Invoking Octave from the Command Line
 
-* Command Line Options::        
-* Startup Files::               
+* Command Line Options::
+* Startup Files::
 
 Command Line Editing
 
-* Cursor Motion::               
-* Killing and Yanking::         
-* Commands For Text::           
-* Commands For Completion::     
-* Commands For History::        
-* Customizing readline::        
-* Customizing the Prompt::      
-* Diary and Echo Commands::     
+* Cursor Motion::
+* Killing and Yanking::
+* Commands For Text::
+* Commands For Completion::
+* Commands For History::
+* Customizing readline::
+* Customizing the Prompt::
+* Diary and Echo Commands::
 
 Comments
 
 * Single Line Comments::
 * Block Comments::
-* Comments and the Help System::                    
+* Comments and the Help System::
 
 Data Types
 
-* Built-in Data Types::         
-* User-defined Data Types::     
-* Object Sizes::                
+* Built-in Data Types::
+* User-defined Data Types::
+* Object Sizes::
 
 Built-in Data Types
 
-* Numeric Objects::             
-* Missing Data::                
-* String Objects::              
-* Data Structure Objects::      
-* Cell Array Objects::          
+* Numeric Objects::
+* Missing Data::
+* String Objects::
+* Data Structure Objects::
+* Cell Array Objects::
 
 Numeric Data Types
 
 * Matrices::
 * Ranges::
 * Single Precision Data Types::
 * Integer Data Types::
 * Bit Manipulations::
-* Logical Values:: 
+* Logical Values::
 * Promotion and Demotion of Data Types::
-* Predicates for Numeric Objects::  
+* Predicates for Numeric Objects::
 
 Matrices
 
-* Empty Matrices::              
+* Empty Matrices::
 
 Integer Data Types
 
 * Integer Arithmetic::
 
 Strings
 
 * Escape Sequences in String Constants::
 * Character Arrays::
-* Creating Strings:: 
-* Comparing Strings::           
-* Manipulating Strings::     
-* String Conversions::          
-* Character Class Functions::   
+* Creating Strings::
+* Comparing Strings::
+* Manipulating Strings::
+* String Conversions::
+* Character Class Functions::
 
 Creating Strings
 
-* Concatenating Strings:: 
-* Conversion of Numerical Data to Strings::
+* Concatenating Strings::
+* Converting Numerical Data to Strings::
 
 Data Containers
 
 * Structures::
 * Cell Arrays::
 * Comma Separated Lists::
 
 Structures
@@ -328,98 +333,98 @@ Cell Arrays
 
 Comma Separated Lists
 
 * Comma Separated Lists Generated from Cell Arrays::
 * Comma Separated Lists Generated from Structure Arrays::
 
 Variables
 
-* Global Variables::            
-* Persistent Variables::        
-* Status of Variables::         
+* Global Variables::
+* Persistent Variables::
+* Status of Variables::
 
 Expressions
 
-* Index Expressions::           
-* Calling Functions::           
-* Arithmetic Ops::              
-* Comparison Ops::              
-* Boolean Expressions::         
-* Assignment Ops::              
-* Increment Ops::               
-* Operator Precedence::         
+* Index Expressions::
+* Calling Functions::
+* Arithmetic Ops::
+* Comparison Ops::
+* Boolean Expressions::
+* Assignment Ops::
+* Increment Ops::
+* Operator Precedence::
 
 Index Expressions
 
 * Advanced Indexing::
 
 Calling Functions
 
-* Call by Value::               
-* Recursion::                   
+* Call by Value::
+* Recursion::
 
 Boolean Expressions
 
-* Element-by-element Boolean Operators::  
-* Short-circuit Boolean Operators::  
+* Element-by-element Boolean Operators::
+* Short-circuit Boolean Operators::
 
 Evaluation
 
 * Calling a Function by its Name::
 * Evaluation in a Different Context::
 
 Statements
 
-* The if Statement::            
-* The switch Statement::        
-* The while Statement::         
-* The do-until Statement::      
-* The for Statement::           
-* The break Statement::         
-* The continue Statement::      
-* The unwind_protect Statement::  
-* The try Statement::           
-* Continuation Lines::          
+* The if Statement::
+* The switch Statement::
+* The while Statement::
+* The do-until Statement::
+* The for Statement::
+* The break Statement::
+* The continue Statement::
+* The unwind_protect Statement::
+* The try Statement::
+* Continuation Lines::
 
 The switch Statement
 
-* Notes for the C Programmer::  
+* Notes for the C Programmer::
 
 The for Statement
 
-* Looping Over Structure Elements::  
+* Looping Over Structure Elements::
 
 Functions and Scripts
 
 * Introduction to Function and Script Files::
-* Defining Functions::          
-* Multiple Return Values::      
-* Variable-length Argument Lists::  
-* Ignoring Arguments::  
-* Variable-length Return Lists::  
-* Returning from a Function::   
-* Default Arguments::   
-* Function Files::              
-* Script Files::                
-* Function Handles Inline Functions and Anonymous Functions::
+* Defining Functions::
+* Multiple Return Values::
+* Variable-length Argument Lists::
+* Ignoring Arguments::
+* Variable-length Return Lists::
+* Returning from a Function::
+* Default Arguments::
+* Function Files::
+* Script Files::
+* Function Handles Anonymous Functions Inline Functions::
 * Commands::
-* Organization of Functions::   
+* Organization of Functions::
 
 Function Files
 
 * Manipulating the Load Path::
 * Subfunctions::
 * Private Functions::
 * Nested Functions::
 * Overloading and Autoloading::
 * Function Locking::
 * Function Precedence::
 
-Function Handles Inline Functions and Anonymous Functions
+Function Handles Anonymous Functions Inline Functions
 
 * Function Handles::
 * Anonymous Functions::
 * Inline Functions::
 
 Errors and Warnings
 
 * Handling Errors::
@@ -443,184 +448,183 @@ Debugging
 * Breakpoints::
 * Debug Mode::
 * Call Stack::
 * Profiling::
 * Profiler Example::
 
 Input and Output
 
-* Basic Input and Output::      
-* C-Style I/O Functions::       
+* Basic Input and Output::
+* C-Style I/O Functions::
 
 Basic Input and Output
 
-* Terminal Output::             
-* Terminal Input::              
-* Simple File I/O::             
+* Terminal Output::
+* Terminal Input::
+* Simple File I/O::
 
 Terminal Output
 
 * Paging Screen Output::
 
 Simple File I/O
 
 * Saving Data on Unexpected Exits::
 
 C-Style I/O Functions
 
-* Opening and Closing Files::   
-* Simple Output::               
-* Line-Oriented Input::         
-* Formatted Output::            
-* Output Conversion for Matrices::  
-* Output Conversion Syntax::    
-* Table of Output Conversions::  
-* Integer Conversions::         
+* Opening and Closing Files::
+* Simple Output::
+* Line-Oriented Input::
+* Formatted Output::
+* Output Conversion for Matrices::
+* Output Conversion Syntax::
+* Table of Output Conversions::
+* Integer Conversions::
 * Floating-Point Conversions::
-* Other Output Conversions::    
-* Formatted Input::             
-* Input Conversion Syntax::     
-* Table of Input Conversions::  
-* Numeric Input Conversions::   
-* String Input Conversions::    
-* Binary I/O::                  
-* Temporary Files::             
-* EOF and Errors::              
-* File Positioning::            
+* Other Output Conversions::
+* Formatted Input::
+* Input Conversion Syntax::
+* Table of Input Conversions::
+* Numeric Input Conversions::
+* String Input Conversions::
+* Binary I/O::
+* Temporary Files::
+* EOF and Errors::
+* File Positioning::
 
 Plotting
 
-* Introduction to Plotting::    
-* High-Level Plotting::         
-* Graphics Data Structures::    
-* Advanced Plotting::           
+* Introduction to Plotting::
+* High-Level Plotting::
+* Graphics Data Structures::
+* Advanced Plotting::
 
 High-Level Plotting
 
-* Two-Dimensional Plots::       
-* Three-Dimensional Plots::  
-* Plot Annotations::            
-* Multiple Plots on One Page::  
-* Multiple Plot Windows::       
-* Use of axis@comma{} line@comma{} and patch Functions::
+* Two-Dimensional Plots::
+* Three-Dimensional Plots::
+* Plot Annotations::
+* Multiple Plots on One Page::
+* Multiple Plot Windows::
 * Manipulation of Plot Windows::
 * Use of the @code{interpreter} Property::
-* Printing and Saving Plots::              
-* Interacting with Plots::      
-* Test Plotting Functions::     
+* Printing and Saving Plots::
+* Interacting with Plots::
+* Test Plotting Functions::
 
 Two-Dimensional Plots
 
-* Axis Configuration::  
-* Two-dimensional Function Plotting::  
-* Two-dimensional Geometric Shapes::  
+* Axis Configuration::
+* Two-dimensional Function Plotting::
+* Two-dimensional Geometric Shapes::
 
 Three-Dimensional Plots
 
 * Aspect Ratio::
-* Three-dimensional Function Plotting::  
-* Three-dimensional Geometric Shapes::  
+* Three-dimensional Function Plotting::
+* Three-dimensional Geometric Shapes::
 
 Graphics Data Structures
 
-* Introduction to Graphics Structures::  
-* Graphics Objects::            
-* Graphics Object Properties::  
-* Searching Properties::        
-* Managing Default Properties::  
+* Introduction to Graphics Structures::
+* Graphics Objects::
+* Graphics Object Properties::
+* Searching Properties::
+* Managing Default Properties::
 
 Graphics Object Properties
 
-* Root Figure Properties::      
-* Figure Properties::           
-* Axes Properties::             
-* Line Properties::             
-* Text Properties::             
-* Image Properties::            
-* Patch Properties::            
-* Surface Properties::          
+* Root Figure Properties::
+* Figure Properties::
+* Axes Properties::
+* Line Properties::
+* Text Properties::
+* Image Properties::
+* Patch Properties::
+* Surface Properties::
 
 Advanced Plotting
 
-* Colors::                      
-* Line Styles::                 
-* Marker Styles::               
-* Callbacks::                   
+* Colors::
+* Line Styles::
+* Marker Styles::
+* Callbacks::
 * Application-defined Data::
-* Object Groups::               
-* Graphics Toolkits::           
+* Object Groups::
+* Graphics Toolkits::
 
 Object Groups
 
-* Data Sources in Object Groups::  
-* Area Series::                 
-* Bar Series::                  
-* Contour Groups::              
-* Error Bar Series::            
-* Line Series::                 
-* Quiver Group::                
-* Scatter Group::               
-* Stair Group::                 
-* Stem Series::                 
-* Surface Group::               
+* Data Sources in Object Groups::
+* Area Series::
+* Bar Series::
+* Contour Groups::
+* Error Bar Series::
+* Line Series::
+* Quiver Group::
+* Scatter Group::
+* Stair Group::
+* Stem Series::
+* Surface Group::
 
 Graphics Toolkits
 
-* Customizing Toolkit Behavior::    
+* Customizing Toolkit Behavior::
 
 Matrix Manipulation
 
-* Finding Elements and Checking Conditions::  
-* Rearranging Matrices::        
-* Special Utility Matrices::    
-* Famous Matrices::             
+* Finding Elements and Checking Conditions::
+* Rearranging Matrices::
+* Special Utility Matrices::
+* Famous Matrices::
 
 Arithmetic
 
 * Exponents and Logarithms::
-* Complex Arithmetic::          
-* Trigonometry::                
-* Sums and Products::           
-* Utility Functions::           
-* Special Functions::           
+* Complex Arithmetic::
+* Trigonometry::
+* Sums and Products::
+* Utility Functions::
+* Special Functions::
 * Rational Approximations::
 * Coordinate Transformations::
-* Mathematical Constants::      
+* Mathematical Constants::
 
 Linear Algebra
 
 * Techniques Used for Linear Algebra::
-* Basic Matrix Functions::      
-* Matrix Factorizations::       
-* Functions of a Matrix::       
+* Basic Matrix Functions::
+* Matrix Factorizations::
+* Functions of a Matrix::
 * Specialized Solvers::
 
 Vectorization and Faster Code Execution
 
 * Basic Vectorization::        Basic techniques for code optimization
 * Broadcasting::               Broadcasting operations
 * Function Application::       Applying functions to arrays, cells, and structs
 * Accumulation::               Accumulation functions
 * JIT Compiler::               Just-In-Time Compiler for loops
 * Miscellaneous Techniques::   Other techniques for speeding up code
 * Examples::
 
 Nonlinear Equations
 
 * Solvers::
-* Minimizers::          
+* Minimizers::
 
 Diagonal and Permutation Matrices
 
-* Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
-* Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
+* Basic Usage::          Creation and Manipulation of Diagonal/Permutation Matrices
+* Matrix Algebra::       Linear Algebra with Diagonal/Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
-* Example Code::         Some Examples of Usage
-* Zeros Treatment::      The Differences in Treatment of Zero Elements
+* Example Code::         Examples of Usage
+* Zeros Treatment::      Differences in Treatment of Zero Elements
 
 Basic Usage
 
 * Creating Diagonal Matrices::
 * Creating Permutation Matrices::
 * Explicit and Implicit Conversions::
 
 Matrix Algebra
@@ -644,47 +648,47 @@ Basics
 
 * Storage of Sparse Matrices::
 * Creating Sparse Matrices::
 * Information::
 * Operators and Functions::
 
 Operators and Functions
 
-* Sparse Functions::            
-* Return Types of Operators and Functions::  
-* Mathematical Considerations::  
+* Sparse Functions::
+* Return Types of Operators and Functions::
+* Mathematical Considerations::
 
 Numerical Integration
 
-* Functions of One Variable:: 
-* Orthogonal Collocation::      
-* Functions of Multiple Variables:: 
+* Functions of One Variable::
+* Orthogonal Collocation::
+* Functions of Multiple Variables::
 
 Differential Equations
 
-* Ordinary Differential Equations::  
-* Differential-Algebraic Equations::  
+* Ordinary Differential Equations::
+* Differential-Algebraic Equations::
 
 Optimization
 
-* Linear Programming::       
-* Quadratic Programming::       
-* Nonlinear Programming::       
-* Linear Least Squares::        
+* Linear Programming::
+* Quadratic Programming::
+* Nonlinear Programming::
+* Linear Least Squares::
 
 Statistics
 
 * Descriptive Statistics::
-* Basic Statistical Functions:: 
-* Statistical Plots:: 
-* Correlation and Regression Analysis::                      
-* Distributions::     
-* Tests::                       
-* Random Number Generation::          
+* Basic Statistical Functions::
+* Statistical Plots::
+* Correlation and Regression Analysis::
+* Distributions::
+* Tests::
+* Random Number Generation::
 
 Sets
 
 * Set Operations::
 
 Polynomial Manipulations
 
 * Evaluating Polynomials::
@@ -708,21 +712,21 @@ Geometry
 
 Delaunay Triangulation
 
 * Plotting the Triangulation::
 * Identifying Points in Triangulation::
 
 Image Processing
 
-* Loading and Saving Images::   
-* Displaying Images::           
-* Representing Images::         
-* Plotting on top of Images::   
-* Color Conversion::            
+* Loading and Saving Images::
+* Displaying Images::
+* Representing Images::
+* Plotting on top of Images::
+* Color Conversion::
 
 Object Oriented Programming
 
 * Creating a Class::
 * Manipulating Classes::
 * Indexing Objects::
 * Overloading Objects::
 * Inheritance and Aggregation::
@@ -735,34 +739,34 @@ Indexing Objects
 Overloading Objects
 
 * Function Overloading::
 * Operator Overloading::
 * Precedence of Objects::
 
 GUI Development
 
-* I/O Dialogs::       
-* Progress Bar::       
-* GUI Utility Functions::       
-* User-Defined Preferences::       
+* I/O Dialogs::
+* Progress Bar::
+* GUI Utility Functions::
+* User-Defined Preferences::
 
 System Utilities
 
-* Timing Utilities::            
-* Filesystem Utilities::        
+* Timing Utilities::
+* Filesystem Utilities::
 * File Archiving Utilities::
 * Networking Utilities::
-* Controlling Subprocesses::    
-* Process ID Information::      
-* Environment Variables::       
-* Current Working Directory::   
-* Password Database Functions::  
-* Group Database Functions::    
-* System Information::          
+* Controlling Subprocesses::
+* Process ID Information::
+* Environment Variables::
+* Current Working Directory::
+* Password Database Functions::
+* Group Database Functions::
+* System Information::
 * Hashing Functions::
 
 Networking Utilities
 
 * FTP Objects::
 * URL Manipulation::
 * Base64 and Binary Data Transmission::
 
@@ -773,68 +777,68 @@ Java Interface
 * FAQ - Frequently asked Questions::
 
 FAQ - Frequently asked Questions
 
 * How to distinguish between Octave and Matlab?::
 * How to make Java classes available?::
 * How to create an instance of a Java class?::
 * How can I handle memory limitations?::
-* Which @TeX{} symbols are implemented in the dialog functions?::
+* Which @TeX{} symbols are implemented in dialog functions?::
 
 Packages
 
-* Installing and Removing Packages::  
-* Using Packages::              
-* Administrating Packages::     
-* Creating Packages::           
+* Installing and Removing Packages::
+* Using Packages::
+* Administrating Packages::
+* Creating Packages::
 
 Creating Packages
 
-* The DESCRIPTION File::        
-* The INDEX File::              
-* PKG_ADD and PKG_DEL Directives::  
+* The DESCRIPTION File::
+* The INDEX File::
+* PKG_ADD and PKG_DEL Directives::
 
 External Code Interface
 
-* Oct-Files::                   
-* Mex-Files::                   
-* Standalone Programs::         
+* Oct-Files::
+* Mex-Files::
+* Standalone Programs::
 
 Oct-Files
 
-* Getting Started with Oct-Files::  
-* Matrices and Arrays in Oct-Files::  
-* Character Strings in Oct-Files::  
-* Cell Arrays in Oct-Files::    
-* Structures in Oct-Files::  
-* Sparse Matrices in Oct-Files::  
-* Accessing Global Variables in Oct-Files::  
-* Calling Octave Functions from Oct-Files::  
-* Calling External Code from Oct-Files::  
-* Allocating Local Memory in Oct-Files::  
-* Input Parameter Checking in Oct-Files::  
-* Exception and Error Handling in Oct-Files::  
-* Documentation and Test of Oct-Files::  
+* Getting Started with Oct-Files::
+* Matrices and Arrays in Oct-Files::
+* Character Strings in Oct-Files::
+* Cell Arrays in Oct-Files::
+* Structures in Oct-Files::
+* Sparse Matrices in Oct-Files::
+* Accessing Global Variables in Oct-Files::
+* Calling Octave Functions from Oct-Files::
+* Calling External Code from Oct-Files::
+* Allocating Local Memory in Oct-Files::
+* Input Parameter Checking in Oct-Files::
+* Exception and Error Handling in Oct-Files::
+* Documentation and Test of Oct-Files::
 
 Sparse Matrices in Oct-Files
 
-* Array and Sparse Differences::  
-* Creating Sparse Matrices in Oct-Files::  
-* Using Sparse Matrices in Oct-Files::  
+* Array and Sparse Class Differences::
+* Creating Sparse Matrices in Oct-Files::
+* Using Sparse Matrices in Oct-Files::
 
 Mex-Files
 
-* Getting Started with Mex-Files::  
-* Working with Matrices and Arrays in Mex-Files::  
-* Character Strings in Mex-Files::  
-* Cell Arrays with Mex-Files::  
-* Structures with Mex-Files::  
-* Sparse Matrices with Mex-Files::  
-* Calling Other Functions in Mex-Files::  
+* Getting Started with Mex-Files::
+* Working with Matrices and Arrays in Mex-Files::
+* Character Strings in Mex-Files::
+* Cell Arrays with Mex-Files::
+* Structures with Mex-Files::
+* Sparse Matrices with Mex-Files::
+* Calling Other Functions in Mex-Files::
 
 Test and Demo Functions
 
 * Test Functions::
 * Demonstration Functions::
 
 Tips and Standards
 
@@ -851,22 +855,22 @@ Contributing Guidelines
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 
 Trouble
 
 * Actual Bugs::                 Bugs we will fix later.
-* Reporting Bugs::              
-* Service::                     
+* Reporting Bugs::
+* Service::
 
 Reporting Bugs
 
-* Bug Criteria::                
+* Bug Criteria::
 * Bug Tracker::        Where to submit your bug report.
 * Bug Reporting::      How to report a bug effectively.
 * Sending Patches::    How to send a patch for Octave.
 
 Installation
 
 * Build Dependencies::
 * Running Configure and Make::
@@ -876,25 +880,25 @@ Installation
 Build Dependencies
 
 * Obtaining the Dependencies Automatically::
 * Build Tools::
 * External Packages::
 
 Emacs Octave Support
 
-* Installing EOS::              
-* Using Octave Mode::           
-* Running Octave from Within Emacs::  
-* Using the Emacs Info Reader for Octave::  
+* Installing EOS::
+* Using Octave Mode::
+* Running Octave from Within Emacs::
+* Using the Emacs Info Reader for Octave::
 
 Grammar and Parser
 
-* Keywords::                    
-* Parser::                    
+* Keywords::
+* Parser::
 
 @end detailmenu
 @end menu
 
 @c ------------------------------------------------------------------------
 
 @include preface.texi
 @include intro.texi
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -89,19 +89,17 @@ the @@polynomial directory.
 
 The constructor of the class, must have the name of the class itself
 and so in our example the constructor with have the name
 @file{@@polynomial/polynomial.m}.  Also ideally when the constructor is
 called with no arguments to should return a value object.  So for example
 our polynomial might look like
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/polynomial.m)
-@end group
 @end example
 
 Note that the return value of the constructor must be the output of
 the @code{class} function called with the first argument being a
 structure and the second argument being the class name.  An example of
 the call to this constructor function is then
 
 @example
@@ -172,47 +170,41 @@ that is not terminated with a semicolon.
 then Octave will printed nothing when displaying the contents of a class.
 
 @DOCSTRING(display)
 
 @noindent
 An example of a display method for the polynomial class might be
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/display.m)
-@end group
 @end example
 
 @noindent
 Note that in the display method, it makes sense to start the method
 with the line @code{fprintf ("%s =", inputname (1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
 when displaying the class. 
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
 all of the properties of the class.  For example:
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/get.m)
-@end group
 @end example
 
 @noindent
 Similarly, the @code{set} method should taken as its first argument an
 object to modify, and then take property/value pairs to be modified. 
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/set.m)
-@end group
 @end example
 
 @noindent
 Note that as Octave does not implement pass by reference, than the
 modified object is the return value of the @code{set} method and it
 must be called like
 
 @example
@@ -271,25 +263,23 @@ like @code{@var{a} (@var{idx}).@var{fiel
 to decide what this indexing actually means.  In the case of our polynomial
 class @code{@var{p} (@var{n})} might mean either the coefficient of the 
 @var{n}-th power of the polynomial, or it might be the evaluation of the 
 polynomial at @var{n}.  The meaning of this subscripted referencing is 
 determined by the @code{subsref} method.
 
 @DOCSTRING(subsref)
 
-For example we might decide that indexing with "()" evaluates the
-polynomial and indexing with "@{@}" returns the @var{n}-th coefficient (of
-@var{n}-th power).  In this case the @code{subsref} method of our polynomial
-class might look like
+For example we might decide that indexing with @qcode{"()"} evaluates the
+polynomial and indexing with @qcode{"@{@}"} returns the @var{n}-th coefficient
+(of @var{n}-th power).  In this case the @code{subsref} method of our
+polynomial class might look like
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/subsref.m)
-@end group
 @end example
 
 The equivalent functionality for subscripted assignments uses the 
 @code{subsasgn} method.
 
 @DOCSTRING(subsasgn)
 
 @DOCSTRING(optimize_subsasgn_calls)
@@ -635,31 +625,29 @@ to a function or operator.  To do this t
 
 For example with our polynomial class consider the case
 
 @example
 2 * polynomial ([1, 0, 1]);
 @end example
 
 @noindent
-That mixes an object of the class "double" with an object of the class
-"polynomial".  In this case we like to ensure that the return type of
-the above is of the type "polynomial" and so we use the
+That mixes an object of the class @qcode{"double"} with an object of the class
+@qcode{"polynomial"}.  In this case we like to ensure that the return type of
+the above is of the type @qcode{"polynomial"} and so we use the
 @code{superiorto} function in the class constructor.  In particular our
 polynomial class constructor would be modified to be
 
 @example
-@group
 @EXAMPLEFILE(@polynomial/polynomial_superiorto.m)
-@end group
 @end example
 
 Note that user classes always have higher precedence than built-in
 Octave types.  So in fact marking our polynomial class higher than the 
-"double" class is in fact not necessary.
+@qcode{"double"} class is in fact not necessary.
 
 When faced with two objects that have the same precedence, Octave will use the
 method of the object that appears first on the list of arguments.
 
 @node Inheritance and Aggregation
 @section Inheritance and Aggregation
 
 Using classes to build new classes is supported by octave through the
@@ -687,19 +675,17 @@ octave:3> y = filter (n, 1, x);
 @end group
 @end example
 
 The equivalent class could be implemented in a class directory
 @@FIRfilter that is on the octave path.  The constructor is a file
 FIRfilter.m in the class directory.
 
 @example
-@group
 @EXAMPLEFILE(@FIRfilter/FIRfilter.m)
-@end group
 @end example
 
 As before, the leading comments provide command-line documentation for
 the class constructor.  This constructor is very similar to the
 polynomial class constructor, except that we pass a polynomial object
 as the third argument to the class function, telling octave that the
 FIRfilter class will be derived from the polynomial class.  Our FIR
 filter does not have any data fields, but we must provide a struct to
@@ -753,22 +739,20 @@ polynomial = 0.333333 + 0.333333 * X + 0
 
 We only need to define a method to actually process data with our
 filter and our class is usable.  It is also useful to provide a means
 of changing the data stored in the class.  Since the fields in the
 underlying struct are private by default, we could provide a mechanism
 to access the fields.  The @code{subsref} method may be used for both.
 
 @example
-@group
 @EXAMPLEFILE(@FIRfilter/subsref.m)
-@end group
 @end example
 
-The "()" case allows us to filter data using the polynomial provided
+The @qcode{"()"} case allows us to filter data using the polynomial provided
 to the constructor.
 
 @example
 @group
 octave:2> f = FIRfilter (polynomial ([1 1 1]/3));
 octave:3> x = ones (5,1);
 octave:4> y = f(x)
 y =
@@ -776,17 +760,17 @@ y =
    0.33333
    0.66667
    1.00000
    1.00000
    1.00000
 @end group
 @end example
 
-The "." case allows us to view the contents of the polynomial field.
+The @qcode{"."} case allows us to view the contents of the polynomial field.
 
 @example
 @group
 octave:1> f = FIRfilter (polynomial ([1 1 1]/3));
 octave:2> f.polynomial
 ans = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @end group
 @end example
@@ -814,14 +798,12 @@ f.polynomial = 1 + 2 * X + 3 * X ^ 2
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
 polynomial may be used.  This is not a normal use of a filter, so that
 aggregation may be a more sensible design approach.  In this case, the
 polynomial is simply a field in the class structure.  A class
 constructor for this case might be
 
 @example
-@group
 @EXAMPLEFILE(@FIRfilter/FIRfilter_aggregation.m)
-@end group
 @end example
 
 For our example, the remaining class methods remain unchanged.
diff --git a/doc/interpreter/optim.txi b/doc/interpreter/optim.txi
--- a/doc/interpreter/optim.txi
+++ b/doc/interpreter/optim.txi
@@ -20,20 +20,20 @@
 @chapter Optimization
 
 Octave comes with support for solving various kinds of optimization
 problems.  Specifically Octave can solve problems in Linear Programming,
 Quadratic Programming, Nonlinear Programming, and Linear Least Squares
 Minimization.
 
 @menu
-* Linear Programming::       
-* Quadratic Programming::       
-* Nonlinear Programming::       
-* Linear Least Squares::        
+* Linear Programming::
+* Quadratic Programming::
+* Nonlinear Programming::
+* Linear Least Squares::
 @end menu
 
 @c @cindex linear programming
 @cindex quadratic programming
 @cindex nonlinear programming
 @cindex optimization
 @cindex LP
 @cindex QP
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -66,17 +66,17 @@ pkg list
 @print{} Package Name  | Version | Installation directory
 @print{} --------------+---------+-----------------------
 @print{}        image *|   1.0.0 | /home/jwe/octave/image-1.0.0
 @end group
 @end example
 
 @noindent
 In this case only version 1.0.0 of the @code{image} package is
-installed.  The '*' character next to the package name shows that the
+installed.  The @qcode{'*'} character next to the package name shows that the
 image package is loaded and ready for use.
 
 It is possible to remove a package from the system using the
 @code{pkg uninstall} command like this
 
 @example
 pkg uninstall image
 @end example
@@ -212,17 +212,17 @@ automatically from the functions in the 
 This is an optional file describing all user-visible changes worth
 mentioning.  As this file increases on size, old entries can be moved
 into @file{package/ONEWS}.
 
 @item package/ONEWS
 This is an optional file describing old entries from the @file{NEWS} file.
 
 @cindex PKG_ADD
-@anchor{docXPKG_ADD}
+@anchor{XREFPKG_ADD}
 @item package/PKG_ADD
 An optional file that includes commands that are run when the package
 is added to the users path.  Note that @w{@code{PKG_ADD}} directives in the
 source code of the package will also be added to this file by the
 Octave package manager.  Note that symbolic links are to be avoided in
 packages, as symbolic links do not exist on some file systems, and so
 a typical use for this file is the replacement of the symbolic link
 
@@ -237,17 +237,17 @@ with an autoload directive like
 autoload ('bar', which ('foo'));
 @end example
 
 @noindent
 @xref{PKG_ADD and PKG_DEL Directives}, for details on @w{@code{PKG_ADD}}
 directives.
 
 @cindex PKG_DEL
-@anchor{docXPKG_DEL}
+@anchor{XREFPKG_DEL}
 @item package/PKG_DEL
 An optional file that includes commands that are run when the package
 is removed from the users path.  Note that @w{@code{PKG_DEL}} directives in
 the source code of the package will also be added to this file by the
 Octave package manager. 
 @xref{PKG_ADD and PKG_DEL Directives}, for details on @w{@code{PKG_DEL}}
 directives.
 
@@ -464,17 +464,17 @@ toolbox >> Toolbox name
 @item Lines beginning with an alphabetical character indicates a new
 category of functions.
 
 @item Lines starting with a white space character indicate that the
 function names on the line belong to the last mentioned category.
 @end itemize
 
 @noindent
-The format can be summarized with the following example.
+The format can be summarized with the following example:
 
 @example
 @group
 # A comment
 toolbox >> Toolbox name
 Category Name 1
  function1 function2 function3
  function4
@@ -566,11 +566,12 @@ In C++ files a @w{@code{PKG_ADD}} direct
 
 @example
 // PKG_ADD: some_octave_command
 @end example
 
 @noindent
 In both cases @code{some_octave_command} should be replaced by the
 command that should be placed in the @w{@code{PKG_ADD}} file.
-@w{@code{PKG_DEL}} directives work in the same way, except the @w{@code{PKG_ADD}}
-keyword is replaced with @w{@code{PKG_DEL}} and the commands get added
-to the @w{@code{PKG_DEL}} file.
+@w{@code{PKG_DEL}} directives work in the same way, except the
+@w{@code{PKG_ADD}} keyword is replaced with @w{@code{PKG_DEL}} and the commands
+get added to the @w{@code{PKG_DEL}} file.
+
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -17,30 +17,30 @@
 @c <http://www.gnu.org/licenses/>.
 
 @node Plotting
 @chapter Plotting
 @cindex plotting
 @cindex graphics
 
 @menu
-* Introduction to Plotting::    
-* High-Level Plotting::         
-* Graphics Data Structures::    
-* Advanced Plotting::           
+* Introduction to Plotting::
+* High-Level Plotting::
+* Graphics Data Structures::
+* Advanced Plotting::
 @end menu
 
 @node Introduction to Plotting
 @section Introduction to Plotting
 
 Earlier versions of Octave provided plotting through the use of
 gnuplot.  This capability is still available.  But, a newer plotting
 capability is provided by access to OpenGL@.  Which plotting system
-is used is controlled by the @code{graphics_toolkit} function.  (See
-@ref{Graphics Toolkits}.)
+is used is controlled by the @code{graphics_toolkit} function.
+@xref{Graphics Toolkits}.
 
 The function call @code{graphics_toolkit ("fltk")} selects the
 FLTK/OpenGL system, and @code{graphics_toolkit ("gnuplot")} selects the
 gnuplot system.  The two systems may be used selectively through the use
 of the @code{graphics_toolkit} property of the graphics handle for each
 figure.  This is explained in @ref{Graphics Data Structures}.
 @strong{Caution:} The FLTK toolkit uses single precision variables internally
 which limits the maximum value that can be displayed to approximately
@@ -52,36 +52,35 @@ toolkit which supports values up to @mat
 
 Octave provides simple means to create many different types of two- and
 three-dimensional plots using high-level functions.
 
 If you need more detailed control, see @ref{Graphics Data Structures}
 and @ref{Advanced Plotting}.
 
 @menu
-* Two-Dimensional Plots::       
-* Three-Dimensional Plots::  
-* Plot Annotations::            
-* Multiple Plots on One Page::  
-* Multiple Plot Windows::       
-* Use of axis@comma{} line@comma{} and patch Functions::
+* Two-Dimensional Plots::
+* Three-Dimensional Plots::
+* Plot Annotations::
+* Multiple Plots on One Page::
+* Multiple Plot Windows::
 * Manipulation of Plot Windows::
 * Use of the @code{interpreter} Property::
-* Printing and Saving Plots::              
-* Interacting with Plots::      
-* Test Plotting Functions::     
+* Printing and Saving Plots::
+* Interacting with Plots::
+* Test Plotting Functions::
 @end menu
 
 @node Two-Dimensional Plots
 @subsection Two-Dimensional Plots
 
 @menu
-* Axis Configuration::  
-* Two-dimensional Function Plotting::  
-* Two-dimensional Geometric Shapes::  
+* Axis Configuration::
+* Two-dimensional Function Plotting::
+* Two-dimensional Geometric Shapes::
 @end menu
 
 The @code{plot} function allows you to create simple x-y plots with
 linear axes.  For example,
 
 @example
 @group
 x = -10:0.1:10;
@@ -248,18 +247,21 @@ appearance of tic marks.
 Similarly the axis limits of the colormap can be changed with the caxis
 function.
 
 @DOCSTRING(caxis)
 
 The @code{xlim}, @code{ylim}, and @code{zlim} functions may be used to
 get or set individual axis limits.  Each has the same form.
 
-@anchor{docXylim}
-@anchor{docXzlim}
+@c Add cross-references and function index entries for other limit functions.
+@anchor{XREFylim}
+@anchor{XREFzlim}
+@findex ylim
+@findex zlim
 @DOCSTRING(xlim)
 
 @node Two-dimensional Function Plotting
 @subsubsection Two-dimensional Function Plotting
 
 Octave can plot a function from a function handle inline function or
 string defining the function without the user needing to explicitly
 create the data to be plotted.  The function @code{fplot} also generates
@@ -391,26 +393,26 @@ three-dimensional plots.
 @DOCSTRING(shading)
 
 @DOCSTRING(scatter3)
 
 @DOCSTRING(waterfall)
 
 @menu
 * Aspect Ratio::
-* Three-dimensional Function Plotting::  
-* Three-dimensional Geometric Shapes::  
+* Three-dimensional Function Plotting::
+* Three-dimensional Geometric Shapes::
 @end menu
 
 @node Aspect Ratio
 @subsubsection Aspect Ratio
 
 For three-dimensional plots the aspect ratio can be set for data with
-@code{daspect} and for the plot box with @code{pbaspect}.  
-See @ref{Axis Configuration} for controlling the x-, y-, and z-limits for
+@code{daspect} and for the plot box with @code{pbaspect}.
+@xref{Axis Configuration}, for controlling the x-, y-, and z-limits for
 plotting.
 
 @DOCSTRING(daspect)
 
 @DOCSTRING(pbaspect)
 
 @node Three-dimensional Function Plotting
 @subsubsection Three-dimensional Function Plotting
@@ -459,18 +461,18 @@ border lines are on.
 @DOCSTRING(title)
 
 @DOCSTRING(legend)
 
 @DOCSTRING(text)
 
 See @ref{Text Properties} for the properties that you can set.
 
-@anchor{docXylabel}
-@anchor{docXzlabel}
+@anchor{XREFylabel}
+@anchor{XREFzlabel}
 @DOCSTRING(xlabel)
 
 @DOCSTRING(clabel)
 
 @DOCSTRING(box)
 
 @DOCSTRING(grid)
 
@@ -518,33 +520,16 @@ fplot (@@cos, [-10, 10]);
 @end example
 
 @noindent
 creates two figures, with the first displaying a sine wave and
 the second a cosine wave.  Figure numbers must be positive integers.
 
 @DOCSTRING(figure)
 
-@node Use of axis@comma{} line@comma{} and patch Functions
-@subsection Use of axis@comma{} line@comma{} and patch Functions
-
-You can create axes, line, and patch objects directly using the
-@code{axes}, @code{line}, and @code{patch} functions.  These objects
-become children of the current axes object.
-
-@DOCSTRING(axes)
-
-@DOCSTRING(line)
-
-@DOCSTRING(patch)
-
-@DOCSTRING(fill)
-
-@DOCSTRING(surface)
-
 @node Manipulation of Plot Windows
 @subsection Manipulation of Plot Windows
 
 By default, Octave refreshes the plot window when a prompt is printed,
 or when waiting for input.  The
 @code{drawnow} function is used to cause a plot window to be updated.
 
 @DOCSTRING(drawnow)
@@ -598,26 +583,26 @@ figure window, call the @code{close} fun
 @DOCSTRING(close)
 
 @DOCSTRING(closereq)
 
 @node Use of the @code{interpreter} Property
 @subsection Use of the @code{interpreter} Property
 
 All text objects, including titles, labels, legends, and text, include
-the property 'interpreter', this property determines the manner in which
+the property @qcode{"interpreter"}, this property determines the manner in which
 special control sequences in the text are rendered.  If the interpreter
-is set to 'none', then no rendering occurs.  At this point the 'latex'
-option is not implemented and so the 'latex' interpreter also does not
-interpret the text.
-
-The 'tex' option implements a subset of @TeX{} functionality in the
+is set to @qcode{"none"}, then no rendering occurs.  At this point the
+@qcode{"latex"} option is not implemented and so the @qcode{"latex"}
+interpreter also does not interpret the text.
+
+The @qcode{"tex"} option implements a subset of @TeX{} functionality in the
 rendering of the text.  This allows the insertion of special characters
 such as Greek or mathematical symbols within the text.  The special
-characters are also inserted with a code starting with the back-slash
+characters are also inserted with a code starting with the backslash
 (\) character, as in the table @ref{tab:extended}.
 
 In addition, the formatting of the text can be changed within the string
 with the codes
 
 @multitable @columnfractions .2 .2 .6 .2
 @item @tab \bf @tab Bold font @tab
 @item @tab \it @tab Italic font @tab
@@ -628,200 +613,273 @@ with the codes
 These are be used in conjunction with the @{ and @} characters to limit
 the change in the font to part of the string.  For example,
 
 @example
 xlabel ('@{\bf H@} = a @{\bf V@}')
 @end example
 
 @noindent
-where the character 'a' will not appear in a bold font.  Note that to
+where the character @qcode{'a'} will not appear in a bold font.  Note that to
 avoid having Octave interpret the backslash characters in the strings,
 the strings should be in single quotes.
 
 It is also possible to change the fontname and size within the text
 
 @multitable @columnfractions .1 .4 .6 .1
 @item @tab \fontname@{@var{fontname}@} @tab Specify the font to use @tab
 @item @tab \fontsize@{@var{size}@} @tab Specify the size of the font to
 use @tab
 @end multitable
 
-Finally, the superscript and subscripting can be controlled with the '^'
-and '_' characters.  If the '^' or '_' is followed by a @{ character,
-then all of the block surrounded by the @{ @} pair is super- or
-sub-scripted.  Without the @{ @} pair, only the character immediately
-following the '^' or '_' is super- or sub-scripted.
+Finally, the superscript and subscripting can be controlled with the @qcode{'^'}
+and @qcode{'_'} characters.  If the @qcode{'^'} or @qcode{'_'} is followed by a
+@{ character, then all of the block surrounded by the @{ @} pair is super- or
+sub-scripted.  Without the @{ @} pair, only the character immediately following
+the @qcode{'^'} or @qcode{'_'} is super- or sub-scripted.
 
 @float Table,tab:extended
 @tex
 \vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
+\newdimen\cola \cola=78pt
+\newdimen\colb \colb=78pt
+\newdimen\colc \colc=78pt
+\def\symtable#1#2#3{
+\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
+\hskip36pt #1
+\vskip6pt
 \halign{
-\vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
-# \hfil & \vrule # & # \hfil & # \vrule &
-# \hfil & \vrule # & # \hfil & # \vrule &
-# \hfil & \vrule # & # \hfil & # \vrule
+\vrule height2.0ex depth1.ex width 0.6pt #2\tabskip=0.3em &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule
 width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & Code && Sym && Code && Sym && Code && Sym &\cr
 \noalign{\hrule}
-& $\backslash$forall    && $\forall$
-&& $\backslash$exists   && $\exists$
-&& $\backslash$ni       && $\ni$       &\cr
-& $\backslash$cong      && $\cong$
-&& $\backslash$Delta    && $\Delta$
-&& $\backslash$Phi      && $\Phi$      &\cr
-& $\backslash$Gamma     && $\Gamma$
-&& $\backslash$vartheta && $\vartheta$
-&& $\backslash$Lambda   && $\Lambda$   &\cr
-& $\backslash$Pi        && $\Pi$
-&& $\backslash$Theta    && $\Theta$
-&& $\backslash$Sigma    && $\Sigma$    &\cr
-& $\backslash$varsigma  && $\varsigma$
-&& $\backslash$Omega    && $\Omega$
-&& $\backslash$Xi       && $\Xi$       &\cr
-& $\backslash$Psi       && $\Psi$
-&& $\backslash$perp     && $\perp$
-&& $\backslash$alpha    && $\alpha$    &\cr
-& $\backslash$beta      && $\beta$
-&& $\backslash$chi      && $\chi$
-&& $\backslash$delta    && $\delta$    &\cr
-& $\backslash$epsilon   && $\epsilon$
-&& $\backslash$phi      && $\phi$
-&& $\backslash$gamma    && $\gamma$    &\cr
-& $\backslash$eta       && $\eta$
-&& $\backslash$iota     && $\iota$
-&& $\backslash$varphi   && $\varphi$   &\cr
-& $\backslash$kappa     && $\kappa$
-&& $\backslash$lambda   && $\lambda$
-&& $\backslash$mu       && $\mu$       &\cr
-& $\backslash$nu        && $\nu$
-&& $\backslash$o        && $\o$
-&& $\backslash$pi       && $\pi$       &\cr
-& $\backslash$theta     && $\theta$
-&& $\backslash$rho      && $\rho$
-&& $\backslash$sigma    && $\sigma$    &\cr
-& $\backslash$tau       && $\tau$
-&& $\backslash$upsilon  && $\upsilon$
-&& $\backslash$varpi    && $\varpi$    &\cr
-& $\backslash$omega     && $\omega$
-&& $\backslash$xi       && $\xi$
-&& $\backslash$psi      && $\psi$      &\cr
-& $\backslash$zeta      && $\zeta$
-&& $\backslash$sim      && $\sim$
-&& $\backslash$Upsilon  && $\Upsilon$  &\cr
-& $\backslash$prime     && $\prime$
-&& $\backslash$leq      && $\leq$
-&& $\backslash$infty    && $\infty$    &\cr
-& $\backslash$clubsuit  && $\clubsuit$
-&& $\backslash$diamondsuit    && $\diamondsuit$
-&& $\backslash$heartsuit      && $\heartsuit$     &\cr
-& $\backslash$spadesuit       && $\spadesuit$
-&& $\backslash$leftrightarrow && $\leftrightarrow$
-&& $\backslash$leftarrow      && $\leftarrow$     &\cr
-& $\backslash$uparrow         && $\uparrow$
-&& $\backslash$rightarrow     && $\rightarrow$
-&& $\backslash$downarrow      && $\downarrow$     &\cr
-& $\backslash$circ      && $\circ$
-&& $\backslash$pm       && $\pm$
-&& $\backslash$geq      && $\geq$      &\cr
-& $\backslash$times     && $\times$
-&& $\backslash$propto   && $\propto$
-&& $\backslash$partial  && $\partial$  &\cr
-& $\backslash$bullet    && $\bullet$
-&& $\backslash$div      && $\div$
-&& $\backslash$neq      && $\neq$      &\cr
-& $\backslash$equiv     && $\equiv$
-&& $\backslash$approx   && $\approx$
-&& $\backslash$ldots    && $\ldots$ &\cr
-& $\backslash$mid       && $\mid$
-&& $\backslash$aleph    && $\aleph$
-&& $\backslash$Im       && $\Im$ &\cr
-& $\backslash$Re        && $\Re$
-&& $\backslash$wp       && $\wp$
-&& $\backslash$otimes   && $\otimes$ &\cr
-& $\backslash$oplus     && $\oplus$
-&& $\backslash$oslash   && $\oslash$
-&& $\backslash$cap      && $\cap$ &\cr
-& $\backslash$cup       && $\cup$
-&& $\backslash$supset   && $\supset$
-&& $\backslash$supseteq && $\supseteq$ &\cr
-& $\backslash$subset    && $\subset$
-&& $\backslash$subseteq && $\subseteq$
-&& $\backslash$in       && $\in$ &\cr
-& $\backslash$notin     && $\notin$
-&& $\backslash$angle    && $\angle$
-&& $\backslash$bigtriangledown && $\bigtriangledown$ &\cr
-& $\backslash$langle    && $\langle$
-&& $\backslash$rangle   && $\rangle$
-&& $\backslash$nabla    && $\nabla$    &\cr
-& $\backslash$prod      && $\prod$
-&& $\backslash$surd     && $\surd$
-&& $\backslash$cdot     && $\cdot$     &\cr
-& $\backslash$neg       && $\neg$
-&& $\backslash$wedge    && $\wedge$
-&& $\backslash$vee      && $\vee$      &\cr
-& $\backslash$Leftrightarrow && $\Leftrightarrow$
-&& $\backslash$Leftarrow     && $\Leftarrow$
-&& $\backslash$Uparrow       && $\Uparrow$           &\cr
-& $\backslash$Rightarrow     && $\Rightarrow$
-&& $\backslash$Downarrow     && $\Downarrow$
-&& $\backslash$diamond  && $\diamond$  &\cr
-& $\backslash$copyright && $\copyright$
-&& $\backslash$rfloor   && $\rfloor$
-&& $\backslash$lceil    && $\lceil$    &\cr
-& $\backslash$lfloor    && $\lfloor$
-&& $\backslash$rceil    && $\rceil$
-&& $\backslash$int      && $\int$      &\cr
+#3
 \noalign{\hrule height 0.6pt}
-}}\hfill}}
+}
+}\hfill}}
+\hoffset72pt
+\symtable{Greek Lowercase Letters} {#}
+{& \hbox to \cola{$\backslash$alpha }    && $\alpha$
+&& \hbox to \colb{$\backslash$beta }     && $\beta$
+&& \hbox to \colc{$\backslash$gamma}     && $\gamma$     &\cr
+& $\backslash$delta      && $\delta$
+&& $\backslash$epsilon   && $\epsilon$
+&& $\backslash$zeta      && $\zeta$      &\cr
+& $\backslash$eta        && $\eta$
+&& $\backslash$theta     && $\theta$
+&& $\backslash$vartheta  && $\vartheta$  &\cr
+& $\backslash$iota       && $\iota$
+&& $\backslash$kappa     && $\kappa$
+&& $\backslash$lambda    && $\lambda$    &\cr
+& $\backslash$mu         && $\mu$
+&& $\backslash$nu        && $\nu$
+&& $\backslash$xi        && $\xi$        &\cr
+& $\backslash$o          && $o$
+&& $\backslash$pi        && $\pi$
+&& $\backslash$varpi     && $\varpi$     &\cr
+& $\backslash$rho        && $\rho$
+&& $\backslash$sigma     && $\sigma$
+&& $\backslash$varsigma  && $\varsigma$  &\cr
+& $\backslash$tau        && $\tau$
+&& $\backslash$upsilon   && $\upsilon$
+&& $\backslash$phi       && $\phi$       &\cr
+& $\backslash$chi        && $\chi$
+&& $\backslash$psi       && $\psi$
+&& $\backslash$omega     && $\omega$     &\cr}
+\vskip12pt
+\symtable{Greek Uppercase Letters} {#}
+{& \hbox to \cola{$\backslash$Gamma}   && $\Gamma$
+&& \hbox to \colb{$\backslash$Delta}   && $\Delta$
+&& \hbox to \colc{$\backslash$Theta}   && $\Theta$      &\cr
+& $\backslash$Lambda   && $\Lambda$
+&& $\backslash$Xi      && $\Xi$
+&& $\backslash$Pi      && $\Pi$         &\cr
+& $\backslash$Sigma    && $\Sigma$
+&& $\backslash$Upsilon && $\Upsilon$
+&& $\backslash$Phi     && $\Phi$        &\cr
+& $\backslash$Psi      && $\Psi$
+&& $\backslash$Omega   && $\Omega$
+&&    &&       &\cr}
+\vskip12pt
+\symtable{Misc Symbols Type Ord} {#}
+{& \hbox to \cola{$\backslash$aleph}       && $\aleph$
+&& \hbox to \colb{$\backslash$wp}          && $\wp$
+&& \hbox to \colc{$\backslash$Re}          && $\Re$      &\cr
+& $\backslash$Im           && $\Im$
+&& $\backslash$partial     && $\partial$
+&& $\backslash$infty       && $\infty$       &\cr
+& $\backslash$prime        && $\prime$
+&& $\backslash$nabla       && $\nabla$
+&& $\backslash$surd        && $\surd$        &\cr
+& $\backslash$angle        && $\angle$
+&& $\backslash$forall      && $\forall$
+&& $\backslash$exists      && $\exists$      &\cr
+& $\backslash$neg          && $\neg$
+&& $\backslash$clubsuit    && $\clubsuit$
+&& $\backslash$diamondsuit && $\diamondsuit$ &\cr
+& $\backslash$heartsuit    && $\heartsuit$
+&& $\backslash$spadesuit   && $\spadesuit$
+&&    &&       &\cr}
+\vskip12pt
+\symtable{``Large'' Operators} {#}
+{& \hbox to \cola{$\backslash$int}   && $\int$
+&& \hbox to \colb{}   &&
+&& \hbox to \colc{}   &&       &\cr}
+\vskip12pt
+\symtable{Binary operators} {#}
+{& \hbox to \cola{$\backslash$pm}     && $\pm$
+&& \hbox to \colb{$\backslash$cdot}   && $\cdot$
+&& \hbox to \colc{$\backslash$times}  && $\times$      &\cr
+& $\backslash$ast     && $\ast$
+&& $\backslash$circ   && $\circ$
+&& $\backslash$bullet && $\bullet$     &\cr
+& $\backslash$div     && $\div$
+&& $\backslash$cap    && $\cap$
+&& $\backslash$cup    && $\cup$        &\cr
+& $\backslash$vee     && $\vee$
+&& $\backslash$wedge  && $\wedge$
+&& $\backslash$oplus  && $\oplus$      &\cr
+& $\backslash$otimes  && $\otimes$
+&& $\backslash$oslash && $\oslash$
+&&    &&      &\cr}
 @end tex
 @ifnottex
-@multitable @columnfractions .125 .25 .25 .25 .125
-@item @tab  \forall     @tab  \exists     @tab  \ni      @tab
-@item @tab  \cong       @tab  \Delta      @tab  \Phi     @tab
-@item @tab  \Gamma      @tab  \vartheta   @tab  \Lambda  @tab
-@item @tab  \Pi         @tab  \Theta      @tab  \Sigma   @tab
-@item @tab  \varsigma   @tab  \Omega      @tab  \Xi      @tab
-@item @tab  \Psi        @tab  \perp       @tab  \alpha   @tab
-@item @tab  \beta       @tab  \chi        @tab  \delta   @tab
-@item @tab  \epsilon    @tab  \phi        @tab  \gamma   @tab
-@item @tab  \eta        @tab  \iota       @tab  \varphi  @tab
-@item @tab  \kappa      @tab  \lambda     @tab  \mu      @tab
-@item @tab  \nu         @tab  \o          @tab  \pi      @tab
-@item @tab  \theta      @tab  \rho        @tab  \sigma   @tab
-@item @tab  \tau        @tab  \upsilon    @tab  \varpi   @tab
-@item @tab  \omega      @tab  \xi         @tab  \psi     @tab
-@item @tab  \zeta       @tab  \sim        @tab  \Upsilon @tab
-@item @tab  \prime      @tab  \leq        @tab  \infty   @tab
-@item @tab  \clubsuit   @tab  \diamondsuit    @tab  \heartsuit  @tab
-@item @tab  \spadesuit  @tab  \leftrightarrow @tab  \leftarrow  @tab
-@item @tab  \uparrow    @tab  \rightarrow @tab  \downarrow @tab
-@item @tab  \circ       @tab \pm          @tab  \geq     @tab
-@item @tab  \times      @tab  \propto     @tab  \partial @tab
-@item @tab  \bullet     @tab \div         @tab  \neq     @tab
-@item @tab  \equiv      @tab  \approx     @tab  \ldots   @tab
-@item @tab  \mid        @tab  \aleph      @tab  \Im      @tab
-@item @tab  \Re         @tab \wp          @tab  \otimes  @tab
-@item @tab  \oplus      @tab \oslash      @tab  \cap     @tab
-@item @tab  \cup        @tab   \supset    @tab  \supseteq @tab
-@item @tab  \subset     @tab \subseteq    @tab  \in      @tab
-@item @tab  \notin      @tab \angle       @tab  \bigrightriangledown @tab
-@item @tab  \langle     @tab  \rangle     @tab  \nabla   @tab
-@item @tab  \prod       @tab \surd        @tab  \cdot    @tab
-@item @tab  \neg        @tab  \wedge      @tab \vee      @tab
-@item @tab  \Leftrightarrow @tab \Leftarrow @tab \Uparrow @tab
-@item @tab  \Rightarrow @tab \Downarrow   @tab \diamond  @tab
-@item @tab  \copyright  @tab  \lfloor     @tab  \lceil   @tab
-@item @tab  \rfloor     @tab  \rceil      @tab  \int     @tab
+@multitable @columnfractions .25 .25 .25 .25
+@item Greek Lowercase Letters
+@item @tab  \alpha      @tab  \beta        @tab  \gamma
+@item @tab  \delta      @tab  \epsilon     @tab  \zeta
+@item @tab  \eta        @tab  \theta       @tab  \vartheta
+@item @tab  \iota       @tab  \kappa       @tab  \lambda
+@item @tab  \mu         @tab  \nu          @tab  \xi
+@item @tab  \o          @tab  \pi          @tab  \varpi
+@item @tab  \rho        @tab  \sigma       @tab  \varsigma
+@item @tab  \tau        @tab  \upsilon     @tab  \phi
+@item @tab  \chi        @tab  \psi         @tab  \omega
+@item Greek Uppercase Letters
+@item @tab  \Gamma      @tab  \Delta       @tab  \Theta
+@item @tab  \Lambda     @tab  \Xi          @tab  \Pi
+@item @tab  \Sigma      @tab  \Upsilon     @tab  \Phi
+@item @tab  \Psi        @tab  \Omega       @tab
+@item Misc Symbols Type Ord
+@item @tab  \aleph      @tab  \wp          @tab  \Re
+@item @tab  \Im         @tab  \partial     @tab  \infty
+@item @tab  \prime      @tab  \nabla       @tab  \surd
+@item @tab  \angle      @tab  \forall      @tab  \exists
+@item @tab  \neg        @tab  \clubsuit    @tab  \diamondsuit
+@item @tab  \heartsuit  @tab  \spadesuit   @tab
+@item ``Large'' Operators
+@item @tab  \int
+@item Binary Operators
+@item @tab  \pm         @tab  \cdot        @tab  \times
+@item @tab  \ast        @tab  \circ        @tab  \bullet
+@item @tab  \div        @tab  \cap         @tab  \cup
+@item @tab  \vee        @tab  \wedge       @tab  \oplus
+@item @tab  \otimes     @tab  \oslash      @tab
+@item Relations
+@item @tab  \leq        @tab  \subset      @tab  \subseteq
+@item @tab  \in         @tab  \geq         @tab  \supset
+@item @tab  \supseteq   @tab  \ni          @tab  \mid
+@item @tab  \equiv      @tab  \sim         @tab  \approx
+@item @tab  \cong       @tab  \propto      @tab  \perp
+@item Arrows
+@item @tab  \leftarrow  @tab  \Leftarrow   @tab  \rightarrow
+@item @tab  \Rightarrow @tab  \leftrightarrow @tab  \uparrow
+@item @tab  \downarrow  @tab               @tab
+@item Openings and Closings
+@item @tab  \lfloor     @tab  \langle      @tab  \lceil
+@item @tab  \rfloor     @tab  \rangle      @tab  \rceil
+@item Alternate Names
+@item @tab  \neq
+@item Other
+@item @tab  \ldots      @tab  \0          @tab  \copyright
+@item @tab  \deg
 @end multitable
 @end ifnottex
 @caption{Available special characters in @TeX{} mode}
 @end float
+@float
+@tex
+\vskip 6pt
+\newdimen\cola \cola=78pt
+\newdimen\colb \colb=78pt
+\newdimen\colc \colc=78pt
+\def\symtable#1#2#3{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
+\hskip36pt #1
+\vskip6pt
+\halign{
+\vrule height2.0ex depth1.ex width 0.6pt #2\tabskip=0.3em &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule &
+#2 \hfil & \vrule #2 & #2 \hfil & #2 \vrule
+width 0.6pt \tabskip=0pt\cr
+\noalign{\hrule height 0.6pt}
+& Code && Sym && Code && Sym && Code && Sym &\cr
+\noalign{\hrule}
+#3
+\noalign{\hrule height 0.6pt}
+}
+}\hfill}}
+\hoffset72pt
+\vskip12pt
+\symtable{Relations} {#}
+{& \hbox to \cola{$\backslash$leq}      && $\leq$
+&& \hbox to \colb{$\backslash$subset}   && $\subset$
+&& \hbox to \colc{$\backslash$subseteq} && $\subseteq$    &\cr
+& $\backslash$in        && $\in$
+&& $\backslash$geq      && $\geq$
+&& $\backslash$supset   && $\supset$      &\cr
+& $\backslash$supseteq  && $\supseteq$
+&& $\backslash$ni       && $\ni$
+&& $\backslash$mid      && $\mid$         &\cr
+& $\backslash$equiv     && $\equiv$
+&& $\backslash$sim      && $\sim$
+&& $\backslash$approx   && $\approx$      &\cr
+& $\backslash$cong      && $\cong$
+&& $\backslash$propto   && $\propto$
+&& $\backslash$perp     && $\perp$        &\cr}
+\vskip12pt
+\symtable{Arrows} {#}
+{& \hbox to \cola{$\backslash$leftarrow}      && $\leftarrow$
+&& \hbox to \colb{$\backslash$Leftarrow}      && $\Leftarrow$
+&& \hbox to \colc{$\backslash$rightarrow}     && $\rightarrow$      &\cr
+& $\backslash$Rightarrow      && $\Rightarrow$
+&& $\backslash$leftrightarrow && $\leftrightarrow$
+&& $\backslash$uparrow        && $\uparrow$         &\cr
+& $\backslash$downarrow       && $\downarrow$
+&&   && 
+&&   &&       &\cr}
+\vskip12pt
+\symtable{Openings and Closings} {#}
+{& \hbox to \cola{$\backslash$lfloor   }    && $\lfloor$
+&& \hbox to \colb{$\backslash$langle   }    && $\langle$
+&& \hbox to \colc{$\backslash$lceil    }    && $\lceil$      &\cr
+& $\backslash$rfloor    && $\rfloor$
+&& $\backslash$rangle   && $\rangle$
+&& $\backslash$rceil    && $\rceil$      &\cr}
+\vskip12pt
+\symtable{Alternate Names} {#}
+{& \hbox to \cola{$\backslash$neq}   && $\neq$
+&& \hbox to \colb{}   && 
+&& \hbox to \colc{}   &&   &\cr}
+\vskip12pt
+\symtable{Other (not in Appendix F Tables)} {#}
+{& \hbox to \cola{$\backslash$ldots}     && $\ldots$
+&& \hbox to \colb{$\backslash$0}         && $\oslash$
+&& \hbox to \colc{$\backslash$copyright} && $\copyright$      &\cr
+& $\backslash$deg        && $^\circ$
+&&    &&  
+&&    &&       &\cr}
+\vskip12pt
+\hskip36pt Table 15.1: Available special characters in \TeX\ mode (cont.)
+@end tex
+@end float
 
 A complete example showing the capabilities of the extended text is
 
 @example
 @group
 x = 0:0.01:3;
 plot (x, erf (x));
 hold on;
@@ -898,27 +956,27 @@ at the Octave prompt should display a th
 @DOCSTRING(sombrero)
 
 @DOCSTRING(peaks)
 @node Graphics Data Structures
 @section Graphics Data Structures
 @cindex graphics data structures
 
 @menu
-* Introduction to Graphics Structures::  
-* Graphics Objects::            
-* Graphics Object Properties::  
-* Searching Properties::        
-* Managing Default Properties::  
+* Introduction to Graphics Structures::
+* Graphics Objects::
+* Graphics Object Properties::
+* Searching Properties::
+* Managing Default Properties::
 @end menu
 
 @node Introduction to Graphics Structures
 @subsection Introduction to Graphics Structures
 @cindex introduction to graphics structures
-@anchor{docXgraphics structures}
+@anchor{XREFgraphics structures}
 
 The graphics functions use pointers, which are of class graphics_handle, in
 order to address the data structures which control graphical displays.  A
 graphics handle may point any one of a number of different object types.  The
 objects are the graphics data structures.  The types of objects are:
 @code{figure}, @code{axes}, @code{line}, @code{text}, @code{patch},
 @code{surface}, @code{text} and @code{image}.
 
@@ -928,61 +986,61 @@ type.  In addition there are several fun
 the graphics objects and which return handles: the functions @code{ plot} and
 @code{plot3} return a handle pointing to an object of type line, the function
 @code{subplot} returns a handle pointing to an object of type axes, the
 function @code{fill} returns a handle pointing to an object of type patch, the
 functions @code{area}, @code{bar}, @code{barh}, @code{contour},
 @code{contourf}, @code{contour3}, @code{surf}, @code{mesh}, @code{surfc},
 @code{meshc}, @code{errorbar}, @code{quiver}, @code{quiver3}, @code{scatter},
 @code{scatter3}, @code{stair}, @code{stem}, @code{stem3} each return a handle
-as documented in @ref{docXdatasources,, Data Sources}.
+as documented in @ref{XREFdatasources,,Data Sources}.
 
 
 The graphics objects are arranged in a hierarchy:
 
 1. The root is at 0.  i.e., @code{get (0)} returns the properties of the root
    object.
 
 2. Below the root are @code{figure} objects.
 
 3. Below the @code{figure} objects are @code{axes}.
 
 4. Below the @code{axes} objects are
 @code{line}, @code{text}, @code{patch},
 @code{surface}, and @code{image} objects.
 
 Graphics handles may be distinguished from function handles
-(@ref{Function Handles}) by means of the function @code{ishandle}.
-@code{ishandle} returns true if its argument is a handle of a graphics object. 
-In addition, the figure object may be tested using @code{isfigure}. 
+(@pxref{Function Handles}) by means of the function @code{ishandle}.
+@code{ishandle} returns true if its argument is a handle of a graphics object.
+In addition, the figure object may be tested using @code{isfigure}.
 @code{isfigure} returns true only if its argument is a handle of a figure.  The
 @code{whos} function can be used to show the object type of each currently
 defined graphics handle.  (Note: this is not true today, but it is, I hope,
 considered an error in whos.  It may be better to have whos just show
 graphics_handle as the class, and provide a new function which, given a
 graphics handle, returns its object type.  This could generalize the ishandle()
 functions and, in fact, replace them.)
 
 The @code{get} and @code{set} commands are used to obtain and set the values of
 properties of graphics objects.  In addition, the @code{get} command may be
 used to obtain property names.
 
-For example, the property "type" of the graphics object pointed to by the
-graphics handle h may be displayed by:
+For example, the property @qcode{"type"} of the graphics object pointed to by
+the graphics handle h may be displayed by:
 
 @example
 get (h, "type")
 @end example
 
 The properties and their current values are returned by @code{get (h)}
 where h is a handle of a graphics object.  If only the names of the
 allowed properties are wanted they may be displayed by:
 @code{get (h, "")}.
 
-Thus, for example,
+Thus, for example:
 
 @smallexample
 h = figure ();
 get (h, "type")
 ans = figure
 get (h, "");
 error: get: ambiguous figure property name ; possible matches:
 
@@ -996,41 +1054,41 @@ beingdeleted          menubar           
 busyaction            mincolormap          type
 buttondownfcn         name                 uicontextmenu
 children              nextplot             units
 clipping              numbertitle          userdata
 closerequestfcn       paperorientation     visible
 color                 paperposition        windowbuttondownfcn
 colormap              paperpositionmode    windowbuttonmotionfcn
 createfcn             papersize            windowbuttonupfcn
-currentaxes           papertype            windowbuttonwheelfcn
+currentaxes           papertype            windowscrollwheelfcn
 currentcharacter      paperunits           windowstyle
 currentobject         parent               wvisual
 currentpoint          pointer              wvisualmode
 deletefcn             pointershapecdata    xdisplay
 dockcontrols          pointershapehotspot  xvisual
 doublebuffer          position             xvisualmode
 filename              renderer
 handlevisibility      renderermode
 @end smallexample
 
 The root figure has index 0.  Its properties may be displayed by:
 @code{get (0, "")}.
 
 The uses of @code{get} and @code{set} are further explained in
-@ref{docXget,,get}, @ref{docXset,,set}.
+@ref{XREFget,,get}, @ref{XREFset,,set}.
 
 @DOCSTRING(isprop)
 
 @node Graphics Objects
 @subsection Graphics Objects
 @cindex graphics objects
 
-The hierarchy of graphics objects was explained above.  (See 
-@ref{Introduction to Graphics Structures}.  Here the
+The hierarchy of graphics objects was explained above.
+@xref{Introduction to Graphics Structures}.  Here the
 specific objects are described, and the properties contained in
 these objects are discussed.  Keep in mind that
 graphics objects are always referenced by @dfn{handle}.
 
 @table @asis
 @c @group
 
 @item root figure
@@ -1072,26 +1130,46 @@ A filled polygon, currently limited to t
 
 @item surface
 @cindex surface graphics object
 @cindex graphics object, surface
 A three-dimensional surface.
 @c @end group
 @end table
 
+@subsubsection Creating Graphics Objects
+@cindex creating graphics objects
+
+You can create axes, line, patch, and surface objects directly using the
+@code{axes}, @code{line}, @code{patch}, @code{fill}, and @code{surface}
+functions.  These objects become children of the current axes object.
+
+@DOCSTRING(axes)
+
+@DOCSTRING(line)
+
+@DOCSTRING(patch)
+
+@DOCSTRING(fill)
+
+@DOCSTRING(surface)
+
 @subsubsection Handle Functions
 @cindex handle functions
 
-To determine whether a variable is a graphics object index or a figure
-index, use the functions @code{ishandle} and @code{isfigure}.
+To determine whether a variable is a graphics object index, or an index
+to an axes or figure, use the functions @code{ishandle}, @code{isaxes}, and
+@code{isfigure}.
 
 @DOCSTRING(ishandle)
 
 @DOCSTRING(ishghandle)
 
+@DOCSTRING(isaxes)
+
 @DOCSTRING(isfigure)
 
 The function @code{gcf} returns an index to the current figure object,
 or creates one if none exists.  Similarly, @code{gca} returns the
 current axes object, or creates one (and its parent figure object) if
 none exists.
 
 @DOCSTRING(gcf)
@@ -1170,19 +1248,19 @@ objects.
 
 @DOCSTRING(findfigs)
 
 @cindex saving graphics objects
 
 Figures can be printed or saved in many graphics formats with @code{print} and
 @code{saveas}.  Occasionally, however, it may be useful to save the original
 Octave handle graphic directly so that further modifications can be made such
-as modifying a title or legend.  
-
-This can be accomplished with the following functions by 
+as modifying a title or legend.
+
+This can be accomplished with the following functions by
 
 @example
 @group
 fig_struct = hdl2struct (gcf);
 save myplot.fig -struct fig_struct;
 @dots{}
 fig_struct = load ("myplot.fig");
 struct2hdl (fig_struct);
@@ -1195,70 +1273,70 @@ struct2hdl (fig_struct);
 
 @DOCSTRING(copyobj)
 
 @node Graphics Object Properties
 @subsection Graphics Object Properties
 @cindex graphics object properties
 
 @menu
-* Root Figure Properties::      
-* Figure Properties::           
-* Axes Properties::             
-* Line Properties::             
-* Text Properties::             
-* Image Properties::            
-* Patch Properties::            
-* Surface Properties::          
+* Root Figure Properties::
+* Figure Properties::
+* Axes Properties::
+* Line Properties::
+* Text Properties::
+* Image Properties::
+* Patch Properties::
+* Surface Properties::
 @end menu
 
 In this Section the object properties are discussed in detail, starting
 with the root figure properties and continuing through the graphics object
 hierarchy.
 
 @node Root Figure Properties
 @subsubsection Root Figure Properties
 @cindex root figure properties
 
 The @code{root figure} properties are:
 
 @table @code
-@item __modified__  
---- Values: "on," "off"
+@item __modified__
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item __myhandle__
 
-@item beingdeleted  
---- Values: "on," "off"
+@item beingdeleted
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item busyaction
 
 @item buttondownfcn
 
 @item callbackobject
 
 @item children
 
 @item clipping
- --- Values: "on," "off"
+ --- Values: @qcode{"on"}, @qcode{"off"}
 
 @item createfcn
 
 @item currentfigure
 
 @item deletefcn
 
-@item handlevisibility  
---- Values: "on," "off"
+@item handlevisibility
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item hittest
---- Values: "on," "off"
-
-@item interruptible  
---- Values: "on," "off"
+--- Values: @qcode{"on"}, @qcode{"off"}
+
+@item interruptible
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item parent
 
 @item screendepth
 
 @item screenpixelsperinch
 
 @item screensize
@@ -1266,18 +1344,18 @@ The @code{root figure} properties are:
 @item selected
 
 @item selectionhighlight
 
 @item screendepth
 
 @item screenpixelsperinch
 
-@item showhiddenhandles  
---- Values: "on," "off"
+@item showhiddenhandles
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item tag
 
 @item type
 
 @item uicontextmenu
 
 @item units
@@ -1289,136 +1367,136 @@ The @code{root figure} properties are:
 
 @node Figure Properties
 @subsubsection Figure Properties
 @cindex figure properties
 
 The @code{figure} properties are:
 
 @table @code
-@item __graphics_toolkit__  
+@item __graphics_toolkit__
 --- The graphics toolkit currently in use.
 
 @item __enhanced__
 
 @item __modified__
 
 @item __myhandle__
 
 @item __plot_stream__
 
 @item alphamap
 
-@item beingdeleted 
---- Values: "on," "off"
+@item beingdeleted
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item busyaction
 
 @item buttondownfcn
 
 @item children
 Handle to children.
 
 @item clipping
---- Values: "on," "off"
-
-@item closerequestfcn 
+--- Values: @qcode{"on"}, @qcode{"off"}
+
+@item closerequestfcn
 --- Handle of function to call on close.
 
 @item color
 
 @item colormap
 An N-by-3 matrix containing the color map for the current axes.
 
 @item paperorientation
 
 @item createfcn
 
-@item currentaxes 
+@item currentaxes
 Handle to graphics object of current axes.
 
 @item currentcharacter
 
 @item currentobject
 
 @item currentpoint
 Holds the coordinates of the point over which the mouse pointer was when
 the mouse button was pressed.  If a mouse callback function is defined,
-@code{"currentpoint"} holds the coordinates of the point over which the
+@qcode{"currentpoint"} holds the coordinates of the point over which the
 mouse pointer is when the function gets called.
 
 @item deletefcn
 
-@item dockcontrols 
---- Values: "on," "off"
-
-@item doublebuffer 
---- Values: "on," "off"
+@item dockcontrols
+--- Values: @qcode{"on"}, @qcode{"off"}
+
+@item doublebuffer
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item filename
 
-@item handlevisibility 
---- Values: "on," "off"
+@item handlevisibility
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item hittest
 
 @item integerhandle
 
-@item interruptible 
---- Values: "on," "off"
+@item interruptible
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item inverthardcopy
 
 @item keypressfcn
-see @code{"keypressfcn"}
+see @qcode{"keypressfcn"}
 
 @item keyreleasefcn
-With @code{"keypressfcn"}, The keyboard callback functions.  These
+With @qcode{"keypressfcn"}, the keyboard callback functions.  These
 callback functions get called when a key is pressed/released
 respectively.  The functions are called with two input arguments.  The
 first argument holds the handle of the calling figure.  The second
 argument holds the event structure which has the following members:
 
 @table @code
 @item Character
 The ASCII value of the key
 
 @item Key
 lowercase value of the key
 
 @item Modifier
 A cell array containing strings representing the modifiers pressed with
-the key.  Possible values are @code{"shift"}, @code{"alt"}, and
-@code{"control"}.
+the key.  Possible values are @qcode{"shift"}, @qcode{"alt"}, and
+@qcode{"control"}.
 @end table
 
 @item menubar
 
 @item mincolormap
 
 @item name
 
 @item nextplot
 May be one of
 
-@table @code
-@item "new"
-
-@item "add"
-
-@item "replace"
-
-@item "replacechildren"
+@table @asis
+@item @qcode{"new"}
+
+@item @qcode{"add"}
+
+@item @qcode{"replace"}
+
+@item @qcode{"replacechildren"}
 @end table
 
 @item numbertitle
 
 @item paperorientation
-Indicates the orientation for printing.  Either @code{"landscape"} or
-@code{"portrait"}.
+Indicates the orientation for printing.  Either @qcode{"landscape"} or
+@qcode{"portrait"}.
 
 @item paperposition
 
 @item paperpositionmode
 
 @item papersize
 
 @item papertype
@@ -1438,48 +1516,48 @@ Indicates the orientation for printing. 
 @item renderermode
 
 @item resize
 
 @item resizefcn
 
 @item selected
 
-@item selectionhighlight 
---- Values: "on," "off"
+@item selectionhighlight
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item selectiontype
 
 @item tag
 
 @item toolbar
 
 @item type
 
 @item units
 
 @item userdata
 
 @item visible
-Either @code{"on"} or @code{"off"} to toggle display of the figure.
+Either @qcode{"on"} or @qcode{"off"} to toggle display of the figure.
 
 @item windowbuttondownfcn
-See @code{"windowbuttonupfcn"}
+See @qcode{"windowbuttonupfcn"}
 
 @item windowbuttonmotionfcn
-See @code{"windowbuttonupfcn"}
+See @qcode{"windowbuttonupfcn"}
 
 @item windowbuttonupfcn
-With @code{"windowbuttondownfcn"} and @code{"windowbuttonmotionfcn"},
-The mouse callback functions.  These callback functions get called when
+With @qcode{"windowbuttondownfcn"} and @qcode{"windowbuttonmotionfcn"},
+the mouse callback functions.  These callback functions get called when
 the mouse button is pressed, dragged, and released respectively.  When
-these callback functions are called, the @code{"currentpoint"} property
+these callback functions are called, the @qcode{"currentpoint"} property
 holds the current coordinates of the cursor.
 
-@item windowbuttonwheelfcn
+@item windowscrollwheelfcn
 
 @item windowstyle
 
 @item wvisual
 
 @item wvisualmode
 
 @item xdisplay
@@ -1506,18 +1584,18 @@ The @code{axes} properties are:
 
 @item alimmode
 
 @item ambientlightcolor
 
 @item beingdeleted
 
 @item box
-Box surrounding axes. 
---- Values: "on," "off"
+Box surrounding axes.
+--- Values: @qcode{"on"}, @qcode{"off"}
 
 @item busyaction
 
 @item buttondownfcn
 
 @item cameraposition
 
 @item camerapositionmode
@@ -1535,45 +1613,45 @@ Box surrounding axes.
 @item cameraviewanglemode
 
 @item children
 
 @item clim
 Two-element vector defining the limits for the c axis of
 an image.  See @code{pcolor} property.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item climmode
-Either @code{"manual"} or @code{"auto"}.
+Either @qcode{"manual"} or @qcode{"auto"}.
 
 @item clipping
 
 @item color
 
 @item colororder
 
 @item createfcn
 
 @item currentpoint
 Holds the coordinates of the point over which the mouse pointer was when
 the mouse button was pressed.  If a mouse callback function is defined,
-@code{"currentpoint"} holds the coordinates of the point over which the
+@qcode{"currentpoint"} holds the coordinates of the point over which the
 mouse pointer is when the function gets called.
 
 @item dataaspectratio
 A two-element vector specifying the relative height and width of the
 data displayed in the axes.  Setting @code{dataaspectratio} to @samp{1,
 2]} causes the length of one unit as displayed on the y-axis to be the
 same as the length of 2 units on the x-axis.  Setting
 @code{dataaspectratio} also forces the @code{dataaspectratiomode}
-property to be set to @code{"manual"}.
-
-@item dataaspectratiomode 
-Either @code{"manual"} or @code{"auto"}.
+property to be set to @qcode{"manual"}.
+
+@item dataaspectratiomode
+Either @qcode{"manual"} or @qcode{"auto"}.
 
 @item deletefcn
 
 @item drawmode
 
 @item fontangle
 
 @item fontname
@@ -1600,24 +1678,22 @@ Either @code{"manual"} or @code{"auto"}.
 
 @item linewidth
 
 @item minorgridlinestyle
 
 @item nextplot
 May be one of
 
-@table @code
-@item "new"
-
-@item "add"
-
-@item "replace"
-
-@item "replacechildren"
+@table @asis
+@item @qcode{"add"}
+
+@item @qcode{"replace"}
+
+@item @qcode{"replacechildren"}
 @end table
 
 @item outerposition
 A vector specifying the position of the plot, including titles, axes and
 legend.  The four elements of the vector are the coordinates of the
 lower left corner and width and height of the plot, in units normalized
 to the width and height of the plot window.  For example, @code{[0.2,
 0.3, 0.4, 0.5]} sets the lower left corner of the axes at @math{(0.2,
@@ -1665,159 +1741,159 @@ Index of text object for the axes title.
 @item units
 
 @item userdata
 
 @item view
 A three element vector specifying the view point for three-dimensional plots.
 
 @item visible
-Either @code{"on"} or @code{"off"} to toggle display of the axes.
+Either @qcode{"on"} or @qcode{"off"} to toggle display of the axes.
 
 @item x_normrendertransform
 
 @item x_projectiontransform
 
 @item x_rendertransform
 
 @item x_viewporttransform
 
 @item x_viewtransform
 
-@item xaxislocation 
-Either @code{"top"} or @code{"bottom"}.
+@item xaxislocation
+Either @qcode{"top"} or @qcode{"bottom"}.
 
 @item xcolor
 
 @item xdir
-Either @code{"forward"} or @code{"reverse"}.
+Either @qcode{"forward"} or @qcode{"reverse"}.
 
 @item xgrid
-Either @code{"on"} or @code{"off"} to toggle display of grid lines.
+Either @qcode{"on"} or @qcode{"off"} to toggle display of grid lines.
 
 @item xlabel
 Indices to text objects for the axes labels.
 
 @item xlim
 Two-element vector defining the limits for the x-axis.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item xlimmode
-Either @code{"manual"} or @code{"auto"}.
-
-@item xminorgrid 
-Either @code{"on"} or @code{"off"} to toggle display of minor grid lines.
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item xminorgrid
+Either @qcode{"on"} or @qcode{"off"} to toggle display of minor grid lines.
 
 @item xminortick
 
 @item xscale
-Either @code{"linear"} or @code{"log"}.
+Either @qcode{"linear"} or @qcode{"log"}.
 
 @item xtick
 Set position of tick marks.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item xticklabel
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
-
-@item xticklabelmode 
-Either @code{"manual"} or @code{"auto"}.
-
-@item xtickmode 
-Either @code{"manual"} or @code{"auto"}.
-
-@item yaxislocation 
-Either @code{"left"} or @code{"right"}
+property to be set to @qcode{"manual"}.
+
+@item xticklabelmode
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item xtickmode
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item yaxislocation
+Either @qcode{"left"} or @qcode{"right"}
 
 @item ycolor
 
 @item ydir
-Either @code{"forward"} or @code{"reverse"}.
+Either @qcode{"forward"} or @qcode{"reverse"}.
 
 @item ygrid
-Either @code{"on"} or @code{"off"} to toggle display of grid lines.
+Either @qcode{"on"} or @qcode{"off"} to toggle display of grid lines.
 
 @item ylabel
 Indices to text objects for the axes labels.
 
 @item ylim
 Two-element vectors defining the limits for the x, y, and z axes and the
 Setting one of these properties also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item ylimmode
-Either @code{"manual"} or @code{"auto"}.
-
-@item yminorgrid 
-Either @code{"on"} or @code{"off"} to toggle display of minor grid lines.
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item yminorgrid
+Either @qcode{"on"} or @qcode{"off"} to toggle display of minor grid lines.
 
 @item yminortick
 
 @item yscale
-Either @code{"linear"} or @code{"log"}.
+Either @qcode{"linear"} or @qcode{"log"}.
 
 @item ytick
 Set position of tick marks.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item yticklabel
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
-
-@item yticklabelmode 
-Either @code{"manual"} or @code{"auto"}.
-
-@item ytickmode 
-Either @code{"manual"} or @code{"auto"}.
+property to be set to @qcode{"manual"}.
+
+@item yticklabelmode
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item ytickmode
+Either @qcode{"manual"} or @qcode{"auto"}.
 
 @item zcolor
 
 @item zdir
-Either @code{"forward"} or @code{"reverse"}.
+Either @qcode{"forward"} or @qcode{"reverse"}.
 
 @item zgrid
-Either @code{"on"} or @code{"off"} to toggle display of grid lines.
+Either @qcode{"on"} or @qcode{"off"} to toggle display of grid lines.
 
 @item zlabel
 Indices to text objects for the axes labels.
 
 @item zlim
 Two-element vector defining the limits for z-axis.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
+property to be set to @qcode{"manual"}.
 
 @item zlimmode
-Either @code{"manual"} or @code{"auto"}.
-
-@item zminorgrid 
-Either @code{"on"} or @code{"off"} to toggle display of minor grid lines.
+Either @qcode{"manual"} or @qcode{"auto"}.
+
+@item zminorgrid
+Either @qcode{"on"} or @qcode{"off"} to toggle display of minor grid lines.
 
 @item zminortick
 
 @item zscale
-Either @code{"linear"} or @code{"log"}.
+Either @qcode{"linear"} or @qcode{"log"}.
 
 @item ztick
 Set position of tick marks.
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
-
-@item zticklabel 
+property to be set to @qcode{"manual"}.
+
+@item zticklabel
 Setting this property also forces the corresponding mode
-property to be set to @code{"manual"}.
-
-@item zticklabelmode 
-Either @code{"manual"} or @code{"auto"}.
+property to be set to @qcode{"manual"}.
+
+@item zticklabelmode
+Either @qcode{"manual"} or @qcode{"auto"}.
 
 @item ztickmode
-Either @code{"manual"} or @code{"auto"}.
+Either @qcode{"manual"} or @qcode{"auto"}.
 
 @end table
 
 @node Line Properties
 @subsubsection Line Properties
 @cindex line properties
 
 The @code{line} properties are:
@@ -1855,17 +1931,17 @@ The text of the legend entry correspondi
 
 @item interpreter
 
 @item interruptible
 
 @item ldata
 The lower errorbar in the y direction to be plotted.
 
-@item linestyle
+@item  linestyle
 @itemx linewidth
 @xref{Line Styles}.
 
 @item linewidth
 
 @item marker
 
 @item markeredgecolor
@@ -1963,41 +2039,41 @@ The text of the legend entry correspondi
 
 @item edgecolor
 
 @item editing
 
 @item erasemode
 
 @item fontangle
-Flag whether the font is italic or normal.  Valid values are 'normal',
-'italic' and 'oblique'.
+Flag whether the font is italic or normal.  Valid values are @qcode{"normal"},
+@qcode{"italic"}, and @qcode{"oblique"}.
 
 @item fontname
 The font used for the text.
 
 @item fontsize
 The size of the font, in points to use.
 
 @item fontunits
 
 @item fontweight
-Flag whether the font is bold, etc.  Valid values are 'normal', 'bold',
-'demi' or 'light'.
+Flag whether the font is bold, etc.  Valid values are @qcode{"normal"},
+@qcode{"bold"}, @qcode{"demi"}, or @qcode{"light"}.
 
 @item handlevisibility
 
 @item hittest
 
 @item horizontalalignment
-May be @code{"left"}, @code{"center"}, or @code{"right"}.
+May be @qcode{"left"}, @qcode{"center"}, or @qcode{"right"}.
 
 @item interpreter
-Determines how the text is rendered.  Valid values are 'none', 'tex' or
-'latex'.
+Determines how the text is rendered.  Valid values are @qcode{"none"},
+@qcode{"tex"}, or @qcode{"latex"}.
 
 @item interruptible
 
 @item linestyle
 
 @item linewidth
 
 @item margin
@@ -2019,17 +2095,17 @@ The character string contained by the te
 
 @item tag
 
 @item type
 
 @item uicontextmenu
 
 @item units
-May be @code{"normalized"} or @code{"graph"}.
+May be @qcode{"normalized"} or @qcode{"graph"}.
 
 @item userdata
 
 @item verticalalignment
 
 @item visible
 
 @item xlim
@@ -2430,18 +2506,18 @@ elements are vectors and @code{zdata} mu
 
 Object properties have two classes of default values, @dfn{factory
 defaults} (the initial values) and @dfn{user-defined defaults}, which
 may override the factory defaults.
 
 Although default values may be set for any object, they are set in
 parent objects and apply to child objects, of the specified object type.
 For example, setting the default @code{color} property of @code{line}
-objects to "green", for the @code{root} object, will result in all
-@code{line} objects inheriting the @code{color} "green" as the default
+objects to @qcode{"green"}, for the @code{root} object, will result in all
+@code{line} objects inheriting the @code{color} @qcode{"green"} as the default
 value.
 
 @example
 set (0, "defaultlinecolor", "green");
 @end example
 
 @noindent
 sets the default line color for all objects.  The rule for constructing
@@ -2479,30 +2555,30 @@ line (1:10, rand (1, 10));
 produces two figures.  The line in first subplot window of the first
 figure is blue because it inherits its color from its parent axes
 object.  The line in the second subplot window of the first figure is
 green because it inherits its color from its parent figure object.  The
 line in the second figure window is red because it inherits its color
 from the global root figure parent object.
 
 To remove a user-defined default setting, set the default property to
-the value @code{"remove"}.  For example,
+the value @qcode{"remove"}.  For example,
 
 @example
 set (gca (), "defaultlinecolor", "remove");
 @end example
 
 @noindent
 removes the user-defined default line color setting from the current axes
 object.  To quickly remove all user-defined defaults use the @code{reset}
 function.
 
 @DOCSTRING(reset)
 
-Getting the @code{"default"} property of an object returns a list of
+Getting the @qcode{"default"} property of an object returns a list of
 user-defined defaults set for the object.  For example,
 
 @example
 get (gca (), "default");
 @end example
 
 @noindent
 returns a list of user-defined default values for the current axes
@@ -2518,35 +2594,35 @@ get (0, "factory");
 @noindent
 returns a list of factory defaults.
 
 @node Advanced Plotting
 @section Advanced Plotting
 
 
 @menu
-* Colors::                      
-* Line Styles::                 
-* Marker Styles::               
-* Callbacks::                   
+* Colors::
+* Line Styles::
+* Marker Styles::
+* Callbacks::
 * Application-defined Data::
-* Object Groups::               
-* Graphics Toolkits::           
+* Object Groups::
+* Graphics Toolkits::
 @end menu
 
 
 @node Colors
 @subsection Colors
 @cindex graphics colors
 @cindex colors, graphics
 
 Colors may be specified as RGB triplets with values ranging from zero to
-one, or by name.  Recognized color names include @code{"blue"},
-@code{"black"}, @code{"cyan"}, @code{"green"}, @code{"magenta"},
-@code{"red"}, @code{"white"}, and @code{"yellow"}.
+one, or by name.  Recognized color names include @qcode{"blue"},
+@qcode{"black"}, @qcode{"cyan"}, @qcode{"green"}, @qcode{"magenta"},
+@qcode{"red"}, @qcode{"white"}, and @qcode{"yellow"}.
 
 @node Line Styles
 @subsection Line Styles
 @cindex line styles, graphics
 @cindex graphics line styles
 
 Line styles are specified by the following properties:
 
@@ -2562,17 +2638,17 @@ Solid line.  [default]
 Dashed line.
 
 @item ":"
 Dotted line.
 
 @item "-."
 A dash-dot line.
 
-@item "none"
+@item @qcode{"none"}
 No line.  Points will still be marked using the current Marker Style.
 @end table
 
 @item linewidth
 A number specifying the width of the line.  The default is 1.  A value
 of 2 is twice as wide as the default, etc.
 @end table
 
@@ -2581,24 +2657,24 @@ of 2 is twice as wide as the default, et
 @cindex graphics marker styles
 @cindex marker styles, graphics
 
 Marker styles are specified by the following properties:
 
 @table @code
 @item marker
 A character indicating a plot marker to be place at each data point, or
-@code{"none"}, meaning no markers should be displayed.
+@qcode{"none"}, meaning no markers should be displayed.
 
 @item markeredgecolor
-The color of the edge around the marker, or @code{"auto"}, meaning that
+The color of the edge around the marker, or @qcode{"auto"}, meaning that
 the edge color is the same as the face color.  @xref{Colors}.
 
 @item markerfacecolor
-The color of the marker, or @code{"none"} to indicate that the marker
+The color of the marker, or @qcode{"none"} to indicate that the marker
 should not be filled.  @xref{Colors}.
 
 @item markersize
 A number specifying the size of the marker.  The default is 1.  A value
 of 2 is twice as large as the default, etc.
 @end table
 
 The @code{colstyle} function will parse a @code{plot}-style specification
@@ -2676,17 +2752,17 @@ functions.
 @DOCSTRING(gcbo)
 
 @DOCSTRING(gcbf)
 
 Callbacks can equally be added to properties with the @code{addlistener}
 function described below.
 
 @node Application-defined Data
-@subsection Application-defined Data 
+@subsection Application-defined Data
 @cindex application-defined data
 
 Octave has a provision for attaching application-defined data to a graphics
 handle.  The data can be anything which is meaningful to the application, and
 will be completely ignored by Octave.
 
 @DOCSTRING(setappdata)
 
@@ -2819,41 +2895,41 @@ member.
 
 In addition the members of the group can also be linked to other
 graphics objects through callback functions.  For example the baseline of
 the @code{bar} or @code{stem} functions is a line object, whose length
 and position are automatically adjusted, based on changes to the
 corresponding hggroup elements.
 
 @menu
-* Data Sources in Object Groups::  
-* Area Series::                 
-* Bar Series::                  
-* Contour Groups::              
-* Error Bar Series::            
-* Line Series::                 
-* Quiver Group::                
-* Scatter Group::               
-* Stair Group::                 
-* Stem Series::                 
-* Surface Group::               
+* Data Sources in Object Groups::
+* Area Series::
+* Bar Series::
+* Contour Groups::
+* Error Bar Series::
+* Line Series::
+* Quiver Group::
+* Scatter Group::
+* Stair Group::
+* Stem Series::
+* Surface Group::
 @end menu
 
 @node Data Sources in Object Groups
 @subsubsection Data Sources in Object Groups
 @cindex data sources in object groups
-@anchor{docXdatasources}
+@anchor{XREFdatasources}
 All of the group objects contain data source parameters.  There are
 string parameters that contain an expression that is evaluated to update
 the relevant data property of the group when the @code{refreshdata}
 function is called.
 
 @DOCSTRING(refreshdata)
 
-@anchor{docXlinkdata}
+@anchor{XREFlinkdata}
 @c add the description of the linkdata function here when it is written
 @c remove the explicit anchor when you add the corresponding @DOCSTRING
 @c command
 
 @node Area Series
 @subsubsection Area Series
 @cindex series objects
 @cindex area series
@@ -2861,89 +2937,89 @@ function is called.
 Area series objects are created by the @code{area} function.  Each of the
 @code{hggroup} elements contains a single patch object.  The properties
 of the area series are
 
 @table @code
 @item basevalue
 The value where the base of the area plot is drawn.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the edge of the patch objects making up the
 areas.  @xref{Line Styles}.
 
-@item edgecolor
+@item  edgecolor
 @itemx facecolor
-The line and fill color of the patch objects making up the areas. 
+The line and fill color of the patch objects making up the areas.
 @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 The x and y coordinates of the original columns of the data passed to
 @code{area} prior to the cumulative summation used in the @code{area}
 function.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 Data source variables.
 @end table
 
 @node Bar Series
 @subsubsection Bar Series
 @cindex series objects
 @cindex bar series
 
 Bar series objects are created by the @code{bar} or @code{barh}
 functions.  Each @code{hggroup} element contains a single patch object.
 The properties of the bar series are
 
 @table @code
-@item showbaseline
+@item  showbaseline
 @itemx baseline
 @itemx basevalue
 The property @code{showbaseline} flags whether the baseline of the bar
-series is displayed (default is "on").  The handle of the graphics object
-representing the baseline is given by the @code{baseline} property and
+series is displayed (default is @qcode{"on"}).  The handle of the graphics
+object representing the baseline is given by the @code{baseline} property and
 the y-value of the baseline by the @code{basevalue} property.
 
 Changes to any of these property are propagated to the other members of
 the bar series and to the baseline itself.  Equally changes in the
 properties of the base line itself are propagated to the members of the
 corresponding bar series.
 
-@item barwidth
+@item  barwidth
 @itemx barlayout
 @itemx horizontal
 The property @code{barwidth} is the width of the bar corresponding to
 the @var{width} variable passed to @code{bar} or @var{barh}.  Whether the
-bar series is "grouped" or "stacked" is determined by the
+bar series is @qcode{"grouped"} or @qcode{"stacked"} is determined by the
 @code{barlayout} property and whether the bars are horizontal or
 vertical by the @code{horizontal} property.
 
 Changes to any of these property are propagated to the other members of
 the bar series.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the edge of the patch objects making up the
 bars.  @xref{Line Styles}.
 
-@item edgecolor
+@item  edgecolor
 @itemx facecolor
 The line and fill color of the patch objects making up the bars.  @xref{Colors}.
 
 @item xdata
 The nominal x positions of the bars.  Changes in this property and
 propagated to the other members of the bar series.
 
 @item ydata
 The y value of the bars in the @code{hggroup}.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 Data source variables.
 @end table
 
 @node Contour Groups
 @subsubsection Contour Groups
 @cindex series objects
 @cindex contour series
@@ -2954,112 +3030,112 @@ by the @code{surfc} and @code{meshc} fun
 group are
 
 @table @code
 @item contourmatrix
 A read only property that contains the data return by @code{contourc} used to
 create the contours of the plot.
 
 @item fill
-A radio property that can have the values "on" or "off" that flags whether the
-contours to plot are to be filled.
-
-@item zlevelmode
+A radio property that can have the values @qcode{"on"} or @qcode{"off"} that
+flags whether the contours to plot are to be filled.
+
+@item  zlevelmode
 @itemx zlevel
-The radio property @code{zlevelmode} can have the values "none", "auto" or
-"manual".  When its value is "none" there is no z component to the plotted
-contours.  When its value is "auto" the z value of the plotted contours is
-at the same value as the contour itself.  If the value is "manual", then the
-z value at which to plot the contour is determined by the @code{zlevel}
-property.
-
-@item levellistmode
+The radio property @code{zlevelmode} can have the values @qcode{"none"},
+@qcode{"auto"}, or @qcode{"manual"}.  When its value is @qcode{"none"} there is
+no z component to the plotted contours.  When its value is @qcode{"auto"} the z
+value of the plotted contours is at the same value as the contour itself.  If
+the value is @qcode{"manual"}, then the z value at which to plot the contour is
+determined by the @code{zlevel} property.
+
+@item  levellistmode
 @itemx levellist
 @itemx levelstepmode
 @itemx levelstep
-If @code{levellistmode} is "manual", then the levels at which to plot the
-contours is determined by @code{levellist}.  If @code{levellistmode} is
-set to "auto", then the distance between contours is determined by
-@code{levelstep}.  If both @code{levellistmode} and @code{levelstepmode}
-are set to "auto", then there are assumed to be 10 equal spaced contours.
-
-@item textlistmode
+If @code{levellistmode} is @qcode{"manual"}, then the levels at which to plot
+the contours is determined by @code{levellist}.  If @code{levellistmode} is set
+to @qcode{"auto"}, then the distance between contours is determined by
+@code{levelstep}.  If both @code{levellistmode} and @code{levelstepmode} are
+set to @qcode{"auto"}, then there are assumed to be 10 equal spaced contours.
+
+@item  textlistmode
 @itemx textlist
 @itemx textstepmode
 @itemx textstep
-If @code{textlistmode} is "manual", then the labeled contours
+If @code{textlistmode} is @qcode{"manual"}, then the labeled contours
 is determined by @code{textlist}.  If @code{textlistmode} is set to
-"auto", then the distance between labeled contours is determined by
+@qcode{"auto"}, then the distance between labeled contours is determined by
 @code{textstep}.  If both @code{textlistmode} and @code{textstepmode}
-are set to "auto", then there are assumed to be 10 equal spaced
+are set to @qcode{"auto"}, then there are assumed to be 10 equal spaced
 labeled contours.
 
 @item showtext
 Flag whether the contour labels are shown or not.
 
 @item labelspacing
 The distance between labels on a single contour in points.
 
 @item linewidth
 
 @item linestyle
 
 @item linecolor
 The properties of the contour lines.  The properties @code{linewidth} and
 @code{linestyle} are similar to the corresponding properties for lines.  The
 property @code{linecolor} is a color property (@pxref{Colors}), that can also
-have the values of "none" or "auto".  If @code{linecolor} is "none", then no
-contour line is drawn.  If @code{linecolor} is "auto" then the line color is
-determined by the colormap.
-
-@item xdata
+have the values of @qcode{"none"} or @qcode{"auto"}.  If @code{linecolor} is
+@qcode{"none"}, then no contour line is drawn.  If @code{linecolor} is
+@qcode{"auto"} then the line color is determined by the colormap.
+
+@item  xdata
 @itemx ydata
 @itemx zdata
 The original x, y, and z data of the contour lines.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 Data source variables.
 @end table
 
 @node Error Bar Series
 @subsubsection Error Bar Series
 @cindex series objects
 @cindex error bar series
 
 Error bar series are created by the @code{errorbar} function.  Each
 @code{hggroup} element contains two line objects representing the data and
 the errorbars separately.  The properties of the error bar series are
 
 @table @code
 @item color
-The RGB color or color name of the line objects of the error bars. 
+The RGB color or color name of the line objects of the error bars.
 @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the line objects of the error bars.  @xref{Line
 Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers on the error bars.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx ldata
 @itemx udata
 @itemx xldata
 @itemx xudata
 The original x, y, l, u, xl, xu data of the error bars.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx ldatasource
 @itemx udatasource
 @itemx xldatasource
 @itemx xudatasource
 Data source variables.
 @end table
 
@@ -3071,32 +3147,32 @@ Data source variables.
 Line series objects are created by the @code{plot}  and @code{plot3}
 functions and are of the type @code{line}.  The properties of the
 line series with the ability to add data sources.
 
 @table @code
 @item color
 The RGB color or color name of the line objects.  @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the line objects.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx zdata
 The original x, y and z data.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 Data source variables.
 @end table
 
 @node Quiver Group
 @subsubsection Quiver Group
 @cindex group objects
@@ -3104,54 +3180,54 @@ Data source variables.
 
 Quiver series objects are created by the @code{quiver} or @code{quiver3}
 functions.  Each @code{hggroup} element of the series contains three line
 objects as children representing the body and head of the arrow,
 together with a marker as the point of origin of the arrows.  The
 properties of the quiver series are
 
 @table @code
-@item autoscale
+@item  autoscale
 @itemx autoscalefactor
 Flag whether the length of the arrows is scaled or defined directly from
 the @var{u}, @var{v} and @var{w} data.  If the arrow length is flagged
 as being scaled by the @code{autoscale} property, then the length of the
 autoscaled arrow is controlled by the @code{autoscalefactor}.
 
 @item maxheadsize
 This property controls the size of the head of the arrows in the quiver
 series.  The default value is 0.2.
 
 @item showarrowhead
 Flag whether the arrow heads are displayed in the quiver plot.
 
 @item color
 The RGB color or color name of the line objects of the quiver.  @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the line objects of the quiver.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the marker objects at the original of the
 arrows.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx zdata
 The origins of the values of the vector field.
 
-@item udata
+@item  udata
 @itemx vdata
 @itemx wdata
 The values of the vector field to plot.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 @itemx udatasource
 @itemx vdatasource
 @itemx wdatasource
 Data source variables.
 @end table
 
@@ -3164,35 +3240,35 @@ Scatter series objects are created by th
 functions.  A single hggroup element contains as many children as there are
 points in the scatter plot, with each child representing one of the points.
 The properties of the stem series are
 
 @table @code
 @item linewidth
 The line width of the line objects of the points.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 The line and fill color of the markers of the points.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx zdata
 The original x, y and z data of the stems.
 
 @item cdata
 The color data for the points of the plot.  Each point can have a separate
 color, or a unique color can be specified.
 
 @item sizedata
 The size data for the points of the plot.  Each point can its own size or a
 unique size can be specified.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 @itemx cdatasource
 @itemx sizedatasource
 Data source variables.
 @end table
 
 @node Stair Group
@@ -3203,79 +3279,79 @@ Data source variables.
 Stair series objects are created by the @code{stair} function.  Each
 @code{hggroup} element of the series contains a single line object as a
 child representing the stair.  The properties of the stair series are
 
 @table @code
 @item color
 The RGB color or color name of the line objects of the stairs.  @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the line objects of the stairs.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers on the stairs.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 The original x and y data of the stairs.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 Data source variables.
 @end table
 
 @node Stem Series
 @subsubsection Stem Series
 @cindex series objects
 @cindex stem series
 
 Stem series objects are created by the @code{stem} or @code{stem3}
 functions.  Each @code{hggroup} element contains a single line object
 as a child representing the stems.  The properties of the stem series
 are
 
 @table @code
-@item showbaseline
+@item  showbaseline
 @itemx baseline
 @itemx basevalue
 The property @code{showbaseline} flags whether the baseline of the
-stem series is displayed (default is "on").  The handle of the graphics
+stem series is displayed (default is @qcode{"on"}).  The handle of the graphics
 object representing the baseline is given by the @code{baseline}
 property and the y-value (or z-value for @code{stem3}) of the baseline
 by the @code{basevalue} property.
 
 Changes to any of these property are propagated to the other members of
 the stem series and to the baseline itself.  Equally changes in the
 properties of the base line itself are propagated to the members of the
 corresponding stem series.
 
 @item color
 The RGB color or color name of the line objects of the stems.  @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the line objects of the stems.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers on the stems.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx zdata
 The original x, y and z data of the stems.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 Data source variables.
 @end table
 
 @node Surface Group
 @subsubsection Surface Group
 @cindex group objects
@@ -3286,36 +3362,36 @@ functions, but are equally one of the ha
 or @code{meshc} functions.  The surface group is of the type @code{surface}.
 
 The properties of the surface group are
 
 @table @code
 @item edgecolor
 
 @item facecolor
-The RGB color or color name of the edges or faces of the surface. 
+The RGB color or color name of the edges or faces of the surface.
 @xref{Colors}.
 
-@item linewidth
+@item  linewidth
 @itemx linestyle
 The line width and style of the lines on the surface.  @xref{Line Styles}.
 
-@item marker
+@item  marker
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers on the surface.  @xref{Colors}.
 
-@item xdata
+@item  xdata
 @itemx ydata
 @itemx zdata
 @itemx cdata
 The original x, y, z and c data.
 
-@item xdatasource
+@item  xdatasource
 @itemx ydatasource
 @itemx zdatasource
 @itemx cdatasource
 Data source variables.
 @end table
 
 @node Graphics Toolkits
 @subsection Graphics Toolkits
@@ -3326,17 +3402,17 @@ Data source variables.
 
 @DOCSTRING(available_graphics_toolkits)
 
 @DOCSTRING(loaded_graphics_toolkits)
 
 @DOCSTRING(register_graphics_toolkit)
 
 @menu
-* Customizing Toolkit Behavior::    
+* Customizing Toolkit Behavior::
 @end menu
 
 @node Customizing Toolkit Behavior
 @subsubsection Customizing Toolkit Behavior
 @cindex toolkit customization
 
 The specific behavior of the backend toolkit may be modified using the
 following utility functions.  Note: Not all functions apply to every
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -21,63 +21,84 @@ function plotimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d", typ];
   endif
 
   if (strcmp(typ , "txt"))
     image_as_txt(nm);
   elseif (strcmp (nm, "plot"))
     x = -10:0.1:10;
     plot (x, sin (x));
-    print (cstrcat (nm, ".", typ), d_typ)    
+    xlabel ("x");
+    ylabel ("sin (x)");
+    title ("Simple 2-D Plot");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "hist"))
     rand ("state", 2);
     hist (randn (10000, 1), 30);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    xlabel ("Value");
+    ylabel ("Count");
+    title ("Histogram of 10,000 normally distributed random numbers");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "errorbar"))
     rand ("state", 2);
     x = 0:0.1:10;
     y = sin (x);
     yl = 0.1 .* rand (size (x));
     yu = 0.1 .* rand (size (x));
     errorbar (x, sin (x), yl, yu);
     axis ([0, 10, -1.1, 1.1]);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    xlabel ("x");
+    ylabel ("sin (x)");
+    title ("Errorbar plot of sin (x)");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "polar"))
     polar (0:0.1:10*pi, 0:0.1:10*pi);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    title ("Example polar plot from 0 to 10*pi");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "mesh"))
     tx = ty = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (tx, ty);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     tz = sin (r) ./ r;
     mesh (tx, ty, tz);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    xlabel ("tx");
+    ylabel ("ty");
+    zlabel ("tz");
+    title ("3-D Sombrero plot");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "plot3"))
     t = 0:0.1:10*pi;
     r = linspace (0, 1, numel (t));
     z = linspace (0, 1, numel (t));
     plot3 (r.*sin(t), r.*cos(t), z);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    xlabel ("r.*sin (t)");
+    ylabel ("r.*cos (t)");
+    zlabel ("z");
+    title ("plot3 display of 3-D helix");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "extended"))
     x = 0:0.01:3;
-    plot(x,erf(x));
+    plot (x,erf(x));
     hold on;
-    plot(x,x,"r");
-    axis([0, 3, 0, 1]);
-    text(0.65, 0.6175, cstrcat('\leftarrow x = {2/\surd\pi {\fontsize{16}',
-      '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175'))
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x,x,"r");
+    axis ([0, 3, 0, 1]);
+    text (0.65, 0.6175, ['\leftarrow x = {2/\surd\pi {\fontsize{16}' ...
+          '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175']);
+    xlabel ("x");
+    ylabel ("erf (x)");
+    title ("erf (x) with text annotation");
+    print ([nm "." typ], d_typ);
   else
     error ("unrecognized plot requested");
   endif
   hide_output ();
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
diff --git a/doc/interpreter/preface.txi b/doc/interpreter/preface.txi
--- a/doc/interpreter/preface.txi
+++ b/doc/interpreter/preface.txi
@@ -58,20 +58,20 @@ easily.
 
 Everyone is encouraged to share this software with others under the
 terms of the GNU General Public License (@pxref{Copying}).  You are 
 also encouraged to help make Octave more useful by writing and 
 contributing additional functions for it, and by reporting any problems
 you may have.
 
 @menu
-* Acknowledgements::            
+* Acknowledgements::
 * Citing Octave in Publications::
-* How You Can Contribute to Octave::  
-* Distribution::                
+* How You Can Contribute to Octave::
+* Distribution::
 @end menu
 
 @node Acknowledgements
 @unnumberedsec Acknowledgements
 @cindex acknowledgements
 @end ifclear
 
 Many people have contributed to Octave's development.  The
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -19,19 +19,19 @@
 @node Numerical Integration
 @chapter Numerical Integration
 
 Octave comes with several built-in functions for computing the integral
 of a function numerically (termed quadrature).  These functions all solve
 1-dimensional integration problems.
 
 @menu
-* Functions of One Variable:: 
-* Orthogonal Collocation::      
-* Functions of Multiple Variables:: 
+* Functions of One Variable::
+* Orthogonal Collocation::
+* Functions of Multiple Variables::
 @end menu
 
 @node Functions of One Variable
 @section Functions of One Variable
 
 Octave supports five different algorithms for computing the integral
 @tex
 $$
@@ -129,19 +129,20 @@ The second step is to call quad with the
      @result{} 1.1522e-07
 @end group
 @end example
 
 Although @code{quad} returns a nonzero value for @var{ier}, the result
 is reasonably accurate (to see why, examine what happens to the result
 if you move the lower bound to 0.1, then 0.01, then 0.001, etc.).
 
-The function "f" can be the string name of a function, a function handle, or
-an inline function.  These options make it quite easy to do integration
-without having to fully define a function in an m-file.  For example:
+The function @qcode{"f"} can be the string name of a function, a function
+handle, or an inline function.  These options make it quite easy to do
+integration without having to fully define a function in an m-file.  For
+example:
 
 @example
 @group
 # Verify integral (x^3) = x^4/4
 f = inline ("x.^3");
 quadgk (f, 0, 1)
      @result{} 0.25000
 
diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -14,84 +14,81 @@
 @c 
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <http://www.gnu.org/licenses/>.
 
 @node Signal Processing
 @chapter Signal Processing
 
-
 This chapter describes the signal processing and fast Fourier
 transform functions available in Octave.  Fast Fourier transforms are
 computed with the @sc{fftw} or @sc{fftpack} libraries depending on how
 Octave is built.
- 
-
-
-@DOCSTRING(detrend)
 
 @DOCSTRING(fft)
 
+@DOCSTRING(ifft)
+
+@DOCSTRING(fft2)
+
+@DOCSTRING(ifft2)
+
+@DOCSTRING(fftn)
+
+@DOCSTRING(ifftn)
+
 Octave uses the @sc{fftw} libraries to perform FFT computations.  When Octave
 starts up and initializes the @sc{fftw} libraries, they read a system wide
 file (on a Unix system, it is typically @file{/etc/fftw/wisdom}) that
 contains information useful to speed up FFT computations.  This
 information is called the @emph{wisdom}.  The system-wide file allows
 wisdom to be shared between all applications using the @sc{fftw} libraries.
 
 Use the @code{fftw} function to generate and save wisdom.  Using the
 utilities provided together with the @sc{fftw} libraries
 (@command{fftw-wisdom} on Unix systems), you can even add wisdom
 generated by Octave to the system-wide wisdom file.
 
 @DOCSTRING(fftw)
 
-@DOCSTRING(ifft)
-
-@DOCSTRING(fft2)
-
-@DOCSTRING(ifft2)
-
-@DOCSTRING(fftn)
-
-@DOCSTRING(ifftn)
-
 @DOCSTRING(fftconv)
 
 @DOCSTRING(fftfilt)
 
 @DOCSTRING(filter)
 
 @DOCSTRING(filter2)
 
 @DOCSTRING(freqz)
 
 @DOCSTRING(freqz_plot)
 
 @DOCSTRING(sinc)
 
 @DOCSTRING(unwrap)
 
-@c FIXME -- someone needs to organize these...
+@c FIXME: someone needs to organize these ...
 
 @DOCSTRING(arch_fit)
 
 @DOCSTRING(arch_rnd)
 
 @DOCSTRING(arch_test)
 
 @DOCSTRING(arma_rnd)
 
 @DOCSTRING(autoreg_matrix)
 
 @DOCSTRING(bartlett)
 
 @DOCSTRING(blackman)
 
+@DOCSTRING(detrend)
+
 @DOCSTRING(diffpara)
 
 @DOCSTRING(durbinlevinson)
 
 @DOCSTRING(fftshift)
 
 @DOCSTRING(ifftshift)
 
@@ -102,31 +99,24 @@ generated by Octave to the system-wide w
 @DOCSTRING(hanning)
 
 @DOCSTRING(hurst)
 
 @DOCSTRING(pchip)
 
 @DOCSTRING(periodogram)
 
-@DOCSTRING(rectangle_lw)
-
-@DOCSTRING(rectangle_sw)
-
 @DOCSTRING(sinetone)
 
 @DOCSTRING(sinewave)
 
 @DOCSTRING(spectral_adf)
 
 @DOCSTRING(spectral_xdf)
 
 @DOCSTRING(spencer)
 
 @DOCSTRING(stft)
 
 @DOCSTRING(synthesis)
 
-@DOCSTRING(triangle_lw)
+@DOCSTRING(yulewalker)
 
-@DOCSTRING(triangle_sw)
-
-@DOCSTRING(yulewalker)
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -18,28 +18,28 @@
 
 @ifhtml
 @set htmltex
 @end ifhtml
 @iftex
 @set htmltex
 @end iftex
 
-@node Sparse Matrices 
+@node Sparse Matrices
 @chapter Sparse Matrices
 
 @menu
 * Basics::                      Creation and Manipulation of Sparse Matrices
 * Sparse Linear Algebra::       Linear Algebra on Sparse Matrices
 * Iterative Techniques::        Iterative Techniques
 * Real Life Example::           Using Sparse Matrices
 @end menu
 
 @node Basics
-@section The Creation and Manipulation of Sparse Matrices
+@section Creation and Manipulation of Sparse Matrices
 
 The size of mathematical problems that can be treated at any particular
 time is generally limited by the available computing resources.  Both,
 the speed of the computer and its available memory place limitation on
 the problem size. 
 
 There are many classes of mathematical problems which give rise to
 matrices, where a large number of the elements are zero.  In this case
@@ -302,22 +302,21 @@ number of memory allocations.
 @DOCSTRING(spalloc)
 
 @DOCSTRING(sparse)
 
 @DOCSTRING(spconvert)
 
 The above problem of memory reallocation can be avoided in
 oct-files.  However, the construction of a sparse matrix from an oct-file
-is more complex than can be discussed here, and
-you are referred to chapter @ref{External Code Interface}, to have
-a full description of the techniques involved.
+is more complex than can be discussed here.  @xref{External Code Interface},
+for a full description of the techniques involved.
 
 @node Information
-@subsection Finding out Information about Sparse Matrices
+@subsection Finding Information about Sparse Matrices
 
 There are a number of functions that allow information concerning
 sparse matrices to be obtained.  The most basic of these is
 @dfn{issparse} that identifies whether a particular Octave object is
 in fact a sparse matrix.
 
 Another very basic function is @dfn{nnz} that returns the number of
 non-zero entries there are in a sparse matrix, while the function
@@ -337,17 +336,17 @@ mean and the variance of each column.
 @DOCSTRING(nonzeros)
 
 @DOCSTRING(nzmax)
 
 @DOCSTRING(spstats)
 
 When solving linear equations involving sparse matrices Octave
 determines the means to solve the equation based on the type of the
-matrix as discussed in @ref{Sparse Linear Algebra}.  Octave probes the
+matrix (@pxref{Sparse Linear Algebra}).  Octave probes the
 matrix type when the div (/) or ldiv (\) operator is first used with
 the matrix and then caches the type.  However the @dfn{matrix_type}
 function can be used to determine the type of the sparse matrix prior
 to use of the div or ldiv operators.  For example,
 
 @example
 @group
 a = tril (sprandn (1024, 1024, 0.02), -1) ...
@@ -438,19 +437,19 @@ symmetric or @code{treeplot (etree (A+A'
 @DOCSTRING(treeplot)
 
 @DOCSTRING(treelayout)
 
 @node Operators and Functions
 @subsection Basic Operators and Functions on Sparse Matrices
 
 @menu
-* Sparse Functions::            
-* Return Types of Operators and Functions::  
-* Mathematical Considerations::  
+* Sparse Functions::
+* Return Types of Operators and Functions::
+* Mathematical Considerations::
 @end menu
 
 @node Sparse Functions
 @subsubsection Sparse Functions
 
 Many Octave functions have been overloaded to work with either sparse or full
 matrices.  There is no difference in calling convention when using an
 overloaded function with a sparse matrix, however, there is also no access to
@@ -500,17 +499,17 @@ rest of this article, the specific spars
 
 In addition all of the standard Octave mapper functions (i.e., basic
 math functions that take a single argument) such as @dfn{abs}, etc.
 can accept sparse matrices.  The reader is referred to the documentation
 supplied with these functions within Octave itself for further
 details.
 
 @node Return Types of Operators and Functions
-@subsubsection The Return Types of Operators and Functions
+@subsubsection Return Types of Operators and Functions
 
 The two basic reasons to use sparse matrices are to reduce the memory 
 usage and to not have to do calculations on zero elements.  The two are
 closely related in that the computation time on a sparse matrix operator
 or function is roughly linear with the number of non-zero elements.
 
 Therefore, there is a certain density of non-zero elements of a matrix 
 where it no longer makes sense to store it as a sparse matrix, but rather
@@ -569,18 +568,18 @@ Note that the @code{sparse_auto_mutate} 
 
 @node Mathematical Considerations
 @subsubsection Mathematical Considerations
 
 The attempt has been made to make sparse matrices behave in exactly the
 same manner as there full counterparts.  However, there are certain differences
 and especially differences with other products sparse implementations.
 
-Firstly, the "./" and ".^" operators must be used with care.  Consider what
-the examples
+Firstly, the @qcode{"./"} and @qcode{".^"} operators must be used with care. 
+Consider what the examples
 
 @example
 @group
   s = speye (4);
   a1 = s .^ 2;
   a2 = s .^ s;
   a3 = s .^ -2;
   a4 = s ./ 2;
@@ -851,17 +850,17 @@ number of eigenvalues and eigenvectors b
 and likewise for @code{svds} which calculates a limited number of
 singular values and vectors.
 
 @DOCSTRING(eigs)
 
 @DOCSTRING(svds)
 
 @node Iterative Techniques
-@section Iterative Techniques applied to sparse matrices
+@section Iterative Techniques Applied to Sparse Matrices
 
 The left division @code{\} and right division @code{/} operators,
 discussed in the previous section, use direct solvers to resolve a
 linear equation of the form @code{@var{x} = @var{A} \ @var{b}} or
 @code{@var{x} = @var{b} / @var{A}}.  Octave equally includes a number of
 functions to solve sparse linear equations using iterative techniques.
 
 @DOCSTRING(pcg)
@@ -872,17 +871,17 @@ The speed with which an iterative solver
 accelerated with the use of a pre-conditioning matrix @var{M}.  In this
 case the linear equation @code{@var{M}^-1 * @var{x} = @var{M}^-1 *
 @var{A} \ @var{b}} is solved instead.  Typical pre-conditioning matrices
 are partial factorizations of the original matrix.
 
 @DOCSTRING(luinc)
 
 @node Real Life Example
-@section Real Life Example of the use of Sparse Matrices
+@section Real Life Example using Sparse Matrices
 
 A common application for sparse matrices is in the solution of Finite
 Element Models.  Finite element models allow numerical solution of
 partial differential equations that do not have closed form solutions,
 typically because of the complex shape of the domain.
 
 In order to motivate this application, we consider the boundary value
 Laplace equation.  This system can model scalar potential fields, such
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -21,17 +21,17 @@ function sparseimages (nm, typ)
   set_print_size ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
 
   if (__have_feature__ ("COLAMD")
       && __have_feature__ ("CHOLMOD")
       && __have_feature__ ("UMFPACK"))
-    if (strcmp(typ,"txt"))
+    if (strcmp (typ,"txt"))
       txtimages (nm, 15, typ);
     else
       if (strcmp (nm, "gplot"))
         gplotimages ("gplot", typ);
       elseif (strcmp (nm, "grid"))
         femimages ("grid", typ);
       else
         otherimages (nm, 200, typ);
@@ -57,212 +57,208 @@ function hide_output ()
   set (f, "visible", "off");
 endfunction
 
 function gplotimages (nm, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
               [1,1,2,2,3,3,4,4,5,5,6,6], 1, 6, 6);
   xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
-  gplot (A, xy)
-  print (cstrcat (nm, ".", typ), d_typ)
+  gplot (A, xy);
+  print ([nm "." typ], d_typ);
   hide_output ();
 endfunction
 
-function txtimages(nm, n, typ)
-  a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
-      sparse(ceil([1:n]/2),1:n,1,n,n);
+function txtimages (nm, n, typ)
+  a = 10*speye (n) + sparse (1:n,ceil([1:n]/2),1,n,n) + ...
+      sparse (ceil ([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "gplot") || strcmp (nm, "grid"))
     fid = fopen (sprintf ("%s.txt", nm), "wt");
     fputs (fid, "\n");
     fputs (fid, "+---------------------------------+\n");
     fputs (fid, "| Image unavailable in text mode. |\n");
     fputs (fid, "+---------------------------------+\n");
     fclose (fid);
   elseif (strcmp (nm, "spmatrix"))
-    printsparse(a,cstrcat("spmatrix.",typ));
+    printsparse (a, ["spmatrix." typ]);
   else
-    if (__have_feature__ ("COLAMD")
-        && __have_feature__ ("CHOLMOD"))
+    if (__have_feature__ ("COLAMD") && __have_feature__ ("CHOLMOD"))
       if (strcmp (nm, "spchol"))
-        r1 = chol(a);
-        printsparse(r1,cstrcat("spchol.",typ));
+        r1 = chol (a);
+        printsparse (r1, ["spchol." typ]);
       elseif (strcmp (nm, "spcholperm"))
-        [r2,p2,q2]=chol(a);
-        printsparse(r2,cstrcat("spcholperm.",typ));
+        [r2,p2,q2] = chol (a);
+        printsparse(r2, ["spcholperm." typ]);
       endif
       ## printf("Text NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
-function otherimages(nm, n, typ)
+function otherimages (nm, n, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
-  a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
-      sparse(ceil([1:n]/2),1:n,1,n,n);
+  a = 10*speye (n) + sparse (1:n,ceil([1:n]/2),1,n,n) + ...
+      sparse (ceil ([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "spmatrix"))
-    spy(a);
-    axis("ij")
-    print(cstrcat("spmatrix.",typ), d_typ)
+    spy (a);
+    axis ("ij");
+    print (["spmatrix." typ], d_typ);
     hide_output ();
   else
-    if (__have_feature__ ("COLAMD")
-        && __have_feature__ ("CHOLMOD"))
+    if (__have_feature__ ("COLAMD") && __have_feature__ ("CHOLMOD"))
       if (strcmp (nm, "spchol"))
-        r1 = chol(a);
-        spy(r1);
-        axis("ij")
-        print(cstrcat("spchol.",typ), d_typ)
+        r1 = chol (a);
+        spy (r1);
+        axis ("ij");
+        print (["spchol." typ], d_typ);
         hide_output ();
       elseif (strcmp (nm, "spcholperm"))
-        [r2,p2,q2]=chol(a);
-        spy(r2);
-        axis("ij")
-        print(cstrcat("spcholperm.",typ), d_typ)
+        [r2,p2,q2] = chol (a);
+        spy (r2);
+        axis ("ij");
+        print (["spcholperm." typ], d_typ);
         hide_output ();
       endif
       ## printf("Image NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
-function printsparse(a, nm)
+function printsparse (a, nm)
   fid = fopen (nm,"wt");
   fputs (fid, "\n");
-  for i = 1:size(a,1)
-    if (rem(i,5) == 0)
+  for i = 1:rows (a)
+    if (rem (i,5) == 0)
       fprintf (fid,"         %2d - ", i);
     else
       fprintf (fid,"            | ");
     endif
-    for j = 1:size(a,2)
+    for j = 1:columns (a)
       if (a(i,j) == 0)
-        fprintf(fid,"  ")
+        fprintf (fid,"  ");
       else
-        fprintf(fid," *")
+        fprintf (fid," *");
       endif
     endfor
-    fprintf(fid,"\n")
+    fprintf (fid,"\n");
   endfor
-  fprintf(fid,"            |-");
-  for j=1:size(a,2)
-    if (rem(j,5)==0)
-      fprintf(fid,"-|");
+  fprintf (fid,"            |-");
+  for j = 1:columns (a)
+    if (rem (j,5) == 0)
+      fprintf (fid,"-|");
     else
-      fprintf(fid,"--");
+      fprintf (fid,"--");
     endif
   endfor
-  fprintf(fid,"\n")
-  fprintf(fid,"              ");
-  for j=1:size(a,2)
-    if (rem(j,5)==0)
-      fprintf(fid,"%2d",j);
+  fprintf (fid,"\n");
+  fprintf (fid,"              ");
+  for j = 1:columns (a)
+    if (rem (j,5) == 0)
+      fprintf (fid,"%2d",j);
     else
-      fprintf(fid,"  ");
+      fprintf (fid,"  ");
     endif
   endfor
-  fclose(fid);
+  fclose (fid);
 endfunction
 
 function femimages (nm, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (__have_feature__ ("COLAMD")
       && __have_feature__ ("CHOLMOD")
       && __have_feature__ ("UMFPACK"))
     ## build a rectangle
-    node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
-    node_x = ones(5,1)*[1,1.05,1.1,1.2,1.3,1.5,1.7,1.8,1.9,1.95,2];
+    node_y = [1;1.2;1.5;1.8;2] * ones (1,11);
+    node_x = ones (5,1) * [1,1.05,1.1,1.2,1.3,1.5,1.7,1.8,1.9,1.95,2];
     nodes = [node_x(:), node_y(:)];
 
-    [h,w] = size(node_x);
+    [h,w] = size (node_x);
     elems = [];
-    for idx = 1:w-1
+    for idx = 1 : w-1
       widx = (idx-1)*h;
       elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]']; 
       elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]']; 
     endfor
 
-    E = size(elems,1);  #No. of elements
-    N = size(nodes,1);  #No. of elements
-    D = size(elems,2);  #dimensions+1
+    E = size (elems,1);  # No. of elements
+    N = size (nodes,1);  # No. of elements
+    D = size (elems,2);  # dimensions+1
 
     ## Plot FEM Geometry
     elemx = elems(:,[1,2,3,1])';
-    xelems = reshape( nodes(elemx, 1), 4, E);
-    yelems = reshape( nodes(elemx, 2), 4, E);
+    xelems = reshape (nodes(elemx, 1), 4, E);
+    yelems = reshape (nodes(elemx, 2), 4, E);
 
     ## Set element conductivity
-    conductivity = [1*ones(1,16),2*ones(1,48),1*ones(1,16)];
+    conductivity = [1*ones(1,16), 2*ones(1,48), 1*ones(1,16)];
 
     ## Dirichlet boundary conditions
     D_nodes = [1:5, 51:55]; 
     D_value = [10*ones(1,5), 20*ones(1,5)]; 
   
     ## Neumann boundary conditions
     ## Note that N_value must be normalized by the boundary
     ##   length and element conductivity
     N_nodes = [];
     N_value = [];
 
     ## Calculate connectivity matrix
-    C = sparse((1:D*E), reshape(elems',D*E,1),1, D*E, N);
+    C = sparse ((1:D*E), reshape (elems',D*E,1),1, D*E, N);
 
     ## Calculate stiffness matrix
-    Siidx = floor([0:D*E-1]'/D)*D*ones(1,D) + ones(D*E,1)*(1:D) ;
-    Sjidx = [1:D*E]'*ones(1,D);
-    Sdata = zeros(D*E,D);
-    dfact = prod(2:(D-1));
+    Siidx = floor ([0:D*E-1]'/D)*D*ones(1,D) + ones(D*E,1)*(1:D);
+    Sjidx = [1:D*E]'*ones (1,D);
+    Sdata = zeros (D*E,D);
+    dfact = prod (2:(D-1));
     for j = 1:E
-      a = inv([ ones(D,1), nodes( elems(j,:), : ) ]);
-      const = conductivity(j)*2/dfact/abs(det(a));
-      Sdata(D*(j-1)+(1:D),:)= const * a(2:D,:)'*a(2:D,:);
+      a = inv ([ ones(D,1), nodes( elems(j,:), : ) ]);
+      const = conductivity(j)*2/dfact/abs (det (a));
+      Sdata(D*(j-1)+(1:D),:) = const * a(2:D,:)'*a(2:D,:);
     endfor
 
     ## Element-wise system matrix
-    SE = sparse(Siidx,Sjidx,Sdata);
+    SE = sparse (Siidx,Sjidx,Sdata);
     ## Global system matrix
     S = C'* SE *C;
 
     ## Set Dirichlet boundary
-    V = zeros(N,1);
+    V = zeros (N,1);
     V(D_nodes) = D_value;
     idx = 1:N;
     idx(D_nodes) = [];
 
     ## Set Neumann boundary
-    Q = zeros(N,1);
+    Q = zeros (N,1);
     Q(N_nodes) = N_value; # FIXME
 
-    V(idx) = S(idx,idx)\( Q(idx) - S(idx,D_nodes)*V(D_nodes) );
+    V(idx) = S(idx,idx) \ ( Q(idx) - S(idx,D_nodes)*V(D_nodes) );
 
-    velems = reshape( V(elemx), 4, E);
-
-    sz = size(xelems,2);
+    velems = reshape (V(elemx), 4, E);
 
     plot3 (xelems, yelems, velems);
     view (10, 10);
-    print(cstrcat(nm,".",typ), d_typ)
+    print ([nm "." typ], d_typ);
     hide_output ();
   endif
 endfunction
 
 ## There is no sparse matrix implementation available because of missing
 ## libraries, plot sombreros instead. Also plot a nice title that we are
 ## sorry about that.
 function sombreroimage (nm, typ)
@@ -276,34 +272,32 @@ function sombreroimage (nm, typ)
     fclose (fid);
     return;
   else ## if (!strcmp (typ, "txt"))
 
     hide_output ();
     if (strcmp (typ, "eps"))
       d_typ = "-depsc2";
     else
-      d_typ = cstrcat ("-d", typ);
+      d_typ = ["-d" typ];
     endif
 
-    x = y = linspace (-8, 8, 41)';
-    [xx, yy] = meshgrid (x, y);
-    r = sqrt (xx .^ 2 + yy .^ 2) + eps;
-    z = sin (r) ./ r;
+    [x, y, z] = sombrero ();
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics are unavailable because Octave was\ncompiled without a sparse matrix implementation.");
     unwind_protect_cleanup
-      print (cstrcat (nm, ".", typ), d_typ);
+      print ([nm "." typ], d_typ);
       hide_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
-function image_as_txt(nm)
+function image_as_txt (nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
   fputs (fid, "\n");
   fputs (fid, "+---------------------------------+\n");
   fputs (fid, "| Image unavailable in text mode. |\n");
   fputs (fid, "+---------------------------------+\n");
   fclose (fid);
 endfunction
+
diff --git a/doc/interpreter/splineimages.m b/doc/interpreter/splineimages.m
--- a/doc/interpreter/splineimages.m
+++ b/doc/interpreter/splineimages.m
@@ -21,38 +21,38 @@ function splineimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (strcmp (typ, "txt"))
     image_as_txt (nm);
   elseif (strcmp (nm, "splinefit1")) ## Breaks and Pieces
     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.2 * randn (size (x));
     ## Uniform breaks
     breaks = linspace (0, 2 * pi, 41); ## 41 breaks, 40 pieces
     pp1 = splinefit (x, y, breaks);
     ## Breaks interpolated from data
     pp2 = splinefit (x, y, 10);  ## 11 breaks, 10 pieces
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
-    plot (x, y, ".", xx, [y1; y2])
-    axis tight
-    ylim ([-2.5 2.5])
-    legend ("data", "41 breaks, 40 pieces", "11 breaks, 10 pieces")
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x, y, ".", xx, [y1; y2]);
+    axis tight;
+    ylim ([-2.5 2.5]);
+    legend ("data", "41 breaks, 40 pieces", "11 breaks, 10 pieces");
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit2")) ## Spline orders
     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.1 * randn (size (x));
     ## Splines
     pp1 = splinefit (x, y, 8, "order", 0);  ## Piecewise constant
     pp2 = splinefit (x, y, 8, "order", 1);  ## Piecewise linear
     pp3 = splinefit (x, y, 8, "order", 2);  ## Piecewise quadratic
@@ -60,38 +60,38 @@ function splineimages (nm, typ)
     pp5 = splinefit (x, y, 8, "order", 4);  ## Etc.
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
     y4 = ppval (pp4, xx);
     y5 = ppval (pp5, xx);
-    plot (x, y, ".", xx, [y1; y2; y3; y4; y5])
-    axis tight
-    ylim ([-2.5 2.5])
-    legend ({"data", "order 0", "order 1", "order 2", "order 3", "order 4"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x, y, ".", xx, [y1; y2; y3; y4; y5]);
+    axis tight;
+    ylim ([-2.5 2.5]);
+    legend ({"data", "order 0", "order 1", "order 2", "order 3", "order 4"});
+    print ([nm, "." typ], d_typ);
   elseif (strcmp (nm, "splinefit3"))
     ## Data (100 points)
     x = 2 * pi * [0, (rand (1, 98)), 1];
     y = sin (x) - cos (2 * x) + 0.2 * randn (size (x));
     ## No constraints
     pp1 = splinefit (x, y, 10, "order", 5);
     ## Periodic boundaries
     pp2 = splinefit (x, y, 10, "order", 5, "periodic", true);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
-    plot (x, y, ".", xx, [y1; y2])
-    axis tight
-    ylim ([-2 3])
-    legend ({"data", "no constraints", "periodic"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x, y, ".", xx, [y1; y2]);
+    axis tight;
+    ylim ([-2 3]);
+    legend ({"data", "no constraints", "periodic"});
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit4"))
     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (2 * x) + 0.1 * randn (size (x));
     ## Breaks
     breaks = linspace (0, 2 * pi, 10);
     ## Clamped endpoints, y = y" = 0
     xc = [0, 0, 2*pi, 2*pi];
@@ -100,42 +100,42 @@ function splineimages (nm, typ)
     pp1 = splinefit (x, y, breaks, "constraints", con);
     ## Hinged periodic endpoints, y = 0
     con = struct ("xc", 0);
     pp2 = splinefit (x, y, breaks, "constraints", con, "periodic", true);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
-    plot (x, y, ".", xx, [y1; y2])
-    axis tight
-    ylim ([-1.5 1.5])
-    legend({"data", "clamped", "hinged periodic"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x, y, ".", xx, [y1; y2]);
+    axis tight;
+    ylim ([-1.5 1.5]);
+    legend({"data", "clamped", "hinged periodic"});
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit5"))
     ## Truncated data
     x = [0,  1,  2,  4,  8, 16, 24, 40, 56, 72, 80] / 80;
     y = [0, 28, 39, 53, 70, 86, 90, 79, 55, 22,  2] / 1000;
     xy = [x; y];
     ## Curve length parameter
     ds = sqrt (diff (x).^2 + diff (y).^2);
     s = [0, cumsum(ds)];
     ## Constraints at s = 0: (x,y) = (0,0), (dx/ds,dy/ds) = (0,1)
     con = struct ("xc", [0 0], "yc", [0 0; 0 1], "cc", eye (2));
     ## Fit a spline with 4 pieces
     pp = splinefit (s, xy, 4, "constraints", con);
     ## Plot
     ss = linspace (0, s(end), 400);
     xyfit = ppval (pp, ss);
-    xyb = ppval(pp, pp.breaks);
-    plot (x, y, ".", xyfit(1,:), xyfit(2,:), "r", xyb(1,:), xyb(2,:), "ro")
-    legend ({"data", "spline", "breaks"})
-    axis tight
-    ylim ([0 0.1])
-    print (cstrcat (nm, ".", typ), d_typ)
+    xyb = ppval (pp, pp.breaks);
+    plot (x, y, ".", xyfit(1,:), xyfit(2,:), "r", xyb(1,:), xyb(2,:), "ro");
+    legend ({"data", "spline", "breaks"});
+    axis tight;
+    ylim ([0 0.1]);
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit6"))
     ## Data
     x = linspace (0, 2*pi, 200);
     y = sin (x) + sin (2 * x) + 0.05 * randn (size (x));
     ## Add outliers
     x = [x, linspace(0,2*pi,60)];
     y = [y, -ones(1,60)];
     ## Fit splines with hinged conditions
@@ -143,22 +143,22 @@ function splineimages (nm, typ)
     pp1 = splinefit (x, y, 8, "constraints", con, "beta", 0.25); ## Robust fitting
     pp2 = splinefit (x, y, 8, "constraints", con, "beta", 0.75); ## Robust fitting
     pp3 = splinefit (x, y, 8, "constraints", con); ## No robust fitting
     ## Plot
     xx = linspace (0, 2*pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
-    plot (x, y, ".", xx, [y1; y2; y3])
-    legend({"data with outliers","robust, beta = 0.25", ...
-            "robust, beta = 0.75", "no robust fitting"})
-    axis tight
-    ylim ([-2 2])
-    print (cstrcat (nm, ".", typ), d_typ)
+    plot (x, y, ".", xx, [y1; y2; y3]);
+    legend ({"data with outliers","robust, beta = 0.25", ...
+             "robust, beta = 0.75", "no robust fitting"});
+    axis tight;
+    ylim ([-2 2]);
+    print ([nm "." typ], d_typ);
   endif
   hide_output ();  
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
@@ -180,13 +180,14 @@ function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
   fputs (fid, "\n");
   fputs (fid, "+---------------------------------+\n");
   fputs (fid, "| Image unavailable in text mode. |\n");
   fputs (fid, "+---------------------------------+\n");
   fclose (fid);
 endfunction
 
+
 %!demo
 %! for s = 1:6
 %!   splineimages (sprintf ("splinefit##d", s), "pdf")
 %! endfor
 
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -37,27 +37,27 @@ a = [ 0.9, 0.7;
 
 @noindent
 contains three observations from a two-dimensional distribution.
 While this is the default data arrangement, most functions support
 different arrangements.
 
 It should be noted that the statistics functions don't test for data
 containing NaN, NA, or Inf.  These values need to be detected and dealt
-with explicitly.  See @ref{docXisnan,,isnan}, @ref{docXisna,,isna}, 
-@ref{docXisinf,,isinf}, @ref{docXisfinite,,isfinite}. 
+with explicitly.  See @ref{XREFisnan,,isnan}, @ref{XREFisna,,isna}, 
+@ref{XREFisinf,,isinf}, @ref{XREFisfinite,,isfinite}. 
 
 @menu
 * Descriptive Statistics::
-* Basic Statistical Functions:: 
-* Statistical Plots:: 
-* Correlation and Regression Analysis::                      
-* Distributions::     
-* Tests::                       
-* Random Number Generation::          
+* Basic Statistical Functions::
+* Statistical Plots::
+* Correlation and Regression Analysis::
+* Distributions::
+* Tests::
+* Random Number Generation::
 @end menu
 
 @node Descriptive Statistics
 @section Descriptive Statistics
 
 One principal goal of descriptive statistics is to represent the essence of a 
 large data set concisely.  Octave provides the mean, median, and mode functions
 which all summarize a data set with just a single number corresponding to 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -41,26 +41,26 @@ but using the more specific keywords is 
 them, Octave is able to provide better diagnostics for mismatched or
 missing end tokens.
 
 The list of statements contained between keywords like @code{if} or
 @code{while} and the corresponding end statement is called the
 @dfn{body} of a control statement.
 
 @menu
-* The if Statement::            
-* The switch Statement::        
-* The while Statement::         
-* The do-until Statement::      
-* The for Statement::           
-* The break Statement::         
-* The continue Statement::      
-* The unwind_protect Statement::  
-* The try Statement::           
-* Continuation Lines::          
+* The if Statement::
+* The switch Statement::
+* The while Statement::
+* The do-until Statement::
+* The for Statement::
+* The break Statement::
+* The continue Statement::
+* The unwind_protect Statement::
+* The try Statement::
+* Continuation Lines::
 @end menu
 
 @node The if Statement
 @section The if Statement
 @cindex @code{if} statement
 @cindex @code{else} statement
 @cindex @code{elseif} statement
 @cindex @code{endif} statement
@@ -254,17 +254,17 @@ making the code easier to read, and henc
 variable @code{X} should change its name, only one line would need
 changing compared to one line per case when @code{if} statements are
 used.
 
 The general form of the @code{switch} statement is
 
 @example
 @group
-switch @var{expression}
+switch (@var{expression})
   case @var{label}
     @var{command_list}
   case @var{label}
     @var{command_list}
   @dots{}
 
   otherwise
     @var{command_list}
@@ -283,17 +283,17 @@ while the @code{otherwise @var{command_l
 If @var{label} is a cell array the corresponding @var{command_list}
 is executed if @emph{any} of the elements of the cell array match
 @var{expression}.  As an example, the following program will print
 @samp{Variable is either 6 or 7}.
 
 @example
 @group
 A = 7;
-switch A
+switch (A)
   case @{ 6, 7 @}
     printf ("variable is either 6 or 7\n");
   otherwise
     printf ("variable is neither 6 nor 7\n");
 endswitch
 @end group
 @end example
 
@@ -323,17 +323,17 @@ switch (X)
   case "a string"
     do_something
   @dots{}
 endswitch
 @end group
 @end example
 
 @menu
-* Notes for the C Programmer::  
+* Notes for the C Programmer::
 @end menu
 
 @node Notes for the C Programmer
 @subsection Notes for the C Programmer
 
 The @code{switch} statement is also available in the widely used C
 programming language.  There are, however, some differences
 between the statement in Octave and C
@@ -596,17 +596,17 @@ dimensional matrix is produced.
 Although it is possible to rewrite all @code{for} loops as @code{while}
 loops, the Octave language has both statements because often a
 @code{for} loop is both less work to type and more natural to think of.
 Counting the number of iterations is very common in loops and it can be
 easier to think of this counting as part of looping rather than as
 something to do inside the loop.
 
 @menu
-* Looping Over Structure Elements::  
+* Looping Over Structure Elements::
 @end menu
 
 @node Looping Over Structure Elements
 @subsection Looping Over Structure Elements
 @cindex structure elements, looping over
 @cindex looping over structure elements
 
 A special form of the @code{for} statement allows you to loop over all
@@ -845,60 +845,65 @@ No warnings or error messages are printe
 executing.  If an error does occur during the execution of @var{body},
 @var{cleanup} can use the function @code{lasterr} to access the text
 of the message that would have been printed.  This is the same
 as @code{eval (@var{try}, @var{catch})} but it is more efficient since
 the commands do not need to be parsed each time the @var{try} and
 @var{catch} statements are evaluated.  @xref{Errors and Warnings}, for more
 information about the @code{lasterr} function.
 
+@node Continuation Lines
+@section Continuation Lines
 @cindex continuation lines
 @cindex @code{...} continuation marker
 @cindex @code{\} continuation marker
 
-@node Continuation Lines
-@section Continuation Lines
-
 In the Octave language, most statements end with a newline character and
 you must tell Octave to ignore the newline character in order to
 continue a statement from one line to the next.  Lines that end with the
-characters @code{...} or @code{\} are joined with the following line
-before they are divided into tokens by Octave's parser.  For example,
-the lines
+characters @code{...} are joined with the following line before they are
+divided into tokens by Octave's parser.  For example, the lines
 
 @example
 @group
 x = long_variable_name ...
-    + longer_variable_name \
+    + longer_variable_name ...
     - 42
 @end group
 @end example
 
 @noindent
-form a single statement.  The backslash character on the second line
-above is interpreted as a continuation character, @emph{not} as a division
-operator.
+form a single statement.
 
-For continuation lines that do not occur inside string constants,
-whitespace and comments may appear between the continuation marker and
-the newline character.  For example, the statement
+Any text between the continuation marker and the newline character is
+ignored.  For example, the statement
 
 @example
 @group
-x = long_variable_name ...     # comment one
-    + longer_variable_name \   # comment two
-    - 42                       # last comment
+x = long_variable_name ...    # comment one
+    + longer_variable_name ...comment two
+    - 42                      # last comment
 @end group
 @end example
 
 @noindent
-is equivalent to the one shown above.  Inside string constants, the
-continuation marker must appear at the end of the line just before the
-newline character.
+is equivalent to the one shown above.
+
+Inside double-quoted string constants, the character @code{\} has to be
+used as continuation marker.  The @code{\} must appear at the end of the
+line just before the newline character:
 
+@example
+@group
+s = "This text starts in the first line \
+and is continued in the second line."
+@end group
+@end example
+
+@noindent
 Input that occurs inside parentheses can be continued to the next line
 without having to use a continuation marker.  For example, it is
 possible to write statements like
 
 @example
 @group
 if (fine_dining_destination == on_a_boat
     || fine_dining_destination == on_a_train)
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -51,21 +51,21 @@ example, the expression
 
 @noindent
 produces the string whose contents are @samp{foobarbaz}.  @xref{Numeric Data
 Types}, for more information about creating matrices.
 
 @menu
 * Escape Sequences in String Constants::
 * Character Arrays::
-* Creating Strings:: 
-* Comparing Strings::           
-* Manipulating Strings::     
-* String Conversions::          
-* Character Class Functions::   
+* Creating Strings::
+* Comparing Strings::
+* Manipulating Strings::
+* String Conversions::
+* Character Class Functions::
 @end menu
 
 @node Escape Sequences in String Constants
 @section Escape Sequences in String Constants
 @cindex escape sequence notation
 In double-quoted strings, the backslash character is used to introduce
 @dfn{escape sequences} that represent other characters.  For example,
 @samp{\n} embeds a newline character in a double-quoted string and
@@ -114,31 +114,27 @@ Represents a newline, control-j, ASCII c
 Represents a carriage return, control-m, ASCII code 13.
 
 @item \t
 Represents a horizontal tab, control-i, ASCII code 9.
 
 @item \v
 Represents a vertical tab, control-k, ASCII code 11.
 
-@c We don't do octal or hex this way yet.
-@c
-@c @item \@var{nnn}
-@c Represents the octal value @var{nnn}, where @var{nnn} are one to three
-@c digits between 0 and 7.  For example, the code for the ASCII ESC
-@c (escape) character is @samp{\033}.@refill
-@c 
-@c @item \x@var{hh}@dots{}
-@c Represents the hexadecimal value @var{hh}, where @var{hh} are hexadecimal
-@c digits (@samp{0} through @samp{9} and either @samp{A} through @samp{F} or
-@c @samp{a} through @samp{f}).  Like the same construct in @sc{ansi} C,
-@c the escape 
-@c sequence continues until the first non-hexadecimal digit is seen.  However,
-@c using more than two hexadecimal digits produces undefined results.  (The
-@c @samp{\x} escape sequence is not allowed in @sc{posix} @code{awk}.)@refill
+@item \@var{nnn}
+Represents the octal value @var{nnn}, where @var{nnn} are one to three
+digits between 0 and 7.  For example, the code for the ASCII ESC
+(escape) character is @samp{\033}.
+
+@item \x@var{hh}@dots{}
+Represents the hexadecimal value @var{hh}, where @var{hh} are hexadecimal
+digits (@samp{0} through @samp{9} and either @samp{A} through @samp{F} or
+@samp{a} through @samp{f}).  Like the same construct in @sc{ansi} C,
+the escape sequence continues until the first non-hexadecimal digit is seen.
+However, using more than two hexadecimal digits produces undefined results.
 @end table
 
 In a single-quoted string there is only one escape sequence: you may insert a
 single quote character using two single quote characters in succession.  For
 example,
 
 @example
 @group
@@ -153,23 +149,23 @@ by using @code{is_dq_string} and @code{i
 @DOCSTRING(is_dq_string)
 
 @DOCSTRING(is_sq_string)
 
 @node Character Arrays
 @section Character Arrays
 
 The string representation used by Octave is an array of characters, so
-internally the string @nospell{"dddddddddd"} is actually a row vector of length
-10 containing the value 100 in all places (100 is the ASCII code of "d").  This
-lends itself to the obvious generalization to character matrices.  Using a
-matrix of characters, it is possible to represent a collection of same-length
-strings in one variable.  The convention used in Octave is that each row in a
-character matrix is a separate string, but letting each column represent a
-string is equally possible.
+internally the string @nospell{@qcode{"dddddddddd"}} is actually a row vector
+of length 10 containing the value 100 in all places (100 is the ASCII code of
+@qcode{"d"}).  This lends itself to the obvious generalization to character
+matrices.  Using a matrix of characters, it is possible to represent a
+collection of same-length strings in one variable.  The convention used in
+Octave is that each row in a character matrix is a separate string, but letting
+each column represent a string is equally possible.
 
 The easiest way to create a character matrix is to put several strings
 together into a matrix.
 
 @example
 collection = [ "String #1"; "String #2" ];
 @end example
 
@@ -217,29 +213,46 @@ The easiest way to create a string is, a
 to enclose a text in double-quotes or single-quotes.  It is however
 possible to create a string without actually writing a text.  The
 function @code{blanks} creates a string of a given length consisting
 only of blank characters (ASCII code 32).
 
 @DOCSTRING(blanks)
 
 @menu
-* Concatenating Strings:: 
-* Conversion of Numerical Data to Strings::
+* Concatenating Strings::
+* Converting Numerical Data to Strings::
 @end menu
 
 @node Concatenating Strings
 @subsection Concatenating Strings
 
-It has been shown above that strings can be concatenated using matrix notation
-(@pxref{Strings}, @ref{Character Arrays}).  Apart from that, there are several
-functions to concatenate string objects: @code{char},
-@code{strvcat}, @code{strcat} and @code{cstrcat}.  In addition, the general
-purpose concatenation functions can be used: see @ref{docXcat,,cat},
-@ref{docXhorzcat,,horzcat} and @ref{docXvertcat,,vertcat}.
+Strings can be concatenated using matrix notation
+(@pxref{Strings}, @ref{Character Arrays}) which is often the most natural
+method.  For example:
+
+@example
+@group
+fullname = [fname ".txt"];
+email = ["<" user "@@" domain ">"];
+@end group
+@end example
+
+@noindent
+In each case it is easy to see what the final string will look like.  This
+method is also the most efficient.  When using matrix concatenation the parser
+immediately begins joining the strings without having to process
+the overhead of a function call and the input validation of the associated
+function.
+
+Nevertheless, there are several other functions for concatenating string
+objects which can be useful in specific circumstances: @code{char},
+@code{strvcat}, @code{strcat}, and @code{cstrcat}.  Finally, the general
+purpose concatenation functions can be used: see @ref{XREFcat,,cat},
+@ref{XREFhorzcat,,horzcat}, and @ref{XREFvertcat,,vertcat}.
 
 @itemize @bullet
 @item All string concatenation functions except @code{cstrcat}
 convert numerical input into character data by taking the corresponding ASCII
 character for each element, as in the following example:
 
 @example
 @group
@@ -270,18 +283,18 @@ strcat ("oc", "tave", " is", " good", " 
 for each empty string in the input.  @code{strvcat}, on the other hand,
 eliminates empty strings.
 
 @example
 @group
 char ("orange", "green", "", "red")
     @result{} orange
        green 
-             
-       red   
+
+       red
 @end group
 
 @group
 strvcat ("orange", "green", "", "red")
     @result{} orange
        green 
        red  
 @end group
@@ -313,17 +326,17 @@ strcat (@{"abc"; "ghi"@}, @{"def"; "jkl"
 
 @item @code{strcat} removes trailing white space in the arguments (except
 within cell arrays), while @code{cstrcat} leaves white space untouched.  Both
 kinds of behavior can be useful as can be seen in the examples:
 
 @example
 @group
 strcat (["dir1";"directory2"], ["/";"/"], ["file1";"file2"])
-     @result{} dir1/file1      
+     @result{} dir1/file1
         directory2/file2
 @end group
 @group
 
 cstrcat (["thirteen apples"; "a banana"], [" 5$";" 1$"])
       @result{} thirteen apples 5$
          a banana        1$
 @end group
@@ -337,26 +350,26 @@ from the internal representation of the 
 @DOCSTRING(char)
 
 @DOCSTRING(strvcat)
 
 @DOCSTRING(strcat)
 
 @DOCSTRING(cstrcat)
 
-@node Conversion of Numerical Data to Strings 
-@subsection Conversion of Numerical Data to Strings
+@node Converting Numerical Data to Strings
+@subsection Converting Numerical Data to Strings
 Apart from the string concatenation functions (@pxref{Concatenating Strings})
 which cast numerical data to the corresponding ASCII characters, there are
 several functions that format numerical data as strings.  @code{mat2str} and
 @code{num2str} convert real or complex matrices, while @code{int2str} converts
 integer matrices.  @code{int2str} takes the real part of complex values and
 round fractional values to integer.  A more flexible way to format numerical
 data as strings is the @code{sprintf} function (@pxref{Formatted Output},
-@ref{docXsprintf}).
+@ref{XREFsprintf,,sprintf}).
 
 @DOCSTRING(mat2str)
 
 @DOCSTRING(num2str)
 
 @DOCSTRING(int2str)
 
 @node Comparing Strings
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -21,27 +21,27 @@
 
 This chapter describes the functions that are available to allow you to
 get information about what is happening outside of Octave, while it is
 still running, and use this information in your program.  For example,
 you can get information about environment variables, the current time,
 and even start other programs from the Octave prompt.
 
 @menu
-* Timing Utilities::            
-* Filesystem Utilities::        
+* Timing Utilities::
+* Filesystem Utilities::
 * File Archiving Utilities::
 * Networking Utilities::
-* Controlling Subprocesses::    
-* Process ID Information::      
-* Environment Variables::       
-* Current Working Directory::   
-* Password Database Functions::  
-* Group Database Functions::    
-* System Information::          
+* Controlling Subprocesses::
+* Process ID Information::
+* Environment Variables::
+* Current Working Directory::
+* Password Database Functions::
+* Group Database Functions::
+* System Information::
 * Hashing Functions::
 @end menu
 
 @node Timing Utilities
 @section Timing Utilities
 
 Octave's core set of functions for manipulating time values are
 patterned after the corresponding functions from the standard C library.
@@ -116,17 +116,17 @@ useful.
 @DOCSTRING(date)
 
 @DOCSTRING(etime)
 
 @DOCSTRING(cputime)
 
 @DOCSTRING(is_leap_year)
 
-@anchor{docXtoc}
+@anchor{XREFtoc}
 @DOCSTRING(tic)
 
 @DOCSTRING(pause)
 
 @DOCSTRING(sleep)
 
 @DOCSTRING(usleep)
 
@@ -172,17 +172,17 @@ status information on files; and for man
 @DOCSTRING(rmdir)
 
 @DOCSTRING(confirm_recursive_rmdir)
 
 @DOCSTRING(mkfifo)
 
 @DOCSTRING(umask)
 
-@anchor{docXlstat}
+@anchor{XREFlstat}
 @DOCSTRING(stat)
 
 @DOCSTRING(S_ISBLK)
 
 @DOCSTRING(S_ISCHR)
 
 @DOCSTRING(S_ISDIR)
 
@@ -486,17 +486,17 @@ The members of the group.
 @end table
 
 In the descriptions of the following functions, this data structure is
 referred to as a @var{grp_struct}.
 
 @DOCSTRING(getgrent)
 
 @DOCSTRING(getgrgid)
-         
+
 @DOCSTRING(getgrnam)
 
 @DOCSTRING(setgrent)
 
 @DOCSTRING(endgrent)
 
 @node System Information
 @section System Information
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -347,17 +347,17 @@ therefore looks like this
 @example
 @group
 -*- texinfo -*-
 @@deftypefn @{Function File@} @{@@var@{ret@} =@} fn (@dots{})
 @@cindex index term
 Help text in Texinfo format.  Code samples should be marked 
 like @@code@{sample of code@} and variables should be marked
 as @@var@{variable@}.
-@@seealso@{fn2@}
+@@seealso@{fn2, fn3@}
 @@end deftypefn
 @end group
 @end example
 
 This help string must be commented in user functions, or in the help
 string of the @w{@code{DEFUN_DLD}} macro for dynamically loadable
 functions.  The important aspects of the documentation string are
 
@@ -380,17 +380,23 @@ filed under different terms.
 @item @@var@{variable@}
 All variables should be marked with this macro.  The markup of variables
 is then changed appropriately for display.
 
 @item @@code@{sample of code@}
 All samples of code should be marked with this macro for the same
 reasons as the @@var macro.
 
-@item @@seealso@{function2@}
+@item  @nospell{@@qcode@{"sample_code"@}}
+@itemx @nospell{@@qcode@{'sample_code'@}}
+All samples of code which are quoted should use this more specialized macro.
+This happens frequently when discussing graphics properties such as "position"
+or options such as "on"/"off".
+
+@item @@seealso@{function2, function3@}
 This is a comma separated list of function names that allows cross
 referencing from one function documentation string to another.
 @end table
 
 Texinfo format has been designed to generate output for online viewing
 with text terminals as well as generating high-quality printed output.
 To these ends, Texinfo has commands which control the diversion of parts
 of the document into a particular output processor.  Three formats are
@@ -462,18 +468,18 @@ which produces
 @code{2 * 2}
 @result{} 4
 @end group
 @end example
 
 The @code{@@group} block prevents the example from being split across a
 page boundary, while the @code{@@result@{@}} macro produces a right
 arrow signifying the result of a command.  If your example is larger than
-20 lines it is better NOT to use grouping so that a reasonable page boundary
-can be calculated.
+20 lines it is better @emph{NOT} to use grouping so that a reasonable page
+boundary can be calculated.
 
 In many cases a function has multiple ways in which it can be called,
 and the @code{@@deftypefnx} macro can be used to give alternatives.  For
 example
 
 @example
 @group
 -*- texinfo -*-
@@ -551,24 +557,25 @@ nchoosek (1:3, 2)
 @@code@{nchoosek@} works only for non-negative, integer arguments.  Use
 @@code@{bincoeff@} for non-integer and negative scalar arguments, or for
 computing many binomial coefficients at once with vector inputs
 for @@var@{n@} or @@var@{k@}.
 
 @@seealso@{bincoeff, perms@}
 @@end deftypefn
 @end example
+
 @noindent
 which demonstrates most of the concepts discussed above.
 @iftex
 This documentation string renders as
-
 @c Note: use the actual output of info below, rather than try and 
 @c reproduce it here to prevent it looking different from how it would
 @c appear with info.
+
 @example
  -- Function File: C = nchoosek (N, K)
  -- Function File: C = nchoosek (SET, K)
      Compute the binomial coefficient or all combinations of a set of
      items.
 
      If N is a scalar then calculate the binomial coefficient of N and
      K which is defined as
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -44,17 +44,17 @@ You should not use them in code you writ
 documented internal variables and built-in symbolic constants.
 
 Case is significant in variable names.  The symbols @code{a} and
 @code{A} are distinct variables.
 
 A variable name is a valid expression by itself.  It represents the
 variable's current value.  Variables are given new values with
 @dfn{assignment operators} and @dfn{increment operators}.
-@xref{Assignment Ops, ,Assignment Expressions}.
+@xref{Assignment Ops,,Assignment Expressions}.
 
 There is one built-in variable with a special meaning.  The @code{ans} variable
 always contains the result of the last computation, where the output wasn't
 assigned to any variable.  The code @code{a = cos (pi)} will assign the value -1
 to the variable @code{a}, but will not change the value of @code{ans}.  However,
 the code @code{cos (pi)} will set the value of @code{ans} to -1.
 
 Variables in Octave do not have fixed types, so it is possible to first
@@ -67,19 +67,19 @@ before they have been given a value.  Do
 
 @DOCSTRING(isvarname)
 
 @DOCSTRING(genvarname)
 
 @DOCSTRING(namelengthmax)
 
 @menu
-* Global Variables::            
-* Persistent Variables::        
-* Status of Variables::         
+* Global Variables::
+* Persistent Variables::
+* Status of Variables::
 @end menu
 
 @node Global Variables
 @section Global Variables
 @cindex global variables
 @cindex @code{global} statement
 @cindex variables, global
 
@@ -173,17 +173,17 @@ the function works with a @emph{copy} of
 
 @DOCSTRING(isglobal)
 
 @node Persistent Variables
 @section Persistent Variables
 @cindex persistent variables
 @cindex @code{persistent} statement
 @cindex variables, persistent
-@anchor{docXpersistent}
+@anchor{XREFpersistent}
 
 A variable that has been declared @dfn{persistent} within a function
 will retain its contents in memory between subsequent calls to the
 same function.  The difference between persistent variables and global
 variables is that persistent variables are local in scope to a
 particular function and are not visible elsewhere.
 
 The following example uses a persistent variable to create a function
@@ -294,18 +294,18 @@ endfor
 
 @noindent
 That is, the persistent variable is only removed from memory when the
 function containing the variable is removed.  Note that if the function
 definition is typed directly into the Octave prompt, the persistent
 variable will be cleared by a simple @code{clear} command as the entire
 function definition will be removed from memory.  If you do not want
 a persistent variable to be removed from memory even if the function is
-cleared, you should use the @code{mlock} function as described in
-@xref{Function Locking}.
+cleared, you should use the @code{mlock} function
+(@pxref{Function Locking}).
 
 @node Status of Variables
 @section Status of Variables
 
 When creating simple one-shot programs it can be very convenient to
 see which variables are available at the prompt.  The function @code{who}
 and its siblings @code{whos} and @code{whos_line_format} will show
 different information about what is in memory, as the following shows.
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -107,17 +107,17 @@ This shows an important general concept 
 instead of looping over an index variable.  @xref{Index Expressions}.
 Also use boolean indexing generously.  If a condition needs to be tested,
 this condition can also be written as a boolean index.  For instance,
 instead of
 
 @example
 @group
 for i = 1:n
-  if a(i) > 5
+  if (a(i) > 5)
     a(i) -= 20
   endif
 endfor
 @end group
 @end example
 
 @noindent
 write
@@ -452,17 +452,17 @@ catch
 end_try_catch
 @end group
 @end example
 
 @noindent
 that may have relied on matrices of different size producing an error.
 Due to how broadcasting changes semantics with older versions of Octave,
 by default Octave warns if a broadcasting operation is performed.  To
-disable this warning, refer to its ID (@pxref{docXwarning_ids}):
+disable this warning, refer to its ID (@pxref{XREFwarning_ids,,warning_ids}):
 
 @example
 warning ("off", "Octave:broadcast");
 @end example
 
 @noindent
 If you want to recover the old behavior and produce an error, turn this
 warning into an error:
@@ -514,31 +514,35 @@ Vectorization is the preferred technique
 code.  Nevertheless, it is not always possible to replace every loop.  In such
 situations it may be worth trying Octave's @strong{experimental} Just-In-Time
 (JIT) compiler.
 
 A JIT compiler works by analyzing the body of a loop, translating the Octave
 statements into another language, compiling the new code segment into an
 executable, and then running the executable and collecting any results.  The
 process is not simple and there is a significant amount of work to perform for
-each step.  It can still make sense, however, if the loop counter is a
-large number.  Because Octave is an interpreted language every time through a
+each step.  It can still make sense, however, if the number of loop iterations
+is large.  Because Octave is an interpreted language every time through a
 loop Octave must parse the statements in the loop body before executing them.
 With a JIT compiler this is done just once when the body is translated to
 another language.
 
 The JIT compiler is a very new feature in Octave and not all valid Octave
 statements can currently be accelerated.  However, if no other technique
 is available it may be worth benchmarking the code with JIT enabled.  The
-function @code{jit_enable} is used to turn compilation on or off.  The function
-@code{debug_jit} is not likely to be of use to anyone not working directly on
-the implementation of the JIT compiler.
+function @code{jit_enable} is used to turn compilation on or off.  The
+function @code{jit_startcnt} sets the threshold for acceleration.  Loops
+with iteration counts above @code{jit_startcnt} will be accelerated.  The
+function @code{debug_jit} is not likely to be of use to anyone not working
+directly on the implementation of the JIT compiler.
 
 @DOCSTRING(jit_enable)
 
+@DOCSTRING(jit_startcnt)
+
 @DOCSTRING(debug_jit)
 
 @node Miscellaneous Techniques
 @section Miscellaneous Techniques
 @cindex execution speed
 @cindex speedups
 @cindex optimization
 
@@ -597,17 +601,17 @@ more memory than needed.  To provide a r
 Octave checks for orphaned lazy slices at certain situations, when a
 value is stored into a "permanent" location, such as a named variable or
 cell or struct element, and possibly economizes them.  For example:
 
 @example
 @group
 a = zeros (1000); # create a 1000x1000 matrix
 b = a(:,10:100);  # lazy slice
-a = []; # the original a array is still allocated
+a = []; # the original "a" array is still allocated
 c@{1@} = b; # b is reallocated at this point
 @end group
 @end example
 
 @item Avoid deep recursion.
 Function calls to m-file functions carry a relatively significant overhead, so
 rewriting a recursion as a loop often helps.  Also, note that the maximum level
 of recursion is limited.
@@ -665,17 +669,17 @@ relatively expensive operations.
 
 If you are using @code{eval} merely as an exception handling mechanism, and not
 because you need to execute some arbitrary text, use the @code{try}
 statement instead.  @xref{The try Statement}.
 
 @item Use @code{ignore_function_time_stamp} when appropriate.
 If you are calling lots of functions, and none of them will need to change
 during your run, set the variable @code{ignore_function_time_stamp} to
-@code{"all"}.  This will stop Octave from checking the time stamp of a function
+@qcode{"all"}.  This will stop Octave from checking the time stamp of a function
 file to see if it has been updated while the program is being run.
 @end itemize
 
 @node Examples
 @section Examples
 
 The following are examples of vectorization questions asked by actual
 users of Octave and their solutions.
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -266,16 +266,18 @@ An overview of the directory layout of O
     elfun            elementary mathematical functions
 
     @ftp             ftp object class
 
     general          utility functions
 
     geometry         geometry algorithms
 
+    gui              User-Interface (UI) functions
+
     help             help subsystem functions
 
     image            image processing
 
     io               input/output functions
 
     linear-algebra   linear algebra stuff
 
@@ -313,25 +315,25 @@ An overview of the directory layout of O
 
     time             time and date functions
 
 
   test          -- tests for the interpreter
 
     test_ .m         fixed tests for the interpreter
 
-    fntests.m        script to run function tests embedded in C++ and .m
-                     files
+    fntests.m        script to run function tests embedded in C++ and
+                     .m files
 
 ----
 John W. Eaton
 jwe@octave.org
 
+Last updated: Fri, 4 Oct 2013 16:58:52 PDT 
 
-Last updated: Wed, 15 May 2013 03:02:45 EDT
 
 
 ################################################################################
 
 Copyright (C) 2009-2012 John W. Eaton
 
 This file is part of Octave.
 
diff --git a/etc/OLD-ChangeLogs/scripts-ChangeLog b/etc/OLD-ChangeLogs/scripts-ChangeLog
--- a/etc/OLD-ChangeLogs/scripts-ChangeLog
+++ b/etc/OLD-ChangeLogs/scripts-ChangeLog
@@ -6292,17 +6292,17 @@ 2009-01-16  Daniel J Sebald  <daniel.seb
 
 	* plot/legend.m: Fix legend order for both horizontal and
 	vertical string cell.
 
 2008-01-15  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/grid.m: Document handle argument.
 
-2009-01-15  Peter L. Sndergaard  <peter@sonderport.dk>
+2009-01-15  Peter L. Sndergaard  <peter@sonderport.dk>
 
 	* general/nargoutchk.m: Doc fix.
 	* general/nargchk.m: Improve compatibility.  New tests.
 
 2008-01-15  Rafael Laboissiere  <rafael@debian.org>
 
 	* gethelp.cc: Include <cstdio>.
 
@@ -6498,17 +6498,17 @@ 2008-12-18  Daniel J Sebald  <daniel.seb
 	* set/unique.m: Only check for options if nargin > 1.
 
 2008-12-15  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/lsqnonneg.m: Preprocess using QR for over-determined
 	systems. Simplify & fix indexing. Use left division for step problem.
 	Fix output args.
 
-2008-12-13  Francesco Potort  <pot@gnu.org>
+2008-12-13  Francesco Potort  <pot@gnu.org>
 
 	* specfun/nchoosek.m: Check for input arguments, signal loss of
 	precision, correctly handle k==0 and k==n cases, add proper tests.
 
 2008-12-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/fsolve.m: Optionally allow pivoted qr factorization.
 
@@ -6587,17 +6587,17 @@ 2008-11-12  David Bateman  <dbateman@fre
 
 	* plot/__quiver__.m: Only autoscale if more than one element to
 	plot. Modify callbacks for change in order of children.
 	* plot/__stem__.m: Modify callbacks for change in order of children.
 
 2008-11-10  John W. Eaton  <jwe@octave.org>
 
 	* polynomial/spline.m: Delete debugging statements.  From
-	Sebastian Schps <sebastian@schoeps.org>.
+	Sebastian Schps <sebastian@schoeps.org>.
 
 2008-11-07  Thorsten Meyer  <thorsten.meyier@gmx.de>
 
 	* mkdoc: do not remove white space before @ within @example
 	environment
 
 2008-11-05  Thorsten Meyer  <thorsten.meyier@gmx.de>
 
diff --git a/examples/@FIRfilter/subsref.m b/examples/@FIRfilter/subsref.m
--- a/examples/@FIRfilter/subsref.m
+++ b/examples/@FIRfilter/subsref.m
@@ -1,10 +1,10 @@
 function out = subsref (f, x)
-  switch x.type
+  switch (x.type)
     case "()"
       n = f.polynomial;
       out = filter (n.poly, 1, x.subs{1});
     case "."
       fld = x.subs;
       if (strcmp (fld, "polynomial"))
         out = f.polynomial;
       else
diff --git a/examples/mysparse.c b/examples/mysparse.c
--- a/examples/mysparse.c
+++ b/examples/mysparse.c
@@ -6,24 +6,24 @@ mexFunction (int nlhs, mxArray *plhs[],
 {
   mwSize m, n, nz;
   mxArray *v;
   mwIndex i;
   double *pr, *pi;
   double *pr2, *pi2;
   mwIndex *ir, *jc;
   mwIndex *ir2, *jc2;
-  
+
   if (nrhs != 1 || ! mxIsSparse (prhs[0]))
     mexErrMsgTxt ("ARG1 must be a sparse matrix");
 
   m = mxGetM (prhs[0]);
   n = mxGetN (prhs[0]);
   nz = mxGetNzmax (prhs[0]);
-  
+
   if (mxIsComplex (prhs[0]))
     {
       mexPrintf ("Matrix is %d-by-%d complex sparse matrix", m, n);
       mexPrintf (" with %d elements\n", nz);
 
       pr = mxGetPr (prhs[0]);
       pi = mxGetPi (prhs[0]);
       ir = mxGetIr (prhs[0]);
@@ -35,17 +35,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       mexPrintf ("last non-zero element (%d, %d) = (%g, %g)\n",
                  ir[nz-1]+ 1, i, pr[nz-1], pi[nz-1]);
 
       v = mxCreateSparse (m, n, nz, mxCOMPLEX);
       pr2 = mxGetPr (v);
       pi2 = mxGetPi (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
-      
+
       for (i = 0; i < nz; i++)
         {
           pr2[i] = 2 * pr[i];
           pi2[i] = 2 * pi[i];
           ir2[i] = ir[i];
         }
       for (i = 0; i < n + 1; i++)
         jc2[i] = jc[i];
@@ -67,17 +67,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       while (jc[i] == jc[i-1] && i != 0) i--;
       mexPrintf ("last non-zero element (%d, %d) = %d\n",
                  ir[nz-1]+ 1, i, pbr[nz-1]);
 
       v = mxCreateSparseLogicalMatrix (m, n, nz);
       pbr2 = mxGetLogicals (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
-      
+
       for (i = 0; i < nz; i++)
         {
           pbr2[i] = pbr[i];
           ir2[i] = ir[i];
         }
       for (i = 0; i < n + 1; i++)
         jc2[i] = jc[i];
 
@@ -97,17 +97,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       while (jc[i] == jc[i-1] && i != 0) i--;
       mexPrintf ("last non-zero element (%d, %d) = %g\n",
                  ir[nz-1]+ 1, i, pr[nz-1]);
 
       v = mxCreateSparse (m, n, nz, mxREAL);
       pr2 = mxGetPr (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
-      
+
       for (i = 0; i < nz; i++)
         {
           pr2[i] = 2 * pr[i];
           ir2[i] = ir[i];
         }
       for (i = 0; i < n + 1; i++)
         jc2[i] = jc[i];
 
diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -15,18 +15,16 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AUTOMAKE_OPTIONS = subdir-objects
-
 MOC_CPPFLAGS =
 
 octlib_LTLIBRARIES = liboctgui.la
 
 TRANSLATIONS = \
   languages/be_BY.ts \
   languages/de_DE.ts \
   languages/en_US.ts \
@@ -104,10 +102,11 @@ ui-%.h: %.ui
 qrc-%.cc: %.qrc
 	$(RCC) -o $@ $<
 
 %.qm: %.ts
 	$(MKDIR_P) languages
 	$(LRELEASE) -qm $@ $<
 
 DISTCLEANFILES = \
+  default-qt-settings \
   $(LOCALES)
 
diff --git a/libgui/languages/be_BY.ts b/libgui/languages/be_BY.ts
--- a/libgui/languages/be_BY.ts
+++ b/libgui/languages/be_BY.ts
@@ -36,16 +36,655 @@
         <source>inherited</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>persistent</source>
         <translation type="unfinished"></translation>
     </message>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.cc" line="+64"/>
+        <source>foreground</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>background</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>selection</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QTerminal</name>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.h" line="+116"/>
+        <source>Copy</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Clear All</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QWinTerminalImpl</name>
+    <message>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
+        <source>copied selection to clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerBatch</name>
+    <message>
+        <location filename="../../../qsci/qscilexerbatch.cpp" line="+179"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Label</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Hide command character</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>External command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Variable</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerCPP</name>
+    <message>
+        <location filename="../../../qsci/qscilexercpp.cpp" line="+352"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc style C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc style C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>IDL UUID</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive IDL UUID</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Pre-processor block</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive pre-processor block</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Unclosed string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive unclosed string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C# verbatim string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C# verbatim string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaScript regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaScript regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc style C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc style C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Secondary keywords and identifiers</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive secondary keywords and identifiers</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc keyword error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc keyword error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Global classes and typedefs</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive global classes and typedefs</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C++ raw string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C++ raw string</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerDiff</name>
+    <message>
+        <location filename="../../../qsci/qscilexerdiff.cpp" line="+107"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Header</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Position</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Removed line</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Added line</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Changed line</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerMatlab</name>
+    <message>
+        <location filename="../../../qsci/qscilexermatlab.cpp" line="+138"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerPerl</name>
+    <message>
+        <location filename="../../../qsci/qscilexerperl.cpp" line="+333"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>POD</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Scalar</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Array</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Hash</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Symbol table</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Substitution</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backticks</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Data section</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Here document delimiter</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backtick here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (q)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qq)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qx)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qr)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qw)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>POD verbatim</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Subroutine prototype</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Format identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Format body</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Translation</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Regular expression (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Substitution (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backticks (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted here document (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backtick here document (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qq, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qx, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qr, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciScintilla</name>
+    <message>
+        <location filename="../../../qsci/qsciscintilla.cpp" line="+4201"/>
+        <source>&amp;Undo</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>&amp;Redo</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+6"/>
+        <source>Cu&amp;t</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+5"/>
+        <source>&amp;Copy</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+6"/>
+        <source>&amp;Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Delete</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+7"/>
+        <source>Select All</source>
+        <translation type="unfinished"></translation>
+    </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
@@ -53,29 +692,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -88,37 +727,37 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation type="unfinished">  &amp;</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation type="unfinished">&amp;</translation>
     </message>
@@ -138,27 +777,27 @@ is already open in the editor</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation type="unfinished">&amp;/ </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation type="unfinished"></translation>
     </message>
@@ -188,57 +827,57 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
+        <location line="+4"/>
+        <source>Close All</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
         <location line="+5"/>
-        <source>Close All</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+4"/>
         <source>Close Other Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation type="unfinished"></translation>
     </message>
@@ -273,32 +912,32 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -314,23 +953,23 @@ Warning: The contents in the editor is m
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -470,32 +1109,32 @@ has been deleted or renamed. Do you want
     <message>
         <location line="+25"/>
         <location line="+11"/>
         <source>Delete file/directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-10"/>
-        <source>Are you sre you want to delete
+        <source>Are you sure you want to delete
 </source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation type="unfinished"></translation>
@@ -580,17 +1219,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation type="unfinished"></translation>
     </message>
@@ -703,22 +1342,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation type="unfinished"></translation>
     </message>
@@ -743,43 +1382,43 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+100"/>
+        <location line="+99"/>
         <source>Searching...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation type="unfinished">     .</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation type="unfinished">       .</translation>
     </message>
@@ -807,119 +1446,124 @@ has been deleted or renamed. Do you want
         <location line="+1"/>
         <source>Create script</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation type="unfinished">  </translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation type="unfinished"> Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation type="unfinished"></translation>
     </message>
@@ -954,17 +1598,37 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"> </translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation type="unfinished"></translation>
     </message>
@@ -984,22 +1648,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1040,63 +1704,49 @@ has been deleted or renamed. Do you want
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation type="unfinished">  </translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation type="unfinished"></translation>
     </message>
-    <message>
-        <location line="+29"/>
-        <source>Unock widget</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
         <source>help</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1152,22 +1802,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Letter icons</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>Graphic  icons</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+39"/>
+        <location line="+46"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1267,22 +1912,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+46"/>
+        <location line="+45"/>
         <source>Font</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-745"/>
+        <location line="-744"/>
         <source>Show line numbers</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1292,17 +1937,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-282"/>
         <source>Show complete path in window title</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+548"/>
+        <location line="-72"/>
+        <source>Graphic icons</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+620"/>
         <source>emacs</source>
         <translation type="unfinished">emacs</translation>
     </message>
     <message>
         <location line="+67"/>
         <source>Terminal</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1312,17 +1962,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+102"/>
+        <location line="+101"/>
         <source>Font size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation type="unfinished"> </translation>
     </message>
@@ -1382,32 +2032,32 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"> :</translation>
     </message>
     <message>
         <location line="-33"/>
         <source>HttpProxy</source>
         <translation type="unfinished">HttpProxy</translation>
     </message>
     <message>
-        <location line="-1108"/>
+        <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+1099"/>
+        <location line="+1098"/>
         <source>Socks5Proxy</source>
         <translation type="unfinished">Socks5Proxy</translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
         <translation type="unfinished"> :</translation>
     </message>
@@ -1429,18 +2079,33 @@ has been deleted or renamed. Do you want
     <message>
         <location filename="../src/settings-dialog.cc" line="+69"/>
         <location line="+4"/>
         <location line="+334"/>
         <source>System setting</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-137"/>
-        <source>Difference to the defalt size</source>
+        <location line="-268"/>
+        <source>IBeam Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Block Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Underline Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+129"/>
+        <source>Difference to the default size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
@@ -1465,71 +2130,61 @@ has been deleted or renamed. Do you want
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/de_DE.ts b/libgui/languages/de_DE.ts
--- a/libgui/languages/de_DE.ts
+++ b/libgui/languages/de_DE.ts
@@ -78,17 +78,17 @@
         <location line="+4"/>
         <source>Clear All</source>
         <translation>Alles lschen</translation>
     </message>
 </context>
 <context>
     <name>QWinTerminalImpl</name>
     <message>
-        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1451"/>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
         <source>copied selection to clipboard</source>
         <translation>Auswahl in die Zwischenablage kopiert</translation>
     </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
@@ -99,29 +99,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation>Siehe Dokumentation fr Hilfe.</translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation>Octave Editor</translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Octave Dateien (*.m);;Alle Dateien (*)</translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation>Kann die Datei &lt;b&gt;%1&lt;/b&gt; nicht zum Lesen ffnen:
 %2.</translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
@@ -137,37 +137,37 @@ ist im Editor bereits geffnet</translation>
         <translation>Der zugehrige Editor-Reiter ist nicht mehr vorhanden und wurde wahrscheinlich geschlossen.</translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation>&amp;%1 %2</translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation>&amp;Neue Datei</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation>Datei &amp;ffnen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation>Datei &amp;speichern</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation>Datei speichern &amp;als</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation>Drucken</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation>&amp;Rckgngig</translation>
     </message>
@@ -187,27 +187,27 @@ ist im Editor bereits geffnet</translation>
         <translation>&amp;Ausschneiden</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation>Einfgen</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation>&amp;Nchstes Lesezeichen</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation>&amp;Voriges Lesezeichen</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation>&amp;Lesezeichen setzen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation>Alle Lesezeichen &amp;entfernen</translation>
     </message>
@@ -237,57 +237,57 @@ ist im Editor bereits geffnet</translation>
         <translation>&amp;Kommentieren</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation>Kommentar &amp;entfernen</translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation>&amp;Zuletzt bearbeitete Dateien</translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation>S&amp;chlieen</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+4"/>
         <source>Close All</source>
         <translation>Alle schlieen</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+5"/>
         <source>Close Other Files</source>
         <translation>Andere Dokumente schlieen</translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation>&amp;Suchen und Ersetzen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
-        <translation>Datei speichern und ausrhren</translation>
+        <translation>Datei speichern und ausfhren</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation>&amp;Gehe zu Zeile</translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation>&amp;Datei</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editieren</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation>&amp;Debuggen</translation>
     </message>
@@ -322,35 +322,35 @@ ist im Editor bereits geffnet</translation>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation>nderungen speichern, verwerfen oder Schlieen abbrechen?</translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation>Octave Editor</translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation>Die Datei
 %1
 soll geschlossen werden, wurde aber verndert.
 %2</translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Octave Dateien (*.m);;All Files (*)</translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -370,24 +370,24 @@ Warning: The contents in the editor is m
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation>Die Datei
 %1
 wurde gelscht oder umbenannt. Soll die Datei jetzt gespeichert werden?%2</translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
-        <translation>Die Datei %1  konnte nicht zum Schrieben geffnet werden:
+        <translation>Die Datei %1  konnte nicht zum Schreiben geffnet werden:
 %2.</translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation>Die Datei %1 wurde von einer anderen Anwendung verndert. Soll der neue Inhalt geladen werden?</translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -432,17 +432,17 @@ wurde gelscht oder umbenannt. Soll die Datei jetzt gespeichert werden?%2</translation>
     <message>
         <location line="+4"/>
         <source>Actions on current directory</source>
         <translation>Aktionen mit aktuellem Verzeichnis</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Show Home directory</source>
-        <translation>Wechlse zum Heimatverzeichnis</translation>
+        <translation>Wechsle zum Heimatverzeichnis</translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Search directory</source>
         <translation>Verzeichnis suchen</translation>
     </message>
     <message>
         <location line="+3"/>
@@ -539,22 +539,22 @@ zu: </translation>
 </translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation>Verzeichnis ist nicht leer und kann daher nicht gelscht werden</translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation>Setze aktuelles Browser Verzeichnis</translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation>Neue Datei</translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation>Neue Datei in</translation>
@@ -639,17 +639,17 @@ zu: </translation>
         <translation>Rck&amp;wrts suchen</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation>In Auswah&amp;l suchen</translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation>Vom Ende suchen</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation>Suche vom Beginn</translation>
     </message>
@@ -684,17 +684,17 @@ zu: </translation>
     <message>
         <location line="+10"/>
         <source>Named:</source>
         <translation>Name:</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Enter the filename expression</source>
-        <translation>EIngabe eines Ausdrucks fr den Dateinamen</translation>
+        <translation>Eingabe eines Ausdrucks fr den Dateinamen</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Start in:</source>
         <translation>Beginne in:</translation>
     </message>
     <message>
         <location line="+4"/>
@@ -724,27 +724,27 @@ zu: </translation>
     <message>
         <location line="+2"/>
         <source>Include directories</source>
         <translation>Verzeichnisse einbeziehen</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Include matching directories in search results</source>
-        <translation>Auch Verzeichnisse bercksichitgen, die die Suchanfrage erfllen</translation>
+        <translation>Auch Verzeichnisse bercksichtigen, die die Suchanfrage erfllen</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Name case insensitive</source>
         <translation>Gro-/Kleinschreibung ignorieren</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set matching name is case insensitive</source>
-        <translation>Gro-/Kleinschriebung bei der Dateisuche ignorieren</translation>
+        <translation>Gro-/Kleinschreibung bei der Dateisuche ignorieren</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Contains text:</source>
         <translation>In Datei vorkommender Text:</translation>
     </message>
     <message>
         <location line="+1"/>
@@ -762,22 +762,22 @@ zu: </translation>
         <translation>Gro-/Kleinschreibung beachten</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation>Gro-/Kleinschreibung beim Text beachten</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation>Suchergebnisse</translation>
     </message>
     <message>
-        <location line="+11"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation>Leerlauf.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation>Suche</translation>
     </message>
@@ -815,30 +815,30 @@ zu: </translation>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation>Suchverzeichnis setzen</translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation>Dateiname</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation>Verzeichnis</translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation>Durchsuchen Sie die Befehlshistorie.</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation>Doppelklick, um den Befehl in das Terminal zu bertragen.</translation>
     </message>
@@ -866,141 +866,146 @@ zu: </translation>
         <location line="+1"/>
         <source>Create script</source>
         <translation>Skript erzeugen</translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation>Lade Arbeitsumgebung</translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation>ber Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation>&amp;Datei</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation>Neu</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation>Skript</translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation>Funktion</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation>Abbildung</translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation>ffnen...</translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation>Einstellungen...</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation>Beenden</translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editieren</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation>Rckgngig</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation>Kopieren</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation>Einfgen</translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation>Arbeitsumgebung speichern als</translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation>Arbeitsverzeichnis setzen</translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation>Zwischenablage leeren</translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation>Suche Dateien...</translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation>Befehlsfenster lschen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation>Befehlshistorie lschen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation>Arbeitsumgebung lschen</translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation>De&amp;bug</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
-        <translation>EInzelschritt</translation>
+        <translation>Einzelschritt</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step in</source>
         <translation>Einzelschritt hinein</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step out</source>
         <translation>Einzelschritt heraus</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Continue</source>
-        <translation>Fortfhren</translation>
+        <translation>Fortfahren</translation>
     </message>
     <message>
         <location line="+8"/>
         <source>Exit Debug Mode</source>
         <translation>Debug Modus verlassen</translation>
     </message>
     <message>
         <location line="+48"/>
@@ -1013,17 +1018,37 @@ zu: </translation>
         <translation>Dateibrowser</translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation>Fensterlayout auf Grundeinstellung zurcksetzen</translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation>Octave Pakete</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation>Code teilen</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation>Bei Octave mitwirken</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation>Ressourcen fr Octave Entwickler</translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation>Auf der Festplatte</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation>Im Internet</translation>
     </message>
@@ -1043,22 +1068,22 @@ zu: </translation>
         <translation>Ein Verzeichnis hher</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation>Verzeichnis suchen</translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation>Arbeitsumgebung laden</translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation>&amp;Fenster</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation>Befehlsfenster anzeigen</translation>
     </message>
@@ -1099,56 +1124,46 @@ zu: </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation>Editor</translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation>Dokumentation</translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation>&amp;Hilfe</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation>Fehler melden</translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation>Agora Webseite</translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation>Octave Forge Webseite</translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
-        <location line="+120"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation>Fenster lsen</translation>
     </message>
     <message>
-        <location line="-111"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation>Fenster verbergen</translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation>Fenster andocken</translation>
     </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
@@ -1161,17 +1176,17 @@ zu: </translation>
     <message>
         <location filename="../src/octave-qt-link.cc" line="+270"/>
         <source>The file %1 does not exist in the load path.  To debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.</source>
         <translation>Die Datei %1 exisitiert nicht im Suchpfad. Um die editierte Funktion zu debuggen, muss entweder in das Verzeichnis %2 gewechselt werden oder dieses Verzeichnis dem Suchpfad hinzugefgt werden.</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>The file %1 is shadowed by a file with the same name in the load path.  To debug the function you are editing, change to the directory %2.</source>
-        <translation>Die Datei %1 wird von einer gleichnamigen Datei im Suchpfad berdeckt. Um die editierte Funktion zu debuggen, in das Verzeichnis %2 gewechselt werden.</translation>
+        <translation>Die Datei %1 wird von einer gleichnamigen Datei im Suchpfad berdeckt. Um die editierte Funktion zu debuggen, muss in das Verzeichnis %2 gewechselt werden.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Change Directory or Add Directory to Load Path</source>
         <translation>Verzeichnis wechseln oder zum Suchpfad hinzufgen</translation>
     </message>
     <message>
         <location line="+2"/>
@@ -1219,17 +1234,17 @@ zu: </translation>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
         <translation>Leerzeichen</translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Do not show white spaces used for indentation</source>
-        <translation>Keine Leezeichen der Einrckung anzeigen</translation>
+        <translation>Keine Leerzeichen der Einrckung anzeigen</translation>
     </message>
     <message>
         <location line="+28"/>
         <source>Color</source>
         <translation>Farbe</translation>
     </message>
     <message>
         <location line="+120"/>
@@ -1274,17 +1289,17 @@ zu: </translation>
     <message>
         <location line="+13"/>
         <source>Case sensitive</source>
         <translation>Gro-/Kleinschreibung beachten</translation>
     </message>
     <message>
         <location line="+13"/>
         <source>Replace word by suggested one</source>
-        <translation>Wort durch Vorschalg ersetzen</translation>
+        <translation>Wort durch Vorschlag ersetzen</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Match words in document</source>
         <translation>Wrter im Dokument bercksichtigen</translation>
     </message>
     <message>
         <location line="+61"/>
@@ -1404,17 +1419,17 @@ zu: </translation>
     <message>
         <location line="+7"/>
         <source>Synchronize octave directory with the file browser</source>
         <translation>Verzeichnisse von Octave und des Dateibrowsers synchronisieren</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Alternating row colors</source>
-        <translation>Alternierende Farben verwenden</translation>
+        <translation>Alternierende Farben fr die Zeilen verwenden</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>Workspace</source>
         <translation>Arbeitsumgebung</translation>
     </message>
     <message>
         <location line="+30"/>
@@ -1501,17 +1516,17 @@ zu: </translation>
     <message>
         <location line="+1"/>
         <source>Underline Cursor</source>
         <translation>Unterstrichener Cursor</translation>
     </message>
     <message>
         <location line="+129"/>
         <source>Difference to the default size</source>
-        <translation>Differenz zur Stnadgre</translation>
+        <translation>Differenz zur Standardgre</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation>Hintergrundfarbe, Pink (255,0,255) fr Standard</translation>
     </message>
     <message>
         <location line="+2"/>
@@ -1535,75 +1550,67 @@ zu: </translation>
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation>Befehlsfenster</translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
-        <translation>Suchbegriff eingeben und mit &apos;Enter&apos; die Scuhe starten</translation>
+        <translation>Suchbegriff eingeben und mit &apos;Enter&apos; die Suche starten</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation>Globale Suche</translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation>Willkommen zu GNU Octave</translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
-        <translation>Es scheint, dass Sie Octave-GUI das erste Mal auf diesem Computer ausfhren, da die Konfigurationsdatei 
-~/.config/octave/qt-settings
-nicht gefunden wurde. Die Default-Konfiguration wird beim Fortfahren an diese Stelle kopiert. Wenn bestehende Einstellungen verwendet werden sollen, muss dieser Dialog geschlossen und  die vorhandene Datei an die oben angegebene Stelle kopiert werden. Eine vorhandene Konfigurationsdatei wird beim nchsten Start automatisch erkannt.
-
-Nach dem Programmstart knnen die Einstellungen im Men &quot;Datei/Einstellungen&quot; angepasst werden.</translation>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation>Die grafische Nutzerschnittstelle von Octave wird offenbar das erste Mal gestartet. Ein Klick auf &apos;Beenden&apos; erstellt eine Standard-Konfigurationsdatei und startet Octave GUI.</translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
+        <translation>Die Konfigurationsdatei wid in __%1__ gespeichert. Wenn diese Datei existiert, erscheint dieser Dialog beim nchsten Start von Octave nicht mehr.</translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
-        <translation>Weiter</translation>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Weitere Informationsquellen zu Octave:&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;Homepage &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; Online-Dokumentation als &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- oder &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-Dokument&lt;/li&gt;
+&lt;li&gt;Dokumentations-Browser von Octave GUI im Hilfe-Men&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation>Zurck</translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation>Willkommen zu Octave!</translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation>Dieses ist die Entwicklungsversion von Octave mit der ersten offiziellen GUI.</translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation>Die GUI von Octave wird offenbar das erste mal auf diesem Computer ausgefhrt. Dieser Assistent erstellt beim Klick auf &apos;Beenden&apos; eine Standarkonfiguration und startet Octve-GUI.  </translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation>Beenden</translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
@@ -1628,17 +1635,17 @@ Nach dem Programmstart knnen die Einstellungen im Men &quot;Datei/Einstellungen&quot; angepasst werden.</translation>
     <message>
         <location line="+1"/>
         <source>Storage Class</source>
         <translation>Speicherklasse</translation>
     </message>
     <message>
         <location line="+107"/>
         <source>Right click to copy, rename, or display</source>
-        <translation>Rechtsklick zum Kopeiren, Umbenennen oder Anzeigen</translation>
+        <translation>Rechtsklick zum Kopieren, Umbenennen oder Anzeigen</translation>
     </message>
 </context>
 <context>
     <name>workspace_view</name>
     <message>
         <location filename="../src/workspace-view.cc" line="+47"/>
         <source>Workspace</source>
         <translation>Arbeitsumgebung</translation>
@@ -1656,22 +1663,22 @@ Nach dem Programmstart knnen die Einstellungen im Men &quot;Datei/Einstellungen&quot; angepasst werden.</translation>
     <message>
         <location line="+3"/>
         <source>Rename</source>
         <translation>Umbenennen</translation>
     </message>
     <message>
         <location line="+8"/>
         <source>Only top-level symbols may be renamed.</source>
-        <translation>Nur Varaiblen auf hchster Ebene knnen umbenannt werden.</translation>
+        <translation>Nur Variablen auf hchster Ebene knnen umbenannt werden.</translation>
     </message>
     <message>
         <location line="+125"/>
         <source>View the variables in the active workspace.&lt;br&gt;</source>
-        <translation>Einsehen der Varaiblen der aktiven Arbeitsumgebung.&lt;br&gt;</translation>
+        <translation>Einsehen der Variablen der aktiven Arbeitsumgebung.&lt;br&gt;</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Colors for the storage class:</source>
         <translation>Farben der Speicherklassen:</translation>
     </message>
 </context>
 </TS>
diff --git a/libgui/languages/en_US.ts b/libgui/languages/en_US.ts
--- a/libgui/languages/en_US.ts
+++ b/libgui/languages/en_US.ts
@@ -36,16 +36,62 @@
         <source>inherited</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>persistent</source>
         <translation type="unfinished"></translation>
     </message>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.cc" line="+64"/>
+        <source>foreground</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>background</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>selection</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QTerminal</name>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.h" line="+116"/>
+        <source>Copy</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Clear All</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QWinTerminalImpl</name>
+    <message>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
+        <source>copied selection to clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
@@ -53,29 +99,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -88,37 +134,37 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation type="unfinished"></translation>
     </message>
@@ -138,27 +184,27 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation type="unfinished"></translation>
     </message>
@@ -188,57 +234,57 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
+        <location line="+4"/>
+        <source>Close All</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
         <location line="+5"/>
-        <source>Close All</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+4"/>
         <source>Close Other Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation type="unfinished"></translation>
     </message>
@@ -273,32 +319,32 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -314,23 +360,23 @@ Warning: The contents in the editor is m
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -470,32 +516,32 @@ has been deleted or renamed. Do you want
     <message>
         <location line="+25"/>
         <location line="+11"/>
         <source>Delete file/directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-10"/>
-        <source>Are you sre you want to delete
+        <source>Are you sure you want to delete
 </source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation type="unfinished"></translation>
@@ -580,17 +626,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation type="unfinished"></translation>
     </message>
@@ -703,22 +749,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation type="unfinished"></translation>
     </message>
@@ -743,43 +789,43 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+100"/>
+        <location line="+99"/>
         <source>Searching...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation type="unfinished"></translation>
     </message>
@@ -807,119 +853,124 @@ has been deleted or renamed. Do you want
         <location line="+1"/>
         <source>Create script</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation type="unfinished"></translation>
     </message>
@@ -954,17 +1005,37 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation type="unfinished"></translation>
     </message>
@@ -984,22 +1055,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1040,63 +1111,49 @@ has been deleted or renamed. Do you want
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation type="unfinished"></translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation type="unfinished"></translation>
     </message>
-    <message>
-        <location line="+29"/>
-        <source>Unock widget</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
         <source>help</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1152,22 +1209,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Letter icons</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>Graphic  icons</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+39"/>
+        <location line="+46"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1267,22 +1319,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+46"/>
+        <location line="+45"/>
         <source>Font</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-745"/>
+        <location line="-744"/>
         <source>Show line numbers</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1292,17 +1344,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-282"/>
         <source>Show complete path in window title</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+548"/>
+        <location line="-72"/>
+        <source>Graphic icons</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+620"/>
         <source>emacs</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+67"/>
         <source>Terminal</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1312,17 +1369,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+102"/>
+        <location line="+101"/>
         <source>Font size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1382,32 +1439,32 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-33"/>
         <source>HttpProxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-1108"/>
+        <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+1099"/>
+        <location line="+1098"/>
         <source>Socks5Proxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1429,18 +1486,33 @@ has been deleted or renamed. Do you want
     <message>
         <location filename="../src/settings-dialog.cc" line="+69"/>
         <location line="+4"/>
         <location line="+334"/>
         <source>System setting</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-137"/>
-        <source>Difference to the defalt size</source>
+        <location line="-268"/>
+        <source>IBeam Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Block Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Underline Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+129"/>
+        <source>Difference to the default size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
@@ -1465,71 +1537,61 @@ has been deleted or renamed. Do you want
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/es_ES.ts b/libgui/languages/es_ES.ts
--- a/libgui/languages/es_ES.ts
+++ b/libgui/languages/es_ES.ts
@@ -36,16 +36,62 @@
         <source>inherited</source>
         <translation>heredado</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>persistent</source>
         <translation>persistente</translation>
     </message>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.cc" line="+64"/>
+        <source>foreground</source>
+        <translation>primer plano</translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>background</source>
+        <translation>plano de fondo</translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>selection</source>
+        <translation>seleccin</translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>cursor</source>
+        <translation>cursor</translation>
+    </message>
+</context>
+<context>
+    <name>QTerminal</name>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.h" line="+116"/>
+        <source>Copy</source>
+        <translation>Copiar</translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Paste</source>
+        <translation>Pegar</translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Clear All</source>
+        <translation>Limpiar todo</translation>
+    </message>
+</context>
+<context>
+    <name>QWinTerminalImpl</name>
+    <message>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
+        <source>copied selection to clipboard</source>
+        <translation>seleccin copiada al portapapeles</translation>
+    </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation>Documentacin</translation>
     </message>
@@ -53,29 +99,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation>Consultar documentacin para obtener ayuda.</translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation>Editor de Octave</translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Archivos de Octave (*.m);;Todos los archivos (*)</translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation>No se ha podido abrir el archivo %1 para su lectura:\n%2.</translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -88,37 +134,37 @@ is already open in the editor</source>
         <translation>La pestaa para la edicin del archivo ha desaparecido.  Es probable que se haya cerrado por algn medio.</translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation>&amp;%1 %2</translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation>Archivo &amp;nuevo</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation>&amp;Abrir archivo</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation>&amp;Guardar archivo</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation>Guardar archivo &amp;como</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation>Imprimir</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation>&amp;Deshacer</translation>
     </message>
@@ -138,27 +184,27 @@ is already open in the editor</source>
         <translation>Cor&amp;tar</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation>Pegar</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation>&amp;Marcador siguiente</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation>Marcador &amp;anterior</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation>&amp;Alternar marcadores</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation>&amp;Eliminar todos los marcadores</translation>
     </message>
@@ -188,57 +234,57 @@ is already open in the editor</source>
         <translation>&amp;Comentar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation>&amp;Eliminar comentario</translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation>Archivos &amp;recientes</translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation>C&amp;errar</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+4"/>
         <source>Close All</source>
         <translation>Cerrar todo</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+5"/>
         <source>Close Other Files</source>
         <translation>Cerrar otros archivos</translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation>&amp;Buscar y reemplazar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation>Guardar archivo y ejecutar</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation>&amp;Ir a lnea</translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation>&amp;Archivo</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editar</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation>&amp;Depurar</translation>
     </message>
@@ -273,32 +319,32 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation>Desea cancelar el cierre, guardar o descartar los cambios?</translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation>Editor de Octave</translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation>El archivo\n%1\n est a punto de ser cerrado pero ha sido modificado.\n%2</translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Archivos de Octave(*.m);;Todos los archivos(*)</translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -314,23 +360,23 @@ Warning: The contents in the editor is m
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation>Al parecer el archivo\n%1\n ha sido eliminado o renombrado.Desea guardarlo ahora?%2</translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation>No se ha podido abrir el archivo %1 para escritura:\n%2.</translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation>Al parecer el archivo \&apos;%1\&apos; ha sido modificado por otra aplicacin. Desea recargarlo?</translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -480,22 +526,22 @@ has been deleted or renamed. Do you want
         <translation>Est seguro que desea eliminar\n</translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation>No se puede eliminar un directorio que no est vacio</translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation>Fijar directorio de explorador de archivos</translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation>Crear archivo</translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation>Crear archivo en</translation>
@@ -580,17 +626,17 @@ has been deleted or renamed. Do you want
         <translation>Buscar hacia &amp;atrs</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation>Buscar se&amp;leccin</translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation>Buscar desde el final</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation>Buscar desde el inicio</translation>
     </message>
@@ -703,22 +749,22 @@ has been deleted or renamed. Do you want
         <translation>Distinguir maysculas/minsculas en texto </translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation>Establecer distincin entre maysculas y minsculas en el texto</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation>Resultados de la bsqueda</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation>Inactivo.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation>Buscar</translation>
     </message>
@@ -743,43 +789,43 @@ has been deleted or renamed. Do you want
         <translation>Nombre de archivo/ubicacin</translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation>Contenido del archivo</translation>
     </message>
     <message>
-        <location line="+100"/>
+        <location line="+99"/>
         <source>Searching...</source>
         <translation>Buscando...</translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation>Fijar directorio de bsqueda</translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation>Nombre de archivo</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation>Directorio</translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation>Explorar y buscar en el historial de comandos.</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation>Haga doble clic para transferir el comando a la terminal.</translation>
     </message>
@@ -808,120 +854,125 @@ has been deleted or renamed. Do you want
         <source>Create script</source>
         <translatorcomment>Ha sido utilizada la traduccin &quot;guin&quot; de script: http://es.wikipedia.org/wiki/Script#Traducci.C3.B3n</translatorcomment>
         <translation>Crear un guin</translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation>Cargar espacio de trabajo</translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation>Acerca de Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation>&amp;Archivo</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation>Nuevo</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translatorcomment>Guin/&quot;Script&quot;</translatorcomment>
         <translation>Guin</translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation>Funcin</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation>Figura</translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation>Abrir...</translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation>Preferencias...</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation>Salir</translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editar</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation>Deshacer</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation>Copiar</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation>Pegar</translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation>Guardar espacio de trabajo como</translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation>Fijar directorio de trabajo</translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation>Limpiar el Portapapeles</translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation>Buscar archivos...</translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation>Limpiar ventana de comandos</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation>Limpiar historial de comandos</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation>Limpiar espacio de trabajo</translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation>&amp;Depurar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation>Siguiente instruccin </translation>
     </message>
@@ -956,17 +1007,37 @@ has been deleted or renamed. Do you want
         <translation>Explorador de archivos</translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation>Reestablecer esquema de ventana predeterminado</translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation>Paquetes de Octave</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation>Compartir cdigo</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation>Contribuir a octave</translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation>Recursos para el desarrollador de Octave</translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation>En disco</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation>En lnea</translation>
     </message>
@@ -986,22 +1057,22 @@ has been deleted or renamed. Do you want
         <translation>Directorio superior</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation>Explorar directorios</translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation>Cargar espacio de trabajo</translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation>&amp;Ventana</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation>Mostrar ventana de comandos</translation>
     </message>
@@ -1042,57 +1113,48 @@ has been deleted or renamed. Do you want
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation>Editor</translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation>Documentacin</translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation>&amp;Ayuda</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation>Informar de fallo</translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation>Visitar Agora</translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation>Visitar Octave Forge</translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translatorcomment>Uso &quot;widget&quot; por ser el trmino usual: http://es.wikipedia.org/wiki/Widget</translatorcomment>
         <translation>Desacoplar widget</translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translatorcomment>Uso &quot;widget&quot; por ser el trmino usual: http://es.wikipedia.org/wiki/Widget</translatorcomment>
         <translation>Ocultar widget</translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translatorcomment>Uso &quot;widget&quot; por ser el trmino usual: http://es.wikipedia.org/wiki/Widget</translatorcomment>
         <translation>Acoplar widget</translation>
     </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
@@ -1269,22 +1331,22 @@ has been deleted or renamed. Do you want
         <translation>Utilizar color de primer plano </translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation>Colores de la terminal</translation>
     </message>
     <message>
-        <location line="+46"/>
+        <location line="+45"/>
         <source>Font</source>
         <translation>Tipo de fuente</translation>
     </message>
     <message>
-        <location line="-745"/>
+        <location line="-744"/>
         <source>Show line numbers</source>
         <translation>Mostrar numeros de lnea</translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
         <translation>Resaltar lnea actual</translation>
     </message>
@@ -1314,17 +1376,17 @@ has been deleted or renamed. Do you want
         <translation>Tipo de cursor: </translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
         <translation>Cursor parpadeante</translation>
     </message>
     <message>
-        <location line="+102"/>
+        <location line="+101"/>
         <source>Font size</source>
         <translation>Tamao de fuente</translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation>Explorador de archivos</translation>
     </message>
@@ -1384,32 +1446,32 @@ has been deleted or renamed. Do you want
         <translation>Tipo de proxy:</translation>
     </message>
     <message>
         <location line="-33"/>
         <source>HttpProxy</source>
         <translation>HttpProxy</translation>
     </message>
     <message>
-        <location line="-1108"/>
+        <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation>conos para widget acoplados</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
         <translation>Lenguaje (reinicio requerido)</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation>Tamao de cono</translation>
     </message>
     <message>
-        <location line="+1099"/>
+        <location line="+1098"/>
         <source>Socks5Proxy</source>
         <translation>&quot;Socks5Proxy&quot;</translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
         <translation>Nombre del host:</translation>
     </message>
@@ -1431,17 +1493,32 @@ has been deleted or renamed. Do you want
     <message>
         <location filename="../src/settings-dialog.cc" line="+69"/>
         <location line="+4"/>
         <location line="+334"/>
         <source>System setting</source>
         <translation>Configuracin del sistema</translation>
     </message>
     <message>
-        <location line="-137"/>
+        <location line="-268"/>
+        <source>IBeam Cursor</source>
+        <translation>cursor IBeam</translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Block Cursor</source>
+        <translation>cursor de bloque</translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Underline Cursor</source>
+        <translation>cursor subrayado</translation>
+    </message>
+    <message>
+        <location line="+129"/>
         <source>Difference to the default size</source>
         <translation>Diferencia con el tamao predeterminado</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation>Color de fondo, rosa (255,0,255) significa predeterminado</translation>
     </message>
@@ -1467,76 +1544,67 @@ has been deleted or renamed. Do you want
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation>Ventana de comandos</translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation>Escriba aqu y pulse la tecla de &apos;Retorno&apos; para buscar</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation>Bsqueda global</translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation>Bienvenido a GNU Octave</translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
-        <translation> Al parecer ha iniciado Octave GUI por primera vez en su 
-  computadora/ordenador, ya que no se ha encontrado un archivo 
-  de configuracin en &apos;~/.octave-gui&apos;. Este asistente lo guiar con los ajustes esenciales que 
-  debe hacer antes de empezar a usar Octave GUI. Si desea transferir su configuracin hecha con anterioridad 
-  solamente cierre este dilogo y copie el archivo de configuracin en su carpeta de inicio. La presencia de dicho archivo de configuracin ser detectada automticamente y evitar esta ventana de asistencia.  
-  IMPORTANTE: Este asistente no es completamente funcional an. Simplemente haga clic de inicio a fin y el asistente crear un archivo de configuracin estndar. </translation>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation>Al parecer usted utiiza la interfase grfica de Octave por primera vez en este ordenador.  Presione &apos;Finalizar&apos; para generar un archivo de configuracin e iniciar Octave GUI.</translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
+        <translation>La configuracin ha sido guardada en __%1__. Si ese archivo existe, usted no ver este dilogo cuando Octave inicie de nuevo.</translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
-        <translation>Siguiente</translation>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Para mayor informacin acerca de Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visite &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; para obtener la documentacin en linea como &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- o &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;como documento &lt;/span&gt;&lt;/a&gt;-pdf, o&lt;/li&gt;
+&lt;li&gt;abrir el navegador de documentacin de Octave GUI con el men de ayuda.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation>Anterior</translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation>Bienvenido a Octave!</translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation>Esta es la versin en desarrollo de Octave con su primer GUI oficial.</translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation>Parece que ejecuta Octave GUI por primera vez en esta computadora/ordenador. Este asistente le ayudar a configurar la instalacin del programa. Presione &quot;Terminar&quot; para escribir un archivo de configuracin e iniciar Octave GUI. </translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation>Terminar</translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/fr_FR.ts b/libgui/languages/fr_FR.ts
--- a/libgui/languages/fr_FR.ts
+++ b/libgui/languages/fr_FR.ts
@@ -78,19 +78,19 @@
         <location line="+4"/>
         <source>Clear All</source>
         <translation>Tout Effacer</translation>
     </message>
 </context>
 <context>
     <name>QWinTerminalImpl</name>
     <message>
-        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1451"/>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
         <source>copied selection to clipboard</source>
-        <translation>slection copie vers le clipboard</translation>
+        <translation>slection copie vers le presse-papier</translation>
     </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation>Documentation</translation>
@@ -99,132 +99,132 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation>Regardez la documentation pour plus d&apos;aide.</translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
-        <translation>Editeur d&apos;Octave</translation>
+        <translation>diteur d&apos;Octave</translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
-        <translation>Fichiers d&apos;Octave (*.);;Tous les fichiers (*)</translation>
+        <translation>Fichiers d&apos;Octave (*.m);;Tous les fichiers (*)</translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation>Impossible d&apos;ouvrir le fichier %1 pour lecture :
 %2.</translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
 is already open in the editor</source>
-        <translation>Fichier non-enregistr! Un fichier avec le nom slectionn
+        <translation>Fichier non-enregistr! Un fichier ayant le nom slectionn
 %1
-est dj ouvert dans l&apos;editeur</translation>
+est dj ouvert dans l&apos;diteur</translation>
     </message>
     <message>
         <location line="+28"/>
         <source>The associated file editor tab has disappeared.  It was likely closed by some means.</source>
-        <translation>L&apos;onglet editeur de fichier associ a disparu. Il a probablement t ferm par un moyen quelconque.</translation>
+        <translation>L&apos;onglet diteur de fichier associ a disparu. Il a probablement t ferm par un moyen quelconque.</translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation>&amp;%1 %2</translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation>&amp;Nouveau</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
-        <translation>&amp;Ouvrir...</translation>
+        <translation>&amp;Ouvrir</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation>&amp;Enregistrer</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation>Enregistrer &amp;sous</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
-        <translation>&amp;Imprimer</translation>
+        <translation>Imprimer</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation>&amp;Annuler</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Redo</source>
-        <translation>&amp;Refaire</translation>
+        <translation>&amp;Rtablir</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Copy</source>
         <translation>&amp;Copier</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Cu&amp;t</source>
         <translation>Co&amp;uper</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
-        <translation>C&amp;oller</translation>
+        <translation>Coller</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation>Marque page &amp;suivant</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
-        <translation>Marque page &amp;precedent</translation>
+        <translation>Marque page &amp;prcdent</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation>Basculer &amp;marque page</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation>&amp;Supprimer tout marque page</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>&amp;Next breakpoint</source>
         <translation>Point d&apos;arrt &amp;suivant</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Pre&amp;vious breakpoint</source>
-        <translation>Point d&apos;arrt &amp;precendent</translation>
+        <translation>Point d&apos;arrt &amp;prcdent</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Toggle &amp;breakpoint</source>
         <translation>&amp;Basculer point d&apos;arrt</translation>
     </message>
     <message>
         <location line="+3"/>
@@ -237,64 +237,64 @@ est dj ouvert dans l&apos;editeur</translation>
         <translation>&amp;Commenter</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation>&amp;Dcommenter</translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
-        <translation>Fichiers &amp;recents</translation>
+        <translation>Fichiers &amp;rcents</translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation>&amp;Fermer</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+4"/>
         <source>Close All</source>
         <translation>Tout fermer</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+5"/>
         <source>Close Other Files</source>
         <translation>Fermer les autres fichiers</translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation>&amp;Rechercher et remplacer</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation>Enregistrer et excuter</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation>&amp;Aller  la ligne</translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation>&amp;Fichier</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editer</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
-        <translation>&amp;Deboguer</translation>
+        <translation>&amp;Dboguer</translation>
     </message>
     <message>
         <location line="+9"/>
         <source>&amp;Run</source>
         <translation>&amp;Excuter</translation>
     </message>
 </context>
 <context>
@@ -322,35 +322,35 @@ est dj ouvert dans l&apos;editeur</translation>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation>Voulez-vous annuler la fermeture, enregistrer ou supprimer les modifications ?</translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
-        <translation>Editeur d&apos;Octave</translation>
+        <translation>diteur d&apos;Octave</translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation>Le fichier
 %1
-est en cours de fermeture, mais il  t modifi.
+est en cours de fermeture mais il a t modifi.
 %2</translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Fichiers d&apos;Octave (*.m);;Tous les fichiers (*)</translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -360,36 +360,36 @@ est le mme que le nom du fichier courant</translation>
     </message>
     <message>
         <location line="+81"/>
         <source>
 
 Warning: The contents in the editor is modified!</source>
         <translation>
 
-Avertissement: Le contenu dans l&apos;editeur est modifi!</translation>
+Avertissement: Le contenu dans l&apos;diteur est modifi!</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation>Il semblerait que le fichier
 %1
 a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
-        <translation>Impossible d&apos;ouvrir le fichier %1 pour ecrire :
+        <translation>Impossible d&apos;ouvrir le fichier %1 pour crire :
 %2.</translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation>Il semblerait que &apos;%1&apos; a t modifi par une autre application. Voulez-vous le rcharger ?</translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -542,22 +542,22 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
 </translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation>Impossible de supprimer un rpertoire qui n&apos;est pas vide</translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation>Dfinir le rpertoire de l&apos;explorateur de fichiers</translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation>Crer un fichier</translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation>Crer un fichier dans
@@ -586,17 +586,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+3"/>
         <source>Re&amp;place with:</source>
         <translation>Rem&amp;placer par :</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Match &amp;case</source>
-        <translation>Respecter &amp;les majuscules/minuscules</translation>
+        <translation>Respecter &amp;la casse</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search from &amp;start</source>
         <translation>Rechercher depuis &amp;le dbut</translation>
     </message>
     <message>
         <location line="+1"/>
@@ -606,17 +606,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+2"/>
         <source>&amp;Find Next</source>
         <translation>Rechercher le &amp;suivant</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Find &amp;Previous</source>
-        <translation>Rechercher le &amp;precedant</translation>
+        <translation>Rechercher le &amp;prcdent</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>&amp;Replace</source>
         <translation>&amp;Remplacer</translation>
     </message>
     <message>
         <location line="+1"/>
@@ -631,57 +631,57 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+13"/>
         <source>&amp;Whole words</source>
         <translation>&amp;Mots entiers</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Regular E&amp;xpressions</source>
-        <translation>E&amp;xpressions regulires</translation>
+        <translation>E&amp;xpressions rgulires</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search &amp;backward</source>
         <translation>Recherche vers l&apos;&amp;arrire</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation>Recherche dans la s&amp;lection</translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation>Rechercher depuis la fin</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation>Rechercher depuis le dbut</translation>
     </message>
     <message>
         <location line="+117"/>
         <source>Replace Result</source>
         <translation>Rsultats du remplacement</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>%1 items replaced</source>
-        <translation>%1 instances remplacs</translation>
+        <translation>%1 instances remplaces</translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Find Result</source>
         <translation>Rsultats de la recherche</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>No more matches found</source>
-        <translation>Aucune correspondance trouve</translation>
+        <translation>Plus aucune correspondance trouve</translation>
     </message>
 </context>
 <context>
     <name>find_files_dialog</name>
     <message>
         <location filename="../src/find-files-dialog.cc" line="+47"/>
         <source>Find Files</source>
         <translation>Rechercher des fichiers</translation>
@@ -714,17 +714,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+1"/>
         <source>Browse for start directory</source>
         <translation>Choisir le rpertoire de dmarrage</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Recurse directories</source>
-        <translation>Parcourir recursivement les sous-rpertoires</translation>
+        <translation>Parcourir rcursivement les sous-rpertoires</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search recursively through directories for matching files</source>
         <translation>Rechercher les fichiers recursivement dans les sous-rpertoires</translation>
     </message>
     <message>
         <location line="+2"/>
@@ -734,82 +734,82 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+2"/>
         <source>Include matching directories in search results</source>
         <translation>Inclure les rpertoires concordants dans des rsultats de la recherche</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Name case insensitive</source>
-        <translation>Nom insensible aux majuscules/minuscules</translation>
+        <translation>Nom insensible  la casse</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set matching name is case insensitive</source>
-        <translation>Les noms concordant sont insensible aux majuscules/minuscules</translation>
+        <translation>Les noms concordant sont insensible  la casse</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Contains text:</source>
         <translation>Contenant le texte :</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search must match text</source>
         <translation>La recherche doit contenir le texte</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Text to match</source>
-        <translation>Texte concordant</translation>
+        <translation>Texte  rechercher</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Text case insensitive</source>
-        <translation>Texte insensible aux majuscules/minuscules</translation>
+        <translation>Texte insensible  la casse</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
-        <translation>Le texte concordant est insensible aux majuscules/minuscules</translation>
+        <translation>Le texte recherch est insensible  la casse</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation>Rsultats de la recherche</translation>
     </message>
     <message>
-        <location line="+11"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation>Inoccup.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation>Rechercher</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Start search for matching files</source>
-        <translation>Dmarrer la recherche pour les fichiers concordants</translation>
+        <translation>Dmarrer la recherche des fichiers concordants</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Stop</source>
         <translation>Arrter</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Stop searching</source>
-        <translation>Arreter la recherche</translation>
+        <translation>Arrter la recherche</translation>
     </message>
     <message>
         <location line="+15"/>
         <source>File name/location</source>
-        <translation>Nom de fichier/chemin</translation>
+        <translation>Nom/Chemin de fichier</translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation>Contenu du fichier</translation>
     </message>
     <message>
         <location line="+99"/>
@@ -820,32 +820,32 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation>Dfinir le rpertoire de recherche</translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
-        <translation>Fichier</translation>
+        <translation>Nom du fichier</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation>Rpertoire</translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
-        <translation>Naviguer et rechercher le historique des commandes.</translation>
+        <translation>Naviguer et rechercher l&apos;historique des commandes.</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation>Double cliquez sur une commande pour la transfrer vers le terminal.</translation>
     </message>
     <message>
         <location line="+6"/>
@@ -871,136 +871,141 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
         <location line="+1"/>
         <source>Create script</source>
         <translation>Crer un fichier de script</translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation>Charger l&apos;espace de travail</translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation> propos d&apos;Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation>&amp;Fichier</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation>Nouveau</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation>Fichier de script</translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation>Fonction</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation>Figure</translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation>Ouvrir...</translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation>Prfrences...</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation>Quitter</translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editer</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
-        <translation>Defaire</translation>
+        <translation>Annuler</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation>Copier</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation>Coller</translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation>Enregistrer l&apos;espace de travail sous</translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation>Dfinir le rpertoire de travail</translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation>Rechercher des fichiers...</translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation>Nettoyer la fentre de commande</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation>Nettoyer l&apos;historique des commandes</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation>Nettoyer l&apos;espace de travail</translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
-        <translation>De&amp;boguer</translation>
+        <translation>D&amp;boguer</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation>Avancer d&apos;un pas</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step in</source>
         <translation>Avancer d&apos;un pas avec entre</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step out</source>
-        <translation>Executer jusqu&apos; l&apos;instruction de retour</translation>
+        <translation>Excuter jusqu&apos; l&apos;instruction de retour</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Continue</source>
         <translation>Continuer</translation>
     </message>
     <message>
         <location line="+8"/>
@@ -1018,17 +1023,37 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
         <translation>Explorateur de fichiers</translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation>Rtablir la disposition par dfaut des fentres</translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation>Install localement</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation>En ligne</translation>
     </message>
@@ -1045,25 +1070,25 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+4"/>
         <source>One directory up</source>
         <translation>Monter au rpertoire parent</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
-        <translation>Naviguer les rpertoires</translation>
+        <translation>Naviguer dans les rpertoires</translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation>Charger l&apos;espace de travail</translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation>&amp;Fentre</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation>Afficher la fentre de commande</translation>
     </message>
@@ -1075,17 +1100,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+6"/>
         <source>Show Workspace</source>
         <translation>Afficher l&apos;espace de travail</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Show Editor</source>
-        <translation>Afficher l&apos;editeur</translation>
+        <translation>Afficher l&apos;diteur</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Show Documentation</source>
         <translation>Afficher la documentation</translation>
     </message>
     <message>
         <location line="+5"/>
@@ -1100,59 +1125,50 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+6"/>
         <source>Workspace</source>
         <translation>Espace de travail</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
-        <translation>Editeur</translation>
+        <translation>diteur</translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation>Documentation</translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation>&amp;Aide</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
-        <translation>Signaler un bug</translation>
-    </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation>Visiter Agora</translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation>Visiter Octave Forge</translation>
+        <translation>Signaler un bogue</translation>
     </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation>Dtacher le widget</translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation>Cacher le widget</translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation>Attacher le widget</translation>
     </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
@@ -1160,22 +1176,22 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
         <translation>aide</translation>
     </message>
 </context>
 <context>
     <name>octave_qt_link</name>
     <message>
         <location filename="../src/octave-qt-link.cc" line="+270"/>
         <source>The file %1 does not exist in the load path.  To debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.</source>
-        <translation>Le fichier %1 n&apos;existe pas dans les chemins accessibles.  Pour dboguer la fonction que vous ditez, vous devez soit modifier le rpertoire pour %2 ou ajouter le rpertoire au chemin.</translation>
+        <translation>Le fichier %1 n&apos;existe pas dans les chemins accessibles. Pour dboguer la fonction que vous ditez, vous devez soit modifier le rpertoire pour %2 ou ajouter le rpertoire aux chemins accessibles.</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>The file %1 is shadowed by a file with the same name in the load path.  To debug the function you are editing, change to the directory %2.</source>
-        <translation>Le fichier %1 est occult par un fichier avec le mme nom dans le chemin.  Pour dboguer la fonction que vous ditez, vous devez modifier le rpertoire pour %2.</translation>
+        <translation>Le fichier %1 est occult par un fichier du mme nom dans les chemins accessibles. Pour dboguer la fonction que vous ditez, vous devez modifier le rpertoire pour %2.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Change Directory or Add Directory to Load Path</source>
         <translation>Changer de rpertoire ou ajouter le rpertoire aux chemins accessibles</translation>
     </message>
     <message>
         <location line="+2"/>
@@ -1218,27 +1234,27 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+7"/>
         <source>Graphic icons</source>
         <translation>Icones graphiques</translation>
     </message>
     <message>
         <location line="+39"/>
         <source>Editor</source>
-        <translation>Editeur</translation>
+        <translation>diteur</translation>
     </message>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
-        <translation>Montrer les espaces blancs</translation>
+        <translation>Montrer les espaces</translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Do not show white spaces used for indentation</source>
-        <translation>Ne pas montrer les espaces blancs utiliss pour l&apos;indentation</translation>
+        <translation>Ne pas montrer les espaces utiliss pour l&apos;indentation</translation>
     </message>
     <message>
         <location line="+28"/>
         <source>Color</source>
         <translation>Couleur</translation>
     </message>
     <message>
         <location line="+120"/>
@@ -1278,77 +1294,77 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+71"/>
         <source>Match keywords</source>
         <translation>Inclure les mots cls</translation>
     </message>
     <message>
         <location line="+13"/>
         <source>Case sensitive</source>
-        <translation>Sensible au maj/minuscules</translation>
+        <translation>Sensible  la casse</translation>
     </message>
     <message>
         <location line="+13"/>
         <source>Replace word by suggested one</source>
         <translation>Remplacer le mot par la suggestion</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Match words in document</source>
-        <translation>Checher dans le document</translation>
+        <translation>Inclure les mots du document</translation>
     </message>
     <message>
         <location line="+61"/>
         <source>Restore editor tabs from previous session on startup</source>
-        <translation>Restaurer les onglets de la session precedente</translation>
+        <translation>Restaurer les onglets de la session prcdente</translation>
     </message>
     <message>
         <location line="+47"/>
         <source>Use custom file editor</source>
-        <translation>Utiliser un editeur externe</translation>
+        <translation>Utiliser un diteur externe</translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Command  line (%f=file, %l=line):</source>
         <translation>Ligne de commande (%f=fichier, %l=ligne) :</translation>
     </message>
     <message>
         <location line="+22"/>
         <source>Editor Styles</source>
         <translation>Affichage</translation>
     </message>
     <message>
         <location line="+24"/>
         <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Select font, font size (as difference to the default size), font decoration (bold, italic, underline), textcolor and background color (for the latter, the color pink (255,0,255) is a placeholder for the default background color)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
-        <translation>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Choisir le font, la taille (difference  la taille par dfaut), le style (gras, italique, sous-lign), la couleur du texte et la couleur du fond (dans ce cas, la couleur rose [255,0,255] design la couleur de fond par dfaut)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+        <translation>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Choisir la police, la taille (diffrence avec  la taille par dfaut), le style (gras, italique, soulign), la couleur du texte et du fond (pour ce dernier, la couleur rose [255,0,255] designe la couleur par dfaut)&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
     </message>
     <message>
         <location line="+76"/>
         <source>Use Foreground Color</source>
         <translation>Utiliser la couleur du texte</translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation>Couleurs de la fenetre de commandes</translation>
     </message>
     <message>
         <location line="+45"/>
         <source>Font</source>
-        <translation>Font</translation>
+        <translation>Police</translation>
     </message>
     <message>
         <location line="-744"/>
         <source>Show line numbers</source>
         <translation>Afficher les numros des lignes</translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
-        <translation>Sous-ligner la ligne courante</translation>
+        <translation>Surligner la ligne courante</translation>
     </message>
     <message>
         <location line="+262"/>
         <source>Code completion</source>
         <translation>Suggestions de saisie</translation>
     </message>
     <message>
         <location line="-282"/>
@@ -1363,27 +1379,27 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+67"/>
         <source>Terminal</source>
         <translation>Terminal</translation>
     </message>
     <message>
         <location line="+15"/>
         <source>Cursor type:</source>
-        <translation>Type de courseur :</translation>
+        <translation>Type de curseur :</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
-        <translation>Courseur clignotant</translation>
+        <translation>Curseur clignotant</translation>
     </message>
     <message>
         <location line="+101"/>
         <source>Font size</source>
-        <translation>Taille du font</translation>
+        <translation>Taille de police</translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation>Explorateur de fichiers</translation>
     </message>
     <message>
         <location line="+6"/>
@@ -1428,17 +1444,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+35"/>
         <source>Network</source>
         <translation>Rseau</translation>
     </message>
     <message>
         <location line="+45"/>
         <source>Use proxy server</source>
-        <translation>Serveur proxy</translation>
+        <translation>Utiliser un serveur proxy</translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Proxy Type:</source>
         <translation>Type de proxy :</translation>
     </message>
     <message>
         <location line="-33"/>
@@ -1448,32 +1464,32 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation>Jeu d&apos;icones pour les widgets</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
-        <translation>Langue (necessite un redemarrage)</translation>
+        <translation>Langue (ncessite un redmarrage)</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation>Taille des icones</translation>
     </message>
     <message>
         <location line="+1098"/>
         <source>Socks5Proxy</source>
-        <translation>Proxy Sock 5</translation>
+        <translation>Proxy Socks5</translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
-        <translation>Nom du hote :</translation>
+        <translation>Nom de l&apos;hote :</translation>
     </message>
     <message>
         <location line="+54"/>
         <source>Port:</source>
         <translation>Port :</translation>
     </message>
     <message>
         <location line="-27"/>
@@ -1505,17 +1521,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+1"/>
         <source>Underline Cursor</source>
         <translation>Curseur Tiret Bas</translation>
     </message>
     <message>
         <location line="+129"/>
         <source>Difference to the default size</source>
-        <translation>Difference avecla taille par dfaut</translation>
+        <translation>Diffrence avec la taille par dfaut</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation>Couleur de fond, rose [255,0,255] designe la valeur par dfaut</translation>
     </message>
     <message>
         <location line="+2"/>
@@ -1533,77 +1549,67 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
         <translation></translation>
     </message>
 </context>
 <context>
     <name>terminal_dock_widget</name>
     <message>
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
-        <translation>Fenetre de commandes</translation>
+        <translation>Fentre de commandes</translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
-        <translation>Entrez le texte ici et appuyez &apos;Entre&apos; pour lancer la recherche</translation>
+        <translation>Entrez le texte ici et appuyez sur &apos;Entre&apos; pour lancer la recherche</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation>Recherche globale</translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
-        <translation>Bienvenu dans Octave</translation>
+        <translation>Bienvenu dans GNU Octave</translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
-        <translation>Il semble que vous avez lanc Octave GUI pour la premiere fois sur cet ordinateur, puisque aucun fichier de configuration n&apos;a t trouv au &apos;~/.octave-gui&apos;. Cet assistant va vous guider  travers les reglages necessaires avant de pouvoir utiliser Octave GUI. Si vous voulez transferer des reglages que vous avez dj fait, fermez ce dialogue et copiez le fichier de configuration dans votre repertoire personnel. La presence de ce fichier va etre detect et cet assistant ne s&apos;affichera plus. IMPORTANT : Cet assistant n&apos;est pas encore completement fonctionnel. Passez les pages jusqu&apos; la fin et il va crer un fichier de configuration standard.</translation>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
-        <translation>Suivant</translation>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation>Precedent</translation>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation>Bienvenu dans Octave!</translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation>Ceci est la version de developpement de Octave avec le premier GUI officiel.</translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation>Il semble que vous executez Octave GUI pour la premiere fois sur cet ordinateur. Cet assistant va vous aider a configurer ce logiciel. Appuyez sur &apos;Fin&apos; pour crer le fichier de configuration et lancer Octave GUI.</translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation>Fin</translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
@@ -1628,17 +1634,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+1"/>
         <source>Storage Class</source>
         <translation>Type de stockage</translation>
     </message>
     <message>
         <location line="+107"/>
         <source>Right click to copy, rename, or display</source>
-        <translation>Clique droit pour copier, renommer ou afficher</translation>
+        <translation>Cliquez droit pour copier, renommer ou afficher</translation>
     </message>
 </context>
 <context>
     <name>workspace_view</name>
     <message>
         <location filename="../src/workspace-view.cc" line="+47"/>
         <source>Workspace</source>
         <translation>Espace de travail</translation>
@@ -1656,17 +1662,17 @@ a t supprim ou rnomm. Voulez-vous l&apos;enregistrer maintenant ?%2</translation>
     <message>
         <location line="+3"/>
         <source>Rename</source>
         <translation>Renommer</translation>
     </message>
     <message>
         <location line="+8"/>
         <source>Only top-level symbols may be renamed.</source>
-        <translation>Seuls les variables de plus haut niveau peuvent etre renomms.</translation>
+        <translation>Seules les variables de plus haut niveau peuvent tre renommes.</translation>
     </message>
     <message>
         <location line="+125"/>
         <source>View the variables in the active workspace.&lt;br&gt;</source>
         <translation>Voir les variables dans l&apos;espace de travail.&lt;br&gt;</translation>
     </message>
     <message>
         <location line="+1"/>
diff --git a/libgui/languages/nl_NL.ts b/libgui/languages/nl_NL.ts
--- a/libgui/languages/nl_NL.ts
+++ b/libgui/languages/nl_NL.ts
@@ -78,17 +78,17 @@
         <location line="+4"/>
         <source>Clear All</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>QWinTerminalImpl</name>
     <message>
-        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1451"/>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
         <source>copied selection to clipboard</source>
         <translation type="unfinished">selectie naar klembord gekopieerd</translation>
     </message>
 </context>
 <context>
     <name>QsciLexerBatch</name>
     <message>
         <location filename="../../../qsci/qscilexerbatch.cpp" line="+179"/>
@@ -241,17 +241,17 @@
     <message>
         <location line="+3"/>
         <source>Inactive operator</source>
         <translation type="unfinished">Inactieve operator</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Identifier</source>
-        <translation type="unfinished"></translation>
+        <translation type="unfinished">Identifier</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Inactive identifier</source>
         <translation type="unfinished">Inactieve identifier</translation>
     </message>
     <message>
         <location line="+3"/>
@@ -692,29 +692,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation type="unfinished">Kijk in de documentatie voor hulp.</translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation></translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished">Octave bestanden (*.m);;Alle bestanden (*)</translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation>Bestand %1 kon niet geopend worden om te lezen:
 %2.</translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
@@ -730,37 +730,37 @@ is reeds geopend in de editor</translati
         <translation>Het bijbehorende tabblad in de editor is verdwenen. Het is waarschijnlijk op een of andere manier gesloten.</translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation></translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation>&amp;Nieuw Bestand</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation>&amp;Openen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation>Op&amp;slaan</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation>Opslaan &amp;als</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation type="unfinished">Afdrukken</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation>Ongedaan maken</translation>
     </message>
@@ -780,27 +780,27 @@ is reeds geopend in de editor</translati
         <translation>Knippen</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation>Plakken</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation>Volge&amp;nde bladwijzer</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation>&amp;Vorige bladwijzer</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation>&amp;Bladwijzer invoegen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation>Alle bladwijzers ve&amp;rwijderen</translation>
     </message>
@@ -830,57 +830,57 @@ is reeds geopend in de editor</translati
         <translation type="unfinished">Zet om naar commentaar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation type="unfinished">Zet om naar code</translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation type="unfinished">Recent geopend</translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation type="unfinished">Sluit bestand</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+4"/>
         <source>Close All</source>
         <translation type="unfinished">Alle bestanden sluiten</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+5"/>
         <source>Close Other Files</source>
         <translation type="unfinished">Andere bestanden sluiten</translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation>Zoek en Vervang</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation>Bestand opslaan en uitvoeren</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation type="unfinished">Ga naar regel</translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation>Bestand</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation>B&amp;ewerken</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation>&amp;Debuggen</translation>
     </message>
@@ -915,34 +915,34 @@ is reeds geopend in de editor</translati
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation type="unfinished">Wil je niet meer afsluiten, het gewijzigde, of het originele bestand opslaan?</translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation></translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation type="unfinished">Het bestand
 %1
 dat gesloten moet worden is gewijzigd.</translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished">Octave bestanden (*.m);;Alle bestanden (*)</translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -963,24 +963,24 @@ Opgelet: Het bestand in de editor is gew
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation type="unfinished">Het lijkt er op dat bestand
 %1
 is gewist of hernoemd. Wil je het nu opslaan?</translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation>Kon bestand %1 niet openen om te schrijven:
 %2.</translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation>Het lijkt erop dat &apos;%1&apos; is gewijzigd door een ander programma. Wil je het opnieuw laden?</translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -1132,22 +1132,22 @@ is gewist of hernoemd. Wil je het nu ops
         </translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation type="unfinished">Kan geen niet-lege map wissen</translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation type="unfinished">Stel file browser map in</translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation type="unfinished">Maak nieuw bestand</translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation type="unfinished">Maak nieuw bestand in
@@ -1234,17 +1234,17 @@ is gewist of hernoemd. Wil je het nu ops
         <translation>Terug zoeken</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation>In se&amp;lectie zoeken</translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation type="unfinished">vanaf einde terug zoeken</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation type="unfinished">Zoeken vanaf begin</translation>
     </message>
@@ -1357,22 +1357,22 @@ is gewist of hernoemd. Wil je het nu ops
         <translation type="unfinished">Niet-hoofdlettergevoelige tekst</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation type="unfinished">Tekst instellen op niet-hoofdlettergevoelig</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation type="unfinished">Zoekresultaten</translation>
     </message>
     <message>
-        <location line="+11"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation type="unfinished">Niet bezig.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation type="unfinished">Zoek</translation>
     </message>
@@ -1410,30 +1410,30 @@ is gewist of hernoemd. Wil je het nu ops
         <location line="+32"/>
         <source>Set search directory</source>
         <translation type="unfinished">Stel zoekmap in</translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation type="unfinished">Bestandsnaam</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation type="unfinished">Map</translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation type="unfinished">Bladeren en zoeken door de opdrachtgeschiedenis.</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation>Dubbelklik op een opdracht om het naar de terminal te sturen.</translation>
     </message>
@@ -1461,119 +1461,124 @@ is gewist of hernoemd. Wil je het nu ops
         <location line="+1"/>
         <source>Create script</source>
         <translation type="unfinished">Nieuw script</translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation>Werkruimte laden</translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation>Over Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation>Bestand</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation>Nieuw</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation>Script</translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation>Functie</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation>Figuur</translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation>Open...</translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation>Voorkeuren...</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation>Afsluiten</translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation>B&amp;ewerken</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation>Ongedaan maken</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation>Kopiren</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation>Plakken</translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation type="unfinished">Bewaar werkruimte als ...</translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation type="unfinished">Stel werkmap in</translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation>Zoek bestanden...</translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation>Veeg opdrachtvenster schoon</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation>Wis opdrachtgeschiedenis</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation>Wis werkruimte</translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation>De&amp;buggen</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation>Volgende opdracht</translation>
     </message>
@@ -1608,17 +1613,37 @@ is gewist of hernoemd. Wil je het nu ops
         <translation type="unfinished">Bestandsbrowser</translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation type="unfinished">Stel oorspronkelijke window layout opnieuw in</translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation type="unfinished">Op schijf</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation type="unfinished">Online</translation>
     </message>
@@ -1638,22 +1663,22 @@ is gewist of hernoemd. Wil je het nu ops
         <translation type="unfinished">En mapniveau omhoog</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation type="unfinished">Blader door mappen</translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation>Werkruimte laden</translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation>Venster</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation>Opdrachtvenster weergeven</translation>
     </message>
@@ -1694,55 +1719,46 @@ is gewist of hernoemd. Wil je het nu ops
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation>Editor</translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation>Documentatie</translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation>Hulp</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation>Probleem rapporteren</translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation>Bezoek Agora</translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation>Bezoek Octave Forge</translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation type="unfinished">Widget laten zweven</translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation type="unfinished">Widget verbergen</translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation type="unfinished">Widget in venster opnemen</translation>
     </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
@@ -2129,71 +2145,61 @@ is gewist of hernoemd. Wil je het nu ops
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation>Opdrachtvenster</translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation>Typ hier en druk op &apos;Enter&apos; om te zoeken</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation>Globaal zoeken</translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation>Welkom bij GNU Octave</translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
-        <translation>Het lijkt erop dat je de Octave GUI voor de eerste keer opstart op deze computer omdat er geen configuratiebestand in &apos;~/.octave-gui&apos; is gevonden. Deze wizard zal je begeleiden tijdens het instellen van de belangrijkste zaken voordat je de Octave GUI kan gebruiken. Wil je eerder gemaakte instellingen overzetten, sluit dan dit dialoogvenster en kopieer het configuratiebestand naar je home map. De aanwezigheid van het bestand zal automatisch gedetecteerd worden en deze wizard doen overslaan. BELANGRIJK: Deze wizard is nog niet volledig functioneel. Klik door tot het einde voor standaardinstellingen.</translation>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
-        <translation>Volgende</translation>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation>Vorige</translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation>Welkom bij Octave!</translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation>Dit is de ontwikkelvariant van Octave met de eerste officile GUI.</translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation>Het lijkt erop dat je de Octave GUI voor de eerste keer uitvoert op deze computer. Deze assistent zal je helpen het programma te configureren. Klik &apos;Voltooien&apos; om een configuratiebestand te maken en de Octave GUI te starten.</translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation>Voltooien</translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/pt_BR.ts b/libgui/languages/pt_BR.ts
--- a/libgui/languages/pt_BR.ts
+++ b/libgui/languages/pt_BR.ts
@@ -78,17 +78,17 @@
         <location line="+4"/>
         <source>Clear All</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>QWinTerminalImpl</name>
     <message>
-        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1451"/>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
         <source>copied selection to clipboard</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
@@ -99,29 +99,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation>Veja a documentao para ajuda.</translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation>Editor Octave</translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Scripts Octave (*.m);;Todos Arquivos (*)</translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation>No foi possvel abrir arquivo %1 para leitura: %2.</translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -134,37 +134,37 @@ is already open in the editor</source>
         <translation>A aba do editor associada ao arquivo desapareceu. Foi provavelmente fechada de alguma maneira.</translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation>&amp;%1 %2</translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation>&amp;Novo Arquivo</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation>&amp;Abrir Arquivo</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation>&amp;Salvar Arquivo</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation>Salvar Arquivo &amp;Como</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation>Imprimir</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation>&amp;Desfazer</translation>
     </message>
@@ -184,27 +184,27 @@ is already open in the editor</source>
         <translation>Recor&amp;tar</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation>Co&amp;lar</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation>&amp;Prximo Marcador</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation>Marcardor &amp;Anterior</translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation>Visualizar &amp;Marcador</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation>&amp;Remover Todos Marcadores</translation>
     </message>
@@ -234,57 +234,57 @@ is already open in the editor</source>
         <translation>&amp;Comentar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation>&amp;Descomentar</translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation>Arquivos &amp;recentes</translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation>&amp;Fechar</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+4"/>
         <source>Close All</source>
         <translation>Fechar &amp;Todos</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+5"/>
         <source>Close Other Files</source>
         <translation>Fechar Outros Arquivos</translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation>Procurar e Substituir</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation>Salvar e Executar</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation>V para Linha</translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation>&amp;Arquivo</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation>&amp;Editar</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation>&amp;Depurar</translation>
     </message>
@@ -319,35 +319,35 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation>Voc deseja salvar, descartar as alteraes ou cancelar fechamento?</translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation>Editor Octave</translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation>O arquivo
 %1
 est prestes a ser fechado com modificaes.
 %2</translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation>Scripts Octave (*.m);; Todos Arquivos (*)</translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -369,24 +369,24 @@ Aviso: Os arquivos no editor foram modif
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation>Parece que o arquivo
 %1
 foi removido ou renomeado. Pretende salv-lo agora?%2</translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation>No foi possvel abrir arquivo %1 para escrita:
 %2.</translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation>Parece que o arquivo &apos;%1&apos; foi modificado por outra aplicao. Deseja recarreg-lo?</translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -537,22 +537,22 @@ para:</translation>
         <translation>Voc tem certeza que deseja remover</translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation>No  possvel remover um diretrio que no est vzio</translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation>Alterar diretrio do navegador de arquivos</translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation>Criar Arquivo</translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation>Criar arquivo em</translation>
@@ -637,17 +637,17 @@ para:</translation>
         <translation>Procure para trs</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation>Seleo de busca</translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation>Procurar do final</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation>Procurar do comeo</translation>
     </message>
@@ -760,22 +760,22 @@ para:</translation>
         <translation>Texto insensvel a caixa alta/baixa</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation>Altere se contedo do texto  insensvel a caixa alta/baixa</translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation>Resultados de Busca</translation>
     </message>
     <message>
-        <location line="+11"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation>Ocupado.</translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation>Procurar</translation>
     </message>
@@ -813,30 +813,30 @@ para:</translation>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation>Alterar diretrio de busca</translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation>Nome do Arquivo</translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation>Diretrio</translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation>Pesquise no histrico de comandos.</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation>Clique duas vezes num comando para transfer-lo ao terminal.</translation>
     </message>
@@ -864,119 +864,124 @@ para:</translation>
         <location line="+1"/>
         <source>Create script</source>
         <translation>Criar script</translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation>Carregar ambiente de trabalho</translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation>Sobre o Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation>Arquivo</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation>Novo</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation>Script</translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation>Funo</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation>Figura</translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation>Abrir...</translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation>Preferncias...</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation>Sair</translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation>Editar</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation>Desfazer</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation>Copiar</translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation>Colar</translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation>Salvar Ambiente de Trabalho como</translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation>Alterar diretrio de trabalho</translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation>Encontrar Arquivos...</translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation>Limpar Janela de Comandos</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation>Limpar Histrico de Comandos</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation>Limpar Ambiente de Trabalho</translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation>Depurar</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation>Passo</translation>
     </message>
@@ -1011,17 +1016,37 @@ para:</translation>
         <translation>Navegador de Arquivos</translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation>Recuperar Disposio de Janelas Padro</translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation>No Disco</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation>Online</translation>
     </message>
@@ -1041,22 +1066,22 @@ para:</translation>
         <translation>Um diretrio acima</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation>Procurar diretrios</translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation>Carregar ambiente de trabalho</translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation>&amp;Janela</translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation>Mostrar Janela de Comandos</translation>
     </message>
@@ -1097,55 +1122,46 @@ para:</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation>Editor</translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation>Documentao</translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation>&amp;Ajuda</translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation>Reportar Bug</translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation>Visite Agora</translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation>Visite Octave Forge</translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation>Desacoplar widget</translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation>Esconder widget</translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation>Acoplar widget</translation>
     </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
@@ -1532,71 +1548,61 @@ para:</translation>
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation>Janela de Comandos</translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation>Digite aqui e pressione &apos;Enter&apos; para procurar</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation>Busca global</translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation>Bem-vindo ao GNU Octave</translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
-        <translation>Aparentemente o Octave GUI foi lanado pela primeira vez neste computador, j que nenhum arquivo de configurao foi encontrado em &apos;~/.octave-gui&apos;. Este tutorial ir gui-lo para realizar configuraes essenciais antes de utilizar o Octave. Se deseja transferir suas configuraes definidas previamente, feche este dilogo e copie os arquivos para o local apropriado. IMPORTANT: Este tutorial no  totalmente funcional ainda. Simplesmente prossiga e configuraes padro sero criadas.</translation>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
-        <translation>Prximo</translation>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation>Anterior</translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation>Bem-vindo ao Octave!</translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation>Esta  a verso de desenvolvimento do Octave com a primeira GUI oficial.</translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation>Voc parece ter executado o Octave GUI pela primeira vez neste computador. Este assistente ir ajud-lo. Clique &apos;Finalizar&apos; para escrever um arquivo de configurao padro e lanar o Octave GUI.</translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation>Finalizar</translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/ru_RU.ts b/libgui/languages/ru_RU.ts
--- a/libgui/languages/ru_RU.ts
+++ b/libgui/languages/ru_RU.ts
@@ -36,16 +36,62 @@
         <source>inherited</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>persistent</source>
         <translation type="unfinished"></translation>
     </message>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.cc" line="+64"/>
+        <source>foreground</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>background</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>selection</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QTerminal</name>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.h" line="+116"/>
+        <source>Copy</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Clear All</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QWinTerminalImpl</name>
+    <message>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
+        <source>copied selection to clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
@@ -53,29 +99,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -88,37 +134,37 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation type="unfinished"> &amp;</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation type="unfinished">&amp;</translation>
     </message>
@@ -138,27 +184,27 @@ is already open in the editor</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation type="unfinished">&amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation type="unfinished">&amp;/ </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation type="unfinished"></translation>
     </message>
@@ -188,57 +234,57 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
+        <location line="+4"/>
+        <source>Close All</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
         <location line="+5"/>
-        <source>Close All</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+4"/>
         <source>Close Other Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation type="unfinished"></translation>
     </message>
@@ -273,32 +319,32 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -314,23 +360,23 @@ Warning: The contents in the editor is m
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -470,32 +516,32 @@ has been deleted or renamed. Do you want
     <message>
         <location line="+25"/>
         <location line="+11"/>
         <source>Delete file/directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-10"/>
-        <source>Are you sre you want to delete
+        <source>Are you sure you want to delete
 </source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation type="unfinished"></translation>
@@ -580,17 +626,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation type="unfinished"></translation>
     </message>
@@ -703,22 +749,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation type="unfinished"></translation>
     </message>
@@ -743,43 +789,43 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+100"/>
+        <location line="+99"/>
         <source>Searching...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation type="unfinished">      .</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation type="unfinished">        .</translation>
     </message>
@@ -807,119 +853,124 @@ has been deleted or renamed. Do you want
         <location line="+1"/>
         <source>Create script</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation type="unfinished">  </translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation type="unfinished"> Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation type="unfinished"></translation>
     </message>
@@ -954,17 +1005,37 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"> </translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation type="unfinished"></translation>
     </message>
@@ -984,22 +1055,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1040,63 +1111,49 @@ has been deleted or renamed. Do you want
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation type="unfinished">  </translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation type="unfinished"></translation>
     </message>
-    <message>
-        <location line="+29"/>
-        <source>Unock widget</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
         <source>help</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1152,22 +1209,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Letter icons</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>Graphic  icons</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+39"/>
+        <location line="+46"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1267,22 +1319,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+46"/>
+        <location line="+45"/>
         <source>Font</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-745"/>
+        <location line="-744"/>
         <source>Show line numbers</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1292,17 +1344,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-282"/>
         <source>Show complete path in window title</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+548"/>
+        <location line="-72"/>
+        <source>Graphic icons</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+620"/>
         <source>emacs</source>
         <translation type="unfinished">emacs</translation>
     </message>
     <message>
         <location line="+67"/>
         <source>Terminal</source>
         <translation type="unfinished"> </translation>
     </message>
@@ -1312,17 +1369,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+102"/>
+        <location line="+101"/>
         <source>Font size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation type="unfinished"> </translation>
     </message>
@@ -1382,32 +1439,32 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-33"/>
         <source>HttpProxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-1108"/>
+        <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+1099"/>
+        <location line="+1098"/>
         <source>Socks5Proxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1429,18 +1486,33 @@ has been deleted or renamed. Do you want
     <message>
         <location filename="../src/settings-dialog.cc" line="+69"/>
         <location line="+4"/>
         <location line="+334"/>
         <source>System setting</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-137"/>
-        <source>Difference to the defalt size</source>
+        <location line="-268"/>
+        <source>IBeam Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Block Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Underline Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+129"/>
+        <source>Difference to the default size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
@@ -1465,71 +1537,61 @@ has been deleted or renamed. Do you want
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/languages/uk_UA.ts b/libgui/languages/uk_UA.ts
--- a/libgui/languages/uk_UA.ts
+++ b/libgui/languages/uk_UA.ts
@@ -36,16 +36,655 @@
         <source>inherited</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>persistent</source>
         <translation type="unfinished"></translation>
     </message>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.cc" line="+64"/>
+        <source>foreground</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>background</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>selection</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QTerminal</name>
+    <message>
+        <location filename="../qterminal/libqterminal/QTerminal.h" line="+116"/>
+        <source>Copy</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Clear All</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QWinTerminalImpl</name>
+    <message>
+        <location filename="../qterminal/libqterminal/win32/QWinTerminalImpl.cpp" line="+1527"/>
+        <source>copied selection to clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerBatch</name>
+    <message>
+        <location filename="../../../qsci/qscilexerbatch.cpp" line="+179"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Label</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Hide command character</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>External command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Variable</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerCPP</name>
+    <message>
+        <location filename="../../../qsci/qscilexercpp.cpp" line="+352"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc style C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc style C comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>IDL UUID</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive IDL UUID</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Pre-processor block</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive pre-processor block</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Unclosed string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive unclosed string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C# verbatim string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C# verbatim string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaScript regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaScript regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc style C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc style C++ comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Secondary keywords and identifiers</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive secondary keywords and identifiers</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>JavaDoc keyword error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive JavaDoc keyword error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Global classes and typedefs</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive global classes and typedefs</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>C++ raw string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Inactive C++ raw string</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerDiff</name>
+    <message>
+        <location filename="../../../qsci/qscilexerdiff.cpp" line="+107"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Header</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Position</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Removed line</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Added line</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Changed line</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerMatlab</name>
+    <message>
+        <location filename="../../../qsci/qscilexermatlab.cpp" line="+138"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Command</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciLexerPerl</name>
+    <message>
+        <location filename="../../../qsci/qscilexerperl.cpp" line="+333"/>
+        <source>Default</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Error</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Comment</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>POD</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Number</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Keyword</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted string</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Operator</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Scalar</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Array</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Hash</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Symbol table</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Regular expression</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Substitution</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backticks</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Data section</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Here document delimiter</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Single-quoted here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backtick here document</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (q)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qq)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qx)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qr)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qw)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>POD verbatim</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Subroutine prototype</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Format identifier</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Format body</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted string (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Translation</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Regular expression (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Substitution (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backticks (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Double-quoted here document (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Backtick here document (interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qq, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qx, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Quoted string (qr, interpolated variable)</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>QsciScintilla</name>
+    <message>
+        <location filename="../../../qsci/qsciscintilla.cpp" line="+4201"/>
+        <source>&amp;Undo</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>&amp;Redo</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+6"/>
+        <source>Cu&amp;t</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+5"/>
+        <source>&amp;Copy</source>
+        <translation type="unfinished">&amp;</translation>
+    </message>
+    <message>
+        <location line="+6"/>
+        <source>&amp;Paste</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+4"/>
+        <source>Delete</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+7"/>
+        <source>Select All</source>
+        <translation type="unfinished"></translation>
+    </message>
 </context>
 <context>
     <name>documentation_dock_widget</name>
     <message>
         <location filename="../src/documentation-dock-widget.cc" line="+34"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
@@ -53,29 +692,29 @@
         <location line="+1"/>
         <source>See the documentation for help.</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>file_editor</name>
     <message>
-        <location filename="../src/m-editor/file-editor.cc" line="+294"/>
+        <location filename="../src/m-editor/file-editor.cc" line="+300"/>
         <location line="+49"/>
         <location line="+28"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-193"/>
+        <location line="-199"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+117"/>
+        <location line="+123"/>
         <source>Could not open file %1 for read:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+49"/>
         <source>File not saved! A file with the selected name
 %1
@@ -88,37 +727,37 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+205"/>
         <source>&amp;%1 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+159"/>
+        <location line="+160"/>
         <source>&amp;New File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Open File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Save File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Save File &amp;As</source>
         <translation type="unfinished"> &amp;</translation>
     </message>
     <message>
-        <location line="+4"/>
+        <location line="+3"/>
         <source>Print</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Undo</source>
         <translation type="unfinished">&amp;</translation>
     </message>
@@ -138,27 +777,27 @@ is already open in the editor</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>&amp;Next Bookmark</source>
         <translation type="unfinished"> &amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Pre&amp;vious Bookmark</source>
         <translation type="unfinished"> &amp; </translation>
     </message>
     <message>
-        <location line="+3"/>
+        <location line="+2"/>
         <source>Toggle &amp;Bookmark</source>
         <translation type="unfinished">&amp;/ </translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Remove All Bookmarks</source>
         <translation type="unfinished"></translation>
     </message>
@@ -188,57 +827,57 @@ is already open in the editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>&amp;Uncomment</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+73"/>
+        <location line="+63"/>
         <source>&amp;Recent Editor Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+15"/>
+        <location line="+16"/>
         <source>&amp;Close</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
+        <location line="+4"/>
+        <source>Close All</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
         <location line="+5"/>
-        <source>Close All</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+4"/>
         <source>Close Other Files</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-94"/>
+        <location line="-85"/>
         <source>&amp;Find and Replace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Save File And Run</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Go&amp;to Line</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+63"/>
+        <location line="+53"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+35"/>
+        <location line="+36"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+21"/>
         <source>&amp;Debug</source>
         <translation type="unfinished"></translation>
     </message>
@@ -273,32 +912,32 @@ is already open in the editor</source>
     <message>
         <location line="+5"/>
         <source>Do you want to cancel closing, save or discard the changes?</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <location line="+114"/>
-        <location line="+104"/>
+        <location line="+109"/>
         <location line="+66"/>
         <location line="+22"/>
         <source>Octave Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-305"/>
+        <location line="-310"/>
         <source>The file
 %1
 is about to be closed but has been modified.
 %2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+184"/>
+        <location line="+189"/>
         <source>Octave Files (*.m);;All Files (*)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+34"/>
         <source>File not saved! The selected file name
 %1
 is the same as the current file name</source>
@@ -314,23 +953,23 @@ Warning: The contents in the editor is m
     <message>
         <location line="+7"/>
         <source>It seems that the file
 %1
 has been deleted or renamed. Do you want to save it now?%2</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-192"/>
+        <location line="-197"/>
         <source>Could not open file %1 for write:
 %2.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+170"/>
+        <location line="+175"/>
         <source>It seems that &apos;%1&apos; has been modified by another application. Do you want to reload it?</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>files_dock_widget</name>
     <message>
         <location filename="../src/files-dock-widget.cc" line="+67"/>
@@ -470,32 +1109,32 @@ has been deleted or renamed. Do you want
     <message>
         <location line="+25"/>
         <location line="+11"/>
         <source>Delete file/directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-10"/>
-        <source>Are you sre you want to delete
+        <source>Are you sure you want to delete
 </source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+11"/>
         <source>Can not delete a directory that is not empty</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+128"/>
+        <location line="+131"/>
         <source>Set directory of file browser</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+27"/>
+        <location line="+28"/>
         <source>Create File</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+0"/>
         <source>Create file in
 </source>
         <translation type="unfinished"></translation>
@@ -580,17 +1219,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Search se&amp;lection</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+61"/>
+        <location line="+71"/>
         <source>Search from end</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Search from start</source>
         <translation type="unfinished"></translation>
     </message>
@@ -703,22 +1342,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Set text content is case insensitive</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+11"/>
         <source>Search results</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+10"/>
+        <location line="+14"/>
         <source>Idle.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+2"/>
         <source>Find</source>
         <translation type="unfinished"></translation>
     </message>
@@ -743,43 +1382,43 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+17"/>
         <source>File contents</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+100"/>
+        <location line="+99"/>
         <source>Searching...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Set search directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>find_files_model</name>
     <message>
-        <location filename="../src/find-files-model.cc" line="+29"/>
+        <location filename="../src/find-files-model.cc" line="+76"/>
         <source>Filename</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+1"/>
         <source>Directory</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>history_dock_widget</name>
     <message>
-        <location filename="../src/history-dock-widget.cc" line="+42"/>
+        <location filename="../src/history-dock-widget.cc" line="+43"/>
         <source>Browse and search the command history.</source>
         <translation type="unfinished">      .</translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Doubleclick a command to transfer it to the terminal.</source>
         <translation type="unfinished">      .</translation>
     </message>
@@ -807,119 +1446,124 @@ has been deleted or renamed. Do you want
         <location line="+1"/>
         <source>Create script</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>main_window</name>
     <message>
-        <location filename="../src/main-window.cc" line="+155"/>
+        <location filename="../src/main-window.cc" line="+160"/>
         <source>Load Workspace</source>
         <translation type="unfinished">  </translation>
     </message>
     <message>
-        <location line="+355"/>
-        <location line="+769"/>
+        <location line="+388"/>
+        <location line="+835"/>
         <source>About Octave</source>
         <translation type="unfinished"> Octave</translation>
     </message>
     <message>
-        <location line="-338"/>
+        <location line="-354"/>
         <source>&amp;File</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
-        <location line="+52"/>
+        <location line="+54"/>
         <source>New</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Script</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+2"/>
+        <location line="+3"/>
         <source>Function</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Figure</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-55"/>
+        <location line="-58"/>
         <source>Open...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+18"/>
+        <location line="+20"/>
         <source>Preferences...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Exit</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+51"/>
+        <location line="+52"/>
         <source>&amp;Edit</source>
         <translation type="unfinished">&amp;</translation>
     </message>
     <message>
         <location line="+5"/>
         <source>Undo</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Copy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+5"/>
+        <location line="+6"/>
         <source>Paste</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-895"/>
-        <location line="+817"/>
+        <location line="-982"/>
+        <location line="+902"/>
         <source>Save Workspace As</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-602"/>
+        <location line="-655"/>
         <source>Set working directory</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+686"/>
+        <location line="+739"/>
+        <source>Clear Clipboard</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+5"/>
         <source>Find Files...</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+6"/>
+        <location line="+5"/>
         <source>Clear Command Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Command History</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Clear Workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+36"/>
+        <location line="+40"/>
         <source>De&amp;bug</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Step</source>
         <translation type="unfinished"></translation>
     </message>
@@ -954,17 +1598,37 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"> </translation>
     </message>
     <message>
         <location line="+14"/>
         <source>Reset Default Window Layout</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+106"/>
+        <location line="+77"/>
+        <source>Octave Packages</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Share Code</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Contribute to Octave</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+3"/>
+        <source>Octave Developer Resources</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+32"/>
         <source>On Disk</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Online</source>
         <translation type="unfinished"></translation>
     </message>
@@ -984,22 +1648,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
         <source>Browse directories</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-392"/>
+        <location line="-412"/>
         <source>Load workspace</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+192"/>
+        <location line="+200"/>
         <source>&amp;Window</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Show Command Window</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1040,63 +1704,49 @@ has been deleted or renamed. Do you want
     </message>
     <message>
         <location line="+3"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+3"/>
-        <location line="+108"/>
+        <location line="+120"/>
         <source>Documentation</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-36"/>
+        <location line="-48"/>
         <source>&amp;Help</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Report Bug</source>
         <translation type="unfinished">  </translation>
     </message>
-    <message>
-        <location line="+6"/>
-        <source>Visit Agora</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-3"/>
-        <source>Visit Octave Forge</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_dock_widget</name>
     <message>
         <location filename="../src/octave-dock-widget.cc" line="+52"/>
+        <location line="+129"/>
         <source>Undock widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+9"/>
+        <location line="-119"/>
         <source>Hide widget</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+82"/>
+        <location line="+86"/>
         <source>Dock widget</source>
         <translation type="unfinished"></translation>
     </message>
-    <message>
-        <location line="+29"/>
-        <source>Unock widget</source>
-        <translation type="unfinished"></translation>
-    </message>
 </context>
 <context>
     <name>octave_qscintilla</name>
     <message>
         <location filename="../src/m-editor/octave-qscintilla.cc" line="+85"/>
         <source>help</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1152,22 +1802,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+10"/>
         <source>Letter icons</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>Graphic  icons</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+39"/>
+        <location line="+46"/>
         <source>Editor</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+16"/>
         <source>Show white space</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1267,22 +1912,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+32"/>
         <source>Terminal Colors</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+46"/>
+        <location line="+45"/>
         <source>Font</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-745"/>
+        <location line="-744"/>
         <source>Show line numbers</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+27"/>
         <source>Highlight current line</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1292,17 +1937,22 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-282"/>
         <source>Show complete path in window title</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+548"/>
+        <location line="-72"/>
+        <source>Graphic icons</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+620"/>
         <source>emacs</source>
         <translation type="unfinished">emacs</translation>
     </message>
     <message>
         <location line="+67"/>
         <source>Terminal</source>
         <translation type="unfinished"> </translation>
     </message>
@@ -1312,17 +1962,17 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+23"/>
         <source>Cursor blinking</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+102"/>
+        <location line="+101"/>
         <source>Font size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+35"/>
         <source>File Browser</source>
         <translation type="unfinished"> </translation>
     </message>
@@ -1382,32 +2032,32 @@ has been deleted or renamed. Do you want
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-33"/>
         <source>HttpProxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-1108"/>
+        <location line="-1107"/>
         <source>Icon set for dock widgets</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Language (requires restart)</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
         <source>Icon size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+1099"/>
+        <location line="+1098"/>
         <source>Socks5Proxy</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="-16"/>
         <source>Hostname:</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1429,18 +2079,33 @@ has been deleted or renamed. Do you want
     <message>
         <location filename="../src/settings-dialog.cc" line="+69"/>
         <location line="+4"/>
         <location line="+334"/>
         <source>System setting</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-137"/>
-        <source>Difference to the defalt size</source>
+        <location line="-268"/>
+        <source>IBeam Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Block Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+1"/>
+        <source>Underline Cursor</source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+129"/>
+        <source>Difference to the default size</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+6"/>
         <source>Background color, pink (255,0,255) means default</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
@@ -1465,71 +2130,61 @@ has been deleted or renamed. Do you want
         <location filename="../src/terminal-dock-widget.cc" line="+38"/>
         <source>Command Window</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>webinfo</name>
     <message>
-        <location filename="../src/qtinfo/webinfo.cc" line="+78"/>
+        <location filename="../src/qtinfo/webinfo.cc" line="+80"/>
         <source>Type here and press &apos;Return&apos; to search</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+4"/>
         <source>Global search</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>welcome_wizard</name>
     <message>
-        <location filename="../src/welcome-wizard.ui" line="+26"/>
+        <location filename="../src/welcome-wizard.ui" line="+29"/>
         <source>Welcome to GNU Octave</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+13"/>
-        <source>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at &apos;~/.octave-gui&apos;. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</source>
+        <location line="+20"/>
+        <source>You seem to be using the Octave graphical interface for the first  time on this computer.  Click &apos;Finish&apos; to write a configuration file  and launch Octave GUI. </source>
+        <translation type="unfinished"></translation>
+    </message>
+    <message>
+        <location line="+10"/>
+        <source>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+41"/>
-        <location line="+50"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <source>Next</source>
+        <location line="+10"/>
+        <source>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-124"/>
-        <location line="+52"/>
-        <location line="+52"/>
-        <location line="+87"/>
-        <source>Previous</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="-45"/>
+        <location line="-27"/>
         <source>Welcome to Octave!</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+7"/>
-        <source>This is the development version of Octave with the first official GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+10"/>
-        <source>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click &apos;Finish&apos; to write a configuration file and launch Octave GUI.</source>
-        <translation type="unfinished"></translation>
-    </message>
-    <message>
-        <location line="+48"/>
+        <location line="+74"/>
         <source>Finish</source>
         <translation type="unfinished"></translation>
     </message>
 </context>
 <context>
     <name>workspace_model</name>
     <message>
         <location filename="../src/workspace-model.cc" line="-42"/>
diff --git a/libgui/qterminal/libqterminal/QTerminal.cc b/libgui/qterminal/libqterminal/QTerminal.cc
--- a/libgui/qterminal/libqterminal/QTerminal.cc
+++ b/libgui/qterminal/libqterminal/QTerminal.cc
@@ -72,21 +72,20 @@ QTerminal::color_names (void)
 
 void
 QTerminal::notice_settings (const QSettings *settings)
 {
   // QSettings pointer is checked before emitting.
 
   // Set terminal font:
   QFont term_font = QFont ();
+  term_font.setStyleHint (QFont::TypeWriter);
   term_font.setFamily
     (settings->value ("terminal/fontName", "Courier New").toString ());
-
   term_font.setPointSize (settings->value ("terminal/fontSize", 10).toInt ());
-
   setTerminalFont (term_font);
 
   QString cursorType
     = settings->value ("terminal/cursorType", "ibeam").toString ();
 
   bool cursorBlinking
     = settings->value ("terminal/cursorBlinking", true).toBool ();
 
diff --git a/libgui/qterminal/libqterminal/unix/Screen.cpp b/libgui/qterminal/libqterminal/unix/Screen.cpp
--- a/libgui/qterminal/libqterminal/unix/Screen.cpp
+++ b/libgui/qterminal/libqterminal/unix/Screen.cpp
@@ -783,18 +783,18 @@ void Screen::ShowCharacter(unsigned shor
           screenLines[cuY].resize(cuX+w);
     }
   }
 
   if (getMode(MODE_Insert)) insertChars(w);
 
   lastPos = loc(cuX,cuY);
 
-  // check if selection is still valid.
-  checkSelection(cuX,cuY);
+  // clear selection on text input
+  clearSelection ();
 
   Character& currentChar = screenLines[cuY][cuX];
 
   currentChar.character = c;
   currentChar.foregroundColor = ef_fg;
   currentChar.backgroundColor = ef_bg;
   currentChar.rendition = ef_re;
 
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalView.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -314,16 +314,20 @@ TerminalView::TerminalView(QWidget *pare
   // this is an important optimization, it tells Qt
   // that TerminalDisplay will handle repainting its entire area.
   setAttribute(Qt::WA_OpaquePaintEvent);
 
   _gridLayout = new QGridLayout(this);
   _gridLayout->setMargin(0);
 
   setLayout( _gridLayout );
+
+  connect (this, SIGNAL (set_global_shortcuts_signal (bool)),
+           parent->parent (), SLOT (set_global_shortcuts (bool)));
+
 }
 
 TerminalView::~TerminalView()
 {
   qApp->removeEventFilter( this );
 
   delete[] _image;
 
@@ -1053,26 +1057,30 @@ void TerminalView::paintEvent( QPaintEve
   //    drawContents(paint, contentsRect());
   drawInputMethodPreeditString(paint,preeditRect());
   paintFilters(paint);
   paint.end();
 }
 
 void TerminalView::focusInEvent(QFocusEvent *focusEvent)
 {
+  emit set_global_shortcuts_signal (false);  // disable some shortcuts
+
   setBlinkingCursorState(true);
   updateImage();
   repaint();
   update();
 
   QWidget::focusInEvent(focusEvent);
 }
 
 void TerminalView::focusOutEvent(QFocusEvent *focusEvent)
 {
+  emit set_global_shortcuts_signal (true);  // re-enable shortcuts
+
   // Force the cursor to be redrawn.
   _cursorBlinking = true;
   setBlinkingCursorState(false);
 
   QWidget::focusOutEvent(focusEvent);
 }
 
 QPoint TerminalView::cursorPosition() const
@@ -2262,19 +2270,16 @@ void TerminalView::copyClipboard()
 {
   if ( !_screenWindow || !hasFocus())
     return;
 
   QString text = _screenWindow->selectedText(_preserveLineBreaks);
 
   if (text.isEmpty ())
     {
-      // FIXME -- interrupt is only appropriate here if CTRL-C is bound
-      // to the copy action.  How can we determine that?
-
       ::raise (SIGINT);
     }
   else
     QApplication::clipboard()->setText(text);
 }
 
 void TerminalView::pasteClipboard()
 {
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.h b/libgui/qterminal/libqterminal/unix/TerminalView.h
--- a/libgui/qterminal/libqterminal/unix/TerminalView.h
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.h
@@ -471,16 +471,22 @@ signals:
      */
     void configureRequest( TerminalView*, int state, const QPoint& position );
 
    void isBusySelecting(bool);
    void sendStringToEmu(const char*);
 
    void tripleClicked( const QString& text );
 
+   /**
+    * Emitted when focus changes
+    */
+   void set_global_shortcuts_signal (bool);
+
+
 protected:
     virtual bool event( QEvent * );
 
     virtual void paintEvent( QPaintEvent * );
 
     void focusInEvent(QFocusEvent *focusEvent);
     void focusOutEvent(QFocusEvent *focusEvent);
 
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -35,17 +35,19 @@ along with Foobar.  If not, see <http://
 #include <QCursor>
 #include <QMessageBox>
 
 #include <fcntl.h>
 #include <io.h>
 #include <stdio.h>
 #include <stdarg.h>
 #define WIN32_LEAN_AND_MEAN
-#define _WIN32_WINNT 0x0500 
+#if ! defined (_WIN32_WINNT) && ! defined (NTDDI_VERSION)
+#define _WIN32_WINNT 0x0500
+#endif
 #include <windows.h>
 #include <cstring>
 #include <csignal>
 #include <limits>
 
 #include "QWinTerminalImpl.h"
 #include "QTerminalColors.h"
 
@@ -87,16 +89,78 @@ protected:
     { q->start (); }
 
 private:
   QWinTerminalImpl* q;
 };
 
 //////////////////////////////////////////////////////////////////////////////
 
+static QString translateKey (QKeyEvent *ev)
+{
+  QString esc = "\x1b";
+  QString s;
+
+  if (ev->key () == Qt::Key_Delete)
+    s = esc + "[C\b";
+  else if (!ev->text ().isEmpty ())
+    s = ev->text ();
+  else
+    {
+
+      switch (ev->key ())
+        {
+        case Qt::Key_Up:
+          s = esc + "[A";
+          break;
+
+        case Qt::Key_Down:
+          s = esc + "[B";
+          break;
+
+        case Qt::Key_Right:
+          s = esc + "[C";
+          break;
+
+        case Qt::Key_Left:
+          s = esc + "[D";
+          break;
+
+        case Qt::Key_Home:
+          s = esc + "[H";
+          break;
+
+        case Qt::Key_End:
+          s = esc + "[F";
+          break;
+
+        case Qt::Key_Insert:
+          s = esc + "[2~";
+          break;
+
+        case Qt::Key_PageUp:
+          s = esc + "[5~";
+          break;
+
+        case Qt::Key_PageDown:
+          s = esc + "[6~";
+          break;
+
+        case Qt::Key_Escape:
+          s = esc;
+          break;
+
+        default:
+          break;
+        }
+    }
+
+  return s;
+}
+
 class QConsolePrivate
 {
   friend class QWinTerminalImpl;
 
 public:
 
   enum KeyboardCursorType
     {
@@ -1094,16 +1158,19 @@ void QConsolePrivate::startCommand (void
 
 void QConsolePrivate::sendConsoleText (const QString& s)
 {
   // Send the string in chunks of 512 characters. Each character is
   // translated into an equivalent keypress event.
 
 #define TEXT_CHUNK_SIZE 512
 
+  // clear any selection on inserting text
+  clearSelection();
+
   int len = s.length ();
   INPUT_RECORD events[TEXT_CHUNK_SIZE];
   DWORD nEvents = 0, written;
   HANDLE hStdIn = GetStdHandle (STD_INPUT_HANDLE);
 
   ZeroMemory (events, sizeof (events));
 
   for (int i = 0; i < len; i++)
@@ -1157,16 +1224,20 @@ QConsolePrivate::cursorRect (void)
                 cw, ch);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 QWinTerminalImpl::QWinTerminalImpl (QWidget* parent)
     : QTerminal (parent), d (new QConsolePrivate (this))
 {
+    installEventFilter (this);
+
+    connect (this, SIGNAL (set_global_shortcuts_signal (bool)),
+           parent, SLOT (set_global_shortcuts (bool)));
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 QWinTerminalImpl::QWinTerminalImpl (const QString& cmd, QWidget* parent)
     : QTerminal (parent), d (new QConsolePrivate (this, cmd))
 {
 }
@@ -1285,37 +1356,16 @@ void QWinTerminalImpl::wheelEvent (QWhee
       d->m_inWheelEvent = true;
       QApplication::sendEvent (d->m_scrollBar, event);
       d->m_inWheelEvent = false;
     }
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
-bool QWinTerminalImpl::winEvent (MSG* msg, long* result)
-{
-  switch (msg->message)
-    {
-    case WM_KEYDOWN:
-    case WM_KEYUP:
-    //case WM_CHAR:
-      // Forward Win32 message to the console window
-      PostMessage (d->m_consoleWindow,
-                   msg->message,
-                   msg->wParam,
-                   msg->lParam);
-      result = 0;
-      return true;
-    default:
-      return false;
-    }
-}
-
-//////////////////////////////////////////////////////////////////////////////
-
 void QWinTerminalImpl::scrollValueChanged (int value)
 {
   d->setScrollValue (value);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::monitorConsole (void)
@@ -1327,33 +1377,57 @@ void QWinTerminalImpl::updateSelection (
 {
   d->updateSelection ();
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::focusInEvent (QFocusEvent* event)
 {
+  emit set_global_shortcuts_signal (false);   // disable some shortcuts
+
   setBlinkingCursorState (true);
 
   QWidget::focusInEvent (event);
 }
 
 void QWinTerminalImpl::focusOutEvent (QFocusEvent* event)
 {
+  emit set_global_shortcuts_signal (true);    // re-enable shortcuts
+
   // Force the cursor to be redrawn.
   d->m_cursorBlinking = true;
 
   setBlinkingCursorState (false);
 
   QWidget::focusOutEvent (event);
 }
 
+bool QWinTerminalImpl::eventFilter (QObject *obj, QEvent * event)
+{
+  // if a keypress, filter out tab keys so that the next/prev tabbing is
+  // disabled - but we still need to pass along to the console .
+  if (event->type () == QEvent::KeyPress)
+  {
+    QKeyEvent* k = static_cast<QKeyEvent*>(event);
+    if (k->key () == Qt::Key_Tab)
+    {
+      sendText ("\t");
+      return true;
+    }
+  }
+  return false;
+}
+
 void QWinTerminalImpl::keyPressEvent (QKeyEvent* event)
 {
+  QString s = translateKey (event);
+  if (!s.isEmpty ())
+    sendText (s);
+
   if (d->m_hasBlinkingCursor)
     {
       d->m_blinkCursorTimer->start (d->BLINK_DELAY);
 
       if (d->m_cursorBlinking)
         blinkCursorEvent ();
     }
 
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
@@ -65,32 +65,34 @@ public:
 public slots:
   void copyClipboard (void);
   void pasteClipboard (void);
   void blinkCursorEvent (void);
 
 signals:
   void terminated (void);
   void titleChanged (const QString&);
+  void set_global_shortcuts_signal (bool);
 
 protected:
   void viewPaintEvent (QConsoleView*, QPaintEvent*);
   void setBlinkingCursor (bool blink);
   void setBlinkingCursorState (bool blink);
   void viewResizeEvent (QConsoleView*, QResizeEvent*);
   void wheelEvent (QWheelEvent*);
   void focusInEvent (QFocusEvent*);
   void focusOutEvent (QFocusEvent*);
   void keyPressEvent (QKeyEvent*);
-  bool winEvent (MSG*, long*);
   virtual void start (void);
   void mouseMoveEvent (QMouseEvent *event);
   void mousePressEvent (QMouseEvent *event);
   void mouseReleaseEvent (QMouseEvent *event);
 
+  bool eventFilter(QObject *obj, QEvent *ev);
+
 private slots:
   void scrollValueChanged (int value);
   void monitorConsole (void);
   void updateSelection (void);
 
 private:
   QConsolePrivate* d;
 };
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -415,17 +415,17 @@ InputDialog::buttonCancel_clicked (void)
 
   
 void
 InputDialog::reject (void)
 {
   buttonCancel_clicked ();
 }
 
-FileDialog::FileDialog (const QStringList& filters, const QString& title,
+FileDialog::FileDialog (const QStringList& name_filters, const QString& title,
                         const QString& filename, const QString& dirname,
                         const QString& multimode)
   : QFileDialog()
 {
   // Create a NonModal message.
   setWindowModality (Qt::NonModal);
 
   setWindowTitle (title.isEmpty () ? " " : title);
@@ -451,17 +451,17 @@ FileDialog::FileDialog (const QStringLis
       setAcceptMode (QFileDialog::AcceptOpen);
     }
   else                           // uigetfile multiselect=off
     {
       setFileMode (QFileDialog::ExistingFile);
       setAcceptMode (QFileDialog::AcceptOpen);
     }
 
-  setNameFilters (filters);
+  setNameFilters (name_filters);
 
   selectFile (filename);
   
   connect (this,
            SIGNAL (finish_input (const QStringList&, const QString&, int)),
            &uiwidget_creator,
            SLOT (filedialog_finished (const QStringList&, const QString&,
                                       int)));
@@ -488,16 +488,16 @@ void FileDialog::accept(void)
   // pull path names, so fix it.
 
   for (int i = 0; i < string_result.size (); i++)
     string_result[i] = QFileInfo (string_result[i]).fileName ();
 
 
   path = directory ().absolutePath ();
 
-  QStringList filters = nameFilters ();
-  idx = filters.indexOf (selectedNameFilter ()) + 1;
+  QStringList name_filters = nameFilters ();
+  idx = name_filters.indexOf (selectedNameFilter ()) + 1;
   
   // send the selected info
   emit finish_input (string_result, path, idx);
   done (QDialog::Accepted);
 }
 
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -31,20 +31,35 @@ documentation_dock_widget::documentation
 {
   setObjectName ("DocumentationDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Documentation"));
   setStatusTip (tr ("See the documentation for help."));
 
   _webinfo = new webinfo (this);
   setWidget (_webinfo);
+
+  connect (p, SIGNAL(show_doc_signal(const QString &)),
+   this, SLOT(showDoc(const QString &)));
 }
 
 void
 documentation_dock_widget::copyClipboard ()
 {
   _webinfo->copyClipboard ();
 }
 void
 documentation_dock_widget::pasteClipboard ()
 {
   _webinfo->pasteClipboard ();
 }
+void
+documentation_dock_widget::showDoc (const QString &name)
+{
+  // show the doc pane
+  if (!isVisible ())
+    setVisible (true);
+  setFocus ();
+  raise ();
+
+  _webinfo->load_ref (name);
+
+}
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -34,14 +34,15 @@ class documentation_dock_widget : public
 public:
 
   documentation_dock_widget (QWidget *parent = 0);
 
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
 
+  void showDoc (const QString & name);
 private:
 
   webinfo *_webinfo;
 };
 
 #endif // DOCUMENTATIONDOCKWIDGET_H
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -631,25 +631,29 @@ files_dock_widget::notice_settings (cons
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
 {
-  QString dir = QDir::homePath ();
+  QString dir = qgetenv ("HOME");
+  if (dir.isEmpty())
+    dir = QDir::homePath ();
+  
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_search_dir (bool)
 {
   QString dir = QFileDialog::getExistingDirectory
-    (this, tr ("Set directory of file browser"),_file_system_model->rootPath());
+    (this, tr ("Set directory of file browser"),_file_system_model->rootPath(),
+     QFileDialog::DontUseNativeDialog);
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_findfiles (bool)
 {
       process_find_files(_file_system_model->rootPath());
 }
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -91,26 +91,30 @@ find_files_dialog::find_files_dialog (QW
   _contains_text_edit = new QLineEdit ();
   _contains_text_edit->setToolTip (tr ("Text to match"));
   _contains_text_edit->setText (settings->value ("findfiles/contains_text", "").toString());
 
   _content_case_check = new QCheckBox (tr("Text case insensitive"));
   _content_case_check->setChecked (settings->value ("findfiles/content_case", false).toBool());
   _content_case_check->setToolTip (tr ("Set text content is case insensitive"));
   
-  find_files_model * model = new find_files_model ();
+  find_files_model * model = new find_files_model (this);
+
   _file_list = new QTableView;
   _file_list->setWordWrap (false);
   _file_list->setModel (model);
   _file_list->setShowGrid (false);
   _file_list->setSelectionBehavior(QAbstractItemView::SelectRows);
   _file_list->setSelectionMode(QAbstractItemView::SingleSelection);
   _file_list->setAlternatingRowColors(true);
   _file_list->setToolTip (tr ("Search results"));
+  _file_list->setSortingEnabled (true);
   _file_list->horizontalHeader ()->restoreState (settings->value ("findfiles/column_state").toByteArray ());
+  _file_list->horizontalHeader ()->setSortIndicatorShown (true);
+  _file_list->horizontalHeader ()->setClickable (true);
   _file_list->horizontalHeader ()->setStretchLastSection (true);
   _file_list->sortByColumn (
               settings->value ("findfiles/sort_files_by_column",0).toInt (),
               static_cast<Qt::SortOrder>(settings->value ("findfiles/sort_files_by_order",Qt::AscendingOrder).toUInt ()));
 
   connect (_file_list, SIGNAL(doubleClicked(const QModelIndex&)),
            this,       SLOT(item_double_clicked(const QModelIndex &)));
 
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -17,22 +17,70 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #include "find-files-model.h"
 #include <QFileIconProvider>
+#include <QtAlgorithms>
+
+class find_file_less_than
+{
+public:
+  find_file_less_than (int ord)
+  {
+    _sortorder = ord;
+  }
+  QVariant getValue (const QFileInfo &f) const
+  {
+     QVariant val;
+     int col = (_sortorder > 0) ? _sortorder : -_sortorder;
+
+     switch (col-1)
+       {
+         case 0:
+           val = QVariant (f.fileName());
+           break;
+
+         case 1:
+           val = QVariant (f.absolutePath());
+           break;
+
+         default:
+            break;
+        }
+     return val;
+  }
+  bool lessThan (const QVariant &left, const QVariant &right) const
+  {
+    return left.toString ().compare (right.toString (), Qt::CaseInsensitive) < 0;
+  }
+  bool operator () (const QFileInfo &left, const QFileInfo &right) const
+  {
+     QVariant leftval = getValue(left);
+     QVariant rightval = getValue(right);
+
+     if (_sortorder > 0)
+        return lessThan(leftval, rightval);
+     else
+        return ! lessThan(leftval, rightval);
+  }
+private:
+  int _sortorder;
+};
+
 
 find_files_model::find_files_model (QObject *p)
   : QAbstractListModel(p)
 {
   _columnNames.append (tr ("Filename"));
   _columnNames.append (tr ("Directory"));
+  _sortorder = 0;
 }
 
 find_files_model::~find_files_model ()
 {
 }
 
 void 
 find_files_model::clear ()
@@ -42,31 +90,39 @@ find_files_model::clear ()
   _files.clear();
 
   endResetModel ();
 }
 
 void 
 find_files_model::addFile (const QFileInfo &info)
 {
-  beginInsertRows(QModelIndex(), _files.size(), _files.size() );
+  beginInsertRows (QModelIndex (), _files.size (), _files.size () );
+
+  QList<QFileInfo>::Iterator it; 
+  find_file_less_than less_than(_sortorder);
 
-  _files.append(info);
+  for (it=_files.begin ();it!=_files.end ();it++)
+    {
+      if (less_than (info, *it)) break;
+    }
 
-  endInsertRows(); 
+  _files.insert (it, info);
+
+  endInsertRows (); 
 }
 
 int 
-find_files_model::rowCount (const QModelIndex & p) const
+find_files_model::rowCount (const QModelIndex &) const
 {
   return _files.size();
 }
 
 int 
-find_files_model::columnCount (const QModelIndex & p) const
+find_files_model::columnCount (const QModelIndex &) const
 {
   return _columnNames.size ();
 }
 
 QVariant 
 find_files_model::data (const QModelIndex& idx, int role) const
 {
   QVariant retval;
@@ -108,16 +164,37 @@ QVariant
 find_files_model::headerData (int section, Qt::Orientation orientation, int role) const
 {
   if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
     return _columnNames[section];
   else
     return QVariant ();
 }
 
+void
+find_files_model::sort (int column, Qt::SortOrder order)
+{
+  if(column >= 0)
+    {
+      if (order == Qt::DescendingOrder)
+        _sortorder = -(column+1);
+      else
+        _sortorder = column+1;
+    }
+  else
+    _sortorder = 0;
+
+  if (_sortorder != 0)
+    {
+      beginResetModel ();
+      qSort (_files.begin (), _files.end (), find_file_less_than (_sortorder));
+      endResetModel ();
+    }
+}
+
 QFileInfo 
 find_files_model::fileInfo (const QModelIndex & p) const
 {
   if(p.isValid ())
   {
     return _files[p.row()];
   }
   return QFileInfo ();
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -45,17 +45,20 @@ public:
 
   int columnCount(const QModelIndex & p=QModelIndex()) const;
 
   QVariant data (const QModelIndex& idx, int role) const;
 
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
 
+  void sort (int column, Qt::SortOrder order=Qt::AscendingOrder);
+
   QFileInfo fileInfo (const QModelIndex & p) const;
   QIcon     fileIcon (const QModelIndex &p) const;
 private:
   QList<QFileInfo> _files;
   QStringList _columnNames;
+  int _sortorder;
 };
 
 #endif // find_files_model_h
 
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <QApplication>
 #include <QClipboard>
 #include <QVBoxLayout>
 #include <QMenu>
+#include <QScrollBar>
 
 #include "error.h"
 
 #include "cmd-hist.h"
 
 #include "history-dock-widget.h"
 
 history_dock_widget::history_dock_widget (QWidget *p)
@@ -99,74 +100,94 @@ void history_dock_widget::ctxMenu(const 
 }
 
 void history_dock_widget::handle_contextmenu_copy(bool)
 {
   QString text;
   QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
   QModelIndexList rows = selectionModel->selectedRows();
   QModelIndexList::iterator it;
-  for (it=rows.begin() ; it != rows.end(); it++) {
-    if ((*it).isValid()) {
-      text += (*it).data().toString()+"\n";
+  bool prev_valid_row = false;
+  for (it = rows.begin(); it != rows.end(); it++)
+    {
+      if ((*it).isValid())
+        {
+          if (prev_valid_row)
+            text += "\n";
+          text += (*it).data().toString();
+          prev_valid_row = true;
+        }
     }
-  }
   QApplication::clipboard()->setText(text);
 }
 
 void history_dock_widget::handle_contextmenu_evaluate(bool)
 {
   QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
   QModelIndexList rows = selectionModel->selectedRows();
   QModelIndexList::iterator it;
-  for (it=rows.begin() ; it != rows.end(); it++) {
-    if ((*it).isValid()) {
-      emit command_double_clicked ((*it).data().toString()+"\n");
+  for (it = rows.begin() ; it != rows.end(); it++)
+    {
+      if ((*it).isValid())
+        emit command_double_clicked ((*it).data().toString());
     }
-  }
 }
 
 void
 history_dock_widget::handle_contextmenu_create_script (bool)
 {
   QString text;
   QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
   QModelIndexList rows = selectionModel->selectedRows ();
 
+  bool prev_valid_row = false;
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       if ((*it).isValid ())
-        text += (*it).data().toString() + "\n";
+        {
+          if (prev_valid_row)
+            text += "\n";
+          text += (*it).data().toString();
+          prev_valid_row = true;
+        }
     }
 
   if (text.length () > 0)
     emit command_create_script (text);
 }
 
 
 void
 history_dock_widget::handle_double_click (QModelIndex modelIndex)
 {
-  emit command_double_clicked (modelIndex.data().toString()+"\n");
+  emit command_double_clicked (modelIndex.data().toString());
 }
 
 void
 history_dock_widget::set_history (const QStringList& hist)
 {
   _history_model->setStringList (hist);
   _history_list_view->scrollToBottom ();
 }
 
 void
 history_dock_widget::append_history (const QString& hist_entry)
 {
   QStringList lst = _history_model->stringList ();
   lst.append (hist_entry);
+
+  QScrollBar *scroll_bar = _history_list_view->verticalScrollBar ();
+
+  bool at_bottom = scroll_bar->maximum () - scroll_bar->value () < 1;
+
   _history_model->setStringList (lst);
-  _history_list_view->scrollToBottom ();
+
+  // Scroll if slider position at bottom.
+  if (at_bottom)
+    _history_list_view->scrollToBottom ();
 }
 
 void
 history_dock_widget::clear_history (void)
 {
   _history_model->setStringList (QStringList ());
 }
 
@@ -181,16 +202,16 @@ history_dock_widget::copyClipboard ()
       clipboard->setText ( _filter_line_edit->selectedText ());
     }
 }
 
 void
 history_dock_widget::pasteClipboard ()
 {
   if(_filter_line_edit->hasFocus ())
-  {
-     QClipboard *clipboard = QApplication::clipboard ();
-     QString str =  clipboard->text ();
-     if (str.length() > 0)
-       _filter_line_edit->insert (str);
-  } 
+    {
+      QClipboard *clipboard = QApplication::clipboard ();
+      QString str =  clipboard->text ();
+      if (str.length() > 0)
+        _filter_line_edit->insert (str);
+    }
 }
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1005,16 +1005,21 @@ file_editor_tab::save_file_as (bool remo
       // If tab is closed, "this" cannot be parent in which case modality
       // has no effect.  Disable editing instead.
       _edit_area->setReadOnly (true);
       fileDialog = new QFileDialog ();
     }
   else
     fileDialog = new QFileDialog (this);
 
+  // Giving trouble under KDE (problem is related to Qt signal handling on unix,
+  // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
+  // it had/has no effect on Windows, though)
+  fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
+
   if (!_file_name.isEmpty () && _file_name.at (_file_name.count () - 1) != '/')
     {
       fileDialog->selectFile (_file_name);
     }
   else
     {
       fileDialog->selectFile ("");
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -171,16 +171,22 @@ file_editor::request_open_file (void)
 {
   // Open file isn't a file_editor_tab function since the file
   // editor tab has yet to be created and there is no object to
   // pass a signal to.  Hence, functionality is here.
 
   // Create a NonModal message.
   QFileDialog *fileDialog = new QFileDialog (this);
   fileDialog->setNameFilter (tr ("Octave Files (*.m);;All Files (*)"));
+
+  // Giving trouble under KDE (problem is related to Qt signal handling on unix,
+  // see https://bugs.kde.org/show_bug.cgi?id=260719 ,
+  // it had/has no effect on Windows, though)
+  fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
+
   fileDialog->setAcceptMode (QFileDialog::AcceptOpen);
   fileDialog->setViewMode (QFileDialog::Detail);
   fileDialog->setDirectory (ced);
 
   connect (fileDialog, SIGNAL (fileSelected (const QString&)),
            this, SLOT (request_open_file (const QString&)));
 
   fileDialog->setWindowModality (Qt::NonModal);
@@ -663,16 +669,17 @@ file_editor::handle_tab_remove_request (
         {
           if (_tab_widget->widget (i) == fileEditorTab)
             {
               _tab_widget->removeTab (i);
               delete fileEditorTab;
             }
         }
     }
+    check_actions ();
 }
 
 void
 file_editor::handle_add_filename_to_list (const QString& fileName, QWidget *ID)
 {
   // Should we allow multiple tabs for a single file?
 
   editor_tab_map[fileName] = ID;
@@ -733,135 +740,120 @@ file_editor::construct (void)
   _tab_widget->setTabsClosable (true);
 
   QAction *new_action = new QAction (QIcon (":/actions/icons/filenew.png"),
                                      tr ("&New File"), _tool_bar);
 
   QAction *open_action = new QAction (QIcon (":/actions/icons/fileopen.png"),
                                       tr ("&Open File"), _tool_bar);
 
-  QAction *save_action = new QAction (QIcon (":/actions/icons/filesave.png"),
+  _save_action = new QAction (QIcon (":/actions/icons/filesave.png"),
                                       tr ("&Save File"), _tool_bar);
 
-  QAction *save_as_action
-    = new QAction (QIcon (":/actions/icons/filesaveas.png"),
-                   tr ("Save File &As"), _tool_bar);
+  _save_as_action = new QAction (QIcon (":/actions/icons/filesaveas.png"),
+                                tr ("Save File &As"), _tool_bar);
 
-  QAction *print_action
-    = new QAction ( QIcon (":/actions/icons/fileprint.png"),
-                    tr ("Print"), _tool_bar);
+  _print_action = new QAction ( QIcon (":/actions/icons/fileprint.png"),
+                                tr ("Print"), _tool_bar);
 
-  QAction *undo_action = new QAction (QIcon (":/actions/icons/undo.png"),
+  _undo_action = new QAction (QIcon (":/actions/icons/undo.png"),
                                       tr ("&Undo"), _tool_bar);
 
-  QAction *redo_action = new QAction (QIcon (":/actions/icons/redo.png"),
+  _redo_action = new QAction (QIcon (":/actions/icons/redo.png"),
                                       tr ("&Redo"), _tool_bar);
 
   _copy_action = new QAction (QIcon (":/actions/icons/editcopy.png"),
                               tr ("&Copy"), _tool_bar);
 
   _cut_action = new QAction (QIcon (":/actions/icons/editcut.png"),
                               tr ("Cu&t"), _tool_bar);
 
-  QAction *paste_action
+  _paste_action
     = new QAction (QIcon (":/actions/icons/editpaste.png"),
                    tr ("Paste"), _tool_bar);
 
-  QAction *next_bookmark_action
-    = new QAction (tr ("&Next Bookmark"), _tool_bar);
+  _next_bookmark_action = new QAction (tr ("&Next Bookmark"), _tool_bar);
+
+  _previous_bookmark_action = new QAction (tr ("Pre&vious Bookmark"), _tool_bar);
 
-  QAction *previous_bookmark_action
-    = new QAction (tr ("Pre&vious Bookmark"), _tool_bar);
+  _toggle_bookmark_action = new QAction (tr ("Toggle &Bookmark"), _tool_bar);
 
-  QAction *toggle_bookmark_action
-    = new QAction (tr ("Toggle &Bookmark"), _tool_bar);
-
-  QAction *remove_bookmark_action
+  _remove_bookmark_action
     = new QAction (tr ("&Remove All Bookmarks"), _tool_bar);
 
   QAction *next_breakpoint_action
     = new QAction (QIcon (":/actions/icons/bp_next.png"),
                    tr ("&Next breakpoint"), _tool_bar);
   QAction *previous_breakpoint_action
     = new QAction (QIcon (":/actions/icons/bp_prev.png"),
                    tr ("Pre&vious breakpoint"), _tool_bar);
   QAction *toggle_breakpoint_action
     = new QAction (QIcon (":/actions/icons/bp_toggle.png"),
                    tr ("Toggle &breakpoint"), _tool_bar);
   QAction *remove_all_breakpoints_action
     = new QAction (QIcon (":/actions/icons/bp_rm_all.png"),
                    tr ("&Remove All breakpoints"), _tool_bar);
 
-  QAction *comment_selection_action
+  _comment_selection_action
     = new QAction (tr ("&Comment"), _tool_bar);
 
-  QAction *uncomment_selection_action
+  _uncomment_selection_action
     = new QAction (tr ("&Uncomment"), _tool_bar);
 
-  QAction *find_action = new QAction (QIcon (":/actions/icons/search.png"),
+  _find_action = new QAction (QIcon (":/actions/icons/search.png"),
                                       tr ("&Find and Replace"), _tool_bar);
 
   _run_action = new QAction (QIcon (":/actions/icons/artsbuilderexecute.png"),
                              tr ("Save File And Run"), _tool_bar);
 
-  QAction *goto_line_action = new QAction (tr ("Go&to Line"), _tool_bar);
+  _goto_line_action = new QAction (tr ("Go&to Line"), _tool_bar);
 
   // the mru-list and an empty array of actions
   QSettings *settings = resource_manager::get_settings ();
   // FIXME -- what should happen if settings is 0?
   _mru_files = settings->value ("editor/mru_file_list").toStringList ();
   for (int i = 0; i < MaxMRUFiles; ++i)
     {
        _mru_file_actions[i] = new QAction (this);
        _mru_file_actions[i]->setVisible (false);
     }
 
   // some actions are disabled from the beginning
   _copy_action->setEnabled (false);
   _cut_action->setEnabled (false);
-  _run_action->setShortcut (Qt::ControlModifier+ Qt::Key_R);
+
   _run_action->setShortcutContext (Qt::WindowShortcut);
-  save_action->setShortcut (QKeySequence::Save);
-  save_action->setShortcutContext (Qt::WindowShortcut);
-  save_as_action->setShortcut (QKeySequence::SaveAs);
-  save_as_action->setShortcutContext (Qt::WindowShortcut);
+  _save_action->setShortcutContext (Qt::WindowShortcut);
+  _save_as_action->setShortcutContext (Qt::WindowShortcut);
 
-  print_action->setShortcut (QKeySequence::Print);
-  print_action->setShortcutContext (Qt::WindowShortcut);
+  _print_action->setShortcutContext (Qt::WindowShortcut);
 
-  next_bookmark_action->setShortcut (Qt::Key_F2);
-  next_bookmark_action->setShortcutContext (Qt::WindowShortcut);
-  previous_bookmark_action->setShortcut (Qt::SHIFT + Qt::Key_F2);
-  previous_bookmark_action->setShortcutContext (Qt::WindowShortcut);
-  toggle_bookmark_action->setShortcut (Qt::Key_F7);
-  toggle_bookmark_action->setShortcutContext (Qt::WindowShortcut);
-  comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_7);
-  comment_selection_action->setShortcutContext (Qt::WindowShortcut);
-  uncomment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_8);
-  uncomment_selection_action->setShortcutContext (Qt::WindowShortcut);
-  find_action->setShortcut (QKeySequence::Find);
-  find_action->setShortcutContext (Qt::WindowShortcut);
-  goto_line_action->setShortcut (Qt::ControlModifier+ Qt::Key_G);
-  goto_line_action->setShortcutContext (Qt::WindowShortcut);
+  _next_bookmark_action->setShortcutContext (Qt::WindowShortcut);
+  _previous_bookmark_action->setShortcutContext (Qt::WindowShortcut);
+  _toggle_bookmark_action->setShortcutContext (Qt::WindowShortcut);
+  _comment_selection_action->setShortcutContext (Qt::WindowShortcut);
+  _uncomment_selection_action->setShortcutContext (Qt::WindowShortcut);
+  _find_action->setShortcutContext (Qt::WindowShortcut);
+  _goto_line_action->setShortcutContext (Qt::WindowShortcut);
 
   // toolbar
   _tool_bar->addAction (new_action);
   _tool_bar->addAction (open_action);
-  _tool_bar->addAction (save_action);
-  _tool_bar->addAction (save_as_action);
+  _tool_bar->addAction (_save_action);
+  _tool_bar->addAction (_save_as_action);
   _tool_bar->addSeparator ();
-  _tool_bar->addAction (print_action);
+  _tool_bar->addAction (_print_action);
   _tool_bar->addSeparator ();
-  _tool_bar->addAction (undo_action);
-  _tool_bar->addAction (redo_action);
+  _tool_bar->addAction (_undo_action);
+  _tool_bar->addAction (_redo_action);
   _tool_bar->addAction (_copy_action);
   _tool_bar->addAction (_cut_action);
-  _tool_bar->addAction (paste_action);
+  _tool_bar->addAction (_paste_action);
   _tool_bar->addSeparator ();
-  _tool_bar->addAction (find_action);
+  _tool_bar->addAction (_find_action);
   _tool_bar->addAction (_run_action);
   _tool_bar->addSeparator ();
   _tool_bar->addAction (toggle_breakpoint_action);
   _tool_bar->addAction (next_breakpoint_action);
   _tool_bar->addAction (previous_breakpoint_action);
   _tool_bar->addAction (remove_all_breakpoints_action);
 
   // menu bar
@@ -871,155 +863,161 @@ file_editor::construct (void)
   for (int i = 0; i < MaxMRUFiles; ++i)
     _mru_file_menu->addAction (_mru_file_actions[i]);
 
   fileMenu->addAction (new_action);
   fileMenu->addAction (open_action);
   fileMenu->addMenu (_mru_file_menu);
 
   fileMenu->addSeparator ();
-  fileMenu->addAction (save_action);
-  fileMenu->addAction (save_as_action);
+  fileMenu->addAction (_save_action);
+  fileMenu->addAction (_save_as_action);
 
   fileMenu->addSeparator ();
-  fileMenu->addAction (QIcon::fromTheme("window-close",
-                                      QIcon (":/actions/icons/fileclose.png")),
-                       tr ("&Close"),
-                       this, SLOT (request_close_file (bool)),
-                             QKeySequence::Close);
-  fileMenu->addAction (QIcon::fromTheme("window-close",
+  _close_action =
+      fileMenu->addAction (QIcon::fromTheme("window-close",
+                                  QIcon (":/actions/icons/fileclose.png")),
+                       tr ("&Close"), this, SLOT (request_close_file (bool)));
+  _close_all_action =
+      fileMenu->addAction (QIcon::fromTheme("window-close",
                                       QIcon (":/actions/icons/fileclose.png")),
                        tr ("Close All"),
                        this, SLOT (request_close_all_files (bool)));
+  _close_others_action = 
   fileMenu->addAction (QIcon::fromTheme("window-close",
                                       QIcon (":/actions/icons/fileclose.png")),
                        tr ("Close Other Files"),
                        this, SLOT (request_close_other_files (bool)));
 
   fileMenu->addSeparator ();
-  fileMenu->addAction (print_action);
+  fileMenu->addAction (_print_action);
 
   _menu_bar->addMenu (fileMenu);
 
 
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
-  editMenu->addAction (undo_action);
-  editMenu->addAction (redo_action);
+  editMenu->addAction (_undo_action);
+  editMenu->addAction (_redo_action);
   editMenu->addSeparator ();
   editMenu->addAction (_copy_action);
   editMenu->addAction (_cut_action);
-  editMenu->addAction (paste_action);
+  editMenu->addAction (_paste_action);
   editMenu->addSeparator ();
-  editMenu->addAction (find_action);
+  editMenu->addAction (_find_action);
   editMenu->addSeparator ();
-  editMenu->addAction (comment_selection_action);
-  editMenu->addAction (uncomment_selection_action);
+  editMenu->addAction (_comment_selection_action);
+  editMenu->addAction (_uncomment_selection_action);
   editMenu->addSeparator ();
-  editMenu->addAction (toggle_bookmark_action);
-  editMenu->addAction (next_bookmark_action);
-  editMenu->addAction (previous_bookmark_action);
-  editMenu->addAction (remove_bookmark_action);
+  editMenu->addAction (_toggle_bookmark_action);
+  editMenu->addAction (_next_bookmark_action);
+  editMenu->addAction (_previous_bookmark_action);
+  editMenu->addAction (_remove_bookmark_action);
   editMenu->addSeparator ();
-  editMenu->addAction (goto_line_action);
+  editMenu->addAction (_goto_line_action);
   _menu_bar->addMenu (editMenu);
 
   _debug_menu = new QMenu (tr ("&Debug"), _menu_bar);
   _debug_menu->addAction (toggle_breakpoint_action);
   _debug_menu->addAction (next_breakpoint_action);
   _debug_menu->addAction (previous_breakpoint_action);
   _debug_menu->addAction (remove_all_breakpoints_action);
   _debug_menu->addSeparator ();
   // The other debug actions will be added by the main window.
   _menu_bar->addMenu (_debug_menu);
 
   QMenu *_run_menu = new QMenu (tr ("&Run"), _menu_bar);
   _run_menu->addAction (_run_action);
   _menu_bar->addMenu (_run_menu);
 
+  // shortcuts
+  set_shortcuts (true);
+
+  // layout
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->addWidget (_menu_bar);
   vbox_layout->addWidget (_tool_bar);
   vbox_layout->addWidget (_tab_widget);
   vbox_layout->setMargin (0);
   editor_widget->setLayout (vbox_layout);
   setWidget (editor_widget);
 
+  // signals
   connect (main_win (), SIGNAL (new_file_signal (const QString&)),
            this, SLOT (request_new_file (const QString&)));
 
   connect (main_win (), SIGNAL (open_file_signal (const QString&)),
            this, SLOT (request_open_file (const QString&)));
 
   connect (new_action, SIGNAL (triggered ()),
            this, SLOT (request_new_file ()));
 
   connect (open_action, SIGNAL (triggered ()),
            this, SLOT (request_open_file ()));
 
-  connect (undo_action, SIGNAL (triggered ()),
+  connect (_undo_action, SIGNAL (triggered ()),
            this, SLOT (request_undo ()));
 
-  connect (redo_action, SIGNAL (triggered ()),
+  connect (_redo_action, SIGNAL (triggered ()),
            this, SLOT (request_redo ()));
 
   connect (_copy_action, SIGNAL (triggered ()),
            this, SLOT (request_copy ()));
 
   connect (_cut_action, SIGNAL (triggered ()),
            this, SLOT (request_cut ()));
 
-  connect (paste_action, SIGNAL (triggered ()),
+  connect (_paste_action, SIGNAL (triggered ()),
            this, SLOT (request_paste ()));
 
-  connect (save_action, SIGNAL (triggered ()),
+  connect (_save_action, SIGNAL (triggered ()),
            this, SLOT (request_save_file ()));
 
-  connect (save_as_action, SIGNAL (triggered ()),
+  connect (_save_as_action, SIGNAL (triggered ()),
            this, SLOT (request_save_file_as ()));
 
-  connect (print_action, SIGNAL (triggered ()),
+  connect (_print_action, SIGNAL (triggered ()),
            this, SLOT (request_print_file ()));
 
   connect (_run_action, SIGNAL (triggered ()),
            this, SLOT (request_run_file ()));
 
-  connect (toggle_bookmark_action, SIGNAL (triggered ()),
+  connect (_toggle_bookmark_action, SIGNAL (triggered ()),
            this, SLOT (request_toggle_bookmark ()));
 
-  connect (next_bookmark_action, SIGNAL (triggered ()),
+  connect (_next_bookmark_action, SIGNAL (triggered ()),
            this, SLOT (request_next_bookmark ()));
 
-  connect (previous_bookmark_action, SIGNAL (triggered ()),
+  connect (_previous_bookmark_action, SIGNAL (triggered ()),
            this, SLOT (request_previous_bookmark ()));
 
-  connect (remove_bookmark_action, SIGNAL (triggered ()),
+  connect (_remove_bookmark_action, SIGNAL (triggered ()),
            this, SLOT (request_remove_bookmark ()));
 
   connect (toggle_breakpoint_action, SIGNAL (triggered ()),
            this, SLOT (request_toggle_breakpoint ()));
 
   connect (next_breakpoint_action, SIGNAL (triggered ()),
            this, SLOT (request_next_breakpoint ()));
 
   connect (previous_breakpoint_action, SIGNAL (triggered ()),
            this, SLOT (request_previous_breakpoint ()));
 
   connect (remove_all_breakpoints_action, SIGNAL (triggered ()),
            this, SLOT (request_remove_breakpoint ()));
 
-  connect (comment_selection_action, SIGNAL (triggered ()),
+  connect (_comment_selection_action, SIGNAL (triggered ()),
            this, SLOT (request_comment_selected_text ()));
 
-  connect (uncomment_selection_action, SIGNAL (triggered ()),
+  connect (_uncomment_selection_action, SIGNAL (triggered ()),
            this, SLOT (request_uncomment_selected_text ()));
 
-  connect (find_action, SIGNAL (triggered ()),
+  connect (_find_action, SIGNAL (triggered ()),
            this, SLOT (request_find ()));
 
-  connect (goto_line_action, SIGNAL (triggered ()),
+  connect (_goto_line_action, SIGNAL (triggered ()),
            this, SLOT (request_goto_line ()));
 
   connect (_mru_file_menu, SIGNAL (triggered (QAction *)),
            this, SLOT (request_mru_open_file (QAction *)));
 
   mru_menu_update ();
 
   connect (_tab_widget, SIGNAL (tabCloseRequested (int)),
@@ -1036,16 +1034,18 @@ file_editor::construct (void)
   if (settings->value ("editor/restoreSession", true).toBool ())
     {
       QStringList sessionFileNames
         = settings->value ("editor/savedSessionTabs", QStringList ()).toStringList ();
 
       for (int n = 0; n < sessionFileNames.count (); ++n)
         request_open_file (sessionFileNames.at (n));
     }
+
+    check_actions ();
 }
 
 void
 file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
 {
   _tab_widget->addTab (f, fn);
 
   // Signals from the file editor_tab
@@ -1164,16 +1164,18 @@ file_editor::add_file_editor_tab (file_e
   connect (this, SIGNAL (fetab_delete_debugger_pointer (const QWidget*, int)),
            f, SLOT (delete_debugger_pointer (const QWidget*, int)));
 
   connect (this, SIGNAL (fetab_do_breakpoint_marker (bool, const QWidget*,
                                                      int)),
            f, SLOT (do_breakpoint_marker (bool, const QWidget*, int)));
 
   _tab_widget->setCurrentWidget (f);
+
+  check_actions ();
 }
 
 void
 file_editor::copyClipboard ()
 {
   QWidget * foc_w = focusWidget ();
 
   if(foc_w && foc_w->inherits ("octave_qscintilla"))
@@ -1187,9 +1189,101 @@ file_editor::pasteClipboard ()
   QWidget * foc_w = focusWidget ();
 
   if(foc_w && foc_w->inherits ("octave_qscintilla"))
   {
     request_paste ();
   }
 }
 
+void
+file_editor::set_shortcuts (bool set)
+{
+  if (set)
+    {
+      _comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_7);
+      _uncomment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_8);
+
+      _copy_action->setShortcut (QKeySequence::Copy);
+      _cut_action->setShortcut (QKeySequence::Cut);
+      _paste_action->setShortcut (QKeySequence::Paste);
+
+      _find_action->setShortcut (QKeySequence::Find);
+      _goto_line_action->setShortcut (Qt::ControlModifier+ Qt::Key_G);
+
+      _next_bookmark_action->setShortcut (Qt::Key_F2);
+      _previous_bookmark_action->setShortcut (Qt::SHIFT + Qt::Key_F2);
+      _toggle_bookmark_action->setShortcut (Qt::Key_F7);
+
+      _print_action->setShortcut (QKeySequence::Print);
+      _run_action->setShortcut (Qt::ControlModifier+ Qt::Key_R);
+
+      _save_action->setShortcut (QKeySequence::Save);
+      _save_as_action->setShortcut (QKeySequence::SaveAs);
+      _close_action->setShortcut (QKeySequence::Close);
+
+      _redo_action->setShortcut (QKeySequence::Redo);
+      _undo_action->setShortcut (QKeySequence::Undo);
+    }
+  else
+    {
+      QKeySequence no_key = QKeySequence ();
+
+      _comment_selection_action->setShortcut (no_key);
+      _uncomment_selection_action->setShortcut (no_key);
+
+      _copy_action->setShortcut (no_key);
+      _cut_action->setShortcut (no_key);
+      _paste_action->setShortcut (no_key);
+
+      _find_action->setShortcut (no_key);
+      _goto_line_action->setShortcut (no_key);
+
+      _next_bookmark_action->setShortcut (no_key);
+      _previous_bookmark_action->setShortcut (no_key);
+      _toggle_bookmark_action->setShortcut (no_key);
+
+      _print_action->setShortcut (no_key);
+      _run_action->setShortcut (no_key);
+
+      _save_action->setShortcut (no_key);
+      _save_as_action->setShortcut (no_key);
+      _close_action->setShortcut (no_key);
+
+      _redo_action->setShortcut (no_key);
+      _undo_action->setShortcut (no_key);
+    }
+}
+
+void
+file_editor::check_actions ()
+{
+  bool  have_tabs = _tab_widget->count () > 0;
+
+  _comment_selection_action->setEnabled (have_tabs);
+  _uncomment_selection_action->setEnabled (have_tabs);
+
+  _copy_action->setEnabled (have_tabs);
+  _cut_action->setEnabled (have_tabs);
+  _paste_action->setEnabled (have_tabs);
+
+  _find_action->setEnabled (have_tabs);
+  _goto_line_action->setEnabled (have_tabs);
+
+  _next_bookmark_action->setEnabled (have_tabs);
+  _previous_bookmark_action->setEnabled (have_tabs);
+  _toggle_bookmark_action->setEnabled (have_tabs);
+
+  _print_action->setEnabled (have_tabs);
+  _run_action->setEnabled (have_tabs);
+
+  _save_action->setEnabled (have_tabs);
+  _save_as_action->setEnabled (have_tabs);
+  _close_action->setEnabled (have_tabs);
+  _close_all_action->setEnabled (have_tabs);
+  _close_others_action->setEnabled (have_tabs && _tab_widget->count () > 1);
+
+  _undo_action->setEnabled (have_tabs);
+  _redo_action->setEnabled (have_tabs);
+}
+
+
 #endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -52,16 +52,17 @@ public:
   QMenu *get_mru_menu (void) { return _mru_file_menu; }
   QMenu *debug_menu (void);
   QToolBar *toolbar (void);
 
   void set_focus (void);
   void handle_enter_debug_mode (void);
   void handle_exit_debug_mode (void);
 
+  void check_actions (void);
 signals:
 
   void fetab_settings_changed (const QSettings *settings);
   void fetab_close_request (const QWidget* ID, bool app_closing = false);
   void fetab_change_request (const QWidget* ID);
   void fetab_file_name_query (const QWidget* ID);
   // Save is a ping-pong type of communication
   void fetab_save_file (const QWidget* ID, const QString& fileName,
@@ -147,16 +148,20 @@ public slots:
   void handle_update_breakpoint_marker_request (bool insert,
                                                 const QString& file, int line);
 
   void handle_edit_file_request (const QString& file);
 
   // Tells the editor to react on changed settings.
   void notice_settings (const QSettings *settings);
 
+  // Tells the ditor to dis- or enable some shortcuts
+  void set_shortcuts (bool set_shortcuts);
+
+
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
 
 private slots:
 
   void request_open_file (const QString& fileName, int line = -1,
                           bool debug_pointer = false,
@@ -173,20 +178,46 @@ private:
 
   std::map<QString, QWidget *> editor_tab_map;
 
   QString ced;
 
   QMenuBar *_menu_bar;
   QToolBar *_tool_bar;
   QMenu *_debug_menu;
+
+  QAction *_comment_selection_action;
+  QAction *_uncomment_selection_action;
+
   QAction *_copy_action;
   QAction *_cut_action;
+  QAction *_paste_action;
+
+  QAction *_find_action;
+  QAction *_goto_line_action;
+
+  QAction *_next_bookmark_action;
+  QAction *_previous_bookmark_action;
+  QAction *_toggle_bookmark_action;
+  QAction * _remove_bookmark_action;
+
+  QAction *_print_action;
   QAction *_run_action;
+
+  QAction *_save_action;
+  QAction *_save_as_action;
+  QAction *_close_action;
+  QAction *_close_all_action;
+  QAction *_close_others_action;
+
+  QAction *_redo_action;
+  QAction *_undo_action;
+
   QTabWidget *_tab_widget;
+
   int _marker_breakpoint;
 
   enum { MaxMRUFiles = 10 };
   QMenu *_mru_file_menu;
   QAction *_mru_file_actions[MaxMRUFiles];
   QStringList _mru_files;
 
 };
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -153,17 +153,27 @@ find_dialog::find_dialog (QsciScintilla*
   main_layout->addWidget (_button_box, 0, 1);
   main_layout->addWidget (_extension, 1, 0);
   setLayout (main_layout);
 
   _extension->hide ();
   _find_next_button->setDefault (true);
   _find_result_available = false;
 
-  move (p->x() + p->frameGeometry ().width (), p->y());
+  // move to dialog to side of the parent if there is room on the desktop to do so.
+  QWidget * desktop = QApplication::desktop ();
+  int xp = p->x () + p->frameGeometry ().width ();
+  int yp=  p->y ();
+  if (desktop != 0 && sizeHint ().isValid ())
+    {
+      if (xp + sizeHint ().width () > desktop->width ())
+        xp = desktop->width () - sizeHint ().width ();
+    }
+
+  move (xp, yp);
 
 }
 
 // set text of "search from start" depending on backward search
 void
 find_dialog::handle_backward_search_changed (int backward)
 {
   if (backward)
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -72,17 +72,21 @@ main_window::main_window (QWidget *p)
     command_window (new terminal_dock_widget (this)),
     history_window (new history_dock_widget (this)),
     file_browser_window (new files_dock_widget (this)),
     doc_browser_window (new documentation_dock_widget (this)),
     editor_window (create_default_editor (this)),
     workspace_window (new workspace_view (this)),
     find_files_dlg (0),
     _octave_main_thread (0),
-    _octave_qt_link (0)
+    _octave_qt_link (0),
+    _clipboard (QApplication::clipboard ()),
+    _cmd_queue (new QStringList ()),  // no command pending
+    _cmd_processing (1),
+    _cmd_queue_mutex ()
 {
   // We have to set up all our windows, before we finally launch octave.
   construct ();
 }
 
 main_window::~main_window (void)
 {
   // Destroy the terminal first so that STDERR stream is redirected back
@@ -98,16 +102,17 @@ main_window::~main_window (void)
   delete _workspace_model;
   if (find_files_dlg) 
     {
       delete find_files_dlg;
       find_files_dlg = 0;
     }
   delete _octave_main_thread;
   delete _octave_qt_link;
+  delete _cmd_queue;
 }
 
 bool
 main_window::command_window_has_focus (void) const
 {
   return command_window->has_focus ();
 }
 
@@ -134,30 +139,30 @@ main_window::report_status_message (cons
 {
   status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request (void)
 {
   QString file =
-    QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".");
+    QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0, QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::save_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request (const QString& file_arg)
 {
   QString file = file_arg;
 
   if (file.isEmpty ())
-    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".");
+    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".", 0, 0, QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::load_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_clear_workspace_request (void)
@@ -192,56 +197,88 @@ void
 main_window::handle_clear_history_request (void)
 {
   octave_link::post_event (this, &main_window::clear_history_callback);
 }
 
 void
 main_window::execute_command_in_terminal (const QString& command)
 {
-  octave_link::post_event (this, &main_window::execute_command_callback,
-                           command.toStdString ());
-
+  queue_command (command);
   focus_command_window ();
 }
 
 void
 main_window::run_file_in_terminal (const QFileInfo& info)
 {
   octave_link::post_event (this, &main_window::run_file_callback, info);
 }
 
 void
+main_window::run_file_callback (const QFileInfo& info)
+{
+  QString dir = info.absolutePath ();
+  QString function_name = info.fileName ();
+  function_name.chop (info.suffix ().length () + 1);
+  if (octave_qt_link::file_in_path (info.absoluteFilePath ().toStdString (),
+                                    dir.toStdString ()))
+    queue_command (function_name);
+}
+
+void
+main_window::queue_command (QString command)
+{
+  _cmd_queue_mutex.lock ();
+  _cmd_queue->append (command);   // queue command
+  _cmd_queue_mutex.unlock ();
+
+  if (_cmd_processing.tryAcquire ())   // if callback is not processing, post event
+    octave_link::post_event (this, &main_window::execute_command_callback);
+}
+
+void
 main_window::handle_new_figure_request (void)
 {
   octave_link::post_event (this, &main_window::new_figure_callback);
 }
 
 void
 main_window::open_online_documentation_page (void)
 {
-  QDesktopServices::openUrl (QUrl ("http://gnu.org/software/octave/doc/interpreter"));
+  QDesktopServices::openUrl (QUrl ("http://octave.org/doc/interpreter"));
 }
 
 void
 main_window::open_bug_tracker_page (void)
 {
-  QDesktopServices::openUrl (QUrl ("http://bugs.octave.org"));
+  QDesktopServices::openUrl (QUrl ("http://octave.org/bugs.html"));
 }
 
 void
-main_window::open_octave_forge_page (void)
+main_window::open_octave_packages_page (void)
 {
-  QDesktopServices::openUrl (QUrl ("http://octave.sourceforge.net/"));
+  QDesktopServices::openUrl (QUrl ("http://octave.org/packages.html"));
 }
 
 void
 main_window::open_agora_page (void)
 {
-  QDesktopServices::openUrl (QUrl ("http://agora.octave.org/"));
+  QDesktopServices::openUrl (QUrl ("http://agora.octave.org"));
+}
+
+void
+main_window::open_contribute_page (void)
+{
+  QDesktopServices::openUrl (QUrl ("http://octave.org/donate.html"));
+}
+
+void
+main_window::open_developer_page (void)
+{
+  QDesktopServices::openUrl (QUrl ("http://octave.org/get-involved.html"));
 }
 
 void
 main_window::process_settings_dialog_request (void)
 {
   settings_dialog *settingsDialog = new settings_dialog (this);
   int change_settings = settingsDialog->exec ();
   if (change_settings == QDialog::Accepted)
@@ -349,17 +386,17 @@ main_window::change_directory (const QSt
 
   file_browser_window->update_octave_directory (dir);
 }
 
 void
 main_window::browse_for_directory (void)
 {
   QString dir
-    = QFileDialog::getExistingDirectory (this, tr ("Set working directory"));
+    = QFileDialog::getExistingDirectory (this, tr ("Set working directory"), 0, QFileDialog::DontUseNativeDialog);
 
   set_current_working_directory (dir);
 
   // FIXME -- on Windows systems, the command window freezes after the
   // previous actions.  Forcing the focus appears to unstick it.
 
   focus_command_window ();
 }
@@ -500,19 +537,21 @@ main_window::handle_update_breakpoint_ma
 
   if (cmd_focus)
     focus_command_window ();
 }
 
 void
 main_window::show_about_octave (void)
 {
-  QString message = OCTAVE_STARTUP_MESSAGE;
+  std::string message
+    = octave_name_version_copyright_copying_warranty_and_bugs (true);
 
-  QMessageBox::about (this, tr ("About Octave"), message);
+  QMessageBox::about (this, tr ("About Octave"),
+                      QString::fromStdString (message));
 }
 
 void
 main_window::closeEvent (QCloseEvent *e)
 {
   e->ignore ();
   octave_link::post_event (this, &main_window::exit_callback);
 }
@@ -537,44 +576,58 @@ main_window::read_settings (void)
       _current_directory_combo_box->addItem (curr_dirs.at (i));
     }
   emit settings_changed (settings);
 }
 
 void
 main_window::set_window_layout (QSettings *settings)
 {
+  QList<octave_dock_widget *> float_and_visible;
+
   // Restore the geometry of all dock-widgets
   foreach (octave_dock_widget *widget, dock_widget_list ())
     {
       QString name = widget->objectName ();
 
       if (! name.isEmpty ())
         {
           // If floating, make window from widget.
           bool floating = settings->value
               ("DockWidgets/" + name + "Floating", false).toBool ();
           if (floating)
             widget->make_window ();
           else if (! widget->parent ())  // should not be floating but is
-            widget->setParent (this);    // reparent
+            widget->make_widget (false); // no docking, just reparent
 
           // restore geometry
           QVariant val = settings->value (name);
           widget->restoreGeometry (val.toByteArray ());
 
           // make widget visible if desired
           bool visible = settings->value
               ("DockWidgets/" + name + "Visible", true).toBool ();
-          widget->setVisible (visible);
+          if (floating && visible)              // floating and visible
+            float_and_visible.append (widget);  // not show before main win
+          else
+            {
+              widget->make_widget ();
+              widget->setVisible (visible);       // not floating -> show
+            }
         }
     }
 
   restoreState (settings->value ("MainWindow/windowState").toByteArray ());
   restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
+  show ();  // main window is ready and can be shown (as first window)
+
+  // show floating widgets after main win to ensure "Octave" in central menu
+  foreach (octave_dock_widget *widget, float_and_visible)
+     widget->setVisible (true);
+
 }
 
 void
 main_window::write_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
   if (!settings)
     {
@@ -794,16 +847,19 @@ main_window::construct (void)
            this, SLOT (notice_settings (const QSettings *)));
 
   connect (file_browser_window, SIGNAL (load_file_signal (const QString&)),
            this, SLOT (handle_load_workspace_request (const QString&)));
 
   connect (file_browser_window, SIGNAL (find_files_signal (const QString&)),
            this, SLOT (find_files (const QString&)));
 
+  connect (this, SIGNAL (set_widget_shortcuts_signal (bool)),
+           editor_window, SLOT (set_shortcuts (bool)));
+
   connect_uiwidget_links ();
 
   setWindowTitle ("Octave");
 
   setDockOptions (QMainWindow::AnimatedDocks
                   | QMainWindow::AllowNestedDocks
                   | QMainWindow::AllowTabbedDocks);
 
@@ -851,16 +907,19 @@ main_window::construct (void)
            editor_window,
            SLOT (handle_update_breakpoint_marker_request (bool, const QString&, int)));
 #endif
 
   QDir curr_dir;
   set_current_working_directory (curr_dir.absolutePath ());
 
   octave_link::post_event (this, &main_window::resize_command_window_callback);
+
+  set_global_shortcuts (true);
+
 }
 
 void
 main_window::construct_octave_qt_link (void)
 {
   _octave_main_thread = new octave_main_thread ();
 
   _octave_qt_link = new octave_qt_link (_octave_main_thread);
@@ -902,16 +961,20 @@ main_window::construct_octave_qt_link (v
            history_window, SLOT (clear_history (void)));
 
   connect (_octave_qt_link, SIGNAL (enter_debugger_signal ()),
            this, SLOT (handle_enter_debugger ()));
 
   connect (_octave_qt_link, SIGNAL (exit_debugger_signal ()),
            this, SLOT (handle_exit_debugger ()));
 
+  connect (_octave_qt_link,
+           SIGNAL (show_preferences_signal (void)),
+           this, SLOT (process_settings_dialog_request ()));
+
 #ifdef HAVE_QSCINTILLA
   connect (_octave_qt_link,
            SIGNAL (edit_file_signal (const QString&)),
            editor_window,
            SLOT (handle_edit_file_request (const QString&)));
 #endif
 
   connect (_octave_qt_link,
@@ -924,16 +987,20 @@ main_window::construct_octave_qt_link (v
            this,
            SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
 
   connect (_octave_qt_link,
            SIGNAL (update_breakpoint_marker_signal (bool, const QString&, int)),
            this,
            SLOT (handle_update_breakpoint_marker_request (bool, const QString&, int)));
 
+  connect (_octave_qt_link,
+           SIGNAL (show_doc_signal (const QString &)),
+           this, SLOT (handle_show_doc (const QString &)));
+
   connect (_workspace_model,
            SIGNAL (rename_variable (const QString&, const QString&)),
            this,
            SLOT (handle_rename_variable_request (const QString&,
                                                  const QString&)));
 
   _octave_qt_link->execute_interpreter ();
 
@@ -961,16 +1028,18 @@ main_window::construct_file_menu (QMenuB
 {
   QMenu *file_menu = p->addMenu (tr ("&File"));
 
   construct_new_menu (file_menu);
 
   _open_action
     = file_menu->addAction (QIcon (":/actions/icons/fileopen.png"),
                             tr ("Open..."));
+  _open_action->setShortcutContext (Qt::ApplicationShortcut);
+
 
 #ifdef HAVE_QSCINTILLA
   file_menu->addMenu (editor_window->get_mru_menu ());
 #endif
 
   file_menu->addSeparator ();
 
   QAction *load_workspace_action
@@ -982,45 +1051,46 @@ main_window::construct_file_menu (QMenuB
   file_menu->addSeparator ();
 
   QAction *preferences_action
     = file_menu->addAction (QIcon (":/actions/icons/configure.png"),
                             tr ("Preferences..."));
 
   file_menu->addSeparator ();
 
-  QAction *exit_action = file_menu->addAction (tr ("Exit"));
-  exit_action->setShortcut (QKeySequence::Quit);
+  _exit_action = file_menu->addAction (tr ("Exit"));
+  _exit_action->setShortcutContext (Qt::ApplicationShortcut);
 
   connect (preferences_action, SIGNAL (triggered ()),
            this, SLOT (process_settings_dialog_request ()));
 
 #ifdef HAVE_QSCINTILLA
   connect (_open_action, SIGNAL (triggered ()),
            editor_window, SLOT (request_open_file ()));
 #endif
 
   connect (load_workspace_action, SIGNAL (triggered ()),
            this, SLOT (handle_load_workspace_request ()));
 
   connect (save_workspace_action, SIGNAL (triggered ()),
            this, SLOT (handle_save_workspace_request ()));
 
-  connect (exit_action, SIGNAL (triggered ()),
+  connect (_exit_action, SIGNAL (triggered ()),
            this, SLOT (close ()));
 }
 
 void
 main_window::construct_new_menu (QMenu *p)
 {
   QMenu *new_menu = p->addMenu (tr ("New"));
 
   _new_script_action
     = new_menu->addAction (QIcon (":/actions/icons/filenew.png"),
                            tr ("Script"));
+  _new_script_action->setShortcutContext (Qt::ApplicationShortcut);
 
   QAction *new_function_action = new_menu->addAction (tr ("Function"));
   new_function_action->setEnabled (true);
 
   QAction *new_figure_action = new_menu->addAction (tr ("Figure"));
   new_figure_action->setEnabled (true);
 
 #ifdef HAVE_QSCINTILLA
@@ -1046,51 +1116,58 @@ main_window::construct_edit_menu (QMenuB
     = edit_menu->addAction (QIcon (":/actions/icons/undo.png"), tr ("Undo"));
   _undo_action->setShortcut (QKeySequence::Undo);
 
   edit_menu->addSeparator ();
 
   _copy_action
     = edit_menu->addAction (QIcon (":/actions/icons/editcopy.png"),
                             tr ("Copy"), this, SLOT (copyClipboard ()));
-  _copy_action->setShortcut (ctrl_shift + Qt::Key_C);
+  _copy_action->setShortcut (QKeySequence::Copy);
+
 
   _paste_action
     = edit_menu->addAction (QIcon (":/actions/icons/editpaste.png"),
                             tr ("Paste"), this, SLOT (pasteClipboard ()));
-  _paste_action->setShortcut (ctrl_shift + Qt::Key_V);
+  _paste_action->setShortcut (QKeySequence::Paste);
+
+  _clear_clipboard_action
+    = edit_menu->addAction (tr ("Clear Clipboard"), this,
+                            SLOT (clear_clipboard ()));
 
   edit_menu->addSeparator ();
 
-  QAction *find_files_action
-    = edit_menu->addAction (tr ("Find Files..."));
-  find_files_action->setShortcut (ctrl_shift + Qt::Key_F);
+  _find_files_action = edit_menu->addAction (tr ("Find Files..."));
 
   edit_menu->addSeparator ();
 
   QAction *clear_command_window_action
     = edit_menu->addAction (tr ("Clear Command Window"));
 
   QAction *clear_command_history
     = edit_menu->addAction(tr ("Clear Command History"));
 
   QAction *clear_workspace_action
     = edit_menu->addAction (tr ("Clear Workspace"));
 
-  connect (find_files_action, SIGNAL (triggered()),
+  connect (_find_files_action, SIGNAL (triggered()),
            this, SLOT (find_files ()));
 
   connect (clear_command_window_action, SIGNAL (triggered ()),
            this, SLOT (handle_clear_command_window_request ()));
 
   connect (clear_command_history, SIGNAL (triggered ()),
            this, SLOT (handle_clear_history_request ()));
 
   connect (clear_workspace_action, SIGNAL (triggered ()),
            this, SLOT (handle_clear_workspace_request ()));
+
+  connect (_clipboard, SIGNAL (changed (QClipboard::Mode)),
+           this, SLOT (clipboard_has_changed (QClipboard::Mode)));
+  clipboard_has_changed (QClipboard::Clipboard);
 }
 
 QAction *
 main_window::construct_debug_menu_item (const char *icon_file,
                                         const QString& item,
                                         const QKeySequence& key)
 {
   QAction *action = _debug_menu->addAction (QIcon (icon_file), item);
@@ -1283,36 +1360,48 @@ main_window::construct_help_menu (QMenuB
 
   construct_documentation_menu (help_menu);
 
   help_menu->addSeparator ();
 
   QAction *report_bug_action
     = help_menu->addAction (tr ("Report Bug"));
 
-  QAction *octave_forge_action
-    = help_menu->addAction (tr ("Visit Octave Forge"));
+  QAction *octave_packages_action
+    = help_menu->addAction (tr ("Octave Packages"));
 
   QAction *agora_action
-    = help_menu->addAction (tr ("Visit Agora"));
+    = help_menu->addAction (tr ("Share Code"));
+
+  QAction *contribute_action
+    = help_menu->addAction (tr ("Contribute to Octave"));
+
+  QAction *developer_action
+    = help_menu->addAction (tr ("Octave Developer Resources"));
 
   help_menu->addSeparator ();
 
   QAction *about_octave_action
     = help_menu->addAction (tr ("About Octave"));
 
   connect (report_bug_action, SIGNAL (triggered ()),
            this, SLOT (open_bug_tracker_page ()));
 
-  connect (octave_forge_action, SIGNAL (triggered ()),
-           this, SLOT (open_octave_forge_page ()));
+  connect (octave_packages_action, SIGNAL (triggered ()),
+           this, SLOT (open_octave_packages_page ()));
 
   connect (agora_action, SIGNAL (triggered ()),
            this, SLOT (open_agora_page ()));
 
+  connect (contribute_action, SIGNAL (triggered ()),
+           this, SLOT (open_contribute_page ()));
+
+  connect (developer_action, SIGNAL (triggered ()),
+           this, SLOT (open_developer_page ()));
+
   connect (about_octave_action, SIGNAL (triggered ()),
            this, SLOT (show_about_octave ()));
 }
 
 void
 main_window::construct_documentation_menu (QMenu *p)
 {
   QMenu *documentation_menu = p->addMenu (tr ("Documentation"));
@@ -1438,39 +1527,44 @@ main_window::resize_command_window_callb
 
 void
 main_window::clear_history_callback (void)
 {
   Fhistory (ovl ("-c"));
 }
 
 void
-main_window::execute_command_callback (const std::string& command)
+main_window::execute_command_callback ()
 {
-  std::string pending_input = command_editor::get_current_line ();
+  bool repost = false;          // flag for reposting event for this callback
 
-  command_editor::set_initial_input (pending_input);
-
-  command_editor::replace_line (command);
-  command_editor::redisplay ();
+  if (!_cmd_queue->isEmpty ())  // list can not be empty here, just to make sure
+    {
+      std::string pending_input = command_editor::get_current_line ();
+      command_editor::set_initial_input (pending_input);
 
-  // We are executing inside the command editor event loop.  Force
-  // the current line to be returned for processing.
-  command_editor::interrupt ();
-}
+      _cmd_queue_mutex.lock (); // critical path
+      std::string command = _cmd_queue->takeFirst ().toStdString ();
+      if (_cmd_queue->isEmpty ())
+        _cmd_processing.release ();  // command queue empty, processing will stop
+      else
+        repost = true;          // not empty, repost at end
+      _cmd_queue_mutex.unlock ();
+
+      command_editor::replace_line (command);
 
-void
-main_window::run_file_callback (const QFileInfo& info)
-{
-  QString dir = info.absolutePath ();
-  QString function_name = info.fileName ();
-  function_name.chop (info.suffix ().length () + 1);
-  if (octave_qt_link::file_in_path (info.absoluteFilePath ().toStdString (),
-                                    dir.toStdString ()))
-    execute_command_callback (function_name.toStdString ());
+      command_editor::redisplay ();
+      // We are executing inside the command editor event loop.  Force
+      // the current line to be returned for processing.
+      command_editor::interrupt ();
+    }
+
+  if (repost)  // queue not empty, so repost event for further processing
+    octave_link::post_event (this, &main_window::execute_command_callback);
+
 }
 
 void
 main_window::new_figure_callback (void)
 {
   Fbuiltin (ovl ("figure"));
   Fdrawnow ();
 }
@@ -1566,9 +1660,69 @@ main_window::find_files(const QString &s
 }
 
 void 
 main_window::find_files_finished(int)
 {
 
 }
 
+void
+main_window::set_global_shortcuts (bool set_shortcuts)
+{
+  if (set_shortcuts)
+    {
 
+      _open_action->setShortcut (QKeySequence::Open);
+      _new_script_action->setShortcut (QKeySequence::New);
+
+      _exit_action->setShortcut (QKeySequence::Quit);
+
+      _find_files_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_F);
+
+    }
+  else
+    {
+
+      QKeySequence no_key = QKeySequence ();
+
+      _open_action->setShortcut (no_key);
+      _new_script_action->setShortcut (no_key);
+
+      _exit_action->setShortcut (no_key);
+
+      _find_files_action->setShortcut (no_key);
+
+    }
+
+  emit set_widget_shortcuts_signal (set_shortcuts);
+}
+
+void
+main_window::handle_show_doc (const QString& file)
+{
+  doc_browser_window->setVisible (true);
+  emit show_doc_signal (file);
+}
+
+void
+main_window::clipboard_has_changed (QClipboard::Mode cp_mode)
+{
+  if (cp_mode == QClipboard::Clipboard)
+    {
+      if (_clipboard->text ().isEmpty ())
+        {
+          _paste_action->setEnabled (false);
+          _clear_clipboard_action->setEnabled (false);
+        }
+      else
+        {
+          _paste_action->setEnabled (true);
+          _clear_clipboard_action->setEnabled (true);
+        }
+    }
+}
+
+void
+main_window::clear_clipboard ()
+{
+  _clipboard->clear (QClipboard::Clipboard);
+}
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include <QMdiArea>
 #include <QStatusBar>
 #include <QToolBar>
 #include <QQueue>
 #include <QMdiSubWindow>
 #include <QCloseEvent>
 #include <QToolButton>
 #include <QComboBox>
+#include <QSemaphore>
 
 // Editor includes
 #include "file-editor-interface.h"
 
 // QTerminal includes
 #include "QTerminal.h"
 
 // Own includes
@@ -77,40 +78,46 @@ public:
 
   void focus_command_window (void);
 
 signals:
   void settings_changed (const QSettings *);
   void new_file_signal (const QString&);
   void open_file_signal (const QString&);
 
+  void show_doc_signal (const QString&);
+
   void insert_debugger_pointer_signal (const QString& file, int line);
   void delete_debugger_pointer_signal (const QString& file, int line);
   void update_breakpoint_marker_signal (bool insert, const QString& file,
                                         int line);
 
   void copyClipboard_signal (void);
   void pasteClipboard_signal (void);
 
+  void set_widget_shortcuts_signal (bool);
+
 public slots:
   void report_status_message (const QString& statusMessage);
   void handle_save_workspace_request (void);
   void handle_load_workspace_request (const QString& file = QString ());
   void handle_clear_command_window_request (void);
   void handle_clear_workspace_request (void);
   void handle_clear_history_request (void);
   void handle_rename_variable_request (const QString& old_name,
                                        const QString& new_name);
   void handle_undo_request (void);
   void new_file (const QString& commands = QString ());
   void open_file (const QString& file_name = QString ());
   void open_online_documentation_page (void);
   void open_bug_tracker_page (void);
-  void open_octave_forge_page (void);
+  void open_octave_packages_page (void);
   void open_agora_page (void);
+  void open_contribute_page (void);
+  void open_developer_page (void);
   void process_settings_dialog_request (void);
   void show_about_octave (void);
   void notice_settings (const QSettings *settings);
   void prepare_to_exit (void);
   void exit (int status);
   void reset_windows (void);
 
   void change_directory (const QString& dir);
@@ -164,19 +171,30 @@ public slots:
                                   const QFloatList&, const QFloatList&,
                                   const QStringList&);
 
   void handle_create_filedialog (const QStringList &filters, 
                                  const QString& title, const QString& filename, 
                                  const QString &dirname,
                                  const QString& multimode);
 
+  void handle_show_doc (const QString &file);
+
   // find files dialog 
   void find_files(const QString &startdir=QDir::currentPath());
   void find_files_finished(int);
+
+  // setting global shortcuts
+  void set_global_shortcuts (bool enable);
+
+  // handling the clipboard
+  void clipboard_has_changed (QClipboard::Mode);
+  void clear_clipboard ();
+
+
 protected:
   void closeEvent (QCloseEvent * closeEvent);
 
 private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
@@ -213,17 +231,17 @@ private:
   void clear_command_window_callback (void);
 
   void resize_command_window_callback (void);
 
   void clear_workspace_callback (void);
 
   void clear_history_callback (void);
 
-  void execute_command_callback (const std::string& command);
+  void execute_command_callback ();
   void run_file_callback (const QFileInfo& info);
 
   void new_figure_callback (void);
 
   void change_directory_callback (const std::string& directory);
 
   void debug_continue_callback (void);
 
@@ -232,17 +250,18 @@ private:
   void debug_step_over_callback (void);
 
   void debug_step_out_callback (void);
 
   void debug_quit_callback (void);
 
   void exit_callback (void);
 
-  // Data models.
+  void queue_command (QString command);  // Data models.
+
   workspace_model *_workspace_model;
 
   // Toolbars.
   QStatusBar *status_bar;
 
   // Subwindows.
   terminal_dock_widget *command_window;
   history_dock_widget *history_window;
@@ -252,17 +271,19 @@ private:
   workspace_view *workspace_window;
   QList<octave_dock_widget *> dock_widget_list ()
   {
     QList<octave_dock_widget *> list = QList<octave_dock_widget *> ();
     list.append (static_cast<octave_dock_widget *> (command_window));
     list.append (static_cast<octave_dock_widget *> (history_window));
     list.append (static_cast<octave_dock_widget *> (file_browser_window));
     list.append (static_cast<octave_dock_widget *> (doc_browser_window));
+#ifdef HAVE_QSCINTILLA
     list.append (static_cast<octave_dock_widget *> (editor_window));
+#endif
     list.append (static_cast<octave_dock_widget *> (workspace_window));
     return list;
   }
 
   QToolBar *_main_tool_bar;
   QMenu *_debug_menu;
 
   QAction *_debug_continue;
@@ -271,29 +292,40 @@ private:
   QAction *_debug_step_out;
   QAction *_debug_quit;
 
   QAction *_new_script_action;
   QAction *_open_action;
 
   QAction *_copy_action;
   QAction *_paste_action;
+  QAction *_clear_clipboard_action;
   QAction *_undo_action;
 
+  QAction *_find_files_action;
+  QAction *_exit_action;
+
   // Toolbars.
   QComboBox *_current_directory_combo_box;
   static const int current_directory_width = 300;
   static const int current_directory_max_visible = 16;
   static const int current_directory_max_count = 16;
   QLineEdit *_current_directory_line_edit;
 
   // Find files dialog
   find_files_dialog * find_files_dlg;
 
   octave_main_thread *_octave_main_thread;
 
   octave_qt_link *_octave_qt_link;
 
+  QClipboard *_clipboard;
+
   // Flag for closing whole application.
   bool _closing;
+
+  // semaphore to synchronize execution signals and related callback
+  QStringList *_cmd_queue;
+  QSemaphore   _cmd_processing;
+  QMutex       _cmd_queue_mutex;
 };
 
 #endif // MAINWINDOW_H
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -50,25 +50,27 @@ octave_dock_widget::octave_dock_widget (
   _dock_action = new QAction
                    (QIcon (":/actions/icons/widget-undock.png"), "", this);
   _dock_action-> setToolTip (tr ("Undock widget"));
   connect (_dock_action, SIGNAL (triggered (bool)),
            this, SLOT (change_floating (bool)));
   QToolButton *dock_button = new QToolButton (this);
   dock_button->setDefaultAction (_dock_action);
   dock_button->setFocusPolicy(Qt::NoFocus);
+  dock_button->setIconSize(QSize(12,12));
 
   QAction *close_action = new QAction
                    (QIcon (":/actions/icons/widget-close.png"), "", this );
   close_action-> setToolTip (tr ("Hide widget"));
   connect (close_action, SIGNAL (triggered (bool)),
            this, SLOT (change_visibility (bool)));
   QToolButton *close_button = new QToolButton (this);
   close_button->setDefaultAction (close_action);
   close_button->setFocusPolicy(Qt::NoFocus);
+  close_button->setIconSize(QSize(12,12));
 
   QHBoxLayout *h_layout = new QHBoxLayout ();
   h_layout->addStretch (100);
   h_layout->addWidget (dock_button);
   h_layout->addWidget (close_button);
   h_layout->setSpacing (0);
   h_layout->setContentsMargins (6,0,0,0);
 
@@ -147,33 +149,37 @@ octave_dock_widget::make_window ()
 
   // restore the last geometry when floating
   restoreGeometry (settings->value
           ("DockWidgets/" + objectName ()+"_floating_geometry").toByteArray ());
 }
 
 // dock the widget
 void
-octave_dock_widget::make_widget ()
+octave_dock_widget::make_widget (bool dock)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // save last floating geometry
   settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
                       saveGeometry ());
   settings->sync ();
 
-  // add widget to last saved docking area
-  int area = settings->value ("DockWidgets/" + objectName () + "_dock_area",
-                               Qt::TopDockWidgetArea).toInt ();
-  _parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
+  if (dock)
+    { // add widget to last saved docking area (dock=true is default)
+      int area = settings->value ("DockWidgets/" + objectName () + "_dock_area",
+                                   Qt::TopDockWidgetArea).toInt ();
+      _parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
 
-  // FIXME: restoreGeometry is ignored for docked widgets and its child widget
-  // restoreGeometry (settings->value
-  //        ("DockWidgets/" + objectName ()).toByteArray ());
+      // FIXME: restoreGeometry is ignored for docked widgets and its child widget
+      // restoreGeometry (settings->value
+      //        ("DockWidgets/" + objectName ()).toByteArray ());
+    }
+  else  // only reparent, no docking
+    setParent (_parent);
 
   // adjust the (un)dock icon
   _dock_action->setIcon (QIcon (":/actions/icons/widget-undock.png"));
   _dock_action->setToolTip (tr ("Undock widget"));
 }
 
 // slot for (un)dock action
 void
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -35,17 +35,17 @@ class octave_dock_widget : public QDockW
 
 public:
 
   octave_dock_widget (QWidget *p = 0);
   virtual ~octave_dock_widget ();
 
   virtual void connect_visibility_changed (void);
   void make_window (void);
-  void make_widget (void);
+  void make_widget (bool dock=true);
   void set_title (const QString&);
 
 signals:
 
   /** Custom signal that tells whether a user has clicked away
    *  that dock widget, i.e the active dock widget has
    *  changed. */
   void active_changed (bool active);
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -33,18 +33,21 @@ along with Octave; see the file COPYING.
 #include <fcntl.h>
 
 #if defined (HAVE_SYS_IOCTL_H)
 #include <sys/ioctl.h>
 #endif
 
 #include "lo-utils.h"
 #include "oct-env.h"
+#include "oct-syscalls.h"
 #include "syswait.h"
 
+#include "sighandlers.h"
+
 #include "welcome-wizard.h"
 #include "resource-manager.h"
 #include "main-window.h"
 #include "octave-gui.h"
 
 // Dissociate from the controlling terminal, if any.
 
 static void
@@ -68,72 +71,75 @@ dissociate_terminal (void)
           std::cerr << "setsid error" << std::endl;
           exit (1);
         }
     }
   else
     {
       // Parent
 
-      // FIXME -- we should catch signals and pass them on to the child
-      // process in some way, possibly translating SIGINT to SIGTERM.
+      install_gui_driver_signal_handlers (pid);
 
       int status;
 
       waitpid (pid, &status, 0);
 
       exit (octave_wait::ifexited (status)
             ? octave_wait::exitstatus (status) : 127);
     }
 
 #endif
 }
 
 int
-octave_start_gui (int argc, char *argv[])
+octave_start_gui (int argc, char *argv[], bool fork)
 {
-  dissociate_terminal ();
+  if (fork)
+    dissociate_terminal ();
 
   QApplication application (argc, argv);
 
+  // install translators for the gui and qt text
+  QTranslator gui_tr, qt_tr, qsci_tr;
+  resource_manager::config_translators (&qt_tr,&qsci_tr,&gui_tr);
+  application.installTranslator (&qt_tr);
+  application.installTranslator (&qsci_tr);
+  application.installTranslator (&gui_tr);
+
   while (true)
     {
       if (resource_manager::is_first_run ())
         {
           welcome_wizard welcomeWizard;
           welcomeWizard.exec ();
           resource_manager::reload_settings ();
         }
       else
         {
-          // install translators for the gui and qt text
-          QTranslator gui_tr, qt_tr, qsci_tr;
-          resource_manager::config_translators (&qt_tr,&qsci_tr,&gui_tr);
-          application.installTranslator (&qt_tr);
-          application.installTranslator (&qsci_tr);
-          application.installTranslator (&gui_tr);
-
           // update network-settings
           resource_manager::update_network_settings ();
 
 #if ! defined (__WIN32__) || defined (__CYGWIN__)
           // If we were started from a launcher, TERM might not be
           // defined, but we provide a terminal with xterm
           // capabilities.
 
           std::string term = octave_env::getenv ("TERM");
 
           if (term.empty ())
             octave_env::putenv ("TERM", "xterm");
+#else
+          std::string term = octave_env::getenv ("TERM");
+
+          if (term.empty ())
+            octave_env::putenv ("TERM", "cygwin");
 #endif
 
           // create main window, read settings, and show window
           main_window w;
-          w.read_settings ();  // get widget settings after construction
-                               // but before showing
-          w.show ();
+          w.read_settings ();  // get widget settings and window layout
           w.focus_command_window ();
           w.connect_visibility_changed (); // connect signals for changes in
                                            // visibility not before w is shown
           return application.exec ();
         }
     }
 }
diff --git a/libgui/src/octave-gui.h b/libgui/src/octave-gui.h
--- a/libgui/src/octave-gui.h
+++ b/libgui/src/octave-gui.h
@@ -18,11 +18,12 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_octave_gui_h)
 #define octave_octave_gui_h 1
 
-extern OCTGUI_API int octave_start_gui (int argc, char **argv);
+extern OCTGUI_API int octave_start_gui (int argc, char **argv,
+                                        bool fork = true);
 
 #endif
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -486,8 +486,22 @@ octave_qt_link::file_in_path (const std:
 
         default:
           break;
         }
     }
 
   return ok;
 }
+
+void
+octave_qt_link::do_show_preferences ()
+{
+  emit show_preferences_signal ();
+}
+
+void
+octave_qt_link::do_show_doc (const std::string& file)
+{
+  emit show_doc_signal (QString::fromStdString (file));
+}
+
+
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -116,16 +116,19 @@ public:
 
   void do_update_breakpoint (bool insert, const std::string& file, int line);
 
   void do_set_default_prompts (std::string& ps1, std::string& ps2,
                                std::string& ps4);
 
   static bool file_in_path (const std::string& file, const std::string& dir);
 
+  void do_show_preferences (void);
+
+  void do_show_doc (const std::string& file);
 private:
 
   // No copying!
 
   octave_qt_link (const octave_qt_link&);
 
   octave_qt_link& operator = (const octave_qt_link&);
 
@@ -161,11 +164,15 @@ signals:
   void enter_debugger_signal (void);
   void exit_debugger_signal (void);
 
   void update_breakpoint_marker_signal (bool insert, const QString& file,
                                         int line);
 
   void insert_debugger_pointer_signal (const QString&, int);
   void delete_debugger_pointer_signal (const QString&, int);
+
+  void show_preferences_signal (void);
+
+  void show_doc_signal (const QString &file);
 };
 
 #endif
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -174,19 +174,39 @@ parser::search_node (const QString& node
 
   return QString ();
 }
 
 QString
 parser::get_next_node (QIODevice *io)
 {
   QString text;
+  QByteArray line, line_buffer;
+  char c;
+  int i;
+
   while (!io->atEnd ())
     {
-      QByteArray line = io->readLine ();
+      io->getChar (&c);
+      if (c)
+        { // first char is not equal 0
+          io->ungetChar (c);
+          line = io->readLine ();
+        }
+      else
+        { // 0 was read -> image -> text length changes
+          line_buffer = io->readLine ();  // image tag that is not needed
+          line = io->readLine ();         // firsts line of text message
+          for (i=1; i<line_buffer.size ()+6; i++)  // correct the size
+            line.insert (line.size ()-1,QByteArray(" "));   // by adding blanks
+        }
+
+      if (line.at (0) == '"' && line.size () == 5)  // end of image construct
+        line = " ";
+
       if (line.at(0) == 31)
         {
           break;
         }
       else
         {
           text.append (line);
         }
@@ -336,17 +356,19 @@ parser::node_text_to_html (const QString
       QString text2 = text.mid (anchorPos);
 
       int n = text1.indexOf ("\n");
       text1.remove (0, n);
 
       info_to_html (text1);
       info_to_html (text2);
 
-      text = text1 + "<a name='" + anchor + "' /><img src=':/actions/icons/stop.png'>" + text2;
+      text = text1 + "<a name='" + anchor
+                   + "'/><img src=':/actions/icons/redled.png'><br>&nbsp;"
+                   + text2;
     }
   else
     {
       int n = text.indexOf ("\n");
       text.remove (0, n);
       info_to_html (text);
     }
 
@@ -366,17 +388,19 @@ parser::node_text_to_html (const QString
 
 
   text.prepend ("<hr>\n<pre>");
   text.append ("</pre>\n<hr><hr>\n");
   text.prepend (navigationLinks);
   text.append (navigationLinks);
   text.prepend ("<html><body>\n");
   text.append ("</body></html>\n");
+
   return text;
+
 }
 
 void
 parser::parse_info_map ()
 {
   QRegExp re ("(Node|Ref): ([^\\0177]+)\\0177(\\d+)\n");
   QRegExp re_files ("([^:]+): (\\d+)\n");
   int foundCount = 0;
@@ -587,8 +611,29 @@ parser::global_search (const QString& te
         }
       io->close ();
       delete io;
     }
 
   results.append ("</body></html>");
   return results;
 }
+
+QString 
+parser::find_ref (const QString &ref_name)
+{
+  QString text = "";
+
+  QHash<QString,node_position>::iterator it;
+  for (it=_ref_map.begin ();it!=_ref_map.end ();++it)
+    {
+      QString k = it.key ();
+      node_position p = it.value ();
+
+      if (k == "XREF" + ref_name)
+        {
+          // found ref, so return its name
+          text = "XREF" + ref_name;
+        }
+    }
+  return text;
+}
+
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -52,16 +52,18 @@ class parser
 
 public:
   parser (QObject *parent = 0);
   void set_info_path (const QString& _info_path);
   QString get_info_path ();
   QString search_node (const QString& node);
   QString global_search (const QString& text, int maxFounds);
 
+  QString find_ref (const QString &name);
+
   /** Checks if this node is reference. If node is reference, it will be returned its position
     * in text, else  it will be returned -1.
     */
   int is_ref (const QString& node);
 
   /**Translates text of node to Html. If anchorPos is not -1, then anchor is inserted in that
     * position.
     */
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -88,16 +88,17 @@ webinfo::webinfo (QWidget *p)
   connect (_tab_bar, SIGNAL (currentChanged (int)), this, SLOT (current_tab_changed (int)));
   connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
   connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
 
   set_info_path (QString::fromStdString (Vinfo_file));
+
 }
 
 void
 webinfo::set_info_path (const QString& info_path)
 {
   _parser.set_info_path (info_path);
   load_node ("Top");
 }
@@ -185,16 +186,34 @@ webinfo::close_tab (int index)
       _stacked_widget->removeWidget (w);
       delete w;
 
       _tab_bar->removeTab (index);
     }
 }
 
 void
+webinfo::load_ref (const QString &ref_name)
+{
+  QString text = _parser.find_ref (ref_name);
+  if (text.length () > 0)
+    {
+      load_node (text);
+    }
+  else
+    {
+      // not found
+     load_node("Top");
+    }
+
+   if (_text_browser)
+     _text_browser->setFocus(); 
+}
+
+void
 webinfo::search ()
 {
   if (_search_check_box->isChecked ())
     {
       // Global search
       QString results = _parser.global_search (_search_line_edit->text (), 5);
       _text_browser=addNewTab ("Results for: " + _search_line_edit->text ());
       _text_browser->setHtml (results);
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -35,16 +35,18 @@ along with Octave; see the file COPYING.
 
 class webinfo : public QWidget
 {
   Q_OBJECT
 public:
   webinfo (QWidget *parent = 0);
   void set_info_path (const QString& info_path);
   void load_node (const QString& node_name);
+ 
+  void load_ref (const QString &ref_name); 
 
 public slots:
   void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab (int index);
   void search ();
   void zoom_in ();
   void zoom_out ();
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -148,23 +148,38 @@ resource_manager::do_get_default_setting
 }
 
 QString
 resource_manager::do_get_home_path (void) const
 {
   return home_path;
 }
 
+QString
+resource_manager::do_get_settings_path (void)
+{
+  QDesktopServices desktopServices;
+  home_path = desktopServices.storageLocation (QDesktopServices::HomeLocation);
+  QString settings_path = home_path + "/.config/octave/";
+  return settings_path;
+}
+
+QString
+resource_manager::do_get_settings_file (void)
+{
+  return do_get_settings_path ()  + "qt-settings";
+}
+
 void
 resource_manager::do_reload_settings (void)
 {
   QDesktopServices desktopServices;
   home_path = desktopServices.storageLocation (QDesktopServices::HomeLocation);
-  QString settings_path = home_path + "/.config/octave/";
-  QString settings_file = settings_path + "qt-settings";
+  QString settings_path = do_get_settings_path ();
+  QString settings_file = do_get_settings_file ();
 
   if (!QFile::exists (settings_file))
     {
       QDir("/").mkpath (settings_path);
       QFile::copy (default_qt_settings_file (), settings_file);
       first_run = true;
     }
   else
@@ -230,1569 +245,8 @@ resource_manager::terminal_color_names (
   return QTerminal::color_names ();
 }
 
 QList<QColor>
 resource_manager::terminal_default_colors (void)
 {
   return QTerminal::default_colors ();
 }
-
-const char*
-resource_manager::octave_keywords (void)
-{
-  return
-      ".nargin. "
-      "EDITOR "
-      "EXEC_PATH "
-      "F_DUPFD "
-      "F_GETFD "
-      "F_GETFL "
-      "F_SETFD "
-      "F_SETFL "
-      "I "
-      "IMAGE_PATH "
-      "Inf "
-      "J "
-      "NA "
-      "NaN "
-      "OCTAVE_HOME "
-      "OCTAVE_VERSION "
-      "O_APPEND "
-      "O_ASYNC "
-      "O_CREAT "
-      "O_EXCL "
-      "O_NONBLOCK "
-      "O_RDONLY "
-      "O_RDWR "
-      "O_SYNC "
-      "O_TRUNC "
-      "O_WRONLY "
-      "PAGER "
-      "PAGER_FLAGS "
-      "PS1 "
-      "PS2 "
-      "PS4 "
-      "P_tmpdir "
-      "SEEK_CUR "
-      "SEEK_END "
-      "SEEK_SET "
-      "SIG "
-      "S_ISBLK "
-      "S_ISCHR "
-      "S_ISDIR "
-      "S_ISFIFO "
-      "S_ISLNK "
-      "S_ISREG "
-      "S_ISSOCK "
-      "WCONTINUE "
-      "WCOREDUMP "
-      "WEXITSTATUS "
-      "WIFCONTINUED "
-      "WIFEXITED "
-      "WIFSIGNALED "
-      "WIFSTOPPED "
-      "WNOHANG "
-      "WSTOPSIG "
-      "WTERMSIG "
-      "WUNTRACED "
-      "__accumarray_max__ "
-      "__accumarray_min__ "
-      "__accumarray_sum__ "
-      "__accumdim_sum__ "
-      "__all_opts__ "
-      "__builtins__ "
-      "__calc_dimensions__ "
-      "__contourc__ "
-      "__current_scope__ "
-      "__delaunayn__ "
-      "__dispatch__ "
-      "__display_tokens__ "
-      "__dsearchn__ "
-      "__dump_symtab_info__ "
-      "__end__ "
-      "__error_text__ "
-      "__finish__ "
-      "__fltk_ginput__ "
-      "__fltk_print__ "
-      "__fltk_uigetfile__ "
-      "__ftp__ "
-      "__ftp_ascii__ "
-      "__ftp_binary__ "
-      "__ftp_close__ "
-      "__ftp_cwd__ "
-      "__ftp_delete__ "
-      "__ftp_dir__ "
-      "__ftp_mget__ "
-      "__ftp_mkdir__ "
-      "__ftp_mode__ "
-      "__ftp_mput__ "
-      "__ftp_pwd__ "
-      "__ftp_rename__ "
-      "__ftp_rmdir__ "
-      "__get__ "
-      "__glpk__ "
-      "__gnuplot_drawnow__ "
-      "__gnuplot_get_var__ "
-      "__gnuplot_ginput__ "
-      "__gnuplot_has_feature__ "
-      "__gnuplot_open_stream__ "
-      "__gnuplot_print__ "
-      "__gnuplot_version__ "
-      "__go_axes__ "
-      "__go_axes_init__ "
-      "__go_close_all__ "
-      "__go_delete__ "
-      "__go_draw_axes__ "
-      "__go_draw_figure__ "
-      "__go_execute_callback__ "
-      "__go_figure__ "
-      "__go_figure_handles__ "
-      "__go_handles__ "
-      "__go_hggroup__ "
-      "__go_image__ "
-      "__go_line__ "
-      "__go_patch__ "
-      "__go_surface__ "
-      "__go_text__ "
-      "__go_uimenu__ "
-      "__gud_mode__ "
-      "__image_pixel_size__ "
-      "__init_fltk__ "
-      "__isa_parent__ "
-      "__keywords__ "
-      "__lexer_debug_flag__ "
-      "__lin_interpn__ "
-      "__list_functions__ "
-      "__magick_finfo__ "
-      "__magick_format_list__ "
-      "__magick_read__ "
-      "__magick_write__ "
-      "__makeinfo__ "
-      "__marching_cube__ "
-      "__next_line_color__ "
-      "__next_line_style__ "
-      "__operators__ "
-      "__parent_classes__ "
-      "__parser_debug_flag__ "
-      "__pathorig__ "
-      "__pchip_deriv__ "
-      "__plt_get_axis_arg__ "
-      "__print_parse_opts__ "
-      "__qp__ "
-      "__request_drawnow__ "
-      "__sort_rows_idx__ "
-      "__strip_html_tags__ "
-      "__token_count__ "
-      "__unimplemented__ "
-      "__varval__ "
-      "__version_info__ "
-      "__voronoi__ "
-      "__which__ "
-      "abs "
-      "accumarray "
-      "accumdim "
-      "acos "
-      "acosd "
-      "acosh "
-      "acot "
-      "acotd "
-      "acoth "
-      "acsc "
-      "acscd "
-      "acsch "
-      "add_input_event_hook "
-      "addlistener "
-      "addpath "
-      "addproperty "
-      "addtodate "
-      "airy "
-      "all "
-      "allchild "
-      "allow_noninteger_range_as_index "
-      "amd "
-      "ancestor "
-      "and "
-      "angle "
-      "anova "
-      "ans "
-      "any "
-      "arch_fit "
-      "arch_rnd "
-      "arch_test "
-      "area "
-      "arg "
-      "argnames "
-      "argv "
-      "arma_rnd "
-      "arrayfun "
-      "asctime "
-      "asec "
-      "asecd "
-      "asech "
-      "asin "
-      "asind "
-      "asinh "
-      "assert "
-      "assignin "
-      "atan "
-      "atan2 "
-      "atand "
-      "atanh "
-      "atexit "
-      "autocor "
-      "autocov "
-      "autoload "
-      "autoreg_matrix "
-      "autumn "
-      "available_graphics_toolkits "
-      "axes "
-      "axis "
-      "balance "
-      "bar "
-      "barh "
-      "bartlett "
-      "bartlett_test "
-      "base2dec "
-      "beep "
-      "beep_on_error "
-      "bessel "
-      "besselh "
-      "besseli "
-      "besselj "
-      "besselk "
-      "bessely "
-      "beta "
-      "betacdf "
-      "betai "
-      "betainc "
-      "betainv "
-      "betaln "
-      "betapdf "
-      "betarnd "
-      "bicgstab "
-      "bicubic "
-      "bin2dec "
-      "bincoeff "
-      "binocdf "
-      "binoinv "
-      "binopdf "
-      "binornd "
-      "bitand "
-      "bitcmp "
-      "bitget "
-      "bitmax "
-      "bitor "
-      "bitpack "
-      "bitset "
-      "bitshift "
-      "bitunpack "
-      "bitxor "
-      "blackman "
-      "blanks "
-      "blkdiag "
-      "blkmm "
-      "bone "
-      "box "
-      "break "
-      "brighten "
-      "bsxfun "
-      "bug_report "
-      "builtin "
-      "bunzip2 "
-      "bzip2 "
-      "calendar "
-      "canonicalize_file_name "
-      "cart2pol "
-      "cart2sph "
-      "case "
-      "cast "
-      "cat "
-      "catch "
-      "cauchy_cdf "
-      "cauchy_inv "
-      "cauchy_pdf "
-      "cauchy_rnd "
-      "caxis "
-      "cbrt "
-      "ccolamd "
-      "cd "
-      "ceil "
-      "cell "
-      "cell2mat "
-      "cell2struct "
-      "celldisp "
-      "cellfun "
-      "cellidx "
-      "cellindexmat "
-      "cellslices "
-      "cellstr "
-      "center "
-      "cgs "
-      "char "
-      "chdir "
-      "chi2cdf "
-      "chi2inv "
-      "chi2pdf "
-      "chi2rnd "
-      "chisquare_test_homogeneity "
-      "chisquare_test_independence "
-      "chol "
-      "chol2inv "
-      "choldelete "
-      "cholinsert "
-      "cholinv "
-      "cholshift "
-      "cholupdate "
-      "chop "
-      "circshift "
-      "cla "
-      "clabel "
-      "class "
-      "clc "
-      "clear "
-      "clf "
-      "clg "
-      "clock "
-      "cloglog "
-      "close "
-      "closereq "
-      "colamd "
-      "colloc "
-      "colon "
-      "colorbar "
-      "colormap "
-      "colperm "
-      "colstyle "
-      "columns "
-      "comet "
-      "comet3 "
-      "comma "
-      "command_line_path "
-      "common_size "
-      "commutation_matrix "
-      "compan "
-      "compare_versions "
-      "compass "
-      "complement "
-      "completion_append_char "
-      "completion_matches "
-      "complex "
-      "computer "
-      "cond "
-      "condest "
-      "confirm_recursive_rmdir "
-      "conj "
-      "continue "
-      "contour "
-      "contour3 "
-      "contourc "
-      "contourf "
-      "contrast "
-      "conv "
-      "conv2 "
-      "convhull "
-      "convhulln "
-      "convn "
-      "cool "
-      "copper "
-      "copyfile "
-      "cor "
-      "cor_test "
-      "corrcoef "
-      "cos "
-      "cosd "
-      "cosh "
-      "cot "
-      "cotd "
-      "coth "
-      "cov "
-      "cplxpair "
-      "cputime "
-      "cquad "
-      "crash_dumps_octave_core "
-      "create_set "
-      "cross "
-      "csc "
-      "cscd "
-      "csch "
-      "cstrcat "
-      "csvread "
-      "csvwrite "
-      "csymamd "
-      "ctime "
-      "ctranspose "
-      "cummax "
-      "cummin "
-      "cumprod "
-      "cumsum "
-      "cumtrapz "
-      "curl "
-      "cut "
-      "cylinder "
-      "daspect "
-      "daspk "
-      "daspk_options "
-      "dasrt "
-      "dasrt_options "
-      "dassl "
-      "dassl_options "
-      "date "
-      "datenum "
-      "datestr "
-      "datetick "
-      "datevec "
-      "dbclear "
-      "dbcont "
-      "dbdown "
-      "dblquad "
-      "dbnext "
-      "dbquit "
-      "dbstack "
-      "dbstatus "
-      "dbstep "
-      "dbstop "
-      "dbtype "
-      "dbup "
-      "dbwhere "
-      "deal "
-      "deblank "
-      "debug "
-      "debug_on_error "
-      "debug_on_interrupt "
-      "debug_on_warning "
-      "dec2base "
-      "dec2bin "
-      "dec2hex "
-      "deconv "
-      "del2 "
-      "delaunay "
-      "delaunay3 "
-      "delaunayn "
-      "delete "
-      "dellistener "
-      "demo "
-      "det "
-      "detrend "
-      "diag "
-      "diary "
-      "diff "
-      "diffpara "
-      "diffuse "
-      "dir "
-      "discrete_cdf "
-      "discrete_inv "
-      "discrete_pdf "
-      "discrete_rnd "
-      "disp "
-      "dispatch "
-      "display "
-      "divergence "
-      "dlmread "
-      "dlmwrite "
-      "dmperm "
-      "dmult "
-      "do "
-      "do_braindead_shortcircuit_evaluation "
-      "do_string_escapes "
-      "doc "
-      "doc_cache_create "
-      "doc_cache_file "
-      "dos "
-      "dot "
-      "double "
-      "drawnow "
-      "dsearch "
-      "dsearchn "
-      "dump_prefs "
-      "dup2 "
-      "duplication_matrix "
-      "durbinlevinson "
-      "e "
-      "echo "
-      "echo_executing_commands "
-      "edit "
-      "edit_history "
-      "eig "
-      "eigs "
-      "ellipsoid "
-      "else "
-      "elseif "
-      "empirical_cdf "
-      "empirical_inv "
-      "empirical_pdf "
-      "empirical_rnd "
-      "end "
-      "end_try_catch "
-      "end_unwind_protect "
-      "endfor "
-      "endfunction "
-      "endgrent "
-      "endif "
-      "endpwent "
-      "endswitch "
-      "endwhile "
-      "eomday "
-      "eps "
-      "eq "
-      "erf "
-      "erfc "
-      "erfcx "
-      "erfinv "
-      "errno "
-      "errno_list "
-      "error "
-      "error_text "
-      "errorbar "
-      "etime "
-      "etree "
-      "etreeplot "
-      "eval "
-      "evalin "
-      "example "
-      "exec "
-      "exist "
-      "exit "
-      "exp "
-      "expcdf "
-      "expinv "
-      "expm "
-      "expm1 "
-      "exppdf "
-      "exprnd "
-      "eye "
-      "ezcontour "
-      "ezcontourf "
-      "ezmesh "
-      "ezmeshc "
-      "ezplot "
-      "ezplot3 "
-      "ezpolar "
-      "ezsurf "
-      "ezsurfc "
-      "f_test_regression "
-      "factor "
-      "factorial "
-      "fail "
-      "false "
-      "fcdf "
-      "fclear "
-      "fclose "
-      "fcntl "
-      "fdisp "
-      "feather "
-      "feof "
-      "ferror "
-      "feval "
-      "fflush "
-      "fft "
-      "fft2 "
-      "fftconv "
-      "fftfilt "
-      "fftn "
-      "fftshift "
-      "fftw "
-      "fgetl "
-      "fgets "
-      "fieldnames "
-      "figure "
-      "file_in_loadpath "
-      "file_in_path "
-      "fileattrib "
-      "filemarker "
-      "fileparts "
-      "fileread "
-      "filesep "
-      "fill "
-      "filter "
-      "filter2 "
-      "find "
-      "find_dir_in_path "
-      "findall "
-      "findobj "
-      "findstr "
-      "finite "
-      "finv "
-      "fix "
-      "fixed_point_format "
-      "flag "
-      "flipdim "
-      "fliplr "
-      "flipud "
-      "floor "
-      "fminbnd "
-      "fminunc "
-      "fmod "
-      "fnmatch "
-      "fopen "
-      "for "
-      "fork "
-      "format "
-      "formula "
-      "fpdf "
-      "fplot "
-      "fprintf "
-      "fputs "
-      "fractdiff "
-      "fread "
-      "freport "
-      "freqz "
-      "freqz_plot "
-      "frewind "
-      "frnd "
-      "fscanf "
-      "fseek "
-      "fskipl "
-      "fsolve "
-      "fstat "
-      "ftell "
-      "full "
-      "fullfile "
-      "func2str "
-      "function "
-      "functions "
-      "fwrite "
-      "fzero "
-      "gamcdf "
-      "gaminv "
-      "gamma "
-      "gammai "
-      "gammainc "
-      "gammaln "
-      "gampdf "
-      "gamrnd "
-      "gca "
-      "gcbf "
-      "gcbo "
-      "gcd "
-      "gcf "
-      "ge "
-      "genpath "
-      "genvarname "
-      "geocdf "
-      "geoinv "
-      "geopdf "
-      "geornd "
-      "get "
-      "get_first_help_sentence "
-      "get_help_text "
-      "get_help_text_from_file "
-      "getappdata "
-      "getegid "
-      "getenv "
-      "geteuid "
-      "getfield "
-      "getgid "
-      "getgrent "
-      "getgrgid "
-      "getgrnam "
-      "gethostname "
-      "getpgrp "
-      "getpid "
-      "getppid "
-      "getpwent "
-      "getpwnam "
-      "getpwuid "
-      "getrusage "
-      "getuid "
-      "ginput "
-      "givens "
-      "glob "
-      "global "
-      "glpk "
-      "glpkmex "
-      "gls "
-      "gmap40 "
-      "gmres "
-      "gmtime "
-      "gnuplot_binary "
-      "gplot "
-      "gradient "
-      "graphics_toolkit "
-      "gray "
-      "gray2ind "
-      "grid "
-      "griddata "
-      "griddata3 "
-      "griddatan "
-      "gt "
-      "gtext "
-      "gunzip "
-      "gzip "
-      "hadamard "
-      "hamming "
-      "hankel "
-      "hanning "
-      "help "
-      "hess "
-      "hex2dec "
-      "hex2num "
-      "hggroup "
-      "hidden "
-      "hilb "
-      "hist "
-      "histc "
-      "history "
-      "history_control "
-      "history_file "
-      "history_save "
-      "history_size "
-      "history_timestamp_format_string "
-      "hold "
-      "home "
-      "horzcat "
-      "hot "
-      "hotelling_test "
-      "hotelling_test_2 "
-      "housh "
-      "hsv "
-      "hsv2rgb "
-      "hurst "
-      "hygecdf "
-      "hygeinv "
-      "hygepdf "
-      "hygernd "
-      "hypot "
-      "i "
-      "idivide "
-      "if "
-      "ifelse "
-      "ifft "
-      "ifft2 "
-      "ifftn "
-      "ifftshift "
-      "ignore_function_time_stamp "
-      "imag "
-      "image "
-      "imagesc "
-      "imfinfo "
-      "imread "
-      "imshow "
-      "imwrite "
-      "ind2gray "
-      "ind2rgb "
-      "ind2sub "
-      "index "
-      "inf "
-      "inferiorto "
-      "info "
-      "info_file "
-      "info_program "
-      "inline "
-      "inpolygon "
-      "input "
-      "inputname "
-      "int16 "
-      "int2str "
-      "int32 "
-      "int64 "
-      "int8 "
-      "interp1 "
-      "interp1q "
-      "interp2 "
-      "interp3 "
-      "interpft "
-      "interpn "
-      "intersect "
-      "intmax "
-      "intmin "
-      "intwarning "
-      "inv "
-      "inverse "
-      "invhilb "
-      "ipermute "
-      "iqr "
-      "is_absolute_filename "
-      "is_duplicate_entry "
-      "is_global "
-      "is_leap_year "
-      "is_rooted_relative_filename "
-      "is_valid_file_id "
-      "isa "
-      "isalnum "
-      "isalpha "
-      "isappdata "
-      "isargout "
-      "isascii "
-      "isbool "
-      "iscell "
-      "iscellstr "
-      "ischar "
-      "iscntrl "
-      "iscolumn "
-      "iscommand "
-      "iscomplex "
-      "isdebugmode "
-      "isdefinite "
-      "isdeployed "
-      "isdigit "
-      "isdir "
-      "isempty "
-      "isequal "
-      "isequalwithequalnans "
-      "isfield "
-      "isfigure "
-      "isfinite "
-      "isfloat "
-      "isglobal "
-      "isgraph "
-      "ishandle "
-      "ishermitian "
-      "ishghandle "
-      "ishold "
-      "isieee "
-      "isindex "
-      "isinf "
-      "isinteger "
-      "iskeyword "
-      "isletter "
-      "islogical "
-      "islower "
-      "ismac "
-      "ismatrix "
-      "ismember "
-      "ismethod "
-      "isna "
-      "isnan "
-      "isnull "
-      "isnumeric "
-      "isobject "
-      "isocolors "
-      "isonormals "
-      "isosurface "
-      "ispc "
-      "isprime "
-      "isprint "
-      "isprop "
-      "ispunct "
-      "israwcommand "
-      "isreal "
-      "isrow "
-      "isscalar "
-      "issorted "
-      "isspace "
-      "issparse "
-      "issquare "
-      "isstr "
-      "isstrprop "
-      "isstruct "
-      "issymmetric "
-      "isunix "
-      "isupper "
-      "isvarname "
-      "isvector "
-      "isxdigit "
-      "j "
-      "jet "
-      "kbhit "
-      "kendall "
-      "keyboard "
-      "kill "
-      "kolmogorov_smirnov_cdf "
-      "kolmogorov_smirnov_test "
-      "kolmogorov_smirnov_test_2 "
-      "kron "
-      "kruskal_wallis_test "
-      "krylov "
-      "krylovb "
-      "kurtosis "
-      "laplace_cdf "
-      "laplace_inv "
-      "laplace_pdf "
-      "laplace_rnd "
-      "lasterr "
-      "lasterror "
-      "lastwarn "
-      "lchol "
-      "lcm "
-      "ldivide "
-      "le "
-      "legend "
-      "legendre "
-      "length "
-      "lgamma "
-      "license "
-      "lin2mu "
-      "line "
-      "link "
-      "linkprop "
-      "linspace "
-      "list "
-      "list_in_columns "
-      "list_primes "
-      "load "
-      "loadaudio "
-      "loadimage "
-      "loadobj "
-      "localtime "
-      "log "
-      "log10 "
-      "log1p "
-      "log2 "
-      "logical "
-      "logistic_cdf "
-      "logistic_inv "
-      "logistic_pdf "
-      "logistic_regression "
-      "logistic_rnd "
-      "logit "
-      "loglog "
-      "loglogerr "
-      "logm "
-      "logncdf "
-      "logninv "
-      "lognpdf "
-      "lognrnd "
-      "logspace "
-      "lookfor "
-      "lookup "
-      "lower "
-      "ls "
-      "ls_command "
-      "lsode "
-      "lsode_options "
-      "lsqnonneg "
-      "lstat "
-      "lt "
-      "lu "
-      "luinc "
-      "luupdate "
-      "magic "
-      "mahalanobis "
-      "make_absolute_filename "
-      "makeinfo_program "
-      "manova "
-      "mark_as_command "
-      "mark_as_rawcommand "
-      "mat2cell "
-      "mat2str "
-      "matlabroot "
-      "matrix_type "
-      "max "
-      "max_recursion_depth "
-      "mcnemar_test "
-      "md5sum "
-      "mean "
-      "meansq "
-      "median "
-      "menu "
-      "merge "
-      "mesh "
-      "meshc "
-      "meshgrid "
-      "meshz "
-      "methods "
-      "mex "
-      "mexext "
-      "mfilename "
-      "mgorth "
-      "min "
-      "minus "
-      "mislocked "
-      "missing_function_hook "
-      "mist "
-      "mkdir "
-      "mkfifo "
-      "mkoctfile "
-      "mkpp "
-      "mkstemp "
-      "mktime "
-      "mldivide "
-      "mlock "
-      "mod "
-      "mode "
-      "moment "
-      "more "
-      "most "
-      "movefile "
-      "mpoles "
-      "mpower "
-      "mrdivide "
-      "mtimes "
-      "mu2lin "
-      "munlock "
-      "namelengthmax "
-      "nan "
-      "nargchk "
-      "nargin "
-      "nargout "
-      "nargoutchk "
-      "native_float_format "
-      "nbincdf "
-      "nbininv "
-      "nbinpdf "
-      "nbinrnd "
-      "nchoosek "
-      "ndgrid "
-      "ndims "
-      "ne "
-      "newplot "
-      "news "
-      "nextpow2 "
-      "nfields "
-      "nnz "
-      "nonzeros "
-      "norm "
-      "normcdf "
-      "normest "
-      "norminv "
-      "normpdf "
-      "normrnd "
-      "not "
-      "now "
-      "nproc "
-      "nth_element "
-      "nthroot "
-      "ntsc2rgb "
-      "null "
-      "num2cell "
-      "num2hex "
-      "num2str "
-      "numel "
-      "nzmax "
-      "ocean "
-      "octave_config_info "
-      "octave_core_file_limit "
-      "octave_core_file_name "
-      "octave_core_file_options "
-      "octave_tmp_file_name "
-      "ols "
-      "onCleanup "
-      "onenormest "
-      "ones "
-      "optimget "
-      "optimize_subsasgn_calls "
-      "optimset "
-      "or "
-      "orderfields "
-      "orient "
-      "orth "
-      "otherwise "
-      "output_max_field_width "
-      "output_precision "
-      "pack "
-      "page_output_immediately "
-      "page_screen_output "
-      "paren "
-      "pareto "
-      "parseparams "
-      "pascal "
-      "patch "
-      "path "
-      "pathdef "
-      "pathsep "
-      "pause "
-      "pbaspect "
-      "pcg "
-      "pchip "
-      "pclose "
-      "pcolor "
-      "pcr "
-      "peaks "
-      "periodogram "
-      "perl "
-      "perms "
-      "permute "
-      "perror "
-      "persistent "
-      "pi "
-      "pie "
-      "pie3 "
-      "pink "
-      "pinv "
-      "pipe "
-      "pkg "
-      "planerot "
-      "playaudio "
-      "plot "
-      "plot3 "
-      "plotmatrix "
-      "plotyy "
-      "plus "
-      "poisscdf "
-      "poissinv "
-      "poisspdf "
-      "poissrnd "
-      "pol2cart "
-      "polar "
-      "poly "
-      "polyaffine "
-      "polyarea "
-      "polyder "
-      "polyderiv "
-      "polyfit "
-      "polygcd "
-      "polyint "
-      "polyout "
-      "polyreduce "
-      "polyval "
-      "polyvalm "
-      "popen "
-      "popen2 "
-      "postpad "
-      "pow2 "
-      "power "
-      "powerset "
-      "ppder "
-      "ppint "
-      "ppjumps "
-      "ppplot "
-      "ppval "
-      "pqpnonneg "
-      "prctile "
-      "prepad "
-      "primes "
-      "print "
-      "print_empty_dimensions "
-      "print_struct_array_contents "
-      "print_usage "
-      "printf "
-      "prism "
-      "probit "
-      "prod "
-      "program_invocation_name "
-      "program_name "
-      "prop_test_2 "
-      "putenv "
-      "puts "
-      "pwd "
-      "qp "
-      "qqplot "
-      "qr "
-      "qrdelete "
-      "qrinsert "
-      "qrshift "
-      "qrupdate "
-      "quad "
-      "quad_options "
-      "quadcc "
-      "quadgk "
-      "quadl "
-      "quadv "
-      "quantile "
-      "quit "
-      "quiver "
-      "quiver3 "
-      "qz "
-      "qzhess "
-      "rainbow "
-      "rand "
-      "rande "
-      "randg "
-      "randi "
-      "randn "
-      "randp "
-      "randperm "
-      "range "
-      "rank "
-      "ranks "
-      "rat "
-      "rats "
-      "rcond "
-      "rdivide "
-      "re_read_readline_init_file "
-      "readdir "
-      "readline_re_read_init_file "
-      "readline_read_init_file "
-      "readlink "
-      "real "
-      "reallog "
-      "realmax "
-      "realmin "
-      "realpow "
-      "realsqrt "
-      "record "
-      "rectangle "
-      "rectint "
-      "refresh "
-      "refreshdata "
-      "regexp "
-      "regexpi "
-      "regexprep "
-      "regexptranslate "
-      "rehash "
-      "rem "
-      "remove_input_event_hook "
-      "rename "
-      "repelems "
-      "replot "
-      "repmat "
-      "reset "
-      "reshape "
-      "residue "
-      "resize "
-      "restoredefaultpath "
-      "rethrow "
-      "return "
-      "rgb2hsv "
-      "rgb2ind "
-      "rgb2ntsc "
-      "ribbon "
-      "rindex "
-      "rmappdata "
-      "rmdir "
-      "rmfield "
-      "rmpath "
-      "roots "
-      "rose "
-      "rosser "
-      "rot90 "
-      "rotdim "
-      "round "
-      "roundb "
-      "rows "
-      "rref "
-      "rsf2csf "
-      "run "
-      "run_count "
-      "run_history "
-      "run_test "
-      "rundemos "
-      "runlength "
-      "runtests "
-      "save "
-      "save_default_options "
-      "save_header_format_string "
-      "save_precision "
-      "saveas "
-      "saveaudio "
-      "saveimage "
-      "saveobj "
-      "savepath "
-      "scanf "
-      "scatter "
-      "scatter3 "
-      "schur "
-      "sec "
-      "secd "
-      "sech "
-      "semicolon "
-      "semilogx "
-      "semilogxerr "
-      "semilogy "
-      "semilogyerr "
-      "set "
-      "setappdata "
-      "setaudio "
-      "setdiff "
-      "setenv "
-      "setfield "
-      "setgrent "
-      "setpwent "
-      "setstr "
-      "setxor "
-      "shading "
-      "shell_cmd "
-      "shg "
-      "shift "
-      "shiftdim "
-      "sighup_dumps_octave_core "
-      "sign "
-      "sign_test "
-      "sigterm_dumps_octave_core "
-      "silent_functions "
-      "sin "
-      "sinc "
-      "sind "
-      "sinetone "
-      "sinewave "
-      "single "
-      "sinh "
-      "size "
-      "size_equal "
-      "sizemax "
-      "sizeof "
-      "skewness "
-      "sleep "
-      "slice "
-      "sombrero "
-      "sort "
-      "sortrows "
-      "source "
-      "spalloc "
-      "sparse "
-      "sparse_auto_mutate "
-      "spatan2 "
-      "spaugment "
-      "spchol "
-      "spchol2inv "
-      "spcholinv "
-      "spconvert "
-      "spcumprod "
-      "spcumsum "
-      "spdet "
-      "spdiag "
-      "spdiags "
-      "spearman "
-      "spectral_adf "
-      "spectral_xdf "
-      "specular "
-      "speed "
-      "spencer "
-      "speye "
-      "spfind "
-      "spfun "
-      "sph2cart "
-      "sphcat "
-      "sphere "
-      "spinmap "
-      "spinv "
-      "spkron "
-      "splchol "
-      "spline "
-      "split "
-      "split_long_rows "
-      "splu "
-      "spmax "
-      "spmin "
-      "spones "
-      "spparms "
-      "spprod "
-      "spqr "
-      "sprand "
-      "sprandn "
-      "sprandsym "
-      "sprank "
-      "spring "
-      "sprintf "
-      "spstats "
-      "spsum "
-      "spsumsq "
-      "spvcat "
-      "spy "
-      "sqp "
-      "sqrt "
-      "sqrtm "
-      "squeeze "
-      "sscanf "
-      "stairs "
-      "stat "
-      "static "
-      "statistics "
-      "std "
-      "stderr "
-      "stdin "
-      "stdnormal_cdf "
-      "stdnormal_inv "
-      "stdnormal_pdf "
-      "stdnormal_rnd "
-      "stdout "
-      "stem "
-      "stem3 "
-      "stft "
-      "str2double "
-      "str2func "
-      "str2mat "
-      "str2num "
-      "strcat "
-      "strchr "
-      "strcmp "
-      "strcmpi "
-      "strerror "
-      "strfind "
-      "strftime "
-      "string_fill_char "
-      "strjust "
-      "strmatch "
-      "strncmp "
-      "strncmpi "
-      "strptime "
-      "strread "
-      "strrep "
-      "strsplit "
-      "strtok "
-      "strtrim "
-      "strtrunc "
-      "struct "
-      "struct2cell "
-      "struct_levels_to_print "
-      "structfun "
-      "strvcat "
-      "studentize "
-      "sub2ind "
-      "subplot "
-      "subsasgn "
-      "subsindex "
-      "subspace "
-      "subsref "
-      "substr "
-      "substruct "
-      "sum "
-      "summer "
-      "sumsq "
-      "superiorto "
-      "suppress_verbose_help_message "
-      "surf "
-      "surface "
-      "surfc "
-      "surfl "
-      "surfnorm "
-      "svd "
-      "svd_driver "
-      "svds "
-      "swapbytes "
-      "switch "
-      "syl "
-      "sylvester_matrix "
-      "symamd "
-      "symbfact "
-      "symlink "
-      "symrcm "
-      "symvar "
-      "synthesis "
-      "system "
-      "t_test "
-      "t_test_2 "
-      "t_test_regression "
-      "table "
-      "tan "
-      "tand "
-      "tanh "
-      "tar "
-      "tcdf "
-      "tempdir "
-      "tempname "
-      "terminal_size "
-      "test "
-      "test2 "
-      "test3 "
-      "text "
-      "textread "
-      "textscan "
-      "tic "
-      "tilde_expand "
-      "time "
-      "times "
-      "tinv "
-      "title "
-      "tmpfile "
-      "tmpnam "
-      "toascii "
-      "toc "
-      "toeplitz "
-      "tolower "
-      "toupper "
-      "tpdf "
-      "trace "
-      "transpose "
-      "trapz "
-      "treelayout "
-      "treeplot "
-      "tril "
-      "trimesh "
-      "triplequad "
-      "triplot "
-      "trisurf "
-      "triu "
-      "trnd "
-      "true "
-      "try "
-      "tsearch "
-      "tsearchn "
-      "type "
-      "typecast "
-      "typeinfo "
-      "u_test "
-      "uigetdir "
-      "uigetfile "
-      "uimenu "
-      "uint16 "
-      "uint32 "
-      "uint64 "
-      "uint8 "
-      "uiputfile "
-      "umask "
-      "uminus "
-      "uname "
-      "undo_string_escapes "
-      "unidcdf "
-      "unidinv "
-      "unidpdf "
-      "unidrnd "
-      "unifcdf "
-      "unifinv "
-      "unifpdf "
-      "unifrnd "
-      "union "
-      "unique "
-      "unix "
-      "unlink "
-      "unmark_command "
-      "unmark_rawcommand "
-      "unmkpp "
-      "unpack "
-      "untabify "
-      "untar "
-      "until "
-      "unwind_protect "
-      "unwind_protect_cleanup "
-      "unwrap "
-      "unzip "
-      "uplus "
-      "upper "
-      "urlread "
-      "urlwrite "
-      "usage "
-      "usleep "
-      "validatestring "
-      "values "
-      "vander "
-      "var "
-      "var_test "
-      "varargin "
-      "varargout "
-      "vec "
-      "vech "
-      "vectorize "
-      "ver "
-      "version "
-      "vertcat "
-      "view "
-      "voronoi "
-      "voronoin "
-      "waitforbuttonpress "
-      "waitpid "
-      "warning "
-      "warning_ids "
-      "warranty "
-      "wavread "
-      "wavwrite "
-      "wblcdf "
-      "wblinv "
-      "wblpdf "
-      "wblrnd "
-      "weekday "
-      "weibcdf "
-      "weibinv "
-      "weibpdf "
-      "weibrnd "
-      "welch_test "
-      "what "
-      "which "
-      "while "
-      "white "
-      "whitebg "
-      "who "
-      "whos "
-      "whos_line_format "
-      "wienrnd "
-      "wilcoxon_test "
-      "wilkinson "
-      "winter "
-      "xlabel "
-      "xlim "
-      "xor "
-      "yes_or_no "
-      "ylabel "
-      "ylim "
-      "yulewalker "
-      "z_test "
-      "z_test_2 "
-      "zeros "
-      "zip "
-      "zlabel "
-      "zlim ";
-  /*            "break case catch continue do else elseif end end_unwind_protect "
-              "endfor endfunction endif endswitch endwhile for function "
-              "global if otherwise persistent return switch try until "
-              "unwind_protect unwind_protect_cleanup while";
-  */
-}
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -49,16 +49,21 @@ public:
     return instance_ok () ? instance->do_get_default_settings () : 0;
   }
 
   static QString get_home_path (void)
   {
     return instance_ok () ? instance->do_get_home_path () : QString ();
   }
 
+  static QString get_settings_file (void)
+  {
+    return instance_ok () ? instance->do_get_settings_file () : QString ();
+  }
+
   static void reload_settings (void)
   {
     if (instance_ok ())
       instance->do_reload_settings ();
   }
 
   static void set_settings (const QString& file)
   {
@@ -76,18 +81,16 @@ public:
       instance->do_update_network_settings ();
   }
 
   static bool is_first_run (void)
   {
     return instance_ok () ? instance->do_is_first_run () : true;
   }
 
-  static const char *octave_keywords (void);
-  
   static QString storage_class_chars (void) { return "afghip"; }
   static QStringList storage_class_names (void);
   static QList<QColor> storage_class_default_colors (void);
 
   static QString terminal_color_chars (void) { return "fbsc"; }
   static QStringList terminal_color_names (void);
   static QList<QColor> terminal_default_colors (void);
 
@@ -114,16 +117,20 @@ private:
   bool first_run;
 
   QSettings *do_get_settings (void) const;
 
   QSettings *do_get_default_settings (void) const;
 
   QString do_get_home_path (void) const;
 
+  QString do_get_settings_file (void);
+
+  QString do_get_settings_path (void);
+
   void do_reload_settings (void);
 
   void do_set_settings (const QString& file);
 
   void do_update_network_settings (void);
 
   bool do_is_first_run (void) const;
 
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -20,42 +20,25 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "welcome-wizard.h"
+#include "resource-manager.h"
 #include "ui-welcome-wizard.h"
 
 welcome_wizard::welcome_wizard (QWidget *p)
   : QDialog (p), _ui (new Ui::welcome_wizard)
 {
   _ui->setupUi (this);
-  connect (_ui->nextButton1, SIGNAL (clicked ()), this, SLOT (next ()));
-  connect (_ui->nextButton2, SIGNAL (clicked ()), this, SLOT (next ()));
-  connect (_ui->nextButton3, SIGNAL (clicked ()), this, SLOT (next ()));
-  connect (_ui->nextButton4, SIGNAL (clicked ()), this, SLOT (next ()));
-
-  connect (_ui->previousButton2, SIGNAL (clicked ()), this, SLOT (previous ()));
-  connect (_ui->previousButton3, SIGNAL (clicked ()), this, SLOT (previous ()));
-  connect (_ui->previousButton4, SIGNAL (clicked ()), this, SLOT (previous ()));
-  connect (_ui->previousButton5, SIGNAL (clicked ()), this, SLOT (previous ()));
+  QString label_text = _ui->label_config_file->text ();
+  label_text.replace (QString ("__%1__"),
+                      resource_manager::get_settings_file ());
+  _ui->label_config_file->setText (label_text);
 }
 
 welcome_wizard::~welcome_wizard()
 {
   delete _ui;
 }
-
-void
-welcome_wizard::next ()
-{
-  _ui->stackedWidget->setCurrentIndex (_ui->stackedWidget->currentIndex () + 1);
-}
-
-void
-welcome_wizard::previous ()
-{
-  _ui->stackedWidget->setCurrentIndex (_ui->stackedWidget->currentIndex () - 1);
-}
-
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -33,16 +33,14 @@ class welcome_wizard : public QDialog
 {
   Q_OBJECT
 
   public:
   explicit welcome_wizard (QWidget *parent = 0);
   ~welcome_wizard ();
 
 public slots:
-  void next ();
-  void previous ();
 
 private:
   Ui::welcome_wizard *_ui;
 };
 
 #endif // WELCOMEWIZARD_H
diff --git a/libgui/src/welcome-wizard.ui b/libgui/src/welcome-wizard.ui
--- a/libgui/src/welcome-wizard.ui
+++ b/libgui/src/welcome-wizard.ui
@@ -1,339 +1,130 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <ui version="4.0">
  <class>welcome_wizard</class>
  <widget class="QDialog" name="welcome_wizard">
+  <property name="enabled">
+   <bool>true</bool>
+  </property>
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>647</width>
-    <height>400</height>
+    <width>480</width>
+    <height>320</height>
    </rect>
   </property>
   <property name="minimumSize">
    <size>
-    <width>647</width>
-    <height>400</height>
+    <width>480</width>
+    <height>320</height>
    </size>
   </property>
   <property name="maximumSize">
    <size>
-    <width>647</width>
-    <height>400</height>
+    <width>480</width>
+    <height>320</height>
    </size>
   </property>
   <property name="windowTitle">
    <string>Welcome to GNU Octave</string>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
-    <widget class="QStackedWidget" name="stackedWidget">
-     <property name="currentIndex">
-      <number>4</number>
-     </property>
-     <widget class="QWidget" name="page">
-      <layout class="QVBoxLayout" name="verticalLayout">
+    <layout class="QVBoxLayout" name="verticalLayout_7">
+     <item>
+      <widget class="QLabel" name="label_2">
+       <property name="font">
+        <font>
+         <pointsize>20</pointsize>
+        </font>
+       </property>
+       <property name="text">
+        <string>Welcome to Octave!</string>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QLabel" name="label_4">
+       <property name="text">
+        <string>You seem to be using the Octave graphical interface for the first  time on this computer.  Click 'Finish' to write a configuration file  and launch Octave GUI. </string>
+       </property>
+       <property name="wordWrap">
+        <bool>true</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QLabel" name="label_config_file">
+       <property name="text">
+        <string>The configuration file is stored in __%1__. If that file exists, you will not see this dialog when Octave starts again.</string>
+       </property>
+       <property name="wordWrap">
+        <bool>true</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QLabel" name="label_3">
+       <property name="text">
+        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;For more information about Octave,&lt;/p&gt;
+&lt;ul&gt;
+&lt;li&gt;visit &lt;a href=&quot;http://octave.org&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;http://octave.org&lt;/span&gt;&lt;/a&gt;,&lt;/li&gt;
+&lt;li&gt; get the documentation online as &lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/index.html&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;html&lt;/span&gt;&lt;/a&gt;- or &lt;a href=&quot;http://www.gnu.org/software/octave/octave.pdf&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;pdf&lt;/span&gt;&lt;/a&gt;-document, or&lt;/li&gt;
+&lt;li&gt;open the documentation browser of Octave GUI with the help menu.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/body&gt;&lt;/html&gt;</string>
+       </property>
+       <property name="wordWrap">
+        <bool>true</bool>
+       </property>
+       <property name="openExternalLinks">
+        <bool>true</bool>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer name="verticalSpacer_5">
+       <property name="orientation">
+        <enum>Qt::Vertical</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>20</width>
+         <height>40</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <layout class="QHBoxLayout" name="horizontalLayout_7">
        <item>
-        <widget class="QLabel" name="label">
-         <property name="text">
-          <string>It appears that you have launched Octave GUI for the first time on this computer, since no configuration file could be found at '~/.octave-gui'. This wizard will guide you through the essential settings you should make before you can start using Octave GUI. If you want to transfer your settings you have previously made just close this dialog and copy over the settings file to your home folder. The presence of that file will automatically be detected and will skip this wizard. IMPORTANT: This wizard is not fully functional yet. Just click your way to the end and it will create a standard settings file.</string>
-         </property>
-         <property name="alignment">
-          <set>Qt::AlignJustify|Qt::AlignVCenter</set>
-         </property>
-         <property name="wordWrap">
-          <bool>true</bool>
-         </property>
-        </widget>
-       </item>
-       <item>
-        <spacer name="verticalSpacer">
+        <spacer name="horizontalSpacer_5">
          <property name="orientation">
-          <enum>Qt::Vertical</enum>
+          <enum>Qt::Horizontal</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
-           <width>20</width>
-           <height>218</height>
+           <width>40</width>
+           <height>20</height>
           </size>
          </property>
         </spacer>
        </item>
        <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_2">
-         <item>
-          <spacer name="horizontalSpacer">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-         <item>
-          <widget class="QPushButton" name="nextButton1">
-           <property name="text">
-            <string>Next</string>
-           </property>
-          </widget>
-         </item>
-        </layout>
-       </item>
-      </layout>
-     </widget>
-     <widget class="QWidget" name="page_2">
-      <layout class="QVBoxLayout" name="verticalLayout_4">
-       <item>
-        <layout class="QVBoxLayout" name="verticalLayout_3">
-         <item>
-          <spacer name="verticalSpacer_2">
-           <property name="orientation">
-            <enum>Qt::Vertical</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>20</width>
-             <height>40</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout">
-           <item>
-            <widget class="QPushButton" name="previousButton2">
-             <property name="text">
-              <string>Previous</string>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <spacer name="horizontalSpacer_2">
-             <property name="orientation">
-              <enum>Qt::Horizontal</enum>
-             </property>
-             <property name="sizeHint" stdset="0">
-              <size>
-               <width>40</width>
-               <height>20</height>
-              </size>
-             </property>
-            </spacer>
-           </item>
-           <item>
-            <widget class="QPushButton" name="nextButton2">
-             <property name="text">
-              <string>Next</string>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </item>
-        </layout>
-       </item>
-      </layout>
-     </widget>
-     <widget class="QWidget" name="page_3">
-      <layout class="QHBoxLayout" name="horizontalLayout_4">
-       <item>
-        <layout class="QVBoxLayout" name="verticalLayout_5">
-         <item>
-          <spacer name="verticalSpacer_3">
-           <property name="orientation">
-            <enum>Qt::Vertical</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>20</width>
-             <height>40</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout_3">
-           <item>
-            <widget class="QPushButton" name="previousButton3">
-             <property name="text">
-              <string>Previous</string>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <spacer name="horizontalSpacer_3">
-             <property name="orientation">
-              <enum>Qt::Horizontal</enum>
-             </property>
-             <property name="sizeHint" stdset="0">
-              <size>
-               <width>40</width>
-               <height>20</height>
-              </size>
-             </property>
-            </spacer>
-           </item>
-           <item>
-            <widget class="QPushButton" name="nextButton3">
-             <property name="text">
-              <string>Next</string>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </item>
-        </layout>
+        <widget class="QPushButton" name="finishButton">
+         <property name="text">
+          <string>Finish</string>
+         </property>
+        </widget>
        </item>
       </layout>
-     </widget>
-     <widget class="QWidget" name="page_4">
-      <layout class="QHBoxLayout" name="horizontalLayout_6">
-       <item>
-        <layout class="QVBoxLayout" name="verticalLayout_6">
-         <item>
-          <spacer name="verticalSpacer_4">
-           <property name="orientation">
-            <enum>Qt::Vertical</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>20</width>
-             <height>40</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout_5">
-           <item>
-            <widget class="QPushButton" name="previousButton4">
-             <property name="text">
-              <string>Previous</string>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <spacer name="horizontalSpacer_4">
-             <property name="orientation">
-              <enum>Qt::Horizontal</enum>
-             </property>
-             <property name="sizeHint" stdset="0">
-              <size>
-               <width>40</width>
-               <height>20</height>
-              </size>
-             </property>
-            </spacer>
-           </item>
-           <item>
-            <widget class="QPushButton" name="nextButton4">
-             <property name="text">
-              <string>Next</string>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </item>
-        </layout>
-       </item>
-      </layout>
-     </widget>
-     <widget class="QWidget" name="page_5">
-      <layout class="QHBoxLayout" name="horizontalLayout_8">
-       <item>
-        <layout class="QVBoxLayout" name="verticalLayout_7">
-         <item>
-          <widget class="QLabel" name="label_2">
-           <property name="font">
-            <font>
-             <pointsize>20</pointsize>
-            </font>
-           </property>
-           <property name="text">
-            <string>Welcome to Octave!</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="label_3">
-           <property name="text">
-            <string>This is the development version of Octave with the first official GUI.</string>
-           </property>
-           <property name="wordWrap">
-            <bool>true</bool>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="label_4">
-           <property name="text">
-            <string>You seem to run Octave GUI for the first time on this computer. This assistant will help you to configure this software installation. Click 'Finish' to write a configuration file and launch Octave GUI.</string>
-           </property>
-           <property name="wordWrap">
-            <bool>true</bool>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <spacer name="verticalSpacer_5">
-           <property name="orientation">
-            <enum>Qt::Vertical</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>20</width>
-             <height>40</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout_7">
-           <item>
-            <widget class="QPushButton" name="previousButton5">
-             <property name="enabled">
-              <bool>false</bool>
-             </property>
-             <property name="text">
-              <string>Previous</string>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <spacer name="horizontalSpacer_5">
-             <property name="orientation">
-              <enum>Qt::Horizontal</enum>
-             </property>
-             <property name="sizeHint" stdset="0">
-              <size>
-               <width>40</width>
-               <height>20</height>
-              </size>
-             </property>
-            </spacer>
-           </item>
-           <item>
-            <widget class="QPushButton" name="finishButton">
-             <property name="text">
-              <string>Finish</string>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </item>
-        </layout>
-       </item>
-      </layout>
-     </widget>
-    </widget>
+     </item>
+    </layout>
    </item>
   </layout>
  </widget>
  <resources/>
  <connections>
   <connection>
    <sender>finishButton</sender>
    <signal>clicked()</signal>
diff --git a/libinterp/Makefile.am b/libinterp/Makefile.am
--- a/libinterp/Makefile.am
+++ b/libinterp/Makefile.am
@@ -15,18 +15,16 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AUTOMAKE_OPTIONS = subdir-objects
-
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I$(top_srcdir)/liboctave/cruft/misc \
   -I$(top_srcdir)/liboctave/array \
   -I$(top_builddir)/liboctave/numeric -I$(top_srcdir)/liboctave/numeric \
   -I$(top_builddir)/liboctave/operators -I$(top_srcdir)/liboctave/operators \
   -I$(top_srcdir)/liboctave/system \
   -I$(top_srcdir)/liboctave/util \
@@ -46,27 +44,33 @@ octlib_LTLIBRARIES = liboctinterp.la
 ## $(DEF_FILES), and building those requires all the sources
 ## (except builtins.cc) to be available.
 BUILT_SOURCES = \
   corefcn/mxarray.h \
   corefcn/oct-errno.cc \
   corefcn/defaults.h \
   corefcn/graphics-props.cc \
   corefcn/graphics.h \
+  corefcn/oct-tex-lexer.cc \
+  corefcn/oct-tex-parser.cc \
+  corefcn/oct-tex-symbols.cc \
   operators/ops.cc \
   parse-tree/lex.cc \
   parse-tree/oct-gperf.h \
   parse-tree/oct-parse.cc \
   oct-conf.h \
   oct-conf-features.h \
   version.h \
   builtin-defun-decls.h \
   builtins.cc
 
 BUILT_DISTFILES = \
+  corefcn/oct-tex-lexer.ll \
+  corefcn/oct-tex-parser.h \
+  corefcn/oct-tex-symbols.cc \
   parse-tree/oct-gperf.h \
   parse-tree/oct-parse.h \
   parse-tree/oct-parse.yy
 
 ## Files that are created during build process and installed,
 ## BUT not distributed in tarball.
 BUILT_NODISTFILES = \
   corefcn/mxarray.h \
@@ -91,17 +95,16 @@ EXTRA_DIST = \
   gendoc.pl \
   genprops.awk \
   mk-errno-list \
   mk-pkg-add \
   mkbuiltins \
   mkdefs \
   mkops \
   oct-conf.in.h \
-  parse-tree/oct-parse.in.yy \
   version.in.h \
   $(BUILT_DISTFILES)
 
 octinclude_HEADERS = \
   corefcn/graphics-props.cc \
   parse-tree/oct-gperf.h \
   builtins.h \
   builtin-defun-decls.h \
@@ -116,20 +119,22 @@ nodist_octinclude_HEADERS = \
   corefcn/mxarray.h \
   corefcn/defaults.h \
   corefcn/graphics.h \
   oct-conf.h \
   version.h
 
 DIST_SRC = \
   octave.cc \
+  version.cc \
   $(OCTAVE_VALUE_SRC) \
   $(PARSE_TREE_SRC) \
   $(PARSER_SRC) \
-  $(COREFCN_SRC)
+  $(COREFCN_SRC) \
+  $(TEX_PARSER_SRC)
 
 noinst_LTLIBRARIES =
 
 include parse-tree/module.mk
 include octave-value/module.mk
 include operators/module.mk
 include template-inst/module.mk
 include corefcn/module.mk
@@ -145,16 +150,17 @@ if AMCOND_ENABLE_DYNAMIC_LINKING
 else
   OCT_FILES =
   OCT_STAMP_FILES =
   DLD_LIBOCTINTERP_LIBADD =
 endif
 
 liboctinterp_la_SOURCES = \
   octave.cc \
+  version.cc \
   $(OPERATORS_SRC) \
   $(TEMPLATE_INST_SRC)
 
 nodist_liboctinterp_la_SOURCES = \
   corefcn/mxarray.h \
   corefcn/oct-errno.cc \
   corefcn/defaults.h \
   corefcn/graphics.h \
@@ -170,16 +176,17 @@ liboctinterp_la_CPPFLAGS = @OCTINTERP_DL
 
 include link-deps.mk
 
 liboctinterp_la_LIBADD = \
   octave-value/liboctave-value.la \
   parse-tree/libparse-tree.la \
   parse-tree/libparser.la \
   corefcn/libcorefcn.la \
+  corefcn/libtex_parser.la \
   $(top_builddir)/liboctave/liboctave.la \
   $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
 liboctinterp_current = 1
 liboctinterp_revision = 1
 liboctinterp_age = 0
 
@@ -189,17 +196,17 @@ liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTINTERP_LINK_OPTS)
 
 ## Section for defining and creating DEF_FILES
 
 ULT_DIST_SRC := \
-  $(filter-out parse-tree/oct-parse.yy, $(DIST_SRC)) parse-tree/oct-parse.in.yy
+  $(filter-out corefcn/oct-tex-lexer.ll parse-tree/oct-parse.yy, $(DIST_SRC)) corefcn/oct-tex-lexer.in.ll parse-tree/oct-parse.in.yy
 
 SRC_DEF_FILES := $(shell $(srcdir)/find-defun-files.sh "$(srcdir)" $(ULT_DIST_SRC))
 
 DLDFCN_DEF_FILES = $(DLDFCN_SRC:.cc=.df)
 
 ## builtins.cc depends on $(DEF_FILES), so DEF_FILES should only include
 ## .df files that correspond to sources included in liboctave.
 if AMCOND_ENABLE_DYNAMIC_LINKING
@@ -243,17 +250,17 @@ TST_FILES := $(addsuffix -tst,$(TST_FILE
 libinterptestsdir := $(octtestsdir)/libinterp
 
 nobase_libinterptests_DATA = $(TST_FILES)
 
 ## Override Automake's rule that forces a .hh extension on us even
 ## though we don't want it.  It would be super awesome if automake
 ## would allow users to choose the header file extension.
 .yy.cc:
-	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
+	$(AM_V_YACC)$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
 
 ## Special rules:
 ## Mostly for sources which must be built before rest of compilation.
 
 ## oct-conf.h must depend on Makefile.
 ## Calling configure may change default/config values.
 ## However, calling configure will also regenerate the Makefiles from
 ## Makefile.am and trigger the rules below.
@@ -311,17 +318,17 @@ install-data-hook: install-oct install-b
 else
 install-data-hook: install-oct uninstall-built-in-docstrings
 endif
 
 uninstall-local: uninstall-oct uninstall-built-in-docstrings
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
 install-oct:
-	$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(octfiledir)
+	$(MKDIR_P) $(DESTDIR)$(octfiledir)
 	if [ -n "`cat $(DLDFCN_PKG_ADD_FILE)`" ]; then \
 	  $(INSTALL_DATA) $(DLDFCN_PKG_ADD_FILE) $(DESTDIR)$(octfiledir)/PKG_ADD; \
 	fi
 	cd $(DESTDIR)$(octlibdir) && \
 	for ltlib in $(DLDFCN_LIBS); do \
 	  f=`echo $$ltlib | $(SED) 's,.*/,,'`; \
 	  dl=`$(SED) -n -e "s/dlname='\([^']*\)'/\1/p" < $$f`; \
 	  if [ -n "$$dl" ]; then \
@@ -352,16 +359,17 @@ install-built-in-docstrings:
 uninstall-built-in-docstrings:
 	rm -f $(DESTDIR)$(octetcdir)/built-in-docstrings
 endif
 .PHONY: install-built-in-docstrings uninstall-built-in-docstrings
 
 CLEANFILES = \
   $(DLDFCN_PKG_ADD_FILE) \
   corefcn/graphics-props.cc \
+  corefcn/oct-tex-parser.output \
   parse-tree/oct-parse.output
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
   DOCSTRINGS \
   $(BUILT_NODISTFILES) \
   $(OCT_FILES) \
   $(OCT_STAMP_FILES) \
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -70,20 +70,20 @@ If four output values are requested, com
 @var{CC}*@var{A}*@var{DD}} and @code{@var{BB} = @var{CC}*@var{B}*@var{DD}},\n\
 in which @var{AA} and @var{BB} have non-zero elements of approximately the\n\
 same magnitude and @var{CC} and @var{DD} are permuted diagonal matrices as\n\
 in @var{DD} for the algebraic eigenvalue problem.\n\
 \n\
 The eigenvalue balancing option @var{opt} may be one of:\n\
 \n\
 @table @asis\n\
-@item \"noperm\", \"S\"\n\
+@item @qcode{\"noperm\"}, @qcode{\"S\"}\n\
 Scale only; do not permute.\n\
 \n\
-@item \"noscal\", \"P\"\n\
+@item @qcode{\"noscal\"}, @qcode{\"P\"}\n\
 Permute only; do not scale.\n\
 @end table\n\
 \n\
 Algebraic eigenvalue balancing uses standard @sc{lapack} routines.\n\
 \n\
 Generalized eigenvalue problem balancing uses Ward's algorithm\n\
 (SIAM Journal on Scientific and Statistical Computing, 1981).\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -644,21 +644,20 @@ return @code{NaN}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%! # Test values computed with GP/PARI version 2.3.3
-%!
+## Test values computed with GP/PARI version 2.3.3
 %!shared alpha, x, jx, yx, ix, kx, nix
 %!
-%! # Bessel functions, even order, positive and negative x
+%! ## Bessel functions, even order, positive and negative x
 %! alpha = 2;  x = 1.25;
 %! jx = 0.1710911312405234823613091417;
 %! yx = -1.193199310178553861283790424;
 %! ix = 0.2220184483766341752692212604;
 %! kx = 0.9410016167388185767085460540;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
 %!assert (bessely (alpha,x), yx, 100*eps)
@@ -701,17 +700,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, odd order, positive and negative x
+%! ## Bessel functions, odd order, positive and negative x
 %! alpha = 3;  x = 2.5;
 %! jx = 0.2166003910391135247666890035;
 %! yx = -0.7560554967536709968379029772;
 %! ix = 0.4743704087780355895548240179;
 %! kx = 0.2682271463934492027663765197;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
 %!assert (bessely (alpha,x), yx, 100*eps)
@@ -756,17 +755,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, fractional order, positive and negative x
+%! ## Bessel functions, fractional order, positive and negative x
 %!
 %! alpha = 3.5;  x = 2.75;
 %! jx = 0.1691636439842384154644784389;
 %! yx = -0.8301381935499356070267953387;
 %! ix = 0.3930540878794826310979363668;
 %! kx = 0.2844099013460621170288192503;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -814,17 +813,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, even order, complex x
+%! ## Bessel functions, even order, complex x
 %!
 %! alpha = 2;  x = 1.25 + 3.625 * I;
 %! jx = -1.299533366810794494030065917 + 4.370833116012278943267479589*I;
 %! yx = -4.370357232383223896393056727 - 1.283083391453582032688834041*I;
 %! ix = -0.6717801680341515541002273932 - 0.2314623443930774099910228553*I;
 %! kx = -0.01108009888623253515463783379 + 0.2245218229358191588208084197*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -850,17 +849,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, odd order, complex x
+%! ## Bessel functions, odd order, complex x
 %!
 %! alpha = 3; x = 2.5 + 1.875 * I;
 %! jx = 0.1330721523048277493333458596 + 0.5386295217249660078754395597*I;
 %! yx = -0.6485072392105829901122401551 + 0.2608129289785456797046996987*I;
 %! ix = -0.6182064685486998097516365709 + 0.4677561094683470065767989920*I;
 %! kx = -0.1568585587733540007867882337 - 0.05185853709490846050505141321*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -886,17 +885,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (-alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
-%! # Bessel functions, fractional order, complex x
+%! ## Bessel functions, fractional order, complex x
 %!
 %! alpha = 3.5;  x = 1.75 + 4.125 * I;
 %! jx = -3.018566131370455929707009100 - 0.7585648436793900607704057611*I;
 %! yx = 0.7772278839106298215614791107 - 3.018518722313849782683792010*I;
 %! ix = 0.2100873577220057189038160913 - 0.6551765604618246531254970926*I;
 %! kx = 0.1757147290513239935341488069 + 0.08772348296883849205562558311*I;
 %!
 %!assert (besselj (alpha,x), jx, 100*eps)
@@ -908,17 +907,17 @@ return @code{NaN}.\n\
 %!
 %!assert (besselj (alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert (bessely (alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert (besseli (alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
 %!assert (besselk (alpha,x,1), kx*exp(x), 100*eps)
 %!assert (besselh (alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert (besselh (alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!  nix = 0.09822388691172060573913739253 - 0.7110230642207380127317227407*I;
+%! nix = 0.09822388691172060573913739253 - 0.7110230642207380127317227407*I;
 %!
 %!assert (besselj (-alpha,x), yx, 100*eps)
 %!assert (bessely (-alpha,x), -jx, 100*eps)
 %!assert (besseli (-alpha,x), nix, 100*eps)
 %!assert (besselk (-alpha,x), kx, 100*eps)
 %!assert (besselh (-alpha,1,x), -I*(jx + I*yx), 100*eps)
 %!assert (besselh (-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -19,30 +19,33 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <limits>
+
 #include "str-vec.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov.h"
 #include "ov-uint64.h"
 #include "ov-uint32.h"
 #include "ov-uint16.h"
 #include "ov-uint8.h"
 #include "ov-int64.h"
 #include "ov-int32.h"
 #include "ov-int16.h"
 #include "ov-int8.h"
+#include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
 #include <functional>
 
 #if !defined (HAVE_CXX_BITWISE_OP_TEMPLATES)
 namespace std 
@@ -133,35 +136,65 @@ bitop (const std::string& fname, const o
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       if ((args(0).class_name () == octave_scalar::static_class_name ())
+          || (args(0).class_name () == octave_float_scalar::static_class_name ())
           || (args(0).class_name () == octave_bool::static_class_name ())
           || (args(1).class_name () == octave_scalar::static_class_name ())
+          || (args(1).class_name () == octave_float_scalar::static_class_name ())
           || (args(1).class_name () == octave_bool::static_class_name ()))
         {
           bool arg0_is_int = (args(0).class_name () !=
                               octave_scalar::static_class_name () &&
                               args(0).class_name () !=
+                              octave_float_scalar::static_class_name () &&
+                              args(0).class_name () !=
                               octave_bool::static_class_name ());
           bool arg1_is_int = (args(1).class_name () !=
                               octave_scalar::static_class_name () &&
                               args(1).class_name () !=
+                              octave_float_scalar::static_class_name () &&
+                              args(1).class_name () !=
                               octave_bool::static_class_name ());
+          bool arg0_is_float = args(0).class_name () ==
+                               octave_float_scalar::static_class_name ();
+          bool arg1_is_float = args(1).class_name () ==
+                               octave_float_scalar::static_class_name ();
 
           if (! (arg0_is_int || arg1_is_int))
             {
-              uint64NDArray x (args(0).array_value ());
-              uint64NDArray y (args(1).array_value ());
-              if (! error_state)
-                retval = bitopx (fname, x, y).array_value ();
+              if (! (arg0_is_float || arg1_is_float))
+                {
+                  uint64NDArray x (args(0).array_value ());
+                  uint64NDArray y (args(1).array_value ());
+                  if (! error_state)
+                    retval = bitopx (fname, x, y).array_value ();
+                }
+              else if (arg0_is_float && arg1_is_float)
+                {
+                  uint64NDArray x (args(0).float_array_value ());
+                  uint64NDArray y (args(1).float_array_value ());
+                  if (! error_state)
+                    retval = bitopx (fname, x, y).float_array_value ();
+                }
+              else
+                {
+                  int p = (arg0_is_float ? 1 : 0);
+                  int q = (arg0_is_float ? 0 : 1);
+
+                  uint64NDArray x (args(p).array_value ());
+                  uint64NDArray y (args(q).float_array_value ());
+                  if (! error_state)
+                    retval = bitopx (fname, x, y).float_array_value ();
+                }
             }
           else
             {
               int p = (arg0_is_int ? 1 : 0);
               int q = (arg0_is_int ? 0 : 1);
 
               NDArray dx = args(p).array_value ();
 
@@ -339,16 +372,23 @@ DEFUN (bitxor, args, ,
 Return the bitwise XOR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   return bitop ("bitxor", args);
 }
 
+template <typename T>
+static int64_t
+max_mantissa_value ()
+{
+  return (static_cast<int64_t> (1) << std::numeric_limits<T>::digits) - 1;
+}
+
 static int64_t
 bitshift (double a, int n, int64_t mask)
 {
   // In the name of bug-for-bug compatibility.
   if (a < 0)
     return -bitshift (-a, n, mask);
 
   if (n > 0)
@@ -538,67 +578,119 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
       else if (cname == "int16")
         DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
       else if (cname == "int32")
         DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
       else if (cname == "int64")
         DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
       else if (cname == "double")
         {
-          nbits = (nbits < 53 ? nbits : 53);
-          int64_t mask = 0x1FFFFFFFFFFFFFLL;
-          if (nbits < 53)
-            mask = mask >> (53 - nbits);
+          static const int bits_in_mantissa = std::numeric_limits<double>::digits;
+          nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
+          int64_t mask = max_mantissa_value<double> ();
+          if (nbits < bits_in_mantissa)
+            mask = mask >> (bits_in_mantissa - nbits);
           else if (nbits < 1)
             mask = 0;
-          int bits_in_type = 64;
+          int bits_in_type = sizeof (double) * std::numeric_limits<unsigned char>::digits;
           NDArray m = m_arg.array_value ();
           DO_BITSHIFT ( );
         }
+      else if (cname == "single")
+        {
+          static const int bits_in_mantissa = std::numeric_limits<float>::digits;
+          nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
+          int64_t mask = max_mantissa_value<float> ();
+          if (nbits < bits_in_mantissa)
+            mask = mask >> (bits_in_mantissa - nbits);
+          else if (nbits < 1)
+            mask = 0;
+          int bits_in_type = sizeof (float) * std::numeric_limits<unsigned char>::digits;
+          FloatNDArray m = m_arg.float_array_value ();
+          DO_BITSHIFT (Float);
+        }
       else
         error ("bitshift: not defined for %s objects", cname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitmax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} bitmax ()\n\
 @deftypefnx {Built-in Function} {} bitmax (\"double\")\n\
 @deftypefnx {Built-in Function} {} bitmax (\"single\")\n\
 Return the largest integer that can be represented within a floating point\n\
-value.  The default class is \"double\", but \"single\" is a valid option.\n\
-On IEEE-754 compatible systems, @code{bitmax} is @w{@math{2^{53} - 1}}.\n\
+value.  The default class is @qcode{\"double\"}, but @qcode{\"single\"} is a\n\
+valid option.  On IEEE-754 compatible systems, @code{bitmax} is\n\
+@w{@math{2^{53} - 1}} for @qcode{\"double\"} and @w{@math{2^{24} -1}} for\n\
+@qcode{\"single\"}.\n\
+@seealso{flintmax, intmax, realmax, realmin}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string cname = "double";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
   else if (nargin != 0)
     {
       print_usage ();
       return retval;
     }
 
   if (cname == "double")
-    retval = (static_cast<double> (0x1FFFFFFFFFFFFFLL));
+    retval = (static_cast<double> (max_mantissa_value<double> ()));
   else if (cname == "single")
-    retval = (static_cast<double> (0xFFFFFFL));
+    retval = (static_cast<float> (max_mantissa_value<float> ()));
   else
     error ("bitmax: not defined for class '%s'", cname.c_str ());
 
   return retval;
 }
 
+DEFUN (flintmax, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} flintmax ()\n\
+@deftypefnx {Built-in Function} {} flintmax (\"double\")\n\
+@deftypefnx {Built-in Function} {} flintmax (\"single\")\n\
+Return the largest integer that can be represented consecutively in a\n\
+floating point value.  The default class is @qcode{\"double\"}, but\n\
+@qcode{\"single\"} is a valid option.  On IEEE-754 compatible systems,\n\
+@code{flintmax} is @w{@math{2^53}} for @qcode{\"double\"} and\n\
+@w{@math{2^24}} for @qcode{\"single\"}.\n\
+@seealso{bitmax, intmax, realmax, realmin}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  std::string cname = "double";
+  int nargin = args.length ();
+
+  if (nargin == 1 && args(0).is_string ())
+    cname = args(0).string_value ();
+  else if (nargin != 0)
+    {
+      print_usage ();
+      return retval;
+    }
+
+  if (cname == "double")
+    retval = (static_cast<double> (max_mantissa_value<double> () + 1));
+  else if (cname == "single")
+    retval = (static_cast<float> (max_mantissa_value<float> () + 1));
+  else
+    error ("flintmax: not defined for class '%s'", cname.c_str ());
+
+  return retval;
+}
+
 DEFUN (intmax, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmax (@var{type})\n\
 Return the largest integer that can be represented in an integer type.\n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
@@ -622,17 +714,17 @@ unsigned 16-bit integer.\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
 \n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
-@seealso{intmin, bitmax}\n\
+@seealso{intmin, flintmax, bitmax}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
@@ -692,17 +784,17 @@ unsigned 16-bit integer.\n\
 @item uint32\n\
 unsigned 32-bit integer.\n\
 \n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{uint32}.\n\
-@seealso{intmax, bitmax}\n\
+@seealso{intmax, flintmax, bitmax}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string cname = "int32";
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     cname = args(0).string_value ();
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -768,46 +768,46 @@ dimensionality as the other array.\n\
 %!assert (bsxfun (@min, a, b), min (aa, bb))
 %!assert (bsxfun (@max, a, b), max (aa, bb))
 %!assert (bsxfun (@and, a > 0, b > 0), (aa > 0) & (bb > 0))
 %!assert (bsxfun (@or, a > 0, b > 0), (aa > 0) | (bb > 0))
 
 %% Test automatic bsxfun
 %
 %!test
-%! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, \
-%!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, \
+%! funs = {@plus, @minus, @times, @rdivide, @ldivide, @power, @max, @min, ...
+%!         @rem, @mod, @atan2, @hypot, @eq, @ne, @lt, @le, @gt, @ge, ...
 %!         @and, @or, @xor };
 %!
 %! float_types = {@single, @double};
-%! int_types = {@int8, @int16, @int32, @int64, \
+%! int_types = {@int8, @int16, @int32, @int64, ...
 %!              @uint8, @uint16, @uint32, @uint64};
 %!
 %! x = rand (3) * 10-5;
 %! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
 %!   for j = 1:length (float_types)
 %!     for k = 1:length (int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
 %!
-%!         assert (bsxfun (fun, f_type (x), i_type (y)), \
+%!         assert (bsxfun (fun, f_type (x), i_type (y)), ...
 %!                 fun (f_type(x), i_type (y)));
-%!         assert (bsxfun (fun, f_type (y), i_type (x)), \
+%!         assert (bsxfun (fun, f_type (y), i_type (x)), ...
 %!                 fun (f_type(y), i_type (x)));
 %!
-%!         assert (bsxfun (fun, i_type (x), i_type (y)), \
+%!         assert (bsxfun (fun, i_type (x), i_type (y)), ...
 %!                 fun (i_type (x), i_type (y)));
-%!         assert (bsxfun (fun, i_type (y), i_type (x)), \
+%!         assert (bsxfun (fun, i_type (y), i_type (x)), ...
 %!                 fun (i_type (y), i_type (x)));
 %!
-%!         assert (bsxfun (fun, f_type (x), f_type (y)), \
+%!         assert (bsxfun (fun, f_type (x), f_type (y)), ...
 %!                 fun (f_type (x), f_type (y)));
-%!         assert (bsxfun (fun, f_type(y), f_type(x)), \
+%!         assert (bsxfun (fun, f_type(y), f_type(x)), ...
 %!                 fun (f_type (y), f_type (x)));
 %!     endfor
 %!   endfor
 %! endfor
 %!
 */
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -128,16 +128,23 @@ try_cellfun_internal_ops (const octave_v
     }
   else if (name == "islogical")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
     }
+  else if (name == "isnumeric")
+    {
+      boolNDArray result (f_args.dims ());
+      for (octave_idx_type  count= 0; count < k; count++)
+        result(count) = f_args.elem (count).is_numeric_type ();
+      retval(0) = result;
+    }
   else if (name == "isreal")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_real_type ();
       retval(0) = result;
     }
   else if (name == "length")
@@ -149,17 +156,17 @@ try_cellfun_internal_ops (const octave_v
     }
   else if (name == "ndims")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).ndims ());
       retval(0) = result;
     }
-  else if (name == "prodofsize" || name == "numel")
+  else if (name == "numel" || name == "prodofsize")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
@@ -273,26 +280,29 @@ individually.  The function @var{name} c
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
 \n\
 @item islogical\n\
 Return 1 for logical elements.\n\
 \n\
+@item isnumeric\n\
+Return 1 for numeric elements.\n\
+\n\
 @item isreal\n\
 Return 1 for real elements.\n\
 \n\
 @item length\n\
 Return a vector of the lengths of cell elements.\n\
 \n\
 @item ndims\n\
 Return the number of dimensions of each element.\n\
 \n\
-@item numel\n\
+@item  numel\n\
 @itemx prodofsize\n\
 Return the number of elements contained within each cell element.  The\n\
 number is the product of the dimensions of the object at each cell element.\n\
 \n\
 @item size\n\
 Return the size along the @var{k}-th dimension.\n\
 \n\
 @item isclass\n\
@@ -332,42 +342,43 @@ endfunction\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
 Note that per default the output argument(s) are arrays of the same size as\n\
 the input arguments.  Input arguments that are singleton (1x1) cells will be\n\
 automatically expanded to the size of the other arguments.\n\
 \n\
-If the parameter \"UniformOutput\" is set to true (the default), then the\n\
-function must return scalars which will be concatenated into the return\n\
-array(s).  If \"UniformOutput\" is false, the outputs are concatenated into a\n\
-cell array (or cell arrays).  For example:\n\
+If the parameter @qcode{\"UniformOutput\"} is set to true (the default),\n\
+then the function must return scalars which will be concatenated into the\n\
+return array(s).  If @qcode{\"UniformOutput\"} is false, the outputs are\n\
+concatenated into a cell array (or cell arrays).  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
          \"UniformOutput\", false)\n\
 @result{} @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
 \n\
-Given the parameter \"ErrorHandler\", then @var{errfunc} defines a function\n\
-to call in case @var{func} generates an error.  The form of the function is\n\
+Given the parameter @qcode{\"ErrorHandler\"}, then @var{errfunc} defines a\n\
+function to call in case @var{func} generates an error.  The form of the\n\
+function is\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
 @noindent\n\
 where there is an additional input argument to @var{errfunc} relative to\n\
 @var{func}, given by @var{s}.  This is a structure with the elements\n\
-'identifier', 'message' and 'index', giving respectively the error\n\
-identifier, the error message, and the index into the input arguments\n\
-of the element that caused the error.  For example:\n\
+@qcode{\"identifier\"}, @qcode{\"message\"} and @qcode{\"index\"}, giving\n\
+respectively the error identifier, the error message, and the index into the\n\
+input arguments of the element that caused the error.  For example:\n\
 \n\
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
 cellfun (\"factorial\", @{-1,2@}, \"ErrorHandler\", @@foo)\n\
 @result{} [NaN 2]\n\
 @end group\n\
 @end example\n\
@@ -773,42 +784,45 @@ v = cellfun (@@det, a); # faster\n\
 %!test
 %! A = cellfun (@islogical, {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@(x) islogical (x), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 
 %% First input argument can be the special string "isreal",
-%% "isempty", "islogical", "length", "ndims" or "prodofsize"
+%% "isempty", "islogical", "isnumeric", "length", "ndims" or "prodofsize"
 %!test
 %! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
 %! assert (A, [true, true, false, false, true, true]);
 %!test
 %! A = cellfun ("isempty", {true, 0.1, false, i*2, [], "abc"});
 %! assert (A, [false, false, false, false, true, false]);
 %!test
 %! A = cellfun ("islogical", {true, 0.1, false, i*2, [], "abc"});
 %! assert (A, [true, false, true, false, false, false]);
 %!test
+%! A = cellfun ("isnumeric", {true, 0.1, false, i*2, [], "abc"});
+%! assert (A, [false, true, false, true, true, false]);
+%!test
 %! A = cellfun ("length", {true, 0.1, false, i*2, [], "abc"});
 %! assert (A, [1, 1, 1, 1, 0, 3]);
 %!test
 %! A = cellfun ("ndims", {[1, 2; 3, 4]; (cell (1,2,3,4))});
 %! assert (A, [2; 4]);
 %!test
 %! A = cellfun ("prodofsize", {[1, 2; 3, 4], (cell (1,2,3,4))});
 %! assert (A, [4, 24]);
 
 %% Number of input and output arguments may not be limited to one
 %!test
 %! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5});
 %! assert (A, [6, 7, 8]);
 %!test
-%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, \
+%! A = cellfun (@(x,y,z) x + y + z, {1, 1, 1}, {2, 2, 2}, {3, 4, 5}, ...
 %!              "UniformOutput", false);
 %! assert (A, {6, 7, 8});
 %!test %% Two input arguments of different types
 %! A = cellfun (@(x,y) islogical (x) && ischar (y), {false, true}, {"a", 3});
 %! assert (A, [true, false]);
 %!test %% Pass another variable to the anonymous function
 %! y = true;
 %! A = cellfun (@(x) islogical (x) && y, {false, 0.3});
@@ -819,73 +833,73 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 
 %% Input arguments can be of type cell array of logical
 %!test
 %! A = cellfun (@(x,y) x == y, {false, true}, {true, true});
 %! assert (A, [false, true]);
 %!test
-%! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, \
+%! A = cellfun (@(x,y) x == y, {false; true}, {true; true}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x) x, {false, true; false, true}, "UniformOutput", false);
 %! assert (A, {false, true; false, true});
 %!test %% Three ouptut arguments of same type
-%! [A, B, C] = cellfun (@find, {true, false; false, true}, \
+%! [A, B, C] = cellfun (@find, {true, false; false, true}, ...
 %!                      "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {true}, {true}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type cell array of numeric
 %!test
 %! A = cellfun (@(x,y) x>y, {1.1, 4.2}, {3.1, 2+3*i});
 %! assert (A, [false, true]);
 %!test
-%! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, \
+%! A = cellfun (@(x,y) x>y, {1.1, 4.2; 2, 4}, {3.1, 2; 2, 4+2*i}, ...
 %!              "UniformOutput", true);
 %! assert (A, [false, true; false, false]);
 %!test
 %! A = cellfun (@(x,y) x:y, {1.1, 4}, {3.1, 6}, "UniformOutput", false);
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -894,25 +908,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
@@ -920,80 +934,81 @@ v = cellfun (@@det, a); # faster\n\
 %! vst1.a = 1.1;  vst1.b = 4.2;  vst2.a = 3.1;  vst2.b = 2;
 %! A = cellfun (@(x,y) (x.a < y.a) && (x.b > y.b), vst1, vst2);
 
 %% Input arguments can be of type cell array of cell arrays
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}});
 %! assert (A, [1, 0], 1e-16);
 %!test
-%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, ...
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
-%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "UniformOutput", false);
 %! assert (A, {true, false});
 %!test
-%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
 %! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b), {a}, {b});
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, ...
 %!              "UniformOutput", true);
 %! assert (A, true);
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, \
+%! A = cellfun (@(x,y) (x.a == y.a) && (x.b < y.b) , {a}, {b}, ...
 %!              "UniformOutput", false);
 %! assert (A, {true});
 %!test
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
 %! a = struct ("a", 1, "b", 2);  b = struct ("a", 1, "b", 3);
-%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, \
+%! A = cellfun (@(x,y) cell2str (x.a, y.a), {a}, {b}, ...
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% A lot of other tests
 %!assert (cellfun (@sin, {0,1}), sin ([0,1]))
 %!assert (cellfun (inline ("sin (x)"), {0,1}), sin ([0,1]))
 %!assert (cellfun ("sin", {0,1}), sin ([0,1]))
 %!assert (cellfun ("isempty", {1,[]}), [false,true])
 %!assert (cellfun ("islogical", {false,pi}), [true,false])
+%!assert (cellfun ("isnumeric", {false,pi,struct()}), [false,true,false])
 %!assert (cellfun ("isreal", {1i,1}), [false,true])
 %!assert (cellfun ("length", {zeros(2,2),1}), [2,1])
 %!assert (cellfun ("prodofsize", {zeros(2,2),1}), [4,1])
 %!assert (cellfun ("ndims", {zeros([2,2,2]),1}), [3,2])
 %!assert (cellfun ("isclass", {zeros([2,2,2]),"test"}, "double"), [true,false])
 %!assert (cellfun ("size", {zeros([1,2,3]),1}, 1), [1,1])
 %!assert (cellfun ("size", {zeros([1,2,3]),1}, 2), [2,1])
 %!assert (cellfun ("size", {zeros([1,2,3]),1}, 3), [3,1])
@@ -1051,17 +1066,17 @@ example:\n\
 @example\n\
 @group\n\
 arrayfun (@@atan2, [1, 0], [0, 1])\n\
      @result{} [ 1.5708   0.0000 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{val} after a further string input argument\n\
-\"UniformOutput\" is set @code{true} (the default), then the named\n\
+@qcode{\"UniformOutput\"} is set @code{true} (the default), then the named\n\
 function @var{func} must return a single element which then will be\n\
 concatenated into the return value and is of type matrix.  Otherwise,\n\
 if that parameter is set to @code{false}, then the outputs are\n\
 concatenated in a cell array.  For example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@(x,y) x:y, \"abc\", \"def\", \"UniformOutput\", false)\n\
@@ -1096,33 +1111,33 @@ C =\n\
 @{\n\
    [1,1] =  10\n\
    [2,1] = [](0x0)\n\
 @}\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{errfunc} after a further string input argument\n\
-\"ErrorHandler\" is another string, a function handle, an inline\n\
+@qcode{\"ErrorHandler\"} is another string, a function handle, an inline\n\
 function, or an anonymous function, then @var{errfunc} defines a\n\
 function to call in the case that @var{func} generates an error.\n\
 The definition of the function must be of the form\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
 @noindent\n\
 where there is an additional input argument to @var{errfunc}\n\
 relative to @var{func}, given by @var{s}.  This is a structure with\n\
-the elements \"identifier\", \"message\", and \"index\" giving,\n\
-respectively, the error identifier, the error message, and the index of\n\
-the array elements that caused the error.  The size of the output\n\
-argument of @var{errfunc} must have the same size as the output\n\
-argument of @var{func}, otherwise a real error is thrown.  For\n\
+the elements @qcode{\"identifier\"}, @qcode{\"message\"}, and\n\
+@qcode{\"index\"} giving, respectively, the error identifier, the error\n\
+message, and the index of the array elements that caused the error.  The\n\
+size of the output argument of @var{errfunc} must have the same size as the\n\
+output argument of @var{func}, otherwise a real error is thrown.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 function y = ferr (s, x), y = \"MyString\"; endfunction\n\
 arrayfun (@@str2num, [1234],\n\
           \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
 @result{}\n\
@@ -1540,25 +1555,25 @@ arrayfun (@@str2num, [1234],\n\
 %! A = arrayfun (@(x) x, [false, true, false, true], "UniformOutput", false);
 %! assert (A, {false, true, false, true});
 %!test %% Three ouptut arguments of same type
 %! [A, B, C] = arrayfun (@find, [true, false; false, true], "UniformOutput", false);
 %! assert (isequal (A, {true, []; [], true}));
 %! assert (isequal (B, {true, []; [], true}));
 %! assert (isequal (C, {true, []; [], true}));
 %!test
-%! A = arrayfun (@(x,y) array2str (x,y), true, true, \
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, \
+%! A = arrayfun (@(x,y) array2str (x,y), true, true, "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type numeric
@@ -1573,26 +1588,26 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, ...
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -1602,17 +1617,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], \
+%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
@@ -1628,17 +1643,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x) mat2str(x), "a", "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, \
+%! A = arrayfun (@(x) mat2str(x), "a", "UniformOutput", true, ...
 %!               "ErrorHandler", @__arrayfunerror);
 %! assert (isfield (A, "identifier"), true);
 %! assert (isfield (A, "message"), true);
 %! assert (isfield (A, "index"), true);
 %! assert (isempty (A.message), false);
 %! assert (A.index, 1);
 
 %% Input arguments can be of type cell array
@@ -1654,17 +1669,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, \
+%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, ...
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
@@ -2210,17 +2225,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
           if (error_state)
             return retval;
         }
 
       octave_value a = args(0);
       bool sparse = a.is_sparse_type ();
       if (sparse && nargin > 3)
         {
-          error ("mat2cell: sparse arguments only support 2D indexing");
+          error ("mat2cell: sparse arguments only support 2-D indexing");
           return retval;
         }
 
       switch (a.builtin_type ())
         {
         case btyp_double:
           {
             if (sparse)
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -39,25 +39,25 @@ DEFUN (conv2, args, ,
 @deftypefn  {Built-in Function} {} conv2 (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
 @deftypefnx {Built-in Function} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
-@item @var{shape} = \"full\"\n\
+@item @var{shape} = @qcode{\"full\"}\n\
 Return the full convolution.  (default)\n\
 \n\
-@item @var{shape} = \"same\"\n\
+@item @var{shape} = @qcode{\"same\"}\n\
 Return the central part of the convolution with the same size as @var{A}.\n\
 The central part of the convolution begins at the indices\n\
 @code{floor ([size(@var{B})/2] + 1)}.\n\
 \n\
-@item @var{shape} = \"valid\"\n\
+@item @var{shape} = @qcode{\"valid\"}\n\
 Return only the parts which do not include zero-padded edges.\n\
 The size of the result is @code{max (size (A) - size (B) + 1, 0)}.\n\
 @end table\n\
 \n\
 When the third argument is a matrix, return the convolution of the matrix\n\
 @var{m} by the vector @var{v1} in the column direction and by the vector\n\
 @var{v2} in the row direction.\n\
 @seealso{conv, convn}\n\
@@ -272,17 +272,17 @@ When the third argument is a matrix, ret
 %!assert (conv2 ([1:5;1:5]', [1:2]', "valid"), [4 7 10 13; 4 7 10 13]')
 
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
-%! assert (B, A); ## Yes, this test is for *exact* equivalence.
+%! assert (B, A);   # Yes, this test is for *exact* equivalence.
 
 
 %% Test input validation
 %!error conv2 ()
 %!error conv2 (1)
 %!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
@@ -294,25 +294,25 @@ DEFUN (convn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{C} =} convn (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
-@item @var{shape} = \"full\"\n\
+@item @var{shape} = @qcode{\"full\"}\n\
 Return the full convolution.  (default)\n\
 \n\
-@item @var{shape} = \"same\"\n\
+@item @var{shape} = @qcode{\"same\"}\n\
 Return central part of the convolution with the same size as @var{A}.\n\
 The central part of the convolution begins at the indices\n\
 @code{floor ([size(@var{B})/2] + 1)}.\n\
 \n\
-@item @var{shape} = \"valid\"\n\
+@item @var{shape} = @qcode{\"valid\"}\n\
 Return only the parts which do not include zero-padded edges.\n\
 The size of the result is @code{max (size (A) - size (B) + 1, 0)}.\n\
 @end table\n\
 \n\
 @seealso{conv2, conv}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1090,18 +1090,18 @@ DEFUN (cumsum, args, ,
 @deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
 Cumulative sum of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-See @code{sum} for an explanation of the optional parameters \"native\",\n\
-\"double\", and \"extra\".\n\
+See @code{sum} for an explanation of the optional parameters\n\
+@qcode{\"native\"}, @qcode{\"double\"}, and @qcode{\"extra\"}.\n\
 @seealso{sum, cumprod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -2370,20 +2370,23 @@ returns the original array @var{A}.\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
-Return the \"length\" of the object @var{a}.  For matrix objects, the\n\
-length is the number of rows or columns, whichever is greater (this\n\
-odd definition is used for compatibility with @sc{matlab}).\n\
-@seealso{size}\n\
+Return the length of the object @var{a}.\n\
+\n\
+The length is 0 for empty objects, 1 for scalars, and the number of elements\n\
+for vectors.  For matrix objects, the length is the number of rows or\n\
+columns, whichever is greater (this odd definition is used for compatibility\n\
+with @sc{matlab}).\n\
+@seealso{numel, size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).length ();
   else
     print_usage ();
@@ -2666,36 +2669,36 @@ DEFUN (sum, args, ,
 @deftypefn  {Built-in Function} {} sum (@var{x})\n\
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-If the optional argument \"native\" is given, then the sum is performed\n\
-in the same type as the original argument, rather than in the default\n\
-double type.  For example:\n\
+If the optional argument @qcode{\"native\"} is given, then the sum is\n\
+performed in the same type as the original argument, rather than in the\n\
+default double type.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sum ([true, true])\n\
    @result{} 2\n\
 sum ([true, true], \"native\")\n\
    @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
-On the contrary, if \"double\" is given, the sum is performed in double\n\
-precision even for single precision inputs.\n\
-\n\
-For double precision inputs, \"extra\" indicates that a more accurate\n\
+On the contrary, if @qcode{\"double\"} is given, the sum is performed in\n\
+double precision even for single precision inputs.\n\
+\n\
+For double precision inputs, @qcode{\"extra\"} indicates that a more accurate\n\
 algorithm than straightforward summation is to be used.  For single precision\n\
-inputs, \"extra\" is the same as \"double\".  Otherwise, \"extra\" has no\n\
-effect.\n\
+inputs, @qcode{\"extra\"} is the same as @qcode{\"double\"}.  Otherwise,\n\
+@qcode{\"extra\"} has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -3965,17 +3968,17 @@ produce infinity are division by zero an
 @end example\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{Inf}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{isinf, NaN}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_inf_value (),
                       lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
@@ -4024,17 +4027,17 @@ is specified by the IEEE standard for fl
 find NaN values, use the @code{isnan} function.\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{NaN}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{isnan, Inf}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
@@ -4073,17 +4076,17 @@ to the base of natural logarithms.  The 
 @end ifnottex\n\
 \n\
 When called with no arguments, return a scalar with the value @math{e}.  When\n\
 called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{log, exp, pi, I}\n\
 @end deftypefn")
 {
 #if defined (M_E)
   double e_val = M_E;
 #else
   double e_val = exp (1.0);
 #endif
@@ -4114,17 +4117,17 @@ for single precision.\n\
 When called with no arguments, return a scalar with the value\n\
 @code{eps (1.0)}.\n\
 Given a single argument @var{x}, return the distance between @var{x} and\n\
 the next largest value.\n\
 When called with more than one argument the first two arguments are taken as\n\
 the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{realmax, realmin, intmax, bitmax}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
@@ -4238,17 +4241,17 @@ When called with no arguments, return a 
 @ifnottex\n\
 pi.\n\
 @end ifnottex\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{e, I}\n\
 @end deftypefn")
 {
 #if defined (M_PI)
   double pi_val = M_PI;
 #else
   double pi_val = 4.0 * atan (1.0);
 #endif
@@ -4271,23 +4274,23 @@ floating point arithmetic, @code{realmax
 $1.7977\\times10^{308}$ for double precision and $3.4028\\times10^{38}$\n\
 @end tex\n\
 @ifnottex\n\
 1.7977e+308 for double precision and 3.4028e+38\n\
 @end ifnottex\n\
 for single precision.\n\
 \n\
 When called with no arguments, return a scalar with the value\n\
-@code{realmax (\"double\")}.\n\
+@code{realmax (@qcode{\"double\"})}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{realmin, intmax, bitmax, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, std::numeric_limits<double>::max (),
                       std::numeric_limits<float>::max (), "realmax");
 }
 
 DEFUN (realmin, args, ,
@@ -4305,23 +4308,23 @@ IEEE floating point arithmetic, @code{re
 $2.2251\\times10^{-308}$ for double precision and $1.1755\\times10^{-38}$\n\
 @end tex\n\
 @ifnottex\n\
 2.2251e-308 for double precision and 1.1755e-38\n\
 @end ifnottex\n\
 for single precision.\n\
 \n\
 When called with no arguments, return a scalar with the value\n\
-@code{realmin (\"double\")}.\n\
+@code{realmin (@qcode{\"double\"})}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{realmax, intmin, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, std::numeric_limits<double>::min (),
                       std::numeric_limits<float>::min (), "realmin");
 }
 
 DEFUN (I, args, ,
@@ -4349,17 +4352,17 @@ I, and its equivalents i, j, and J, are 
 be reused for other purposes (such as i for a counter variable).\n\
 \n\
 When called with no arguments, return a scalar with the value @math{i}.  When\n\
 called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{e, pi, log, exp}\n\
 @end deftypefn")
 {
   return fill_matrix (args, Complex (0.0, 1.0), "I");
 }
 
 DEFALIAS (i, I);
 DEFALIAS (J, I);
@@ -4379,17 +4382,17 @@ Note that NA always compares not equal t
 To find NA values, use the @code{isna} function.\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{NA}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
-either \"double\" or \"single\".\n\
+either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_na_value (),
                       lo_ieee_float_na_value (), "NA");
 }
 
 /*
@@ -4778,19 +4781,19 @@ if fewer than two values are requested.\
 %!test
 %! x1 = linspace (1, 2);
 %! x2 = linspace (1, 2, 10);
 %! x3 = linspace (1, -2, 10);
 %! assert (size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2);
 %! assert (size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2);
 %! assert (size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2);
 
-%assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
-
-%assert (linspace (0, 1, []), 1)
+%! ##assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
+
+%!assert (linspace (0, 1, []), 1)
 
 %!error linspace ()
 %!error linspace (1, 2, 3, 4)
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
@@ -5139,55 +5142,55 @@ If @var{A} is a matrix (or sparse matrix
 \n\
 @table @asis\n\
 @item @var{p} = @code{1}\n\
 1-norm, the largest column sum of the absolute values of @var{A}.\n\
 \n\
 @item @var{p} = @code{2}\n\
 Largest singular value of @var{A}.\n\
 \n\
-@item @var{p} = @code{Inf} or @code{\"inf\"}\n\
+@item @var{p} = @code{Inf} or @qcode{\"inf\"}\n\
 @cindex infinity norm\n\
 Infinity norm, the largest row sum of the absolute values of @var{A}.\n\
 \n\
-@item @var{p} = @code{\"fro\"}\n\
+@item @var{p} = @qcode{\"fro\"}\n\
 @cindex Frobenius norm\n\
 Frobenius norm of @var{A}, @code{sqrt (sum (diag (@var{A}' * @var{A})))}.\n\
 \n\
 @item other @var{p}, @code{@var{p} > 1}\n\
 @cindex general p-norm\n\
 maximum @code{norm (A*x, p)} such that @code{norm (x, p) == 1}\n\
 @end table\n\
 \n\
 If @var{A} is a vector or a scalar:\n\
 \n\
 @table @asis\n\
-@item @var{p} = @code{Inf} or @code{\"inf\"}\n\
+@item @var{p} = @code{Inf} or @qcode{\"inf\"}\n\
 @code{max (abs (@var{A}))}.\n\
 \n\
 @item @var{p} = @code{-Inf}\n\
 @code{min (abs (@var{A}))}.\n\
 \n\
-@item @var{p} = @code{\"fro\"}\n\
+@item @var{p} = @qcode{\"fro\"}\n\
 Frobenius norm of @var{A}, @code{sqrt (sumsq (abs (A)))}.\n\
 \n\
 @item @var{p} = 0\n\
 Hamming norm - the number of nonzero elements.\n\
 \n\
 @item other @var{p}, @code{@var{p} > 1}\n\
 p-norm of @var{A}, @code{(sum (abs (@var{A}) .^ @var{p})) ^ (1/@var{p})}.\n\
 \n\
 @item other @var{p} @code{@var{p} < 1}\n\
 the p-pseudonorm defined as above.\n\
 @end table\n\
 \n\
-If @var{opt} is the value @code{\"rows\"}, treat each row as a vector and\n\
+If @var{opt} is the value @qcode{\"rows\"}, treat each row as a vector and\n\
 compute its norm.  The result is returned as a column vector.\n\
-Similarly, if @var{opt} is @code{\"columns\"} or @code{\"cols\"} then compute\n\
-the norms of each column and return a row vector.\n\
+Similarly, if @var{opt} is @qcode{\"columns\"} or @qcode{\"cols\"} then\n\
+compute the norms of each column and return a row vector.\n\
 @seealso{cond, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
@@ -5208,39 +5211,63 @@ the norms of each column and return a ro
                 strflag = sffrob;
               else if (str == "inf")
                 strflag = sfinf;
               else
                 error ("norm: unrecognized option: %s", str.c_str ());
               // we've handled the last parameter, so act as if it was removed
               nargin --;
             }
-          else if (nargin > 1 && ! args(1).is_scalar_type ())
-            gripe_wrong_type_arg ("norm", args(1), true);
 
           if (! error_state)
             {
               octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
-              switch (strflag)
+
+              if (p_arg.is_empty ())
+                p_arg = octave_value (2);
+              else if (p_arg.is_string ())
                 {
-                case sfmatrix:
-                  retval(0) = xnorm (x_arg, p_arg);
-                  break;
-                case sfcols:
-                  retval(0) = xcolnorms (x_arg, p_arg);
-                  break;
-                case sfrows:
-                  retval(0) = xrownorms (x_arg, p_arg);
-                  break;
-                case sffrob:
-                  retval(0) = xfrobnorm (x_arg);
-                  break;
-                case sfinf:
-                  retval(0) = xnorm (x_arg, octave_Inf);
-                  break;
+                  std::string str = p_arg.string_value ();
+                  if ((strflag == sfcols || strflag == sfrows))
+                    {
+                      if (str == "cols" || str == "columns" || str == "rows")
+                        error ("norm: invalid combination of options");
+                      else if (str == "fro")
+                        p_arg = octave_value (2);
+                      else if (str == "inf")
+                        p_arg = octave_Inf;
+                      else
+                        error ("norm: unrecognized option: %s", str.c_str ());
+                    }
+                  else
+                    error ("norm: invalid combination of options");
+                }
+              else if (! p_arg.is_scalar_type ())
+                gripe_wrong_type_arg ("norm", p_arg, true);
+
+              if (! error_state)
+                {
+                  switch (strflag)
+                    {
+                    case sfmatrix:
+                      retval(0) = xnorm (x_arg, p_arg);
+                      break;
+                    case sfcols:
+                      retval(0) = xcolnorms (x_arg, p_arg);
+                      break;
+                    case sfrows:
+                      retval(0) = xrownorms (x_arg, p_arg);
+                      break;
+                    case sffrob:
+                      retval(0) = xfrobnorm (x_arg);
+                      break;
+                    case sfinf:
+                      retval(0) = xnorm (x_arg, octave_Inf);
+                      break;
+                    }
                 }
             }
         }
       else
         error ("norm: only valid for 2-D objects");
     }
   else
     print_usage ();
@@ -5294,16 +5321,28 @@ the norms of each column and return a ro
 %!assert (norm (m,"inf"), single (34))
 %!shared m2, flo, fhi
 %! m2 = single ([1,2;3,4]);
 %! flo = single (1e-300);
 %! fhi = single (1e+300);
 %!assert (norm (flo*m2,"fro"), single (sqrt (30)*flo), -eps ("single"))
 %!assert (norm (fhi*m2,"fro"), single (sqrt (30)*fhi), -eps ("single"))
 
+%!shared q
+%! q = rand (1e3, 3);
+%!assert (norm (q, 3, "rows"), sum (q.^3, 2).^(1/3), sqrt (eps));
+%!assert (norm (q, "fro", "rows"), sum (q.^2, 2).^(1/2), sqrt (eps));
+%!assert (norm (q, "fro", "rows"), sqrt (sumsq (q, 2)), sqrt (eps));
+%!assert (norm (q, "fro", "cols"), sqrt (sumsq (q, 1)), sqrt (eps));
+%!assert (norm (q, 3, "cols"), sum (q.^3, 1).^(1/3), sqrt (eps));
+%!assert (norm (q, "inf", "rows"), norm (q, Inf, "rows"));
+%!assert (norm (q, "inf", "cols"), norm (q, Inf, "cols"));
+%!assert (norm (q, [], "rows"), norm (q, 2, "rows"));
+%!assert (norm (q, [], "cols"), norm (q, 2, "cols"));
+
 %!test
 %! ## Test for norm returning NaN on sparse matrix (bug #30631)
 %! A = sparse (2,2); 
 %! A(2,1) = 1;
 %! assert (norm (A), 1);
 */
 
 static octave_value
@@ -5328,38 +5367,38 @@ Return the logical NOT of @var{x}.  This
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
-This function and @w{@xcode{+ x}} are equivalent.\n\
+This function and @w{@tcode{+ x}} are equivalent.\n\
 @seealso{uminus, plus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uplus, args);
 }
 
 DEFUN (uminus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uminus (@var{x})\n\
-This function and @w{@xcode{- x}} are equivalent.\n\
+This function and @w{@tcode{- x}} are equivalent.\n\
 @seealso{uplus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uminus, args);
 }
 
 DEFUN (transpose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} transpose (@var{x})\n\
 Return the transpose of @var{x}.\n\
-This function and @xcode{x.'} are equivalent.\n\
+This function and @tcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
 
 /*
 %!assert (2.', 2)
@@ -5380,17 +5419,17 @@ This function and @xcode{x.'} are equiva
 
 %!assert (transpose (single ([1,2;3,4])), single ([1,3;2,4]))
 */
 
 DEFUN (ctranspose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
 Return the complex conjugate transpose of @var{x}.\n\
-This function and @xcode{x'} are equivalent.\n\
+This function and @tcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
 
 /*
 %!assert (2', 2)
@@ -5454,17 +5493,17 @@ binary_assoc_op_defun_body (octave_value
 
   return retval;
 }
 
 DEFUN (plus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
-This function and @w{@xcode{x + y}} are equivalent.\n\
+This function and @w{@tcode{x + y}} are equivalent.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5473,29 +5512,29 @@ At least one argument is required.\n\
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
 }
 
 DEFUN (minus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} minus (@var{x}, @var{y})\n\
-This function and @w{@xcode{x - y}} are equivalent.\n\
+This function and @w{@tcode{x - y}} are equivalent.\n\
 @seealso{plus, uminus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
-This function and @w{@xcode{x * y}} are equivalent.\n\
+This function and @w{@tcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5505,39 +5544,39 @@ At least one argument is required.\n\
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
 }
 
 DEFUN (mrdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mrdivide (@var{x}, @var{y})\n\
 Return the matrix right division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x / y}} are equivalent.\n\
+This function and @w{@tcode{x / y}} are equivalent.\n\
 @seealso{mldivide, rdivide, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_div, args);
 }
 
 DEFUN (mpower, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mpower (@var{x}, @var{y})\n\
 Return the matrix power operation of @var{x} raised to the @var{y} power.\n\
-This function and @w{@xcode{x ^ y}} are equivalent.\n\
+This function and @w{@tcode{x ^ y}} are equivalent.\n\
 @seealso{power, mtimes, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x @xbackslashchar{} y}} are equivalent.\n\
+This function and @w{@tcode{x @xbackslashchar{} y}} are equivalent.\n\
 @seealso{mrdivide, ldivide, rdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
   "-*- texinfo -*-\n\
@@ -5601,17 +5640,17 @@ This function is equivalent to @w{@code{
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
-This function and @w{@xcode{x .* y}} are equivalent.\n\
+This function and @w{@tcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
@@ -5621,44 +5660,44 @@ At least one argument is required.\n\
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
 }
 
 DEFUN (rdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rdivide (@var{x}, @var{y})\n\
 Return the element-by-element right division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x ./ y}} are equivalent.\n\
+This function and @w{@tcode{x ./ y}} are equivalent.\n\
 @seealso{ldivide, mrdivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
 @var{y} power.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 \n\
-This function and @w{@xcode{x .^ y}} are equivalent.\n\
+This function and @w{@tcode{x .^ y}} are equivalent.\n\
 @seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x .@xbackslashchar{} y}} are equivalent.\n\
+This function and @w{@tcode{x .@xbackslashchar{} y}} are equivalent.\n\
 @seealso{rdivide, mldivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
@@ -5924,17 +5963,17 @@ sort ([1, 2; 2, 3; 3, 1])\n\
        2  2\n\
        3  3\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is given, then the matrix is sorted\n\
 along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
 defines the order in which the values will be sorted.  Valid values of\n\
-@code{mode} are \"ascend\" or \"descend\".\n\
+@code{mode} are @qcode{\"ascend\"} or @qcode{\"descend\"}.\n\
 \n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
 matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
@@ -6317,21 +6356,21 @@ get_sort_mode_option (const octave_value
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} issorted (@var{a})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, \"rows\", @var{mode})\n\
 Return true if the array is sorted according to @var{mode}, which\n\
-may be either \"ascending\", \"descending\", or \"either\".  By default,\n\
- @var{mode} is \"ascending\".  NaNs are treated in the same manner as\n\
-@code{sort}.\n\
-\n\
-If the optional argument \"rows\" is supplied, check whether\n\
+may be either @qcode{\"ascending\"}, @qcode{\"descending\"}, or\n\
+@qcode{\"either\"}.  By default,  @var{mode} is @qcode{\"ascending\"}.  NaNs\n\
+are treated in the same manner as @code{sort}.\n\
+\n\
+If the optional argument @qcode{\"rows\"} is supplied, check whether\n\
 the array is sorted by rows as output by the function @code{sortrows}\n\
 (with no options).\n\
 \n\
 This function does not support sparse matrices.\n\
 @seealso{sort, sortrows}\n\
 @end deftypefn\n")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -912,18 +912,18 @@ DEFUN (dbtype, args, ,
 @deftypefnx {Command} {} dbtype @var{func}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{lineno}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{startl:endl}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{startl:end}\n\
 Display a script file with line numbers.\n\
 \n\
 When called with no arguments in debugging mode, display the script file\n\
 currently being debugged.  An optional range specification can be used to\n\
-list only a portion of the file.  The special keyword \"end\" is a valid\n\
-line number specification for the last line of the file.\n\
+list only a portion of the file.  The special keyword @qcode{\"end\"} is a\n\
+valid line number specification for the last line of the file.\n\
 \n\
 When called with the name of a function, list that script file with line\n\
 numbers.\n\
 @seealso{dbwhere, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
@@ -1036,17 +1036,17 @@ numbers.\n\
   return retval;
 }
 
 DEFUN (dblist, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dblist\n\
 @deftypefnx {Command} {} dblist @var{n}\n\
 In debugging mode, list @var{n} lines of the function being debugged\n\
-centered around the the current line to be executed.  If unspecified @var{n}\n\
+centered around the current line to be executed.  If unspecified @var{n}\n\
 defaults to 10 (+/- 5 lines)\n\
 @seealso{dbwhere, dbtype}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int n = 10;
 
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -469,21 +469,22 @@ DEFUN (EDITOR, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EDITOR (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the editor to\n\
 use with the @code{edit_history} command.  The default value is taken from\n\
 the environment variable @w{@env{EDITOR}} when Octave starts.  If the\n\
 environment variable is not initialized, @w{@env{EDITOR}} will be set to\n\
-@code{\"emacs\"}.\n\
+@qcode{\"emacs\"}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
 /*
 %!test
@@ -503,19 +504,21 @@ DEFUN (EXEC_PATH, args, nargout,
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to append to the shell PATH when executing external\n\
 programs.  The initial value of is taken from the environment variable\n\
 @w{@env{OCTAVE_EXEC_PATH}}, but that value can be overridden by\n\
 the command line argument @option{--exec-path PATH}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+\n\
+@seealso{IMAGE_PATH, OCTAVE_HOME}\n\
 @end deftypefn")
 {
   octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
   if (args.length () > 0)
     set_exec_path (VEXEC_PATH);
 
   return retval;
@@ -536,19 +539,21 @@ variable value is restored when exiting 
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+\n\
+@seealso{EXEC_PATH, OCTAVE_HOME}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
 /*
 %!test
 %! orig_val = IMAGE_PATH ();
@@ -560,16 +565,18 @@ variable value is restored when exiting 
 
 %!error (IMAGE_PATH (1, 2))
 */
 
 DEFUN (OCTAVE_HOME, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
+\n\
+@seealso{EXEC_PATH, IMAGE_PATH}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Voctave_home;
   else
     print_usage ();
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -89,93 +89,99 @@ octave_change_to_directory (const std::s
   else
     error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Command} {} cd dir\n\
-@deftypefnx {Command} {} chdir dir\n\
-Change the current working directory to @var{dir}.  If @var{dir} is\n\
-omitted, the current directory is changed to the user's home\n\
-directory.  For example,\n\
+@deftypefn  {Command} {} cd @var{dir}\n\
+@deftypefnx {Command} {} cd\n\
+@deftypefnx {Built-in Function} {@var{old_dir} =} cd @var{dir}\n\
+@deftypefnx {Command} {} chdir @dots{}\n\
+Change the current working directory to @var{dir}.\n\
+\n\
+If @var{dir} is omitted, the current directory is changed to the user's home\n\
+directory (@qcode{\"~\"}).\n\
+\n\
+For example,\n\
 \n\
 @example\n\
 cd ~/octave\n\
 @end example\n\
 \n\
 @noindent\n\
 changes the current working directory to @file{~/octave}.  If the\n\
 directory does not exist, an error message is printed and the working\n\
 directory is not changed.\n\
-@seealso{mkdir, rmdir, dir}\n\
+\n\
+@code{chdir} is an alias for @code{cd} and can be used in all of the same\n\
+calling formats.\n\
+\n\
+Compatibility Note: When called with no arguments, @sc{matlab} prints the\n\
+present working directory rather than changing to the user's home directory.\n\
+@seealso{pwd, mkdir, rmdir, dir, ls}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("cd");
 
   if (error_state)
     return retval;
 
+  if (nargout > 0)
+    retval = octave_value (octave_env::get_current_directory ());
+
   if (argc > 1)
     {
       std::string dirname = argv[1];
 
-      if (dirname.length () > 0
-          && ! octave_change_to_directory (dirname))
-        {
-          return retval;
-        }
+      if (dirname.length () > 0)
+        octave_change_to_directory (dirname);
     }
   else
     {
-      // Behave like Unixy shells for "cd" by itself, but be Matlab
-      // compatible if doing "current_dir = cd".
+      std::string home_dir = octave_env::get_home_directory ();
 
-      if (nargout == 0)
-        {
-          std::string home_dir = octave_env::get_home_directory ();
-
-          if (home_dir.empty () || ! octave_change_to_directory (home_dir))
-            return retval;
-        }
-      else
-        retval = octave_value (octave_env::get_current_directory ());
+      if (! home_dir.empty ())
+        octave_change_to_directory (home_dir);
     }
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 DEFUN (pwd, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} pwd ()\n\
+@deftypefn  {Built-in Function} {} pwd ()\n\
+@deftypefnx {Built-in Function} {@var{dir} =} pwd ()\n\
 Return the current working directory.\n\
-@seealso{dir, ls}\n\
+@seealso{cd, dir, ls, mkdir, rmdir}\n\
 @end deftypefn")
 {
   return octave_value (octave_env::get_current_directory ());
 }
 
 DEFUN (readdir, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
-Return names of the files in the directory @var{dir} as a cell array of\n\
-strings.  If an error occurs, return an empty cell array in @var{files}.\n\
+@deftypefn  {Built-in Function} {@var{files} =} readdir (@var{dir})\n\
+@deftypefnx {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
+Return the names of files in the directory @var{dir} as a cell array of\n\
+strings.\n\
 \n\
+If an error occurs, return an empty cell array in @var{files}.\n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
-@seealso{ls, dir, glob}\n\
+@seealso{ls, dir, glob, what}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Cell ();
 
@@ -202,30 +208,34 @@ system-dependent error message.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-// FIXME -- should maybe also allow second arg to specify
-// mode?  OTOH, that might cause trouble with compatibility later...
+// FIXME: should maybe also allow second arg to specify mode?
+//        OTOH, that might cause trouble with compatibility later...
 
 DEFUNX ("mkdir", Fmkdir, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{dir})\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@var{parent}, @var{dir})\n\
+@deftypefn  {Built-in Function} {} mkdir @var{dir}\n\
+@deftypefnx {Built-in Function} {} mkdir (@var{parent}, @var{dir})\n\
+@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})\n\
 Create a directory named @var{dir} in the directory @var{parent}.\n\
 \n\
-If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
-character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
-system-dependent error message, and @var{msgid} contains a unique\n\
-message identifier.\n\
-@seealso{rmdir}\n\
+If no @var{parent} directory is specified the present working directory is\n\
+used.\n\
+\n\
+If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
+character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
+system-dependent error message, and @var{msgid} contains a unique message\n\
+identifier.\n\
+@seealso{rmdir, pwd, cd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
@@ -290,28 +300,29 @@ message identifier.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir})\n\
-@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@var{dir}, \"s\")\n\
+@deftypefn  {Built-in Function} {} rmdir @var{dir}\n\
+@deftypefnx {Built-in Function} {} rmdir (@var{dir}, \"s\")\n\
+@deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})\n\
 Remove the directory named @var{dir}.\n\
 \n\
-If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty\n\
-character strings.  Otherwise, @var{status} is 0, @var{msg} contains a\n\
-system-dependent error message, and @var{msgid} contains a unique\n\
-message identifier.\n\
+If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
+character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
+system-dependent error message, and @var{msgid} contains a unique message\n\
+identifier.\n\
 \n\
-If the optional second parameter is supplied with value @code{\"s\"},\n\
+If the optional second parameter is supplied with value @qcode{\"s\"},\n\
 recursively remove all subdirectories as well.\n\
-@seealso{mkdir, confirm_recursive_rmdir}\n\
+@seealso{mkdir, confirm_recursive_rmdir, pwd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
@@ -364,23 +375,24 @@ recursively remove all subdirectories as
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
+@deftypefn  {Built-in Function} {} link @var{old} @var{new}\n\
+@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
 Create a new link (also known as a hard link) to an existing file.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
-@seealso{symlink}\n\
+@seealso{symlink, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
@@ -396,38 +408,38 @@ system-dependent error message.\n\
           if (error_state)
             gripe_wrong_type_arg ("link", args(1));
           else
             {
               std::string msg;
 
               int status = octave_link (from, to, msg);
 
-              retval(0) = status;
-
               if (status < 0)
                 retval(1) = msg;
+              retval(0) = status;
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
+@deftypefn  {Built-in Function} {} symlink @var{old} @var{new}\n\
+@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
 Create a symbolic link @var{new} which contains the string @var{old}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
-@seealso{link, readlink}\n\
+@seealso{link, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
@@ -443,39 +455,39 @@ system-dependent error message.\n\
           if (error_state)
             gripe_wrong_type_arg ("symlink", args(1));
           else
             {
               std::string msg;
 
               int status = octave_symlink (from, to, msg);
 
-              retval(0) = status;
-
               if (status < 0)
                 retval(1) = msg;
+              retval(0) = status;
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
+@deftypefn  {Built-in Function} {} readlink @var{symlink}\n\
+@deftypefnx {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
 Read the value of the symbolic link @var{symlink}.\n\
 \n\
 If successful, @var{result} contains the contents of the symbolic link\n\
-@var{symlink}, @var{err} is 0 and @var{msg} is an empty string.\n\
-Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
-system-dependent error message.\n\
-@seealso{link, symlink}\n\
+@var{symlink}, @var{err} is 0, and @var{msg} is an empty string.\n\
+Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
+error message.\n\
+@seealso{lstat, symlink, link, unlink, delete}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = std::string ();
 
@@ -501,23 +513,24 @@ system-dependent error message.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
+@deftypefn  {Built-in Function} {} rename @var{old} @var{new}\n\
+@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
 Change the name of file @var{old} to @var{new}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
-@seealso{ls, dir}\n\
+@seealso{movefile, copyfile, ls, dir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
@@ -533,20 +546,19 @@ system-dependent error message.\n\
           if (error_state)
             gripe_wrong_type_arg ("rename", args(1));
           else
             {
               std::string msg;
 
               int status = octave_rename (from, to, msg);
 
-              retval(0) = status;
-
               if (status < 0)
                 retval(1) = msg;
+              retval(0) = status;
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
@@ -566,19 +578,18 @@ matches any string, including the null s
 \n\
 @item ?\n\
 matches any single character, and\n\
 \n\
 @item [@dots{}]\n\
 matches any of the enclosed characters.\n\
 @end table\n\
 \n\
-Tilde expansion\n\
-is performed on each of the patterns before looking for matching file\n\
-names.  For example:\n\
+Tilde expansion is performed on each of the patterns before looking for\n\
+matching file names.  For example:\n\
 \n\
 @example\n\
 ls\n\
    @result{}\n\
       file1  file2  file3  myfile1 myfile1b\n\
 glob (\"*file1\")\n\
    @result{}\n\
       @{\n\
@@ -592,17 +603,17 @@ glob (\"myfile?\")\n\
       @}\n\
 glob (\"file[12]\")\n\
    @result{}\n\
       @{\n\
         [1,1] = file1\n\
         [2,1] = file2\n\
       @}\n\
 @end example\n\
-@seealso{ls, dir, readdir}\n\
+@seealso{ls, dir, readdir, what, fnmatch}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       string_vector pat = args(0).all_strings ();
 
@@ -623,17 +634,17 @@ glob (\"file[12]\")\n\
 
 /*
 %!test
 %! tmpdir = tmpnam;
 %! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
 %! if (mkdir (tmpdir))
 %!   cwd = pwd;
 %!   cd (tmpdir);
-%!   if strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir))
+%!   if (strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir)))
 %!     a = 0;
 %!     for n = 1:5
 %!       save (filename{n}, "a");
 %!     endfor
 %!   else
 %!     rmdir (tmpdir);
 %!     error ("Couldn't change to temporary dir");
 %!   endif
@@ -651,26 +662,27 @@ glob (\"file[12]\")\n\
 %! assert (result1, {"file1"; "myfile1"});
 %! assert (result2, {"myfile1"});
 %! assert (result3, {"file1"; "file2"});
 */
 
 DEFUNX ("fnmatch", Ffnmatch, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
-Return 1 or zero for each element of @var{string} that matches any of\n\
+Return true or false for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 filename pattern matching.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})\n\
      @result{} [ 1; 1; 0 ]\n\
 @end group\n\
 @end example\n\
+@seealso{glob, regexp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       string_vector pat = args(0).all_strings ();
       string_vector str = args(1).all_strings ();
@@ -691,18 +703,18 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
 }
 
 DEFUN (filesep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} filesep ()\n\
 @deftypefnx {Built-in Function} {} filesep (\"all\")\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
-If \"all\" is given, the function returns all valid file separators in\n\
-the form of a string.  The list of file separators is system-dependent.\n\
+If @qcode{\"all\"} is given, the function returns all valid file separators\n\
+in the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
 @seealso{pathsep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
@@ -775,15 +787,16 @@ Query or set the character used to separ
 DEFUN (confirm_recursive_rmdir, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} confirm_recursive_rmdir (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will ask for confirmation before recursively removing a directory tree.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+@seealso{rmdir}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (confirm_recursive_rmdir);
 }
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -168,24 +168,25 @@ separation character is defined by @var{
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
 The @var{range} parameter may be a 4-element vector containing the upper\n\
 left and lower right corner @code{[@var{R0},@var{C0},@var{R1},@var{C1}]}\n\
 where the lowest index value is zero.  Alternatively, a spreadsheet style\n\
-range such as \"A2..Q15\" or \"T1:AA5\" can be used.  The lowest alphabetical\n\
-index 'A' refers to the first column.  The lowest row index is 1.\n\
+range such as @qcode{\"A2..Q15\"} or @qcode{\"T1:AA5\"} can be used.  The\n\
+lowest alphabetical index @qcode{'A'} refers to the first column.  The\n\
+lowest row index is 1.\n\
 \n\
 @var{file} should be a file name or file id given by @code{fopen}.  In the\n\
 latter case, the file is read until end of file is reached.\n\
 \n\
-The \"emptyvalue\" option may be used to specify the value used to fill empty\n\
-fields.  The default is zero.\n\
+The @qcode{\"emptyvalue\"} option may be used to specify the value used to\n\
+fill empty fields.  The default is zero.\n\
 @seealso{csvread, textscan, textread, dlmwrite}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   double empty_value = 0.0;
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -1,11 +1,11 @@
 /*
 
-// Author: Leopoldo Cerbaro <redbliss@libero.it>
+Copyright (C) 2013 Leopoldo Cerbaro <redbliss@libero.it>
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -21,158 +21,61 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "lo-ieee.h"
+#include "lo-specfun.h"
 
 static void
 gripe_ellipj_arg (const char *arg)
 {
   error ("ellipj: expecting scalar or matrix as %s argument", arg);
 }
 
-static void
-sncndn (double u, double m, double& sn, double& cn, double& dn, double& err)
-{
-  static const int Nmax = 16;
-  double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
-  int n, Nn, ii;
-
-  if (m < 0 || m > 1)
-    {
-      warning ("ellipj: expecting 0 <= m <= 1"); /* -lc- */
-      sn = cn = dn = lo_ieee_nan_value ();
-      return;
-    }
-
-  double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
-  if (m < sqrt_eps)
-    {
-      /*  # For small m, ( Abramowitz and Stegun, Section 16.13 ) */
-      si_u = sin (u);
-      co_u = cos (u);
-      t = 0.25*m*(u - si_u*co_u);
-      sn = si_u - t * co_u;
-      cn = co_u + t * si_u;
-      dn = 1 - 0.5*m*si_u*si_u;
-    }
-  else if ((1 - m) < sqrt_eps)
-    {
-      /*  For m1 = (1-m) small ( Abramowitz and Stegun, Section 16.15 ) */
-      m1 = 1 - m;
-      si_u = sinh (u);
-      co_u = cosh (u);
-      ta_u = tanh (u);
-      se_u = 1/co_u;
-      sn = ta_u + 0.25*m1*(si_u*co_u - u)*se_u*se_u;
-      cn = se_u - 0.25*m1*(si_u*co_u - u)*ta_u*se_u;
-      dn = se_u + 0.25*m1*(si_u*co_u + u)*ta_u*se_u;
-    }
-  else
-    {
-      /*
-      //  Arithmetic-Geometric Mean (AGM) algorithm
-      //    ( Abramowitz and Stegun, Section 16.4 )
-      */
-
-      a[0] = 1;
-      b    = sqrt (1 - m);
-      c[0] = sqrt (m);
-      for (n = 1; n < Nmax; ++n)
-        {
-          a[n] = (a[n - 1] + b)/2;
-          c[n] = (a[n - 1] - b)/2;
-          b = sqrt (a[n - 1]*b);
-          if (c[n]/a[n] < std::numeric_limits<double>::epsilon ()) break;
-        }
-      if (n >= Nmax - 1)
-        {
-          err = 1;
-          return;
-        }
-      Nn = n;
-      for (ii = 1; n > 0; ii = ii*2, --n) ; // ii = pow(2,Nn)
-      phi = ii*a[Nn]*u;
-      for (n = Nn; n > 0; --n)
-        {
-          t = phi;
-          phi = (asin ((c[n]/a[n])* sin (phi)) + phi)/2;
-        }
-      sn = sin (phi);
-      cn = cos (phi);
-      dn = cn/cos (t - phi);
-    }
-}
-
-static void
-sncndn (Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
-        double& err)
-{
-  double m1 = 1 - m, ss1, cc1, dd1;
-
-  sncndn (imag (u), m1, ss1, cc1, dd1, err);
-  if (real (u) == 0)
-    {
-      /* u is pure imag: Jacoby imag. transf. */
-      sn = Complex (0, ss1/cc1);
-      cn = 1/cc1;         //    cn.imag = 0;
-      dn = dd1/cc1;       //    dn.imag = 0;
-    }
-  else
-    {
-      /* u is generic complex */
-      double ss, cc, dd, ddd;
-
-      sncndn (real (u), m, ss, cc, dd, err);
-      ddd = cc1*cc1 + m*ss*ss*ss1*ss1;
-      sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
-      cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
-      dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
-    }
-}
-
 DEFUN (ellipj, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m})\n\
 @deftypefnx {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m}, @var{tol})\n\
 Compute the Jacobi elliptic functions @var{sn}, @var{cn}, and @var{dn}\n\
 of complex argument @var{u} and real parameter @var{m}.\n\
 \n\
 If @var{m} is a scalar, the results are the same size as @var{u}.\n\
 If @var{u} is a scalar, the results are the same size as @var{m}.\n\
 If @var{u} is a column vector and @var{m} is a row vector, the\n\
 results are matrices with @code{length (@var{u})} rows and\n\
 @code{length (@var{m})} columns.  Otherwise, @var{u} and\n\
-@var{m} must conform and the results will be the same size.\n\
+@var{m} must conform in size and the results will be the same size as the\n\
+inputs.\n\
 \n\
 The value of @var{u} may be complex.\n\
-The value of @var{m} must be 0 @leq{} m @leq{} 1.\n\
+The value of @var{m} must be 0 @leq{} @var{m} @leq{} 1.\n\
 \n\
-@var{tol} is currently ignored (@sc{matlab} uses this to allow faster,\n\
-less accurate approximation).\n\
+The optional input @var{tol} is currently ignored (@sc{matlab} uses this to\n\
+allow faster, less accurate approximation).\n\
 \n\
 If requested, @var{err} contains the following status information\n\
 and is the same size as the result.\n\
 \n\
 @enumerate 0\n\
 @item\n\
 Normal return.\n\
 \n\
 @item\n\
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
- Ref: Abramowitz, Milton and Stegun, Irene A\n\
-      Handbook of Mathematical Functions, Dover, 1965\n\
-      Chapter 16 (Sections 16.4, 16.13 and 16.15)\n\
+\n\
+Reference: Milton Abramowitz and Irene A Stegun,\n\
+@cite{Handbook of Mathematical Functions}, Chapter 16 (Sections 16.4, 16.13,\n\
+and 16.15), Dover, 1965.\n\
+\n\
 @seealso{ellipke}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
@@ -192,291 +95,342 @@ return @code{NaN}.\n\
         {
           gripe_ellipj_arg ("second");
           return retval;
         }
 
       if (u_arg.is_scalar_type ())
         {
           if (u_arg.is_real_type ())
-            {  // u real
+            {  // u real, m scalar
               double u = args(0).double_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
+
               double sn, cn, dn;
               double err = 0;
 
-              sncndn (u, m, sn, cn, dn, err);
-              retval (0) = sn;
-              retval (1) = cn;
-              retval (2) = dn;
-              if (nargout > 3) retval(3) =  err;
+              ellipj (u, m, sn, cn, dn, err);
+
+              if (nargout > 3)
+                retval(3) = err;
+              retval(2) = dn;
+              retval(1) = cn;
+              retval(0) = sn;
             }
           else
-            {  // u complex
+            {  // u complex, m scalar
               Complex u = u_arg.complex_value ();
 
               if (error_state)
                 {
-                  gripe_ellipj_arg ("second");
+                  gripe_ellipj_arg ("first");
                   return retval;
                 }
 
               Complex sn, cn, dn;
-              double err;
+              double err = 0;
 
-              sncndn (u, m, sn, cn, dn, err);
+              ellipj (u, m, sn, cn, dn, err);
 
-              retval (0) = sn;
-              retval (1) = cn;
-              retval (2) = dn;
-              if (nargout > 3) retval(3) = err;
+              if (nargout > 3)
+                retval(3) = err;
+              retval(2) = dn;
+              retval(1) = cn;
+              retval(0) = sn;
             }
         }
       else
-        {  /* u is matrix ( m is scalar ) */
-          ComplexMatrix u = u_arg.complex_matrix_value ();
-
+        {  // u is matrix, m is scalar
+          ComplexNDArray u = u_arg.complex_array_value ();
+          
           if (error_state)
             {
               gripe_ellipj_arg ("first");
               return retval;
             }
 
-          octave_idx_type nr = u.rows ();
-          octave_idx_type nc = u.cols ();
+          dim_vector sz_u = u.dims ();
 
-          ComplexMatrix sn (nr, nc), cn (nr, nc), dn (nr, nc);
-          Matrix err (nr, nc);
+          ComplexNDArray sn (sz_u), cn (sz_u), dn (sz_u);
+          NDArray err (sz_u);
 
-          for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = 0; i < nr; i++)
-              sncndn (u(i,j), m, sn(i,j), cn(i,j), dn(i,j), err(i,j));
+          const Complex *pu = u.data ();
+          Complex *psn = sn.fortran_vec ();
+          Complex *pcn = cn.fortran_vec ();
+          Complex *pdn = dn.fortran_vec ();
+          double *perr = err.fortran_vec ();
+          octave_idx_type nel = u.numel ();
 
-          retval (0) = sn;
-          retval (1) = cn;
-          retval (2) = dn;
-          if (nargout > 3) retval(3) = err;
+          for (octave_idx_type i = 0; i < nel; i++)
+            ellipj (pu[i], m, psn[i], pcn[i], pdn[i], perr[i]);
+
+          if (nargout > 3)
+            retval(3) = err;
+          retval(2) = dn;
+          retval(1) = cn;
+          retval(0) = sn;
         }
     }
   else
     {
-      Matrix m = args(1).matrix_value ();
+      NDArray m = args(1).array_value ();
 
       if (error_state)
         {
           gripe_ellipj_arg ("second");
           return retval;
         }
 
-      octave_idx_type mr = m.rows ();
-      octave_idx_type mc = m.cols ();
+      dim_vector sz_m = m.dims ();
 
       if (u_arg.is_scalar_type ())
-        {    /* u is scalar */
-          octave_idx_type nr = m.rows ();
-          octave_idx_type nc = m.cols ();
-          Matrix err (nr, nc);
-
+        {  // u is scalar, m is array
           if (u_arg.is_real_type ())
-            {
+            {  // u is real scalar, m is array
               double u = u_arg.double_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
-              Matrix sn (nr, nc), cn (nr, nc), dn (nr, nc);
-              for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = 0; i < nr; i++)
-                  sncndn (u, m(i,j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
+              NDArray sn (sz_m), cn (sz_m), dn (sz_m);
+              NDArray err (sz_m);
 
-              retval (0) = sn;
-              retval (1) = cn;
-              retval (2) = dn;
-              if (nargout > 3)  retval(3) = err;
+              const double *pm = m.data ();
+              double *psn = sn.fortran_vec ();
+              double *pcn = cn.fortran_vec ();
+              double *pdn = dn.fortran_vec ();
+              double *perr = err.fortran_vec ();
+              octave_idx_type nel = m.numel ();
+
+              for (octave_idx_type i = 0; i < nel; i++)
+                ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+
+              if (nargout > 3)
+                retval(3) = err;
+              retval(2) = dn;
+              retval(1) = cn;
+              retval(0) = sn;
             }
           else
-            {
+            {  // u is complex scalar, m is array
               Complex u = u_arg.complex_value ();
+
+              if (error_state)
+                {
+                  gripe_ellipj_arg ("first");
+                  return retval;
+                }
+
+              ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
+              NDArray err (sz_m);
+
+              const double *pm = m.data ();
+              Complex *psn = sn.fortran_vec ();
+              Complex *pcn = cn.fortran_vec ();
+              Complex *pdn = dn.fortran_vec ();
+              double *perr = err.fortran_vec ();
+              octave_idx_type nel = m.numel ();
+
+              for (octave_idx_type i = 0; i < nel; i++)
+                ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+
+              if (nargout > 3)
+                retval(3) = err;
+              retval(2) = dn;
+              retval(1) = cn;
+              retval(0) = sn;
+            }
+        }
+      else
+        {  // u is array, m is array
+          if (u_arg.is_real_type ())
+            {  // u is real array, m is array
+              NDArray u = u_arg.array_value ();
+
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
-              ComplexMatrix sn (nr, nc), cn (nr, nc), dn (nr, nc);
-              for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = 0; i < nr; i++)
-                  sncndn (u, m(i,j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
-              retval (0) = sn;
-              retval (1) = cn;
-              retval (2) = dn;
-              if (nargout > 3)  retval(3) = err;
-            }
-        }
-      else
-        {    // u is matrix  (m is matrix)
-          if (u_arg.is_real_type ())
-            {  // u real matrix
+              dim_vector sz_u = u.dims ();
 
-              Matrix u = u_arg.matrix_value ();
-              if (error_state)
-                {
-                  gripe_ellipj_arg ("first ");
-                  return retval;
-                }
+              if (sz_u.length () == 2 && sz_m.length () == 2
+                  && sz_u(1) == 1 && sz_m(0) == 1)
+                {  // u is real column vector, m is row vector
+                  octave_idx_type ur = sz_u(0);
+                  octave_idx_type mc = sz_m(1);
+                  dim_vector sz_out (ur, mc);
 
-              octave_idx_type ur = u.rows ();
-              octave_idx_type uc = u.cols ();
+                  NDArray sn (sz_out), cn (sz_out), dn (sz_out);
+                  NDArray err (sz_out);
 
-              if (mr == 1 && uc == 1)
-                {  // u column, m row
-                  RowVector rm = m.row (0);
-                  ColumnVector cu = u.column (0);
-
-                  Matrix sn (ur, mc), cn (ur, mc), dn (ur, mc);
-                  Matrix err (ur,mc);
+                  const double *pu = u.data ();
+                  const double *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      sncndn (cu(i), rm(j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
 
-                  retval (0) = sn;
-                  retval (1) = cn;
-                  retval (2) = dn;
-                  if (nargout > 3)  retval(3) = err;
+                  if (nargout > 3)
+                    retval(3) = err;
+                  retval(2) = dn;
+                  retval(1) = cn;
+                  retval(0) = sn;
                 }
-              else if (ur == mr && uc == mc)
+              else if (sz_m == sz_u)
                 {
-                  Matrix sn (ur, mc), cn (ur, mc), dn (ur, mc);
-                  Matrix err (ur,mc);
+                  NDArray sn (sz_m), cn (sz_m), dn (sz_m);
+                  NDArray err (sz_m);
 
-                  for (octave_idx_type j = 0; j < uc; j++)
-                    for (octave_idx_type i = 0; i < ur; i++)
-                      sncndn (u(i,j), m(i,j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                  const double *pu = u.data ();
+                  const double *pm = m.data ();
+                  double *psn = sn.fortran_vec ();
+                  double *pcn = cn.fortran_vec ();
+                  double *pdn = dn.fortran_vec ();
+                  double *perr = err.fortran_vec ();
+                  octave_idx_type nel = m.numel ();
 
-                  retval (0) = sn;
-                  retval (1) = cn;
-                  retval (2) = dn;
-                  if (nargout > 3)  retval(3) = err;
+                  for (octave_idx_type i = 0; i < nel; i++)
+                    ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+
+                  if (nargout > 3)
+                    retval(3) = err;
+                  retval(2) = dn;
+                  retval(1) = cn;
+                  retval(0) = sn;
                 }
               else
-                error ("u m invalid");
+                error ("ellipj: Invalid size combination for U and M");
             }
           else
-            {  // u complex matrix
-              ComplexMatrix u = u_arg.complex_matrix_value ();
+            {  // u is complex array, m is array
+              ComplexNDArray u = u_arg.complex_array_value ();
+
               if (error_state)
                 {
                   gripe_ellipj_arg ("second");
                   return retval;
                 }
 
-              octave_idx_type ur = u.rows ();
-              octave_idx_type uc = u.cols ();
+              dim_vector sz_u = u.dims ();
 
-              if (mr == 1 && uc == 1)
-                {
-                  RowVector rm = m.row (0);
-                  ComplexColumnVector cu = u.column (0);
+              if (sz_u.length () == 2 && sz_m.length () == 2
+                  && sz_u(1) == 1 && sz_m(0) == 1)
+                {  // u is complex column vector, m is row vector
+                  octave_idx_type ur = sz_u(0);
+                  octave_idx_type mc = sz_m(1);
+                  dim_vector sz_out (ur, mc);
 
-                  ComplexMatrix sn (ur, mc), cn (ur, mc), dn (ur, mc);
-                  Matrix err (ur,mc);
+                  ComplexNDArray sn (sz_out), cn (sz_out), dn (sz_out);
+                  NDArray err (sz_out);
+
+                  const Complex *pu = u.data ();
+                  const double  *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      sncndn (cu(i), rm(j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
 
-                  retval (0) = sn;
-                  retval (1) = cn;
-                  retval (2) = dn;
-                  if (nargout > 3)  retval(3) = err;
+                  if (nargout > 3)
+                    retval(3) = err;
+                  retval(2) = dn;
+                  retval(1) = cn;
+                  retval(0) = sn;
                 }
-              else if (ur == mr && uc == mc)
+              else if (sz_m == sz_u)
                 {
-                  ComplexMatrix sn (ur, mc), cn (ur, mc), dn (ur, mc);
-                  Matrix err (ur,mc);
+                  ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
+                  NDArray err (sz_m);
 
-                  for (octave_idx_type j = 0; j < uc; j++)
-                    for (octave_idx_type i = 0; i < ur; i++)
-                      sncndn (u(i,j), m(i,j), sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                  const Complex *pu = u.data ();
+                  const double  *pm = m.data ();
+                  Complex *psn = sn.fortran_vec ();
+                  Complex *pcn = cn.fortran_vec ();
+                  Complex *pdn = dn.fortran_vec ();
+                  double *perr = err.fortran_vec ();
+                  octave_idx_type nel = m.numel ();
 
-                  retval (0) = sn;
-                  retval (1) = cn;
-                  retval (2) = dn;
-                  if (nargout > 3)  retval(3) = err;
+                  for (octave_idx_type i = 0; i < nel; i++)
+                    ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+
+                  if (nargout > 3)
+                    retval(3) = err;
+                  retval(2) = dn;
+                  retval(1) = cn;
+                  retval(0) = sn;
                 }
               else
-                error ("u m invalid");
+                error ("ellipj: Invalid size combination for U and M");
             }
         }
     }  // m matrix
 
   return retval;
 }
 
 /*
 ## demos taken from inst/ellipj.m
 
 %!demo
 %! N = 150;
-%! % m = [1-logspace(0,log(eps),N-1), 1]; ## m near 1
-%! % m = [0, logspace(log(eps),0,N-1)];   ## m near 0
-%!   m = linspace(0,1,N);                 ## m equally spaced
-%! u = linspace(-20,20,N);
-%! M = ones(length(u),1) * m;
-%! U = u' * ones(1, length(m));
-%! [sn, cn, dn] = ellipj(U,M);
+%! # m = [1-logspace(0,log(eps),N-1), 1]; # m near 1
+%! # m = [0, logspace(log(eps),0,N-1)];   # m near 0
+%!   m = linspace (0,1,N);                # m equally spaced
+%! u = linspace (-20, 20, N);
+%! M = ones (length (u), 1) * m;
+%! U = u' * ones (1, length (m));
+%! [sn, cn, dn] = ellipj (U,M);
 %!
-%! %% Plotting
-%! c = colormap(hot(64));
+%! ## Plotting
 %! data = {sn,cn,dn};
 %! dname = {"sn","cn","dn"};
 %! for i=1:3
-%!   subplot(1,3,i);
+%!   subplot (1,3,i);
 %!   data{i}(data{i} > 1) = 1;
 %!   data{i}(data{i} < -1) = -1;
-%!   image(m,u,32*data{i}+32);
-%!   title(dname{i});
-%! end
-%! colormap(c);
+%!   image (m,u,32*data{i}+32);
+%!   title (dname{i});
+%! endfor
+%! colormap (hot (64));
 
 %!demo
 %! N = 200;
-%! % m = [1-logspace(0,log(eps),N-1), 1]; ## m near 1
-%! % m = [0, logspace(log(eps),0,N-1)];   ## m near 0
-%!   m = linspace(0,1,N);                 ## m equally spaced
-%! u = linspace(0,20,5);
-%! M = ones(length(u),1) * m;
-%! U = u' * ones(1, length(m));
-%! [sn, cn, dn] = ellipj(U,M);
+%! # m = [1-logspace(0,log(eps),N-1), 1]; # m near 1
+%! # m = [0, logspace(log(eps),0,N-1)];   # m near 0
+%!   m = linspace (0,1,N);                # m equally spaced
+%! u = linspace (0,20,5);
+%! M = ones (length (u), 1) * m;
+%! U = u' * ones (1, length (m));
+%! [sn, cn, dn] = ellipj (U,M);
 %!
-%! %% Plotting
+%! ## Plotting
 %! data = {sn,cn,dn};
 %! dname = {"sn","cn","dn"};
 %! for i=1:3
-%!   subplot(1,3,i);
-%!   plot(m, data{i});
-%!   title(dname{i});
+%!   subplot (1,3,i);
+%!   plot (m, data{i});
+%!   title (dname{i});
 %!   grid on;
-%! end
+%! endfor
 */
 
 /*
 ## tests taken from inst/test_sncndn.m
 
 %!test
-%! k = (tan(pi/8.))^2; m = k*k;
+%! k = (tan(pi/8.))^2;  m = k*k;
 %! SN = [
 %! -1. + I * 0. ,  -0.8392965923 + 0. * I
 %! -1. + I * 0.2 ,  -0.8559363407 + 0.108250955 * I
 %! -1. + I * 0.4 ,  -0.906529758 + 0.2204040232 * I
 %! -1. + I * 0.6 ,  -0.9931306727 + 0.3403783409 * I
 %! -1. + I * 0.8 ,  -1.119268095 + 0.4720784944 * I
 %! -1. + I * 1. ,  -1.29010951 + 0.6192468708 * I
 %! -1. + I * 1.2 ,  -1.512691987 + 0.7850890595 * I
@@ -843,105 +797,132 @@ return @code{NaN}.\n\
 %! ];
 %! tol = 1e-9;
 %! for x = 0:10
 %!   for y = 0:10
 %!     ur = -1 + x * 0.2;
 %!     ui =  y * 0.2;
 %!     ii = 1 + y + x*11;
 %!     [sn, cn, dn] = ellipj (ur + I * ui, m);
-%!     assert (SN (ii, 2), sn, tol);
-%!     assert (CN (ii, 2), cn, tol);
-%!     assert (DN (ii, 2), dn, tol);
+%!     assert (sn, SN(ii, 2), tol);
+%!     assert (cn, CN(ii, 2), tol);
+%!     assert (dn, DN(ii, 2), tol);
 %!   endfor
 %! endfor
 
 ## tests taken from test_ellipj.m
 %!test
 %! u1 = pi/3; m1 = 0;
 %! res1 = [sin(pi/3), cos(pi/3), 1];
-%! [sn,cn,dn]=ellipj(u1,m1);
-%! assert([sn,cn,dn], res1, 10*eps);
+%! [sn,cn,dn] = ellipj (u1,m1);
+%! assert ([sn,cn,dn], res1, 10*eps);
 
 %!test
 %! u2 = log(2); m2 = 1;
 %! res2 = [ 3/5, 4/5, 4/5 ];
-%! [sn,cn,dn]=ellipj(u2,m2);
-%! assert([sn,cn,dn], res2, 10*eps);
+%! [sn,cn,dn] = ellipj (u2,m2);
+%! assert ([sn,cn,dn], res2, 10*eps);
 
 %!test
 %! u3 = log(2)*1i; m3 = 0;
 %! res3 = [3i/4,5/4,1];
-%! [sn,cn,dn]=ellipj(u3,m3);
-%! assert([sn,cn,dn], res3, 10*eps);
+%! [sn,cn,dn] = ellipj (u3,m3);
+%! assert ([sn,cn,dn], res3, 10*eps);
 
 %!test
-%! u4 = -1; m4 = tan(pi/8)^4;
+%! u4 = -1; m4 = tan (pi/8)^4;
 %! res4 = [-0.8392965923,0.5436738271,0.9895776106];
-%! [sn,cn,dn]=ellipj(u4, m4);
-%! assert([sn,cn,dn], res4, 1e-10);
+%! [sn,cn,dn] = ellipj (u4, m4);
+%! assert ([sn,cn,dn], res4, 1e-10);
 
 %!test
 %! u5 = -0.2 + 0.4i; m5 = tan(pi/8)^4;
 %! res5 = [ -0.2152524522 + 0.402598347i, ...
 %!           1.059453907  + 0.08179712295i, ...
 %!           1.001705496  + 0.00254669712i ];
-%! [sn,cn,dn]=ellipj(u5,m5);
-%! assert([sn,cn,dn], res5, 1e-9);
+%! [sn,cn,dn] = ellipj (u5,m5);
+%! assert ([sn,cn,dn], res5, 1e-9);
 
 %!test
 %! u6 = 0.2 + 0.6i; m6 = tan(pi/8)^4;
 %! res6 = [ 0.2369100139 + 0.624633635i, ...
 %!          1.16200643   - 0.1273503824i, ...
-%!          1.004913944 - 0.004334880912i ];
-%! [sn,cn,dn]=ellipj(u6,m6);
-%! assert([sn,cn,dn], res6, 1e-8);
+%!          1.004913944  - 0.004334880912i ];
+%! [sn,cn,dn] = ellipj (u6,m6);
+%! assert ([sn,cn,dn], res6, 1e-8);
 
 %!test
-%! u7 = 0.8 + 0.8i; m7 = tan(pi/8)^4;
+%! u7 = 0.8 + 0.8i; m7 = tan (pi/8)^4;
 %! res7 = [0.9588386397 + 0.6107824358i, ...
 %!         0.9245978896 - 0.6334016187i, ...
 %!         0.9920785856 - 0.01737733806i ];
-%! [sn,cn,dn]=ellipj(u7,m7);
-%! assert([sn,cn,dn], res7, 1e-10);
+%! [sn,cn,dn] = ellipj (u7,m7);
+%! assert ([sn,cn,dn], res7, 1e-10);
 
 %!test
-%! u=[0,pi/6,pi/4,pi/2]; m=0;
+%! u = [0,pi/6,pi/4,pi/2]; m=0;
 %! res = [0,1/2,1/sqrt(2),1;1,cos(pi/6),1/sqrt(2),0;1,1,1,1];
-%! [sn,cn,dn]=ellipj(u,m);
-%! assert([sn;cn;dn],res, 100*eps);
-%! [sn,cn,dn]=ellipj(u',0);
-%! assert([sn,cn,dn],res', 100*eps);
+%! [sn,cn,dn] = ellipj (u,m);
+%! assert ([sn;cn;dn], res, 100*eps);
+%! [sn,cn,dn] = ellipj (u',0);
+%! assert ([sn,cn,dn], res', 100*eps);
+
+## FIXME: need to check [real,complex]x[scalar,rowvec,colvec,matrix]x[u,m]
 
-## XXX FIXME XXX
-## need to check [real,complex]x[scalar,rowvec,colvec,matrix]x[u,m]
+## One test for u column vector x m row vector
+%!test
+%! u = [0,pi/6,pi/4,pi/2]';  m = [0 0 0 0];
+%! res = [0,1/2,1/sqrt(2),1;1,cos(pi/6),1/sqrt(2),0;1,1,1,1]';
+%! [sn,cn,dn] = ellipj (u,m);
+%! assert (sn, repmat (res(:,1), [1,4]), 100*eps);
+%! assert (cn, repmat (res(:,2), [1,4]), 100*eps);
+%! assert (dn, repmat (res(:,3), [1,4]), 100*eps);
 
 %!test
 %! ## Test Jacobi elliptic functions
 %! ## against "exact" solution from Mathematica 3.0
 %! ## David Billinghurst <David.Billinghurst@riotinto.com>
 %! ## 1 February 2001
 %! u = [ 0.25; 0.25; 0.20; 0.20; 0.672; 0.5];
 %! m = [ 0.0;  1.0;  0.19; 0.81; 0.36;  0.9999999999];
-%! S = [ sin(0.25); tanh(0.25);
-%!  0.19842311013970879516;
-%!  0.19762082367187648571;
-%!  0.6095196917919021945;
-%!  0.4621171572617320908 ];
-%! C = [ cos(0.25); sech(0.25);
-%!  0.9801164570409401062;
-%!  0.9802785369736752032;
-%!  0.7927709286533560550;
-%!  0.8868188839691764094 ];
-%! D = [ 1.0;  sech(0.25);
-%!  0.9962526643271134302;
-%!  0.9840560289645665155;
-%!  0.9307281387786906491;
-%!  0.8868188839812167635 ];
-%! [sn,cn,dn] = ellipj(u,m);
-%! assert(sn,S,8*eps);
-%! assert(cn,C,8*eps);
-%! assert(dn,D,8*eps);
+%! S = [ sin(0.25);
+%!       tanh(0.25);
+%!       0.19842311013970879516;
+%!       0.19762082367187648571;
+%!       0.6095196917919021945;
+%!       0.4621171572617320908 ];
+%! C = [ cos(0.25);
+%!       sech(0.25);
+%!       0.9801164570409401062;
+%!       0.9802785369736752032;
+%!       0.7927709286533560550;
+%!       0.8868188839691764094 ];
+%! D = [ 1.0;
+%!       sech(0.25);
+%!       0.9962526643271134302;
+%!       0.9840560289645665155;
+%!       0.9307281387786906491;
+%!       0.8868188839812167635 ];
+%! [sn,cn,dn] = ellipj (u,m);
+%! assert (sn, S, 8*eps);
+%! assert (cn, C, 8*eps);
+%! assert (dn, D, 8*eps);
 
 %!error ellipj ()
 %!error ellipj (1)
 %!error ellipj (1,2,3,4)
+%!warning <expecting 0 <= M <= 1> ellipj (1,2);
+## FIXME: errors commented out untill lasterr() truly returns the last error.
+%!#error <expecting scalar or matrix as second argument> ellipj (1, "1")
+%!#error <expecting scalar or matrix as first argument> ellipj ("1", 1)
+%!#error <expecting scalar or matrix as first argument> ellipj ({1}, 1)
+%!#error <expecting scalar or matrix as first argument> ellipj ({1, 2}, 1)
+%!#error <expecting scalar or matrix as second argument> ellipj (1, {1, 2})
+%!#error <expecting scalar or matrix as first argument> ellipj ("1", [1, 2])
+%!#error <expecting scalar or matrix as first argument> ellipj ({1}, [1, 2])
+%!#error <expecting scalar or matrix as first argument> ellipj ({1}, [1, 2])
+%!#error <expecting scalar or matrix as first argument> ellipj ("1,2", [1, 2])
+%!#error <expecting scalar or matrix as first argument> ellipj ({1, 2}, [1, 2])
+%!error <Invalid size combination for U and M> ellipj ([1:4], [1:3])
+%!error <Invalid size combination for U and M> ellipj (complex (1:4,1:4), [1:3])
+
 */
+
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -825,20 +825,20 @@ handle_message (error_fun f, const char 
 
   return retval;
 }
 
 DEFUN (rethrow, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rethrow (@var{err})\n\
 Reissue a previous error as defined by @var{err}.  @var{err} is a structure\n\
-that must contain at least the 'message' and 'identifier' fields.  @var{err}\n\
-can also contain a field 'stack' that gives information on the assumed\n\
-location of the error.  Typically @var{err} is returned from\n\
-@code{lasterror}.\n\
+that must contain at least the @qcode{\"message\"} and @qcode{\"identifier\"}\n\
+fields.  @var{err} can also contain a field @qcode{\"stack\"} that gives\n\
+information on the assumed location of the error.  Typically @var{err} is\n\
+returned from @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
@@ -1086,17 +1086,17 @@ endif\n\
 error (err_msg);\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 which will only stop execution if an error has been found.\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, escape\n\
-sequences (e.g., \"\\n\" => newline) are processed in @var{template}\n\
+sequences (e.g., @qcode{\"\\n\"} => newline) are processed in @var{template}\n\
 regardless of whether @var{template} has been defined within single quotes\n\
 as long as there are two or more input arguments.\n\
 Use a second backslash to stop interpolation of the escape sequence (e.g.,\n\
 \"\\\\n\") or use the @code{regexptranslate} function.\n\
 @seealso{warning, lasterror}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1230,45 +1230,45 @@ functions (@pxref{Formatted Output}) and
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{warning: }.\n\
 You should use this function when you want to notify the user\n\
 of an unusual condition, but only when it makes sense for your program\n\
 to go on.\n\
 \n\
 The optional message identifier allows users to enable or disable\n\
 warnings tagged by @var{id}.  A message identifier is of the form\n\
-\"NAMESPACE:WARNING-NAME\".  Octave's own warnings use the \"Octave\"\n\
-namespace (@pxref{docXwarning_ids}).  The special identifier @samp{\"all\"}\n\
+\"NAMESPACE:WARNING-NAME\".  Octave's own warnings use the @qcode{\"Octave\"}\n\
+namespace (@pxref{XREFwarning_ids}).  The special identifier @qcode{\"all\"}\n\
 may be used to set the state of all warnings.\n\
 \n\
-If the first argument is @samp{\"on\"} or @samp{\"off\"}, set the state\n\
-of a particular warning using the identifier @var{id}.  If the first\n\
-argument is @samp{\"query\"}, query the state of this warning instead.\n\
-If the identifier is omitted, a value of @samp{\"all\"} is assumed.  If\n\
-you set the state of a warning to @samp{\"error\"}, the warning named by\n\
-@var{id} is handled as if it were an error instead.  So, for example, the\n\
-following handles all warnings as errors:\n\
+If the first argument is @qcode{\"on\"} or @qcode{\"off\"},\n\
+set the state of a particular warning using the identifier @var{id}.  If the\n\
+first argument is @qcode{\"query\"}, query the state of this warning\n\
+instead.  If the identifier is omitted, a value of @qcode{\"all\"} is\n\
+assumed.  If you set the state of a warning to @qcode{\"error\"}, the\n\
+warning named by @var{id} is handled as if it were an error instead.  So,\n\
+for example, the following handles all warnings as errors:\n\
 \n\
 @example\n\
 @group\n\
 warning (\"error\");\n\
 @end group\n\
 @end example\n\
 \n\
-If the state is @samp{\"on\"}, @samp{\"off\"}, or @samp{\"error\"}\n\
-and the third argument is @samp{\"local\"}, then the warning state\n\
+If the state is @qcode{\"on\"}, @qcode{\"off\"}, or @qcode{\"error\"}\n\
+and the third argument is @qcode{\"local\"}, then the warning state\n\
 will be set temporarily, until the end of the current function.\n\
 Changes to warning states that are set locally affect the current\n\
 function and all functions called from the current scope.  The\n\
 previous warning state is restored on return from the current\n\
-function.  The \"local\" option is ignored if used in the top-level\n\
+function.  The @qcode{\"local\"} option is ignored if used in the top-level\n\
 workspace.\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, escape\n\
-sequences (e.g., \"\\n\" => newline) are processed in @var{template}\n\
+sequences (e.g., @qcode{\"\\n\"} => newline) are processed in @var{template}\n\
 regardless of whether @var{template} has been defined within single quotes\n\
 as long as there are two or more input arguments.\n\
 Use a second backslash to stop interpolation of the escape sequence (e.g.,\n\
 \"\\\\n\") or use the @code{regexptranslate} function.\n\
 @seealso{warning_ids, lastwarn, error}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1649,49 +1649,49 @@ DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror (\"reset\")\n\
 Query or set the last error message structure.  When called without\n\
 arguments, return a structure containing the last error message and other\n\
 information related to this error.  The elements of the structure are:\n\
 \n\
-@table @asis\n\
-@item 'message'\n\
+@table @code\n\
+@item message\n\
 The text of the last error message\n\
 \n\
-@item 'identifier'\n\
+@item identifier\n\
 The message identifier of this error message\n\
 \n\
-@item 'stack'\n\
+@item stack\n\
 A structure containing information on where the message occurred.  This may\n\
 be an empty structure if the information cannot\n\
 be obtained.  The fields of the structure are:\n\
 \n\
-@table @asis\n\
-@item 'file'\n\
+@table @code\n\
+@item file\n\
 The name of the file where the error occurred\n\
 \n\
-@item 'name'\n\
+@item name\n\
 The name of function in which the error occurred\n\
 \n\
-@item 'line'\n\
+@item line\n\
 The line number at which the error occurred\n\
 \n\
-@item 'column'\n\
+@item column\n\
 An optional field with the column number at which the error occurred\n\
 @end table\n\
 @end table\n\
 \n\
 The last error structure may be set by passing a scalar structure, @var{err},\n\
 as input.  Any fields of @var{err} that match those above are set while any\n\
 unspecified fields are initialized with default values.\n\
 \n\
-If @code{lasterror} is called with the argument \"reset\", all fields are\n\
-set to their default values.\n\
+If @code{lasterror} is called with the argument @qcode{\"reset\"}, all\n\
+fields are set to their default values.\n\
 @seealso{lasterr, error, lastwarn}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   unwind_protect frame;
 
@@ -1951,54 +1951,54 @@ to check for the proper number of argume
 DEFUN (beep_on_error, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} beep_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} beep_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to ring the terminal bell before printing an error message.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
 DEFUN (debug_on_error, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_warning (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{debug_on_error, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_warning);
 }
 
 std::string
 last_error_message (void)
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -642,48 +642,39 @@ Open an existing file for reading and wr
 Open a file for reading or writing.  The previous contents are\n\
 discarded.\n\
 \n\
 @item @samp{a+}\n\
 Open or create a file for reading or writing at the end of the\n\
 file.\n\
 @end table\n\
 \n\
-Append a \"t\" to the mode string to open the file in text mode or a\n\
-\"b\" to open in binary mode.  On Windows and Macintosh systems, text\n\
+Append a @qcode{\"t\"} to the mode string to open the file in text mode or a\n\
+@qcode{\"b\"} to open in binary mode.  On Windows and Macintosh systems, text\n\
 mode reading and writing automatically converts linefeeds to the\n\
 appropriate line end character for the system (carriage-return linefeed\n\
 on Windows, carriage-return on Macintosh).  The default if no mode is\n\
 specified is binary mode.\n\
 \n\
-Additionally, you may append a \"z\" to the mode string to open a\n\
+Additionally, you may append a @qcode{\"z\"} to the mode string to open a\n\
 gzipped file for reading or writing.  For this to be successful, you\n\
 must also open the file in binary mode.\n\
 \n\
 The parameter @var{arch} is a string specifying the default data format\n\
 for the file.  Valid values for @var{arch} are:\n\
 \n\
 @table @samp\n\
 @item native\n\
 The format of the current machine (this is the default).\n\
 \n\
 @item ieee-be\n\
 IEEE big endian format.\n\
 \n\
 @item ieee-le\n\
 IEEE little endian format.\n\
-\n\
-@item vaxd\n\
-VAX D floating format.\n\
-\n\
-@item vaxg\n\
-VAX G floating format.\n\
-\n\
-@item cray\n\
-Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 however, conversions are currently only supported for @samp{native}\n\
 @samp{ieee-be}, and @samp{ieee-le} formats.\n\
 @seealso{fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport}\n\
 @end deftypefn")
 {
@@ -820,18 +811,20 @@ DEFUN (fseek, args, ,
 @deftypefn  {Built-in Function} {} fseek (@var{fid}, @var{offset})\n\
 @deftypefnx {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
 @deftypefnx {Built-in Function} {@var{status} =} fseek (@dots{})\n\
 Set the file pointer to any location within the file @var{fid}.\n\
 \n\
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @w{@code{SEEK_CUR}} (current\n\
 position), @w{@code{SEEK_SET}} (beginning), or @w{@code{SEEK_END}} (end of\n\
-file) or strings \"cof\", \"bof\" or \"eof\".  If @var{origin} is omitted,\n\
-@w{@code{SEEK_SET}} is assumed.  @var{offset} may be positive, negative, or zero but not all combinations of @var{origin} and @var{offset} can be realized.\n\
+file) or strings @qcode{\"cof\"}, @qcode{\"bof\"} or @qcode{\"eof\"}.  If\n\
+@var{origin} is omitted, @w{@code{SEEK_SET}} is assumed.  @var{offset} may\n\
+be positive, negative, or zero but not all combinations of @var{origin} and\n\
+@var{offset} can be realized.\n\
 \n\
 Return 0 on success and -1 on error.\n\
 @seealso{fskipl, frewind, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
@@ -1435,94 +1428,94 @@ of @var{nr}, the last column is padded w
 \n\
 @noindent\n\
 If @var{size} is omitted, a value of @code{Inf} is assumed.\n\
 \n\
 The optional argument @var{precision} is a string specifying the type of\n\
 data to read and may be one of\n\
 \n\
 @table @asis\n\
-@item \"schar\"\n\
-@itemx \"signed char\"\n\
+@item  @qcode{\"schar\"}\n\
+@itemx @qcode{\"signed char\"}\n\
 Signed character.\n\
 \n\
-@item \"uchar\"\n\
-@itemx \"unsigned char\"\n\
+@item  @qcode{\"uchar\"}\n\
+@itemx @qcode{\"unsigned char\"}\n\
 Unsigned character.\n\
 \n\
-@item \"int8\"\n\
-@itemx \"integer*1\"\n\
+@item  @qcode{\"int8\"}\n\
+@itemx @qcode{\"integer*1\"}\n\
 \n\
 8-bit signed integer.\n\
 \n\
-@item \"int16\"\n\
-@itemx \"integer*2\"\n\
+@item  @qcode{\"int16\"}\n\
+@itemx @qcode{\"integer*2\"}\n\
 16-bit signed integer.\n\
 \n\
-@item \"int32\"\n\
-@itemx \"integer*4\"\n\
+@item  @qcode{\"int32\"}\n\
+@itemx @qcode{\"integer*4\"}\n\
 32-bit signed integer.\n\
 \n\
-@item \"int64\"\n\
-@itemx \"integer*8\"\n\
+@item  @qcode{\"int64\"}\n\
+@itemx @qcode{\"integer*8\"}\n\
 64-bit signed integer.\n\
 \n\
-@item \"uint8\"\n\
+@item @qcode{\"uint8\"}\n\
 8-bit unsigned integer.\n\
 \n\
-@item \"uint16\"\n\
+@item @qcode{\"uint16\"}\n\
 16-bit unsigned integer.\n\
 \n\
-@item \"uint32\"\n\
+@item @qcode{\"uint32\"}\n\
 32-bit unsigned integer.\n\
 \n\
-@item \"uint64\"\n\
+@item @qcode{\"uint64\"}\n\
 64-bit unsigned integer.\n\
 \n\
-@item \"single\"\n\
-@itemx \"float32\"\n\
-@itemx \"real*4\"\n\
+@item  @qcode{\"single\"}\n\
+@itemx @qcode{\"float32\"}\n\
+@itemx @qcode{\"real*4\"}\n\
 32-bit floating point number.\n\
 \n\
-@item \"double\"\n\
-@itemx \"float64\"\n\
-@itemx \"real*8\"\n\
+@item  @qcode{\"double\"}\n\
+@itemx @qcode{\"float64\"}\n\
+@itemx @qcode{\"real*8\"}\n\
 64-bit floating point number.\n\
 \n\
-@item \"char\"\n\
-@itemx \"char*1\"\n\
+@item  @qcode{\"char\"}\n\
+@itemx @qcode{\"char*1\"}\n\
 Single character.\n\
 \n\
-@item \"short\"\n\
+@item @qcode{\"short\"}\n\
 Short integer (size is platform dependent).\n\
 \n\
-@item \"int\"\n\
+@item @qcode{\"int\"}\n\
 Integer (size is platform dependent).\n\
 \n\
-@item \"long\"\n\
+@item @qcode{\"long\"}\n\
 Long integer (size is platform dependent).\n\
 \n\
-@item \"ushort\"\n\
-@itemx \"unsigned short\"\n\
+@item  @qcode{\"ushort\"}\n\
+@itemx @qcode{\"unsigned short\"}\n\
 Unsigned short integer (size is platform dependent).\n\
 \n\
-@item \"uint\"\n\
-@itemx \"unsigned int\"\n\
+@item  @qcode{\"uint\"}\n\
+@itemx @qcode{\"unsigned int\"}\n\
 Unsigned integer (size is platform dependent).\n\
 \n\
-@item \"ulong\"\n\
-@itemx \"unsigned long\"\n\
+@item  @qcode{\"ulong\"}\n\
+@itemx @qcode{\"unsigned long\"}\n\
 Unsigned long integer (size is platform dependent).\n\
 \n\
-@item \"float\"\n\
+@item @qcode{\"float\"}\n\
 Single precision floating point number (size is platform dependent).\n\
 @end table\n\
 \n\
 @noindent\n\
-The default precision is @code{\"uchar\"}.\n\
+The default precision is @qcode{\"uchar\"}.\n\
 \n\
 The @var{precision} argument may also specify an optional repeat\n\
 count.  For example, @samp{32*single} causes @code{fread} to read\n\
 a block of 32 single precision floating point numbers.  Reading in\n\
 blocks is useful in combination with the @var{skip} argument.\n\
 \n\
 The @var{precision} argument may also specify a type conversion.\n\
 For example, @samp{int16=>int32} causes @code{fread} to read 16-bit\n\
@@ -1548,39 +1541,26 @@ fread (f, 10, \"3*single=>single\", 8)\n
 @noindent\n\
 will omit the final 8-byte skip because the last read will not be\n\
 a complete block of 3 values.\n\
 \n\
 The optional argument @var{arch} is a string specifying the data format\n\
 for the file.  Valid values are\n\
 \n\
 @table @code\n\
-@item \"native\"\n\
+@item @qcode{\"native\"}\n\
 The format of the current machine.\n\
 \n\
 @item \"ieee-be\"\n\
 IEEE big endian.\n\
 \n\
 @item \"ieee-le\"\n\
 IEEE little endian.\n\
-\n\
-@item \"vaxd\"\n\
-VAX D floating format.\n\
-\n\
-@item \"vaxg\"\n\
-VAX G floating format.\n\
-\n\
-@item \"cray\"\n\
-Cray floating format.\n\
 @end table\n\
 \n\
-@noindent\n\
-Conversions are currently only supported for @code{\"ieee-be\"} and\n\
-@code{\"ieee-le\"} formats.\n\
-\n\
 The data read from the file is returned in @var{val}, and the number of\n\
 values read is returned in @code{count}\n\
 @seealso{fwrite, fgets, fgetl, fscanf, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -1822,21 +1802,21 @@ DEFUN (popen, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.  The name of the command to run is\n\
 given by @var{command}.  The file identifier corresponding to the input\n\
 or output stream of the process is returned in @var{fid}.  The argument\n\
 @var{mode} may be\n\
 \n\
 @table @code\n\
-@item \"r\"\n\
+@item @qcode{\"r\"}\n\
 The pipe will be connected to the standard output of the process, and\n\
 open for reading.\n\
 \n\
-@item \"w\"\n\
+@item @qcode{\"w\"}\n\
 The pipe will be connected to the standard input of the process, and\n\
 open for writing.\n\
 @end table\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -1917,17 +1897,17 @@ DEFUNX ("tmpnam", Ftmpnam, args, ,
 @c List other forms of function in documentation index\n\
 @findex octave_tmp_file_name\n\
 \n\
 @deftypefn  {Built-in Function} {} tmpnam ()\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir})\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
 \n\
-If @var{prefix} is omitted, a value of @code{\"oct-\"} is used.\n\
+If @var{prefix} is omitted, a value of @qcode{\"oct-\"} is used.\n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 is used.  If @var{dir} is provided, it must exist, otherwise the default\n\
 directory for temporary files is used.  Since the named file is not\n\
 opened, by @code{tmpnam}, it is possible (though relatively unlikely)\n\
 that it will not be available by the time your program attempts to open it.\n\
 @seealso{tmpfile, mkstemp, P_tmpdir}\n\
 @end deftypefn")
 {
@@ -1959,17 +1939,17 @@ that it will not be available by the tim
 }
 
 DEFALIAS (octave_tmp_file_name, tmpnam);
 
 DEFUN (tmpfile, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} tmpfile ()\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
-name.  The file is opened in binary read/write (@code{\"w+b\"}) mode.\n\
+name.  The file is opened in binary read/write (@qcode{\"w+b\"}) mode.\n\
 The file will be deleted automatically when it is closed or when Octave\n\
 exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{tmpnam, mkstemp, P_tmpdir}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -372,19 +372,20 @@ containing the nonzero values.  For exam
        @result{} j = [ 1; 2 ]\n\
        @result{} v = [ 3; 3 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two inputs are given, @var{n} indicates the maximum number of\n\
 elements to find from the beginning of the matrix or vector.\n\
 \n\
-If three inputs are given, @var{direction} should be one of \"first\" or\n\
-\"last\", requesting only the first or last @var{n} indices, respectively.\n\
-However, the indices are always returned in ascending order.\n\
+If three inputs are given, @var{direction} should be one of\n\
+@qcode{\"first\"} or @qcode{\"last\"}, requesting only the first or last\n\
+@var{n} indices, respectively.  However, the indices are always returned in\n\
+ascending order.\n\
 \n\
 Note that this function is particularly useful for sparse matrices, as\n\
 it extracts the non-zero elements as vectors, which can then be used to\n\
 create the original matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sz = size (a);\n\
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -61,18 +61,18 @@ The standard notation is @math{P(a,x)}, 
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
 for each element of @var{x} and vice versa.\n\
 \n\
 If neither @var{x} nor @var{a} is scalar, the sizes of @var{x} and\n\
 @var{a} must agree, and @code{gammainc} is applied element-by-element.\n\
 \n\
 By default the incomplete gamma function integrated from 0 to @var{x} is\n\
-computed.  If \"upper\" is given then the complementary function integrated\n\
-from @var{x} to infinity is calculated.  It should be noted that\n\
+computed.  If @qcode{\"upper\"} is given then the complementary function\n\
+integrated from @var{x} to infinity is calculated.  It should be noted that\n\
 \n\
 @example\n\
 gammainc (@var{x}, @var{a}) @equiv{} 1 - gammainc (@var{x}, @var{a}, \"upper\")\n\
 @end example\n\
 @seealso{gamma, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1595,35 +1595,37 @@ opengl_renderer::draw_surface (const sur
   opengl_texture tex;
 
   int i1, i2, j1, j2;
   bool x_mat = (x.rows () == z.rows ());
   bool y_mat = (y.columns () == z.columns ());
 
   i1 = i2 = j1 = j2 = 0;
 
+  if ((fc_mode > 0 && fc_mode < 3) || ec_mode > 0)
+    c = props.get_color_data ().array_value ();
+
   boolMatrix clip (z.dims (), false);
 
   for (int i = 0; i < zr; i++)
     {
       if (x_mat)
         i1 = i;
 
       for (int j = 0; j < zc; j++)
         {
           if (y_mat)
             j1 = j;
 
           clip(i,j) = is_nan_or_inf (x(i1,j), y(i,j1), z(i,j));
+          if (fc_mode == 1 || fc_mode == 2)
+            clip(i,j) |= (xisnan (c(i,j)) || xisinf (c(i,j)));
         }
     }
 
-  if ((fc_mode > 0 && fc_mode < 3) || ec_mode > 0)
-    c = props.get_color_data ().array_value ();
-
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: implement alphadata conversion
       //a = props.get_alpha_data ();
     }
 
   if (fl_mode > 0 || el_mode > 0)
     {
@@ -3004,17 +3006,17 @@ opengl_renderer::make_marker_list (const
 void
 opengl_renderer::text_to_pixels (const std::string& txt,
                                  uint8NDArray& pixels,
                                  Matrix& bbox,
                                  int halign, int valign, double rotation)
 {
 #if HAVE_FREETYPE
   text_renderer.text_to_pixels (txt, pixels, bbox,
-                                halign, valign, rotation);
+                                halign, valign, rotation, "none");
 #endif
 }
 
 Matrix
 opengl_renderer::render_text (const std::string& txt,
                             double x, double y, double z,
                             int halign, int valign, double rotation)
 {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1922,32 +1922,16 @@ property_list::as_struct (const std::str
            q != pval_map.end ();
            q++)
         m.assign (prefix + q->first, q->second);
     }
 
   return m;
 }
 
-graphics_handle::graphics_handle (const octave_value& a)
-  : val (octave_NaN)
-{
-  if (a.is_empty ())
-    /* do nothing */;
-  else
-    {
-      double tval = a.double_value ();
-
-      if (! error_state)
-        val = tval;
-      else
-        error ("invalid graphics handle");
-    }
-}
-
 // Set properties given as a cs-list of name, value pairs.
 
 void
 graphics_object::set (const octave_value_list& args)
 {
   int nargin = args.length ();
 
   if (nargin == 0)
@@ -1973,21 +1957,24 @@ graphics_object::set (const octave_value
     }
   else
     error ("set: invalid number of arguments");
 }
 
 /*
 ## test set with name, value pairs
 %!test
-%! set (gcf, "visible", "off");
+%! hf = figure ("visible", "off");
 %! h = plot (1:10, 10:-1:1);
 %! set (h, "linewidth", 10, "marker", "x");
-%! assert (get (h, "linewidth"), 10);
-%! assert (get (h, "marker"), "x");
+%! lw = get (h, "linewidth");
+%! mk = get (h, "marker");
+%! close (hf);
+%! assert (lw, 10);
+%! assert (mk, "x");
 */
 
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
@@ -2008,42 +1995,57 @@ graphics_object::set (const Array<std::s
       if (error_state)
         break;
     }
 }
 
 /*
 ## test set with cell array arguments
 %!test
-%! set (gcf, "visible", "off");
+%! hf = figure ("visible", "off");
 %! h = plot (1:10, 10:-1:1);
 %! set (h, {"linewidth", "marker"}, {10, "x"});
-%! assert (get (h, "linewidth"), 10);
-%! assert (get (h, "marker"), "x");
+%! lw = get (h, "linewidth");
+%! mk = get (h, "marker");
+%! close (hf);
+%! assert (lw, 10);
+%! assert (mk, "x");
 
 ## test set with multiple handles and cell array arguments
 %!test
-%! set (gcf, "visible", "off");
-%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
-%! assert (get (h, "linewidth"), {10; 5});
-%! assert (get (h, "marker"), {"x"; "o"});
-%! set (h, {"linewidth", "marker"}, {10, "x"});
-%! assert (get (h, "linewidth"), {10; 10});
-%! assert (get (h, "marker"), {"x"; "x"});
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%!   set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
+%!   assert (get (h, "linewidth"), {10; 5});
+%!   assert (get (h, "marker"), {"x"; "o"});
+%!   set (h, {"linewidth", "marker"}, {10, "x"});
+%!   assert (get (h, "linewidth"), {10; 10});
+%!   assert (get (h, "marker"), {"x"; "x"});
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect;
 
 %!error <set: number of graphics handles must match number of value rows>
-%! set (gcf, "visible", "off");
-%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%!   set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 
 %!error <set: number of names must match number of value columns>
-%! set (gcf, "visible", "off");
-%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%! set (h, {"linewidth"}, {10, "x"; 5, "o"});
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%!   set (h, {"linewidth"}, {10, "x"; 5, "o"});
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 */
 
 // Set properties given in a struct array
 void
 graphics_object::set (const octave_map& m)
 {
   for (octave_idx_type p = 0; p < m.nfields (); p++)
     {
@@ -2056,78 +2058,92 @@ graphics_object::set (const octave_map& 
       if (error_state)
         break;
     }
 }
 
 /*
 ## test set ticklabels for compatibility
 %!test
-%! set (gcf (), "visible", "off");
+%! hf = figure ("visible", "off");
 %! set (gca (), "xticklabel", [0, 0.2, 0.4, 0.6, 0.8, 1]);
 %! xticklabel = get (gca (), "xticklabel");
+%! close (hf);
 %! assert (class (xticklabel), "char");
 %! assert (size (xticklabel), [6, 3]);
+
 %!test
-%! set (gcf (), "visible", "off");
+%! hf = figure ("visible", "off");
 %! set (gca (), "xticklabel", "0|0.2|0.4|0.6|0.8|1");
 %! xticklabel = get (gca (), "xticklabel");
+%! close (hf);
 %! assert (class (xticklabel), "char");
 %! assert (size (xticklabel), [6, 3]);
+
 %!test
-%! set (gcf (), "visible", "off");
+%! hf = figure ("visible", "off");
 %! set (gca (), "xticklabel", ["0 "; "0.2"; "0.4"; "0.6"; "0.8"; "1 "]);
 %! xticklabel = get (gca (), "xticklabel");
+%! close (hf);
 %! assert (class (xticklabel), "char");
 %! assert (size (xticklabel), [6, 3]);
+
 %!test
-%! set (gcf (), "visible", "off");
+%! hf = figure ("visible", "off");
 %! set (gca (), "xticklabel", {"0", "0.2", "0.4", "0.6", "0.8", "1"});
 %! xticklabel = get (gca (), "xticklabel");
+%! close (hf);
 %! assert (class (xticklabel), "cell");
 %! assert (size (xticklabel), [6, 1]);
 */
 
 /*
 ## test set with struct arguments
 %!test
-%! set (gcf, "visible", "off");
-%! h = plot (1:10, 10:-1:1);
-%! set (h, struct ("linewidth", 10, "marker", "x"));
-%! assert (get (h, "linewidth"), 10);
-%! assert (get (h, "marker"), "x");
-%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%! set (h, struct ("linewidth", {5, 10}));
-%! assert (get (h, "linewidth"), {10; 10});
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = plot (1:10, 10:-1:1);
+%!   set (h, struct ("linewidth", 10, "marker", "x"));
+%!   assert (get (h, "linewidth"), 10);
+%!   assert (get (h, "marker"), "x");
+%!   h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%!   set (h, struct ("linewidth", {5, 10}));
+%!   assert (get (h, "linewidth"), {10; 10});
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
 ## test ordering
 %!test
 %! markchanged = @(h, foobar, name) set (h, "userdata", [get(h,"userdata"); {name}]);
-%! figure (1, "visible", "off")
-%! clf ();
-%! h = line ();
-%! set (h, "userdata", {});
-%! addlistener (h, "color", {markchanged, "color"});
-%! addlistener (h, "linewidth", {markchanged, "linewidth"});
-%! # "linewidth" first
-%! props.linewidth = 2;
-%! props.color = "r";
-%! set (h, props);
-%! assert (get (h, "userdata"), fieldnames (props));
-%! clear props
-%! clf ();
-%! h = line ();
-%! set (h, "userdata", {});
-%! addlistener (h, "color", {markchanged, "color"});
-%! addlistener (h, "linewidth", {markchanged, "linewidth"});
-%! # "color" first
-%! props.color = "r";
-%! props.linewidth = 2;
-%! set (h, props);
-%! assert (get (h, "userdata"), fieldnames (props));
-%! close (1);
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = line ();
+%!   set (h, "userdata", {});
+%!   addlistener (h, "color", {markchanged, "color"});
+%!   addlistener (h, "linewidth", {markchanged, "linewidth"});
+%!   ## "linewidth" first
+%!   props.linewidth = 2;
+%!   props.color = "r";
+%!   set (h, props);
+%!   assert (get (h, "userdata"), fieldnames (props));
+%!   clear props;
+%!   clf ();
+%!   h = line ();
+%!   set (h, "userdata", {});
+%!   addlistener (h, "color", {markchanged, "color"});
+%!   addlistener (h, "linewidth", {markchanged, "linewidth"});
+%!   ## "color" first
+%!   props.color = "r";
+%!   props.linewidth = 2;
+%!   set (h, props);
+%!   assert (get (h, "userdata"), fieldnames (props));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 */
 
 // Set a property to a value or to its (factory) default value.
 
 void
 graphics_object::set_value_or_default (const caseless_str& name,
                                        const octave_value& val)
 {
@@ -2168,23 +2184,29 @@ graphics_object::set_value_or_default (c
     }
   else
     rep->set (name, val);
 }
 
 /*
 ## test setting of default values
 %!test
-%! set (gcf, "visible", "off");
-%! h = plot (1:10, 10:-1:1);
-%! set (0, "defaultlinelinewidth", 20);
-%! set (h, "linewidth", "default");
-%! assert (get (h, "linewidth"), 20);
-%! set (h, "linewidth", "factory");
-%! assert (get (h, "linewidth"), 0.5);
+%! old_lw = get (0, "defaultlinelinewidth");
+%! unwind_protect
+%!   hf = figure ("visible", "off");
+%!   h = plot (1:10, 10:-1:1);
+%!   set (0, "defaultlinelinewidth", 20);
+%!   set (h, "linewidth", "default");
+%!   assert (get (h, "linewidth"), 20);
+%!   set (h, "linewidth", "factory");
+%!   assert (get (h, "linewidth"), 0.5);
+%! unwind_protect_cleanup
+%!   close (hf);
+%!   set (0, "defaultlinelinewidth", old_lw);
+%! end_unwind_protect
 */
 
 static double
 make_handle_fraction (void)
 {
   static double maxrand = RAND_MAX + 2.0;
 
   return (rand () + 1.0) / maxrand;
@@ -3120,29 +3142,34 @@ root_figure::properties::get_boundingbox
   Matrix pos = Matrix (1, 4, 0);
   pos(2) = screen_size(0);
   pos(3) = screen_size(1);
   return pos;
 }
 
 /*
 %!test
-%! set (0, "units", "pixels");
-%! sz = get (0, "screensize") - [1, 1, 0, 0];
-%! dpi = get (0, "screenpixelsperinch");
-%! set (0, "units", "inches");
-%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi);
-%! set (0, "units", "centimeters");
-%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54);
-%! set (0, "units", "points");
-%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72);
-%! set (0, "units", "normalized");
-%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0]);
-%! set (0, "units", "pixels");
-%! assert (get (0, "screensize"), sz + [1, 1, 0, 0]);
+%! old_units = get (0, "units");
+%! unwind_protect
+%!   set (0, "units", "pixels");
+%!   sz = get (0, "screensize") - [1, 1, 0, 0];
+%!   dpi = get (0, "screenpixelsperinch");
+%!   set (0, "units", "inches");
+%!   assert (get (0, "screensize"), sz / dpi, 0.5 / dpi);
+%!   set (0, "units", "centimeters");
+%!   assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54);
+%!   set (0, "units", "points");
+%!   assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72);
+%!   set (0, "units", "normalized");
+%!   assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0]);
+%!   set (0, "units", "pixels");
+%!   assert (get (0, "screensize"), sz + [1, 1, 0, 0]);
+%! unwind_protect_cleanup
+%!   set (0, "units", old_units);
+%! end_unwind_protect
 */
 
 void
 root_figure::properties::remove_child (const graphics_handle& gh)
 {
   gh_manager::pop_figure (gh);
 
   graphics_handle cf = gh_manager::current_figure ();
@@ -3740,37 +3767,44 @@ figure::properties::update_papersize (vo
     {
       std::swap (sz(0), sz(1));
       papersize.set (octave_value (sz));
     }
 }
 
 /*
 %!test
-%! figure (1, "visible", "off");
-%! set (1, "paperunits", "inches");
-%! set (1, "papersize", [5, 4]);
-%! set (1, "paperunits", "points");
-%! assert (get (1, "papersize"), [5, 4] * 72, 1);
-%! papersize = get (gcf, "papersize");
-%! set (1, "papersize", papersize + 1);
-%! set (1, "papersize", papersize);
-%! assert (get (1, "papersize"), [5, 4] * 72, 1);
-%! close (1);
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   set (hf, "paperunits", "inches");
+%!   set (hf, "papersize", [5, 4]);
+%!   set (hf, "paperunits", "points");
+%!   assert (get (hf, "papersize"), [5, 4] * 72, 1);
+%!   papersize = get (hf, "papersize");
+%!   set (hf, "papersize", papersize + 1);
+%!   set (hf, "papersize", papersize);
+%!   assert (get (hf, "papersize"), [5, 4] * 72, 1);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
 %!test
-%! figure (1, "visible", "off");
-%! set (1, "paperunits", "inches");
-%! set (1, "papersize", [5, 4]);
-%! set (1, "paperunits", "centimeters");
-%! assert (get (1, "papersize"), [5, 4] * 2.54, 2.54/72);
-%! papersize = get (gcf, "papersize");
-%! set (1, "papersize", papersize + 1);
-%! set (1, "papersize", papersize);
-%! assert (get (1, "papersize"), [5, 4] * 2.54, 2.54/72);
-%! close (1);
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   set (hf, "paperunits", "inches");
+%!   set (hf, "papersize", [5, 4]);
+%!   set (hf, "paperunits", "centimeters");
+%!   assert (get (hf, "papersize"), [5, 4] * 2.54, 2.54/72);
+%!   papersize = get (hf, "papersize");
+%!   set (hf, "papersize", papersize + 1);
+%!   set (hf, "papersize", papersize);
+%!   assert (get (hf, "papersize"), [5, 4] * 2.54, 2.54/72);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 */
 
 void
 figure::properties::update_paperorientation (void)
 {
   std::string porient = get_paperorientation ();
   Matrix sz = get_papersize ().matrix_value ();
   Matrix pos = get_paperposition ().matrix_value ();
@@ -3784,35 +3818,39 @@ figure::properties::update_paperorientat
       // between update_papersize and update_papertype
       papersize.set (octave_value (sz));
       paperposition.set (octave_value (pos));
     }
 }
 
 /*
 %!test
-%! figure (1, "visible", false);
-%! tol = 100 * eps ();
-%! ## UPPER case and MiXed case is part of test and should not be changed.
-%! set (gcf (), "paperorientation", "PORTRAIT");
-%! set (gcf (), "paperunits", "inches");
-%! set (gcf (), "papertype", "USletter");
-%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol);
-%! set (gcf (), "paperorientation", "Landscape");
-%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol);
-%! set (gcf (), "paperunits", "centimeters");
-%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol);
-%! set (gcf (), "papertype", "a4");
-%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol);
-%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0]);
-%! assert (get (gcf (), "papertype"), "usletter");
-%! assert (get (gcf (), "paperorientation"), "portrait");
-%! set (gcf (), "papersize", [11.0, 8.5]);
-%! assert (get (gcf (), "papertype"), "usletter");
-%! assert (get (gcf (), "paperorientation"), "landscape");
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   tol = 100 * eps ();
+%!   ## UPPER case and MiXed case is part of test and should not be changed.
+%!   set (hf, "paperorientation", "PORTRAIT");
+%!   set (hf, "paperunits", "inches");
+%!   set (hf, "papertype", "USletter");
+%!   assert (get (hf, "papersize"), [8.5, 11.0], tol);
+%!   set (hf, "paperorientation", "Landscape");
+%!   assert (get (hf, "papersize"), [11.0, 8.5], tol);
+%!   set (hf, "paperunits", "centimeters");
+%!   assert (get (hf, "papersize"), [11.0, 8.5] * 2.54, tol);
+%!   set (hf, "papertype", "a4");
+%!   assert (get (hf, "papersize"), [29.7, 21.0], tol);
+%!   set (hf, "paperunits", "inches", "papersize", [8.5, 11.0]);
+%!   assert (get (hf, "papertype"), "usletter");
+%!   assert (get (hf, "paperorientation"), "portrait");
+%!   set (hf, "papersize", [11.0, 8.5]);
+%!   assert (get (hf, "papertype"), "usletter");
+%!   assert (get (hf, "paperorientation"), "landscape");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
 */
 
 void
 figure::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
@@ -3828,23 +3866,30 @@ void
 figure::properties::update_units (const caseless_str& old_units)
 {
   position.set (convert_position (get_position ().matrix_value (), old_units,
                                   get_units (), screen_size_pixels ()), false);
 }
 
 /*
 %!test
-%! figure (1, "visible", false);
-%! set (0, "units", "pixels");
-%! rsz = get (0, "screensize");
-%! set (gcf (), "units", "pixels");
-%! fsz = get (gcf (), "position");
-%! set (gcf (), "units", "normalized");
-%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]));
+%! hf = figure ("visible", "off");
+%! old_units = get (0, "units");
+%! unwind_protect
+%!   set (0, "units", "pixels");
+%!   rsz = get (0, "screensize");
+%!   set (gcf (), "units", "pixels");
+%!   fsz = get (gcf (), "position");
+%!   set (gcf (), "units", "normalized");
+%!   pos = get (gcf (), "position");
+%!   assert (pos, (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]));
+%! unwind_protect_cleanup
+%!   close (hf);
+%!   set (0, "units", old_units);
+%! end_unwind_protect
 */
 
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
@@ -4001,238 +4046,100 @@ axes::properties::calc_tightbox (const M
   if (ext(1)+ext(3) > pos(1)+pos(3))
     pos(3) = ext(1)+ext(3)-pos(1);
   return pos;
 }
 
 void
 axes::properties::sync_positions (void)
 {
-  Matrix ref_linset = looseinset.get ().matrix_value ();
-  if (autopos_tag_is ("subplot"))
-    {
-      graphics_object parent_obj = gh_manager::get_object (get_parent ());
-      if (parent_obj.isa ("figure"))
-        {
-           // FIXME: temporarily changed units should be protected
-           //        from interrupts
-           std::string fig_units = parent_obj.get ("units").string_value ();
-           parent_obj.set ("units", "pixels");
-
-           Matrix ref_outbox = outerposition.get ().matrix_value ();
-           ref_outbox(2) += ref_outbox(0);
-           ref_outbox(3) += ref_outbox(1);
-
-           // Find those subplots that are left, right, bottom and top aligned
-           // with the current subplot
-           Matrix kids = parent_obj.get_properties ().get_children ();
-           std::vector<octave_value> aligned;
-           std::vector<bool> l_aligned, b_aligned, r_aligned, t_aligned;
-           for (octave_idx_type i = 0; i < kids.numel (); i++)
-             {
-               graphics_object go = gh_manager::get_object (kids(i));
-               if (go.isa ("axes"))
-                 {
-                   axes::properties& props =
-                     dynamic_cast<axes::properties&> (go.get_properties ());
-                   if (props.autopos_tag_is ("subplot"))
-                     {
-                       Matrix outpos = go.get ("outerposition").matrix_value ();
-                       bool l_align = (std::abs (outpos(0)-ref_outbox(0)) < 1e-15);
-                       bool b_align = (std::abs (outpos(1)-ref_outbox(1)) < 1e-15);
-                       bool r_align = (std::abs (outpos(0)+outpos(2)-ref_outbox(2)) < 1e-15);
-                       bool t_align = (std::abs (outpos(1)+outpos(3)-ref_outbox(3)) < 1e-15);
-                       if (l_align || b_align || r_align || t_align)
-                         {
-                           aligned.push_back (kids(i));
-                           l_aligned.push_back (l_align);
-                           b_aligned.push_back (b_align);
-                           r_aligned.push_back (r_align);
-                           t_aligned.push_back (t_align);
-                           // FIXME: the temporarily deleted tags should be
-                           //        protected from interrupts
-                           props.set_autopos_tag ("none");
-                         }
-                     }
-                 }
-             }
-           // Determine a minimum box which aligns the subplots
-           Matrix ref_box (1, 4, 0.);
-           ref_box(2) = 1.;
-           ref_box(3) = 1.;
-           for (size_t i = 0; i < aligned.size (); i++)
-             {
-               graphics_object go = gh_manager::get_object (aligned[i]);
-               axes::properties& props =
-                 dynamic_cast<axes::properties&> (go.get_properties ());
-               Matrix linset = props.get_looseinset ().matrix_value ();
-               if (l_aligned[i])
-                 linset(0) = std::min (0., linset(0)-0.01);
-               if (b_aligned[i])
-                 linset(1) = std::min (0., linset(1)-0.01);
-               if (r_aligned[i])
-                 linset(2) = std::min (0., linset(2)-0.01);
-               if (t_aligned[i])
-                 linset(3) = std::min (0., linset(3)-0.01);
-               props.set_looseinset (linset);
-               Matrix pos = props.get_position ().matrix_value ();
-               if (l_aligned[i])
-                 ref_box(0) = std::max (ref_box(0), pos(0));
-               if (b_aligned[i])
-                 ref_box(1) = std::max (ref_box(1), pos(1));
-               if (r_aligned[i])
-                 ref_box(2) = std::min (ref_box(2), pos(0)+pos(2));
-               if (t_aligned[i])
-                 ref_box(3) = std::min (ref_box(3), pos(1)+pos(3));
-             }
-           // Set common looseinset values for all aligned subplots and
-           // revert their tag values
-           for (size_t i = 0; i < aligned.size (); i++)
-             {
-               graphics_object go = gh_manager::get_object (aligned[i]);
-               axes::properties& props =
-                 dynamic_cast<axes::properties&> (go.get_properties ());
-               Matrix outpos = props.get_outerposition ().matrix_value ();
-               Matrix linset = props.get_looseinset ().matrix_value ();
-               if (l_aligned[i])
-                 linset(0) = (ref_box(0)-outpos(0))/outpos(2);
-               if (b_aligned[i])
-                 linset(1) = (ref_box(1)-outpos(1))/outpos(3);
-               if (r_aligned[i])
-                 linset(2) = (outpos(0)+outpos(2)-ref_box(2))/outpos(2);
-               if (t_aligned[i])
-                 linset(3) = (outpos(1)+outpos(3)-ref_box(3))/outpos(3);
-               props.set_looseinset (linset);
-               props.set_autopos_tag ("subplot");
-             }
-           parent_obj.set ("units", fig_units);
-        }
-    }
+  // First part is equivalent to `update_tightinset ()'
+  if (activepositionproperty.is ("position"))
+    update_position ();
   else
-    sync_positions (ref_linset);
-}
-
-void
-axes::properties::sync_positions (const Matrix& linset)
-{
-  Matrix pos = position.get ().matrix_value ();
-  Matrix outpos = outerposition.get ().matrix_value ();
-  double lratio = linset(0);
-  double bratio = linset(1);
-  double wratio = 1-linset(0)-linset(2);
-  double hratio = 1-linset(1)-linset(3);
-  if (activepositionproperty.is ("outerposition"))
-    {
-      pos = outpos;
-      pos(0) = outpos(0)+lratio*outpos(2);
-      pos(1) = outpos(1)+bratio*outpos(3);
-      pos(2) = wratio*outpos(2);
-      pos(3) = hratio*outpos(3);
-
-      position = pos;
-      update_transform ();
-      Matrix tightpos = calc_tightbox (pos);
-
-      double thrshldx = 0.005*outpos(2);
-      double thrshldy = 0.005*outpos(3);
-      double minsizex = 0.2*outpos(2);
-      double minsizey = 0.2*outpos(3);
-      bool updatex = true, updatey = true;
-      for (int i = 0; i < 10; i++)
-        {
-          double dt;
-          bool modified = false;
-          dt = outpos(0)+outpos(2)-tightpos(0)-tightpos(2);
-          if (dt < -thrshldx && updatex)
-            {
-              pos(2) += dt;
-              modified = true;
-            }
-          dt = outpos(1)+outpos(3)-tightpos(1)-tightpos(3);
-          if (dt < -thrshldy && updatey)
-            {
-              pos(3) += dt;
-              modified = true;
-            }
-          dt = outpos(0)-tightpos(0);
-          if (dt > thrshldx && updatex)
-            {
-              pos(0) += dt;
-              pos(2) -= dt;
-              modified = true;
-            }
-          dt = outpos(1)-tightpos(1);
-          if (dt > thrshldy && updatey)
-            {
-              pos(1) += dt;
-              pos(3) -= dt;
-              modified = true;
-            }
-
-          // Note: checking limit for minimum axes size
-          if (pos(2) < minsizex)
-            {
-              pos(0) -= 0.5*(minsizex-pos(2));
-              pos(2) = minsizex;
-              updatex = false;
-            }
-          if (pos(3) < minsizey)
-            {
-              pos(1) -= 0.5*(minsizey-pos(3));
-              pos(3) = minsizey;
-              updatey = false;
-            }
-
-          if (modified)
-            {
-              position = pos;
-              update_transform ();
-              tightpos = calc_tightbox (pos);
-            }
-          else
-            break;
-        }
-    }
-  else
-    {
-      update_transform ();
-
-      outpos(0) = pos(0)-pos(2)*lratio/wratio;
-      outpos(1) = pos(1)-pos(3)*bratio/hratio;
-      outpos(2) = pos(2)/wratio;
-      outpos(3) = pos(3)/hratio;
-
-      outerposition = calc_tightbox (outpos);
-    }
-
-  update_insets ();
-}
-
-void
-axes::properties::update_insets (void)
-{
+    update_outerposition ();
+  caseless_str old_units = get_units ();
+  set_units ("normalized");
   Matrix pos = position.get ().matrix_value ();
   Matrix outpos = outerposition.get ().matrix_value ();
   Matrix tightpos = calc_tightbox (pos);
-  // Determine the tightinset = axes_bbox - position
-  Matrix inset (1, 4, 1.0);
-  inset(0) = pos(0)-tightpos(0);
-  inset(1) = pos(1)-tightpos(1);
-  inset(2) = tightpos(0)+tightpos(2)-pos(0)-pos(2);
-  inset(3) = tightpos(1)+tightpos(3)-pos(1)-pos(3);
-  tightinset = inset;
-
-  // Determine the looseinset = outerposition - position
-  inset(0) = pos(0)-outpos(0);
-  inset(1) = pos(1)-outpos(1);
-  inset(2) = outpos(0)+outpos(2)-pos(0)-pos(2);
-  inset(3) = outpos(1)+outpos(3)-pos(1)-pos(3);
-  looseinset = inset;
-}
-
+  Matrix tinset (1, 4, 1.0);
+  tinset(0) = pos(0)-tightpos(0);
+  tinset(1) = pos(1)-tightpos(1);
+  tinset(2) = tightpos(0)+tightpos(2)-pos(0)-pos(2);
+  tinset(3) = tightpos(1)+tightpos(3)-pos(1)-pos(3);
+  tightinset = tinset;
+  set_units (old_units);
+  update_transform ();
+  if (activepositionproperty.is ("position"))
+    update_position ();
+  else
+    update_outerposition ();
+}
+
+/*
+%!testif HAVE_FLTK
+%! hf = figure ("visible", "off");
+%! graphics_toolkit (hf, "fltk");
+%! unwind_protect
+%!   subplot(2,1,1); plot(rand(10,1)); subplot(2,1,2); plot(rand(10,1));
+%!   hax = findall (gcf (), "type", "axes");
+%!   positions = cell2mat (get (hax, "position"));
+%!   outerpositions = cell2mat (get (hax, "outerposition"));
+%!   looseinsets = cell2mat (get (hax, "looseinset"));
+%!   tightinsets = cell2mat (get (hax, "tightinset"));
+%!   subplot(2,1,1); plot(rand(10,1)); subplot(2,1,2); plot(rand(10,1));
+%!   hax = findall (gcf (), "type", "axes");
+%!   assert (cell2mat (get (hax, "position")), positions, 1e-4);
+%!   assert (cell2mat (get (hax, "outerposition")), outerpositions, 1e-4);
+%!   assert (cell2mat (get (hax, "looseinset")), looseinsets, 1e-4);
+%!   assert (cell2mat (get (hax, "tightinset")), tightinsets, 1e-4);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+%!testif HAVE_FLTK
+%! hf = figure ("visible", "off");
+%! graphics_toolkit (hf, "fltk");
+%! fpos = get (hf, "position");
+%! unwind_protect
+%!   plot (rand (3))
+%!   position = get (gca, "position");
+%!   outerposition = get (gca, "outerposition");
+%!   looseinset = get (gca, "looseinset");
+%!   tightinset = get (gca, "tightinset");
+%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)])
+%!   set (hf, "position", fpos);
+%!   assert (get (gca, "outerposition"), outerposition, 0.001)
+%!   assert (get (gca, "position"), position, 0.001)
+%!   assert (get (gca, "looseinset"), looseinset, 0.001)
+%!   assert (get (gca, "tightinset"), tightinset, 0.001)
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+%!testif HAVE_FLTK
+%! hf = figure ("visible", "off");
+%! graphics_toolkit (hf, "fltk");
+%! fpos = get (hf, "position");
+%! set (gca, "activepositionproperty", "position")
+%! unwind_protect
+%!   plot (rand (3))
+%!   position = get (gca, "position");
+%!   outerposition = get (gca, "outerposition");
+%!   looseinset = get (gca, "looseinset");
+%!   tightinset = get (gca, "tightinset");
+%!   set (hf, "position", [fpos(1:2), 2*fpos(3:4)])
+%!   set (hf, "position", fpos);
+%!   assert (get (gca, "position"), position, 0.001)
+%!   assert (get (gca, "outerposition"), outerposition, 0.001)
+%!   assert (get (gca, "looseinset"), looseinset, 0.001)
+%!   assert (get (gca, "tightinset"), tightinset, 0.001)
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+*/
 
 void
 axes::properties::set_text_child (handle_property& hp,
                                   const std::string& who,
                                   const octave_value& v)
 {
   graphics_handle val;
 
@@ -4329,104 +4236,122 @@ axes::properties::set_title (const octav
 }
 
 void
 axes::properties::set_defaults (base_graphics_object& obj,
                                 const std::string& mode)
 {
   box = "on";
   colororder = default_colororder ();
-  dataaspectratio = Matrix (1, 3, 1.0);
+  // Note: dataspectratio will be set through update_aspectratios
   dataaspectratiomode = "auto";
   layer = "bottom";
 
   Matrix tlim (1, 2, 0.0);
   tlim(1) = 1;
   xlim = tlim;
   ylim = tlim;
   zlim = tlim;
 
   Matrix cl (1, 2, 0);
   cl(1) = 1;
   clim = cl;
 
+  alim = tlim;
+
   xlimmode = "auto";
   ylimmode = "auto";
   zlimmode = "auto";
   climmode = "auto";
+  alimmode = "auto";
 
   xgrid = "off";
   ygrid = "off";
   zgrid = "off";
   xminorgrid = "off";
   yminorgrid = "off";
   zminorgrid = "off";
   xtick = Matrix ();
   ytick = Matrix ();
   ztick = Matrix ();
   xtickmode = "auto";
   ytickmode = "auto";
   ztickmode = "auto";
+  xminortick = "off";
+  yminortick = "off";
+  zminortick = "off";
   xticklabel = "";
   yticklabel = "";
   zticklabel = "";
   xticklabelmode = "auto";
   yticklabelmode = "auto";
   zticklabelmode = "auto";
+
+  interpreter = "none";
+
   color = color_values ("white");
   xcolor = color_values ("black");
   ycolor = color_values ("black");
   zcolor = color_values ("black");
   xscale = "linear";
   yscale = "linear";
   zscale = "linear";
   xdir = "normal";
   ydir = "normal";
   zdir = "normal";
   yaxislocation = "left";
   xaxislocation = "bottom";
 
-  // Note: camera properties will be set through update_transform
+  Matrix tview (1, 2, 0.0);
+  tview(1) = 90;
+  view = tview;
+
+  __hold_all__ = "off";
+  nextplot = "replace";
+
+  ambientlightcolor = Matrix (1, 3, 1.0);
+
+  // Note: camera properties (not mode) will be set in update_transform
   camerapositionmode = "auto";
   cameratargetmode = "auto";
   cameraupvectormode = "auto";
   cameraviewanglemode = "auto";
-  plotboxaspectratio = Matrix (1, 3, 1.0);
+
   drawmode = "normal";
+
+  fontangle = "normal";
+  fontname = OCTAVE_DEFAULT_FONTNAME;
+  fontsize = 10;
+  fontunits = "points";
+  fontweight = "normal";
+
   gridlinestyle = ":";
   linestyleorder = "-";
   linewidth = 0.5;
   minorgridlinestyle = ":";
-  // Note: plotboxaspectratio will be set through update_aspectratiors
+
+  // Note: plotboxaspectratio will be set through update_aspectratios
   plotboxaspectratiomode = "auto";
   projection = "orthographic";
+
   tickdir = "in";
   tickdirmode = "auto";
   ticklength = default_axes_ticklength ();
+
   tightinset = Matrix (1, 4, 0.0);
 
   sx = "linear";
   sy = "linear";
   sz = "linear";
 
-  Matrix tview (1, 2, 0.0);
-  tview(1) = 90;
-  view = tview;
-
   visible = "on";
-  nextplot = "replace";
-
+
+  // Replace preserves Position and Units properties
   if (mode != "replace")
     {
-      fontangle = "normal";
-      fontname = OCTAVE_DEFAULT_FONTNAME;
-      fontsize = 10;
-      fontunits = "points";
-      fontweight = "normal";
-
       outerposition = default_axes_outerposition ();
       position = default_axes_position ();
       activepositionproperty = "outerposition";
     }
 
   delete_children (true);
 
   xlabel = gh_manager::make_graphics_handle ("text", __myhandle__,
@@ -4478,17 +4403,17 @@ axes::properties::set_defaults (base_gra
   xset (title.handle_value (), "autopos_tag", "title");
 
   adopt (xlabel.handle_value ());
   adopt (ylabel.handle_value ());
   adopt (zlabel.handle_value ());
   adopt (title.handle_value ());
 
   update_transform ();
-  update_insets ();
+  sync_positions ();
   override_defaults (obj);
 }
 
 void
 axes::properties::delete_text_child (handle_property& hp)
 {
   graphics_handle h = hp.handle_value ();
 
@@ -4684,17 +4609,17 @@ axes::properties::update_camera (void)
   Matrix xlimits = sx.scale (get_xlim ().matrix_value ());
   Matrix ylimits = sy.scale (get_ylim ().matrix_value ());
   Matrix zlimits = sz.scale (get_zlim ().matrix_value ());
 
   double xo = xlimits(xd > 0 ? 0 : 1);
   double yo = ylimits(yd > 0 ? 0 : 1);
   double zo = zlimits(zd > 0 ? 0 : 1);
 
-  Matrix pb  = get_plotboxaspectratio ().matrix_value ();
+  Matrix pb = get_plotboxaspectratio ().matrix_value ();
 
   bool autocam = (camerapositionmode_is ("auto")
                   && cameratargetmode_is ("auto")
                   && cameraupvectormode_is ("auto")
                   && cameraviewanglemode_is ("auto"));
   bool dowarp = (autocam && dataaspectratiomode_is ("auto")
                  && plotboxaspectratiomode_is ("auto"));
 
@@ -5486,18 +5411,17 @@ max_axes_scale (double& s, Matrix& limit
 {
   if (tight)
     {
       double minval = octave_Inf;
       double maxval = -octave_Inf;
       double min_pos = octave_Inf;
       double max_neg = -octave_Inf;
       get_children_limits (minval, maxval, min_pos, max_neg, kids, limit_type);
-      if (!xisinf (minval) && !xisnan (minval)
-          && !xisinf (maxval) && !xisnan (maxval))
+      if (xfinite (minval) && xfinite (maxval))
         {
           limits(0) = minval;
           limits(1) = maxval;
           s = xmax(s, (maxval - minval) / (pbfactor * dafactor));
         }
     }
   else
     s = xmax(s, (limits(1) - limits(0)) / (pbfactor * dafactor));
@@ -5837,16 +5761,66 @@ axes::properties::set_zticklabel (const 
           zticklabel.run_listeners (POSTSET);
           mark_modified ();
         }
       else
         set_zticklabelmode ("manual");
     }
 }
 
+// Almost identical to convert_ticklabel_string but it only accepts
+// cellstr or string, not numeric input.
+static octave_value
+convert_linestyleorder_string (const octave_value& val)
+{
+  octave_value retval = val;
+
+  if (val.is_cellstr ())
+    {
+      // Always return a column vector for Matlab Compatibility
+      if (val.columns () > 1)
+        retval = val.reshape (dim_vector (val.numel (), 1));
+    }
+  else
+    {
+      string_vector sv;
+      if (val.is_string () && val.rows () == 1)
+        {
+          std::string valstr = val.string_value ();
+          std::istringstream iss (valstr);
+          std::string tmpstr;
+
+          // Split string with delimiter '|'
+          while (std::getline (iss, tmpstr, '|'))
+            sv.append (tmpstr);
+          
+          // If string ends with '|' Matlab appends a null string
+          if (*valstr.rbegin () == '|')
+            sv.append (std::string (""));
+        }
+      else
+        return retval;
+
+      charMatrix chmat (sv, ' ');
+
+      retval = octave_value (chmat);
+    }
+
+  return retval;
+}
+
+void
+axes::properties::set_linestyleorder (const octave_value& v)
+{
+  if (!error_state)
+    {
+      linestyleorder.set (convert_linestyleorder_string (v), false);
+    }
+}
+
 void
 axes::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
       if (units.set (v, true))
         {
@@ -5968,26 +5942,26 @@ axes::get_default (const caseless_str& n
 // FIXME -- maybe this should go into array_property class?
 /*
 static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const array_property& data)
 {
   double val = data.min_val ();
-  if (! (xisinf (val) || xisnan (val)) && val < min_val)
+  if (xfinite (val) && val < min_val)
     min_val = val;
   val = data.max_val ();
-  if (! (xisinf (val) || xisnan (val)) && val > max_val)
+  if (xfinite (val) && val > max_val)
     max_val = val;
   val = data.min_pos ();
-  if (! (xisinf (val) || xisnan (val)) && val > 0 && val < min_pos)
+  if (xfinite (val) && val > 0 && val < min_pos)
     min_pos = val;
   val = data.max_neg ();
-  if (! (xisinf (val) || xisnan (val)) && val < 0 && val > max_neg)
+  if (xfinite (val) && val < 0 && val > max_neg)
     max_neg = val;
 }
 */
 
 static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const octave_value& data)
@@ -5996,29 +5970,29 @@ check_limit_vals (double& min_val, doubl
     {
       Matrix m = data.matrix_value ();
 
       if (! error_state && m.numel () == 4)
         {
           double val;
 
           val = m(0);
-          if (! (xisinf (val) || xisnan (val)) && val < min_val)
+          if (xfinite (val) && val < min_val)
             min_val = val;
 
           val = m(1);
-          if (! (xisinf (val) || xisnan (val)) && val > max_val)
+          if (xfinite (val) && val > max_val)
             max_val = val;
 
           val = m(2);
-          if (! (xisinf (val) || xisnan (val)) && val > 0 && val < min_pos)
+          if (xfinite (val) && val > 0 && val < min_pos)
             min_pos = val;
 
           val = m(3);
-          if (! (xisinf (val) || xisnan (val)) && val < 0 && val > max_neg)
+          if (xfinite (val) && val < 0 && val > max_neg)
             max_neg = val;
         }
     }
 }
 
 // magform(x) Returns (a, b), where x = a * 10^b, abs (a) >= 1., and b is
 // integer.
 
@@ -6347,17 +6321,17 @@ axes::properties::get_ticklabel_extents 
     {
       double val = ticks(i);
       if (limits(0) <= val && val <= limits(1))
         {
           std::string label (ticklabels(i));
           label.erase (0, label.find_first_not_of (" "));
           label = label.substr (0, label.find_last_not_of (" ")+1);
 #ifdef HAVE_FREETYPE
-          ext = text_renderer.get_extent (label);
+          ext = text_renderer.get_extent (label, 0.0, "none");
           wmax = std::max (wmax, ext(0));
           hmax = std::max (hmax, ext(1));
 #else
           // FIXME: find a better approximation
           int len = label.length ();
           wmax = std::max (wmax, 0.5*fontsize*len);
           hmax = fontsize;
 #endif
@@ -6473,26 +6447,26 @@ axes::update_axis_limits (const std::str
 
   Matrix limits;
   double val;
 
 #define FIX_LIMITS \
   if (limits.numel () == 4) \
     { \
       val = limits(0); \
-      if (! (xisinf (val) || xisnan (val))) \
+      if (xfinite (val)) \
         min_val = val; \
       val = limits(1); \
-      if (! (xisinf (val) || xisnan (val))) \
+      if (xfinite (val)) \
         max_val = val; \
       val = limits(2); \
-      if (! (xisinf (val) || xisnan (val))) \
+      if (xfinite (val)) \
         min_pos = val; \
       val = limits(3); \
-      if (! (xisinf (val) || xisnan (val))) \
+      if (xfinite (val)) \
         max_neg = val; \
     } \
   else \
     { \
       limits.resize (4, 1); \
       limits(0) = min_val; \
       limits(1) = max_val; \
       limits(2) = min_pos; \
@@ -7072,16 +7046,18 @@ void
 axes::initialize (const graphics_object& go)
 {
   base_graphics_object::initialize (go);
 
   xinitialize (xproperties.get_title ());
   xinitialize (xproperties.get_xlabel ());
   xinitialize (xproperties.get_ylabel ());
   xinitialize (xproperties.get_zlabel ());
+
+  xproperties.sync_positions ();
 }
 
 // ---------------------------------------------------------------------
 
 Matrix
 line::properties::compute_xlim (void) const
 {
   Matrix m (1, 4);
@@ -7181,17 +7157,18 @@ text::properties::update_text_extent (vo
 
   // FIXME: string should be parsed only when modified, for efficiency
 
   octave_value string_prop = get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
-                           halign, valign, get_rotation ());
+                           halign, valign, get_rotation (),
+                           get_interpreter ());
   /* The bbox is relative to the text's position.
      We'll leave it that way, because get_position () does not return
      valid results when the text is first constructed.
      Conversion to proper coordinates is performed in get_extent. */
   set_extent (bbox);
 
 #endif
 
@@ -7446,26 +7423,26 @@ hggroup::update_axis_limits (const std::
     {
       limits = xproperties.get_alim ().matrix_value ();
       update_type = 'a';
     }
 
   if (limits.numel () == 4)
     {
       val = limits(0);
-      if (! (xisinf (val) || xisnan (val)))
+      if (xfinite (val))
         min_val = val;
       val = limits(1);
-      if (! (xisinf (val) || xisnan (val)))
+      if (xfinite (val))
         max_val = val;
       val = limits(2);
-      if (! (xisinf (val) || xisnan (val)))
+      if (xfinite (val))
         min_pos = val;
       val = limits(3);
-      if (! (xisinf (val) || xisnan (val)))
+      if (xfinite (val))
         max_neg = val;
     }
   else
     {
       limits.resize (4,1);
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
@@ -7626,24 +7603,25 @@ uicontrol::properties::update_text_exten
 
   text_element *elt;
   ft_render text_renderer;
   Matrix box;
 
   // FIXME: parsed content should be cached for efficiency
   // FIXME: support multiline text
 
-  elt = text_parser_none ().parse (get_string_string ());
+  elt = text_parser::parse (get_string_string (), "none");
 #ifdef HAVE_FONTCONFIG
   text_renderer.set_font (get_fontname (),
                           get_fontweight (),
                           get_fontangle (),
                           get_fontsize ());
 #endif
   box = text_renderer.get_extent (elt, 0);
+  delete elt;
 
   Matrix ext (1, 4, 0.0);
 
   // FIXME: also handle left and bottom components
 
   ext(0) = ext(1) = 1;
   ext(2) = box(0);
   ext(3) = box(1);
@@ -8442,20 +8420,21 @@ root_figure::init_factory_properties (vo
 }
 
 // ---------------------------------------------------------------------
 
 DEFUN (ishandle, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ishandle (@var{h})\n\
 Return true if @var{h} is a graphics handle and false otherwise.\n\
+\n\
 @var{h} may also be a matrix of handles in which case a logical\n\
 array is returned that is true where the elements of @var{h} are\n\
 graphics handles and false where they are not.\n\
-@seealso{isfigure}\n\
+@seealso{isaxes, isfigure}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 1)
     retval = is_handle (args(0));
@@ -8517,19 +8496,20 @@ Undocumented internal function.\n\
 
   return retval;
 }
 
 DEFUN (reset, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} reset (@var{h}, @var{property})\n\
 Remove any defaults set for the handle @var{h}.  The default figure\n\
-properties of \"position\", \"units\", \"windowstyle\" and\n\
-\"paperunits\" and the default axes properties of \"position\" and \"units\"\n\
-are not reset.\n\
+properties of @qcode{\"position\"}, @qcode{\"units\"},\n\
+@qcode{\"windowstyle\"} and @qcode{\"paperunits\"} and the default axes\n\
+properties of @qcode{\"position\"} and @qcode{\"units\"} are not reset.\n\
+@seealso{cla, clf}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
@@ -9103,35 +9083,37 @@ Undocumented internal function.\n\
 int
 calc_dimensions (const graphics_object& go)
 {
 
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
-
-  if ((go.isa ("line") || go.isa ("patch")) && ! go.get("zdata").is_empty ())
+  else if ((go.isa ("line") || go.isa ("patch"))
+            && ! go.get ("zdata").is_empty ())
     nd = 3;
-
-  Matrix kids = go.get_properties ().get_children ();
-
-  for (octave_idx_type i = 0; i < kids.length (); i++)
-    {
-      graphics_handle hnd = gh_manager::lookup (kids(i));
-
-      if (hnd.ok ())
-        {
-          const graphics_object& kid = gh_manager::get_object (hnd);
-
-          if (kid.valid_object ())
-            nd = calc_dimensions (kid);
-
-          if (nd == 3)
-            break;
+  else
+    {
+      Matrix kids = go.get_properties ().get_children ();
+
+      for (octave_idx_type i = 0; i < kids.length (); i++)
+        {
+          graphics_handle hnd = gh_manager::lookup (kids(i));
+
+          if (hnd.ok ())
+            {
+              const graphics_object& kid = gh_manager::get_object (hnd);
+
+              if (kid.valid_object ())
+                nd = calc_dimensions (kid);
+
+              if (nd == 3)
+                break;
+            }
         }
     }
 
   return nd;
 }
 
 DEFUN (__calc_dimensions__, args, ,
   "-*- texinfo -*-\n\
@@ -9141,27 +9123,25 @@ object, whether 2 or 3.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      double h = args(0).double_value ();
-
-      if (! error_state)
-        retval = calc_dimensions (gh_manager::get_object (h));
-      else
-        error ("__calc_dimensions__: expecting graphics handle as only argument");
-    }
+  if (nargin != 1)
+    print_usage ();
+
+  double h = args(0).double_value ();
+
+  if (! error_state)
+    retval = calc_dimensions (gh_manager::get_object (h));
   else
-    print_usage ();
+    error ("__calc_dimensions__: expecting graphics handle as only argument");
 
   return retval;
 }
 
 DEFUN (__go_axes__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes__ (@var{parent})\n\
 Undocumented internal function.\n\
@@ -9500,16 +9480,26 @@ Internal function: returns the pixel siz
   else
     print_usage ();
 
   return retval;
 }
 
 gtk_manager *gtk_manager::instance = 0;
 
+gtk_manager::gtk_manager (void)
+  : dtk (), available_toolkits (), loaded_toolkits ()
+{
+#if defined (HAVE_FLTK)
+  dtk = "fltk";
+#else
+  dtk = "gnuplot";
+#endif
+}
+
 void
 gtk_manager::create_instance (void)
 {
   instance = new gtk_manager ();
 
   if (instance)
     singleton_cleanup_list::add (cleanup_instance);
 }
@@ -9601,17 +9591,17 @@ Return a cell array of the currently loa
 
 DEFUN (drawnow, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} drawnow ()\n\
 @deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
 @deftypefnx {Built-in Function} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.  The event queue is flushed and\n\
 any callbacks generated are executed.  With the optional argument\n\
-@code{\"expose\"}, only graphic objects are updated and no other events or\n\
+@qcode{\"expose\"}, only graphic objects are updated and no other events or\n\
 callbacks are processed.\n\
 The third calling form of @code{drawnow} is for debugging and is\n\
 undocumented.\n\
 @end deftypefn")
 {
   static int drawnow_executing = 0;
 
   octave_value retval;
@@ -9786,16 +9776,17 @@ Example:\n\
 function my_listener (h, dummy, p1)\n\
   fprintf (\"my_listener called with p1=%s\\n\", p1);\n\
 endfunction\n\
 \n\
 addlistener (gcf, \"position\", @{@@my_listener, \"my string\"@})\n\
 @end group\n\
 @end example\n\
 \n\
+@seealso{addproperty, hggroup}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
@@ -9978,16 +9969,17 @@ Examples:\n\
 @example\n\
 @group\n\
 addproperty (\"my_property\", gcf, \"string\", \"a string value\");\n\
 addproperty (\"my_radio\", gcf, \"radio\", \"val_1|val_2|@{val_3@}\");\n\
 addproperty (\"my_style\", gcf, \"linelinestyle\", \"--\");\n\
 @end group\n\
 @end example\n\
 \n\
+@seealso{addlistener, hggroup}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
@@ -10206,21 +10198,22 @@ waitfor_del_listener (const octave_value
 
 DEFUN (waitfor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} waitfor (@var{h})\n\
 @deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop})\n\
 @deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop}, @var{value})\n\
 @deftypefnx {Built-in Function} {} waitfor (@dots{}, \"timeout\", @var{timeout})\n\
 Suspend the execution of the current program until a condition is\n\
-satisfied on the graphics handle @var{h}.  While the program is suspended\n\
-graphics events are still being processed normally, allowing callbacks to\n\
-modify the state of graphics objects.  This function is reentrant and can be\n\
-called from a callback, while another @code{waitfor} call is pending at\n\
-top-level.\n\
+satisfied on the graphics handle @var{h}.\n\
+\n\
+While the program is suspended graphics events are still being processed\n\
+normally, allowing callbacks to modify the state of graphics objects.  This\n\
+function is reentrant and can be called from a callback, while another\n\
+@code{waitfor} call is pending at the top-level.\n\
 \n\
 In the first form, program execution is suspended until the graphics object\n\
 @var{h} is destroyed.  If the graphics handle is invalid, the function\n\
 returns immediately.\n\
 \n\
 In the second form, execution is suspended until the graphics object is\n\
 destroyed or the property named @var{prop} is modified.  If the graphics\n\
 handle is invalid or the property does not exist, the function returns\n\
@@ -10237,17 +10230,17 @@ This timeout value is the number of seco
 true.  @var{timeout} must be at least 1. If a smaller value is specified, a\n\
 warning is issued and a value of 1 is used instead.  If the timeout value is\n\
 not an integer, it is truncated towards 0.\n\
 \n\
 To define a condition on a property named @code{timeout}, use the string\n\
 @code{\\timeout} instead.\n\
 \n\
 In all cases, typing CTRL-C stops program execution immediately.\n\
-@seealso{isequal}\n\
+@seealso{waitforbuttonpress, isequal}\n\
 @end deftypefn")
 {
   if (args.length () > 0)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
         {
@@ -10405,17 +10398,17 @@ In all cases, typing CTRL-C stops progra
                     error ("waitfor: invalid timeout value, expected a value >= 1");
                 }
               else
                 error ("waitfor: missing timeout value");
             }
 
           // FIXME: There is still a "hole" in the following loop. The code
           //        assumes that an object handle is unique, which is a fair
-          //        assumptions, except for figures. If a figure is destroyed
+          //        assumption, except for figures. If a figure is destroyed
           //        then recreated with the same figure ID, within the same
           //        run of event hooks, then the figure destruction won't be
           //        caught and the loop will not stop. This is an unlikely
           //        possibility in practice, though.
           //
           //        Using deletefcn callback is also unreliable as it could be
           //        modified during a callback execution and the waitfor loop
           //        would not stop.
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -32,133 +32,33 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 #include <list>
 #include <map>
 #include <set>
 #include <sstream>
 #include <string>
 
 #include "caseless-str.h"
-#include "lo-ieee.h"
 
 #include "gripes.h"
+#include "oct-handle.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
 #include "oct-refcount.h"
 #include "ov.h"
 #include "txt-eng-ft.h"
 
-// FIXME -- maybe this should be a configure option?
+// FIXME: maybe this should be a configure option?
 // Matlab defaults to "Helvetica", but that causes problems for many
 // gnuplot users.
 #if !defined (OCTAVE_DEFAULT_FONTNAME)
 #define OCTAVE_DEFAULT_FONTNAME "*"
 #endif
 
-// ---------------------------------------------------------------------
-
-class graphics_handle
-{
-public:
-  graphics_handle (void) : val (octave_NaN) { }
-
-  graphics_handle (const octave_value& a);
-
-  graphics_handle (int a) : val (a) { }
-
-  graphics_handle (double a) : val (a) { }
-
-  graphics_handle (const graphics_handle& a) : val (a.val) { }
-
-  graphics_handle& operator = (const graphics_handle& a)
-  {
-    if (&a != this)
-      val = a.val;
-
-    return *this;
-  }
-
-  ~graphics_handle (void) { }
-
-  double value (void) const { return val; }
-
-  octave_value as_octave_value (void) const
-  {
-    return ok () ? octave_value (val) : octave_value (Matrix ());
-  }
-
-  // Prefix increment/decrement operators.
-  graphics_handle& operator ++ (void)
-  {
-    ++val;
-    return *this;
-  }
-
-  graphics_handle& operator -- (void)
-  {
-    --val;
-    return *this;
-  }
-
-  // Postfix increment/decrement operators.
-  const graphics_handle operator ++ (int)
-  {
-    graphics_handle old_value = *this;
-    ++(*this);
-    return old_value;
-  }
-
-  const graphics_handle operator -- (int)
-  {
-    graphics_handle old_value = *this;
-    --(*this);
-    return old_value;
-  }
-
-  bool ok (void) const { return ! xisnan (val); }
-
-private:
-  double val;
-};
-
-inline bool
-operator == (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () == b.value ();
-}
-
-inline bool
-operator != (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () != b.value ();
-}
-
-inline bool
-operator < (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () < b.value ();
-}
-
-inline bool
-operator <= (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () <= b.value ();
-}
-
-inline bool
-operator >= (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () >= b.value ();
-}
-
-inline bool
-operator > (const graphics_handle& a, const graphics_handle& b)
-{
-  return a.value () > b.value ();
-}
+typedef octave_handle graphics_handle;
 
 // ---------------------------------------------------------------------
 
 class base_scaler
 {
 public:
   base_scaler (void) { }
 
@@ -1478,17 +1378,17 @@ public:
 
 protected:
   bool do_set (const octave_value& v)
     {
       octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
 
       if (validate (tmp))
         {
-          // FIXME -- should we check for actual data change?
+          // FIXME: should we check for actual data change?
           if (! is_equal (tmp))
             {
               data = tmp;
 
               get_data_limits ();
 
               return true;
             }
@@ -2356,20 +2256,17 @@ public:
 
   static std::string default_toolkit (void)
   {
     return instance_ok () ? instance->do_default_toolkit () : std::string ();
   }
 
 private:
 
-  // FIXME -- default toolkit should be configurable.
-
-  gtk_manager (void)
-    : dtk ("gnuplot"), available_toolkits (), loaded_toolkits () { }
+  gtk_manager (void);
 
   ~gtk_manager (void) { }
 
   OCTINTERP_API static void create_instance (void);
 
   static bool instance_ok (void)
   {
     bool retval = true;
@@ -2623,32 +2520,32 @@ public:
 
   void renumber_parent (graphics_handle new_gh)
     {
       parent = new_gh;
     }
 
   static property_list::pval_map_type factory_defaults (void);
 
-  // FIXME -- these functions should be generated automatically by the
-  // genprops.awk script.
+  // FIXME: these functions should be generated automatically by the
+  //        genprops.awk script.
   //
   // EMIT_BASE_PROPERTIES_GET_FUNCTIONS
 
+  virtual octave_value get_alim (void) const { return octave_value (); }
+  virtual octave_value get_clim (void) const { return octave_value (); }
   virtual octave_value get_xlim (void) const { return octave_value (); }
   virtual octave_value get_ylim (void) const { return octave_value (); }
   virtual octave_value get_zlim (void) const { return octave_value (); }
-  virtual octave_value get_clim (void) const { return octave_value (); }
-  virtual octave_value get_alim (void) const { return octave_value (); }
-
+
+  virtual bool is_aliminclude (void) const { return false; }
+  virtual bool is_climinclude (void) const { return false; }
   virtual bool is_xliminclude (void) const { return false; }
   virtual bool is_yliminclude (void) const { return false; }
   virtual bool is_zliminclude (void) const { return false; }
-  virtual bool is_climinclude (void) const { return false; }
-  virtual bool is_aliminclude (void) const { return false; }
 
   bool is_handle_visible (void) const;
 
   std::set<std::string> dynamic_property_names (void) const;
 
   bool has_dynamic_property (const std::string& pname);
 
 protected:
@@ -2674,23 +2571,22 @@ protected:
     radio_property handlevisibility , "{on}|callback|off"
     bool_property hittest , "on"
     bool_property interruptible , "on"
     handle_property parent fs , p
     bool_property selected , "off"
     bool_property selectionhighlight , "on"
     string_property tag s , ""
     string_property type frs , ty
+    handle_property uicontextmenu , graphics_handle ()
     any_property userdata , Matrix ()
     bool_property visible , "on"
-    // additional (octave-specific) properties
+    // additional (Octave-specific) properties
     bool_property __modified__ s , "on"
     graphics_handle __myhandle__ fhrs , mh
-    // FIXME -- should this really be here?
-    handle_property uicontextmenu , graphics_handle ()
   END_PROPERTIES
 
 protected:
   struct cmp_caseless_str
     {
       bool operator () (const caseless_str &a, const caseless_str &b) const
         {
           std::string a1 = a;
@@ -3105,51 +3001,51 @@ public:
   }
 
   bool valid_object (void) const { return rep->valid_object (); }
 
   std::string type (void) const { return rep->type (); }
 
   operator bool (void) const { return rep->valid_object (); }
 
-  // FIXME -- these functions should be generated automatically by the
-  // genprops.awk script.
+  // FIXME: these functions should be generated automatically by the
+  //        genprops.awk script.
   //
   // EMIT_GRAPHICS_OBJECT_GET_FUNCTIONS
 
+  octave_value get_alim (void) const
+  { return get_properties ().get_alim (); }
+
+  octave_value get_clim (void) const
+  { return get_properties ().get_clim (); }
+
   octave_value get_xlim (void) const
   { return get_properties ().get_xlim (); }
 
   octave_value get_ylim (void) const
   { return get_properties ().get_ylim (); }
 
   octave_value get_zlim (void) const
   { return get_properties ().get_zlim (); }
 
-  octave_value get_clim (void) const
-  { return get_properties ().get_clim (); }
-
-  octave_value get_alim (void) const
-  { return get_properties ().get_alim (); }
+  bool is_aliminclude (void) const
+  { return get_properties ().is_aliminclude (); }
+
+  bool is_climinclude (void) const
+  { return get_properties ().is_climinclude (); }
 
   bool is_xliminclude (void) const
   { return get_properties ().is_xliminclude (); }
 
   bool is_yliminclude (void) const
   { return get_properties ().is_yliminclude (); }
 
   bool is_zliminclude (void) const
   { return get_properties ().is_zliminclude (); }
 
-  bool is_climinclude (void) const
-  { return get_properties ().is_climinclude (); }
-
-  bool is_aliminclude (void) const
-  { return get_properties ().is_aliminclude (); }
-
   bool is_handle_visible (void) const
   { return get_properties ().is_handle_visible (); }
 
   graphics_toolkit get_toolkit (void) const { return rep->get_toolkit (); }
 
   void add_property_listener (const std::string& nm, const octave_value& v,
                               listener_mode mode = POSTSET)
     { rep->add_property_listener (nm, v, mode); }
@@ -3182,38 +3078,48 @@ public:
     void remove_child (const graphics_handle& h);
 
     Matrix get_boundingbox (bool internal = false,
                             const Matrix& parent_pix_size = Matrix ()) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
-    // FIXME -- it seems strange to me that the diary, diaryfile,
-    // echo, format, formatspacing, language, and recursionlimit
-    // properties are here.  WTF do they have to do with graphics?
+    // FIXME: it seems strange to me that the diary, diaryfile,
+    // echo, errormessage, format, formatspacing, language, and
+    // recursionlimit properties are here.
+    // WTF do they have to do with graphics?
     // Also note that these properties (and the monitorpositions,
     // pointerlocation, and pointerwindow properties) are not yet used
     // by Octave, so setting them will have no effect, and changes
     // made elswhere (say, the diary or format functions) will not
     // cause these properties to be updated.
+    // ANSWER: Matlab defines these properties and uses them in
+    // the same way that Octave uses an internal static variable to
+    // keep track of state.  set (0, "echo", "on") is equivalent
+    // to Octave's echo ("on").  Maybe someday we can connect callbacks
+    // that actually call Octave's own functions for this.
+
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (root_figure, root)
       handle_property callbackobject Sr , graphics_handle ()
       array_property commandwindowsize r , Matrix (1, 2, 0)
       handle_property currentfigure S , graphics_handle ()
       bool_property diary , "off"
       string_property diaryfile , "diary"
       bool_property echo , "off"
-      radio_property format , "+|bank|bit|debug|hex|long|longe|longeng|longg|native-bit|native-hex|rational|{short}|shorte|shorteng|shortg"
-      radio_property formatspacing , "{loose}|compact"
+      string_property errormessage , ""
+      string_property fixedwidthfontname , "Courier"
+      radio_property format , "+|bank|bit|hex|long|longe|longeng|longg|native-bit|native-hex|none|rational|{short}|shorte|shorteng|shortg"
+      radio_property formatspacing , "compact|{loose}"
       string_property language , "ascii"
       array_property monitorpositions , Matrix (1, 4, 0)
       array_property pointerlocation , Matrix (1, 2, 0)
-      double_property pointerwindow , 0.0
+      double_property pointerwindow r , 0.0
       double_property recursionlimit , 256.0
       double_property screendepth r , default_screendepth ()
       double_property screenpixelsperinch r , default_screenpixelsperinch ()
       array_property screensize r , default_screensize ()
       bool_property showhiddenhandles , "off"
       radio_property units U , "inches|centimeters|normalized|points|{pixels}"
     END_PROPERTIES
 
@@ -3388,71 +3294,75 @@ public:
     void update_units (const caseless_str& old_units);
 
     void update_paperunits (const caseless_str& old_paperunits);
 
     std::string get_title (void) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (figure)
-      any_property __plot_stream__ h , Matrix ()
-      bool_property __enhanced__ h , "on"
-      radio_property nextplot , "new|{add}|replacechildren|replace"
+      array_property alphamap , Matrix (64, 1, 1)
+      callback_property buttondownfcn , Matrix ()
       callback_property closerequestfcn , "closereq"
+      color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
+      array_property colormap , jet_colormap ()
       handle_property currentaxes S , graphics_handle ()
-      array_property colormap , jet_colormap ()
-      radio_property paperorientation U , "{portrait}|landscape|rotated"
-      color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
-      array_property alphamap , Matrix (64, 1, 1)
       string_property currentcharacter r , ""
       handle_property currentobject r , graphics_handle ()
       array_property currentpoint r , Matrix (2, 1, 0)
       bool_property dockcontrols , "off"
       bool_property doublebuffer , "on"
       string_property filename , ""
       bool_property integerhandle S , "on"
       bool_property inverthardcopy , "off"
       callback_property keypressfcn , Matrix ()
       callback_property keyreleasefcn , Matrix ()
       radio_property menubar , "none|{figure}"
       double_property mincolormap , 64
       string_property name , ""
+      radio_property nextplot , "new|{add}|replacechildren|replace"
       bool_property numbertitle , "on"
       array_property outerposition s , Matrix (1, 4, -1.0)
-      radio_property paperunits Su , "{inches}|centimeters|normalized|points"
+      radio_property paperorientation U , "{portrait}|landscape|rotated"
       array_property paperposition , default_figure_paperposition ()
       radio_property paperpositionmode , "auto|{manual}"
       array_property papersize U , default_figure_papersize ()
       radio_property papertype SU , "{usletter}|uslegal|a0|a1|a2|a3|a4|a5|b0|b1|b2|b3|b4|b5|arch-a|arch-b|arch-c|arch-d|arch-e|a|b|c|d|e|tabloid|<custom>"
+      radio_property paperunits Su , "{inches}|centimeters|normalized|points"
       radio_property pointer , "crosshair|fullcrosshair|{arrow}|ibeam|watch|topl|topr|botl|botr|left|top|right|bottom|circle|cross|fleur|custom|hand"
       array_property pointershapecdata , Matrix (16, 16, 0)
       array_property pointershapehotspot , Matrix (1, 2, 0)
       array_property position s , default_figure_position ()
       radio_property renderer , "{painters}|zbuffer|opengl|none"
       radio_property renderermode , "{auto}|manual"
       bool_property resize , "on"
       callback_property resizefcn , Matrix ()
       radio_property selectiontype , "{normal}|open|alt|extend"
       radio_property toolbar , "none|{auto}|figure"
       radio_property units Su , "inches|centimeters|normalized|points|{pixels}|characters"
       callback_property windowbuttondownfcn , Matrix ()
       callback_property windowbuttonmotionfcn , Matrix ()
       callback_property windowbuttonupfcn , Matrix ()
-      callback_property windowbuttonwheelfcn , Matrix ()
+      callback_property windowkeypressfcn , Matrix ()
+      callback_property windowkeyreleasefcn , Matrix ()
+      callback_property windowscrollwheelfcn , Matrix ()
       radio_property windowstyle , "{normal}|modal|docked"
       string_property wvisual , ""
       radio_property wvisualmode , "{auto}|manual"
       string_property xdisplay , ""
       string_property xvisual , ""
       radio_property xvisualmode , "{auto}|manual"
-      callback_property buttondownfcn , Matrix ()
-      string_property __graphics_toolkit__ s , "gnuplot"
+      // Octave-specific properties
+      bool_property __enhanced__ h , "on"
+      string_property __graphics_toolkit__ s , gtk_manager::default_toolkit ()
       any_property __guidata__ h , Matrix ()
+      any_property __plot_stream__ h , Matrix ()
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         colormap.add_constraint (dim_vector (-1, 3));
         alphamap.add_constraint (dim_vector (-1, 1));
         paperposition.add_constraint (dim_vector (1, 4));
@@ -3657,16 +3567,18 @@ public:
     void update_aspectratios (void);
     void update_transform (void)
       {
         update_aspectratios ();
         update_camera ();
         update_axes_layout ();
       }
 
+    void sync_positions (void);
+
     void update_autopos (const std::string& elem_type);
     void update_xlabel_position (void);
     void update_ylabel_position (void);
     void update_zlabel_position (void);
     void update_title_position (void);
 
     graphics_xform get_transform (void) const
       { return graphics_xform (x_render, x_render_inv, sx, sy, sz, x_zlim); }
@@ -3757,123 +3669,126 @@ public:
 
     void set_text_child (handle_property& h, const std::string& who,
                          const octave_value& v);
 
     void delete_text_child (handle_property& h);
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
-
-    // properties which are not in matlab: interpreter
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (axes)
-      array_property position u , default_axes_position ()
+      radio_property activepositionproperty , "{outerposition}|position"
+      row_vector_property alim m , default_lim ()
+      radio_property alimmode , "{auto}|manual"
+      color_property ambientlightcolor , color_values (1, 1, 1)
       bool_property box , "on"
+      array_property cameraposition m , Matrix (1, 3, 0.0)
+      radio_property camerapositionmode , "{auto}|manual"
+      array_property cameratarget m , Matrix (1, 3, 0.0)
+      radio_property cameratargetmode , "{auto}|manual"
+      array_property cameraupvector m , Matrix ()
+      radio_property cameraupvectormode , "{auto}|manual"
+      double_property cameraviewangle m , 10.0
+      radio_property cameraviewanglemode , "{auto}|manual"
+      row_vector_property clim m , default_lim ()
+      radio_property climmode al , "{auto}|manual"
+      color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
       array_property colororder , default_colororder ()
+      array_property currentpoint , Matrix (2, 3, 0.0)
       array_property dataaspectratio mu , Matrix (1, 3, 1.0)
       radio_property dataaspectratiomode u , "{auto}|manual"
-      radio_property layer u , "{bottom}|top"
-      row_vector_property xlim mu , default_lim ()
-      row_vector_property ylim mu , default_lim ()
-      row_vector_property zlim mu , default_lim ()
-      row_vector_property clim m , default_lim ()
-      row_vector_property alim m , default_lim ()
-      radio_property xlimmode al , "{auto}|manual"
-      radio_property ylimmode al , "{auto}|manual"
-      radio_property zlimmode al , "{auto}|manual"
-      radio_property climmode al , "{auto}|manual"
-      radio_property alimmode    , "{auto}|manual"
-      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
-      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
-      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
-      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
-      bool_property xgrid , "off"
-      bool_property ygrid , "off"
-      bool_property zgrid , "off"
-      bool_property xminorgrid , "off"
-      bool_property yminorgrid , "off"
-      bool_property zminorgrid , "off"
-      row_vector_property xtick mu , default_axes_tick ()
-      row_vector_property ytick mu , default_axes_tick ()
-      row_vector_property ztick mu , default_axes_tick ()
-      radio_property xtickmode u , "{auto}|manual"
-      radio_property ytickmode u , "{auto}|manual"
-      radio_property ztickmode u , "{auto}|manual"
-      bool_property xminortick , "off"
-      bool_property yminortick , "off"
-      bool_property zminortick , "off"
-      // FIXME -- should be kind of string array.
-      any_property xticklabel S , ""
-      any_property yticklabel S , ""
-      any_property zticklabel S , ""
-      radio_property xticklabelmode u , "{auto}|manual"
-      radio_property yticklabelmode u , "{auto}|manual"
-      radio_property zticklabelmode u , "{auto}|manual"
-      radio_property interpreter , "tex|{none}|latex"
-      color_property color , color_property (color_values (1, 1, 1), radio_values ("none"))
-      color_property xcolor , color_values (0, 0, 0)
-      color_property ycolor , color_values (0, 0, 0)
-      color_property zcolor , color_values (0, 0, 0)
-      radio_property xscale alu , "{linear}|log"
-      radio_property yscale alu , "{linear}|log"
-      radio_property zscale alu , "{linear}|log"
-      radio_property xdir u , "{normal}|reverse"
-      radio_property ydir u , "{normal}|reverse"
-      radio_property zdir u , "{normal}|reverse"
-      radio_property yaxislocation u , "{left}|right|zero"
-      radio_property xaxislocation u , "{bottom}|top|zero"
-      array_property view u , Matrix ()
-      bool_property __hold_all__ h , "off"
-      radio_property nextplot , "new|add|replacechildren|{replace}"
-      array_property outerposition u , default_axes_outerposition ()
-      radio_property activepositionproperty , "{outerposition}|position"
-      color_property ambientlightcolor , color_values (1, 1, 1)
-      array_property cameraposition m , Matrix (1, 3, 0.0)
-      array_property cameratarget m , Matrix (1, 3, 0.0)
-      array_property cameraupvector m , Matrix ()
-      double_property cameraviewangle m , 10.0
-      radio_property camerapositionmode , "{auto}|manual"
-      radio_property cameratargetmode , "{auto}|manual"
-      radio_property cameraupvectormode , "{auto}|manual"
-      radio_property cameraviewanglemode , "{auto}|manual"
-      array_property currentpoint , Matrix (2, 3, 0.0)
       radio_property drawmode , "{normal}|fast"
       radio_property fontangle u , "{normal}|italic|oblique"
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontunits SU , "{points}|normalized|inches|centimeters|pixels"
       radio_property fontweight u , "{normal}|light|demi|bold"
       radio_property gridlinestyle , "-|--|{:}|-.|none"
-      string_array_property linestyleorder , "-"
+      // NOTE: interpreter is not a Matlab axis property, but it makes
+      //       more sense to have it so that axis ticklabels can use it.
+      radio_property interpreter , "tex|{none}|latex"
+      radio_property layer u , "{bottom}|top"
+      // FIXME: should be kind of string array.
+      any_property linestyleorder S , "-"
       double_property linewidth , 0.5
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
+      radio_property nextplot , "add|replacechildren|{replace}"
+      array_property outerposition u , default_axes_outerposition ()
       array_property plotboxaspectratio mu , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode u , "{auto}|manual"
+      array_property position u , default_axes_position ()
       radio_property projection , "{orthographic}|perpective"
       radio_property tickdir mu , "{in}|out"
       radio_property tickdirmode u , "{auto}|manual"
       array_property ticklength u , default_axes_ticklength ()
       array_property tightinset r , Matrix (1, 4, 0.0)
-      // FIXME -- uicontextmenu should be moved here.
+      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      // FIXME: uicontextmenu should be moved here.
       radio_property units SU , "{normalized}|inches|centimeters|points|pixels|characters"
+      array_property view u , Matrix ()
+      radio_property xaxislocation u , "{bottom}|top|zero"
+      color_property xcolor , color_values (0, 0, 0)
+      radio_property xdir u , "{normal}|reverse"
+      bool_property xgrid , "off"
+      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      row_vector_property xlim mu , default_lim ()
+      radio_property xlimmode al , "{auto}|manual"
+      bool_property xminorgrid , "off"
+      bool_property xminortick , "off"
+      radio_property xscale alu , "{linear}|log"
+      row_vector_property xtick mu , default_axes_tick ()
+      // FIXME: should be kind of string array.
+      any_property xticklabel S , ""
+      radio_property xticklabelmode u , "{auto}|manual"
+      radio_property xtickmode u , "{auto}|manual"
+      radio_property yaxislocation u , "{left}|right|zero"
+      color_property ycolor , color_values (0, 0, 0)
+      radio_property ydir u , "{normal}|reverse"
+      bool_property ygrid , "off"
+      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      row_vector_property ylim mu , default_lim ()
+      radio_property ylimmode al , "{auto}|manual"
+      bool_property yminorgrid , "off"
+      bool_property yminortick , "off"
+      radio_property yscale alu , "{linear}|log"
+      row_vector_property ytick mu , default_axes_tick ()
+      any_property yticklabel S , ""
+      radio_property yticklabelmode u , "{auto}|manual"
+      radio_property ytickmode u , "{auto}|manual"
+      color_property zcolor , color_values (0, 0, 0)
+      radio_property zdir u , "{normal}|reverse"
+      bool_property zgrid , "off"
+      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
+      row_vector_property zlim mu , default_lim ()
+      radio_property zlimmode al , "{auto}|manual"
+      bool_property zminorgrid , "off"
+      bool_property zminortick , "off"
+      radio_property zscale alu , "{linear}|log"
+      row_vector_property ztick mu , default_axes_tick ()
+      any_property zticklabel S , ""
+      radio_property zticklabelmode u , "{auto}|manual"
+      radio_property ztickmode u , "{auto}|manual"
+      // Octave-specific properties
+      bool_property __hold_all__ h , "off"
+      // hidden properties for alignment of subplots
+      radio_property autopos_tag h , "{none}|subplot"
+      // hidden properties for inset
+      array_property looseinset hu , Matrix (1, 4, 0.0)
       // hidden properties for transformation computation
       array_property x_viewtransform h , Matrix (4, 4, 0.0)
       array_property x_projectiontransform h , Matrix (4, 4, 0.0)
       array_property x_viewporttransform h , Matrix (4, 4, 0.0)
       array_property x_normrendertransform h , Matrix (4, 4, 0.0)
       array_property x_rendertransform h , Matrix (4, 4, 0.0)
       // hidden properties for minor ticks
       row_vector_property xmtick h , Matrix ()
       row_vector_property ymtick h , Matrix ()
       row_vector_property zmtick h , Matrix ()
-      // hidden properties for inset
-      array_property looseinset hu , Matrix (1, 4, 0.0)
-      // hidden properties for alignment of subplots
-      radio_property autopos_tag h , "{none}|subplot"
    END_PROPERTIES
 
   protected:
     void init (void);
 
   private:
 
     std::string
@@ -3986,34 +3901,95 @@ public:
       }
 
     void update_font (void);
     void update_fontname (void) { update_font (); }
     void update_fontsize (void) { update_font (); }
     void update_fontangle (void) { update_font (); }
     void update_fontweight (void) { update_font (); }
 
-    void sync_positions (const Matrix& linset);
-    void sync_positions (void);
-
-    void update_insets (void);
-
     void update_outerposition (void)
     {
       set_activepositionproperty ("outerposition");
-      sync_positions ();
+      caseless_str old_units = get_units ();
+      set_units ("normalized");
+      Matrix outerbox = outerposition.get ().matrix_value ();
+      Matrix innerbox = position.get ().matrix_value ();
+      Matrix linset = looseinset.get ().matrix_value ();
+      Matrix tinset = tightinset.get ().matrix_value ();
+      outerbox(2) = outerbox(2) + outerbox(0);
+      outerbox(3) = outerbox(3) + outerbox(1);
+      innerbox(0) = outerbox(0) + std::max (linset(0), tinset(0));
+      innerbox(1) = outerbox(1) + std::max (linset(1), tinset(1));
+      innerbox(2) = outerbox(2) - std::max (linset(2), tinset(2));
+      innerbox(3) = outerbox(3) - std::max (linset(3), tinset(3));
+      innerbox(2) = innerbox(2) - innerbox(0);
+      innerbox(3) = innerbox(3) - innerbox(1);
+      position = innerbox;
+      set_units (old_units);
+      update_transform ();
     }
 
     void update_position (void)
     {
       set_activepositionproperty ("position");
-      sync_positions ();
+      caseless_str old_units = get_units ();
+      set_units ("normalized");
+      Matrix outerbox = outerposition.get ().matrix_value ();
+      Matrix innerbox = position.get ().matrix_value ();
+      Matrix linset = looseinset.get ().matrix_value ();
+      Matrix tinset = tightinset.get ().matrix_value ();
+      innerbox(2) = innerbox(2) + innerbox(0);
+      innerbox(3) = innerbox(3) + innerbox(1);
+      outerbox(0) = innerbox(0) - std::max (linset(0), tinset(0));
+      outerbox(1) = innerbox(1) - std::max (linset(1), tinset(1));
+      outerbox(2) = innerbox(2) + std::max (linset(2), tinset(2));
+      outerbox(3) = innerbox(3) + std::max (linset(3), tinset(3));
+      outerbox(2) = outerbox(2) - outerbox(0);
+      outerbox(3) = outerbox(3) - outerbox(1);
+      outerposition = outerbox;
+      set_units (old_units);
+      update_transform ();
     }
 
-    void update_looseinset (void) { sync_positions (); }
+    void update_looseinset (void)
+      {
+        caseless_str old_units = get_units ();
+        set_units ("normalized");
+        Matrix innerbox = position.get ().matrix_value ();
+        innerbox(2) = innerbox(2) + innerbox(0);
+        innerbox(3) = innerbox(3) + innerbox(1);
+        Matrix outerbox = outerposition.get ().matrix_value ();
+        outerbox(2) = outerbox(2) + outerbox(0);
+        outerbox(3) = outerbox(3) + outerbox(1);
+        Matrix linset = looseinset.get ().matrix_value ();
+        Matrix tinset = tightinset.get ().matrix_value ();
+        if (activepositionproperty.is ("position"))
+          {
+            outerbox(0) = innerbox(0) - std::max (linset(0), tinset(0));
+            outerbox(1) = innerbox(1) - std::max (linset(1), tinset(1));
+            outerbox(2) = innerbox(2) + std::max (linset(2), tinset(2));
+            outerbox(3) = innerbox(3) + std::max (linset(3), tinset(3));
+            outerbox(2) = outerbox(2) - outerbox(0);
+            outerbox(3) = outerbox(3) - outerbox(1);
+            outerposition = outerbox;
+          }
+        else
+          {
+            innerbox(0) = outerbox(0) + std::max (linset(0), tinset(0));
+            innerbox(1) = outerbox(1) + std::max (linset(1), tinset(1));
+            innerbox(2) = outerbox(2) - std::max (linset(2), tinset(2));
+            innerbox(3) = outerbox(3) - std::max (linset(3), tinset(3));
+            innerbox(2) = innerbox(2) - innerbox(0);
+            innerbox(3) = innerbox(3) - innerbox(1);
+            position = innerbox;
+          }
+        set_units (old_units);
+        update_transform ();
+      }
 
     double calc_tick_sep (double minval, double maxval);
     void calc_ticks_and_lims (array_property& lims, array_property& ticks, array_property& mticks,
                               bool limmode_is_auto, bool is_logscale);
     void calc_ticklabels (const array_property& ticks, any_property& labels, bool is_logscale);
     Matrix get_ticklabel_extents (const Matrix& ticks,
                                   const string_vector& ticklabels,
                                   const Matrix& limits);
@@ -4140,17 +4116,17 @@ public:
     remove_all_listeners ();
     xproperties.set_defaults (*this, mode);
   }
 
   octave_value get (const caseless_str& name) const
   {
     octave_value retval;
 
-    // FIXME -- finish this.
+    // FIXME: finish this.
     if (name.compare ("default", 7))
       retval = get_default (name.substr (7));
     else
       retval = xproperties.get (name);
 
     return retval;
   }
 
@@ -4186,36 +4162,38 @@ private:
 class OCTINTERP_API line : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
-
-    // properties which are not in matlab: interpreter
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (line)
-      row_vector_property xdata u , default_data ()
-      row_vector_property ydata u , default_data ()
-      row_vector_property zdata u , Matrix ()
-      string_property xdatasource , ""
-      string_property ydatasource , ""
-      string_property zdatasource , ""
       color_property color , color_values (0, 0, 0)
+      string_property displayname , ""
+      radio_property erasemode , "{normal}|none|xor|background"
+      // FIXME: interpreter is not a property of Matlab line objects.
+      //        Octave uses this for legend() with the string displayname.
+      radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
-      radio_property marker , "{none}|s|o|x|+|.|*|<|>|v|^|d|p|h|@"
+      radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
       color_property markeredgecolor , "{auto}|none"
       color_property markerfacecolor , "auto|{none}"
       double_property markersize , 6
-      radio_property interpreter , "{tex}|none|latex"
-      string_property displayname , ""
-      radio_property erasemode , "{normal}|none|xor|background"
+      row_vector_property xdata u , default_data ()
+      string_property xdatasource , ""
+      row_vector_property ydata u , default_data ()
+      string_property ydatasource , ""
+      row_vector_property zdata u , Matrix ()
+      string_property zdatasource , ""
+
       // hidden properties for limit computation
       row_vector_property xlim hlr , Matrix ()
       row_vector_property ylim hlr , Matrix ()
       row_vector_property zlim hlr , Matrix ()
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "off"
     END_PROPERTIES
@@ -4288,38 +4266,39 @@ public:
             set_positionmode ("manual");
         }
     }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (text)
-      text_label_property string u , ""
-      radio_property units u , "{data}|pixels|normalized|inches|centimeters|points"
-      array_property position smu , Matrix (1, 3, 0.0)
-      double_property rotation mu , 0
-      radio_property horizontalalignment mu , "{left}|center|right"
+      color_property backgroundcolor , "{none}"
       color_property color u , color_values (0, 0, 0)
+      string_property displayname , ""
+      color_property edgecolor , "{none}"
+      bool_property editing , "off"
+      radio_property erasemode , "{normal}|none|xor|background"
+      array_property extent rG , Matrix (1, 4, 0.0)
+      radio_property fontangle u , "{normal}|italic|oblique"
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
-      radio_property fontangle u , "{normal}|italic|oblique"
+      radio_property fontunits , "inches|centimeters|normalized|{points}|pixels"
       radio_property fontweight u , "light|{normal}|demi|bold"
+      radio_property horizontalalignment mu , "{left}|center|right"
       radio_property interpreter u , "{tex}|none|latex"
-      color_property backgroundcolor , "{none}"
-      string_property displayname , ""
-      color_property edgecolor , "{none}"
-      radio_property erasemode , "{normal}|none|xor|background"
-      bool_property editing , "off"
-      radio_property fontunits , "inches|centimeters|normalized|{points}|pixels"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
       double_property margin , 1
+      array_property position smu , Matrix (1, 3, 0.0)
+      double_property rotation mu , 0
+      text_label_property string u , ""
+      radio_property units u , "{data}|pixels|normalized|inches|centimeters|points"
       radio_property verticalalignment mu , "top|cap|{middle}|baseline|bottom"
-      array_property extent rG , Matrix (1, 4, 0.0)
+
       // hidden properties for limit computation
       row_vector_property xlim hlr , Matrix ()
       row_vector_property ylim hlr , Matrix ()
       row_vector_property zlim hlr , Matrix ()
       bool_property xliminclude hl , "off"
       bool_property yliminclude hl , "off"
       bool_property zliminclude hl , "off"
       // hidden properties for auto-positioning
@@ -4421,38 +4400,49 @@ public:
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API image : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
+    bool is_aliminclude (void) const
+      { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
+    std::string get_aliminclude (void) const
+      { return aliminclude.current_value (); }
+
     bool is_climinclude (void) const
       { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
     std::string get_climinclude (void) const
       { return climinclude.current_value (); }
 
     octave_value get_color_data (void) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (image)
+      array_property alphadata u , Matrix ()
+      radio_property alphadatamapping al , "none|direct|{scaled}"
+      array_property cdata u , Matrix ()
+      radio_property cdatamapping al , "scaled|{direct}"
+      radio_property erasemode , "{normal}|none|xor|background"
       row_vector_property xdata u , Matrix ()
       row_vector_property ydata u , Matrix ()
-      array_property cdata u , Matrix ()
-      radio_property cdatamapping al , "{scaled}|direct"
       // hidden properties for limit computation
+      row_vector_property alim hlr , Matrix ()
+      row_vector_property clim hlr , Matrix ()
       row_vector_property xlim hlr , Matrix ()
       row_vector_property ylim hlr , Matrix ()
-      row_vector_property clim hlr , Matrix ()
+      bool_property aliminclude hlg , "on"
+      bool_property climinclude hlg , "on"
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
-      bool_property climinclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         xdata.add_constraint (2);
         ydata.add_constraint (2);
         cdata.add_constraint ("double");
@@ -4462,16 +4452,32 @@ public:
         cdata.add_constraint ("uint16");
         cdata.add_constraint ("int16");
         cdata.add_constraint ("real");
         cdata.add_constraint (dim_vector (-1, -1));
         cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
+    void update_alphadata (void)
+      {
+        if (alphadatamapping_is ("scaled"))
+          set_alim (alphadata.get_limits ());
+        else
+          alim = alphadata.get_limits ();
+      }
+
+    void update_cdata (void)
+      {
+        if (cdatamapping_is ("scaled"))
+          set_clim (cdata.get_limits ());
+        else
+          clim = cdata.get_limits ();
+      }
+
     void update_xdata (void)
     {
       Matrix limits = xdata.get_limits ();
       float dp = pixel_xsize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_xlim (limits);
@@ -4482,24 +4488,16 @@ public:
       Matrix limits = ydata.get_limits ();
       float dp = pixel_ysize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_ylim (limits);
     }
 
-    void update_cdata (void)
-      {
-        if (cdatamapping_is ("scaled"))
-          set_clim (cdata.get_limits ());
-        else
-          clim = cdata.get_limits ();
-      }
-
     float pixel_size (octave_idx_type dim, const Matrix limits)
     {
       octave_idx_type l = dim - 1;
       float dp;
 
       if (l > 0 && limits(0) != limits(1))
         dp = (limits(1) - limits(0))/(2*l);
       else
@@ -4548,74 +4546,79 @@ public:
 class OCTINTERP_API patch : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
-    bool is_climinclude (void) const
-      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
-    std::string get_climinclude (void) const
-      { return climinclude.current_value (); }
-
     bool is_aliminclude (void) const
       { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
       { return aliminclude.current_value (); }
 
+    bool is_climinclude (void) const
+      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
+    std::string get_climinclude (void) const
+      { return climinclude.current_value (); }
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (patch)
-      array_property xdata u , Matrix ()
-      array_property ydata u , Matrix ()
-      array_property zdata u , Matrix ()
+      radio_property alphadatamapping l , "none|{scaled}|direct"
+      double_property ambientstrength , 0.3
+      radio_property backfacelighting , "unlit|lit|{reverselit}"
       array_property cdata u , Matrix ()
       radio_property cdatamapping l , "{scaled}|direct"
+      double_property diffusestrength , 0.6
+      string_property displayname , ""
+      double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
+      color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
+      radio_property edgelighting , "{none}|flat|gouraud|phong"
+      radio_property erasemode , "{normal}|background|xor|none"
+      double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
+      color_property facecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
+      radio_property facelighting , "{none}|flat|gouraud|phong"
       array_property faces , Matrix ()
       array_property facevertexalphadata , Matrix ()
       array_property facevertexcdata , Matrix ()
-      array_property vertices , Matrix ()
-      array_property vertexnormals , Matrix ()
-      radio_property normalmode , "{auto}|manual"
-      color_property facecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
-      double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
-      radio_property facelighting , "flat|{none}|gouraud|phong"
-      color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
-      double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
-      radio_property edgelighting , "{none}|flat|gouraud|phong"
-      radio_property backfacelighting , "{reverselit}|unlit|lit"
-      double_property ambientstrength , 0.3
-      double_property diffusestrength , 0.6
-      double_property specularstrength , 0.6
-      double_property specularexponent , 10.0
-      double_property specularcolorreflectance , 1.0
-      radio_property erasemode , "{normal}|background|xor|none"
+      // FIXME: interpreter is not a property of a Matlab patch.
+      //        Octave uses this for legend() with the string displayname.
+      radio_property interpreter , "{tex}|none|latex"
       radio_property linestyle , "{-}|--|:|-.|none"
       double_property linewidth , 0.5
-      radio_property marker , "{none}|s|o|x|+|.|*|<|>|v|^|d|p|h|@"
-      color_property markeredgecolor , "{auto}|none|flat"
-      color_property markerfacecolor , "auto|{none}|flat"
+      radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
+      //radio_property marker , "{none}|+|o|*|.|x|s|d|^|v|>|<|p|h"
+      color_property markeredgecolor , "none|{auto}|flat"
+      color_property markerfacecolor , "{none}|auto|flat"
       double_property markersize , 6
-      radio_property interpreter , "{tex}|none|latex"
-      string_property displayname , ""
-      radio_property alphadatamapping l , "none|{scaled}|direct"
+      radio_property normalmode , "{auto}|manual"
+      double_property specularcolorreflectance , 1.0
+      double_property specularexponent , 10.0
+      double_property specularstrength , 0.6
+      array_property vertexnormals , Matrix ()
+      array_property vertices , Matrix ()
+      array_property xdata u , Matrix ()
+      array_property ydata u , Matrix ()
+      array_property zdata u , Matrix ()
+
       // hidden properties for limit computation
+      row_vector_property alim hlr , Matrix ()
+      row_vector_property clim hlr , Matrix ()
       row_vector_property xlim hlr , Matrix ()
       row_vector_property ylim hlr , Matrix ()
       row_vector_property zlim hlr , Matrix ()
-      row_vector_property clim hlr , Matrix ()
-      row_vector_property alim hlr , Matrix ()
+      bool_property aliminclude hlg , "on"
+      bool_property climinclude hlg , "on"
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "on"
-      bool_property climinclude hlg , "on"
-      bool_property aliminclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         xdata.add_constraint (dim_vector (-1, -1));
         ydata.add_constraint (dim_vector (-1, -1));
         zdata.add_constraint (dim_vector (-1, -1));
@@ -4666,76 +4669,81 @@ public:
 class OCTINTERP_API surface : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
-    bool is_climinclude (void) const
-      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
-    std::string get_climinclude (void) const
-      { return climinclude.current_value (); }
-
     bool is_aliminclude (void) const
       { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
       { return aliminclude.current_value (); }
 
+    bool is_climinclude (void) const
+      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
+    std::string get_climinclude (void) const
+      { return climinclude.current_value (); }
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (surface)
-      array_property xdata u , Matrix ()
-      array_property ydata u , Matrix ()
-      array_property zdata u , Matrix ()
-      array_property cdata u , Matrix ()
-      radio_property cdatamapping al , "{scaled}|direct"
-      string_property xdatasource , ""
-      string_property ydatasource , ""
-      string_property zdatasource , ""
-      string_property cdatasource , ""
-      color_property facecolor , "{flat}|none|interp|texturemap"
-      double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp"))
-      color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("flat|none|interp"))
-      radio_property linestyle , "{-}|--|:|-.|none"
-      double_property linewidth , 0.5
-      radio_property marker , "{none}|s|o|x|+|.|*|<|>|v|^|d|p|h|@"
-      color_property markeredgecolor , "{auto}|none"
-      color_property markerfacecolor , "auto|{none}"
-      double_property markersize , 6
-      radio_property interpreter , "{tex}|none|latex"
-      string_property displayname , ""
       array_property alphadata u , Matrix ()
       radio_property alphadatamapping l , "none|direct|{scaled}"
       double_property ambientstrength , 0.3
       radio_property backfacelighting , "unlit|lit|{reverselit}"
+      array_property cdata u , Matrix ()
+      radio_property cdatamapping al , "{scaled}|direct"
+      string_property cdatasource , ""
       double_property diffusestrength , 0.6
+      string_property displayname , ""
       double_radio_property edgealpha , double_radio_property (1.0, radio_values ("flat|interp"))
+      color_property edgecolor , color_property (color_values (0, 0, 0), radio_values ("none|flat|interp"))
       radio_property edgelighting , "{none}|flat|gouraud|phong"
       radio_property erasemode , "{normal}|none|xor|background"
+      double_radio_property facealpha , double_radio_property (1.0, radio_values ("flat|interp|texturemap"))
+      color_property facecolor , "none|{flat}|interp|texturemap"
       radio_property facelighting , "{none}|flat|gouraud|phong"
+      // FIXME: interpreter is not a Matlab surface property
+      //        Octave uses this for legend() with the string displayname.
+      radio_property interpreter , "{tex}|none|latex"
+      radio_property linestyle , "{-}|--|:|-.|none"
+      double_property linewidth , 0.5
+      radio_property marker , "{none}|+|o|*|.|x|s|square|d|diamond|^|v|>|<|p|pentagram|h|hexagram"
+      //radio_property marker , "{none}|+|o|*|.|x|s|d|^|v|>|<|p|h"
+      color_property markeredgecolor , "none|{auto}|flat"
+      color_property markerfacecolor , "{none}|auto|flat"
+      double_property markersize , 6
       radio_property meshstyle , "{both}|row|column"
       radio_property normalmode u , "{auto}|manual"
       double_property specularcolorreflectance , 1
       double_property specularexponent , 10
       double_property specularstrength , 0.9
       array_property vertexnormals u , Matrix ()
+      array_property xdata u , Matrix ()
+      string_property xdatasource , ""
+      array_property ydata u , Matrix ()
+      string_property ydatasource , ""
+      array_property zdata u , Matrix ()
+      string_property zdatasource , ""
+
       // hidden properties for limit computation
+      row_vector_property alim hlr , Matrix ()
+      row_vector_property clim hlr , Matrix ()
       row_vector_property xlim hlr , Matrix ()
       row_vector_property ylim hlr , Matrix ()
       row_vector_property zlim hlr , Matrix ()
-      row_vector_property clim hlr , Matrix ()
-      row_vector_property alim hlr , Matrix ()
+      bool_property aliminclude hlg , "on"
+      bool_property climinclude hlg , "on"
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "on"
-      bool_property climinclude hlg , "on"
-      bool_property aliminclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         xdata.add_constraint (dim_vector (-1, -1));
         ydata.add_constraint (dim_vector (-1, -1));
         zdata.add_constraint (dim_vector (-1, -1));
@@ -4747,17 +4755,31 @@ public:
         cdata.add_constraint ("single");
         cdata.add_constraint ("double");
         cdata.add_constraint ("uint8");
         cdata.add_constraint (dim_vector (-1, -1));
         cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
-    void update_normals (void);
+    void update_alphadata (void)
+      {
+        if (alphadatamapping_is ("scaled"))
+          set_alim (alphadata.get_limits ());
+        else
+          alim = alphadata.get_limits ();
+      }
+
+    void update_cdata (void)
+      {
+        if (cdatamapping_is ("scaled"))
+          set_clim (cdata.get_limits ());
+        else
+          clim = cdata.get_limits ();
+      }
 
     void update_xdata (void)
       {
         update_normals ();
         set_xlim (xdata.get_limits ());
       }
 
     void update_ydata (void)
@@ -4767,31 +4789,17 @@ public:
       }
 
     void update_zdata (void)
       {
         update_normals ();
         set_zlim (zdata.get_limits ());
       }
 
-    void update_cdata (void)
-      {
-        if (cdatamapping_is ("scaled"))
-          set_clim (cdata.get_limits ());
-        else
-          clim = cdata.get_limits ();
-      }
-
-    void update_alphadata (void)
-      {
-        if (alphadatamapping_is ("scaled"))
-          set_alim (alphadata.get_limits ());
-        else
-          alim = alphadata.get_limits ();
-      }
+    void update_normals (void);
 
     void update_normalmode (void)
       { update_normals (); }
 
     void update_vertexnormals (void)
       { set_normalmode ("manual"); }
   };
 
@@ -4832,31 +4840,33 @@ public:
       {
 
         base_properties::adopt (h);
         update_limits (h);
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (hggroup)
       string_property displayname , ""
       radio_property erasemode , "{normal}|none|xor|background"
+
       // hidden properties for limit computation
+      row_vector_property alim hr , Matrix ()
+      row_vector_property clim hr , Matrix ()
       row_vector_property xlim hr , Matrix ()
       row_vector_property ylim hr , Matrix ()
       row_vector_property zlim hr , Matrix ()
-      row_vector_property clim hr , Matrix ()
-      row_vector_property alim hr , Matrix ()
+      bool_property aliminclude h , "on"
+      bool_property climinclude h , "on"
       bool_property xliminclude h , "on"
       bool_property yliminclude h , "on"
       bool_property zliminclude h , "on"
-      bool_property climinclude h , "on"
-      bool_property aliminclude h , "on"
     END_PROPERTIES
 
   private:
       void update_limits (void) const;
 
       void update_limits (const graphics_handle& h) const;
 
   protected:
@@ -4905,27 +4915,29 @@ public:
 
     void adopt (const graphics_handle& h)
       {
         base_properties::adopt (h);
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uimenu)
       any_property __object__ , Matrix ()
       string_property accelerator , ""
       callback_property callback , Matrix ()
       bool_property checked , "off"
       bool_property enable , "on"
       color_property foregroundcolor , color_values (0, 0, 0)
       string_property label , ""
       double_property position , 9
       bool_property separator , "off"
+      // Octave-specific properties
       string_property fltk_label h , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       { }
   };
 
@@ -4954,16 +4966,17 @@ public:
 class OCTINTERP_API uicontextmenu : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uicontextmenu)
       any_property __object__ , Matrix ()
       callback_property callback , Matrix ()
       array_property position , Matrix (1, 2, 0.0)
     END_PROPERTIES
 
   protected:
@@ -5005,32 +5018,33 @@ public:
   public:
     Matrix get_boundingbox (bool internal = false,
                             const Matrix& parent_pix_size = Matrix ()) const;
 
     double get_fontsize_points (double box_pix_height = 0) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uicontrol)
       any_property __object__ , Matrix ()
       color_property backgroundcolor , color_values (1, 1, 1)
       callback_property callback , Matrix ()
       array_property cdata , Matrix ()
       bool_property clipping , "on"
       radio_property enable , "{on}|inactive|off"
       array_property extent rG , Matrix (1, 4, 0.0)
       radio_property fontangle u , "{normal}|italic|oblique"
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
       radio_property fontweight u , "light|{normal}|demi|bold"
       color_property foregroundcolor , color_values (0, 0, 0)
-      radio_property horizontalalignment , "{left}|center|right"
+      radio_property horizontalalignment , "left|{center}|right"
       callback_property keypressfcn , Matrix ()
       double_property listboxtop , 1
       double_property max , 1
       double_property min , 0
       array_property position , default_control_position ()
       array_property sliderstep , default_control_sliderstep ()
       string_array_property string u , ""
       radio_property style S , "{pushbutton}|togglebutton|radiobutton|checkbox|edit|text|slider|frame|listbox|popupmenu"
@@ -5097,16 +5111,17 @@ public:
   public:
     Matrix get_boundingbox (bool internal = false,
                             const Matrix& parent_pix_size = Matrix ()) const;
 
     double get_fontsize_points (double box_pix_height = 0) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uipanel)
       any_property __object__ , Matrix ()
       color_property backgroundcolor , color_values (1, 1, 1)
       radio_property bordertype , "none|{etchedin}|etchedout|beveledin|beveledout|line"
       double_property borderwidth , 1
       radio_property fontangle , "{normal}|italic|oblique"
       string_property fontname , OCTAVE_DEFAULT_FONTNAME
@@ -5158,16 +5173,17 @@ public:
 class OCTINTERP_API uitoolbar : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uitoolbar)
       any_property __object__ , Matrix ()
     END_PROPERTIES
 
   protected:
     void init (void)
       { }
@@ -5246,16 +5262,17 @@ private:
 class OCTINTERP_API uipushtool : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uipushtool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
       callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
       bool_property separator , "off"
       string_property tooltipstring , ""
@@ -5296,16 +5313,17 @@ public:
 class OCTINTERP_API uitoggletool : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uitoggletool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
       callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
       callback_property offcallback , Matrix ()
       callback_property oncallback , Matrix ()
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -231,8 +231,16 @@ gripe_nonbraced_cs_list_assignment (void
 }
 
 void
 gripe_warn_complex_cmp (void)
 {
   warning_with_id ("Octave:matlab-incompatible",
                    "potential Matlab compatibility problem: comparing complex numbers");
 }
+
+void
+gripe_disabled_feature (const std::string& func, const std::string& feature,
+                        const std::string& pkg /*="Octave"*/)
+{
+  error ("%s: support for %s was disabled when %s was built",
+         func.c_str (), feature.c_str (), pkg.c_str ());
+}
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -122,9 +122,12 @@ extern OCTINTERP_API void
 gripe_indexed_cs_list (void);
 
 extern OCTINTERP_API void
 gripe_nonbraced_cs_list_assignment (void);
 
 extern OCTINTERP_API void
 gripe_warn_complex_cmp (void);
 
+extern OCTINTERP_API void
+gripe_disabled_feature (const std::string& func, const std::string& feature,
+                        const std::string& pkg="Octave");
 #endif
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -636,18 +636,18 @@ endif\n\
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} otherwise\n\
 The default statement in a switch block (similar to else in an if block).\n\
 @seealso{switch}\n\
 @end deftypefn"),
 
   pair_type ("parfor",
     "-*- texinfo -*-\n\
-@deftypefn  {Keyword} {} for @var{i} = @var{range}\n\
-@deftypefnx {Keyword} {} for (@var{i} = @var{range}, @var{maxproc})\n\
+@deftypefn  {Keyword} {} parfor @var{i} = @var{range}\n\
+@deftypefnx {Keyword} {} parfor (@var{i} = @var{range}, @var{maxproc})\n\
 Begin a for loop that may execute in parallel.\n\
 \n\
 @example\n\
 @group\n\
 parfor i = 1:10\n\
   i\n\
 endparfor\n\
 @end group\n\
@@ -962,17 +962,17 @@ install_built_in_docstrings (void)
 {
   std::string fname = Vbuilt_in_docstrings_file;
 
   std::ifstream file (fname.c_str (), std::ios::in | std::ios::binary);
 
   if (file)
     {
       // Ignore header;
-      file.ignore (1000, 0x1f);
+      file.ignore (1000, 0x1d);
 
       if (file.gcount () == 1000)
         {
           // We use std::cerr here instead of calling Octave's warning
           // function because install_built_in_docstrings is called
           // before the interpreter is initialized, so warning messages
           // won't work properly.
 
@@ -983,17 +983,17 @@ install_built_in_docstrings (void)
 
       // FIXME -- eliminate fixed buffer size.
       size_t bufsize = 100000;
 
       OCTAVE_LOCAL_BUFFER (char, buf, bufsize);
 
       while (! file.eof ())
         {
-          file.getline (buf, bufsize, 0x1f);
+          file.getline (buf, bufsize, 0x1d);
 
           std::string tmp (buf);
 
           size_t pos = tmp.find ('\n');
 
           std::string fcn = tmp.substr (0, pos);
 
           octave_value ov = symbol_table::find_built_in_function (fcn);
@@ -1061,18 +1061,18 @@ do_get_help_text (const std::string& nam
     }
 }
 
 DEFUN (get_help_text, args, , "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
 Return the raw help text of function @var{name}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
-The format is a string which is one of @t{\"texinfo\"}, @t{\"html\"}, or\n\
-@t{\"plain text\"}.\n\
+The format is a string which is one of @qcode{\"texinfo\"},\n\
+@qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       const std::string name = args (0).string_value ();
 
@@ -1130,18 +1130,18 @@ do_get_help_text_from_file (const std::s
 }
 
 DEFUN (get_help_text_from_file, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
 Return the raw help text from the file @var{fname}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
-The format is a string which is one of @t{\"texinfo\"}, @t{\"html\"}, or\n\
-@t{\"plain text\"}.\n\
+The format is a string which is one of @qcode{\"texinfo\"},\n\
+@qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       const std::string fname = args(0).string_value ();
 
@@ -1393,19 +1393,19 @@ Octave documentation cache file.  A cach
 the performance of the @code{lookfor} command.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/doc-cache},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_DOC_CACHE_FILE}}, or the command line argument\n\
 @samp{--doc-cache-file FNAME}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{doc_cache_create, lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
 DEFUN (texi_macros_file, args, nargout,
   "-*- texinfo -*-\n\
@@ -1417,19 +1417,19 @@ file containing Texinfo macros that are 
 before they are passed to makeinfo.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/macros.texi},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 and @var{version} is the Octave version number.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_TEXI_MACROS_FILE}}, or the command line argument\n\
 @samp{--texi-macros-file FNAME}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
 }
 
 DEFUN (info_file, args, nargout,
   "-*- texinfo -*-\n\
@@ -1439,19 +1439,19 @@ DEFUN (info_file, args, nargout,
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
 which @var{octave-home} is the root directory of the Octave installation.\n\
 The default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_INFO_FILE}}, or the command line argument\n\
 @samp{--info-file FNAME}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
 DEFUN (info_program, args, nargout,
   "-*- texinfo -*-\n\
@@ -1463,51 +1463,51 @@ info program to run.  The default value 
 @file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 @var{version} is the Octave version number, and @var{arch}\n\
 is the system type (for example, @code{i686-pc-linux-gnu}).  The\n\
 default value may be overridden by the environment variable\n\
 @w{@env{OCTAVE_INFO_PROGRAM}}, or the command line argument\n\
 @samp{--info-program NAME}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{info_file, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
 }
 
 DEFUN (makeinfo_program, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} makeinfo_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{texi_macros_file, info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} suppress_verbose_help_message (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -55,16 +55,17 @@ is upper Hessenberg ($H_{i,j} = 0, \\for
 unitary matrix (@code{@var{P}' * @var{P} = I}, using complex-conjugate\n\
 transposition) and @var{H} is upper Hessenberg\n\
 (@code{@var{H}(i, j) = 0 forall i >= j+1)}.\n\
 @end ifnottex\n\
 \n\
 The Hessenberg decomposition is usually used as the first step in an\n\
 eigenvalue computation, but has other applications as well (see Golub,\n\
 Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).\n\
+@seealso{eig, chol, lu, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -29,153 +29,277 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (hex2num, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
+@deftypefn  {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
+@deftypefnx {Built-in Function} {@var{n} =} hex2num (@var{s}, @var{class})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
-strings are right padded with '0' characters.\n\
+strings are right padded with @qcode{'0'} characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
 @group\n\
 hex2num ([\"4005bf0a8b145769\"; \"4024000000000000\"])\n\
    @result{} [2.7183; 10.000]\n\
 @end group\n\
 @end example\n\
+\n\
+The optional argument @var{class} can be passed as the string\n\
+@qcode{\"single\"} to specify that the given string should be interpreted as\n\
+a single precision number.  In this case, @var{s} should be an 8 character\n\
+hexadecimal string.  For example: \n\
+\n\
+@example\n\
+@group\n\
+hex2num ([\"402df854\"; \"41200000\"], \"single\")\n\
+   @result{} [2.7183; 10.000]\n\
+@end group\n\
+@end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
-  if (nargin != 1)
+  if (nargin < 1 || nargin > 2)
     print_usage ();
+  else if (nargin == 2 && ! args(1).is_string ())
+    error ("hex2num: CLASS must be a string");
   else
     {
       const charMatrix cmat = args(0).char_matrix_value ();
+      std::string prec = (nargin == 2) ? args(1).string_value () : "double";
+      bool is_single = (prec == "single");
+      octave_idx_type nchars = (is_single) ? 8 : 16;
 
-      if (cmat.columns () > 16)
-        error ("hex2num: S must be no more than 16 characters");
+      if (cmat.columns () > nchars)
+        error ("hex2num: S must be no more than %d characters", nchars);
+      else if (prec != "double" && prec != "single")
+        error ("hex2num: CLASS must be either \"double\" or \"single\"");
       else if (! error_state)
         {
           octave_idx_type nr = cmat.rows ();
           octave_idx_type nc = cmat.columns ();
-          ColumnVector m (nr);
 
-          for (octave_idx_type i = 0; i < nr; i++)
+          if (is_single)
             {
-              union
-              {
-                uint64_t ival;
-                double dval;
-              } num;
+              FloatColumnVector m (nr);
 
-              num.ival = 0;
+              for (octave_idx_type i = 0; i < nr; i++)
+                {
+                  union
+                  {
+                    uint32_t ival;
+                    float dval;
+                  } num;
+
+                  num.ival = 0;
+
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      unsigned char ch = cmat.elem (i, j);
 
-              for (octave_idx_type j = 0; j < nc; j++)
-                {
-                  unsigned char ch = cmat.elem (i, j);
+                      if (isxdigit (ch))
+                        {
+                          num.ival <<= 4;
+                          if (ch >= 'a')
+                            num.ival += static_cast<uint32_t> (ch - 'a' + 10);
+                          else if (ch >= 'A')
+                            num.ival += static_cast<uint32_t> (ch - 'A' + 10);
+                          else
+                            num.ival += static_cast<uint32_t> (ch - '0');
+                        }
+                      else
+                        {
+                          error ("hex2num: illegal character found in string S");
+                          break;
+                        }
+                    }
 
-                  if (isxdigit (ch))
-                    {
-                      num.ival <<= 4;
-                      if (ch >= 'a')
-                        num.ival += static_cast<uint64_t> (ch - 'a' + 10);
-                      else if (ch >= 'A')
-                        num.ival += static_cast<uint64_t> (ch - 'A' + 10);
-                      else
-                        num.ival += static_cast<uint64_t> (ch - '0');
-                    }
+                  if (error_state)
+                    break;
                   else
                     {
-                      error ("hex2num: illegal character found in string S");
-                      break;
+                      if (nc < nchars)
+                        num.ival <<= (nchars - nc) * 4;
+
+                      m(i) = num.dval;
                     }
                 }
 
-              if (error_state)
-                break;
-              else
+              if (! error_state)
+                retval =  m;
+            }
+          else
+            {
+              ColumnVector m (nr);
+
+              for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  if (nc < 16)
-                    num.ival <<= (16 - nc) * 4;
+                  union
+                  {
+                    uint64_t ival;
+                    double dval;
+                  } num;
+
+                  num.ival = 0;
+
+                  for (octave_idx_type j = 0; j < nc; j++)
+                    {
+                      unsigned char ch = cmat.elem (i, j);
 
-                  m(i) = num.dval;
+                      if (isxdigit (ch))
+                        {
+                          num.ival <<= 4;
+                          if (ch >= 'a')
+                            num.ival += static_cast<uint64_t> (ch - 'a' + 10);
+                          else if (ch >= 'A')
+                            num.ival += static_cast<uint64_t> (ch - 'A' + 10);
+                          else
+                            num.ival += static_cast<uint64_t> (ch - '0');
+                        }
+                      else
+                        {
+                          error ("hex2num: illegal character found in string S");
+                          break;
+                        }
+                    }
+
+                  if (error_state)
+                    break;
+                  else
+                    {
+                      if (nc < nchars)
+                        num.ival <<= (nchars - nc) * 4;
+
+                      m(i) = num.dval;
+                    }
                 }
+
+              if (! error_state)
+                retval =  m;
             }
-
-          if (! error_state)
-            retval =  m;
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
+%!assert (hex2num (["c00";"bf8";"000";"3f8";"400"], "single"), single([-2:2])')
 */
 
 DEFUN (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} num2hex (@var{n})\n\
-Typecast a double precision number or vector to a 16 character hexadecimal\n\
-string of the IEEE 754 representation of the number.  For example:\n\
+Typecast a double or single precision number or vector to a 8 or 16\n\
+character hexadecimal string of the IEEE 754 representation of the number.\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
-num2hex ([-1, 1, e, Inf, NaN, NA])\n\
+num2hex ([-1, 1, e, Inf])\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
-    7ff0000000000000\n\
-    fff8000000000000\n\
-    7ff00000000007a2\"\n\
+    7ff0000000000000\"\n\
+@end group\n\
+@end example\n\
+\n\
+If the argument @var{n} is a single precision number or vector, the returned\n\
+string has a length of 8.  For example:\n\
+\n\
+@example\n\
+@group\n\
+num2hex (single ([-1, 1, e, Inf]))\n\
+@result{} \"bf800000\n\
+    3f800000\n\
+    402df854\n\
+    7f800000\"\n\
 @end group\n\
 @end example\n\
 @seealso{hex2num, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
     print_usage ();
+  else if (args(0).is_single_type ())
+    {
+      const FloatColumnVector v (args(0).float_vector_value ());
+
+      if (! error_state)
+        {
+          octave_idx_type nchars = 8;
+          octave_idx_type nr = v.length ();
+          charMatrix m (nr, nchars);
+          const float *pv = v.fortran_vec ();
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            {
+              union
+              {
+                uint32_t ival;
+                float dval;
+              } num;
+
+              num.dval = *pv++;
+
+              for (octave_idx_type j = 0; j < nchars; j++)
+                {
+                  unsigned char ch =
+                    static_cast<char> (num.ival >> ((nchars - 1 - j) * 4) & 0xF);
+                  if (ch >= 10)
+                    ch += 'a' - 10;
+                  else
+                    ch += '0';
+
+                  m.elem (i, j) = ch;
+                }
+            }
+
+          retval = m;
+        }
+    }
   else
     {
       const ColumnVector v (args(0).vector_value ());
 
       if (! error_state)
         {
+          octave_idx_type nchars = 16;
           octave_idx_type nr = v.length ();
-          charMatrix m (nr, 16);
+          charMatrix m (nr, nchars);
           const double *pv = v.fortran_vec ();
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
               union
               {
                 uint64_t ival;
                 double dval;
               } num;
 
               num.dval = *pv++;
 
-              for (octave_idx_type j = 0; j < 16; j++)
+              for (octave_idx_type j = 0; j < nchars; j++)
                 {
                   unsigned char ch =
-                    static_cast<char> (num.ival >> ((15 - j) * 4) & 0xF);
+                    static_cast<char> (num.ival >> ((nchars - 1 - j) * 4) & 0xF);
                   if (ch >= 10)
                     ch += 'a' - 10;
                   else
                     ch += '0';
 
                   m.elem (i, j) = ch;
                 }
             }
@@ -184,9 +308,10 @@ num2hex ([-1, 1, e, Inf, NaN, NA])\n\
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (num2hex (-2:2), ["c000000000000000";"bff0000000000000";"0000000000000000";"3ff0000000000000";"4000000000000000"])
+%!assert (num2hex (single (-2:2)), ["c0000000";"bf800000";"00000000";"3f800000";"40000000"])
 */
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -142,17 +142,17 @@ set_default_prompts (void)
   VPS4 = "+ ";
 
   octave_link::set_default_prompts (VPS1, VPS2, VPS4);
 }
 
 void
 octave_base_reader::do_input_echo (const std::string& input_string) const
 {
-  int do_echo = LEXER->reading_script_file ?
+  int do_echo = (LEXER && LEXER->reading_script_file) ?
     (Vecho_executing_commands & ECHO_SCRIPTS)
       : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
         {
           if (pflag > 0)
@@ -267,19 +267,17 @@ octave_base_reader::octave_gets (bool& e
       retval = last_debugging_command;
       history_skip_auto_repeated_debugging_command = true;
     }
 
   if (retval != "\n")
     {
       if (! history_skip_auto_repeated_debugging_command)
         {
-          command_history::add (retval);
-
-          if (! command_history::ignoring_entries ())
+          if (command_history::add (retval))
             octave_link::append_history (retval);
         }
 
       octave_diary << retval;
 
       if (retval[retval.length () - 1] != '\n')
         octave_diary << "\n";
 
@@ -551,20 +549,20 @@ get_debug_input (const std::string& prom
 
   if (! msg.empty ())
     std::cerr << msg << std::endl;
 
   frame.protect_var (VPS1);
   VPS1 = prompt;
 
   if (! (interactive || forced_interactive)
-      || LEXER->reading_fcn_file
-      || LEXER->reading_classdef_file
-      || LEXER->reading_script_file
-      || LEXER->input_from_eval_string ())
+      || (LEXER && (LEXER->reading_fcn_file
+                    || LEXER->reading_classdef_file
+                    || LEXER->reading_script_file
+                    || LEXER->input_from_eval_string ())))
     {
       frame.protect_var (forced_interactive);
       forced_interactive = true;
     }
 
   // octave_parser constructor sets this for us.
   frame.protect_var (LEXER);
 
@@ -736,17 +734,17 @@ Pick a number, any number!\n\
 and waits for the user to enter a value.  The string entered by the user\n\
 is evaluated as an expression, so it may be a literal constant, a\n\
 variable name, or any other valid expression.\n\
 \n\
 Currently, @code{input} only returns one value, regardless of the number\n\
 of values produced by the evaluation of the expression.\n\
 \n\
 If you are only interested in getting a literal string value, you can\n\
-call @code{input} with the character string @code{\"s\"} as the second\n\
+call @code{input} with the character string @qcode{\"s\"} as the second\n\
 argument.  This tells Octave to return the string entered by the user\n\
 directly, without evaluating it first.\n\
 \n\
 Because there may be output waiting to be displayed by the pager, it is\n\
 a good idea to always call @code{fflush (stdout)} before calling\n\
 @code{input}.  This will ensure that all pending output is written to\n\
 the screen before your prompt.\n\
 @seealso{yes_or_no, kbhit}\n\
@@ -1223,17 +1221,17 @@ for input.\n\
 DEFUN (PS1, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS1 (@var{new_val}, \"local\")\n\
 Query or set the primary prompt string.  When executing interactively,\n\
 Octave displays the primary prompt when it is ready to read a command.\n\
 \n\
-The default value of the primary prompt string is @code{\"\\s:\\#> \"}.\n\
+The default value of the primary prompt string is @qcode{\"\\s:\\#> \"}.\n\
 To change it, use a command like\n\
 \n\
 @example\n\
 PS1 (\"\\\\u@@\\\\H> \")\n\
 @end example\n\
 \n\
 @noindent\n\
 which will result in the prompt @samp{boris@@kremvax> } for the user\n\
@@ -1246,77 +1244,77 @@ This can be useful for coloring the prom
 \n\
 @example\n\
 PS1 (\"\\\\[\\\\033[01;31m\\\\]\\\\s:\\\\#> \\\\[\\\\033[0m\\\\]\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will give the default Octave prompt a red coloring.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{PS2, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS1);
 }
 
 DEFUN (PS2, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS2 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS2 (@var{new_val}, \"local\")\n\
 Query or set the secondary prompt string.  The secondary prompt is\n\
 printed when Octave is expecting additional input to complete a\n\
 command.  For example, if you are typing a @code{for} loop that spans several\n\
 lines, Octave will print the secondary prompt at the beginning of\n\
 each line after the first.  The default value of the secondary prompt\n\
-string is @code{\"> \"}.\n\
+string is @qcode{\"> \"}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{PS1, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
 DEFUN (PS4, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS4 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS4 (@var{new_val}, \"local\")\n\
 Query or set the character string used to prefix output produced\n\
 when echoing commands is enabled.\n\
-The default value is @code{\"+ \"}.\n\
+The default value is @qcode{\"+ \"}.\n\
 @xref{Diary and Echo Commands}, for a description of echoing commands.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{echo, echo_executing_commands, PS1, PS2}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS4);
 }
 
 DEFUN (completion_append_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} completion_append_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} completion_append_char (@var{new_val}, \"local\")\n\
 Query or set the internal character variable that is appended to\n\
 successful command-line completion attempts.  The default\n\
-value is @code{\" \"} (a single space).\n\
+value is @qcode{\" \"} (a single space).\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
 DEFUN (echo_executing_commands, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
@@ -1337,19 +1335,19 @@ Echo commands read from command line.\n\
 @end table\n\
 \n\
 More than one state can be active at once.  For example, a value of 3 is\n\
 equivalent to the command @kbd{echo on all}.\n\
 \n\
 The value of @code{echo_executing_commands} may be set by the @kbd{echo}\n\
 command or the command line option @option{--echo-commands}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 DEFUN (__request_drawnow__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __request_drawnow__ ()\n\
@@ -1412,19 +1410,19 @@ For example,\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 will set a breakpoint at the first line of the subfunction @code{mysubfunc}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   char tmp = Vfilemarker;
   octave_value retval = SET_INTERNAL_VARIABLE (filemarker);
 
   // The character passed must not be a legal character for a function name
   if (! error_state && (::isalnum (Vfilemarker) || Vfilemarker == '_'))
     {
diff --git a/libinterp/corefcn/jit-ir.cc b/libinterp/corefcn/jit-ir.cc
--- a/libinterp/corefcn/jit-ir.cc
+++ b/libinterp/corefcn/jit-ir.cc
@@ -29,18 +29,23 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_LLVM
 
 #include "jit-ir.h"
 
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instructions.h>
+#else
 #include <llvm/BasicBlock.h>
 #include <llvm/Instructions.h>
+#endif
 
 #include "error.h"
 
 // -------------------- jit_factory --------------------
 jit_factory::~jit_factory (void)
 {
   for (value_list::iterator iter = all_values.begin ();
        iter != all_values.end (); ++iter)
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -30,23 +30,40 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #ifdef HAVE_LLVM
 
 #include "jit-typeinfo.h"
 
 #include <llvm/Analysis/Verifier.h>
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
+
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+#include <llvm/IR/GlobalVariable.h>
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/Intrinsics.h>
+#else
 #include <llvm/GlobalVariable.h>
-#include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/LLVMContext.h>
 #include <llvm/Function.h>
 #include <llvm/Instructions.h>
 #include <llvm/Intrinsics.h>
+#endif
+
+#ifdef HAVE_LLVM_SUPPORT_IRBUILDER_H
 #include <llvm/Support/IRBuilder.h>
+#elif defined(HAVE_LLVM_IR_IRBUILDER_H)
+#include <llvm/IR/IRBuilder.h>
+#else
+#include <llvm/IRBuilder.h>
+#endif
+
 #include <llvm/Support/raw_os_ostream.h>
 
 #include "jit-ir.h"
 #include "ov.h"
 #include "ov-builtin.h"
 #include "ov-complex.h"
 #include "ov-scalar.h"
 #include "pager.h"
@@ -574,20 +591,33 @@ jit_function::jit_function (llvm::Module
 
   // we mark all functinos as external linkage because this prevents llvm
   // from getting rid of always inline functions
   llvm::FunctionType *ft = llvm::FunctionType::get (rtype, llvm_args, false);
   llvm_function = llvm::Function::Create (ft, llvm::Function::ExternalLinkage,
                                           aname, module);
 
   if (sret ())
-    llvm_function->addAttribute (1, llvm::Attribute::StructRet);
+    {
+#ifdef FUNCTION_ADDATTRIBUTE_ARG_IS_ATTRIBUTES
+      llvm::AttrBuilder attr_builder;
+      attr_builder.addAttribute (llvm::Attributes::StructRet);
+      llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder);
+      llvm_function->addAttribute (1, attrs);
+#else
+      llvm_function->addAttribute (1, llvm::Attribute::StructRet);
+#endif
+    }
 
   if (call_conv == jit_convention::internal)
+#ifdef FUNCTION_ADDFNATTR_ARG_IS_ATTRIBUTES
+    llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
+#else
     llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
+#endif
 }
 
 jit_function::jit_function (const jit_function& fn, jit_type *aresult,
                             const std::vector<jit_type *>& aargs)
   : module (fn.module), llvm_function (fn.llvm_function), mresult (aresult),
     args (aargs), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
 {
 }
@@ -680,17 +710,24 @@ jit_function::call (llvm::IRBuilderD& bu
       llvm_args.push_back (arg);
     }
 
   llvm::CallInst *callinst = builder.CreateCall (llvm_function, llvm_args);
   llvm::Value *ret = callinst;
 
   if (sret ())
     {
+#ifdef CALLINST_ADDATTRIBUTE_ARG_IS_ATTRIBUTES
+      llvm::AttrBuilder attr_builder;
+      attr_builder.addAttribute(llvm::Attributes::StructRet);
+      llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder); 
+      callinst->addAttribute (1, attrs);
+#else
       callinst->addAttribute (1, llvm::Attribute::StructRet);
+#endif
       ret = builder.CreateLoad (sret_mem);
     }
 
   if (mresult)
     {
       jit_type::convert_fn unpack = mresult->unpack (call_conv);
       if (unpack)
         ret = unpack (builder, ret);
diff --git a/libinterp/corefcn/jit-util.cc b/libinterp/corefcn/jit-util.cc
--- a/libinterp/corefcn/jit-util.cc
+++ b/libinterp/corefcn/jit-util.cc
@@ -27,17 +27,22 @@ along with Octave; see the file COPYING.
 #define __STDC_CONSTANT_MACROS
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #ifdef HAVE_LLVM
 
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+#include <llvm/IR/Value.h>
+#else
 #include <llvm/Value.h>
+#endif
+
 #include <llvm/Support/raw_os_ostream.h>
 
 std::ostream&
 operator<< (std::ostream& os, const llvm::Value& v)
 {
   llvm::raw_os_ostream llvm_out (os);
   v.print (llvm_out);
   return os;
diff --git a/libinterp/corefcn/jit-util.h b/libinterp/corefcn/jit-util.h
--- a/libinterp/corefcn/jit-util.h
+++ b/libinterp/corefcn/jit-util.h
@@ -26,16 +26,20 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_jit_util_h)
 #define octave_jit_util_h 1
 
 #ifdef HAVE_LLVM
 
 #include <stdexcept>
 
+#if defined(HAVE_LLVM_IR_DATALAYOUT_H) || defined(HAVE_LLVM_DATALAYOUT_H)
+#define HAVE_LLVM_DATALAYOUT
+#endif
+
 // we don't want to include llvm headers here, as they require
 // __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS be defined in the entire
 // compilation unit
 namespace llvm
 {
   class Value;
   class Module;
   class FunctionPassManager;
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2314,18 +2314,18 @@ No checks are made for duplicate element
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add named directories to the function search path.  If\n\
-@var{option} is \"-begin\" or 0 (the default), prepend the\n\
-directory name to the current path.  If @var{option} is \"-end\"\n\
+@var{option} is @qcode{\"-begin\"} or 0 (the default), prepend the\n\
+directory name to the current path.  If @var{option} is @qcode{\"-end\"}\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
 addpath (\"dir1:/dir2:~/dir3\")\n\
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -264,16 +264,30 @@ get_file_format (std::istream& file, con
             {
               file.clear ();
               file.seekg (0, std::ios::beg);
 
               std::string tmp = extract_keyword (file, "name");
 
               if (! tmp.empty ())
                 retval = LS_ASCII;
+              else
+                {
+                  file.clear ();
+                  file.seekg (0, std::ios::beg);
+
+                  // FIXME -- looks_like_mat_ascii_file does not check to see
+                  // whether the file contains numbers.  It just skips comments and
+                  // checks for the same number of words on each line.  We may need
+                  // a better check here.  The best way to do that might be just
+                  // to try to read the file and see if it works.
+
+                  if (looks_like_mat_ascii_file (file, filename))
+                    retval = LS_MAT_ASCII;
+                }
             }
         }
     }
 
   return retval;
 }
 
 static load_save_format
@@ -283,49 +297,46 @@ get_file_format (const std::string& fnam
   load_save_format retval = LS_UNKNOWN;
 
 #ifdef HAVE_HDF5
   // check this before we open the file
   if (H5Fis_hdf5 (fname.c_str ()) > 0)
     return LS_HDF5;
 #endif /* HAVE_HDF5 */
 
-  std::ifstream file (fname.c_str ());
+#ifdef HAVE_ZLIB
+  use_zlib = check_gzip_magic (fname);
+#else
   use_zlib = false;
-
-  if (file)
-    {
-      retval = get_file_format (file, orig_fname);
-      file.close ();
-
-#ifdef HAVE_ZLIB
-      if (retval == LS_UNKNOWN && check_gzip_magic (fname))
-        {
-          gzifstream gzfile (fname.c_str ());
-          use_zlib = true;
-
-          if (gzfile)
-            {
-              retval = get_file_format (gzfile, orig_fname);
-              gzfile.close ();
-            }
-        }
 #endif
 
-      // FIXME -- looks_like_mat_ascii_file does not check to see
-      // whether the file contains numbers.  It just skips comments and
-      // checks for the same number of words on each line.  We may need
-      // a better check here.  The best way to do that might be just
-      // to try to read the file and see if it works.
-
-      if (retval == LS_UNKNOWN && looks_like_mat_ascii_file (fname))
-        retval = LS_MAT_ASCII;
+  if (! use_zlib)
+    {
+      std::ifstream file (fname.c_str ());
+      if (file)
+        {
+          retval = get_file_format (file, orig_fname);
+          file.close ();
+        }
+      else if (! quiet)
+        gripe_file_open ("load", orig_fname);
     }
-  else if (! quiet)
-    gripe_file_open ("load", orig_fname);
+#ifdef HAVE_ZLIB
+  else
+    {
+      gzifstream gzfile (fname.c_str ());
+      if (gzfile)
+        {
+          retval = get_file_format (gzfile, orig_fname);
+          gzfile.close ();
+        }
+      else if (! quiet)
+        gripe_file_open ("load", orig_fname);
+    }
+#endif
 
   return retval;
 }
 
 octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
          load_save_format format, oct_mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
@@ -612,17 +623,17 @@ Note that Octave can read @sc{hdf5} file
 skip some datasets in formats that it cannot support.  This format is\n\
 only available if Octave was built with a link to the @sc{hdf5} libraries.\n\
 \n\
 @item -import\n\
 This option is accepted for backward compatibility but is ignored.\n\
 Octave can now support multi-dimensional HDF data and automatically\n\
 modifies variable names if they are invalid Octave identifiers.\n\
 \n\
-@item -mat\n\
+@item  -mat\n\
 @itemx -mat-binary\n\
 @itemx -6\n\
 @itemx -v6\n\
 @itemx -7\n\
 @itemx -v7\n\
 Force Octave to assume the file is in @sc{matlab}'s version 6 or 7 binary\n\
 format.\n\
 \n\
@@ -1310,16 +1321,18 @@ save_vars (const string_vector& argv, in
         }
       else
         save_fields (os, struct_var_map, "*", fmt, save_as_floats);
     }
   else
     {
       for (int i = argv_idx; i < argc; i++)
         {
+          if (argv[i] == "")
+            continue;  // Skip empty vars for Matlab compatibility
           if (! save_vars (os, argv[i], fmt, save_as_floats))
             warning ("save: no such variable '%s'", argv[i].c_str ());
         }
     }
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
@@ -1504,39 +1517,39 @@ Center for Supercomputing Applications a
 This format is only available if Octave was built with a link to the\n\
 @sc{hdf5} libraries.\n\
 \n\
 @item -float-hdf5\n\
 Save the data in @sc{hdf5} format but only using single precision.\n\
 Only use this format if you know that all the\n\
 values to be saved can be represented in single precision.\n\
 \n\
-@item -V7\n\
+@item  -V7\n\
 @itemx -v7\n\
 @itemx -7\n\
 @itemx -mat7-binary\n\
 Save the data in @sc{matlab}'s v7 binary data format.\n\
 \n\
-@item -V6\n\
+@item  -V6\n\
 @itemx -v6\n\
 @itemx -6\n\
 @itemx -mat\n\
 @itemx -mat-binary\n\
 Save the data in @sc{matlab}'s v6 binary data format.\n\
 \n\
-@item -V4\n\
+@item  -V4\n\
 @itemx -v4\n\
 @itemx -4\n\
 @itemx -mat4-binary\n\
 Save the data in the binary format written by @sc{matlab} version 4.\n\
 \n\
 @item -text\n\
 Save the data in Octave's text data format.  (default).\n\
 \n\
-@item -zip\n\
+@item  -zip\n\
 @itemx -z\n\
 Use the gzip algorithm to compress the file.  This works equally on files\n\
 that are compressed with gzip outside of octave, and gzip can equally be\n\
 used to convert the files for backward compatibility.\n\
 This option is only available if Octave was built with a link to the zlib\n\
 libraries.\n\
 @end table\n\
 \n\
@@ -1756,41 +1769,41 @@ the file @file{data} in Octave's binary 
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-workspace\" if it\n\
+to save all current variables to the file @file{octave-workspace} if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
 }
 
 DEFUN (save_default_options, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_default_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_default_options (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} save_default_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the default options\n\
 for the @code{save} command, and defines the default format.\n\
-Typical values include @code{\"-ascii\"}, @code{\"-text -zip\"}.\n\
+Typical values include @qcode{\"-ascii\"}, @qcode{\"-text -zip\"}.\n\
 The default value is @option{-text}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{save}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (save_default_options);
 }
 
 DEFUN (octave_core_file_limit, args, nargout,
   "-*- texinfo -*-\n\
@@ -1801,37 +1814,37 @@ Query or set the internal variable that 
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).  If\n\
 @var{octave_core_file_options} flags specify a binary format,\n\
 then @var{octave_core_file_limit} will be approximately the maximum\n\
 size of the file.  If a text file format is used, then the file could\n\
 be much larger than the limit.  The default value is -1 (unlimited)\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
 DEFUN (octave_core_file_name, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_name (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
-The default value is @code{\"octave-workspace\"}\n\
+The default value is @qcode{\"octave-workspace\"}\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
 }
 
 DEFUN (octave_core_file_options, args, nargout,
   "-*- texinfo -*-\n\
@@ -1839,19 +1852,19 @@ DEFUN (octave_core_file_options, args, n
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options used for\n\
 saving the workspace data if Octave aborts.  The value of\n\
 @code{octave_core_file_options} should follow the same format as the\n\
 options for the @code{save} function.  The default value is Octave's binary\n\
 format.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_options);
 }
 
 DEFUN (save_header_format_string, args, nargout,
   "-*- texinfo -*-\n\
@@ -1867,16 +1880,16 @@ passed to @code{strftime} and should beg
 the header comment is omitted from text-format data files.  The\n\
 default value is\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 \"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end smallexample\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{strftime, save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (save_header_format_string);
 }
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -102,17 +102,17 @@ get_mat_data_input_line (std::istream& i
         }
     }
   while (! (have_data || is.eof ()));
 
   return retval;
 }
 
 static void
-get_lines_and_columns (std::istream& is, 
+get_lines_and_columns (std::istream& is,
                        octave_idx_type& nr, octave_idx_type& nc,
                        const std::string& filename = std::string (),
                        bool quiet = false, bool check_numeric = false)
 {
   std::streampos pos = is.tellg ();
 
   int file_line_number = 0;
 
@@ -405,26 +405,19 @@ save_mat_ascii_data (std::ostream& os, c
 
       os.precision (old_precision);
     }
 
   return (os && success);
 }
 
 bool
-looks_like_mat_ascii_file (const std::string& filename)
+looks_like_mat_ascii_file (std::istream& is, const std::string& filename)
 {
   bool retval = false;
-
-  std::ifstream is (filename.c_str ());
+  octave_idx_type nr = 0;
+  octave_idx_type nc = 0;
 
-  if (is)
-    {
-      octave_idx_type nr = 0;
-      octave_idx_type nc = 0;
-
-      get_lines_and_columns (is, nr, nc, filename, true, true);
-
-      retval = (nr != 0 && nc != 0);
-    }
+  get_lines_and_columns (is, nr, nc, filename, true, true);
+  retval = (nr != 0 && nc != 0);
 
   return retval;
 }
diff --git a/libinterp/corefcn/ls-mat-ascii.h b/libinterp/corefcn/ls-mat-ascii.h
--- a/libinterp/corefcn/ls-mat-ascii.h
+++ b/libinterp/corefcn/ls-mat-ascii.h
@@ -26,11 +26,11 @@ along with Octave; see the file COPYING.
 extern std::string
 read_mat_ascii_data (std::istream& is, const std::string& filename,
                      octave_value& tc);
 
 extern bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val_arg,
                      int precision, bool tabs = false);
 
-extern bool looks_like_mat_ascii_file (const std::string& filename);
+extern bool looks_like_mat_ascii_file (std::istream& is, const std::string& filename);
 
 #endif
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -189,27 +189,18 @@ mopt_digit_to_float_format (int mach)
       flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
       break;
 
     case 1:
       flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
       break;
 
     case 2:
-      flt_fmt = oct_mach_info::flt_fmt_vax_d;
-      break;
-
     case 3:
-      flt_fmt = oct_mach_info::flt_fmt_vax_g;
-      break;
-
     case 4:
-      flt_fmt = oct_mach_info::flt_fmt_cray;
-      break;
-
     default:
       flt_fmt = oct_mach_info::flt_fmt_unknown;
       break;
     }
 
   return flt_fmt;
 }
 
@@ -223,28 +214,16 @@ float_format_to_mopt_digit (oct_mach_inf
     case oct_mach_info::flt_fmt_ieee_little_endian:
       retval = 0;
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       retval = 1;
       break;
 
-    case oct_mach_info::flt_fmt_vax_d:
-      retval = 2;
-      break;
-
-    case oct_mach_info::flt_fmt_vax_g:
-      retval = 3;
-      break;
-
-    case oct_mach_info::flt_fmt_cray:
-      retval = 4;
-      break;
-
     default:
       break;
     }
 
   return retval;
 }
 
 // Extract one value (scalar, matrix, string, etc.) from stream IS and
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1955,17 +1955,17 @@ save_mat5_array_length (const double* va
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
           for (octave_idx_type i = 0; i < nel; i++)
             {
               double tmp = val[i];
 
-              if (! (xisnan (tmp) || xisinf (tmp))
+              if (xfinite (tmp)
                   && fabs (tmp) > std::numeric_limits<float>::max ())
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
 
           if (!too_large_for_float)
diff --git a/libinterp/corefcn/ls-oct-ascii.cc b/libinterp/corefcn/ls-oct-ascii.cc
--- a/libinterp/corefcn/ls-oct-ascii.cc
+++ b/libinterp/corefcn/ls-oct-ascii.cc
@@ -362,17 +362,17 @@ save_three_d (std::ostream& os, const oc
 {
   bool fail = false;
 
   octave_idx_type nr = tc.rows ();
   octave_idx_type nc = tc.columns ();
 
   if (tc.is_real_matrix ())
     {
-      os << "# 3D data...\n"
+      os << "# 3-D data...\n"
          << "# type: matrix\n"
          << "# total rows: " << nr << "\n"
          << "# total columns: " << nc << "\n";
 
       long old_precision = os.precision ();
       os.precision (6);
 
       if (parametric)
@@ -403,31 +403,31 @@ save_three_d (std::ostream& os, const oc
                 os << "\n";
             }
         }
 
       os.precision (old_precision);
     }
   else
     {
-      ::error ("for now, I can only save real matrices in 3D format");
+      ::error ("for now, I can only save real matrices in 3-D format");
       fail = true;
     }
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} save_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 digits to keep when saving data in text format.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.\n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (save_precision, -1,
                                             std::numeric_limits<int>::max ());
 }
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -120,28 +120,29 @@ This typically leads to a sparser and mo
 An additional input argument @var{thres}, that defines the pivoting\n\
 threshold can be given.  @var{thres} can be a scalar, in which case\n\
 it defines the @sc{umfpack} pivoting tolerance for both symmetric and\n\
 unsymmetric cases.  If @var{thres} is a 2-element vector, then the first\n\
 element defines the pivoting tolerance for the unsymmetric @sc{umfpack}\n\
 pivoting strategy and the second for the symmetric strategy.  By default,\n\
 the values defined by @code{spparms} are used ([0.1, 0.001]).\n\
 \n\
-Given the string argument \"vector\", @code{lu} returns the values of @var{P}\n\
-and @var{Q} as vector values, such that for full matrix, @code{@var{A}\n\
-(@var{P},:) = @var{L} * @var{U}}, and @code{@var{R}(@var{P},:) * @var{A}\n\
-(:, @var{Q}) = @var{L} * @var{U}}.\n\
+Given the string argument @qcode{\"vector\"}, @code{lu} returns the values\n\
+of @var{P} and @var{Q} as vector values, such that for full matrix,\n\
+@code{@var{A} (@var{P},:) = @var{L} * @var{U}}, and @code{@var{R}(@var{P},:)\n\
+* @var{A} (:, @var{Q}) = @var{L} * @var{U}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{A} = @var{L} * @var{U}}.\n\
 With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
 routines is returned.  If the input matrix is sparse then the matrix @var{L}\n\
 is embedded into @var{U} to give a return value similar to the full case.\n\
 For both full and sparse matrices, @code{lu} loses the permutation\n\
 information.\n\
+@seealso{luupdate, chol, hess, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
   bool scale = (nargout  == 5);
 
   if (nargin < 1 || (issparse && (nargin > 3 || nargout > 5))
@@ -609,17 +610,17 @@ in that case, an updated permutation mat
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
 [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
 @noindent\n\
-then a factorization of @xcode{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
+then a factorization of @tcode{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
 either as\n\
 \n\
 @example\n\
 [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
@@ -630,17 +631,17 @@ or\n\
 \n\
 The first form uses the unpivoted algorithm, which is faster, but less\n\
 stable.  The second form uses a slower pivoted algorithm, which is more\n\
 stable.\n\
 \n\
 The matrix case is done as a sequence of rank-1 updates;\n\
 thus, for large enough k, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
-@seealso{lu, qrupdate, cholupdate}\n\
+@seealso{lu, cholupdate, qrupdate}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   bool pivoted = nargin == 5;
 
   if (nargin != 4 && nargin != 5)
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -42,17 +42,17 @@ DEFUN (luinc, args, nargout,
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
-Called with a second argument of '0', the zero-level incomplete\n\
+Called with a second argument of @qcode{'0'}, the zero-level incomplete\n\
 LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
 where the position of the non-zero arguments correspond to the same\n\
 positions as in the matrix @var{A}.\n\
 \n\
 Alternatively, the fill-in of the incomplete LU@tie{}factorization can\n\
 be controlled through the variable @var{droptol} or the structure\n\
 @var{opts}.  The @sc{umfpack} multifrontal factorization code by Tim A.\n\
 Davis is used for the incomplete LU@tie{}factorization, (availability\n\
@@ -86,18 +86,18 @@ factors.  The default is @code{false}.\n
 @item thresh\n\
 Defines the pivot threshold in the interval [0,1].  Values outside that\n\
 range are ignored.\n\
 @end table\n\
 \n\
 All other fields in @var{opts} are ignored.  The outputs from @code{luinc}\n\
 are the same as for @code{lu}.\n\
 \n\
-Given the string argument \"vector\", @code{luinc} returns the values of\n\
-@var{p} @var{q} as vector values.\n\
+Given the string argument @qcode{\"vector\"}, @code{luinc} returns the\n\
+values of @var{p} @var{q} as vector values.\n\
 @seealso{sparse, lu}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin == 0)
     print_usage ();
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -45,58 +45,59 @@ DEFUN (matrix_type, args, ,
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 more rapid solutions of linear equations involving @var{A} to be performed.\n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
-If the option \"nocompute\" is given, the function will not attempt to guess\n\
-the type if it is still unknown.  This is useful for debugging purposes.\n\
+If the option @qcode{\"nocompute\"} is given, the function will not attempt\n\
+to guess the type if it is still unknown.  This is useful for debugging\n\
+purposes.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and\n\
 can be one of the following\n\
 \n\
 @table @asis\n\
-@item \"unknown\"\n\
+@item @qcode{\"unknown\"}\n\
 Remove any previously cached matrix type, and mark type as unknown.\n\
 \n\
-@item \"full\"\n\
+@item @qcode{\"full\"}\n\
 Mark the matrix as full.\n\
 \n\
-@item \"positive definite\"\n\
+@item @qcode{\"positive definite\"}\n\
 Probable full positive definite matrix.\n\
 \n\
-@item \"diagonal\"\n\
+@item @qcode{\"diagonal\"}\n\
 Diagonal matrix.  (Sparse matrices only)\n\
 \n\
-@item \"permuted diagonal\"\n\
+@item @qcode{\"permuted diagonal\"}\n\
 Permuted Diagonal matrix.  The permutation does not need to be specifically\n\
 indicated, as the structure of the matrix explicitly gives this.  (Sparse\n\
 matrices only)\n\
 \n\
-@item \"upper\"\n\
+@item @qcode{\"upper\"}\n\
 Upper triangular.  If the optional third argument @var{perm} is given, the\n\
 matrix is assumed to be a permuted upper triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
-@item \"lower\"\n\
+@item @qcode{\"lower\"}\n\
 Lower triangular.  If the optional third argument @var{perm} is given, the\n\
 matrix is assumed to be a permuted lower triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
-@item \"banded\"\n\
-@itemx \"banded positive definite\"\n\
+@item  @qcode{\"banded\"}\n\
+@itemx @qcode{\"banded positive definite\"}\n\
 Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}\n\
 above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and\n\
 treated with specialized code.  In addition the matrix can be marked as\n\
 probably a positive definite.  (Sparse matrices only)\n\
 \n\
-@item \"singular\"\n\
+@item @qcode{\"singular\"}\n\
 The matrix is assumed to be singular and will be treated with a minimum norm\n\
 solution.\n\
 \n\
 @end table\n\
 \n\
 Note that the matrix type will be discovered automatically on the first\n\
 attempt to solve a linear equation involving @var{A}.  Therefore\n\
 @code{matrix_type} is only useful to give Octave hints of the matrix type.\n\
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -658,85 +658,111 @@ do_cumminmax_body (const octave_value_li
   return retval;
 }
 
 DEFUN (cummin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cummin (@var{x})\n\
 @deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
-Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
-is unspecified it defaults to column-wise operation.  For example:\n\
+Return the cumulative minimum values along dimension @var{dim}.\n\
+\n\
+If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
+example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
    @result{}  5  4  4  2  2  1\n\
 @end group\n\
 @end example\n\
 \n\
-\n\
-The call\n\
-\n\
-@example\n\
-  [w, iw] = cummin (x)\n\
-@end example\n\
-\n\
-@noindent\n\
-with @code{x} a vector, is equivalent to the following code:\n\
+If called with two output arguments the index of the minimum value is also\n\
+returned.\n\
 \n\
 @example\n\
 @group\n\
-w = iw = zeros (size (x));\n\
-for i = 1:length (x)\n\
-  [w(i), iw(i)] = max (x(1:i));\n\
-endfor\n\
+[w, iw] = cummin ([5 4 6 2 3 1])\n\
+@result{}\n\
+w =  5  4  4  2  2  1\n\
+iw = 1  2  2  4  4  6\n\
 @end group\n\
 @end example\n\
 \n\
-@noindent\n\
-but computed in a much faster manner.\n\
 @seealso{cummax, min, max}\n\
 @end deftypefn")
 {
   return do_cumminmax_body (args, nargout, true);
 }
 
+/*
+%!assert (cummin ([1, 4, 2, 3]), [1 1 1 1])
+%!assert (cummin ([1; -10; 5; -2]), [1; -10; -10; -10])
+%!assert (cummin ([4, i; -2, 2]), [4, i; -2, i])
+
+%!test
+%! x = reshape (1:8, [2,2,2]);
+%! assert (cummin (x, 1), reshape ([1 1 3 3 5 5 7 7], [2,2,2]));
+%! assert (cummin (x, 2), reshape ([1 2 1 2 5 6 5 6], [2,2,2]));
+%! [w, iw] = cummin (x, 3);
+%! assert (ndims (w), 3);
+%! assert (w, repmat ([1 3; 2 4], [1 1 2]));
+%! assert (ndims (iw), 3);
+%! assert (iw, ones (2,2,2));
+
+%!error cummin ()
+%!error cummin (1, 2, 3)
+*/
+
 DEFUN (cummax, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cummax (@var{x})\n\
 @deftypefnx {Built-in Function} {} cummax (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
-Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
-is unspecified it defaults to column-wise operation.  For example:\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@dots{})\n\
+Return the cumulative maximum values along dimension @var{dim}.\n\
+\n\
+If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
+example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
    @result{}  1  3  3  6  6  6\n\
 @end group\n\
 @end example\n\
 \n\
-The call\n\
-\n\
-@example\n\
-[w, iw] = cummax (x, dim)\n\
-@end example\n\
-\n\
-@noindent\n\
-with @code{x} a vector, is equivalent to the following code:\n\
+If called with two output arguments the index of the maximum value is also\n\
+returned.\n\
 \n\
 @example\n\
 @group\n\
-w = iw = zeros (size (x));\n\
-for i = 1:length (x)\n\
-  [w(i), iw(i)] = max (x(1:i));\n\
-endfor\n\
+[w, iw] = cummax ([1 3 2 6 4 5])\n\
+@result{}\n\
+w =  1  3  3  6  6  6\n\
+iw = 1  2  2  4  4  4\n\
 @end group\n\
 @end example\n\
 \n\
-@noindent\n\
-but computed in a much faster manner.\n\
 @seealso{cummin, max, min}\n\
 @end deftypefn")
 {
   return do_cumminmax_body (args, nargout, false);
 }
+
+/*
+%!assert (cummax ([1, 4, 2, 3]), [1 4 4 4])
+%!assert (cummax ([1; -10; 5; -2]), [1; 1; 5; 5])
+%!assert (cummax ([4, i 4.9, -2, 2, 3+4i]), [4, 4, 4.9, 4.9, 4.9, 3+4i])
+
+%!test
+%! x = reshape (8:-1:1, [2,2,2]);
+%! assert (cummax (x, 1), reshape ([8 8 6 6 4 4 2 2], [2,2,2]));
+%! assert (cummax (x, 2), reshape ([8 7 8 7 4 3 4 3], [2,2,2]));
+%! [w, iw] = cummax (x, 3);
+%! assert (ndims (w), 3);
+%! assert (w, repmat ([8 6; 7 5], [1 1 2]));
+%! assert (ndims (iw), 3);
+%! assert (iw, ones (2,2,2));
+
+%!error cummax ()
+%!error cummax (1, 2, 3)
+*/
+
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -1159,17 +1159,17 @@ public:
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
 
     switch (get_class_id ())
       {
       case mxLOGICAL_CLASS:
-        retval = int_to_ov<bool, boolNDArray, bool> (dv);
+        retval = int_to_ov<mxLogical, boolNDArray, bool> (dv);
         break;
 
       case mxCHAR_CLASS:
         {
           mwSize nel = get_number_of_elements ();
 
           mxChar *ppr = static_cast<mxChar *> (pr);
 
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -1,15 +1,17 @@
 EXTRA_DIST += \
   corefcn/module.mk \
   corefcn/defaults.in.h \
   corefcn/gl2ps.c \
   corefcn/graphics.in.h \
   corefcn/mxarray.in.h \
-  corefcn/oct-errno.in.cc
+  corefcn/oct-errno.in.cc \
+  corefcn/oct-tex-lexer.in.ll \
+  corefcn/oct-tex-symbols.in
 
 ## Options functions for Fortran packages like LSODE, DASPK.
 ## These are generated automagically by configure and Perl.
 OPT_HANDLERS = \
   corefcn/DASPK-opts.cc \
   corefcn/DASRT-opts.cc \
   corefcn/DASSL-opts.cc \
   corefcn/LSODE-opts.cc \
@@ -21,28 +23,32 @@ OPT_INC = \
   $(top_builddir)/liboctave/numeric/DASSL-opts.h \
   $(top_builddir)/liboctave/numeric/LSODE-opts.h \
   $(top_builddir)/liboctave/numeric/Quad-opts.h
 
 $(OPT_HANDLERS): corefcn/%.cc : $(top_builddir)/liboctave/numeric/%.in
 	$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-handler-fcns $< > $@-t
 	mv $@-t $@
 
+$(OPT_HANDLERS): $(top_srcdir)/build-aux/mk-opts.pl
+
 $(OPT_INC) : %.h : %.in
 	$(MAKE) -C $(top_builddir)/liboctave/numeric $(@F)
 
 JIT_INC = \
   corefcn/jit-util.h \
   corefcn/jit-typeinfo.h \
   corefcn/jit-ir.h \
   corefcn/pt-jit.h
 
+TEX_PARSER_INC = \
+  corefcn/oct-tex-parser.h
+
 COREFCN_INC = \
   corefcn/Cell.h \
-  corefcn/action-container.h \
   corefcn/c-file-ptr-stream.h \
   corefcn/comment-list.h \
   corefcn/cutils.h \
   corefcn/data.h \
   corefcn/debug.h \
   corefcn/defun-dld.h \
   corefcn/defun-int.h \
   corefcn/defun.h \
@@ -69,16 +75,17 @@ COREFCN_INC = \
   corefcn/ls-oct-ascii.h \
   corefcn/ls-oct-binary.h \
   corefcn/ls-utils.h \
   corefcn/mex.h \
   corefcn/mexproto.h \
   corefcn/mxarray.in.h \
   corefcn/oct-errno.h \
   corefcn/oct-fstrm.h \
+  corefcn/oct-handle.h \
   corefcn/oct-hdf5.h \
   corefcn/oct-hist.h \
   corefcn/oct-iostrm.h \
   corefcn/oct-lvalue.h \
   corefcn/oct-map.h \
   corefcn/oct-obj.h \
   corefcn/oct-prcstrm.h \
   corefcn/oct-procbuf.h \
@@ -95,32 +102,36 @@ COREFCN_INC = \
   corefcn/siglist.h \
   corefcn/sparse-xdiv.h \
   corefcn/sparse-xpow.h \
   corefcn/symtab.h \
   corefcn/sysdep.h \
   corefcn/toplev.h \
   corefcn/txt-eng-ft.h \
   corefcn/txt-eng.h \
-  corefcn/unwind-prot.h \
   corefcn/utils.h \
   corefcn/variables.h \
   corefcn/workspace-element.h \
   corefcn/xdiv.h \
   corefcn/xnorm.h \
   corefcn/xpow.h \
   corefcn/zfstream.h \
-  $(JIT_INC)
+  $(JIT_INC) \
+  $(TEX_PARSER_INC)
 
 JIT_SRC = \
   corefcn/jit-util.cc \
   corefcn/jit-typeinfo.cc \
   corefcn/jit-ir.cc \
   corefcn/pt-jit.cc
 
+TEX_PARSER_SRC = \
+  corefcn/oct-tex-lexer.ll \
+  corefcn/oct-tex-parser.yy
+
 C_COREFCN_SRC = \
   corefcn/cutils.c \
   corefcn/matherr.c \
   corefcn/siglist.c \
   corefcn/xgl2ps.c
 
 COREFCN_SRC = \
   corefcn/Cell.cc \
@@ -235,19 +246,20 @@ COREFCN_SRC = \
   corefcn/svd.cc \
   corefcn/syl.cc \
   corefcn/symtab.cc \
   corefcn/syscalls.cc \
   corefcn/sysdep.cc \
   corefcn/time.cc \
   corefcn/toplev.cc \
   corefcn/tril.cc \
+  corefcn/txt-eng.cc \
   corefcn/txt-eng-ft.cc \
   corefcn/typecast.cc \
-  corefcn/unwind-prot.cc \
+  corefcn/urlwrite.cc \
   corefcn/utils.cc \
   corefcn/variables.cc \
   corefcn/xdiv.cc \
   corefcn/xnorm.cc \
   corefcn/xpow.cc \
   corefcn/zfstream.cc \
   $(JIT_SRC) \
   $(C_COREFCN_SRC)
@@ -285,13 +297,33 @@ corefcn/oct-errno.cc: corefcn/oct-errno.
 	mv $@-t $@
 
 corefcn/mxarray.h: corefcn/mxarray.in.h Makefile
 	$(SED) < $< \
 	  -e "s|%NO_EDIT_WARNING%|DO NOT EDIT!  Generated automatically from $(<F) by Make.|" \
 	  -e "s|%OCTAVE_IDX_TYPE%|${OCTAVE_IDX_TYPE}|" > $@-t
 	mv $@-t $@
 
-noinst_LTLIBRARIES += corefcn/libcorefcn.la
+corefcn/oct-tex-lexer.ll: corefcn/oct-tex-lexer.in.ll corefcn/oct-tex-symbols.in Makefile.am
+	$(AWK) 'BEGIN { print "/* DO NOT EDIT. AUTOMATICALLY GENERATED FROM oct-tex-lexer.in.ll and oct-tex-symbols.in. */"; } /^@SYMBOL_RULES@$$/ { count = 0; while (getline < "$(srcdir)/corefcn/oct-tex-symbols.in") { if ($$0 !~ /^#.*/ && NF == 3) { printf("\"\\\\%s\" { yylval->sym = %d; return SYM; }\n", $$1, count); count++; } } getline } ! /^@SYMBOL_RULES@$$/ { print }' $< > $@-t
+	mv $@-t $@
+
+corefcn/oct-tex-symbols.cc: corefcn/oct-tex-symbols.in Makefile.am
+	$(AWK) 'BEGIN { print "// DO NOT EDIT. AUTOMATICALLY GENERATED FROM oct-tex-symbols.in."; print "static uint32_t symbol_codes[][2] = {"; count = 0; } END { print "};"; printf("static int num_symbol_codes = %d;\n", count); } /^#/ { } { if (NF == 3) { printf("  { %s, %s },\n", $$2, $$3); count++; } }' $< > $@-t
+	mv $@-t $@
+
+corefcn/txt-eng.cc: corefcn/oct-tex-symbols.cc
+corefcn/oct-tex-lexer.cc: LEX_OUTPUT_ROOT := lex.octave_tex_
+corefcn/oct-tex-parser.h: corefcn/oct-tex-parser.yy
+
+
+noinst_LTLIBRARIES += \
+  corefcn/libcorefcn.la \
+  corefcn/libtex_parser.la
 
 corefcn_libcorefcn_la_SOURCES = $(COREFCN_SRC)
 corefcn_libcorefcn_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS) $(FFTW_XCPPFLAGS)
 
+corefcn_libtex_parser_la_SOURCES = $(TEX_PARSER_SRC)
+corefcn_libtex_parser_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
+corefcn_libtex_parser_la_CXXFLAGS = \
+  $(filter-out -Wold-style-cast, $(AM_CXXFLAGS))
+
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-handle.h
@@ -0,0 +1,147 @@
+/*
+
+Copyright (C) 2007-2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_handle_h)
+#define octave_handle_h 1
+
+#include "dMatrix.h"
+#include "lo-ieee.h"
+
+#include "ov.h"
+
+// ---------------------------------------------------------------------
+
+class octave_handle
+{
+public:
+  octave_handle (void) : val (octave_NaN) { }
+
+  octave_handle (const octave_value& a)
+    : val (octave_NaN)
+  {
+    if (a.is_empty ())
+      /* do nothing */;
+    else
+      {
+        double tval = a.double_value ();
+
+        if (! error_state)
+          val = tval;
+        else
+          error ("invalid handle");
+      }
+  }
+
+  octave_handle (int a) : val (a) { }
+
+  octave_handle (double a) : val (a) { }
+
+  octave_handle (const octave_handle& a) : val (a.val) { }
+
+  octave_handle& operator = (const octave_handle& a)
+  {
+    if (&a != this)
+      val = a.val;
+
+    return *this;
+  }
+
+  ~octave_handle (void) { }
+
+  double value (void) const { return val; }
+
+  octave_value as_octave_value (void) const
+  {
+    return ok () ? octave_value (val) : octave_value (Matrix ());
+  }
+
+  // Prefix increment/decrement operators.
+  octave_handle& operator ++ (void)
+  {
+    ++val;
+    return *this;
+  }
+
+  octave_handle& operator -- (void)
+  {
+    --val;
+    return *this;
+  }
+
+  // Postfix increment/decrement operators.
+  const octave_handle operator ++ (int)
+  {
+    octave_handle old_value = *this;
+    ++(*this);
+    return old_value;
+  }
+
+  const octave_handle operator -- (int)
+  {
+    octave_handle old_value = *this;
+    --(*this);
+    return old_value;
+  }
+
+  bool ok (void) const { return ! xisnan (val); }
+
+private:
+  double val;
+};
+
+inline bool
+operator == (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () == b.value ();
+}
+
+inline bool
+operator != (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () != b.value ();
+}
+
+inline bool
+operator < (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () < b.value ();
+}
+
+inline bool
+operator <= (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () <= b.value ();
+}
+
+inline bool
+operator >= (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () >= b.value ();
+}
+
+inline bool
+operator > (const octave_handle& a, const octave_handle& b)
+{
+  return a.value () > b.value ();
+}
+
+#endif
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -323,20 +323,18 @@ edit_history_add_hist (const std::string
       std::string tmp = line;
 
       int len = tmp.length ();
 
       if (len > 0 && tmp[len-1] == '\n')
         tmp.resize (len - 1);
 
       if (! tmp.empty ())
-        {
-          command_history::add (tmp);
+        if (command_history::add (tmp))
           octave_link::append_history (tmp);
-        }
     }
 }
 
 static bool
 get_int_arg (const octave_value& arg, int& val)
 {
   bool ok = true;
 
@@ -575,20 +573,18 @@ initialize_history (bool read_history_fi
 void
 octave_history_write_timestamp (void)
 {
   octave_localtime now;
 
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
-    {
-      command_history::add (timestamp); 
+    if (command_history::add (timestamp))
       octave_link::append_history (timestamp);
-   }
 }
 
 DEFUN (edit_history, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Command} {} edit_history\n\
 @deftypefnx {Command} {} edit_history @var{cmd_number}\n\
 @deftypefnx {Command} {} edit_history @var{first} @var{last}\n\
 Edit the history list using the editor named by the variable\n\
@@ -754,22 +750,23 @@ A value of @code{ignoreboth} is shorthan
 @code{ignoredups}.  A value of @code{erasedups} causes all previous lines\n\
 matching the current line to be removed from the history list before that\n\
 line is saved.  Any value not in the above list is ignored.  If\n\
 @code{history_control} is the empty string, all commands are saved on\n\
 the history list, subject to the value of @code{history_save}.\n\
 @seealso{history_file, history_size, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   std::string old_history_control = command_history::histcontrol ();
 
   std::string tmp = old_history_control;
 
-  octave_value retval = set_internal_variable (tmp, args, nargout,
-                                               "history_control");
+  retval = set_internal_variable (tmp, args, nargout, "history_control");
 
   if (tmp != old_history_control)
     command_history::process_histcontrol (tmp);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
@@ -777,23 +774,25 @@ DEFUN (history_size, args, nargout,
 @deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
 to store in the history file.  The default value is @code{1000},\n\
 but may be overridden by the environment variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   int old_history_size = command_history::size ();
 
   int tmp = old_history_size;
 
-  octave_value retval = set_internal_variable (tmp, args, nargout,
-                                               "history_size", -1,
-                                               std::numeric_limits<int>::max ());
+  retval = set_internal_variable (tmp, args, nargout,
+                                  "history_size", -1,
+                                  std::numeric_limits<int>::max ());
 
   if (tmp != old_history_size)
     command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
@@ -802,22 +801,23 @@ DEFUN (history_file, args, nargout,
 @deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 file used to store command history.  The default value is\n\
 @file{~/.octave_hist}, but may be overridden by the environment\n\
 variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, history_save, history_timestamp_format_string}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   std::string old_history_file = command_history::file ();
 
   std::string tmp = old_history_file;
 
-  octave_value retval = set_internal_variable (tmp, args, nargout,
-                                               "history_file");
+  retval = set_internal_variable (tmp, args, nargout, "history_file");
 
   if (tmp != old_history_file)
     command_history::set_file (tmp);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
@@ -829,43 +829,44 @@ Query or set the internal variable that 
 for the comment line that is written to the history file when Octave\n\
 exits.  The format string is passed to @code{strftime}.  The default\n\
 value is\n\
 \n\
 @example\n\
 \"# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end example\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{strftime, history_file, history_size, history_save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
 }
 
 DEFUN (history_save, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_save ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_save (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} history_save (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{history_control, history_file, history_size, history_timestamp_format_string}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   bool old_history_save = ! command_history::ignoring_entries ();
 
   bool tmp = old_history_save;
 
-  octave_value retval = set_internal_variable (tmp, args, nargout,
-                                               "history_save");
+  retval = set_internal_variable (tmp, args, nargout, "history_save");
 
   if (tmp != old_history_save)
     command_history::ignore_entries (! tmp);
 
   return retval;
 }
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -469,16 +469,17 @@ private:
                       const octave_map *map_list, octave_map& retval);
 };
 
 template<>
 inline octave_map octave_value_extract<octave_map> (const octave_value& v)
   { return v.map_value (); }
 
 // The original Octave_map object which is now deprecated.
+// It was fully deprecated in version 3.8 and should be removed in 3.12.
 // Octave_map and octave_map are convertible to each other.
 
 class
 OCTINTERP_API
 Octave_map
 {
  public:
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -1184,39 +1184,16 @@ octave_scan (std::istream& is, const sca
 template<>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
                char* valptr)
 {
   return is >> valptr;
 }
 
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, long int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, short int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, unsigned int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, unsigned long int*);
-
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, unsigned short int*);
-
-#if 0
-template std::istream&
-octave_scan (std::istream&, const scanf_format_elt&, float*);
-#endif
-
 template<>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double* valptr)
 {
   double& ref = *valptr;
 
   switch (fmt.type)
     {
@@ -1273,46 +1250,16 @@ do_scanf_conv (std::istream& is, const s
         {
           conversion_count++;
           data[idx++] = *(valptr);
         }
     }
 }
 
 template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, long int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, short int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned long int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, unsigned short int*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-
-#if 0
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, float*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
-#endif
-
-template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
                Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
@@ -2397,40 +2344,16 @@ do_printf_conv (std::ostream& os, const 
     default:
       ::error ("%s: internal error handling format", who.c_str ());
       break;
     }
 
   return retval;
 }
 
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, int,
-                const std::string&);
-
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, long,
-                const std::string&);
-
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, unsigned int,
-                const std::string&);
-
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, unsigned long,
-                const std::string&);
-
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, double,
-                const std::string&);
-
-template int
-do_printf_conv (std::ostream&, const char*, int, int, int, const char*,
-                const std::string&);
-
 #define DO_DOUBLE_CONV(TQUAL) \
   do \
     { \
       if (val > std::numeric_limits<TQUAL long>::max () \
           || val < std::numeric_limits<TQUAL long>::min ()) \
         { \
           std::string tfmt = fmt; \
  \
@@ -2539,19 +2462,27 @@ octave_base_stream::do_printf (printf_fo
 
                           if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
                             {
                               tfmt.erase (i2, i1-i2);
                               if (elt->prec < 0)
                                 nsa--;
                             }
 
-                          const char *tval = xisinf (val)
-                            ? (val < 0 ? "-Inf" : "Inf")
-                            : (lo_ieee_is_NA (val) ? "NA" : "NaN");
+                          const char *tval;
+                          if (xisinf (val))
+                            if (elt->flags.find ('+') != std::string::npos)
+                              tval = (val < 0 ? "-Inf" : "+Inf");
+                            else
+                              tval = (val < 0 ? "-Inf" : "Inf");
+                          else
+                            if (elt->flags.find ('+') != std::string::npos)
+                              tval = (lo_ieee_is_NA (val) ? "+NA" : "+NaN");
+                            else
+                              tval = (lo_ieee_is_NA (val) ? "NA" : "NaN");
 
                           retval += do_printf_conv (os, tfmt.c_str (),
                                                     nsa, sa_1, sa_2,
                                                     tval, who);
                         }
                       else
                         {
                           char type = elt->type;
@@ -3022,329 +2953,339 @@ octave_stream::is_open (void) const
 
 void
 octave_stream::close (void)
 {
   if (stream_ok ())
     rep->close ();
 }
 
-template <class RET_T, class READ_T>
-octave_value
-do_read (octave_stream& strm, octave_idx_type nr, octave_idx_type nc, octave_idx_type block_size,
-         octave_idx_type skip, bool do_float_fmt_conv, bool do_NA_conv,
-         oct_mach_info::float_format from_flt_fmt, octave_idx_type& count)
+template <class SRC_T, class DST_T>
+static octave_value
+convert_and_copy (std::list<void *>& input_buf_list,
+                  octave_idx_type input_buf_elts,
+                  octave_idx_type elts_read,
+                  octave_idx_type nr, octave_idx_type nc, bool swap,
+                  bool do_float_fmt_conv, bool do_NA_conv,
+                  oct_mach_info::float_format from_flt_fmt)
 {
-  octave_value retval;
-
-  RET_T nda;
-
-  count = 0;
-
-  typedef typename RET_T::element_type ELMT;
-  ELMT elt_zero = ELMT ();
-
-  ELMT *dat = 0;
-
-  octave_idx_type max_size = 0;
-
-  octave_idx_type final_nr = 0;
-  octave_idx_type final_nc = 1;
-
-  if (nr > 0)
+  typedef typename DST_T::element_type dst_elt_type;
+
+  DST_T conv (dim_vector (nr, nc));
+
+  dst_elt_type *conv_data = conv.fortran_vec ();
+
+  octave_idx_type j = 0;
+
+  for (std::list<void *>::const_iterator it = input_buf_list.begin ();
+       it != input_buf_list.end (); it++)
     {
-      if (nc > 0)
+      SRC_T *data = static_cast<SRC_T *> (*it);
+
+      if (swap || do_float_fmt_conv)
         {
-          nda.resize (dim_vector (nr, nc), elt_zero);
-          dat = nda.fortran_vec ();
-          max_size = nr * nc;
+          for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+               i++, j++)
+            {
+              if (swap)
+                swap_bytes<sizeof (SRC_T)> (&data[i]);
+              else if (do_float_fmt_conv)
+                do_float_format_conversion (&data[i], sizeof (SRC_T),
+                                            1, from_flt_fmt,
+                                            oct_mach_info::float_format ());
+
+              dst_elt_type tmp (data[i]);
+
+              if (do_NA_conv && __lo_ieee_is_old_NA (tmp))
+                tmp = __lo_ieee_replace_old_NA (tmp);
+
+              conv_data[j] = tmp;
+            }
         }
       else
         {
-          nda.resize (dim_vector (nr, 32), elt_zero);
-          dat = nda.fortran_vec ();
-          max_size = nr * 32;
+          if (do_NA_conv)
+            {
+              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                   i++, j++)
+                {
+                  dst_elt_type tmp (data[i]);
+
+                  if (__lo_ieee_is_old_NA (tmp))
+                    tmp = __lo_ieee_replace_old_NA (tmp);
+
+                  conv_data[j] = tmp;
+                }
+            }
+          else
+            {
+              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                   i++, j++)
+                conv_data[j] = data[i];
+            }
         }
+
+      delete [] data;
     }
-  else
+
+  input_buf_list.clear ();
+
+  for (octave_idx_type i = elts_read; i < nr * nc; i++)
+    conv_data[i] = dst_elt_type (0);
+
+  return conv;
+}
+
+typedef octave_value (*conv_fptr)
+  (std::list<void *>& input_buf_list, octave_idx_type input_buf_elts,
+   octave_idx_type elts_read, octave_idx_type nr, octave_idx_type nc,
+   bool swap, bool do_float_fmt_conv, bool do_NA_conv,
+   oct_mach_info::float_format from_flt_fmt);
+
+#define TABLE_ELT(T, U, V, W) \
+  conv_fptr_table[oct_data_conv::T][oct_data_conv::U] = convert_and_copy<V, W>
+
+#define FILL_TABLE_ROW(T, V) \
+  TABLE_ELT (T, dt_int8, V, int8NDArray); \
+  TABLE_ELT (T, dt_uint8, V, uint8NDArray); \
+  TABLE_ELT (T, dt_int16, V, int16NDArray); \
+  TABLE_ELT (T, dt_uint16, V, uint16NDArray); \
+  TABLE_ELT (T, dt_int32, V, int32NDArray); \
+  TABLE_ELT (T, dt_uint32, V, uint32NDArray); \
+  TABLE_ELT (T, dt_int64, V, int64NDArray); \
+  TABLE_ELT (T, dt_uint64, V, uint64NDArray); \
+  TABLE_ELT (T, dt_single, V, FloatNDArray); \
+  TABLE_ELT (T, dt_double, V, NDArray); \
+  TABLE_ELT (T, dt_char, V, charNDArray); \
+  TABLE_ELT (T, dt_schar, V, charNDArray); \
+  TABLE_ELT (T, dt_uchar, V, charNDArray); \
+  TABLE_ELT (T, dt_logical, V, boolNDArray);
+
+octave_value
+octave_stream::finalize_read (std::list<void *>& input_buf_list,
+                              octave_idx_type input_buf_elts,
+                              octave_idx_type elts_read,
+                              octave_idx_type nr, octave_idx_type nc,
+                              oct_data_conv::data_type input_type,
+                              oct_data_conv::data_type output_type,
+                              oct_mach_info::float_format ffmt)
+{
+  octave_value retval;
+
+  static bool initialized = false;
+
+  // Table function pointers for return types x read types.
+
+  static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
+
+  if (! initialized)
     {
-      nda.resize (dim_vector (32, 1), elt_zero);
-      dat = nda.fortran_vec ();
-      max_size = 32;
+      for (int i = 0; i < oct_data_conv::dt_unknown; i++)
+        for (int j = 0; j < 14; j++)
+          conv_fptr_table[i][j] = 0;
+
+      FILL_TABLE_ROW (dt_int8, int8_t);
+      FILL_TABLE_ROW (dt_uint8, uint8_t);
+      FILL_TABLE_ROW (dt_int16, int16_t);
+      FILL_TABLE_ROW (dt_uint16, uint16_t);
+      FILL_TABLE_ROW (dt_int32, int32_t);
+      FILL_TABLE_ROW (dt_uint32, uint32_t);
+      FILL_TABLE_ROW (dt_int64, int64_t);
+      FILL_TABLE_ROW (dt_uint64, uint64_t);
+      FILL_TABLE_ROW (dt_single, float);
+      FILL_TABLE_ROW (dt_double, double);
+      FILL_TABLE_ROW (dt_char, char);
+      FILL_TABLE_ROW (dt_schar, signed char);
+      FILL_TABLE_ROW (dt_uchar, unsigned char);
+      FILL_TABLE_ROW (dt_logical, bool);
+
+      initialized = true;
     }
 
-  // FIXME -- byte order for Cray?
-
   bool swap = false;
 
+  if (ffmt == oct_mach_info::flt_fmt_unknown)
+    ffmt = float_format ();
+
   if (oct_mach_info::words_big_endian ())
-    swap = (from_flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-            || from_flt_fmt == oct_mach_info::flt_fmt_vax_g
-            || from_flt_fmt == oct_mach_info::flt_fmt_vax_g);
+    swap = (ffmt == oct_mach_info::flt_fmt_ieee_little_endian);
   else
-    swap = (from_flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
-
-  union
-  {
-    char buf[sizeof (typename strip_template_param<octave_int, READ_T>::type)];
-    typename strip_template_param<octave_int, READ_T>::type val;
-  } u;
-
-  std::istream *isp = strm.input_stream ();
-
-  if (isp)
+    swap = (ffmt == oct_mach_info::flt_fmt_ieee_big_endian);
+
+  bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
+                             || input_type == oct_data_conv::dt_single)
+                            && ffmt != float_format ());
+
+  bool do_NA_conv = (output_type == oct_data_conv::dt_double);
+
+  switch (output_type)
     {
-      std::istream& is = *isp;
-
-      octave_idx_type elts_read = 0;
-
-      for (;;)
-        {
-          // FIXME -- maybe there should be a special case for
-          // skip == 0.
-
-          if (is)
-            {
-              if (nr > 0 && nc > 0 && count == max_size)
-                {
-                  final_nr = nr;
-                  final_nc = nc;
-
-                  break;
-                }
-
-              is.read (u.buf, sizeof (typename strip_template_param<octave_int, READ_T>::type));
-
-              // We only swap bytes for integer types.  For float
-              // types, the format conversion will also handle byte
-              // swapping.
-
-              if (swap)
-                swap_bytes<sizeof (typename strip_template_param<octave_int, READ_T>::type)> (u.buf);
-              else if (do_float_fmt_conv)
-                do_float_format_conversion
-                  (u.buf,
-                   sizeof (typename strip_template_param<octave_int, READ_T>::type),
-                   1, from_flt_fmt, oct_mach_info::float_format ());
-
-              typename RET_T::element_type tmp
-                = static_cast <typename RET_T::element_type> (u.val);
-
-              if (is)
-                {
-                  if (count == max_size)
-                    {
-                      max_size *= 2;
-
-                      if (nr > 0)
-                        nda.resize (dim_vector (nr, max_size / nr),
-                                    elt_zero);
-                      else
-                        nda.resize (dim_vector (max_size, 1), elt_zero);
-
-                      dat = nda.fortran_vec ();
-                    }
-
-                  if (do_NA_conv && __lo_ieee_is_old_NA (tmp))
-                    tmp = __lo_ieee_replace_old_NA (tmp);
-
-                  dat[count++] = tmp;
-
-                  elts_read++;
-                }
-
-              int seek_status = 0;
-
-              if (skip != 0 && elts_read == block_size)
-                {
-                  seek_status = strm.seek (skip, SEEK_CUR);
-                  elts_read = 0;
-                }
-
-              if (is.eof () || seek_status < 0)
-                {
-                  if (nr > 0)
-                    {
-                      if (count > nr)
-                        {
-                          final_nr = nr;
-                          final_nc = (count - 1) / nr + 1;
-                        }
-                      else
-                        {
-                          final_nr = count;
-                          final_nc = 1;
-                        }
-                    }
-                  else
-                    {
-                      final_nr = count;
-                      final_nc = 1;
-                    }
-
-                  break;
-                }
-            }
-          else if (is.eof ())
-            break;
-        }
+    case oct_data_conv::dt_int8:
+    case oct_data_conv::dt_uint8:
+    case oct_data_conv::dt_int16:
+    case oct_data_conv::dt_uint16:
+    case oct_data_conv::dt_int32:
+    case oct_data_conv::dt_uint32:
+    case oct_data_conv::dt_int64:
+    case oct_data_conv::dt_uint64:
+    case oct_data_conv::dt_single:
+    case oct_data_conv::dt_double:
+    case oct_data_conv::dt_char:
+    case oct_data_conv::dt_schar:
+    case oct_data_conv::dt_uchar:
+    case oct_data_conv::dt_logical:
+      {
+        conv_fptr fptr = conv_fptr_table[input_type][output_type];
+
+        retval = fptr (input_buf_list, input_buf_elts, elts_read,
+                       nr, nc, swap, do_float_fmt_conv, do_NA_conv, ffmt);
+      }
+      break;
+
+    default:
+      retval = false;
+      (*current_liboctave_error_handler)
+        ("read: invalid type specification");
+      break;
     }
-
-  nda.resize (dim_vector (final_nr, final_nc), elt_zero);
-
-  retval = nda;
+  
 
   return retval;
 }
 
-#define DO_READ_VAL_TEMPLATE(RET_T, READ_T) \
-  template octave_value \
-  do_read<RET_T, READ_T> (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, bool, \
-                          oct_mach_info::float_format, octave_idx_type&)
-
-// FIXME -- should we only have float if it is a different
-// size from double?
-
-#define INSTANTIATE_DO_READ(VAL_T) \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_int8); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_uint8); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_int16); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_uint16); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_int32); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_uint32); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_int64); \
-  DO_READ_VAL_TEMPLATE (VAL_T, octave_uint64); \
-  DO_READ_VAL_TEMPLATE (VAL_T, float); \
-  DO_READ_VAL_TEMPLATE (VAL_T, double); \
-  DO_READ_VAL_TEMPLATE (VAL_T, char); \
-  DO_READ_VAL_TEMPLATE (VAL_T, signed char); \
-  DO_READ_VAL_TEMPLATE (VAL_T, unsigned char)
-
-INSTANTIATE_DO_READ (int8NDArray);
-INSTANTIATE_DO_READ (uint8NDArray);
-INSTANTIATE_DO_READ (int16NDArray);
-INSTANTIATE_DO_READ (uint16NDArray);
-INSTANTIATE_DO_READ (int32NDArray);
-INSTANTIATE_DO_READ (uint32NDArray);
-INSTANTIATE_DO_READ (int64NDArray);
-INSTANTIATE_DO_READ (uint64NDArray);
-INSTANTIATE_DO_READ (FloatNDArray);
-INSTANTIATE_DO_READ (NDArray);
-INSTANTIATE_DO_READ (charNDArray);
-INSTANTIATE_DO_READ (boolNDArray);
-
-typedef octave_value (*read_fptr) (octave_stream&, octave_idx_type, octave_idx_type, octave_idx_type, octave_idx_type, bool, bool,
-                                   oct_mach_info::float_format ffmt, octave_idx_type&);
-
-#define FILL_TABLE_ROW(R, VAL_T) \
-  read_fptr_table[R][oct_data_conv::dt_int8] = do_read<VAL_T, octave_int8>; \
-  read_fptr_table[R][oct_data_conv::dt_uint8] = do_read<VAL_T, octave_uint8>; \
-  read_fptr_table[R][oct_data_conv::dt_int16] = do_read<VAL_T, octave_int16>; \
-  read_fptr_table[R][oct_data_conv::dt_uint16] = do_read<VAL_T, octave_uint16>; \
-  read_fptr_table[R][oct_data_conv::dt_int32] = do_read<VAL_T, octave_int32>; \
-  read_fptr_table[R][oct_data_conv::dt_uint32] = do_read<VAL_T, octave_uint32>; \
-  read_fptr_table[R][oct_data_conv::dt_int64] = do_read<VAL_T, octave_int64>; \
-  read_fptr_table[R][oct_data_conv::dt_uint64] = do_read<VAL_T, octave_uint64>; \
-  read_fptr_table[R][oct_data_conv::dt_single] = do_read<VAL_T, float>; \
-  read_fptr_table[R][oct_data_conv::dt_double] = do_read<VAL_T, double>; \
-  read_fptr_table[R][oct_data_conv::dt_char] = do_read<VAL_T, char>; \
-  read_fptr_table[R][oct_data_conv::dt_schar] = do_read<VAL_T, signed char>; \
-  read_fptr_table[R][oct_data_conv::dt_uchar] = do_read<VAL_T, unsigned char>; \
-  read_fptr_table[R][oct_data_conv::dt_logical] = do_read<VAL_T, unsigned char>
-
 octave_value
 octave_stream::read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
                      octave_idx_type skip, oct_mach_info::float_format ffmt,
                      octave_idx_type& char_count)
 {
-  static bool initialized = false;
-
-  // Table function pointers for return types x read types.
-
-  static read_fptr read_fptr_table[oct_data_conv::dt_unknown][14];
-
-  if (! initialized)
-    {
-      for (int i = 0; i < oct_data_conv::dt_unknown; i++)
-        for (int j = 0; j < 14; j++)
-          read_fptr_table[i][j] = 0;
-
-      FILL_TABLE_ROW (oct_data_conv::dt_int8, int8NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_uint8, uint8NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_int16, int16NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_uint16, uint16NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_int32, int32NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_uint32, uint32NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_int64, int64NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_uint64, uint64NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_single, FloatNDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_double, NDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_char, charNDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_schar, charNDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_uchar, charNDArray);
-      FILL_TABLE_ROW (oct_data_conv::dt_logical, boolNDArray);
-
-      initialized = true;
-    }
-
   octave_value retval;
 
+  octave_idx_type nr = -1;
+  octave_idx_type nc = -1;
+
+  bool one_elt_size_spec = false;
+
   if (stream_ok ())
     {
       // FIXME -- we may eventually want to make this extensible.
 
       // FIXME -- we need a better way to ensure that this
       // numbering stays consistent with the order of the elements in the
       // data_type enum in the oct_data_conv class.
 
       char_count = 0;
 
-      octave_idx_type nr = -1;
-      octave_idx_type nc = -1;
-
-      bool ignore;
-
-      get_size (size, nr, nc, ignore, "fread");
+      get_size (size, nr, nc, one_elt_size_spec, "fread");
 
       if (! error_state)
         {
-          if (nr == 0 || nc == 0)
-            retval = Matrix (nr, nc);
+
+          octave_idx_type elts_to_read = std::numeric_limits<octave_idx_type>::max ();
+
+          if (one_elt_size_spec)
+            {
+              // If NR == 0, Matlab returns [](0x0).
+
+              // If NR > 0, the result will be a column vector with the given
+              // number of rows.
+
+              // If NR < 0, then we have Inf and the result will be a column
+              // vector but we have to wait to see how big NR will be.
+
+              if (nr == 0)
+                nr = nc = 0;
+              else
+                nc = 1;
+            }
           else
             {
-              if (ffmt == oct_mach_info::flt_fmt_unknown)
-                ffmt = float_format ();
-
-              read_fptr fcn = read_fptr_table[output_type][input_type];
-
-              bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
-                                         || input_type == oct_data_conv::dt_single)
-                                        && ffmt != float_format ());
-
-              bool do_NA_conv = (output_type == oct_data_conv::dt_double);
-
-              if (fcn)
+              // Matlab returns [] even if there are two elements in the size
+              // specification and one is nonzero.
+
+              // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
+              // should be.
+
+              if (nr == 0 || nc == 0)
+                nr = nc = 0;
+            }
+
+          // FIXME -- ensure that this does not overflow.
+
+          elts_to_read = nr * nc;
+
+          bool read_to_eof = elts_to_read < 0;
+
+          octave_idx_type input_buf_elts = -1;
+
+          if (skip == 0)
+            {
+              if (read_to_eof)
+                input_buf_elts = 1024 * 1024;
+              else
+                input_buf_elts = elts_to_read;
+            }
+          else
+            input_buf_elts = block_size;
+
+          octave_idx_type input_elt_size = oct_data_conv::data_type_size (input_type);
+
+          octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
+
+          assert (input_buf_size >= 0);
+
+          // Must also work and return correct type object for 0 elements to read.
+
+          std::istream *isp = input_stream ();
+
+          if (isp)
+            {
+              std::istream& is = *isp;
+
+              std::list <void *> input_buf_list;
+
+              octave_idx_type elts_read = 0;
+
+              while (is && ! is.eof () && (read_to_eof || elts_read < elts_to_read))
                 {
-                  retval = (*fcn) (*this, nr, nc, block_size, skip,
-                                   do_float_fmt_conv, do_NA_conv,
-                                   ffmt, char_count);
-
-                  // FIXME -- kluge!
-
-                  if (! error_state
-                      && (output_type == oct_data_conv::dt_char
-                          || output_type == oct_data_conv::dt_schar
-                          || output_type == oct_data_conv::dt_uchar))
-                    retval = retval.char_matrix_value ();
+                  char *input_buf = new char [input_buf_size];
+
+                  is.read (input_buf, input_buf_size);
+
+                  size_t count = is.gcount ();
+
+                  char_count += count;
+
+                  elts_read += count / input_elt_size;
+
+                  input_buf_list.push_back (input_buf);
+
+                  if (is && skip != 0 && elts_read == block_size)
+                    {
+                      int seek_status = seek (skip, SEEK_CUR);
+
+                      if (seek_status < 0)
+                        break;
+                    }
                 }
-              else
-                error ("fread: unable to read and convert requested types");
+
+              if (read_to_eof)
+                {
+                  if (nc < 0)
+                    nc = elts_read / nr + 1;
+                  else
+                    nr = elts_read;
+                }
+
+              retval = finalize_read (input_buf_list, input_buf_elts, elts_read,
+                                      nr, nc, input_type, output_type, ffmt);
             }
+          else
+            error ("fread: invalid input stream");
         }
       else
         invalid_operation ("fread", "reading");
     }
 
   return retval;
 }
 
@@ -3372,318 +3313,297 @@ octave_stream::write (const octave_value
         }
       else
         invalid_operation ("fwrite", "writing");
     }
 
   return retval;
 }
 
-template <class T>
-void
-write_int (std::ostream& os, bool swap, const T& val)
+template <class T, class V>
+static void
+convert_ints (const T *data, void *conv_data, octave_idx_type n_elts,
+              bool swap)
 {
-  typename T::val_type tmp = val.value ();
-
-  if (swap)
-    swap_bytes<sizeof (typename T::val_type)> (&tmp);
-
-  os.write (reinterpret_cast<const char *> (&tmp),
-            sizeof (typename T::val_type));
+  typedef typename V::val_type val_type;
+
+  val_type *vt_data = static_cast <val_type *> (conv_data);
+
+  for (octave_idx_type i = 0; i < n_elts; i++)
+    {
+      V val (data[i]);
+
+      vt_data[i] = val.value ();
+
+      if (swap)
+        swap_bytes<sizeof (val_type)> (&vt_data[i]);
+    }
 }
 
-template void write_int (std::ostream&, bool, const octave_int8&);
-template void write_int (std::ostream&, bool, const octave_uint8&);
-template void write_int (std::ostream&, bool, const octave_int16&);
-template void write_int (std::ostream&, bool, const octave_uint16&);
-template void write_int (std::ostream&, bool, const octave_int32&);
-template void write_int (std::ostream&, bool, const octave_uint32&);
-template void write_int (std::ostream&, bool, const octave_int64&);
-template void write_int (std::ostream&, bool, const octave_uint64&);
-
 template <class T>
-static inline bool
-do_write (std::ostream& os, const T& val, oct_data_conv::data_type output_type,
-          oct_mach_info::float_format flt_fmt, bool swap,
-          bool do_float_conversion)
+static bool
+convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
+              oct_data_conv::data_type output_type,
+              oct_mach_info::float_format flt_fmt)
 {
   bool retval = true;
 
-  // For compatibility, Octave converts to the output type, then
-  // writes.  This means that truncation happens on the conversion.
-  // For example, the following program prints 0:
-  //
-  //   x = int8 (-1)
-  //   f = fopen ("foo.dat", "w");
-  //   fwrite (f, x, "unsigned char");
-  //   fclose (f);
-  //   f = fopen ("foo.dat", "r");
-  //   y = fread (f, 1, "unsigned char");
-  //   printf ("%d\n", y);
+  bool swap
+    = ((oct_mach_info::words_big_endian ()
+        && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
+       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+
+  bool do_float_conversion =  flt_fmt != oct_mach_info::float_format ();
+
+  // We use octave_intN classes here instead of converting directly to
+  // intN_t so that we get integer saturation semantics.
 
   switch (output_type)
     {
     case oct_data_conv::dt_char:
     case oct_data_conv::dt_schar:
     case oct_data_conv::dt_int8:
-      write_int (os, swap, octave_int8 (val));
+      convert_ints<T, octave_int8> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_uchar:
     case oct_data_conv::dt_uint8:
-      write_int (os, swap, octave_uint8 (val));
+      convert_ints<T, octave_uint8> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_int16:
-      write_int (os, swap, octave_int16 (val));
+      convert_ints<T, octave_int16> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_uint16:
-      write_int (os, swap, octave_uint16 (val));
+      convert_ints<T, octave_uint16> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_int32:
-      write_int (os, swap, octave_int32 (val));
+      convert_ints<T, octave_int32> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_uint32:
-      write_int (os, swap, octave_uint32 (val));
+      convert_ints<T, octave_uint32> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_int64:
-      write_int (os, swap, octave_int64 (val));
+      convert_ints<T, octave_int64> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_uint64:
-      write_int (os, swap, octave_uint64 (val));
+      convert_ints<T, octave_uint64> (data, conv_data, n_elts, swap);
       break;
 
     case oct_data_conv::dt_single:
       {
-        float f = static_cast<float> (val);
-
-        if (do_float_conversion)
-          do_float_format_conversion (&f, 1, flt_fmt);
-
-        os.write (reinterpret_cast<const char *> (&f), sizeof (float));
+        float *vt_data = static_cast <float *> (conv_data);
+
+        for (octave_idx_type i = 0; i < n_elts; i++)
+          {
+            vt_data[i] = data[i];
+
+            if (do_float_conversion)
+              do_float_format_conversion (&vt_data[i], 1, flt_fmt);
+          }
       }
       break;
 
     case oct_data_conv::dt_double:
       {
-        double d = static_cast<double> (val);
-        if (do_float_conversion)
-          do_double_format_conversion (&d, 1, flt_fmt);
-
-        os.write (reinterpret_cast<const char *> (&d), sizeof (double));
+        double *vt_data = static_cast <double *> (conv_data);
+
+        for (octave_idx_type i = 0; i < n_elts; i++)
+          {
+            vt_data[i] = data[i];
+
+            if (do_float_conversion)
+              do_double_format_conversion (&vt_data[i], 1, flt_fmt);
+          }
       }
       break;
 
     default:
       retval = false;
       (*current_liboctave_error_handler)
         ("write: invalid type specification");
       break;
     }
 
   return retval;
 }
 
-template bool
-do_write (std::ostream&, const octave_int8&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_uint8&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_int16&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_uint16&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_int32&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_uint32&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_int64&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
-
-template bool
-do_write (std::ostream&, const octave_uint64&, oct_data_conv::data_type,
-          oct_mach_info::float_format, bool, bool);
+bool
+octave_stream::write_bytes (const void *data, size_t nbytes)
+{
+  bool status = false;
+
+  std::ostream *osp = output_stream ();
+
+  if (osp)
+    {
+      std::ostream& os = *osp;
+
+      if (os)
+        {
+          os.write (static_cast<const char *> (data), nbytes);
+
+          if (os)
+            status = true;
+        }
+    }
+
+  return status;
+}
+
+bool
+octave_stream::skip_bytes (size_t skip)
+{
+  bool status = false;
+
+  std::ostream *osp = output_stream ();
+
+  if (osp)
+    {
+      std::ostream& os = *osp;
+
+      // Seek to skip when inside bounds of existing file.
+      // Otherwise, write NUL to skip.
+
+      off_t orig_pos = tell ();
+
+      seek (0, SEEK_END);
+
+      off_t eof_pos = tell ();
+
+      // Is it possible for this to fail to return us to the
+      // original position?
+      seek (orig_pos, SEEK_SET);
+
+      size_t remaining = eof_pos - orig_pos;
+
+      if (remaining < skip)
+        {
+          seek (0, SEEK_END);
+
+          // FIXME -- probably should try to write larger blocks...
+
+          unsigned char zero = 0;
+          for (size_t j = 0; j < skip - remaining; j++)
+            os.write (reinterpret_cast<const char *> (&zero), 1);
+        }
+      else
+        seek (skip, SEEK_CUR);
+
+      if (os)
+        status = true;
+    }
+
+  return status;
+}
 
 template <class T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
-                      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
+                      octave_idx_type skip,
+                      oct_mach_info::float_format flt_fmt)
 {
-  octave_idx_type retval = -1;
-
-  bool status = true;
-
-  octave_idx_type count = 0;
-
-  const T *d = data.data ();
-
-  octave_idx_type n = data.length ();
-
-  oct_mach_info::float_format native_flt_fmt
-    = oct_mach_info::float_format ();
-
-  bool do_float_conversion = (flt_fmt != native_flt_fmt);
-
-  // FIXME -- byte order for Cray?
-
-  bool swap = false;
-
-  if (oct_mach_info::words_big_endian ())
-    swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
-            || flt_fmt == oct_mach_info::flt_fmt_vax_g
-            || flt_fmt == oct_mach_info::flt_fmt_vax_g);
+  bool swap
+    = ((oct_mach_info::words_big_endian ()
+        && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
+       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+
+  bool do_data_conversion
+    = (swap || ! is_equivalent_type<T> (output_type) 
+       || flt_fmt != oct_mach_info::float_format ());
+
+  octave_idx_type nel = data.numel ();
+
+  octave_idx_type chunk_size;
+
+  if (skip != 0)
+    chunk_size = block_size;
+  else if (do_data_conversion)
+    chunk_size = 1024 * 1024;
   else
-    swap = (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
-
-  for (octave_idx_type i = 0; i < n; i++)
+    chunk_size = nel;
+
+  octave_idx_type i = 0;
+
+  const T *pdata = data.data ();
+
+  while (i < nel)
     {
-      std::ostream *osp = output_stream ();
-
-      if (osp)
+      if (skip != 0)
         {
-          std::ostream& os = *osp;
-
-          if (skip != 0 && (i % block_size) == 0)
-            {
-              // Seek to skip when inside bounds of existing file.
-              // Otherwise, write NUL to skip.
-
-              off_t orig_pos = tell ();
-
-              seek (0, SEEK_END);
-
-              off_t eof_pos = tell ();
-
-              // Is it possible for this to fail to return us to the
-              // original position?
-              seek (orig_pos, SEEK_SET);
-
-              off_t remaining = eof_pos - orig_pos;
-
-              if (remaining < skip)
-                {
-                  seek (0, SEEK_END);
-
-                  // FIXME -- probably should try to write larger
-                  // blocks...
-
-                  unsigned char zero = 0;
-                  for (octave_idx_type j = 0; j < skip - remaining; j++)
-                    os.write (reinterpret_cast<const char *> (&zero), 1);
-                }
-              else
-                seek (skip, SEEK_CUR);
-            }
-
-          if (os)
-            {
-              status = do_write (os, d[i], output_type, flt_fmt, swap,
-                                 do_float_conversion);
-
-              if (os && status)
-                count++;
-              else
-                break;
-            }
-          else
-            {
-              status = false;
-              break;
-            }
+          if (! skip_bytes (skip))
+            return -1;
+        }
+
+      octave_idx_type remaining_nel = nel - i;
+
+      if (chunk_size > remaining_nel)
+        chunk_size = remaining_nel;
+
+      bool status = false;
+
+      if (do_data_conversion)
+        {
+          size_t output_size
+            = chunk_size * oct_data_conv::data_type_size (output_type);
+
+          OCTAVE_LOCAL_BUFFER (unsigned char, conv_data, output_size);
+
+          status = convert_data (&pdata[i], conv_data, chunk_size,
+                                 output_type, flt_fmt);
+
+          if (status)
+            status = write_bytes (conv_data, output_size);
         }
       else
-        {
-          status = false;
-          break;
-        }
+        status = write_bytes (pdata, sizeof (T) * chunk_size);
+
+      if (! status)
+        return -1;
+
+      i += chunk_size;
     }
 
-  if (status)
-    retval = count;
-
-  return retval;
+  return nel;
 }
 
-template octave_idx_type
-octave_stream::write (const Array<char>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<bool>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<double>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<float>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_int8>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_uint8>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_int16>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_uint16>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_int32>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_uint32>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_int64>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
-
-template octave_idx_type
-octave_stream::write (const Array<octave_uint64>&, octave_idx_type,
-                      oct_data_conv::data_type,
-                      octave_idx_type, oct_mach_info::float_format);
+#define INSTANTIATE_WRITE(T) \
+  template \
+  octave_idx_type \
+  octave_stream::write (const Array<T>& data, octave_idx_type block_size, \
+                        oct_data_conv::data_type output_type, \
+                        octave_idx_type skip, \
+                        oct_mach_info::float_format flt_fmt)
+
+INSTANTIATE_WRITE (octave_int8);
+INSTANTIATE_WRITE (octave_uint8);
+INSTANTIATE_WRITE (octave_int16);
+INSTANTIATE_WRITE (octave_uint16);
+INSTANTIATE_WRITE (octave_int32);
+INSTANTIATE_WRITE (octave_uint32);
+INSTANTIATE_WRITE (octave_int64);
+INSTANTIATE_WRITE (octave_uint64);
+INSTANTIATE_WRITE (int8_t);
+INSTANTIATE_WRITE (uint8_t);
+INSTANTIATE_WRITE (int16_t);
+INSTANTIATE_WRITE (uint16_t);
+INSTANTIATE_WRITE (int32_t);
+INSTANTIATE_WRITE (uint32_t);
+INSTANTIATE_WRITE (int64_t);
+INSTANTIATE_WRITE (uint64_t);
+INSTANTIATE_WRITE (bool);
+INSTANTIATE_WRITE (char);
+INSTANTIATE_WRITE (float);
+INSTANTIATE_WRITE (double);
 
 octave_value
 octave_stream::scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who)
 {
   octave_value retval;
 
   if (stream_ok ())
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -26,22 +26,24 @@ along with Octave; see the file COPYING.
 class Matrix;
 class string_vector;
 class octave_value;
 class octave_value_list;
 
 #include <iosfwd>
 #include <sstream>
 #include <string>
+#include <list>
 #include <map>
 
 #include "Array.h"
 #include "data-conv.h"
 #include "lo-utils.h"
 #include "mach-info.h"
+#include "oct-locbuf.h"
 #include "oct-refcount.h"
 
 class
 OCTINTERP_API
 scanf_format_elt
 {
 public:
 
@@ -534,23 +536,29 @@ public:
 
   octave_value read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
                      octave_idx_type skip, oct_mach_info::float_format flt_fmt,
                      octave_idx_type& count);
 
   octave_idx_type write (const octave_value& data, octave_idx_type block_size,
-             oct_data_conv::data_type output_type,
-             octave_idx_type skip, oct_mach_info::float_format flt_fmt);
+                         oct_data_conv::data_type output_type,
+                         octave_idx_type skip,
+                         oct_mach_info::float_format flt_fmt);
+
+  bool write_bytes (const void *data, size_t n_elts);
+
+  bool skip_bytes (size_t n_elts);
 
   template <class T>
-  octave_idx_type write (const Array<T>&, octave_idx_type block_size,
-             oct_data_conv::data_type output_type,
-             octave_idx_type skip, oct_mach_info::float_format flt_fmt);
+  octave_idx_type write (const Array<T>& data, octave_idx_type block_size,
+                         oct_data_conv::data_type output_type,
+                         octave_idx_type skip,
+                         oct_mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value scanf (const octave_value& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   octave_value_list oscanf (const std::string& fmt,
@@ -636,16 +644,25 @@ private:
       return retval;
     }
 
   void invalid_operation (const std::string& who, const char *rw)
     {
       if (rep)
         rep->invalid_operation (who, rw);
     }
+
+  octave_value
+  finalize_read (std::list<void *>& input_buf_list,
+                 octave_idx_type input_buf_elts,
+                 octave_idx_type elts_read,
+                 octave_idx_type nr, octave_idx_type nc,
+                 oct_data_conv::data_type input_type,
+                 oct_data_conv::data_type output_type,
+                 oct_mach_info::float_format ffmt);
 };
 
 class
 OCTINTERP_API
 octave_stream_list
 {
 protected:
 
diff --git a/libinterp/corefcn/oct-tex-lexer.in.ll b/libinterp/corefcn/oct-tex-lexer.in.ll
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-tex-lexer.in.ll
@@ -0,0 +1,146 @@
+/*
+
+Copyright (C) 2013 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+%option prefix = "octave_tex_"
+%option noyywrap
+%option reentrant
+%option bison-bridge
+
+%top {
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "txt-eng.h"
+#include "oct-tex-parser.h"
+}
+
+%x	NUM_MODE
+%x	MAYBE_NUM_MODE
+
+D       [0-9]
+NUM	(({D}+\.?{D}*)|(\.{D}+))
+
+%%
+
+%{
+// Numeric values
+%}
+
+<NUM_MODE>{NUM}		{
+    int nread;
+
+    nread = sscanf (yytext, "%lf", &(yylval->num));
+    if (nread == 1)
+      return NUM;
+  }
+<NUM_MODE>[ \t]+	{ }
+<NUM_MODE>"\n"|.	{ yyless (0); BEGIN (INITIAL); }
+
+<MAYBE_NUM_MODE>"{"	{ BEGIN (NUM_MODE); return START; }
+<MAYBE_NUM_MODE>"\n"|.	{ yyless (0); BEGIN (INITIAL); }
+
+%{
+// Simple commands
+%}
+
+"\\bf"		{ return BF; }
+"\\it"		{ return IT; }
+"\\sl"		{ return SL; }
+"\\rm"		{ return RM; }
+
+%{
+// Generic font commands
+%}
+
+"\\fontname"	{ return FONTNAME; }
+"\\fontsize"	{ BEGIN (MAYBE_NUM_MODE); return FONTSIZE; }
+"\\color[rgb]"	{ BEGIN (MAYBE_NUM_MODE); return COLOR_RGB; }
+"\\color"	{ return COLOR; }
+
+%{
+// Special characters
+%}
+
+"{"	{ return START; }
+"}"	{ return END; }
+"^"	{ return SUPER; }
+"_"	{ return SUB; }
+
+"\\{"	|
+"\\}"	|
+"\\^"	|
+"\\_"	|
+"\\\\"	{ yylval->ch = yytext[1]; return CH; }
+
+%{
+// Symbols
+%}
+
+@SYMBOL_RULES@
+
+%{
+// Generic character
+%}
+
+"\n"	|
+.	{ yylval->ch = yytext[0]; return CH; }
+
+%%
+
+bool
+text_parser_tex::init_lexer (const std::string& s)
+{
+  if (! scanner)
+    octave_tex_lex_init (&scanner);
+
+  if (scanner)
+    {
+      if (buffer_state)
+        {
+          octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
+                                     scanner);
+          buffer_state = 0;
+        }
+
+      buffer_state = octave_tex__scan_bytes (s.data (), s.length (), scanner);
+    }
+
+  return (scanner && buffer_state);
+}
+
+void
+text_parser_tex::destroy_lexer (void)
+{
+  if (buffer_state)
+    {
+      octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
+                                 scanner);
+      buffer_state = 0;
+    }
+
+  if (scanner)
+    {
+      octave_tex_lex_destroy (scanner);
+      scanner = 0;
+    }
+}
diff --git a/libinterp/corefcn/oct-tex-parser.yy b/libinterp/corefcn/oct-tex-parser.yy
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-tex-parser.yy
@@ -0,0 +1,210 @@
+/*
+
+Copyright (C) 2013 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+%{
+#define YYDEBUG 1
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "txt-eng.h"
+#include "oct-tex-parser.h"
+
+extern int octave_tex_lex (YYSTYPE *, void *);
+static void yyerror (text_parser_tex& parser, const char *s);
+
+#define scanner parser.get_scanner ()
+%}
+
+%name-prefix="octave_tex_"
+%define api.pure
+%parse-param { text_parser_tex& parser } 
+%lex-param { void *scanner }
+
+%code requires {#include <string>}
+
+%union {
+  /* Leaf symbols produced by the scanner */
+  char                       ch;
+  double                     num;
+  int                        sym;
+
+  /* Used for string buffering */
+  std::string*               str;
+
+  /* Objects produced by the parser */
+  text_element*              e_base;
+  text_element_list*         e_list;
+}
+
+%token BF IT SL RM
+%token FONTNAME FONTSIZE
+%token COLOR COLOR_RGB
+%token START END SUPER SUB
+%token<ch> CH
+%token<num> NUM
+%token<sym> SYM
+
+%type<str> simple_string
+%type<e_base> string_element symbol_element
+%type<e_base> superscript_element subscript_element combined_script_element
+%type<e_base> font_modifier_element fontname_element fontsize_element color_element
+%type<e_list> string_element_list scoped_string_element_list
+
+/* Make sure there's no memory leak on parse error. */
+%destructor { } <ch> <num> <sym>
+%destructor { delete $$; } <*>
+
+%nonassoc SCRIPT
+%nonassoc SUB SUPER
+
+%nonassoc STR
+%nonassoc CH
+
+%start string
+
+%%
+
+simple_string			: CH
+				  { $$ = new std::string (1, $1); }
+				| simple_string CH
+				  { $1->append (1, $2); $$ = $1; }
+				;
+
+symbol_element			: SYM
+				  { $$ = new text_element_symbol ($1); }
+				;
+
+font_modifier_element		: BF
+				  { $$ = new text_element_fontstyle (text_element_fontstyle::bold); }
+				| IT
+				  { $$ = new text_element_fontstyle (text_element_fontstyle::italic); }
+				| SL
+				  { $$ = new text_element_fontstyle (text_element_fontstyle::oblique); }
+				| RM
+				  { $$ = new text_element_fontstyle (text_element_fontstyle::normal); }
+				;
+
+fontsize_element		: FONTSIZE START NUM END
+				  { $$ = new text_element_fontsize ($3); }
+				;
+
+fontname_element		: FONTNAME START simple_string END
+				  {
+				    $$ = new text_element_fontname (*$3);
+				    delete $3;
+				  }
+				;
+
+color_element			: COLOR START simple_string END
+				  {
+				    $$ = new text_element_color (*$3);
+				    delete $3;
+				  }
+				| COLOR_RGB START NUM NUM NUM END
+				  {
+				    $$ = new text_element_color ($3, $4, $5);
+				  }
+				;
+
+string_element			: simple_string %prec STR
+				  {
+				    $$ = new text_element_string (*$1);
+				    delete $1;
+				  }
+				| scoped_string_element_list
+				  /* This is just to avoid a warning in bison. */
+				  { $$ = $1; }
+				| symbol_element
+				| font_modifier_element
+				| fontsize_element
+				| fontname_element
+				| color_element
+				| superscript_element %prec SCRIPT
+				| subscript_element %prec SCRIPT
+				| combined_script_element
+				;
+
+superscript_element		: SUPER CH
+				  { $$ = new text_element_superscript ($2); }
+				| SUPER scoped_string_element_list
+				  { $$ = new text_element_superscript ($2); }
+				| SUPER symbol_element
+				  { $$ = new text_element_superscript ($2); }
+				;
+
+subscript_element		: SUB CH
+				  { $$ = new text_element_subscript ($2); }
+				| SUB scoped_string_element_list
+				  { $$ = new text_element_subscript ($2); }
+				| SUB symbol_element
+				  { $$ = new text_element_subscript ($2); }
+				;
+
+combined_script_element		: subscript_element superscript_element
+				  { $$ = new text_element_combined ($1, $2); }
+				| superscript_element subscript_element
+				  { $$ = new text_element_combined ($1, $2); }
+				;
+
+string_element_list		: string_element
+				  { $$ = new text_element_list ($1); }
+				| string_element_list string_element
+				  { $1->push_back ($2); $$ = $1; }
+				;
+
+scoped_string_element_list	: START string_element_list END
+				  { $$ = $2; }
+				| START END
+				  { $$ = new text_element_list (); }
+				;
+
+string				: /* empty */
+				  { parser.set_parse_result (new text_element_string ("")); }
+				| string_element_list
+				  { parser.set_parse_result ($1); }
+				;
+
+%%
+
+text_element*
+text_parser_tex::parse (const std::string& s)
+{
+  octave_tex_debug = 0;
+
+  if (init_lexer (s))
+    {
+      result = 0;
+
+      if (octave_tex_parse (*this) == 0)
+        return result;
+    }
+
+  return new text_element_string (s);
+}
+
+static void
+yyerror (text_parser_tex&, const char *s)
+{
+  fprintf (stderr, "TeX parse error: %s\n", s);
+}
diff --git a/libinterp/corefcn/oct-tex-symbols.in b/libinterp/corefcn/oct-tex-symbols.in
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-tex-symbols.in
@@ -0,0 +1,113 @@
+# List of supported symbols for the TeX interpreter
+# (http://www.mathworks.com/help/matlab/ref/text_props.html):
+# - symbol name
+# - Unicode code
+# - MS symbol code (http://www.kostis.net/charsets/symbol.htm)
+# - Arranged by listings in The TeXbook, Appendix F 
+# - Lowercase Greek letters: Greek Upper case: Misc Symbols type Ord: "Large" operators:
+# - Binary operators: Relations: Negated relations: Arrows: Openings: Closings: Alternate names:
+# - Other (not in Appendix F Tables):
+
+alpha           0x03B1  0xF061
+beta            0x03B2  0xF062
+gamma           0x03B3  0xF067
+delta           0x03B4  0xF064
+epsilon         0x03B5  0xF065
+zeta            0x03B6  0xF07A
+eta             0x03B7  0xF068
+theta           0x03B8  0xF071
+vartheta        0x03D1  0xF04A
+iota            0x03B9  0xF069
+kappa           0x03BA  0xF06B
+lambda          0x03BB  0xF06C
+mu              0x03BC  0xF06D
+nu              0x03BD  0xF06E
+xi              0x03BE  0xF078
+o               0x03BF  0xF0B0
+pi              0x03C0  0xF070
+varpi           0x03D6  0xF076
+rho             0x03C1  0xF072
+sigma           0x03C3  0xF073
+varsigma        0x03C2  0xF056
+tau             0x03C4  0xF074
+upsilon         0x03C5  0xF075
+phi             0x03C6  0xF066
+chi             0x03C7  0xF063
+psi             0x03C8  0xF079
+omega           0x03C9  0xF077
+Gamma           0x0393  0xF047
+Delta           0x0394  0xF044
+Theta           0x0398  0xF051
+Lambda          0x039B  0xF04C
+Xi              0x039E  0xF058
+Pi              0x03A0  0xF050
+Sigma           0x03A3  0xF053
+Upsilon         0x03D2  0xF055
+Phi             0x03A6  0xF046
+Psi             0x03A8  0xF059
+Omega           0x03A9  0xF057
+aleph           0x2135  0xF0C0
+wp              0x2118  0xF0C3
+Re              0x211C  0xF0C2
+Im              0x2111  0xF0C1
+partial         0x2202  0xF0B6
+infty           0x221E  0xF0A5
+prime           0x2032  0xF0A2
+nabla           0x2207  0xF0D1
+surd            0x221A  0xF0D6
+angle           0x2220  0xF0D0
+forall          0x2200  0xF022
+exists          0x2203  0xF024
+neg             0x00AC  0xF0D8
+clubsuit        0x2663  0xF0A7
+diamondsuit     0x2666  0xF0A8
+heartsuit       0x2665  0xF0A9
+spadesuit       0x2660  0xF0AA
+int             0x222B  0xF0F2
+pm              0x00B1  0xF0B1
+cdot            0x22C5  0xF0D7
+times           0x00D7  0xF0B4
+ast             0x2217  0xF02A
+circ            0x2218  0xF0B0
+bullet          0x2219  0xF0B7
+div             0x00F7  0xF0B8
+cap             0x2229  0xF0C7
+cup             0x222A  0xF0C8
+vee             0x2228  0xF0DA
+wedge           0x2227  0xF0D9
+oplus           0x2295  0xF0C5
+otimes          0x2297  0xF0C4
+oslash          0x2298  0xF0C6
+leq             0x2264  0xF0A3
+subset          0x2282  0xF0CC
+subseteq        0x2286  0xF0CD
+in              0x2208  0xF0CE
+geq             0x2265  0xF0B3
+supset          0x2283  0xF0C9
+supseteq        0x2287  0xF0CA
+ni              0x220B  0xF027
+mid             0x2223  0xF0BD
+equiv           0x2261  0xF0BA
+sim             0x223C  0xF07E
+approx          0x2248  0xF0BB
+cong            0x2245  0xF040
+propto          0x221D  0xF0B5
+perp            0x22A5  0xF05E
+leftarrow       0x2190  0xF0AC
+Leftarrow       0x21D0  0xF0DC
+rightarrow      0x2192  0xF0AE
+Rightarrow      0x21D2  0xF0DE
+leftrightarrow  0x2194  0xF0AB
+uparrow         0x2191  0xF0AD
+downarrow       0x2193  0xF0AF
+lfloor          0x230A  0xF0EB
+langle          0x27E8  0xF0E1
+lceil           0x2308  0xF0E9
+rfloor          0x230B  0xF0FB
+rangle          0x27E9  0xF0F1
+rceil           0x2309  0xF0F9
+neq             0x2260  0xF0B9
+ldots           0x2026  0xF0BC
+0               0x2298  0xF0C6
+copyright       0x00A9  0xF0E3
+deg             0x00B0  0xF0B0
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -226,17 +226,17 @@ Undocumented internal function.\n\
           std::list<std::string> items_lst
             = octave_link::file_dialog (filter_lst, title, filename, pathname,
                                         multi_on);
 
           nel = items_lst.size ();
 
           retval.resize (3);
 
-          // If 3, then is filename, directory and selected index.
+          // If 3, then retval is filename, directory, and selected index.
           if (nel <= 3)
             {
               int idx = 0;
               for (std::list<std::string>::iterator it = items_lst.begin ();
                    it != items_lst.end (); it++)
                 {
                   retval(idx++) = *it;
 
@@ -245,22 +245,22 @@ Undocumented internal function.\n\
 
                   if (idx == 3)
                     retval(2) = atoi (retval(2).string_value ().c_str ());
                 }
             }
           else
             {
               // Multiple files.
-              nel = items_lst.size ();
+              nel = items_lst.size () - 2;
               Cell items (dim_vector (1, nel));
 
               std::list<std::string>::iterator it = items_lst.begin ();
 
-              for (unsigned int idx = 0; idx < items_lst.size ()-2; idx++)
+              for (int idx = 0; idx < nel; idx++)
                 {
                   items.xelem (idx) = *it;
                   it++;
                 }
 
               retval(0) = items;
               retval(1) = *it++;
               retval(2) = atoi (it->c_str ());
@@ -397,8 +397,41 @@ Undocumented internal function.\n\
           retval = items;
         }
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
+
+DEFUN (__octave_link_show_preferences__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __octave_link_show_preferences__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  retval = octave_link::show_preferences ();
+
+  return retval;
+}
+
+DEFUN (__octave_link_show_doc__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __octave_link_show_doc__ ( @var{filename} )\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+  std::string file;
+
+  if (args.length () >= 1)
+    file = args(0).string_value();
+
+  retval = octave_link::show_doc (file);
+
+  return retval;
+}
+
+
+
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -302,16 +302,41 @@ public:
       instance->do_set_default_prompts (ps1, ps2, ps4);
   }
 
   static bool enabled (void)
   {
     return instance_ok () ? instance->link_enabled : false;
   }
 
+  static bool
+  show_preferences ()
+  {
+    if (enabled ())
+      { 
+        instance->do_show_preferences ();
+        return true;
+      }
+    else
+      return false;
+  }
+
+  static bool 
+  show_doc (const std::string & file)
+  {
+    if (enabled ())
+      { 
+        instance->do_show_doc (file);
+        return true;
+      }
+    else
+      return false;
+ 
+  }
+
 private:
 
   static octave_link *instance;
 
   // No copying!
 
   octave_link (const octave_link&);
 
@@ -420,11 +445,15 @@ protected:
 
   virtual void do_exit_debugger_event (void) = 0;
 
   virtual void do_update_breakpoint (bool insert,
                                      const std::string& file, int line) = 0;
 
   virtual void do_set_default_prompts (std::string& ps1, std::string& ps2,
                                        std::string& ps4) = 0;
+
+  virtual void do_show_preferences (void) = 0;
+
+  virtual void do_show_doc (const std::string &file) = 0;
 };
 
 #endif // OCTAVELINK_H
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -509,33 +509,39 @@ open_diary_file (void)
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file '%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Command} {} diary options\n\
+@deftypefn  {Command} {} diary\n\
+@deftypefnx {Command} {} diary on\n\
+@deftypefnx {Command} {} diary off\n\
+@deftypefnx {Command} {} diary @var{filename}\n\
 Record a list of all commands @emph{and} the output they produce, mixed\n\
-together just as you see them on your terminal.  Valid options are:\n\
+together just as they appear on the terminal.\n\
 \n\
-@table @code\n\
+Valid options are:\n\
+\n\
+@table @asis\n\
 @item on\n\
-Start recording your session in a file called @file{diary} in your\n\
+Start recording a session in a file called @file{diary} in the\n\
 current working directory.\n\
 \n\
 @item off\n\
-Stop recording your session in the diary file.\n\
+Stop recording the session in the diary file.\n\
 \n\
-@item @var{file}\n\
-Record your session in the file named @var{file}.\n\
+@item @var{filename}\n\
+Record the session in the file named @var{filename}.\n\
 @end table\n\
 \n\
 With no arguments, @code{diary} toggles the current diary state.\n\
+@seealso{history}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("diary");
 
@@ -643,19 +649,19 @@ DEFUN (page_output_immediately, args, na
 @deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{page_screen_output, more, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
 DEFUN (page_screen_output, args, nargout,
   "-*- texinfo -*-\n\
@@ -663,53 +669,53 @@ DEFUN (page_screen_output, args, nargout
 @deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} page_screen_output (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether output intended\n\
 for the terminal window that is longer than one page is sent through a\n\
 pager.  This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{more, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
 DEFUN (PAGER, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PAGER (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the program to use\n\
 to display terminal output on your system.  The default value is\n\
-normally @code{\"less\"}, @code{\"more\"}, or\n\
-@code{\"pg\"}, depending on what programs are installed on your system.\n\
+normally @qcode{\"less\"}, @qcode{\"more\"}, or\n\
+@qcode{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{PAGER_FLAGS, page_output_immediately, more, page_screen_output}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 DEFUN (PAGER_FLAGS, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PAGER_FLAGS (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options to pass\n\
 to the pager.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{PAGER, more, page_screen_output, page_output_immediately}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER_FLAGS);
 }
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -167,22 +167,22 @@ where @code{sigma_max (@var{x})} is the 
         }
     }
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
-%! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
+%! a = reshape (rand*[1:16], 4, 4);  # Rank 2 matrix
 %! b = pinv (a);
 %! tol = 4e-14;
 %! hitol = 40*sqrt (eps);
 %! d = diag ([rand, rand, hitol, hitol]);
-%! u = rand (4);                      ## Could be singular by freak accident
+%! u = rand (4);                     # Could be singular by freak accident
 %! x = inv (u)*d*u;
 %! y = pinv (x, sqrt (eps));
 %!
 %!assert (a*b*a, a, tol)
 %!assert (b*a*b, b, tol)
 %!assert ((b*a)', b*a, tol)
 %!assert ((a*b)', a*b, tol)
 %!assert (x*y*x, x, -hitol)
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -488,17 +488,17 @@ pr_max_internal (const Matrix& m)
   double result = -std::numeric_limits<double>::max ();
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         double val = m(i,j);
-        if (xisinf (val) || xisnan (val))
+        if (! xfinite (val))
           continue;
 
         all_inf_or_nan = false;
 
         if (val > result)
           result = val;
       }
 
@@ -517,17 +517,17 @@ pr_min_internal (const Matrix& m)
   double result = std::numeric_limits<double>::max ();
 
   bool all_inf_or_nan = true;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         double val = m(i,j);
-        if (xisinf (val) || xisnan (val))
+        if (xfinite (val))
           continue;
 
         all_inf_or_nan = false;
 
         if (val < result)
           result = val;
       }
 
@@ -993,21 +993,19 @@ set_format (const Complex& c, int& r_fw,
 
   bool inf_or_nan = (xisinf (c) || xisnan (c));
 
   bool int_only = (D_NINT (rp) == rp && D_NINT (ip) == ip);
 
   double r_abs = rp < 0.0 ? -rp : rp;
   double i_abs = ip < 0.0 ? -ip : ip;
 
-  int r_x = (xisinf (rp) || xisnan (rp) || r_abs == 0.0)
-    ? 0 : num_digits (r_abs);
-
-  int i_x = (xisinf (ip) || xisnan (ip) || i_abs == 0.0)
-    ? 0 : num_digits (i_abs);
+  int r_x = (! xfinite (rp) || r_abs == 0.0) ? 0 : num_digits (r_abs);
+
+  int i_x = (! xfinite (ip) || i_abs == 0.0) ? 0 : num_digits (i_abs);
 
   int x_max, x_min;
 
   if (r_x > i_x)
     {
       x_max = r_x;
       x_min = i_x;
     }
@@ -1456,35 +1454,30 @@ pr_any_float (const float_format *fmt, s
       if (hex_format)
         {
           equiv tmp;
           tmp.d = d;
 
           // Unless explicitly asked for, always print in big-endian
           // format.
 
-          // FIXME -- is it correct to swap bytes for VAX
-          // formats and not for Cray?
-
           // FIXME -- will bad things happen if we are
           // interrupted before resetting the format flags and fill
           // character?
 
           oct_mach_info::float_format flt_fmt =
             oct_mach_info::native_float_format ();
 
           char ofill = os.fill ('0');
 
           std::ios::fmtflags oflags
             = os.flags (std::ios::right | std::ios::hex);
 
           if (hex_format > 1
-              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
-              || flt_fmt == oct_mach_info::flt_fmt_cray
-              || flt_fmt == oct_mach_info::flt_fmt_unknown)
+              || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian)
             {
               for (size_t i = 0; i < sizeof (double); i++)
                 os << std::setw (2) << static_cast<int> (tmp.i[i]);
             }
           else
             {
               for (int i = sizeof (double) - 1; i >= 0; i--)
                 os << std::setw (2) << static_cast<int> (tmp.i[i]);
@@ -1493,25 +1486,20 @@ pr_any_float (const float_format *fmt, s
           os.fill (ofill);
           os.setf (oflags);
         }
       else if (bit_format)
         {
           equiv tmp;
           tmp.d = d;
 
-          // FIXME -- is it correct to swap bytes for VAX
-          // formats and not for Cray?
-
           oct_mach_info::float_format flt_fmt =
             oct_mach_info::native_float_format ();
 
-          if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian
-              || flt_fmt == oct_mach_info::flt_fmt_cray
-              || flt_fmt == oct_mach_info::flt_fmt_unknown)
+          if (flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian)
             {
               for (size_t i = 0; i < sizeof (double); i++)
                 PRINT_CHAR_BITS (os, tmp.i[i]);
             }
           else
             {
               if (bit_format > 1)
                 {
@@ -3800,32 +3788,32 @@ it switches to an exponential @samp{e} f
 @item long\n\
 Fixed point format with 15 significant figures in a field that is a maximum\n\
 of 20 characters wide.\n\
 \n\
 As with the @samp{short} format, Octave will switch to an exponential\n\
 @samp{e} format if it is unable to format a matrix properly using the\n\
 current format.\n\
 \n\
-@item short e\n\
+@item  short e\n\
 @itemx long e\n\
 Exponential format.  The number to be represented is split between a mantissa\n\
 and an exponent (power of 10).  The mantissa has 5 significant digits in the\n\
 short format and 15 digits in the long format.\n\
 For example, with the @samp{short e} format, @code{pi} is displayed as\n\
 @code{3.1416e+00}.\n\
 \n\
-@item short E\n\
+@item  short E\n\
 @itemx long E\n\
 Identical to @samp{short e} or @samp{long e} but displays an uppercase\n\
 @samp{E} to indicate the exponent.\n\
 For example, with the @samp{long E} format, @code{pi} is displayed as\n\
 @code{3.14159265358979E+00}.\n\
 \n\
-@item short g\n\
+@item  short g\n\
 @itemx long g\n\
 Optimally choose between fixed point and exponential format based on\n\
 the magnitude of the number.\n\
 For example, with the @samp{short g} format,\n\
 @code{pi .^ [2; 4; 8; 16; 32]} is displayed as\n\
 \n\
 @example\n\
 @group\n\
@@ -3834,29 +3822,29 @@ ans =\n\
       9.8696\n\
       97.409\n\
       9488.5\n\
   9.0032e+07\n\
   8.1058e+15\n\
 @end group\n\
 @end example\n\
 \n\
-@item short eng\n\
+@item  short eng\n\
 @itemx long eng\n\
 Identical to @samp{short e} or @samp{long e} but displays the value\n\
 using an engineering format, where the exponent is divisible by 3. For\n\
 example, with the @samp{short eng} format, @code{10 * pi} is displayed as\n\
 @code{31.4159e+00}.\n\
 \n\
-@item long G\n\
+@item  long G\n\
 @itemx short G\n\
 Identical to @samp{short g} or @samp{long g} but displays an uppercase\n\
 @samp{E} to indicate the exponent.\n\
 \n\
-@item free\n\
+@item  free\n\
 @itemx none\n\
 Print output in free format, without trying to line up columns of\n\
 matrices on the decimal point.  This also causes complex numbers to be\n\
 formatted as numeric pairs like this @samp{(0.60419, 0.60709)} instead\n\
 of like this @samp{0.60419 + 0.60709i}.\n\
 @end table\n\
 \n\
 The following formats affect all numeric output (floating point and\n\
@@ -3979,19 +3967,19 @@ ans =\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Notice that first value appears to be zero when it is actually 1.  For\n\
 this reason, you should be careful when setting\n\
 @code{fixed_point_format} to a nonzero value.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{format, output_max_field_width, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
   "-*- texinfo -*-\n\
@@ -4008,19 +3996,19 @@ zeros (3, 0)\n\
 \n\
 @noindent\n\
 will print\n\
 \n\
 @example\n\
 ans = [](3x0)\n\
 @end example\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_empty_dimensions);
 }
 
 DEFUN (split_long_rows, args, nargout,
   "-*- texinfo -*-\n\
@@ -4046,52 +4034,52 @@ ans =\n\
 \n\
  Columns 7 through 10:\n\
 \n\
   0.90174  0.11854  0.72313  0.73326\n\
   0.44672  0.94303  0.56564  0.82150\n\
 @end group\n\
 @end example\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (split_long_rows);
 }
 
 DEFUN (output_max_field_width, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_max_field_width ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} output_max_field_width (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum width\n\
 of a numeric output field.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (output_precision, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} output_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{format, fixed_point_format, output_max_field_width}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_precision, -1,
                                             std::numeric_limits<int>::max ());
 }
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -39,29 +39,53 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 #ifdef HAVE_LLVM
 
 static bool Vdebug_jit = false;
 
 static bool Vjit_enable = true;
 
+static int Vjit_startcnt = 1000;
+
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/Bitcode/ReaderWriter.h>
-#include <llvm/LLVMContext.h>
 #include <llvm/ExecutionEngine/ExecutionEngine.h>
 #include <llvm/ExecutionEngine/JIT.h>
+#include <llvm/PassManager.h>
+
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Module.h>
+#else
+#include <llvm/LLVMContext.h>
 #include <llvm/Module.h>
-#include <llvm/PassManager.h>
+#endif
+
+#ifdef HAVE_LLVM_SUPPORT_IRBUILDER_H
 #include <llvm/Support/IRBuilder.h>
+#elif defined(HAVE_LLVM_IR_IRBUILDER_H)
+#include <llvm/IR/IRBuilder.h>
+#else
+#include <llvm/IRBuilder.h>
+#endif
+
 #include <llvm/Support/raw_os_ostream.h>
 #include <llvm/Support/TargetSelect.h>
+
+#ifdef HAVE_LLVM_IR_DATALAYOUT_H
+#include <llvm/IR/DataLayout.h>
+#elif defined(HAVE_LLVM_DATALAYOUT_H)
+#include <llvm/DataLayout.h>
+#else
 #include <llvm/Target/TargetData.h>
+#endif
+
 #include <llvm/Transforms/IPO.h>
 #include <llvm/Transforms/Scalar.h>
 
 static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
 // -------------------- jit_break_exception --------------------
@@ -1863,17 +1887,21 @@ tree_jit::initialize (void)
 
   if (! engine)
     return false;
 
   module_pass_manager = new llvm::PassManager ();
   module_pass_manager->add (llvm::createAlwaysInlinerPass ());
 
   pass_manager = new llvm::FunctionPassManager (module);
-  pass_manager->add (new llvm::TargetData(*engine->getTargetData ()));
+#ifdef HAVE_LLVM_DATALAYOUT
+  pass_manager->add (new llvm::DataLayout (*engine->getDataLayout ()));
+#else
+  pass_manager->add (new llvm::TargetData (*engine->getTargetData ()));
+#endif
   pass_manager->add (llvm::createCFGSimplificationPass ());
   pass_manager->add (llvm::createBasicAliasAnalysisPass ());
   pass_manager->add (llvm::createPromoteMemoryToRegisterPass ());
   pass_manager->add (llvm::createInstructionCombiningPass ());
   pass_manager->add (llvm::createReassociatePass ());
   pass_manager->add (llvm::createGVNPass ());
   pass_manager->add (llvm::createCFGSimplificationPass ());
   pass_manager->doInitialization ();
@@ -1881,29 +1909,27 @@ tree_jit::initialize (void)
   jit_typeinfo::initialize (module, engine);
 
   return true;
 }
 
 bool
 tree_jit::do_execute (tree_simple_for_command& cmd, const octave_value& bounds)
 {
-  const size_t MIN_TRIP_COUNT = 1000;
-
   size_t tc = trip_count (bounds);
   if (! tc || ! initialize () || ! enabled ())
     return false;
 
   jit_info::vmap extra_vars;
   extra_vars["#for_bounds0"] = &bounds;
 
   jit_info *info = cmd.get_info ();
   if (! info || ! info->match (extra_vars))
     {
-      if (tc < MIN_TRIP_COUNT)
+      if (tc < static_cast<size_t> (Vjit_startcnt))
         return false;
 
       delete info;
       info = new jit_info (*this, cmd, bounds);
       cmd.stash_info (info);
     }
 
   return info->execute (extra_vars);
@@ -2291,20 +2317,20 @@ jit_info::find (const vmap& extra_vars, 
 DEFUN (debug_jit, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_jit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_jit (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_jit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether\n\
 debugging/tracing is enabled for Octave's JIT compiler.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
-@seealso{jit_enable}\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+@seealso{jit_enable, jit_startcnt}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE (debug_jit);
 #else
   warning ("debug_jit: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
@@ -2312,388 +2338,46 @@ variable value is restored when exiting 
 
 DEFUN (jit_enable, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} jit_enable ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} jit_enable (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} jit_enable (@var{new_val}, \"local\")\n\
 Query or set the internal variable that enables Octave's JIT compiler.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
-@seealso{debug_jit}\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+@seealso{jit_startcnt, debug_jit}\n\
 @end deftypefn")
 {
 #if defined (HAVE_LLVM)
   return SET_INTERNAL_VARIABLE (jit_enable);
 #else
   warning ("jit_enable: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
-/*
-Test some simple cases that compile.
-
-%!test
-%! for i=1:1e6
-%!   if i < 5
-%!     break
-%!   else
-%!     break
-%!   endif
-%! endfor
-%! assert (i, 1);
-
-%!test
-%! while 1
-%!   if 1
-%!     break
-%!  else
-%!    break
-%!  endif
-%! endwhile
-
-%!test
-%! for i=1:1e6
-%!   if i == 100
-%!     break
-%!   endif
-%! endfor
-%! assert (i, 100);
-
-%!test
-%! inc = 1e-5;
-%! result = 0;
-%! for ii = 0:inc:1
-%!   result = result + inc * (1/3 * ii * ii);
-%! endfor
-%! assert (abs (result - 1/9) < 1e-5);
-
-%!test
-%! inc = 1e-5;
-%! result = 0;
-%! for ii = 0:inc:1
-%!   # the ^ operator's result is complex
-%!   result = result + inc * (1/3 * ii ^ 2);
-%! endfor
-%! assert (abs (result - 1/9) < 1e-5);
-
-%!test
-%! temp = 1+1i;
-%! nan = NaN;
-%! while 1
-%!   temp = temp - 1i;
-%!   temp = temp * nan;
-%!   break;
-%! endwhile
-%! assert (imag (temp), 0);
-
-%!test
-%! temp = 1+1i;
-%! nan = NaN+1i;
-%! while 1
-%!   nan = nan - 1i;
-%!   temp = temp - 1i;
-%!   temp = temp * nan;
-%!   break;
-%! endwhile
-%! assert (imag (temp), 0);
-
-%!test
-%! temp = 1+1i;
-%! while 1
-%!   temp = temp * 5;
-%!   break;
-%! endwhile
-%! assert (temp, 5+5i);
-
-%!test
-%! nr = 1001;
-%! mat = zeros (1, nr);
-%! for i = 1:nr
-%!   mat(i) = i;
-%! endfor
-%! assert (mat == 1:nr);
-
-%!test
-%! nr = 1001;
-%! mat = 1:nr;
-%! mat(end) = 0; # force mat to a matrix
-%! total = 0;
-%! for i = 1:nr
-%!   total = mat(i) + total;
-%! endfor
-%! assert (sum (mat) == total);
-
-%!test
-%! nr = 1001;
-%! mat = [3 1 5];
-%! try
-%!   for i = 1:nr
-%!     if i > 500
-%!       result = mat(100);
-%!     else
-%!       result = i;
-%!     endif
-%!   endfor
-%! catch
-%! end
-%! assert (result == 500);
-
-%!function result = gen_test (n)
-%!  result = double (rand (1, n) > .01);
-%!endfunction
-
-%!function z = vectorized (A, K)
-%!  temp = ones (1, K);
-%!  z = conv (A, temp);
-%!  z = z > K-1;
-%!  z = conv (z, temp);
-%!  z = z(K:end-K+1);
-%!  z = z >= 1;
-%!endfunction
-
-%!function z = loopy (A, K)
-%!  z = A;
-%!  n = numel (A);
-%!  counter = 0;
-%!  for ii=1:n
-%!    if z(ii)
-%!      counter = counter + 1;
-%!    else
-%!      if counter > 0 && counter < K
-%!        z(ii-counter:ii-1) = 0;
-%!      endif
-%!      counter = 0;
-%!    endif
-%!  endfor
-%!
-%!  if counter > 0 && counter < K
-%!    z(end-counter+1:end) = 0;
-%!  endif
-%!endfunction
-
-%!test
-%! test_set = gen_test (10000);
-%! assert (all (vectorized (test_set, 3) == loopy (test_set, 3)));
-
-%!test
-%! niter = 1001;
-%! i = 0;
-%! while (i < niter)
-%!   i = i + 1;
-%! endwhile
-%! assert (i == niter);
-
-%!test
-%! niter = 1001;
-%! result = 0;
-%! m = [5 10];
-%! for i=1:niter
-%!   result = result + m(end);
-%! endfor
-%! assert (result == m(end) * niter);
-
-%!test
-%! ndim = 100;
-%! result = 0;
-%! m = zeros (ndim);
-%! m(:) = 1:ndim^2;
-%! i = 1;
-%! while (i <= ndim)
-%!   for j = 1:ndim
-%!     result = result + m(i, j);
-%!    endfor
-%!   i = i + 1;
-%! endwhile
-%! assert (result == sum (sum (m)));
-
-%!test
-%! ndim = 100;
-%! m = zeros (ndim);
-%! i = 1;
-%! while (i <= ndim)
-%!   for j = 1:ndim
-%!     m(i, j) = (j - 1) * ndim + i;
-%!   endfor
-%!   i = i + 1;
-%! endwhile
-%! m2 = zeros (ndim);
-%! m2(:) = 1:(ndim^2);
-%! assert (all (m == m2));
-
-%!test
-%! ndim = 2;
-%! m = zeros (ndim, ndim, ndim, ndim);
-%! result = 0;
-%! i0 = 1;
-%! while (i0 <= ndim)
-%!   for i1 = 1:ndim
-%!     for i2 = 1:ndim
-%!       for i3 = 1:ndim
-%!         m(i0, i1, i2, i3) = 1;
-%!         m(i0, i1, i2, i3, 1, 1, 1, 1, 1, 1) = 1;
-%!         result = result + m(i0, i1, i2, i3);
-%!       endfor
-%!     endfor
-%!   endfor
-%!   i0 = i0 + 1;
-%! endwhile
-%! expected = ones (ndim, ndim, ndim, ndim);
-%! assert (all (m == expected));
-%! assert (result == sum (expected (:)));
-
-%!function test_divide ()
-%! state = warning ("query", "Octave:divide-by-zero").state;
-%! unwind_protect
-%!   warning ("error", "Octave:divide-by-zero");
-%!   for i=1:1e5
-%!     a = 1;
-%!     a / 0;
-%!   endfor
-%! unwind_protect_cleanup
-%!   warning (state, "Octave:divide-by-zero");
-%! end_unwind_protect
-%!endfunction
-
-%!error <division by zero> test_divide ()
-
-%!test
-%! while 1
-%!   a = 0;
-%!   result = a / 1;
-%!   break;
-%! endwhile
-%! assert (result, 0);
-
-%!test
-%! m = zeros (2, 1001);
-%! for i=1:1001
-%!   m(end, i) = i;
-%!   m(end - 1, end - i + 1) = i;
-%! endfor
-%! m2 = zeros (2, 1001);
-%! m2(1, :) = fliplr (1:1001);
-%! m2(2, :) = 1:1001;
-%! assert (m, m2);
-
-%!test
-%! m = [1 2 3];
-%! for i=1:1001
-%!   m = sin (m);
-%!   break;
-%! endfor
-%! assert (m == sin ([1  2 3]));
-
-%!test
-%! i = 0;
-%! while i < 10
-%!   i += 1;
-%! endwhile
-%! assert (i == 10);
-
-%!test
-%! i = 0;
-%! while i < 10
-%!   a = ++i;
-%! endwhile
-%! assert (i == 10);
-%! assert (a == 10);
-%!test
-%! i = 0;
-%! while i < 10
-%!   a = i++;
-%! endwhile
-%! assert (i == 10);
-%! assert (a == 9);
-
-%!test
-%! num = 2;
-%! a = zeros (1, num);
-%! i = 1;
-%! while i <= num
-%!   a(i) = norm (eye (i));
-%!   ++i;
-%! endwhile
-%! assert (a, ones (1, num));
-
-%!function test_compute_idom ()
-%! while (li <= length (l1) && si <= length (s1))
-%!   if (l1 (li) < s1 (si))
-%!     if (li == si)
-%!       break;
-%!     endif;
-%!     li++;
-%!   else
-%!     si++;
-%!   endif;
-%! endwhile
-
-%!error test_compute_idom ()
-
-%!function x = test_overload (a)
-%!  while 1
-%!    x = a;
-%!    break;
-%!  endwhile
-%!endfunction
-
-%!assert (test_overload (1), 1);
-%!assert (test_overload ([1 2]), [1 2]);
-
-%!function a = bubble (a = [3 2 1])
-%!  swapped = 1;
-%!  n = length (a);
-%!  while (swapped)
-%!    swapped = 0;
-%!    for i = 1:n-1
-%!      if a(i) > a(i + 1)
-%!        swapped = 1;
-%!        temp = a(i);
-%!        a(i) = a(i + 1);
-%!        a(i + 1) = temp;
-%!      endif
-%!    endfor
-%!  endwhile
-%!endfunction
-
-%!assert (bubble (), [1 2 3]);
-
-%!test
-%! a = 0;
-%! b = 1;
-%! for i=1:1e3
-%!   for j=1:2
-%!     a = a + b;
-%!   endfor
-%! endfor
-%! assert (a, 2000);
-%! assert (b, 1);
-
-%!test
-%! a = [1+1i 1+2i];
-%! b = 0;
-%! while 1
-%!   b = a(1);
-%!   break;
-%! endwhile
-%! assert (b, a(1));
-
-%!function test_undef ()
-%!  for i=1:1e7
-%!    XXX;
-%!  endfor
-%!endfunction
-
-%!error <undefined near> (test_undef);
-
-%!shared id
-%! id = @(x) x;
-
-%!assert (id (1), 1);
-%!assert (id (1+1i), 1+1i)
-%!assert (id (1, 2), 1)
-%!error <undefined> (id ())
-
-
-*/
+DEFUN (jit_startcnt, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} jit_startcnt ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} jit_startcnt (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} jit_startcnt (@var{new_val}, \"local\")\n\
+Query or set the internal variable that determines whether JIT compilation\n\
+will take place for a specific loop.  Because compilation is a costly\n\
+operation it does not make sense to employ JIT when the loop count is low.\n\
+By default only loops with greater than 1000 iterations will be accelerated.\n\
+\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+@seealso{jit_enable, debug_jit}\n\
+@end deftypefn")
+{
+#if defined (HAVE_LLVM)
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS (jit_startcnt, 1,
+                                            std::numeric_limits<int>::max ());
+#else
+  warning ("jit_enable: JIT compiling not available in this version of Octave");
+  return octave_value ();
+#endif
+}
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -341,40 +341,40 @@ the generalized eigenvectors @var{V}, @v
 @var{Q}.\n\
 \n\
 @table @var\n\
 @item opt\n\
 for ordering eigenvalues of the @nospell{GEP} pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
 \n\
 @table @asis\n\
-@item \"N\"\n\
+@item @qcode{\"N\"}\n\
 = unordered (default)\n\
 \n\
-@item \"S\"\n\
+@item @qcode{\"S\"}\n\
 = small: leading block has all |lambda| @leq{} 1\n\
 \n\
-@item \"B\"\n\
+@item @qcode{\"B\"}\n\
 = big: leading block has all |lambda| @geq{} 1\n\
 \n\
-@item \"-\"\n\
+@item @qcode{\"-\"}\n\
 = negative real part: leading block has all eigenvalues\n\
 in the open left half-plane\n\
 \n\
-@item \"+\"\n\
+@item @qcode{\"+\"}\n\
 = non-negative real part: leading block has all eigenvalues\n\
 in the closed right half-plane\n\
 @end table\n\
 @end table\n\
 @end enumerate\n\
 \n\
 Note: @code{qz} performs permutation balancing, but not scaling\n\
-(@pxref{docXbalance}).  The order of output arguments was selected for\n\
+(@pxref{XREFbalance}).  The order of output arguments was selected for\n\
 compatibility with @sc{matlab}.\n\
-@seealso{balance, eig, schur}\n\
+@seealso{eig, balance, lu, chol, hess, qr, qzhess, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
 #ifdef DEBUG
   std::cout << "qz: nargin = " << nargin << ", nargout = " << nargout << std::endl;
 #endif
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
 %!shared __random_statistical_tests__
-%! # Flag whether the statistical tests should be run in "make check" or not
+%! ## Flag whether the statistical tests should be run in "make check" or not
 %! __random_statistical_tests__ = 0;
 */
 
 static octave_value
 do_rand (const octave_value_list& args, int nargin, const char *fcn,
          const std::string& distribution, bool additional_arg = false)
 {
   octave_value retval;
@@ -419,17 +419,17 @@ several returned values together, otherw
 can be learned after reading 624 consecutive values.\n\
 \n\
 Older versions of Octave used a different random number generator.\n\
 The new generator is used by default\n\
 as it is significantly faster than the old generator, and produces\n\
 random numbers with a significantly longer cycle time.  However, in\n\
 some circumstances it might be desirable to obtain the same random\n\
 sequences as used by the old generators.  To do this the keyword\n\
-\"seed\" is used to specify that the old generators should be use,\n\
+@qcode{\"seed\"} is used to specify that the old generators should be use,\n\
 as in\n\
 \n\
 @example\n\
 rand (\"seed\", val)\n\
 @end example\n\
 \n\
 @noindent\n\
 which sets the seed of the generator to @var{val}.  The seed of the\n\
@@ -437,23 +437,25 @@ generator can be queried with\n\
 \n\
 @example\n\
 s = rand (\"seed\")\n\
 @end example\n\
 \n\
 However, it should be noted that querying the seed will not cause\n\
 @code{rand} to use the old generators, only setting the seed will.\n\
 To cause @code{rand} to once again use the new generators, the\n\
-keyword \"state\" should be used to reset the state of the @code{rand}.\n\
+keyword @qcode{\"state\"} should be used to reset the state of the\n\
+@code{rand}.\n\
 \n\
 The state or seed of the generator can be reset to a new random value\n\
-using the \"reset\" keyword.\n\
+using the @qcode{\"reset\"} keyword.\n\
 \n\
-The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument.  These are the only valid classes.\n\
+The class of the value returned can be controlled by a trailing\n\
+@qcode{\"double\"} or @qcode{\"single\"} argument.  These are the only valid\n\
+classes.\n\
 @seealso{randn, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   retval = do_rand (args, nargin, "rand", "uniform");
@@ -495,49 +497,62 @@ or \"single\" argument.  These are the o
 %! s = rand ("seed");  y = rand (1,2);
 %! assert (x, y);
 %! rand ("seed", s);  z = rand (1,2);
 %! assert (x, z);
 */
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! rand ("state", 1);
 %! assert (rand (1,6), [0.1343642441124013 0.8474337369372327 0.763774618976614 0.2550690257394218 0.495435087091941 0.4494910647887382], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! rand ("seed", 1);
 %! assert (rand (1,6), [0.8668024251237512 0.9126510815694928 0.09366085007786751 0.1664607301354408 0.7408077004365623 0.7615650338120759], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   rand ("state", 12);
 %!   x = rand (100000, 1);
 %!   assert (max (x) < 1);   #*** Please report this!!! ***
 %!   assert (min (x) > 0);   #*** Please report this!!! ***
 %!   assert (mean (x), 0.5, 0.0024);
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   rand ("seed", 12);
 %!   x = rand (100000, 1);
 %!   assert (max (x) < 1);   #*** Please report this!!! ***
 %!   assert (min (x) > 0);   #*** Please report this!!! ***
 %!   assert (mean (x), 0.5, 0.0024);
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 */
 
+/*
+%!# Test out-of-range values as rand() seeds.  See oct-rand.cc: double2uint32().
+%!function v = __rand_sample__ (initval)
+%!  rand ("state", initval);
+%!  v = rand (1, 6);
+%!endfunction
+%!
+%!assert (__rand_sample__ (0), __rand_sample__ (2^32))
+%!assert (__rand_sample__ (-2), __rand_sample__ (2^32-2))
+%!assert (__rand_sample__ (Inf), __rand_sample__ (NaN))
+%!assert (! isequal (__rand_sample__ (-1), __rand_sample__ (-2)))
+*/
+
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN (randn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randn (@var{n})\n\
 @deftypefnx {Built-in Function} {} randn (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} randn ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
@@ -550,18 +565,19 @@ DEFUN (randn, args, ,
 @deftypefnx {Built-in Function} {} randn (@dots{}, \"double\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
-The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument.  These are the only valid classes.\n\
+The class of the value returned can be controlled by a trailing\n\
+@qcode{\"double\"} or @qcode{\"single\"} argument.  These are the only valid\n\
+classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
@@ -572,36 +588,36 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "randn", "normal");
 
   return retval;
 }
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randn ("state", 1);
 %! assert (randn (1, 6), [-2.666521678978671 -0.7381719971724564 1.507903992673601 0.6019427189162239 -0.450661261143348 -0.7054431351574116], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randn ("seed", 1);
 %! assert (randn (1, 6), [-1.039402365684509 -1.25938892364502 0.1968704611063004 0.3874166905879974 -0.5976632833480835 -0.6615074276924133], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randn ("state", 12);
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randn ("seed", 12);
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
@@ -620,18 +636,19 @@ DEFUN (rande, args, ,
 @deftypefnx {Built-in Function} {} rande (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to an exponential distribution.\n\
 \n\
-The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument.  These are the only valid classes.\n\
+The class of the value returned can be controlled by a trailing\n\
+@qcode{\"double\"} or @qcode{\"single\"} argument.  These are the only valid\n\
+classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
@@ -642,37 +659,37 @@ J. Statistical Software, vol 5, 2000,\n\
 
   retval = do_rand (args, nargin, "rande", "exponential");
 
   return retval;
 }
 
 /*
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! rande ("state", 1);
 %! assert (rande (1, 6), [3.602973885835625 0.1386190677555021 0.6743112889616958 0.4512830847258422 0.7255744741233175 0.3415969205292291], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! rande ("seed", 1);
 %! assert (rande (1, 6), [0.06492075175653866 1.717980206012726 0.4816154008731246 0.5231300676241517 0.103910739364359 1.668931916356087], 1e-6);
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally
+%!   ## statistical tests may fail occasionally
 %!   rande ("state", 1);
 %!   x = rande (100000, 1);
 %!   assert (min (x) > 0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally
+%!   ## statistical tests may fail occasionally
 %!   rande ("seed", 1);
 %!   x = rande (100000, 1);
 %!   assert (min (x)>0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
@@ -766,18 +783,19 @@ r(df > 0) += 2 * randg (df(df > 0)/2)\n\
 @group\n\
 r = (randg (a1), @dots{}, randg (ak))\n\
 r = r / sum (r)\n\
 @end group\n\
 @end example\n\
 \n\
 @end table\n\
 \n\
-The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument.  These are the only valid classes.\n\
+The class of the value returned can be controlled by a trailing\n\
+@qcode{\"double\"} or @qcode{\"single\"} argument.  These are the only valid\n\
+classes.\n\
 @seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -789,161 +807,161 @@ or \"single\" argument.  These are the o
 }
 
 /*
 %!test
 %! randg ("state", 12)
 %! assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]); # *** Please report
 
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (0.1, 1, 6), [0.0103951513331241 8.335671459898252e-05 0.00138691397249762 0.000587308416993855 0.495590518784736 2.3921917414795e-12], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (0.95, 1, 6), [3.099382433255327 0.3974529788871218 0.644367450750855 1.143261091802246 1.964111762696822 0.04011915547957939], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (1, 1, 6), [0.2273389379645993 1.288822625058359 0.2406335209340746 1.218869553370733 1.024649860162554 0.09631230343599533], 1e-6);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (10, 1, 6), [3.520369644331133 15.15369864472106 8.332112081991205 8.406211067432674 11.81193475187611 10.88792728177059], 1e-5);
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randg ("state", 1);
 %! assert (randg (100, 1, 6), [75.34570255262264 115.4911985594699 95.23493031356388 95.48926019250911 106.2397448229803 103.4813150404118], 1e-4);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (0.1, 1, 6), [0.07144210487604141 0.460641473531723 0.4749028384685516 0.06823389977216721 0.000293838675133884 1.802567535340305e-12], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (0.95, 1, 6), [1.664905071258545 1.879976987838745 1.905677795410156 0.9948706030845642 0.5606933236122131 0.0766092911362648], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (1, 1, 6), [0.03512085229158401 0.6488978862762451 0.8114678859710693 0.1666885763406754 1.60791552066803 1.90356981754303], 1e-6);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (10, 1, 6), [6.566435813903809 10.11648464202881 10.73162078857422 7.747178077697754 6.278522491455078 6.240195751190186], 1e-5);
 %!test
-%! # Test fixed seed
+%! ## Test fixed seed
 %! randg ("seed", 1);
 %! assert (randg (100, 1, 6), [89.40208435058594 101.4734725952148 103.4020004272461 93.62763214111328 88.33104705810547 88.1871337890625], 1e-4);
 
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 0.1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.01);
 %!   assert (skewness (x), 2/sqrt (a), 1);
 %!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 0.95;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 10;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.1);
 %!   assert (var (x),      a,          0.5);
 %!   assert (skewness (x), 2/sqrt (a), 0.1);
 %!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("state", 12);
 %!   a = 100;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 %!test
 %! randg ("seed", 12);
 %!assert (randg ([-inf, -1, 0, inf, nan]), [nan, nan, nan, nan, nan]) # *** Please report
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 0.1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.01);
 %!   assert (skewness (x), 2/sqrt (a), 1);
 %!   assert (kurtosis (x), 6/a,        50);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 0.95;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 1;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.01);
 %!   assert (var (x),      a,          0.04);
 %!   assert (skewness (x), 2/sqrt (a), 0.2);
 %!   assert (kurtosis (x), 6/a,        2);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 10;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.1);
 %!   assert (var (x),      a,          0.5);
 %!   assert (skewness (x), 2/sqrt (a), 0.1);
 %!   assert (kurtosis (x), 6/a,        0.5);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randg ("seed", 12);
 %!   a = 100;
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
@@ -988,18 +1006,19 @@ H. Zechner, @cite{Efficient sampling fro
 unimodal distributions}, Doctoral Dissertation, 156pp., Technical\n\
 University Graz, Austria, 1994.\n\
 \n\
 @item For @var{l} > 1e8, use normal approximation.\n\
 L. Montanet, et al., @cite{Review of Particle Properties}, Physical Review\n\
 D 50 p1284, 1994.\n\
 @end table\n\
 \n\
-The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument.  These are the only valid classes.\n\
+The class of the value returned can be controlled by a trailing\n\
+@qcode{\"double\"} or @qcode{\"single\"} argument.  These are the only valid\n\
+classes.\n\
 @seealso{rand, randn, rande, randg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -1010,85 +1029,85 @@ or \"single\" argument.  These are the o
   return retval;
 }
 
 /*
 %!test
 %! randp ("state", 12);
 %! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (5, 1, 6), [5 5 3 7 7 3])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (15, 1, 6), [13 15 8 18 18 15])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("state", 1);
 %! assert (randp (1e9, 1, 6), [999915677 999976657 1000047684 1000019035 999985749 999977692], -1e-6)
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! %%assert (randp (5, 1, 6), [8 2 3 6 6 8])
 %! assert (randp (5, 1, 5), [8 2 3 6 6])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! assert (randp (15, 1, 6), [15 16 12 10 10 12])
 %!test
-%! # Test fixed state
+%! ## Test fixed state
 %! randp ("seed", 1);
 %! assert (randp (1e9, 1, 6), [1000006208 1000012224 999981120 999963520 999963072 999981440], -1e-6)
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("state", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a (1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("state", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1)*ones (100000, 1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! randp ("seed", 12);
 %! assert (randp ([-inf, -1, 0, inf, nan]), [nan, nan, 0, nan, nan]);   # *** Please report
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("seed", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 %!test
 %! if (__random_statistical_tests__)
-%!   # statistical tests may fail occasionally.
+%!   ## statistical tests may fail occasionally.
 %!   randp ("seed", 12);
 %!   for a = [5, 15, 1e9; 0.03, 0.03, -5e-3; 0.03, 0.03, 0.03]
 %!     x = randp (a(1)*ones (100000, 1), 100000, 1);
 %!     assert (min (x) >= 0);   # *** Please report this!!! ***
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <list>
 #include <sstream>
 
 #include <pcre.h>
 
 #include "base-list.h"
 #include "oct-locbuf.h"
 #include "quit.h"
-#include "regexp.h"
+#include "lo-regexp.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "Cell.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-obj.h"
@@ -65,16 +65,23 @@ do_regexp_ptn_string_escapes (const std:
       if (s[j] == '\\' && j+1 < len)
         {
           switch (s[++j])
             {
             case 'b': // backspace
               retval[i] = '\b';
               break;
 
+            // Translate \< and \> to PCRE word boundary
+            case '<': // begin word boundary
+            case '>': // end word boundary
+              retval[i] = '\\';
+              retval[++i] = 'b';
+              break;
+
 #if 0
 // FIXME : To be complete, we need to handle \oN, \o{N}.
 //         The PCRE library already handles \N where N
 //         is an octal number.  New code needs to merely
 //         replace \oN or \o{N} with \N.
             case 'o': // octal number
 #endif
 
@@ -635,49 +642,47 @@ alternatives must be delimited by the gr
 @item ^ $\n\
 Anchoring operators.  Requires pattern to occur at the start (@code{^}) or\n\
 end (@code{$}) of the string.\n\
 @end table\n\
 \n\
 In addition, the following escaped characters have special meaning.\n\
 \n\
 @table @code\n\
-@item \\b\n\
-Match a word boundary\n\
+\n\
+@item \\d\n\
+Match any digit\n\
 \n\
-@item \\B\n\
-Match within a word\n\
+@item \\D\n\
+Match any non-digit\n\
+\n\
+@item \\s\n\
+Match any whitespace character\n\
+\n\
+@item \\S\n\
+Match any non-whitespace character\n\
 \n\
 @item \\w\n\
 Match any word character\n\
 \n\
 @item \\W\n\
 Match any non-word character\n\
 \n\
 @item \\<\n\
 Match the beginning of a word\n\
 \n\
 @item \\>\n\
 Match the end of a word\n\
 \n\
-@item \\s\n\
-Match any whitespace character\n\
-\n\
-@item \\S\n\
-Match any non-whitespace character\n\
-\n\
-@item \\d\n\
-Match any digit\n\
-\n\
-@item \\D\n\
-Match any non-digit\n\
+@item \\B\n\
+Match within a word\n\
 @end table\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, ordinary escape\n\
-sequences (e.g., \"\\n\" => newline) are processed in @var{pat}\n\
+sequences (e.g., @qcode{\"\\n\"} => newline) are processed in @var{pat}\n\
 regardless of whether @var{pat} has been defined within single quotes.  Use\n\
 a second backslash to stop interpolation of the escape sequence (e.g.,\n\
 \"\\\\n\") or use the @code{regexptranslate} function.\n\
 \n\
 The outputs of @code{regexp} default to the order given below\n\
 \n\
 @table @var\n\
 @item s\n\
@@ -707,23 +712,23 @@ split the string based on @var{pat}.\n\
 @end table\n\
 \n\
 Particular output arguments, or the order of the output arguments, can be\n\
 selected by additional @var{opt} arguments.  These are strings and the\n\
 correspondence between the output arguments and the optional argument\n\
 are\n\
 \n\
 @multitable @columnfractions 0.2 0.3 0.3 0.2\n\
-@item @tab 'start'        @tab @var{s}  @tab\n\
-@item @tab 'end'          @tab @var{e}  @tab\n\
-@item @tab 'tokenExtents' @tab @var{te} @tab\n\
-@item @tab 'match'        @tab @var{m}  @tab\n\
-@item @tab 'tokens'       @tab @var{t}  @tab\n\
-@item @tab 'names'        @tab @var{nm} @tab\n\
-@item @tab 'split'        @tab @var{sp} @tab\n\
+@item @tab @qcode{'start'}        @tab @var{s}  @tab\n\
+@item @tab @qcode{'end'}          @tab @var{e}  @tab\n\
+@item @tab @qcode{'tokenExtents'} @tab @var{te} @tab\n\
+@item @tab @qcode{'match'}        @tab @var{m}  @tab\n\
+@item @tab @qcode{'tokens'}       @tab @var{t}  @tab\n\
+@item @tab @qcode{'names'}        @tab @var{nm} @tab\n\
+@item @tab @qcode{'split'}        @tab @var{sp} @tab\n\
 @end multitable\n\
 \n\
 Additional arguments are summarized below.\n\
 \n\
 @table @samp\n\
 @item once\n\
 Return only the first occurrence of the pattern.\n\
 \n\
@@ -772,18 +777,18 @@ the character @samp{#}.\n\
 Alternatively, use (?x) in the pattern.\n\
 \n\
 @item noemptymatch\n\
 Zero-length matches are not returned.  (default)\n\
 \n\
 @item emptymatch\n\
 Return zero-length matches.\n\
 \n\
-@code{regexp ('a', 'b*', 'emptymatch'} returns @code{[1 2]} because there are\n\
-zero or more 'b' characters at positions 1 and end-of-string.\n\
+@code{regexp ('a', 'b*', 'emptymatch')} returns @code{[1 2]} because there\n\
+are zero or more @qcode{'b'} characters at positions 1 and end-of-string.\n\
 \n\
 @end table\n\
 @seealso{regexpi, strfind, regexprep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -915,17 +920,17 @@ zero or more 'b' characters at positions
 %! assert (size (nm), [1, 1]);
 %! assert (nm.first{1}, 'John');
 %! assert (nm.first{2}, 'James');
 %! assert (nm.last{1}, 'Davis');
 %! assert (nm.last{2}, 'Rogers');
 
 ## Tests for named tokens
 %!test
-%! # Parenthesis in named token (ie (int)) causes a problem
+%! ## Parenthesis in named token (ie (int)) causes a problem
 %! assert (regexp ('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
 %!test
 %! ## Mix of named and unnamed tokens can cause segfault (bug #35683)
 %! str = "abcde";
 %! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
 %! tokens = regexp (str, ptn, "names");
 %! assert (isstruct (tokens) && numel (tokens) == 1);
@@ -1062,17 +1067,17 @@ zero or more 'b' characters at positions
 
 DEFUN (regexpi, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Built-in Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Search for @var{pat} in\n\
 @var{str} and return the positions and substrings of any matches, or empty\n\
-values if there are none.  @xref{docXregexp,,regexp}, for details on the\n\
+values if there are none.  @xref{XREFregexp,,regexp}, for details on the\n\
 syntax of the search pattern.\n\
 @seealso{regexp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -1274,17 +1279,17 @@ octregexprep (const octave_value_list &a
 
 DEFUN (regexprep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
 @deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
-@xref{docXregexp,,regexp}.\n\
+@xref{XREFregexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  For example,\n\
 \n\
 @example\n\
 regexprep (\"Bill Dunn\", '(\\w+) (\\w+)', '$2, $1')\n\
 @end example\n\
 \n\
@@ -1299,17 +1304,17 @@ Options in addition to those of @code{re
 Replace only the first occurrence of @var{pat} in the result.\n\
 \n\
 @item warnings\n\
 This option is present for compatibility but is ignored.\n\
 \n\
 @end table\n\
 \n\
 Implementation Note: For compatibility with @sc{matlab}, ordinary escape\n\
-sequences (e.g., \"\\n\" => newline) are processed in both @var{pat}\n\
+sequences (e.g., @qcode{\"\\n\"} => newline) are processed in both @var{pat}\n\
 and @var{repstr} regardless of whether they were defined within single\n\
 quotes.  Use a second backslash to stop interpolation of the escape sequence\n\
 (e.g., \"\\\\n\") or use the @code{regexptranslate} function.\n\
 @seealso{regexp, regexpi, strrep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -102,33 +102,34 @@ along the diagonal.  The diagonal elemen
 $2 \\times 2$\n\
 @end tex\n\
 @ifnottex\n\
 @code{2 x 2}\n\
 @end ifnottex\n\
 blocks, when appropriate) are the eigenvalues of @var{A} and @var{S}.\n\
 \n\
 The default for real matrices is a real Schur@tie{}decomposition.\n\
-A complex decomposition may be forced by passing the flag \"complex\".\n\
+A complex decomposition may be forced by passing the flag\n\
+@qcode{\"complex\"}.\n\
 \n\
 The eigenvalues are optionally ordered along the diagonal according to\n\
 the value of @var{opt}.  @code{@var{opt} = \"a\"} indicates that all\n\
 eigenvalues with negative real parts should be moved to the leading\n\
 block of @var{S}\n\
 (used in @code{are}), @code{@var{opt} = \"d\"} indicates that all eigenvalues\n\
 with magnitude less than one should be moved to the leading block of @var{S}\n\
 (used in @code{dare}), and @code{@var{opt} = \"u\"}, the default, indicates\n\
 that no ordering of eigenvalues should occur.  The leading @var{k}\n\
 columns of @var{U} always span the @var{A}-invariant\n\
 subspace corresponding to the @var{k} leading eigenvalues of @var{S}.\n\
 \n\
 The Schur@tie{}decomposition is used to compute eigenvalues of a\n\
 square matrix, and has applications in the solution of algebraic\n\
 Riccati equations in control (see @code{are} and @code{dare}).\n\
-@seealso{rsf2csf}\n\
+@seealso{rsf2csf, lu, chol, hess, qr, qz, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
@@ -300,17 +301,17 @@ upper triangular Schur@tie{}form @var{T}
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
 $UR \\cdot TR \\cdot {UR}^T = U T U^{\\dagger}$ and\n\
 $U^{\\dagger} U$ is the identity matrix I.\n\
 @end tex\n\
 @ifnottex\n\
-@xcode{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
+@tcode{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
 @code{@var{U}' * @var{U}} is the identity matrix I.\n\
 @end ifnottex\n\
 \n\
 Note also that @var{U} and @var{T} are not unique.\n\
 @seealso{schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -572,16 +572,147 @@ install_signal_handlers (void)
 #endif
 
 #ifdef SIGXFSZ
   octave_set_signal_handler (SIGXFSZ, generic_sig_handler);
 #endif
 
 }
 
+static pid_t gui_pid = 0;
+
+static void
+gui_driver_sig_handler (int sig)
+{
+  if (gui_pid > 0)
+    octave_syscalls::kill (gui_pid, sig);
+}
+
+void
+install_gui_driver_signal_handlers (pid_t pid)
+{
+  gui_pid = pid;
+
+#ifdef SIGINT
+  octave_set_signal_handler (SIGINT, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGBREAK
+  octave_set_signal_handler (SIGBREAK, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGABRT
+  octave_set_signal_handler (SIGABRT, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGALRM
+  octave_set_signal_handler (SIGALRM, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGBUS
+  octave_set_signal_handler (SIGBUS, gui_driver_sig_handler);
+#endif
+
+  // SIGCHLD
+  // SIGCLD
+  // SIGCONT
+
+#ifdef SIGEMT
+  octave_set_signal_handler (SIGEMT, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGFPE
+  octave_set_signal_handler (SIGFPE, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGHUP
+  octave_set_signal_handler (SIGHUP, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGILL
+  octave_set_signal_handler (SIGILL, gui_driver_sig_handler);
+#endif
+
+  // SIGINFO
+  // SIGINT
+
+#ifdef SIGIOT
+  octave_set_signal_handler (SIGIOT, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGLOST
+  octave_set_signal_handler (SIGLOST, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGPIPE
+  octave_set_signal_handler (SIGPIPE, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGPOLL
+  octave_set_signal_handler (SIGPOLL, gui_driver_sig_handler);
+#endif
+
+  // SIGPROF
+  // SIGPWR
+
+#ifdef SIGQUIT
+  octave_set_signal_handler (SIGQUIT, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGSEGV
+  octave_set_signal_handler (SIGSEGV, gui_driver_sig_handler);
+#endif
+
+  // SIGSTOP
+
+#ifdef SIGSYS
+  octave_set_signal_handler (SIGSYS, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGTERM
+  octave_set_signal_handler (SIGTERM, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGTRAP
+  octave_set_signal_handler (SIGTRAP, gui_driver_sig_handler);
+#endif
+
+  // SIGTSTP
+  // SIGTTIN
+  // SIGTTOU
+  // SIGURG
+
+#ifdef SIGUSR1
+  octave_set_signal_handler (SIGUSR1, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGUSR2
+  octave_set_signal_handler (SIGUSR2, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGVTALRM
+  octave_set_signal_handler (SIGVTALRM, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGIO
+  octave_set_signal_handler (SIGIO, gui_driver_sig_handler);
+#endif
+
+  // SIGWINCH
+
+#ifdef SIGXCPU
+  octave_set_signal_handler (SIGXCPU, gui_driver_sig_handler);
+#endif
+
+#ifdef SIGXFSZ
+  octave_set_signal_handler (SIGXFSZ, gui_driver_sig_handler);
+#endif
+
+}
+
 static octave_scalar_map
 make_sig_struct (void)
 {
   octave_scalar_map m;
 
 #ifdef SIGABRT
   m.assign ("ABRT", SIGABRT);
 #endif
@@ -903,19 +1034,19 @@ DEFUN (debug_on_interrupt, args, nargout
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{debug_on_error, debug_on_warning}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 /*
 %!test
@@ -930,22 +1061,22 @@ variable value is restored when exiting 
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-workspace\" if it receives\n\
-a hangup signal.\n\
+to save all current variables to the file @file{octave-workspace} if it\n\
+receives a hangup signal.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
 /*
 %!test
 %! orig_val = sighup_dumps_octave_core ();
@@ -959,22 +1090,22 @@ variable value is restored when exiting 
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-workspace\" if it receives\n\
-a terminate signal.\n\
+to save all current variables to the file @file{octave-workspace} if it\n\
+receives a terminate signal.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
 
 /*
 %!test
 %! orig_val = sigterm_dumps_octave_core ();
diff --git a/libinterp/corefcn/sighandlers.h b/libinterp/corefcn/sighandlers.h
--- a/libinterp/corefcn/sighandlers.h
+++ b/libinterp/corefcn/sighandlers.h
@@ -66,16 +66,18 @@ extern int pipe_handler_error_count;
 // TRUE means we can be interrupted.
 extern OCTINTERP_API bool can_interrupt;
 
 extern OCTINTERP_API sig_handler *octave_set_signal_handler (int, sig_handler *,
                                                bool restart_syscalls = true);
 
 extern OCTINTERP_API void install_signal_handlers (void);
 
+extern OCTINTERP_API void install_gui_driver_signal_handlers (pid_t pid);
+
 extern OCTINTERP_API void octave_signal_handler (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_catch_interrupts (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_ignore_interrupts (void);
 
 extern OCTINTERP_API octave_interrupt_handler
 octave_set_interrupt_handler (const volatile octave_interrupt_handler&,
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -86,18 +86,19 @@ The following are all equivalent:\n\
 @example\n\
 @group\n\
 s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
 s = sparse (i, j, s, m, n, \"sum\")\n\
 @end group\n\
 @end example\n\
 \n\
-Given the option \"unique\". if more than two values are specified for the\n\
-same @var{i}, @var{j} indices, the last specified value will be used.\n\
+Given the option @qcode{\"unique\"}, if more than two values are specified\n\
+for the same @var{i}, @var{j} indices, the last specified value will be\n\
+used.\n\
 \n\
 @code{sparse (@var{m}, @var{n})} is equivalent to\n\
 @code{sparse ([], [], [], @var{m}, @var{n}, 0)}\n\
 \n\
 If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded\n\
 to have a common size.\n\
 @seealso{full, accumarray}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -92,19 +92,19 @@ by the @sc{lapack} banded solvers (defau
 @item umfpack\n\
 Flag whether the @sc{umfpack} or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with\n\
 @code{spparms (@var{key}, @var{val})}.\n\
 The default values can be restored with the special keyword\n\
-\"defaults\".  The special keyword \"tight\" can be used to set the mmd\n\
-solvers to attempt a sparser solution at the potential cost of longer\n\
-running time.\n\
+@qcode{\"defaults\"}.  The special keyword @qcode{\"tight\"} can be used to\n\
+set the mmd solvers to attempt a sparser solution at the potential cost of\n\
+longer running time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       if (nargout == 0)
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -267,10 +267,10 @@ Mathematics, Manchester, England, Januar
 %! x = [0 1; 0 0];
 %! assert (any (isnan (sqrtm (x))(:)));
 
 %!test
 %! x = eye (4);  x(2,2) = x(3,3) = 2^-26;  x(1,4) = 1;
 %! z = eye (4);  z(2,2) = z(3,3) = 2^-13;  z(1,4) = 0.5;
 %! [y, err] = sqrtm (x);
 %! assert (y, z);
-%! assert (err, 0);   ## Yes, this one has to hold exactly
+%! assert (err, 0);   # Yes, this one has to hold exactly
 */
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -37,19 +37,21 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "gripes.h"
 #include "utils.h"
 
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
-static std::istringstream&
-single_num (std::istringstream& is, double& num)
+static double
+single_num (std::istringstream& is)
 {
+  double num;
+
   char c = is.peek ();
 
   // Skip spaces.
   while (isspace (c))
     {
       is.get ();
       c = is.peek ();
     }
@@ -87,17 +89,17 @@ single_num (std::istringstream& is, doub
             }
           else
             is.setstate (std::ios::failbit); // indicate that read has failed.
         }
     }
   else
     is >> num;
 
-  return is;
+  return num;
 }
 
 static std::istringstream&
 extract_num (std::istringstream& is, double& num, bool& imag, bool& have_sign)
 {
   have_sign = imag = false;
 
   char c = is.peek ();
@@ -109,20 +111,20 @@ extract_num (std::istringstream& is, dou
       c = is.peek ();
     }
 
   bool negative = false;
 
   // Accept leading sign.
   if (c == '+' || c == '-')
     {
+      have_sign = true;
       negative = c == '-';
       is.get ();
       c = is.peek ();
-      have_sign = true;
     }
 
   // Skip spaces after sign.
   while (isspace (c))
     {
       is.get ();
       c = is.peek ();
     }
@@ -133,58 +135,56 @@ extract_num (std::istringstream& is, dou
       // possible infinity.
       is.get ();
       c = is.peek ();
 
       if (is.eof ())
         {
           // just 'i' and string is finished.  Return immediately.
           imag = true;
-          num = 1.0;
-          if (negative)
-            num = -num;
+          num = negative ? -1.0 : 1.0;
           return is;
         }
       else
-        { 
+        {
           if (std::tolower (c) != 'n')
             imag = true;
           is.unget ();
         }
     }
   else if (c == 'j')
     imag = true;
-    
+
   // It's i*num or just i
   if (imag)
     {
       is.get ();
       c = is.peek ();
       // Skip spaces after imaginary unit.
       while (isspace (c))
         {
           is.get ();
           c = is.peek ();
         }
 
       if (c == '*')
         {
           // Multiplier follows, we extract it as a number.
           is.get ();
-          single_num (is, num);
+          num = single_num (is);
           if (is.good ())
             c = is.peek ();
         }
       else
         num = 1.0;
     }
   else
     {
       // It's num, num*i, or numi.
-      single_num (is, num);
+      num = single_num (is);
       if (is.good ())
         {
           c = is.peek ();
 
           // Skip spaces after number.
           while (isspace (c))
             {
               is.get ();
@@ -260,20 +260,19 @@ set_component (Complex& c, double num, b
 
 static Complex
 str2double1 (const std::string& str_arg)
 {
   Complex val (0.0, 0.0);
 
   std::string str = str_arg;
 
-  // FIXME -- removing all commas does too much...
-  std::string::iterator se = str.end ();
-  se = std::remove (str.begin (), se, ',');
-  str.erase (se, str.end ());
+  // FIXME: removing all commas doesn't allow actual parsing.
+  //        Example: "1,23.45" is wrong, but passes Octave.
+  str.erase (std::remove (str.begin (), str.end(), ','), str.end ());
   std::istringstream is (str);
 
   double num;
   bool i1, i2, s1, s2;
 
   if (is.eof ())
     val = octave_NaN;
   else if (! extract_num (is, num, i1, s1))
@@ -295,57 +294,68 @@ str2double1 (const std::string& str_arg)
 }
 
 DEFUN (str2double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2double (@var{s})\n\
 Convert a string to a real or complex number.\n\
 \n\
 The string must be in one of the following formats where\n\
-a and b are real numbers and the complex unit is 'i' or 'j':\n\
+a and b are real numbers and the complex unit is @qcode{'i'} or @qcode{'j'}:\n\
 \n\
 @itemize\n\
 @item a + bi\n\
 \n\
 @item a + b*i\n\
 \n\
 @item a + i*b\n\
 \n\
 @item bi + a\n\
 \n\
 @item b*i + a\n\
 \n\
 @item i*b + a\n\
 @end itemize\n\
 \n\
 If present, a and/or b are of the form @nospell{[+-]d[,.]d[[eE][+-]d]} where\n\
-the brackets indicate optional arguments and 'd' indicates zero or more\n\
-digits.  The special input values @code{Inf}, @code{NaN}, and @code{NA} are\n\
-also accepted.\n\
+the brackets indicate optional arguments and @qcode{'d'} indicates zero or\n\
+more digits.  The special input values @code{Inf}, @code{NaN}, and @code{NA}\n\
+are also accepted.\n\
 \n\
-@var{s} may also be a character matrix, in which case the conversion is\n\
-repeated for each row.  Or @var{s} may be a cell array of strings, in which\n\
-case each element is converted and an array of the same dimensions is\n\
-returned.\n\
+@var{s} may be a character string, character matrix, or cell array.\n\
+For character arrays the conversion is repeated for every row, and\n\
+a double or complex array is returned.  Empty rows in @var{s} are deleted\n\
+and not returned in the numeric array.  For cell arrays each character\n\
+string element is processed and a double or complex array of the same\n\
+dimensions as @var{s} is returned.\n\
 \n\
-@code{str2double} returns NaN for elements of @var{s} which cannot be\n\
-converted.\n\
+For unconvertible scalar or character string input @code{str2double} returns\n\
+a NaN@.  Similarly, for character array input @code{str2double} returns a\n\
+NaN for any row of @var{s} that could not be converted.  For a cell array,\n\
+@code{str2double} returns a NaN for any element of @var{s} for which\n\
+conversion fails.  Note that numeric elements in a mixed string/numeric\n\
+cell array are not strings and the conversion will fail for these elements\n\
+and return NaN.\n\
 \n\
 @code{str2double} can replace @code{str2num}, and it avoids the security\n\
 risk of using @code{eval} on unknown data.\n\
 @seealso{str2num}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
   else if (args(0).is_string ())
     {
-      if (args(0).rows () == 1 && args(0).ndims () == 2)
+      if (args(0).rows () == 0 || args(0).columns () == 0)
+        {
+          retval = Matrix (1, 1, octave_NaN);
+        }
+      else if (args(0).rows () == 1 && args(0).ndims () == 2)
         {
           retval = str2double1 (args(0).string_value ());
         }
       else
         {
           const string_vector sv = args(0).all_strings ();
           if (! error_state)
             retval = sv.map<Complex> (str2double1);
@@ -362,27 +372,26 @@ risk of using @code{eval} on unknown dat
         {
           if (cell(i).is_string ())
             output(i) = str2double1 (cell(i).string_value ());
         }
         retval = output;
       }
     }
   else
-    retval = NDArray (args(0).dims (), octave_NaN);
+    retval = Matrix (1, 1, octave_NaN);
 
 
   return retval;
 }
 
 /*
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i])
-%!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double ("1,222.5"), 1222.5)
 %!assert (str2double ("i"), i)
 %!assert (str2double ("2j"), 2i)
 %!assert (str2double ("2 + j"), 2+j)
 %!assert (str2double ("i*2 + 3"), 3+2i)
 %!assert (str2double (".5*i + 3.5"), 3.5+0.5i)
 %!assert (str2double ("1e-3 + i*.25"), 1e-3 + 0.25i)
 %!assert (str2double (["2 + j";"1.25e-3";"-05"]), [2+i; 1.25e-3; -5])
@@ -397,10 +406,13 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("iNF*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
-%!assert (str2double (zeros (3,1,2)), NaN (3,1,2))
-*/
+%!assert (str2double (zeros (3,1,2)), NaN)
+%!assert (str2double (''), NaN)
+%!assert (str2double ([]), NaN)
+%!assert (str2double (char(zeros(3,0))), NaN)
+ */
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -144,30 +144,39 @@ qs_search (const Array<char>& needle,
 
   return result;
 }
 
 DEFUN (strfind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} strfind (@dots{}, \"overlaps\", @var{val})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
+\n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
+The optional argument @qcode{\"overlaps\"} determines whether the pattern\n\
+can match at every position in @var{str} (true), or only for unique\n\
+occurrences of the complete pattern (false).  The default is true.\n\
 \n\
 If a cell array of strings @var{cellstr} is specified\n\
-then @var{idx} is a cell array of vectors, as specified\n\
-above.  Examples:\n\
+then @var{idx} is a cell array of vectors, as specified above.\n\
+\n\
+Examples:\n\
 \n\
 @example\n\
 @group\n\
 strfind (\"abababa\", \"aba\")\n\
      @result{} [1, 3, 5]\n\
 \n\
+strfind (\"abababa\", \"aba\", \"overlaps\", false)\n\
+     @result{} [1, 5]\n\
+\n\
 strfind (@{\"abababa\", \"bebebe\", \"ab\"@}, \"aba\")\n\
      @result{}\n\
         @{\n\
           [1,1] =\n\
 \n\
              1   3   5\n\
 \n\
           [1,2] = [](1x0)\n\
@@ -316,30 +325,38 @@ qs_replace (const Array<char>& str, cons
         }
     }
 
   return ret;
 }
 
 DEFUN (strrep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
-@deftypefnx {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
-Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
-with the string @var{rep} and return the result.  For example:\n\
+@deftypefn  {Built-in Function} {@var{newstr} =} strrep (@var{str}, @var{ptn}, @var{rep})\n\
+@deftypefnx {Built-in Function} {@var{newstr} =} strrep (@var{cellstr}, @var{ptn}, @var{rep})\n\
+@deftypefnx {Built-in Function} {@var{newstr} =} strrep (@dots{}, \"overlaps\", @var{val})\n\
+Replace all occurrences of the pattern @var{ptn} in the string @var{str}\n\
+with the string @var{rep} and return the result.\n\
+\n\
+The optional argument @qcode{\"overlaps\"} determines whether the pattern\n\
+can match at every position in @var{str} (true), or only for unique\n\
+occurrences of the complete pattern (false).  The default is true.\n\
+\n\
+@var{s} may also be a cell array of strings, in which case the replacement is\n\
+done for each element and a cell array is returned.\n\
+\n\
+Example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
     @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
-@var{s} may also be a cell array of strings, in which case the replacement is\n\
-done for each element and a cell array is returned.\n\
 @seealso{regexprep, strfind, findstr}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
   bool overlaps = true;
 
   if (nargin == 5 && args(3).is_string () && args(4).is_scalar_type ())
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -116,17 +116,17 @@ v =\n\
   -0.45986  -0.52829  -0.71375\n\
   -0.32330  -0.64901   0.68867\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{svd} returns an economy-sized\n\
 decomposition, eliminating the unnecessary rows or columns of @var{U} or\n\
 @var{V}.\n\
-@seealso{svd_driver, svds, eig}\n\
+@seealso{svd_driver, svds, eig, lu, chol, hess, qr, qz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     {
@@ -403,22 +403,22 @@ decomposition, eliminating the unnecessa
 */
 
 DEFUN (svd_driver, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} svd_driver ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
-Currently recognized values are \"gesvd\" and \"gesdd\".  The default\n\
-is \"gesvd\".\n\
+Currently recognized values are @qcode{\"gesvd\"} and @qcode{\"gesdd\"}.  \n\
+The default is @qcode{\"gesvd\"}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{svd}\n\
 @end deftypefn")
 {
   static const char *driver_names[] = { "gesvd", "gesdd", 0 };
 
   return SET_INTERNAL_VARIABLE_CHOICES (svd_driver, driver_names);
 }
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1589,24 +1589,24 @@ symbol_table::do_update_nest (void)
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave checks\n\
 the time stamp on files each time it looks up functions defined in\n\
-function files.  If the internal variable is set to @code{\"system\"},\n\
+function files.  If the internal variable is set to @qcode{\"system\"},\n\
 Octave will not automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
 they were last compiled, but will recompile other function files in the\n\
-search path if they change.  If set to @code{\"all\"}, Octave will not\n\
+search path if they change.  If set to @qcode{\"all\"}, Octave will not\n\
 recompile any function files unless their definitions are removed with\n\
-@code{clear}.  If set to \"none\", Octave will always check time stamps\n\
-on files to determine whether functions defined in function files\n\
+@code{clear}.  If set to @qcode{\"none\"}, Octave will always check time\n\
+stamps on files to determine whether functions defined in function files\n\
 need to recompiled.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <deque>
 #include <list>
 #include <map>
 #include <set>
 #include <string>
 
 #include "glob-match.h"
-#include "regexp.h"
+#include "lo-regexp.h"
 
 class tree_argument_list;
 class octave_user_function;
 
 #include "oct-obj.h"
 #include "workspace-element.h"
 #include "oct-refcount.h"
 #include "ov.h"
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -33,26 +33,28 @@ along with Octave; see the file COPYING.
 #include <cstdio>
 #include <cstring>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include <fcntl.h>
 
+#include "cmd-hist.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-syscalls.h"
 #include "oct-uname.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "lo-utils.h"
+#include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 #include "input.h"
@@ -215,16 +217,21 @@ error message.\n\
             {
               exec_args.resize (1);
 
               exec_args[0] = exec_file;
             }
 
           if (! error_state)
             {
+              octave_history_write_timestamp ();
+
+              if (! command_history::ignoring_entries ())
+                command_history::clean_up_and_save ();
+
               std::string msg;
 
               int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
               retval(1) = msg;
               retval(0) = status;
             }
         }
@@ -271,17 +278,17 @@ fclose (out);\n\
 waitpid (pid);\n\
 \n\
    @print{} these\n\
    @print{} strings\n\
    @print{} some\n\
    @print{} are\n\
 @end example\n\
 \n\
-Note that @code{popen2}, unlike @code{popen}, will not \"reap\" the\n\
+Note that @code{popen2}, unlike @code{popen}, will not @qcode{\"reap\"} the\n\
 child process.  If you don't use @code{waitpid} to check the child's\n\
 exit status, it will linger until Octave exits.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = -1;
   retval(1) = Matrix ();
@@ -737,21 +744,23 @@ Return 0 if successful, otherwise return
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("lstat", Flstat, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{symlink})\n\
+@deftypefn  {Built-in Function} {@var{info} =} lstat (@var{symlink})\n\
+@deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{symlink})\n\
 Return a structure @var{info} containing information about the symbolic link\n\
-@var{symlink}.  The function outputs are described in the documentation for\n\
-@code{stat}.\n\
-@seealso{stat}\n\
+@var{symlink}.\n\
+\n\
+The function outputs are described in the documentation for @code{stat}.\n\
+@seealso{stat, symlink}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string fname = args(0).string_value ();
 
@@ -765,22 +774,24 @@ Return a structure @var{info} containing
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("mkfifo", Fmkfifo, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name}, @var{mode})\n\
-Create a @var{fifo} special file named @var{name} with file mode @var{mode}\n\
+@deftypefn  {Built-in Function} {} mkfifo (@var{name}, @var{mode})\n\
+@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name}, @var{mode})\n\
+Create a FIFO special file named @var{name} with file mode @var{mode}\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
+@seealso{pipe}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
@@ -825,16 +836,17 @@ DEFUNX ("pipe", Fpipe, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{read_fd}, @var{write_fd}, @var{err}, @var{msg}] =} pipe ()\n\
 Create a pipe and return the reading and writing ends of the pipe\n\
 into @var{read_fd} and @var{write_fd} respectively.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
+@seealso{mkfifo}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(3) = std::string ();
   retval(2) = -1;
   retval(1) = -1;
   retval(0) = -1;
@@ -888,19 +900,19 @@ Return a structure @var{info} containing
 @item dev\n\
 ID of device containing a directory entry for this file.\n\
 \n\
 @item ino\n\
 File number of the file.\n\
 \n\
 @item mode\n\
 File mode, as an integer.  Use the functions @w{@code{S_ISREG}},\n\
-@w{@code{S_ISDIR}}, @w{@code{S_ISCHR}}, @w{@code{S_ISBLK}}, @w{@code{S_ISFIFO}},\n\
-@w{@code{S_ISLNK}}, or @w{@code{S_ISSOCK}} to extract information from this\n\
-value.\n\
+@w{@code{S_ISDIR}}, @w{@code{S_ISCHR}}, @w{@code{S_ISBLK}},\n\
+@w{@code{S_ISFIFO}}, @w{@code{S_ISLNK}}, or @w{@code{S_ISSOCK}} to extract\n\
+information from this value.\n\
 \n\
 @item modestr\n\
 File mode, as a string of ten letters or dashes as would be returned by\n\
 @kbd{ls -l}.\n\
 \n\
 @item nlink\n\
 Number of links.\n\
 \n\
@@ -963,16 +975,17 @@ For example:\n\
        mode = -rw-r--r--\n\
        modestr = -rw-r--r--\n\
        ino = 9316\n\
        dev = 2049\n\
      @}\n\
   @result{} err = 0\n\
   @result{} msg =\n\
 @end example\n\
+@seealso{lstat, ls, dir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_scalar_type ())
         {
@@ -1001,18 +1014,19 @@ For example:\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISREG (@var{mode})\n\
-Return true if @var{mode} corresponds to a regular file.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a regular file.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1026,18 +1040,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISDIR (@var{mode})\n\
-Return true if @var{mode} corresponds to a directory.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a directory.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1051,18 +1066,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISCHR (@var{mode})\n\
-Return true if @var{mode} corresponds to a character device.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a character device.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1076,18 +1092,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISBLK (@var{mode})\n\
-Return true if @var{mode} corresponds to a block device.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a block device.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1101,18 +1118,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISFIFO (@var{mode})\n\
-Return true if @var{mode} corresponds to a fifo.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a fifo.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1126,18 +1144,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISLNK (@var{mode})\n\
-Return true if @var{mode} corresponds to a symbolic link.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a symbolic link.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
@@ -1151,18 +1170,19 @@ of @var{mode} is assumed to be returned 
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISSOCK (@var{mode})\n\
-Return true if @var{mode} corresponds to a socket.  The value\n\
-of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
+Return true if @var{mode} corresponds to a socket.\n\
+\n\
+The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -629,16 +629,19 @@ main_loop (void)
           recover_from_exception ();
           std::cerr
             << "error: out of memory -- trying to return to prompt"
             << std::endl;
         }
     }
   while (retval == 0);
 
+  if (retval == EOF)
+    retval = 0;
+
   return retval;
 }
 
 // Fix up things before exiting.
 
 static std::list<std::string> octave_atexit_functions;
 
 static void
@@ -746,17 +749,17 @@ clean_up_and_exit (int retval, bool safe
           // day...
 
           gnulib::sleep (86400);
         }
     }
   else
     {
       if (octave_exit)
-        (*octave_exit) (retval == EOF ? 0 : retval);
+        (*octave_exit) (retval);
     }
 }
 
 DEFUN (quit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
 Exit the current Octave session.  If the optional integer value\n\
@@ -802,18 +805,17 @@ DEFALIAS (exit, quit);
 DEFUN (warranty, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} warranty ()\n\
 Describe the conditions for copying and distributing Octave.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  octave_stdout << "\n" \
-    OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\
+  octave_stdout << "\n" << octave_name_version_and_copyright () << "\n\
 \n\
 GNU Octave free software; you can redistribute it and/or modify\n\
 it under the terms of the GNU General Public License as published by\n\
 the Free Software Foundation; either version 3 of the License, or\n\
 (at your option) any later version.\n\
 \n\
 GNU Octave is distributed in the hope that it will be useful,\n\
 but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
@@ -908,21 +910,21 @@ enum system_exec_type { et_sync, et_asyn
 
 DEFUN (system, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} system (\"@var{string}\")\n\
 @deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output})\n\
 @deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output}, @var{type})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} system (@dots{})\n\
 Execute a shell command specified by @var{string}.\n\
-If the optional argument @var{type} is \"async\", the process\n\
+If the optional argument @var{type} is @qcode{\"async\"}, the process\n\
 is started in the background and the process ID of the child process\n\
 is returned immediately.  Otherwise, the child process is started and\n\
 Octave waits until it exits.  If the @var{type} argument is omitted, it\n\
-defaults to the value \"sync\".\n\
+defaults to the value @qcode{\"sync\"}.\n\
 \n\
 If @var{system} is called with one or more output arguments, or if the\n\
 optional argument @var{return_output} is true and the subprocess is started\n\
 synchronously, then the output from the command is returned as a variable.  \n\
 Otherwise, if the subprocess is executed synchronously, its output is sent\n\
 to the standard output.  To send the output of a command executed with\n\
 @code{system} through the pager, use a command like\n\
 \n\
@@ -1134,17 +1136,17 @@ Register a function to be called when Oc
 function last_words ()\n\
   disp (\"Bye bye\");\n\
 endfunction\n\
 atexit (\"last_words\");\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
-will print the message \"Bye bye\" when Octave exits.\n\
+will print the message @qcode{\"Bye bye\"} when Octave exits.\n\
 \n\
 The additional argument @var{flag} will register or unregister\n\
 @var{fcn} from the list of functions to be called when Octave\n\
 exits.  If @var{flag} is true, the function is registered, and if\n\
 @var{flag} is false, it is unregistered.  For example,\n\
 after registering the function @code{last_words} above,\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -35,16 +35,17 @@ class octave_user_script;
 class tree_statement;
 class tree_statement_list;
 class charMatrix;
 
 #include "quit.h"
 
 #include "input.h"
 #include "oct-map.h"
+#include "symtab.h"
 
 
 typedef void (*octave_exit_func) (int);
 extern OCTINTERP_API octave_exit_func octave_exit;
 
 extern OCTINTERP_API bool quit_allowed;
 
 extern OCTINTERP_API bool quitting_gracefully;
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -381,19 +381,19 @@ and\n\
 @group\n\
 tril (ones (3), 1)\n\
      @result{}  1  1  0\n\
          1  1  1\n\
          1  1  1\n\
 @end group\n\
 @end example\n\
 \n\
-If the option \"pack\" is given as third argument, the extracted elements\n\
-are not inserted into a matrix, but rather stacked column-wise one above\n\
-other.\n\
+If the option @qcode{\"pack\"} is given as third argument, the extracted\n\
+elements are not inserted into a matrix, but rather stacked column-wise one\n\
+above other.\n\
 @seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN (triu, args, ,
   "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -25,51 +25,58 @@ along with Octave; see the file COPYING.
 #endif
 
 #if defined (HAVE_FREETYPE)
 
 #if defined (HAVE_FONTCONFIG)
 #include <fontconfig/fontconfig.h>
 #endif
 
+#include <clocale>
+#include <cwchar>
 #include <iostream>
+#include <map>
+#include <utility>
 
 #include "singleton-cleanup.h"
 
 #include "error.h"
 #include "pr-output.h"
 #include "txt-eng-ft.h"
 
-// FIXME -- maybe issue at most one warning per glyph/font/size/weight
-// combination.
+// FIXME: maybe issue at most one warning per glyph/font/size/weight
+//        combination.
 
 static void
-gripe_missing_glyph (char c)
+gripe_missing_glyph (FT_ULong c)
 {
   warning_with_id ("Octave:missing-glyph",
-                   "ft_render: skipping missing glyph for character '%c'",
+                   "ft_render: skipping missing glyph for character '%x'",
                    c);
 }
 
 static void
-gripe_glyph_render (char c)
+gripe_glyph_render (FT_ULong c)
 {
   warning_with_id ("Octave:glyph-render",
-                   "ft_render: unable to render glyph for character '%c'",
+                   "ft_render: unable to render glyph for character '%x'",
                    c);
 }
 
 #ifdef _MSC_VER
-// This is just a trick to avoid multiply symbols definition.
+// This is just a trick to avoid multiple symbol definitions.
 // PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
-// that will make MSVC not to generate new instantiation and
-// use the imported one.
+// that will cause MSVC not to generate a new instantiation and
+// use the imported one instead.
 #include "PermMatrix.h"
 #endif
 
+// Forward declaration
+static void ft_face_destroyed (void* object);
+
 class
 ft_manager
 {
 public:
   static bool instance_ok (void)
     {
       bool retval = true;
 
@@ -94,20 +101,34 @@ public:
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static FT_Face get_font (const std::string& name, const std::string& weight,
                            const std::string& angle, double size)
     { return (instance_ok ()
               ? instance->do_get_font (name, weight, angle, size)
               : 0); }
 
+  static void font_destroyed (FT_Face face)
+    {
+      if (instance_ok ())
+        instance->do_font_destroyed (face);
+    }
+
 private:
 
   static ft_manager *instance;
 
+  typedef std::pair<std::string, double> ft_key;
+  typedef std::map<ft_key, FT_Face> ft_cache;
+
+  // Cache the fonts loaded by freetype. This cache only contains
+  // weak references to the fonts, strong references are only present
+  // in class ft_render.
+  ft_cache cache;
+
 private:
 
   // No copying!
 
   ft_manager (const ft_manager&);
 
   ft_manager& operator = (const ft_manager&);
 
@@ -128,32 +149,45 @@ private:
     }
 
   ~ft_manager (void)
     {
       if (freetype_initialized)
         FT_Done_FreeType (library);
 
 #if defined (HAVE_FONTCONFIG)
-      // FIXME -- Skip the call to FcFini because it can trigger the
-      // assertion
+      // FIXME: Skip the call to FcFini because it can trigger the assertion
       //
       //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
       //
       // if (fontconfig_initialized)
       //   FcFini ();
 #endif
     }
 
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
                        const std::string& angle, double size)
     {
       FT_Face retval = 0;
 
+#if HAVE_FT_REFERENCE_FACE
+      // Look first into the font cache, then use fontconfig. If the font
+      // is present in the cache, simply add a reference and return it.
+
+      ft_key key (name + ":" + weight + ":" + angle, size);
+      ft_cache::const_iterator it = cache.find (key);
+
+      if (it != cache.end ())
+        {
+          FT_Reference_Face (it->second);
+          return it->second;
+        }
+#endif
+
       std::string file;
 
 #if defined (HAVE_FONTCONFIG)
       if (fontconfig_initialized)
         {
           int fc_weight, fc_angle;
 
           if (weight == "bold")
@@ -185,17 +219,17 @@ private:
           if (FcConfigSubstitute (0, pat, FcMatchPattern))
             {
               FcResult res;
               FcPattern *match;
 
               FcDefaultSubstitute (pat);
               match = FcFontMatch (0, pat, &res);
 
-              // FIXME -- originally, this test also required that
+              // FIXME: originally, this test also required that
               // res != FcResultNoMatch.  Is that really needed?
               if (match)
                 {
                   unsigned char *tmp;
 
                   FcPatternGetString (match, FC_FILE, 0, &tmp);
                   file = reinterpret_cast<char*> (tmp);
                 }
@@ -216,303 +250,610 @@ private:
         {
 #ifdef __WIN32__
           file = "C:/WINDOWS/Fonts/verdana.ttf";
 #else
           // FIXME: find a "standard" font for UNIX platforms
 #endif
         }
 
-      if (! file.empty () && FT_New_Face (library, file.c_str (), 0, &retval))
-        ::warning ("ft_manager: unable to load font: %s", file.c_str ());
+      if (! file.empty ())
+        {
+          if (FT_New_Face (library, file.c_str (), 0, &retval))
+            ::warning ("ft_manager: unable to load font: %s", file.c_str ());
+#if HAVE_FT_REFERENCE_FACE
+          else
+            {
+              // Install a finalizer to notify ft_manager that the font is
+              // being destroyed. The class ft_manager only keeps weak
+              // references to font objects.
+
+              retval->generic.data = new ft_key (key);
+              retval->generic.finalizer = ft_face_destroyed;
+
+              // Insert loaded font into the cache.
+
+              cache[key] = retval;
+            }
+#endif
+        }
 
       return retval;
     }
 
+  void do_font_destroyed (FT_Face face)
+    {
+      if (face->generic.data)
+        {
+          ft_key* pkey = reinterpret_cast<ft_key*> (face->generic.data);
+
+          cache.erase (*pkey);
+          delete pkey;
+          face->generic.data = 0;
+        }
+    }
+
 private:
   FT_Library library;
   bool freetype_initialized;
   bool fontconfig_initialized;
 };
 
 ft_manager* ft_manager::instance = 0;
 
+static void
+ft_face_destroyed (void* object)
+{ ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object)); }
+
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
-    : text_processor (), face (0), bbox (1, 4, 0.0),
-      xoffset (0), yoffset (0), multiline_halign (0),
-      multiline_align_xoffsets (), mode (MODE_BBOX),
-      red (0), green (0), blue (0)
+    : text_processor (), font (), bbox (1, 4, 0.0), halign (0), xoffset (0),
+      line_yoffset (0), yoffset (0), mode (MODE_BBOX),
+      color (dim_vector (1, 3), 0)
 {
 }
 
 ft_render::~ft_render (void)
 {
-  if (face)
-    FT_Done_Face (face);
 }
 
 void
 ft_render::set_font (const std::string& name, const std::string& weight,
                      const std::string& angle, double size)
 {
-  if (face)
-    FT_Done_Face (face);
+  // FIXME: take "fontunits" into account
+
+  font = ft_font (name, weight, angle, size, 0);
+}
+
+void
+ft_render::push_new_line (void)
+{
+  switch (mode)
+    {
+    case MODE_BBOX:
+        {
+          // Create a new bbox entry based on the current font.
+
+          FT_Face face = font.get_face ();
+
+          if (face)
+            {
+              int asc = face->size->metrics.ascender >> 6;
+              int desc = face->size->metrics.descender >> 6;
+              int h = face->size->metrics.height >> 6;
+
+              Matrix bb (1, 5, 0.0);
+
+              bb(1) = desc;
+              bb(3) = asc - desc;
+              bb(4) = h;
+
+              line_bbox.push_back (bb);
 
-  // FIXME: take "fontunits" into account
-  face = ft_manager::get_font (name, weight, angle, size);
+              xoffset = yoffset = 0;
+            }
+        }
+      break;
+
+    case MODE_RENDER:
+        {
+          // Move to the next line bbox, adjust xoffset based on alignment
+          // and yoffset based on the old and new line bbox.
+
+          Matrix old_bbox = line_bbox.front ();
+          line_bbox.pop_front ();
+          Matrix new_bbox = line_bbox.front ();
+
+          xoffset = compute_line_xoffset (new_bbox);
+          line_yoffset += (old_bbox(1) - (new_bbox(1) + new_bbox(3)));
+          yoffset = 0;
+        }
+      break;
+    }
+}
+
+int
+ft_render::compute_line_xoffset (const Matrix& lb) const
+{
+  if (! bbox.is_empty ())
+    {
+      switch (halign)
+        {
+        case 0:
+          return 0;
+        case 1:
+          return (bbox(2) - lb(2)) / 2;
+        case 2:
+          return (bbox(2) - lb(2));
+        }
+    }
 
-  if (face)
+  return 0;
+}
+
+void
+ft_render::compute_bbox (void)
+{
+  // Stack the various line bbox together and compute the final
+  // bounding box for the entire text string.
+
+  bbox = Matrix ();
+
+  switch (line_bbox.size ())
     {
-      if (FT_Set_Char_Size (face, 0, size*64, 0, 0))
-        ::warning ("ft_render: unable to set font size to %d", size);
+    case 0:
+      break;
+    case 1:
+      bbox = line_bbox.front ().extract (0, 0, 0, 3);
+      break;
+    default:
+      for (std::list<Matrix>::const_iterator it = line_bbox.begin ();
+           it != line_bbox.end (); ++it)
+        {
+          if (bbox.is_empty ())
+            bbox = it->extract (0, 0, 0, 3);
+          else
+            {
+              bbox(1) -= (*it)(3);
+              bbox(3) += (*it)(3);
+              bbox(2) = xmax (bbox(2), (*it)(2));
+            }
+        }
+      break;
     }
-  else
-    ::warning ("ft_render: unable to load appropriate font");
+}
+
+void
+ft_render::update_line_bbox (void)
+{
+  // Called after a font change, when in MODE_BBOX mode, to update the
+  // current line bbox with the new font metrics. This also includes the
+  // current yoffset, that is the offset of the current glyph's baseline
+  // the line's baseline.
+
+  if (mode == MODE_BBOX)
+    {
+      int asc = font.get_face ()->size->metrics.ascender >> 6;
+      int desc = font.get_face ()->size->metrics.descender >> 6;
+
+      Matrix& bb = line_bbox.front ();
+
+      if ((yoffset + desc) < bb(1))
+        {
+          // The new font goes below the bottom of the current bbox.
+
+          int delta = bb(1) - (yoffset + desc);
+
+          bb(1) -= delta;
+          bb(3) += delta;
+        }
+
+      if ((yoffset + asc) > (bb(1) + bb(3)))
+        {
+          // The new font goes above the top of the current bbox.
+
+          int delta = (yoffset + asc) - (bb(1) + bb(3));
+
+          bb(3) += delta;
+        }
+    }
 }
 
 void
 ft_render::set_mode (int m)
 {
   mode = m;
 
   switch (mode)
     {
     case MODE_BBOX:
-      xoffset = yoffset = 0;
+      xoffset = line_yoffset = yoffset = 0;
       bbox = Matrix (1, 4, 0.0);
+      line_bbox.clear ();
+      push_new_line ();
       break;
     case MODE_RENDER:
       if (bbox.numel () != 4)
         {
           ::warning ("ft_render: invalid bounding box, cannot render");
 
-          xoffset = yoffset = 0;
+          xoffset = line_yoffset = yoffset = 0;
           pixels = uint8NDArray ();
         }
       else
         {
           pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
                                  static_cast<uint8_t> (0));
-          xoffset = 0;
-          yoffset = -bbox(1)-1;
+          xoffset = compute_line_xoffset (line_bbox.front ());
+          line_yoffset = -bbox(1)-1;
+          yoffset = 0;
         }
       break;
     default:
       ::error ("ft_render: invalid mode '%d'", mode);
       break;
     }
 }
 
+FT_UInt
+ft_render::process_character (FT_ULong code, FT_UInt previous)
+{
+  FT_Face face = font.get_face ();
+  FT_UInt glyph_index = 0;
+
+  if (face)
+    {
+      glyph_index = FT_Get_Char_Index (face, code);
+
+      if (code != '\n'
+          && (! glyph_index
+              || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT)))
+        {
+          glyph_index = 0;
+          gripe_missing_glyph (code);
+        }
+      else
+        {
+          switch (mode)
+            {
+            case MODE_RENDER:
+              if (code == '\n')
+                {
+                  glyph_index = FT_Get_Char_Index (face, ' ');
+                  if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+                    {
+                      glyph_index = 0;
+                      gripe_missing_glyph (' ');
+                    }
+                  else
+                    push_new_line ();
+                }
+              else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
+                {
+                  glyph_index = 0;
+                  gripe_glyph_render (code);
+                }
+              else
+                {
+                  FT_Bitmap& bitmap = face->glyph->bitmap;
+                  int x0, y0;
+
+                  if (previous)
+                    {
+                      FT_Vector delta;
+
+                      FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
+                      xoffset += (delta.x >> 6);
+                    }
+
+                  x0 = xoffset + face->glyph->bitmap_left;
+                  y0 = line_yoffset + yoffset + face->glyph->bitmap_top;
+
+                  // 'w' seems to have a negative -1
+                  // face->glyph->bitmap_left, this is so we don't
+                  // index out of bound, and assumes we we allocated
+                  // the right amount of horizontal space in the bbox.
+                  if (x0 < 0)
+                    x0 = 0;
+
+                  for (int r = 0; r < bitmap.rows; r++)
+                    for (int c = 0; c < bitmap.width; c++)
+                      {
+                        unsigned char pix = bitmap.buffer[r*bitmap.width+c];
+                        if (x0+c < 0 || x0+c >= pixels.dim2 ()
+                            || y0-r < 0 || y0-r >= pixels.dim3 ())
+                          {
+                            //::warning ("ft_render: pixel out of bound (char=%d, (x,y)=(%d,%d), (w,h)=(%d,%d)",
+                            //           str[i], x0+c, y0-r, pixels.dim2 (), pixels.dim3 ());
+                          }
+                        else if (pixels(3, x0+c, y0-r).value () == 0)
+                          {
+                            pixels(0, x0+c, y0-r) = color(0);
+                            pixels(1, x0+c, y0-r) = color(1);
+                            pixels(2, x0+c, y0-r) = color(2);
+                            pixels(3, x0+c, y0-r) = pix;
+                          }
+                      }
+
+                  xoffset += (face->glyph->advance.x >> 6);
+                }
+              break;
+
+            case MODE_BBOX:
+              if (code == '\n')
+                {
+                  glyph_index = FT_Get_Char_Index (face, ' ');
+                  if (! glyph_index
+                      || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+                    {
+                      glyph_index = 0;
+                      gripe_missing_glyph (' ');
+                    }
+                  else
+                    push_new_line ();
+                }
+              else
+                {
+                  Matrix& bb = line_bbox.back ();
+
+                  // If we have a previous glyph, use kerning information.
+                  // This usually means moving a bit backward before adding
+                  // the next glyph. That is, "delta.x" is usually < 0.
+                  if (previous)
+                    {
+                      FT_Vector delta;
+
+                      FT_Get_Kerning (face, previous, glyph_index,
+                                      FT_KERNING_DEFAULT, &delta);
+
+                      xoffset += (delta.x >> 6);
+                    }
+
+                  // Extend current X offset box by the width of the current
+                  // glyph. Then extend the line bounding box if necessary.
+
+                  xoffset += (face->glyph->advance.x >> 6);
+                  bb(2) = xmax (bb(2), xoffset);
+                }
+              break;
+            }
+        }
+    }
+
+  return glyph_index;
+}
+
 void
 ft_render::visit (text_element_string& e)
 {
-  if (face)
+  if (font.is_valid ())
     {
-      int line_index = 0;
-      FT_UInt box_line_width = 0;
-      std::string str = e.string_value ();
       FT_UInt glyph_index, previous = 0;
 
-      if (mode == MODE_BBOX)
-        multiline_align_xoffsets.clear ();
-      else if (mode == MODE_RENDER)
-        xoffset += multiline_align_xoffsets[line_index];
+      std::string str = e.string_value ();
+      size_t n = str.length (), curr = 0;
+      mbstate_t ps;
+      memset (&ps, 0, sizeof (ps));  // Initialize state to 0.
+      wchar_t wc;
 
-      for (size_t i = 0; i < str.length (); i++)
+      while (n > 0)
         {
-          glyph_index = FT_Get_Char_Index (face, str[i]);
+          size_t r = gnulib::mbrtowc (&wc, str.data () + curr, n, &ps);
 
-          if (str[i] != '\n'
-              && (! glyph_index
-              || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT)))
-            gripe_missing_glyph (str[i]);
+          if (r > 0
+              && r != static_cast<size_t> (-1)
+              && r != static_cast<size_t> (-2))
+            {
+              n -= r;
+              curr += r;
+
+              glyph_index = process_character (wc, previous);
+
+              if (wc == L'\n')
+                previous = 0;
+              else
+                previous = glyph_index;
+            }
           else
             {
-              switch (mode)
-                {
-                case MODE_RENDER:
-                  if (str[i] == '\n')
-                    {
-                    glyph_index = FT_Get_Char_Index (face, ' ');
-                    if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
-                      {
-                        gripe_missing_glyph (' ');
-                      }
-                    else
-                      {
-                        line_index++;
-                        xoffset = multiline_align_xoffsets[line_index];
-                        yoffset -= (face->size->metrics.height >> 6);
-                      }
-                    }
-                  else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
-                    {
-                      gripe_glyph_render (str[i]);
-                    }
-                  else
-                    {
-                      FT_Bitmap& bitmap = face->glyph->bitmap;
-                      int x0, y0;
-
-                      if (previous)
-                        {
-                          FT_Vector delta;
-
-                          FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
-                          xoffset += (delta.x >> 6);
-                        }
-
-                      x0 = xoffset+face->glyph->bitmap_left;
-                      y0 = yoffset+face->glyph->bitmap_top;
-
-                      // 'w' seems to have a negative -1
-                      // face->glyph->bitmap_left, this is so we don't
-                      // index out of bound, and assumes we we allocated
-                      // the right amount of horizontal space in the bbox.
-                      if (x0 < 0)
-                        x0 = 0;
-
-                      for (int r = 0; r < bitmap.rows; r++)
-                        for (int c = 0; c < bitmap.width; c++)
-                          {
-                            unsigned char pix = bitmap.buffer[r*bitmap.width+c];
-                            if (x0+c < 0 || x0+c >= pixels.dim2 ()
-                                || y0-r < 0 || y0-r >= pixels.dim3 ())
-                              {
-                                //::error ("out-of-bound indexing!!");
-                              }
-                            else if (pixels(3, x0+c, y0-r).value () == 0)
-                              {
-                                pixels(0, x0+c, y0-r) = red;
-                                pixels(1, x0+c, y0-r) = green;
-                                pixels(2, x0+c, y0-r) = blue;
-                                pixels(3, x0+c, y0-r) = pix;
-                              }
-                          }
-
-                      xoffset += (face->glyph->advance.x >> 6);
-                    }
-                  break;
-
-                case MODE_BBOX:
-                  if (str[i] == '\n')
-                    {
-                      glyph_index = FT_Get_Char_Index (face, ' ');
-                      if (! glyph_index
-                          || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
-                      {
-                        gripe_missing_glyph (' ');
-                      }
-                    else
-                      {
-                        multiline_align_xoffsets.push_back (box_line_width);
-                        // Reset the pixel width for this newline, so we don't
-                        // allocate a bounding box larger than the horizontal
-                        // width of the multi-line
-                        box_line_width = 0;
-                        bbox(1) -= (face->size->metrics.height >> 6);
-                      }
-                    }
-                  else
-                    {
-                    // width
-                    if (previous)
-                      {
-                        FT_Vector delta;
-
-                        FT_Get_Kerning (face, previous, glyph_index,
-                                        FT_KERNING_DEFAULT, &delta);
-
-                        box_line_width += (delta.x >> 6);
-                      }
-
-                    box_line_width += (face->glyph->advance.x >> 6);
-
-                    int asc, desc;
-
-                    if (false /*tight*/)
-                      {
-                        desc = face->glyph->metrics.horiBearingY - face->glyph->metrics.height;
-                        asc = face->glyph->metrics.horiBearingY;
-                      }
-                    else
-                      {
-                        asc = face->size->metrics.ascender;
-                        desc = face->size->metrics.descender;
-                      }
-
-                    asc = yoffset + (asc >> 6);
-                    desc = yoffset + (desc >> 6);
-
-                    if (desc < bbox(1))
-                      {
-                        bbox(3) += (bbox(1) - desc);
-                        bbox(1) = desc;
-                      }
-                    if (asc > (bbox(3)+bbox(1)))
-                      bbox(3) = asc-bbox(1);
-                    if (bbox(2) < box_line_width)
-                      bbox(2) = box_line_width;
-                  }
-                  break;
-                }
-                if (str[i] == '\n')
-                  previous = 0;
-                else
-                  previous = glyph_index;
-            }
-        }
-      if (mode == MODE_BBOX)
-        {
-          /* Push last the width associated with the last line */
-          multiline_align_xoffsets.push_back (box_line_width);
-
-          for (unsigned int i = 0; i < multiline_align_xoffsets.size (); i++)
-            {
-            /* Center align */
-            if (multiline_halign == 1)
-              multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
-            /* Right align */
-            else if (multiline_halign == 2)
-              multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i]);
-            /* Left align */
-            else
-              multiline_align_xoffsets[i] = 0;
+              if (r != 0)
+                ::warning ("ft_render: failed to decode string `%s' with "
+                           "locale `%s'", str.c_str (),
+                           std::setlocale (LC_CTYPE, NULL));
+              break;
             }
         }
     }
 }
 
 void
+ft_render::visit (text_element_list& e)
+{
+  // Save and restore (after processing the list) the current font and color.
+
+  ft_font saved_font (font);
+  uint8NDArray saved_color (color);
+
+  text_processor::visit (e);
+
+  font = saved_font;
+  color = saved_color;
+}
+
+void
+ft_render::visit (text_element_subscript& e)
+{
+  ft_font saved_font (font);
+  int saved_line_yoffset = line_yoffset;
+  int saved_yoffset = yoffset;
+
+  set_font (font.get_name (), font.get_weight (), font.get_angle (),
+            font.get_size () - 2);
+
+  if (font.is_valid ())
+    {
+      int h = font.get_face ()->size->metrics.height >> 6;
+
+      // Shifting the baseline by 2/3 the font height seems to produce
+      // decent result.
+      yoffset -= (h * 2) / 3;
+
+      if (mode == MODE_BBOX)
+        update_line_bbox ();
+    }
+
+  text_processor::visit (e);
+
+  font = saved_font;
+  // If line_yoffset changed, this means we moved to a new line; hence yoffset
+  // cannot be restored, because the saved value is not relevant anymore.
+  if (line_yoffset == saved_line_yoffset)
+    yoffset = saved_yoffset;
+}
+
+void
+ft_render::visit (text_element_superscript& e)
+{
+  ft_font saved_font (font);
+  int saved_line_yoffset = line_yoffset;
+  int saved_yoffset = yoffset;
+
+  set_font (font.get_name (), font.get_weight (), font.get_angle (),
+            font.get_size () - 2);
+
+  if (saved_font.is_valid ())
+    {
+      int s_asc = saved_font.get_face ()->size->metrics.ascender >> 6;
+
+      // Shifting the baseline by 2/3 base font ascender seems to produce
+      // decent result.
+      yoffset += (s_asc * 2) / 3;
+
+      if (mode == MODE_BBOX)
+        update_line_bbox ();
+    }
+
+  text_processor::visit (e);
+
+  font = saved_font;
+  // If line_yoffset changed, this means we moved to a new line; hence yoffset
+  // cannot be restored, because the saved value is not relevant anymore.
+  if (line_yoffset == saved_line_yoffset)
+    yoffset = saved_yoffset;
+}
+
+void
+ft_render::visit (text_element_color& e)
+{
+  if (mode == MODE_RENDER)
+    set_color (e.get_color ());
+}
+
+void
+ft_render::visit (text_element_fontsize& e)
+{
+  double sz = e.get_fontsize ();
+
+  // FIXME: Matlab documentation says that the font size is expressed
+  //        in the text object FontUnit.
+
+  set_font (font.get_name (), font.get_weight (), font.get_angle (), sz);
+
+  if (mode == MODE_BBOX)
+    update_line_bbox ();
+}
+
+void
+ft_render::visit (text_element_fontname& e)
+{
+  set_font (e.get_fontname (), font.get_weight (), font.get_angle (),
+            font.get_size ());
+
+  if (mode == MODE_BBOX)
+    update_line_bbox ();
+}
+
+void
+ft_render::visit (text_element_fontstyle& e)
+{
+  switch (e.get_fontstyle ())
+    {
+    case text_element_fontstyle::normal:
+      set_font (font.get_name (), "normal", "normal", font.get_size ());
+      break;
+    case text_element_fontstyle::bold:
+      set_font (font.get_name (), "bold", "normal", font.get_size ());
+      break;
+    case text_element_fontstyle::italic:
+      set_font (font.get_name (), "normal", "italic", font.get_size ());
+      break;
+    case text_element_fontstyle::oblique:
+      set_font (font.get_name (), "normal", "oblique", font.get_size ());
+      break;
+    }
+
+  if (mode == MODE_BBOX)
+    update_line_bbox ();
+}
+
+void
+ft_render::visit (text_element_symbol& e)
+{
+  uint32_t code = e.get_symbol_code ();
+
+  if (code != text_element_symbol::invalid_code && font.is_valid ())
+    process_character (code);
+  else if (font.is_valid ())
+    ::warning ("ignoring unknown symbol: %d", e.get_symbol ());
+}
+
+void
+ft_render::visit (text_element_combined& e)
+{
+  int saved_xoffset = xoffset;
+  int max_xoffset = xoffset;
+
+  for (text_element_combined::iterator it = e.begin (); it != e.end (); ++it)
+    {
+      xoffset = saved_xoffset;
+      (*it)->accept (*this);
+      max_xoffset = xmax (xoffset, max_xoffset);
+    }
+
+  xoffset = max_xoffset;
+}
+
+void
 ft_render::reset (void)
 {
   set_mode (MODE_BBOX);
   set_color (Matrix (1, 3, 0.0));
 }
 
 void
 ft_render::set_color (Matrix c)
 {
   if (c.numel () == 3)
     {
-      red = static_cast<uint8_t> (c(0)*255);
-      green = static_cast<uint8_t> (c(1)*255);
-      blue = static_cast<uint8_t> (c(2)*255);
+      color(0) = static_cast<uint8_t> (c(0)*255);
+      color(1) = static_cast<uint8_t> (c(1)*255);
+      color(2) = static_cast<uint8_t> (c(2)*255);
     }
   else
     ::warning ("ft_render::set_color: invalid color");
 }
 
 uint8NDArray
 ft_render::render (text_element* elt, Matrix& box, int rotation)
 {
   set_mode (MODE_BBOX);
   elt->accept (*this);
+  compute_bbox ();
   box = bbox;
 
   set_mode (MODE_RENDER);
   if (pixels.numel () > 0)
     {
       elt->accept (*this);
 
       switch (rotation)
@@ -569,16 +910,17 @@ ft_render::render (text_element* elt, Ma
 // y-extent is overly large because it is measured from baseline-to-baseline.
 // Calling routines, such as ylabel, may need to account for this mismatch.
 
 Matrix
 ft_render::get_extent (text_element *elt, double rotation)
 {
   set_mode (MODE_BBOX);
   elt->accept (*this);
+  compute_bbox ();
 
   Matrix extent (1, 2, 0.0);
 
   switch (rotation_to_mode (rotation))
     {
     case ROTATION_0:
     case ROTATION_180:
       extent(0) = bbox(2);
@@ -589,51 +931,58 @@ ft_render::get_extent (text_element *elt
       extent(0) = bbox(3);
       extent(1) = bbox(2);
     }
 
   return extent;
 }
 
 Matrix
-ft_render::get_extent (const std::string& txt, double rotation)
+ft_render::get_extent (const std::string& txt, double rotation,
+                       const caseless_str& interpreter)
 {
-  text_element *elt = text_parser_none ().parse (txt);
+  text_element *elt = text_parser::parse (txt, interpreter);
   Matrix extent = get_extent (elt, rotation);
   delete elt;
 
   return extent;
 }
 
 int
 ft_render::rotation_to_mode (double rotation) const
 {
+  // Clip rotation to range [0, 360]
+  while (rotation < 0)
+    rotation += 360.0;
+  while (rotation > 360.0)
+    rotation -= 360.0;
+
   if (rotation == 0.0)
     return ROTATION_0;
   else if (rotation == 90.0)
     return ROTATION_90;
   else if (rotation == 180.0)
     return ROTATION_180;
   else if (rotation == 270.0)
     return ROTATION_270;
   else
     return ROTATION_0;
 }
 
 void
 ft_render::text_to_pixels (const std::string& txt,
                            uint8NDArray& pixels_, Matrix& box,
-                           int halign, int valign, double rotation)
+                           int _halign, int valign, double rotation,
+                           const caseless_str& interpreter)
 {
-  // FIXME: clip "rotation" between 0 and 360
   int rot_mode = rotation_to_mode (rotation);
 
-  multiline_halign = halign;
+  halign = _halign;
 
-  text_element *elt = text_parser_none ().parse (txt);
+  text_element *elt = text_parser::parse (txt, interpreter);
   pixels_ = render (elt, box, rot_mode);
   delete elt;
 
   if (pixels_.numel () == 0)
     {
       // nothing to render
       return;
     }
@@ -667,9 +1016,66 @@ ft_render::text_to_pixels (const std::st
     case ROTATION_270:
       std::swap (box(0), box(1));
       std::swap (box(2), box(3));
       box(1) = -box(1)-box(3);
       break;
     }
 }
 
+ft_render::ft_font::ft_font (const ft_font& ft)
+     : name (ft.name), weight (ft.weight), angle (ft.angle), size (ft.size),
+       face (0)
+{
+#if HAVE_FT_REFERENCE_FACE
+  FT_Face ft_face = ft.get_face ();
+
+  if (ft_face && FT_Reference_Face (ft_face) == 0)
+    face = ft_face;
+#endif
+}
+
+ft_render::ft_font&
+ft_render::ft_font::operator = (const ft_font& ft)
+{
+  if (&ft != this)
+    {
+      name = ft.name;
+      weight = ft.weight;
+      angle = ft.angle;
+      size = ft.size;
+      if (face)
+        {
+          FT_Done_Face (face);
+          face = 0;
+        }
+
+#if HAVE_FT_REFERENCE_FACE
+      FT_Face ft_face = ft.get_face ();
+
+      if (ft_face && FT_Reference_Face (ft_face) == 0)
+        face = ft_face;
+#endif
+    }
+
+  return *this;
+}
+
+FT_Face
+ft_render::ft_font::get_face (void) const
+{
+  if (! face && ! name.empty ())
+    {
+      face = ft_manager::get_font (name, weight, angle, size);
+
+      if (face)
+        {
+          if (FT_Set_Char_Size (face, 0, size*64, 0, 0))
+            ::warning ("ft_render: unable to set font size to %g", size);
+        }
+      else
+        ::warning ("ft_render: unable to load appropriate font");
+    }
+
+  return face;
+}
+
 #endif // HAVE_FREETYPE
diff --git a/libinterp/corefcn/txt-eng-ft.h b/libinterp/corefcn/txt-eng-ft.h
--- a/libinterp/corefcn/txt-eng-ft.h
+++ b/libinterp/corefcn/txt-eng-ft.h
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (txt_eng_ft_h)
 #define txt_eng_ft_h 1
 
 #if HAVE_FREETYPE
 
+#include <list>
 #include <vector>
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 
 #include <dMatrix.h>
 #include <uint8NDArray.h>
 #include "txt-eng.h"
@@ -53,55 +54,155 @@ public:
 
 public:
   ft_render (void);
 
   ~ft_render (void);
 
   void visit (text_element_string& e);
 
+  void visit (text_element_list& e);
+
+  void visit (text_element_subscript& e);
+
+  void visit (text_element_superscript& e);
+
+  void visit (text_element_color& e);
+
+  void visit (text_element_fontsize& e);
+
+  void visit (text_element_fontname& e);
+
+  void visit (text_element_fontstyle& e);
+
+  void visit (text_element_symbol& e);
+
+  void visit (text_element_combined& e);
+
   void reset (void);
 
   uint8NDArray get_pixels (void) const { return pixels; }
 
   Matrix get_boundingbox (void) const { return bbox; }
 
   uint8NDArray render (text_element* elt, Matrix& box,
                        int rotation = ROTATION_0);
 
   Matrix get_extent (text_element *elt, double rotation = 0.0);
-  Matrix get_extent (const std::string& txt, double rotation = 0.0);
+  Matrix get_extent (const std::string& txt, double rotation = 0.0,
+                     const caseless_str& interpreter = "tex");
 
   void set_font (const std::string& name, const std::string& weight,
                  const std::string& angle, double size);
 
   void set_color (Matrix c);
 
   void set_mode (int m);
 
   void text_to_pixels (const std::string& txt,
                        uint8NDArray& pixels_, Matrix& bbox,
-                       int halign, int valign, double rotation);
+                       int halign, int valign, double rotation,
+                       const caseless_str& interpreter = "tex");
 
 private:
   int rotation_to_mode (double rotation) const;
 
   // No copying!
 
   ft_render (const ft_render&);
 
   ft_render& operator = (const ft_render&);
 
+  // Class to hold information about fonts and a strong
+  // reference to the font objects loaded by freetype.
+  class ft_font
+    {
+    public:
+      ft_font (void)
+        : name (), weight (), angle (), size (0), face (0) { }
+
+      ft_font (const std::string& nm, const std::string& wt,
+               const std::string& ang, double sz, FT_Face f = 0)
+        : name (nm), weight (wt), angle (ang), size (sz), face (f) { }
+
+      ft_font (const ft_font& ft);
+
+      ~ft_font (void)
+        {
+          if (face)
+            FT_Done_Face (face);
+        }
+
+      ft_font& operator = (const ft_font& ft);
+
+      bool is_valid (void) const { return get_face (); }
+
+      std::string get_name (void) const { return name; }
+
+      std::string get_weight (void) const { return weight; }
+
+      std::string get_angle (void) const { return angle; }
+
+      double get_size (void) const { return size; }
+
+      FT_Face get_face (void) const;
+
+    private:
+      std::string name;
+      std::string weight;
+      std::string angle;
+      double size;
+      mutable FT_Face face;
+    };
+
+  void push_new_line (void);
+
+  void update_line_bbox (void);
+
+  void compute_bbox (void);
+
+  int compute_line_xoffset (const Matrix& lb) const;
+
+  FT_UInt process_character (FT_ULong code, FT_UInt previous = 0);
+
 private:
-  FT_Face face;
+  // The current font used by the renderer.
+  ft_font font;
+
+  // Used to stored the bounding box corresponding to the rendered text.
+  // The bounding box has the form [x, y, w, h] where x and y represent the
+  // coordinates of the bottom left corner relative to the anchor point of
+  // the text (== start of text on the baseline). Due to font descent or
+  // multiple lines, the value y is usually negative.
   Matrix bbox;
+
+  // Used to stored the rendered text. It's a 3D matrix with size MxNx4
+  // where M and N are the width and height of the bounding box.
   uint8NDArray pixels;
+
+  // Used to store the bounding box of each line. This is used to layout
+  // multiline text properly.
+  std::list<Matrix> line_bbox;
+
+  // The current horizontal alignment. This is used to align multi-line text.
+  int halign;
+
+  // The X offset for the next glyph.
   int xoffset;
+
+  // The Y offset of the baseline for the current line.
+  int line_yoffset;
+
+  // The Y offset of the baseline for the next glyph. The offset is relative
+  // to line_yoffset. The total Y offset is computed with:
+  // line_yoffset + yoffset.
   int yoffset;
-  int multiline_halign;
-  std::vector<int> multiline_align_xoffsets;
+
+  // The current mode of the rendering process (box computing or rendering).
   int mode;
-  uint8_t red, green, blue;
+
+  // The base color of the rendered text.
+  uint8NDArray color;
 };
 
 #endif // HAVE_FREETYPE
 
 #endif
diff --git a/libinterp/corefcn/txt-eng.cc b/libinterp/corefcn/txt-eng.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/txt-eng.cc
@@ -0,0 +1,39 @@
+/*
+
+Copyright (C) 2013 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "txt-eng.h"
+#include "oct-tex-symbols.cc"
+
+uint32_t
+text_element_symbol::get_symbol_code (void) const
+{
+  uint32_t code = invalid_code;
+
+  if (0 <= symbol && symbol < num_symbol_codes)
+    code = symbol_codes[symbol][0];
+
+  return code;
+}
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -18,23 +18,34 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (txt_eng_h)
 #define txt_eng_h 1
 
+#include <memory>
+#include <string>
+
 #include "base-list.h"
+#include "caseless-str.h"
+#include "dMatrix.h"
 
 class text_element;
 class text_element_string;
+class text_element_symbol;
 class text_element_list;
-class text_subscript_element;
-class text_superscript_element;
+class text_element_subscript;
+class text_element_superscript;
+class text_element_combined;
+class text_element_fontname;
+class text_element_fontsize;
+class text_element_fontstyle;
+class text_element_color;
 
 class text_processor;
 
 class
 OCTINTERP_API
 text_element
 {
 public:
@@ -49,130 +60,332 @@ private:
 };
 
 class
 OCTINTERP_API
 text_element_string : public text_element
 {
 public:
   text_element_string (const std::string& s = "")
-      : text_element (), str (s) { }
+    : text_element (), str (s) { }
 
   ~text_element_string (void) { }
 
   std::string string_value (void) const { return str; }
 
   void accept (text_processor& p);
 
 private:
   std::string str;
 
 private:
   text_element_string (const text_element_string &);
 };
 
 class
 OCTINTERP_API
+text_element_symbol : public text_element
+{
+public:
+  enum { invalid_code = 0xFFFFFFFFU };
+
+public:
+  text_element_symbol (int sym)
+    : text_element (), symbol (sym) { }
+
+  ~text_element_symbol (void) { }
+
+  int get_symbol (void) const { return symbol; }
+
+  uint32_t get_symbol_code (void) const;
+
+  void accept (text_processor& p);
+
+private:
+  int symbol;
+};
+
+class
+OCTINTERP_API
 text_element_list :
     public text_element,
     public octave_base_list<text_element *>
 {
 public:
   text_element_list (void)
-      : text_element (), octave_base_list<text_element*> () { }
+    : text_element (), octave_base_list<text_element*> () { }
+
+  text_element_list (text_element* e)
+    : text_element (), octave_base_list<text_element*> ()
+    { push_back (e); }
 
   ~text_element_list (void)
     {
       while (! empty ())
         {
           iterator it = begin ();
           delete (*it);
           erase (it);
         }
     }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
-text_subscript_element : public text_element_list
+text_element_subscript : public text_element
+{
+public:
+  text_element_subscript (text_element* e)
+    : text_element (), elem (e) { }
+
+  text_element_subscript (char c)
+    : text_element ()
+    { elem = new text_element_string (std::string (1, c)); }
+
+  ~text_element_subscript (void)
+    { delete elem; }
+
+  void accept (text_processor& p);
+
+  text_element* get_element (void) { return elem; }
+
+private:
+  text_element* elem;
+
+private:
+  text_element_subscript (void);
+};
+
+class
+OCTINTERP_API
+text_element_superscript : public text_element
 {
 public:
-  text_subscript_element (void)
-      : text_element_list () { }
+  text_element_superscript (text_element* e)
+    : text_element (), elem (e) { }
+
+  text_element_superscript (char c)
+    : text_element ()
+    { elem = new text_element_string (std::string (1, c)); }
+
+  ~text_element_superscript (void)
+    { delete elem; }
+
+  void accept (text_processor& p);
+
+  text_element* get_element (void) { return elem; }
 
-  ~text_subscript_element (void) { }
+private:
+  text_element* elem;
+
+private:
+  text_element_superscript (void);
+};
+
+class
+OCTINTERP_API
+text_element_combined : public text_element_list
+{
+public:
+  text_element_combined (text_element* e)
+    : text_element_list (e) { }
+
+  text_element_combined (text_element* e1, text_element* e2)
+    : text_element_list(e1)
+    { push_back (e2); }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
-text_superscript_element : public text_element_list
+text_element_fontstyle : public text_element
+{
+public:
+  enum fontstyle
+    {
+      normal,
+      bold,
+      italic,
+      oblique
+    };
+
+  text_element_fontstyle (fontstyle st)
+    : text_element (), style (st) { }
+
+  ~text_element_fontstyle (void) { }
+
+  fontstyle get_fontstyle (void) const { return style; }
+
+  void accept (text_processor& p);
+
+private:
+  fontstyle style;
+
+private:
+  text_element_fontstyle (void);
+};
+
+class
+OCTINTERP_API
+text_element_fontname : public text_element
+{
+public:
+  text_element_fontname (const std::string& fname)
+    : text_element (), name (fname) { }
+
+  ~text_element_fontname (void) { }
+
+  const std::string& get_fontname (void) const { return name; }
+
+  void accept (text_processor& p);
+
+private:
+  std::string name;
+
+private:
+  text_element_fontname (void);
+};
+
+class
+OCTINTERP_API
+text_element_fontsize : public text_element
 {
 public:
-  text_superscript_element (void)
-      : text_element_list () { }
+  text_element_fontsize (double fsize)
+    : text_element (), size (fsize) { }
 
-  ~text_superscript_element (void) { }
+  ~text_element_fontsize (void) { }
+
+  double get_fontsize (void) const { return size; }
 
   void accept (text_processor& p);
+
+private:
+  double size;
+
+private:
+  text_element_fontsize (void);
+};
+
+class
+OCTINTERP_API
+text_element_color : public text_element
+{
+public:
+  text_element_color (double r, double g, double b)
+    : text_element (), rgb (1, 3, 0.0)
+    {
+      rgb(0) = r;
+      rgb(1) = g;
+      rgb(2) = b;
+    }
+
+  text_element_color (const std::string& cname)
+    : text_element (), rgb (1, 3, 0.0)
+    {
+#define ASSIGN_COLOR(r,g,b) { rgb(0) = r; rgb(1) = g; rgb(2) = b; }
+      if (cname == "red") ASSIGN_COLOR(1, 0, 0)
+      else if (cname == "green") ASSIGN_COLOR(0, 1, 0)
+      else if (cname == "yellow") ASSIGN_COLOR(1, 1, 0)
+      else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
+      else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
+      else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
+      else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
+      else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
+      else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
+      else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
+      else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
+#undef ASSIGN_COLOR
+    }
+
+  ~text_element_color (void) { }
+
+  Matrix get_color (void) { return rgb; }
+
+  void accept (text_processor& p);
+
+private:
+  Matrix rgb;
 };
 
 class
 OCTINTERP_API
 text_processor
 {
 public:
   virtual void visit (text_element_string& e) = 0;
 
+  virtual void visit (text_element_symbol&) { }
+
   virtual void visit (text_element_list& e)
     {
       for (text_element_list::iterator it = e.begin ();
            it != e.end (); ++it)
         {
           (*it)->accept (*this);
         }
     }
 
-  virtual void visit (text_subscript_element& e)
-    { visit (dynamic_cast<text_element_list&> (e)); }
+  virtual void visit (text_element_subscript& e)
+    { e.get_element ()->accept (*this); }
+
+  virtual void visit (text_element_superscript& e)
+    { e.get_element ()->accept (*this); }
+
+  virtual void visit (text_element_combined&) { }
 
-  virtual void visit (text_superscript_element& e)
-    { visit (dynamic_cast<text_element_list&> (e)); }
+  virtual void visit (text_element_fontstyle&) { }
+
+  virtual void visit (text_element_fontname&) { }
+
+  virtual void visit (text_element_fontsize&) { }
+
+  virtual void visit (text_element_color&) { }
 
   virtual void reset (void) { }
 
 protected:
   text_processor (void) { }
 
   virtual ~text_processor (void) { }
 };
 
 #define TEXT_ELEMENT_ACCEPT(cls) \
 inline void \
 cls::accept (text_processor& p) \
 { p.visit (*this); }
 
 TEXT_ELEMENT_ACCEPT(text_element_string)
+TEXT_ELEMENT_ACCEPT(text_element_symbol)
 TEXT_ELEMENT_ACCEPT(text_element_list)
-TEXT_ELEMENT_ACCEPT(text_subscript_element)
-TEXT_ELEMENT_ACCEPT(text_superscript_element)
+TEXT_ELEMENT_ACCEPT(text_element_subscript)
+TEXT_ELEMENT_ACCEPT(text_element_superscript)
+TEXT_ELEMENT_ACCEPT(text_element_combined)
+TEXT_ELEMENT_ACCEPT(text_element_fontstyle)
+TEXT_ELEMENT_ACCEPT(text_element_fontname)
+TEXT_ELEMENT_ACCEPT(text_element_fontsize)
+TEXT_ELEMENT_ACCEPT(text_element_color)
 
 class
 OCTINTERP_API
 text_parser
 {
 public:
   text_parser (void) { }
 
   virtual ~text_parser (void) { }
 
   virtual text_element* parse (const std::string& s) = 0;
+
+public:
+  static text_element* parse (const std::string& s,
+                              const caseless_str& interpreter);
 };
 
 class
 OCTINTERP_API
 text_parser_none : public text_parser
 {
 public:
   text_parser_none (void) : text_parser () { }
@@ -185,9 +398,55 @@ public:
   // creates...
 
   text_element* parse (const std::string& s)
     {
       return new text_element_string (s);
     }
 };
 
+class
+OCTINTERP_API
+text_parser_tex : public text_parser
+{
+public:
+  text_parser_tex (void)
+    : text_parser (), scanner (0), buffer_state (0), result (0)
+    { }
+
+  ~text_parser_tex (void)
+    { destroy_lexer (); }
+
+  text_element* parse (const std::string& s);
+
+  void* get_scanner (void) { return scanner; }
+
+  void set_parse_result (text_element* e) { result = e; }
+
+  text_element* get_parse_result (void) { return result; }
+
+private:
+  bool init_lexer (const std::string& s);
+
+  void destroy_lexer (void);
+
+private:
+  void* scanner;
+
+  void* buffer_state;
+
+  text_element* result;
+};
+
+inline text_element*
+text_parser::parse (const std::string& s, const caseless_str& interpreter)
+{
+  std::auto_ptr<text_parser> parser;
+
+  if (interpreter.compare ("tex"))
+    parser.reset (new text_parser_tex ());
+  else
+    parser.reset (new text_parser_none ());
+
+  return parser->parse (s);
+}
+
 #endif
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <climits>
+#include <limits>
 
 #include "mx-base.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
@@ -116,20 +116,20 @@ of @var{x} and @var{class} must be one o
 \n\
 @noindent\n\
 the last two are reserved for @var{class}; they indicate that a\n\
 complex-valued result is requested.  Complex arrays are stored in memory as\n\
 consecutive pairs of real numbers.  The sizes of integer types are given by\n\
 their bit counts.  Both logical and char are typically one byte wide;\n\
 however, this is not guaranteed by C++.  If your system is IEEE conformant,\n\
 single and double should be 4 bytes and 8 bytes wide, respectively.\n\
-\"logical\" is not allowed for @var{class}.  If the input is a row vector,\n\
-the return value is a row vector, otherwise it is a column vector.  If the\n\
-bit length of @var{x} is not divisible by that of @var{class}, an error\n\
-occurs.\n\
+@qcode{\"logical\"} is not allowed for @var{class}.  If the input is a row\n\
+vector, the return value is a row vector, otherwise it is a column vector.  \n\
+If the bit length of @var{x} is not divisible by that of @var{class}, an\n\
+error occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
 typecast (@var{x}, \"uint8\")\n\
 @result{} [   1,   0, 255, 255]\n\
@@ -237,36 +237,36 @@ typecast (@var{x}, \"uint8\")\n\
   return retval;
 }
 
 template <class ArrayType>
 ArrayType
 do_bitpack (const boolNDArray& bitp)
 {
   typedef typename ArrayType::element_type T;
-  octave_idx_type n = bitp.numel () / (sizeof (T) * CHAR_BIT);
+  octave_idx_type n = bitp.numel () / (sizeof (T) * std::numeric_limits<unsigned char>::digits);
 
-  if (n * static_cast<int> (sizeof (T)) * CHAR_BIT == bitp.numel ())
+  if (n * static_cast<int> (sizeof (T)) * std::numeric_limits<unsigned char>::digits == bitp.numel ())
     {
 
       ArrayType retval (get_vec_dims (bitp.dims (), n));
 
       const bool *bits = bitp.fortran_vec ();
       char *packed = reinterpret_cast<char *> (retval.fortran_vec ());
 
       octave_idx_type m = n * sizeof (T);
 
       for (octave_idx_type i = 0; i < m; i++)
         {
           char c = bits[0];
-          for (int j = 1; j < CHAR_BIT; j++)
+          for (int j = 1; j < std::numeric_limits<unsigned char>::digits; j++)
             c |= bits[j] << j;
 
           packed[i] = c;
-          bits += CHAR_BIT;
+          bits += std::numeric_limits<unsigned char>::digits;
         }
 
       return retval;
     }
   else
     {
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
@@ -356,32 +356,32 @@ it is a column vector.\n\
   return retval;
 }
 
 template <class ArrayType>
 boolNDArray
 do_bitunpack (const ArrayType& array)
 {
   typedef typename ArrayType::element_type T;
-  octave_idx_type n = array.numel () * sizeof (T) * CHAR_BIT;
+  octave_idx_type n = array.numel () * sizeof (T) * std::numeric_limits<unsigned char>::digits;
 
   boolNDArray retval (get_vec_dims (array.dims (), n));
 
   const char *packed = reinterpret_cast<const char *> (array.fortran_vec ());
   bool *bits = retval.fortran_vec ();
 
-  octave_idx_type m = n / CHAR_BIT;
+  octave_idx_type m = n / std::numeric_limits<unsigned char>::digits;
 
   for (octave_idx_type i = 0; i < m; i++)
     {
       char c = packed[i];
       bits[0] = c & 1;
-      for (int j = 1; j < CHAR_BIT; j++)
+      for (int j = 1; j < std::numeric_limits<unsigned char>::digits; j++)
         bits[j] = (c >>= 1) & 1;
-      bits += CHAR_BIT;
+      bits += std::numeric_limits<unsigned char>::digits;
     }
 
   return retval;
 }
 
 DEFUN (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} bitunpack (@var{x})\n\
diff --git a/libinterp/dldfcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
rename from libinterp/dldfcn/urlwrite.cc
rename to libinterp/corefcn/urlwrite.cc
--- a/libinterp/dldfcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -33,662 +33,261 @@ along with Octave; see the file COPYING.
 #include <fstream>
 #include <iomanip>
 #include <iostream>
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
+#include "oct-handle.h"
 #include "glob-match.h"
+#include "singleton-cleanup.h"
+#include "url-transfer.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "unwind-prot.h"
 
-#ifdef HAVE_CURL
-
-#include <curl/curl.h>
-#include <curl/curlver.h>
-#include <curl/easy.h>
-
-static int
-write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
+static void
+delete_file (const std::string& file)
 {
-  std::ostream& stream = *(static_cast<std::ostream*> (streamp));
-  stream.write (static_cast<const char*> (buffer), size*nmemb);
-  return (stream.fail () ? 0 : size * nmemb);
-}
-
-static int
-read_data (void *buffer, size_t size, size_t nmemb, void *streamp)
-{
-  std::istream& stream = *(static_cast<std::istream*> (streamp));
-  stream.read (static_cast<char*> (buffer), size*nmemb);
-  if (stream.eof ())
-    return stream.gcount ();
-  else
-    return (stream.fail () ? 0 : size * nmemb);
-}
-
-static size_t
-throw_away (void *, size_t size, size_t nmemb, void *)
-{
-  return static_cast<size_t>(size * nmemb);
+  octave_unlink (file);
 }
 
-class
-curl_handle
-{
-private:
-  class
-  curl_handle_rep
-  {
-  public:
-    curl_handle_rep (void) : count (1), valid (true), ascii (false)
-      {
-        curl = curl_easy_init ();
-        if (!curl)
-          error ("can not create curl handle");
-      }
-
-    ~curl_handle_rep (void)
-      {
-        if (curl)
-          curl_easy_cleanup (curl);
-      }
-
-    bool is_valid (void) const
-      {
-        return valid;
-      }
-
-    bool perform (bool curlerror) const
-      {
-        bool retval = false;
-        if (!error_state)
-          {
-            BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+typedef octave_handle curl_handle;
 
-            errnum = curl_easy_perform (curl);
-            if (errnum != CURLE_OK)
-              {
-                if (curlerror)
-                  error ("%s", curl_easy_strerror (errnum));
-              }
-            else
-              retval = true;
-
-            END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          }
-        return retval;
-      }
-
-    CURL* handle (void) const
-      {
-        return curl;
-      }
+class OCTINTERP_API ch_manager
+{
+protected:
 
-    bool is_ascii (void) const
-      {
-        return ascii;
-      }
-
-    bool is_binary (void) const
-      {
-        return !ascii;
-      }
-
-    octave_refcount<size_t> count;
-    std::string host;
-    std::string url;
-    std::string userpwd;
-    bool valid;
-    bool ascii;
-    mutable CURLcode errnum;
-
-  private:
-    CURL *curl;
-
-    // No copying!
-
-    curl_handle_rep (const curl_handle_rep& ov);
-
-    curl_handle_rep& operator = (const curl_handle_rep&);
-  };
+  ch_manager (void)
+    : handle_map (), handle_free_list (),
+      next_handle (-1.0 - (rand () + 1.0) / (RAND_MAX + 2.0)) { }
 
 public:
 
-// I'd love to rewrite this as a private method of the curl_handle
-// class, but you can't pass the va_list from the wrapper setopt to
-// the curl_easy_setopt function.
-#define setopt(option, parameter) \
-  { \
-    CURLcode res = curl_easy_setopt (rep->handle (), option, parameter); \
-    if (res != CURLE_OK) \
-      error ("%s", curl_easy_strerror (res)); \
+  static void create_instance (void);
+
+  static bool instance_ok (void)
+  {
+    bool retval = true;
+
+    if (! instance)
+      create_instance ();
+
+    if (! instance)
+      {
+        ::error ("unable to create ch_manager!");
+
+        retval = false;
+      }
+
+    return retval;
+  }
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
+  static curl_handle get_handle (void)
+  {
+    return instance_ok ()
+      ? instance->do_get_handle () : curl_handle ();
+  }
+
+  static void free (const curl_handle& h)
+  {
+    if (instance_ok ())
+      instance->do_free (h);
+  }
+
+  static curl_handle lookup (double val)
+  {
+    return instance_ok () ? instance->do_lookup (val) : curl_handle ();
+  }
+
+  static curl_handle lookup (const octave_value& val)
+  {
+    return val.is_real_scalar ()
+      ? lookup (val.double_value ()) : curl_handle ();
+  }
+
+  static url_transfer get_object (double val)
+  {
+    return get_object (lookup (val));
+  }
+
+  static url_transfer get_object (const octave_value& val)
+  {
+    return get_object (lookup (val));
+  }
+
+  static url_transfer get_object (const curl_handle& h)
+  {
+    return instance_ok () ? instance->do_get_object (h) : url_transfer ();
+  }
+
+  static curl_handle make_curl_handle (const std::string& host,
+                                       const std::string& user,
+                                       const std::string& passwd,
+                                       std::ostream& os)
+  {
+    return instance_ok ()
+      ? instance->do_make_curl_handle (host, user, passwd, os) : curl_handle ();
+  }
+
+  static Matrix handle_list (void)
+  {
+    return instance_ok () ? instance->do_handle_list () : Matrix ();
   }
 
-  curl_handle (void) : rep (new curl_handle_rep ())
-    {
-      rep->valid = false;
-    }
+private:
 
-  curl_handle (const std::string& _host, const std::string& user,
-               const std::string& passwd) :
-    rep (new curl_handle_rep ())
-    {
-      rep->host = _host;
-      init (user, passwd, std::cin, octave_stdout);
+  static ch_manager *instance;
 
-      rep->url = "ftp://" + _host;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-
-      // Setup the link, with no transfer
-      if (!error_state)
-        perform ();
-    }
+  typedef std::map<curl_handle, url_transfer>::iterator iterator;
+  typedef std::map<curl_handle, url_transfer>::const_iterator const_iterator;
 
-  curl_handle (const std::string& url, const std::string& method,
-               const Cell& param, std::ostream& os, bool& retval) :
-    rep (new curl_handle_rep ())
-    {
-      retval = false;
+  typedef std::set<curl_handle>::iterator free_list_iterator;
+  typedef std::set<curl_handle>::const_iterator const_free_list_iterator;
 
-      init ("", "", std::cin, os);
+  // A map of handles to curl objects.
+  std::map<curl_handle, url_transfer> handle_map;
 
-      setopt (CURLOPT_NOBODY, 0);
+  // The available curl handles.
+  std::set<curl_handle> handle_free_list;
 
-      // Restore the default HTTP request method to GET after setting
-      // NOBODY to true and back to false.  This is needed for backward
-      // compatibility with versions of libcurl < 7.18.2.
-      setopt (CURLOPT_HTTPGET, 1);
-
-      // Don't need to store the parameters here as we can't change
-      // the URL after the handle is created
-      std::string query_string = form_query_string (param);
+  // The next handle available if handle_free_list is empty.
+  double next_handle;
 
-      if (method == "get")
-        {
-          query_string = url + "?" + query_string;
-          setopt (CURLOPT_URL, query_string.c_str ());
-        }
-      else if (method == "post")
-        {
-          setopt (CURLOPT_URL, url.c_str ());
-          setopt (CURLOPT_POSTFIELDS, query_string.c_str ());
-        }
-      else
-        setopt (CURLOPT_URL, url.c_str ());
+  curl_handle do_get_handle (void);
+
+  void do_free (const curl_handle& h);
 
-      if (!error_state)
-        retval = perform (false);
-    }
+  curl_handle do_lookup (double val)
+  {
+    iterator p = (xisnan (val) ? handle_map.end () : handle_map.find (val));
 
-  curl_handle (const curl_handle& h) : rep (h.rep)
-    {
-      rep->count++;
-    }
-
-  ~curl_handle (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+    return (p != handle_map.end ()) ? p->first : curl_handle ();
+  }
 
-  curl_handle& operator = (const curl_handle& h)
-    {
-      if (this != &h)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  url_transfer do_get_object (const curl_handle& h)
+  {
+    iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
-          rep = h.rep;
-          rep->count++;
-        }
-      return *this;
-    }
+    return (p != handle_map.end ()) ? p->second : url_transfer ();
+  }
 
-  bool is_valid (void) const
-    {
-      return rep->is_valid ();
-    }
-
-  std::string lasterror (void) const
-    {
-      return std::string (curl_easy_strerror (rep->errnum));
-    }
-
-  void set_ostream (std::ostream& os) const
-    {
-      setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
-    }
+  curl_handle do_make_curl_handle (const std::string& host,
+                                   const std::string& user,
+                                   const std::string& passwd,
+                                   std::ostream& os)
+  {
+    curl_handle h = get_handle ();
 
-  void set_istream (std::istream& is) const
-    {
-      setopt (CURLOPT_READDATA, static_cast<void*> (&is));
-    }
+    url_transfer obj (host, user, passwd, os);
 
-  void ascii (void) const
-    {
-      setopt (CURLOPT_TRANSFERTEXT, 1);
-      rep->ascii = true;
-    }
+    if (! error_state)
+      handle_map[h] = obj;
+    else
+      h = curl_handle ();
 
-  void binary (void) const
-    {
-      setopt (CURLOPT_TRANSFERTEXT, 0);
-      rep->ascii = false;
-    }
+    return h;
+  }
 
-  bool is_ascii (void) const
-    {
-      return rep->is_ascii ();
-    }
+  Matrix do_handle_list (void)
+  {
+    Matrix retval (1, handle_map.size ());
 
-  bool is_binary (void) const
-    {
-      return rep->is_binary ();
-    }
+    octave_idx_type i = 0;
+    for (const_iterator p = handle_map.begin (); p != handle_map.end (); p++)
+      {
+        curl_handle h = p->first;
 
-  void cwd (const std::string& path) const
-    {
-      struct curl_slist *slist = 0;
-      std::string cmd = "cwd " + path;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      setopt (CURLOPT_POSTQUOTE, slist);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-    }
+        retval(i++) = h.value ();
+      }
+
+    return retval;
+  }
+};
+
+void
+ch_manager::create_instance (void)
+{
+  instance = new ch_manager ();
 
-  void del (const std::string& file) const
-    {
-      struct curl_slist *slist = 0;
-      std::string cmd = "dele " + file;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      setopt (CURLOPT_POSTQUOTE, slist);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-    }
+  if (instance)
+    singleton_cleanup_list::add (cleanup_instance);
+}
+
+static double
+make_handle_fraction (void)
+{
+  static double maxrand = RAND_MAX + 2.0;
+
+  return (rand () + 1.0) / maxrand;
+}
 
-  void rmdir (const std::string& path) const
-    {
-      struct curl_slist *slist = 0;
-      std::string cmd = "rmd " + path;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      setopt (CURLOPT_POSTQUOTE, slist);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-    }
+curl_handle
+ch_manager::do_get_handle (void)
+{
+  curl_handle retval;
 
-  bool mkdir (const std::string& path, bool curlerror = true) const
+  // Curl handles are negative integers plus some random fractional
+  // part.  To avoid running out of integers, we recycle the integer
+  // part but tack on a new random part each time.
+
+  free_list_iterator p = handle_free_list.begin ();
+
+  if (p != handle_free_list.end ())
     {
-      bool retval = false;
-      struct curl_slist *slist = 0;
-      std::string cmd = "mkd " + path;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      setopt (CURLOPT_POSTQUOTE, slist);
-      if (! error_state)
-        retval = perform (curlerror);
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-      return retval;
+      retval = *p;
+      handle_free_list.erase (p);
     }
-
-  void rename (const std::string& oldname, const std::string& newname) const
-    {
-      struct curl_slist *slist = 0;
-      std::string cmd = "rnfr " + oldname;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      cmd = "rnto " + newname;
-      slist = curl_slist_append (slist, cmd.c_str ());
-      setopt (CURLOPT_POSTQUOTE, slist);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-    }
-
-  void put (const std::string& file, std::istream& is) const
+  else
     {
-      rep->url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-      setopt (CURLOPT_UPLOAD, 1);
-      setopt (CURLOPT_NOBODY, 0);
-      set_istream (is);
-      if (! error_state)
-        perform ();
-      set_istream (std::cin);
-      setopt (CURLOPT_NOBODY, 1);
-      setopt (CURLOPT_UPLOAD, 0);
-      rep->url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-    }
+      retval = curl_handle (next_handle);
 
-  void get (const std::string& file, std::ostream& os) const
-    {
-      rep->url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-      setopt (CURLOPT_NOBODY, 0);
-      set_ostream (os);
-      if (! error_state)
-        perform ();
-      set_ostream (octave_stdout);
-      setopt (CURLOPT_NOBODY, 1);
-      rep->url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-    }
-
-  void dir (void) const
-    {
-      rep->url = "ftp://" + rep->host + "/";
-      setopt (CURLOPT_URL, rep->url.c_str ());
-      setopt (CURLOPT_NOBODY, 0);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_NOBODY, 1);
-      rep->url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, rep->url.c_str ());
+      next_handle = std::ceil (next_handle) - 1.0 - make_handle_fraction ();
     }
 
-  string_vector list (void) const
-    {
-      std::ostringstream buf;
-      rep->url = "ftp://" + rep->host + "/";
-      setopt (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
-      setopt (CURLOPT_URL, rep->url.c_str ());
-      setopt (CURLOPT_DIRLISTONLY, 1);
-      setopt (CURLOPT_NOBODY, 0);
-      if (! error_state)
-        perform ();
-      setopt (CURLOPT_NOBODY, 1);
-      rep->url = "ftp://" + rep->host;
-      setopt (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
-      setopt (CURLOPT_DIRLISTONLY, 0);
-      setopt (CURLOPT_URL, rep->url.c_str ());
-
-      // Count number of directory entries
-      std::string str = buf.str ();
-      octave_idx_type n = 0;
-      size_t pos = 0;
-      while (true)
-        {
-          pos = str.find_first_of ('\n', pos);
-          if (pos == std::string::npos)
-            break;
-          pos++;
-          n++;
-        }
-      string_vector retval (n);
-      pos = 0;
-      for (octave_idx_type i = 0; i < n; i++)
-        {
-          size_t newpos = str.find_first_of ('\n', pos);
-          if (newpos == std::string::npos)
-            break;
-
-          retval(i) = str.substr(pos, newpos - pos);
-          pos = newpos + 1;
-        }
-      return retval;
-    }
-
-  void get_fileinfo (const std::string& filename, double& filesize,
-                     time_t& filetime, bool& fileisdir) const
-    {
-      std::string path = pwd ();
-
-      rep->url = "ftp://" + rep->host + "/" + path + "/" + filename;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-      setopt (CURLOPT_FILETIME, 1);
-      setopt (CURLOPT_HEADERFUNCTION, throw_away);
-      setopt (CURLOPT_WRITEFUNCTION, throw_away);
-
-      // FIXME
-      // The MDTM command fails for a directory on the servers I tested
-      // so this is a means of testing for directories. It also means
-      // I can't get the date of directories!
-      if (! error_state)
-        {
-          if (! perform (false))
-            {
-              fileisdir = true;
-              filetime = -1;
-              filesize = 0;
-            }
-          else
-            {
-              fileisdir = false;
-              time_t ft;
-              curl_easy_getinfo (rep->handle (), CURLINFO_FILETIME, &ft);
-              filetime = ft;
-              double fs;
-              curl_easy_getinfo (rep->handle (),
-                                 CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
-              filesize = fs;
-            }
-        }
-
-      setopt (CURLOPT_WRITEFUNCTION, write_data);
-      setopt (CURLOPT_HEADERFUNCTION, 0);
-      setopt (CURLOPT_FILETIME, 0);
-      rep->url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, rep->url.c_str ());
-
-      // The MDTM command seems to reset the path to the root with the
-      // servers I tested with, so cd again into the correct path. Make
-      // the path absolute so that this will work even with servers that
-      // don't end up in the root after an MDTM command.
-      cwd ("/" + path);
-    }
-
-  std::string pwd (void) const
-    {
-      struct curl_slist *slist = 0;
-      std::string retval;
-      std::ostringstream buf;
-
-      slist = curl_slist_append (slist, "pwd");
-      setopt (CURLOPT_POSTQUOTE, slist);
-      setopt (CURLOPT_HEADERFUNCTION, write_data);
-      setopt (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
-
-      if (! error_state)
-        {
-          perform ();
-          retval = buf.str ();
-
-          // Can I assume that the path is alway in "" on the last line
-          size_t pos2 = retval.rfind ('"');
-          size_t pos1 = retval.rfind ('"', pos2 - 1);
-          retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
-        }
-      setopt (CURLOPT_HEADERFUNCTION, 0);
-      setopt (CURLOPT_WRITEHEADER, 0);
-      setopt (CURLOPT_POSTQUOTE, 0);
-      curl_slist_free_all (slist);
-
-      return retval;
-    }
-
-  bool perform (bool curlerror = true) const
-    {
-      return rep->perform (curlerror);
-    }
-
-private:
-  curl_handle_rep *rep;
-
-  std::string form_query_string (const Cell& param)
-    {
-      std::ostringstream query;
-
-      for (int i = 0; i < param.numel (); i += 2)
-        {
-          std::string name = param(i).string_value ();
-          std::string text = param(i+1).string_value ();
-
-          // Encode strings.
-          char *enc_name = curl_easy_escape (rep->handle (), name.c_str (),
-                                             name.length ());
-          char *enc_text = curl_easy_escape (rep->handle (), text.c_str (),
-                                             text.length ());
-
-          query << enc_name << "=" << enc_text;
-
-          curl_free (enc_name);
-          curl_free (enc_text);
-
-          if (i < param.numel ()-1)
-            query << "&";
-        }
-
-      query.flush ();
-
-      return query.str ();
-    }
-
-  void init (const std::string& user, const std::string& passwd,
-             std::istream& is, std::ostream& os)
-    {
-      // No data transfer by default
-      setopt (CURLOPT_NOBODY, 1);
-
-      // Set the username and password
-      rep->userpwd = user;
-      if (! passwd.empty ())
-        rep->userpwd += ":" + passwd;
-      if (! rep->userpwd.empty ())
-        setopt (CURLOPT_USERPWD, rep->userpwd.c_str ());
-
-      // Define our callback to get called when there's data to be written.
-      setopt (CURLOPT_WRITEFUNCTION, write_data);
-
-      // Set a pointer to our struct to pass to the callback.
-      setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
-
-      // Define our callback to get called when there's data to be read
-      setopt (CURLOPT_READFUNCTION, read_data);
-
-      // Set a pointer to our struct to pass to the callback.
-      setopt (CURLOPT_READDATA, static_cast<void*> (&is));
-
-      // Follow redirects.
-      setopt (CURLOPT_FOLLOWLOCATION, true);
-
-      // Don't use EPSV since connecting to sites that don't support it
-      // will hang for some time (3 minutes?) before moving on to try PASV
-      // instead.
-      setopt (CURLOPT_FTP_USE_EPSV, false);
-
-      setopt (CURLOPT_NOPROGRESS, true);
-      setopt (CURLOPT_FAILONERROR, true);
-
-      setopt (CURLOPT_POSTQUOTE, 0);
-      setopt (CURLOPT_QUOTE, 0);
-    }
-
-#undef setopt
-};
-
-class
-curl_handles
-{
-public:
-
-  typedef std::map<std::string, curl_handle>::iterator iterator;
-  typedef std::map<std::string, curl_handle>::const_iterator const_iterator;
-
-  curl_handles (void) : map ()
-   {
-     curl_global_init (CURL_GLOBAL_DEFAULT);
-   }
-
-  ~curl_handles (void)
-    {
-      // Remove the elements of the map explicitly as they should
-      // be deleted before the call to curl_global_cleanup
-      map.erase (begin (), end ());
-
-      curl_global_cleanup ();
-    }
-
-  iterator begin (void) { return iterator (map.begin ()); }
-  const_iterator begin (void) const { return const_iterator (map.begin ()); }
-
-  iterator end (void) { return iterator (map.end ()); }
-  const_iterator end (void) const { return const_iterator (map.end ()); }
-
-  iterator seek (const std::string& k) { return map.find (k); }
-  const_iterator seek (const std::string& k) const { return map.find (k); }
-
-  std::string key (const_iterator p) const { return p->first; }
-
-  curl_handle& contents (const std::string& k)
-    {
-      return map[k];
-    }
-
-  curl_handle contents (const std::string& k) const
-    {
-      const_iterator p = seek (k);
-      return p != end () ? p->second : curl_handle ();
-    }
-
-  curl_handle& contents (iterator p)
-    { return p->second; }
-
-  curl_handle contents (const_iterator p) const
-    { return p->second; }
-
-  void del (const std::string& k)
-    {
-      iterator p = map.find (k);
-
-      if (p != map.end ())
-        map.erase (p);
-    }
-
-private:
-  std::map<std::string, curl_handle> map;
-};
-
-static curl_handles handles;
-
-static void
-cleanup_urlwrite (std::string filename)
-{
-  octave_unlink (filename);
+  return retval;
 }
 
-static void
-reset_path (const curl_handle curl)
+void
+ch_manager::do_free (const curl_handle& h)
 {
-  curl.cwd ("..");
+  if (h.ok ())
+    {
+      iterator p = handle_map.find (h);
+
+      if (p != handle_map.end ())
+        {
+          // Curl handles are negative integers plus some random
+          // fractional part.  To avoid running out of integers, we
+          // recycle the integer part but tack on a new random part
+          // each time.
+
+          handle_map.erase (p);
+
+          if (h.value () < 0)
+            handle_free_list.insert (std::ceil (h.value ()) - make_handle_fraction ());
+        }
+      else
+        error ("ch_manager::free: invalid object %g", h.value ());
+    }
 }
 
-static void
-delete_file (std::string file)
-{
-  octave_unlink (file);
-}
-#endif
+ch_manager *ch_manager::instance = 0;
 
-DEFUN_DLD (urlwrite, args, nargout,
+DEFUN (urlwrite, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{url} and save it as\n\
 @var{localfile}.  For example:\n\
 \n\
@@ -727,18 +326,16 @@ urlwrite (\"http://www.google.com/search
           \"get\", @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-#ifdef HAVE_CURL
-
   int nargin = args.length ();
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     {
       print_usage ();
       return retval;
     }
@@ -756,17 +353,17 @@ urlwrite (\"http://www.google.com/search
 
   if (error_state)
     {
       error ("urlwrite: LOCALFILE must be a character string");
       return retval;
     }
 
   std::string method;
-  Cell param; // empty cell array
+  Array<std::string> param;
 
   if (nargin == 4)
     {
       method = args(2).string_value ();
 
       if (error_state)
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
@@ -774,21 +371,21 @@ urlwrite (\"http://www.google.com/search
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(3).cell_value ();
+      param = args(3).cellstr_value ();
 
       if (error_state)
         {
-          error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell");
+          error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
           return retval;
         }
 
 
       if (param.numel () % 2 == 1 )
         {
           error ("urlwrite: number of elements in PARAM must be even");
           return retval;
@@ -806,55 +403,48 @@ urlwrite (\"http://www.google.com/search
   if (! ofile.is_open ())
     {
       error ("urlwrite: unable to open file");
       return retval;
     }
 
   unwind_protect_safe frame;
 
-  frame.add_fcn (cleanup_urlwrite, filename);
+  frame.add_fcn (delete_file, filename);
 
-  bool ok;
-  curl_handle curl = curl_handle (url, method, param, ofile, ok);
+  url_transfer curl = url_transfer (url, method, param, ofile);
 
   ofile.close ();
 
-  if (!error_state)
+  if (curl.good ())
     frame.discard ();
-  else
-    frame.run ();
 
   if (nargout > 0)
     {
-      if (ok)
+      if (curl.good ())
         {
           retval(2) = std::string ();
           retval(1) = true;
           retval(0) = octave_env::make_absolute (filename);
         }
       else
         {
           retval(2) = curl.lasterror ();
           retval(1) = false;
           retval(0) = std::string ();
         }
     }
 
-  if (nargout < 2 && ! ok)
-    error ("urlwrite: curl: %s", curl.lasterror ().c_str ());
-
-#else
-  error ("urlwrite: not available in this version of Octave");
-#endif
+  if (nargout < 2 && ! curl.good ())
+    error ("urlwrite: %s", curl.lasterror ().c_str ());
 
   return retval;
 }
 
-DEFUN_DLD (urlread, args, nargout,
+DEFUN (urlread, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{url} and return its content\n\
 in string @var{s}.  For example:\n\
 \n\
@@ -887,18 +477,16 @@ s = urlread (\"http://www.google.com/sea
 @end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
 @end deftypefn")
 {
   // Octave's return value
   octave_value_list retval;
 
-#ifdef HAVE_CURL
-
   int nargin = args.length ();
 
   // verify arguments
   if (nargin != 1  && nargin != 3)
     {
       print_usage ();
       return retval;
     }
@@ -907,17 +495,17 @@ s = urlread (\"http://www.google.com/sea
 
   if (error_state)
     {
       error ("urlread: URL must be a character string");
       return retval;
     }
 
   std::string method;
-  Cell param; // empty cell array
+  Array<std::string> param;
 
   if (nargin == 3)
     {
       method = args(1).string_value ();
 
       if (error_state)
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
@@ -925,611 +513,521 @@ s = urlread (\"http://www.google.com/sea
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(2).cell_value ();
+      param = args(2).cellstr_value ();
 
       if (error_state)
         {
-          error ("urlread: parameters (PARAM) for get and post requests must be given as a cell");
+          error ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
           return retval;
         }
 
       if (param.numel () % 2 == 1 )
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
-  bool ok;
-  curl_handle curl = curl_handle (url, method, param, buf, ok);
+  url_transfer curl = url_transfer (url, method, param, buf);
 
-  if (nargout > 0)
+  if (curl.good ())
     {
-      // Return empty string if no error occured.
-      retval(2) = ok ? "" : curl.lasterror ();
-      retval(1) = ok;
-      retval(0) = buf.str ();
+      if (nargout > 0)
+        {
+          // Return empty string if no error occured.
+          retval(2) = curl.good () ? "" : curl.lasterror ();
+          retval(1) = curl.good ();
+          retval(0) = buf.str ();
+        }
     }
 
-  if (nargout < 2 && ! ok)
-    error ("urlread: curl: %s", curl.lasterror().c_str());
-
-#else
-  error ("urlread: not available in this version of Octave");
-#endif
+  if (nargout < 2 && ! curl.good ())
+    error ("urlread: %s", curl.lasterror().c_str());
 
   return retval;
 }
 
-DEFUN_DLD (__ftp__, args, ,
+DEFUN (__ftp__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __ftp__ (@var{handle}, @var{host})\n\
-@deftypefnx {Loadable Function} {} __ftp__ (@var{handle}, @var{host}, @var{username}, @var{password})\n\
+@deftypefn  {Loadable Function} {@var{handle} =} __ftp__ (@var{host})\n\
+@deftypefnx {Loadable Function} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
-  std::string handle;
   std::string host;
   std::string user = "anonymous";
   std::string passwd = "";
 
-  if (nargin < 2 || nargin > 4)
-    error ("incorrect number of arguments");
+  if (nargin < 1 || nargin > 3)
+    {
+      print_usage ();
+      return retval;
+    }
   else
     {
-      handle = args(0).string_value ();
-      host = args(1).string_value ();
+      host = args(0).string_value ();
 
       if (nargin > 1)
-        user = args(2).string_value ();
+        user = args(1).string_value ();
 
       if (nargin > 2)
-        passwd = args(3).string_value ();
+        passwd = args(2).string_value ();
 
-      if (!error_state)
+      if (! error_state)
         {
-          handles.contents (handle) = curl_handle (host, user, passwd);
+          curl_handle ch
+            = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
-          if (error_state)
-            handles.del (handle);
+          if (! error_state)
+            retval = ch.value ();
         }
     }
-#else
-  error ("__ftp__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_pwd__, args, ,
+DEFUN (__ftp_pwd__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
-#ifdef HAVE_CURL
+
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
-        {
-          const curl_handle curl = handles.contents (handle);
+      if (error_state)
+        return retval;
 
-          if (curl.is_valid ())
-            retval = curl.pwd ();
-          else
-            error ("__ftp_pwd__: invalid ftp handle");
-        }
+      if (curl.is_valid ())
+        retval = curl.pwd ();
+      else
+        error ("__ftp_pwd__: invalid ftp handle");
     }
-#else
-  error ("__ftp_pwd__: not available in this version of Octave");
-#endif
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_cwd__, args, ,
+DEFUN (__ftp_cwd__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     error ("__ftp_cwd__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string path = "";
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (nargin > 1)
-        path  = args(1).string_value ();
+      if (error_state)
+        return retval;
 
-      if (!error_state)
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string path = "";
 
-          if (curl.is_valid ())
+          if (nargin > 1)
+            path = args(1).string_value ();
+
+          if (! error_state)
             curl.cwd (path);
           else
-            error ("__ftp_cwd__: invalid ftp handle");
+            error ("__ftp_cwd__: expecting path as second argument");
         }
+      else
+        error ("__ftp_cwd__: invalid ftp handle");
     }
-#else
-  error ("__ftp_cwd__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_dir__, args, nargout,
+DEFUN (__ftp_dir__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
-#ifdef HAVE_CURL
+
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_dir__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
+      if (error_state)
+        return retval;
+
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          if (nargout == 0)
+            curl.dir ();
+          else
+            {
+              string_vector sv = curl.list ();
+              octave_idx_type n = sv.length ();
 
-          if (curl.is_valid ())
-            {
-              if (nargout == 0)
-                curl.dir ();
+              if (n == 0)
+                {
+                  string_vector flds (5);
+
+                  flds(0) = "name";
+                  flds(1) = "date";
+                  flds(2) = "bytes";
+                  flds(3) = "isdir";
+                  flds(4) = "datenum";
+
+                  retval = octave_map (flds);
+                }
               else
                 {
-                  string_vector sv = curl.list ();
-                  octave_idx_type n = sv.length ();
-                  if (n == 0)
+                  octave_map st;
+
+                  Cell filectime (dim_vector (n, 1));
+                  Cell filesize (dim_vector (n, 1));
+                  Cell fileisdir (dim_vector (n, 1));
+                  Cell filedatenum (dim_vector (n, 1));
+
+                  st.assign ("name", Cell (sv));
+
+                  for (octave_idx_type i = 0; i < n; i++)
                     {
-                      string_vector flds (5);
-                      flds(0) = "name";
-                      flds(1) = "date";
-                      flds(2) = "bytes";
-                      flds(3) = "isdir";
-                      flds(4) = "datenum";
-                      retval = octave_map (flds);
-                    }
-                  else
-                    {
-                      octave_map st;
-                      Cell filectime (dim_vector (n, 1));
-                      Cell filesize (dim_vector (n, 1));
-                      Cell fileisdir (dim_vector (n, 1));
-                      Cell filedatenum (dim_vector (n, 1));
+                      time_t ftime;
+                      bool fisdir;
+                      double fsize;
 
-                      st.assign ("name", Cell (sv));
-
-                      for (octave_idx_type i = 0; i < n; i++)
-                        {
-                          time_t ftime;
-                          bool fisdir;
-                          double fsize;
-
-                          curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
+                      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
-                          fileisdir (i) = fisdir;
-                          filectime (i) = ctime (&ftime);
-                          filesize (i) = fsize;
-                          filedatenum (i) = double (ftime);
-                        }
-                      st.assign ("date", filectime);
-                      st.assign ("bytes", filesize);
-                      st.assign ("isdir", fileisdir);
-                      st.assign ("datenum", filedatenum);
-                      retval = st;
+                      fileisdir (i) = fisdir;
+                      filectime (i) = ctime (&ftime);
+                      filesize (i) = fsize;
+                      filedatenum (i) = double (ftime);
                     }
+
+                  st.assign ("date", filectime);
+                  st.assign ("bytes", filesize);
+                  st.assign ("isdir", fileisdir);
+                  st.assign ("datenum", filedatenum);
+
+                  retval = st;
                 }
             }
-          else
-            error ("__ftp_dir__: invalid ftp handle");
         }
+      else
+        error ("__ftp_dir__: invalid ftp handle");
     }
-#else
-  error ("__ftp_dir__: not available in this version of Octave");
-#endif
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_ascii__, args, ,
+DEFUN (__ftp_ascii__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
-        {
-          const curl_handle curl = handles.contents (handle);
+      if (error_state)
+        return retval;
 
-          if (curl.is_valid ())
-            curl.ascii ();
-          else
-            error ("__ftp_ascii__: invalid ftp handle");
-        }
+      if (curl.is_valid ())
+        curl.ascii ();
+      else
+        error ("__ftp_ascii__: invalid ftp handle");
     }
-#else
-  error ("__ftp_ascii__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_binary__, args, ,
+DEFUN (__ftp_binary__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_binary__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
-        {
-          const curl_handle curl = handles.contents (handle);
+      if (error_state)
+        return retval;
 
-          if (curl.is_valid ())
-            curl.binary ();
-          else
-            error ("__ftp_binary__: invalid ftp handle");
-        }
+      if (curl.is_valid ())
+        curl.binary ();
+      else
+        error ("__ftp_binary__: invalid ftp handle");
     }
-#else
-  error ("__ftp_binary__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_close__, args, ,
+DEFUN (__ftp_close__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
- Undocumented internal function\n\
- @end deftypefn")
- {
- #ifdef HAVE_CURL
-   int nargin = args.length ();
+Undocumented internal function\n\
+@end deftypefn")
+{
+  octave_value retval;
 
-   if (nargin != 1)
-     error ("__ftp_close__: incorrect number of arguments");
-   else
-     {
-       std::string handle = args(0).string_value ();
+  int nargin = args.length ();
+
+  if (nargin != 1)
+    error ("__ftp_close__: incorrect number of arguments");
+  else
+    {
+      curl_handle h = ch_manager::lookup (args(0));
 
-       if (!error_state)
-         handles.del (handle);
-     }
- #else
-   error ("__ftp_close__: not available in this version of Octave");
- #endif
+      if (error_state)
+        return retval;
 
-   return octave_value ();
- }
+      if (h.ok ())
+        ch_manager::free (h);
+      else
+        error ("__ftp_close__: invalid ftp handle");
+    }
 
-DEFUN_DLD (__ftp_mode__, args, ,
+  return retval;
+}
+
+DEFUN (__ftp_mode__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mode__ (@var{handle})\n\
- Undocumented internal function\n\
- @end deftypefn")
- {
-   octave_value retval;
- #ifdef HAVE_CURL
-   int nargin = args.length ();
+Undocumented internal function\n\
+@end deftypefn")
+{
+  octave_value retval;
 
-   if (nargin != 1)
-     error ("__ftp_mode__: incorrect number of arguments");
-   else
-     {
-       std::string handle = args(0).string_value ();
+  int nargin = args.length ();
 
+  if (nargin != 1)
+    error ("__ftp_mode__: incorrect number of arguments");
+  else
+    {
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
-        {
-          const curl_handle curl = handles.contents (handle);
+      if (error_state)
+        return retval;
 
-          if (curl.is_valid ())
-            retval = (curl.is_ascii () ? "ascii" : "binary");
-          else
-            error ("__ftp_binary__: invalid ftp handle");
-        }
-     }
- #else
-   error ("__ftp_mode__: not available in this version of Octave");
- #endif
+      if (curl.is_valid ())
+        retval = (curl.is_ascii () ? "ascii" : "binary");
+      else
+        error ("__ftp_binary__: invalid ftp handle");
+    }
 
-   return retval;
- }
+  return retval;
+}
 
-DEFUN_DLD (__ftp_delete__, args, ,
+DEFUN (__ftp_delete__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string file = args(1).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
+
+      if (error_state)
+        return retval;
 
-      if (!error_state)
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string file = args(1).string_value ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             curl.del (file);
           else
-            error ("__ftp_delete__: invalid ftp handle");
+            error ("__ftp_delete__: expecting file name as second argument");
         }
+      else
+        error ("__ftp_delete__: invalid ftp handle");
     }
-#else
-  error ("__ftp_delete__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_rmdir__, args, ,
+DEFUN (__ftp_rmdir__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string dir = args(1).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
+
+      if (error_state)
+        return retval;
 
-      if (!error_state)
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string dir = args(1).string_value ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             curl.rmdir (dir);
           else
-            error ("__ftp_rmdir__: invalid ftp handle");
+            error ("__ftp_rmdir__: expecting directory name as second argument");
         }
+      else
+        error ("__ftp_rmdir__: invalid ftp handle");
     }
-#else
-  error ("__ftp_rmdir__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_mkdir__, args, ,
+DEFUN (__ftp_mkdir__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string dir = args(1).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
+
+      if (error_state)
+        return retval;
 
-      if (!error_state)
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string dir = args(1).string_value ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             curl.mkdir (dir);
           else
-            error ("__ftp_mkdir__: invalid ftp handle");
+            error ("__ftp_mkdir__: expecting directory name as second argument");
         }
+      else
+        error ("__ftp_mkdir__: invalid ftp handle");
     }
-#else
-  error ("__ftp_mkdir__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
 
-DEFUN_DLD (__ftp_rename__, args, ,
+DEFUN (__ftp_rename__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string oldname = args(1).string_value ();
-      std::string newname = args(2).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
+
+      if (error_state)
+        return retval;
 
-      if (!error_state)
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string oldname = args(1).string_value ();
+          std::string newname = args(2).string_value ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             curl.rename (oldname, newname);
           else
-            error ("__ftp_rename__: invalid ftp handle");
-        }
-    }
-#else
-  error ("__ftp_rename__: not available in this version of Octave");
-#endif
-
-  return octave_value ();
-}
-
-#ifdef HAVE_CURL
-static string_vector
-mput_directory (const curl_handle& curl, const std::string& base,
-                const std::string& dir)
-{
-  string_vector retval;
-
-  if (! curl.mkdir (dir, false))
-    warning ("__ftp_mput__: can not create the remote directory ""%s""",
-             (base.length () == 0 ? dir : base +
-              file_ops::dir_sep_str () + dir).c_str ());
-
-  curl.cwd (dir);
-
-  if (! error_state)
-    {
-      unwind_protect_safe frame;
-
-      frame.add_fcn (reset_path, curl);
-
-      std::string realdir = base.length () == 0 ? dir : base +
-                         file_ops::dir_sep_str () + dir;
-
-      dir_entry dirlist (realdir);
-
-      if (dirlist)
-        {
-          string_vector files = dirlist.read ();
-
-          for (octave_idx_type i = 0; i < files.length (); i++)
-            {
-              std::string file = files (i);
-
-              if (file == "." || file == "..")
-                continue;
-
-              std::string realfile = realdir + file_ops::dir_sep_str () + file;
-              file_stat fs (realfile);
-
-              if (! fs.exists ())
-                {
-                  error ("__ftp__mput: file ""%s"" does not exist",
-                         realfile.c_str ());
-                  break;
-                }
-
-              if (fs.is_dir ())
-                {
-                  retval.append (mput_directory (curl, realdir, file));
-
-                  if (error_state)
-                    break;
-                }
-              else
-                {
-                  // FIXME Does ascii mode need to be flagged here?
-                  std::ifstream ifile (realfile.c_str (), std::ios::in |
-                                       std::ios::binary);
-
-                  if (! ifile.is_open ())
-                    {
-                      error ("__ftp_mput__: unable to open file ""%s""",
-                             realfile.c_str ());
-                      break;
-                    }
-
-                  curl.put (file, ifile);
-
-                  ifile.close ();
-
-                  if (error_state)
-                    break;
-
-                  retval.append (realfile);
-                }
-            }
+            error ("__ftp_rename__: expecting file names for second and third arguments");
         }
       else
-        error ("__ftp_mput__: can not read the directory ""%s""",
-               realdir.c_str ());
+        error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
 }
-#endif
 
-DEFUN_DLD (__ftp_mput__, args, nargout,
+DEFUN (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-  string_vector retval;
+  octave_value retval;
 
-#ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string pat = args(1).string_value ();
+      url_transfer curl = ch_manager::get_object (args(0));
 
-      if (!error_state)
+      if (error_state)
+        return retval;
+
+      if (curl.is_valid ())
         {
-          const curl_handle curl = handles.contents (handle);
+          std::string pat = args(1).string_value ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             {
+              string_vector file_list;
+
               glob_match pattern (file_ops::tilde_expand (pat));
               string_vector files = pattern.glob ();
 
               for (octave_idx_type i = 0; i < files.length (); i++)
                 {
                   std::string file = files (i);
 
                   file_stat fs (file);
@@ -1537,19 +1035,23 @@ Undocumented internal function\n\
                   if (! fs.exists ())
                     {
                       error ("__ftp__mput: file does not exist");
                       break;
                     }
 
                   if (fs.is_dir ())
                     {
-                      retval.append (mput_directory (curl, "", file));
-                      if (error_state)
-                        break;
+                      file_list.append (curl.mput_directory ("", file));
+
+                      if (! curl.good ())
+                        {
+                          error ("__ftp_mput__: %s", curl.lasterror().c_str());
+                          break;
+                        }
                     }
                   else
                     {
                       // FIXME Does ascii mode need to be flagged here?
                       std::ifstream ifile (file.c_str (), std::ios::in |
                                            std::ios::binary);
 
                       if (! ifile.is_open ())
@@ -1557,153 +1059,87 @@ Undocumented internal function\n\
                           error ("__ftp_mput__: unable to open file");
                           break;
                         }
 
                       curl.put (file, ifile);
 
                       ifile.close ();
 
-                      if (error_state)
-                        break;
+                      if (! curl.good ())
+                        {
+                          error ("__ftp_mput__: %s", curl.lasterror().c_str());
+                          break;
+                        }
 
-                      retval.append (file);
+                      file_list.append (file);
                     }
                 }
+
+              if (nargout > 0)
+                retval = file_list;
             }
           else
-            error ("__ftp_mput__: invalid ftp handle");
+            error ("__ftp_mput__: expecting file name patter as second argument");
         }
-    }
-#else
-  error ("__ftp_mput__: not available in this version of Octave");
-#endif
-
-  return (nargout > 0 ? octave_value (retval) : octave_value ());
-}
-
-#ifdef HAVE_CURL
-static void
-getallfiles (const curl_handle& curl, const std::string& dir,
-             const std::string& target)
-{
-  std::string sep = file_ops::dir_sep_str ();
-  file_stat fs (dir);
-
-  if (!fs || !fs.is_dir ())
-    {
-      std::string msg;
-      int status = octave_mkdir (dir, 0777, msg);
-
-      if (status < 0)
-        error ("__ftp_mget__: can't create directory %s%s%s. %s",
-               target.c_str (), sep.c_str (), dir.c_str (), msg.c_str ());
+      else
+        error ("__ftp_mput__: invalid ftp handle");
     }
 
-  if (! error_state)
-    {
-      curl.cwd (dir);
-
-      if (! error_state)
-        {
-          unwind_protect_safe frame;
-
-          frame.add_fcn (reset_path, curl);
-
-          string_vector sv = curl.list ();
-
-          for (octave_idx_type i = 0; i < sv.length (); i++)
-            {
-              time_t ftime;
-              bool fisdir;
-              double fsize;
-
-              curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
-
-              if (fisdir)
-                getallfiles (curl, sv(i), target + dir + sep);
-              else
-                {
-                  std::string realfile = target + dir + sep + sv(i);
-                  std::ofstream ofile (realfile.c_str (),
-                                       std::ios::out |
-                                       std::ios::binary);
+  return retval;
+}
 
-                  if (! ofile.is_open ())
-                    {
-                      error ("__ftp_mget__: unable to open file");
-                      break;
-                    }
-
-                  unwind_protect_safe frame2;
-
-                  frame2.add_fcn (delete_file, realfile);
-
-                  curl.get (sv(i), ofile);
-
-                  ofile.close ();
-
-                  if (!error_state)
-                    frame2.discard ();
-                  else
-                    frame2.run ();
-                }
-
-              if (error_state)
-                break;
-            }
-        }
-    }
-}
-#endif
-
-DEFUN_DLD (__ftp_mget__, args, ,
+DEFUN (__ftp_mget__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
-#ifdef HAVE_CURL
+  octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
   else
     {
-      std::string handle = args(0).string_value ();
-      std::string file = args(1).string_value ();
-      std::string target;
+      url_transfer curl = ch_manager::get_object (args(0));
+
+      if (error_state)
+        return retval;
 
-      if (nargin == 3)
-        target = args(2).string_value () + file_ops::dir_sep_str ();
+      if (curl.is_valid ())
+        {
+          std::string file = args(1).string_value ();
+          std::string target;
 
-      if (! error_state)
-        {
-          const curl_handle curl = handles.contents (handle);
+          if (nargin == 3)
+            target = args(2).string_value () + file_ops::dir_sep_str ();
 
-          if (curl.is_valid ())
+          if (! error_state)
             {
               string_vector sv = curl.list ();
               octave_idx_type n = 0;
               glob_match pattern (file);
 
+
               for (octave_idx_type i = 0; i < sv.length (); i++)
                 {
                   if (pattern.match (sv(i)))
                     {
                       n++;
 
                       time_t ftime;
                       bool fisdir;
                       double fsize;
 
                       curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
                       if (fisdir)
-                        getallfiles (curl, sv(i), target);
+                        curl.mget_directory (sv(i), target);
                       else
                         {
                           std::ofstream ofile ((target + sv(i)).c_str (),
                                                std::ios::out |
                                                std::ios::binary);
 
                           if (! ofile.is_open ())
                             {
@@ -1714,29 +1150,31 @@ Undocumented internal function\n\
                           unwind_protect_safe frame;
 
                           frame.add_fcn (delete_file, target + sv(i));
 
                           curl.get (sv(i), ofile);
 
                           ofile.close ();
 
-                          if (!error_state)
+                          if (curl.good ())
                             frame.discard ();
-                          else
-                            frame.run ();
                         }
 
-                      if (error_state)
-                        break;
+                      if (! curl.good ())
+                        {
+                          error ("__ftp_mget__: %s", curl.lasterror().c_str());
+                          break;
+                        }
                     }
                 }
               if (n == 0)
                 error ("__ftp_mget__: file not found");
             }
+          else
+            error ("__ftp_mget__: expecting file name and target as second and third arguments");
         }
+      else
+        error ("__ftp_mget__: invalid ftp handle");
     }
-#else
-  error ("__ftp_mget__: not available in this version of Octave");
-#endif
 
-  return octave_value ();
+  return retval;
 }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -294,17 +294,17 @@ DEFUN (file_in_loadpath, args, ,
 Return the absolute name of @var{file} if it can be found in\n\
 the list of directories specified by @code{path}.\n\
 If no file is found, return an empty character string.\n\
 \n\
 If the first argument is a cell array of strings, search each\n\
 directory of the loadpath for element of the cell array and return\n\
 the first that matches.\n\
 \n\
-If the second optional argument @code{\"all\"} is supplied, return\n\
+If the second optional argument @qcode{\"all\"} is supplied, return\n\
 a cell array containing the list of all files that have the same\n\
 name in the path.  If no files are found, return an empty cell array.\n\
 @seealso{file_in_path, path}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -370,17 +370,17 @@ file_in_path (EXEC_PATH, \"sh\")\n\
      @result{} \"/bin/sh\"\n\
 @end group\n\
 @end example\n\
 \n\
 If the second argument is a cell array of strings, search each\n\
 directory of the path for element of the cell array and return\n\
 the first that matches.\n\
 \n\
-If the third optional argument @code{\"all\"} is supplied, return\n\
+If the third optional argument @qcode{\"all\"} is supplied, return\n\
 a cell array containing the list of all files that have the same\n\
 name in the path.  If no files are found, return an empty cell array.\n\
 @seealso{file_in_loadpath}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -891,19 +891,20 @@ system.  No check is done for the existe
 */
 
 DEFUN (find_dir_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} find_dir_in_path (@var{dir})\n\
 @deftypefnx {Built-in Function} {} find_dir_in_path (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.  The\n\
 match is performed at the end of each path element.  For example, if\n\
-@var{dir} is @code{\"foo/bar\"}, it matches the path element\n\
-@code{\"/some/dir/foo/bar\"}, but not @code{\"/some/dir/foo/bar/baz\"}\n\
-or @code{\"/some/dir/allfoo/bar\"}.\n\
+@var{dir} is @qcode{\"foo/bar\"}, it matches the path element\n\
+@nospell{@qcode{\"/some/dir/foo/bar\"}}, but not\n\
+@nospell{@qcode{\"/some/dir/foo/bar/baz\"}}\n\
+@nospell{@qcode{\"/some/dir/allfoo/bar\"}}.\n\
 \n\
 The second argument is optional.  If it is supplied, return a cell array\n\
 containing all name matches rather than just the first.\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   int nargin = args.length ();
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <iomanip>
 #include <set>
 #include <string>
 
 #include "file-stat.h"
 #include "oct-env.h"
 #include "file-ops.h"
 #include "glob-match.h"
-#include "regexp.h"
+#include "lo-regexp.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
@@ -396,16 +396,18 @@ symbol_exist (const std::string& name, c
 
   size_t pos = name.find ('.');
 
   if (pos != std::string::npos && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
+  else if (is_keyword (symbol_name))
+    return retval;
 
   // We shouldn't need to look in the global symbol table, since any
   // name that is visible in the current scope will be in the local
   // symbol table.
 
   octave_value val = safe_symbol_lookup (symbol_name);
 
   if (val.is_defined ())
@@ -532,26 +534,26 @@ This function also returns 2 if a regula
 exists in Octave's search path.  If you want information about\n\
 other types of files, you should use some combination of the functions\n\
 @code{file_in_path} and @code{stat} instead.\n\
 \n\
 If the optional argument @var{type} is supplied, check only for\n\
 symbols of the specified type.  Valid types are\n\
 \n\
 @table @asis\n\
-@item \"var\"\n\
+@item @qcode{\"var\"}\n\
 Check only for variables.\n\
 \n\
-@item \"builtin\"\n\
+@item @qcode{\"builtin\"}\n\
 Check only for built-in functions.\n\
 \n\
-@item \"file\"\n\
+@item @qcode{\"file\"}\n\
 Check only for files and directories.\n\
 \n\
-@item \"dir\"\n\
+@item @qcode{\"dir\"}\n\
 Check only for directories.\n\
 @end table\n\
 \n\
 @seealso{file_in_loadpath, file_in_path, stat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -2525,40 +2527,40 @@ auto-expand as required.\n\
 The parameters @code{left-min} and @code{balance} are only available when the\n\
 column-aligned modifier is used with the command @samp{%s}.\n\
 @code{balance} specifies the column number within the field width which will\n\
 be aligned between entries.  Numbering starts from 0 which indicates the\n\
 leftmost column.  @code{left-min} specifies the minimum field width to the\n\
 left of the specified balance column.\n\
 \n\
 The default format is\n\
-@code{\"  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\\n\"}.\n\
+@qcode{\"  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\\n\"}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 static std::string Vmissing_function_hook = "__unimplemented__";
 
 DEFUN (missing_function_hook, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} missing_function_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 an unknown identifier is requested.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (missing_function_hook);
 }
 
 void maybe_missing_function_hook (const std::string& name)
 {
   // Don't do this if we're handling errors.
@@ -2599,8 +2601,38 @@ Undocumented internal function.\n\
       else
         error ("__varval__: expecting argument to be variable name");
     }
   else
     print_usage ();
 
   return retval;
 }
+
+static std::string Vmissing_component_hook;
+
+DEFUN (missing_component_hook, args, nargout,
+    "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} missing_component_hook ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} missing_component_hook (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} missing_component_hook (@var{new_val}, \"local\")\n\
+Query or set the internal variable that specifies the function to call when\n\
+a component of Octave is missing.  This can be useful for packagers that\n\
+may split the Octave installation into multiple sub-packages, for example,\n\
+to provide a hint to users for how to install the missing components.\n\
+\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+\n\
+The hook function is expected to be of the form\n\
+\n\
+@example\n\
+@var{fcn} (@var{component})\n\
+@end example\n\
+\n\
+Octave will call @var{fcn} with the name of the function that requires the\n\
+component and a string describing the missing component.  The hook function\n\
+should return an error message to be displayed.\n\
+@end deftypefn")
+{
+  return SET_INTERNAL_VARIABLE (missing_component_hook);
+}
diff --git a/libinterp/dldfcn/eigs.cc b/libinterp/dldfcn/__eigs__.cc
rename from libinterp/dldfcn/eigs.cc
rename to libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/eigs.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -124,189 +124,39 @@ eigs_complex_func (const ComplexColumnVe
           eigs_error = 1;
           gripe_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (eigs, args, nargout,
+DEFUN_DLD (__eigs__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{d} =} eigs (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} eigs (@var{A}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} eigs (@var{af}, @var{n}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{A}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{af}, @var{n}, @dots{})\n\
-Calculate a limited number of eigenvalues and eigenvectors of @var{A},\n\
-based on a selection criteria.  The number of eigenvalues and eigenvectors to\n\
-calculate is given by @var{k} and defaults to 6.\n\
-\n\
-By default, @code{eigs} solve the equation\n\
-@tex\n\
-$A \\nu = \\lambda \\nu$,\n\
-@end tex\n\
-@ifinfo\n\
-@code{A * v = lambda * v},\n\
-@end ifinfo\n\
-where\n\
-@tex\n\
-$\\lambda$ is a scalar representing one of the eigenvalues, and $\\nu$\n\
-@end tex\n\
-@ifinfo\n\
-@code{lambda} is a scalar representing one of the eigenvalues, and @code{v}\n\
-@end ifinfo\n\
-is the corresponding eigenvector.  If given the positive definite matrix\n\
-@var{B} then @code{eigs} solves the general eigenvalue equation\n\
-@tex\n\
-$A \\nu = \\lambda B \\nu$.\n\
-@end tex\n\
-@ifinfo\n\
-@code{A * v = lambda * B * v}.\n\
-@end ifinfo\n\
-\n\
-The argument @var{sigma} determines which eigenvalues are returned.\n\
-@var{sigma} can be either a scalar or a string.  When @var{sigma} is a\n\
-scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If\n\
-@var{sigma} is a string, it must have one of the following values.\n\
-\n\
-@table @asis\n\
-@item \"lm\"\n\
-Largest Magnitude (default).\n\
-\n\
-@item \"sm\"\n\
-Smallest Magnitude.\n\
-\n\
-@item \"la\"\n\
-Largest Algebraic (valid only for real symmetric problems).\n\
-\n\
-@item \"sa\"\n\
-Smallest Algebraic (valid only for real symmetric problems).\n\
-\n\
-@item \"be\"\n\
-Both Ends, with one more from the high-end if @var{k} is odd (valid only for\n\
-real symmetric problems).\n\
-\n\
-@item \"lr\"\n\
-Largest Real part (valid only for complex or unsymmetric problems).\n\
-\n\
-@item \"sr\"\n\
-Smallest Real part (valid only for complex or unsymmetric problems).\n\
-\n\
-@item \"li\"\n\
-Largest Imaginary part (valid only for complex or unsymmetric problems).\n\
-\n\
-@item \"si\"\n\
-Smallest Imaginary part (valid only for complex or unsymmetric problems).\n\
-@end table\n\
-\n\
-If @var{opts} is given, it is a structure defining possible options that\n\
-@code{eigs} should use.  The fields of the @var{opts} structure are:\n\
-\n\
-@table @code\n\
-@item issym\n\
-If @var{af} is given, then flags whether the function @var{af} defines a\n\
-symmetric problem.  It is ignored if @var{A} is given.  The default is false.\n\
-\n\
-@item isreal\n\
-If @var{af} is given, then flags whether the function @var{af} defines a\n\
-real problem.  It is ignored if @var{A} is given.  The default is true.\n\
-\n\
-@item tol\n\
-Defines the required convergence tolerance, calculated as\n\
-@code{tol * norm (A)}.  The default is @code{eps}.\n\
-\n\
-@item maxit\n\
-The maximum number of iterations.  The default is 300.\n\
-\n\
-@item p\n\
-The number of Lanzcos basis vectors to use.  More vectors will result in\n\
-faster convergence, but a greater use of memory.  The optimal value of\n\
-@code{p} is problem dependent and should be in the range @var{k} to @var{n}.\n\
-The default value is @code{2 * @var{k}}.\n\
-\n\
-@item v0\n\
-The starting vector for the algorithm.  An initial vector close to the\n\
-final vector will speed up convergence.  The default is for @sc{arpack}\n\
-to randomly generate a starting vector.  If specified, @code{v0} must be\n\
-an @var{n}-by-1 vector where @code{@var{n} = rows (@var{A})}\n\
-\n\
-@item disp\n\
-The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then\n\
-diagnostics are disabled.  The default value is 0.\n\
-\n\
-@item cholB\n\
-Flag if @code{chol (@var{B})} is passed rather than @var{B}.  The default is\n\
-false.\n\
-\n\
-@item permB\n\
-The permutation vector of the Cholesky@tie{}factorization of @var{B} if\n\
-@code{cholB} is true.  That is @code{chol (@var{B}(permB, permB))}.  The\n\
-default is @code{1:@var{n}}.\n\
-\n\
-@end table\n\
-\n\
-It is also possible to represent @var{A} by a function denoted @var{af}.\n\
-@var{af} must be followed by a scalar argument @var{n} defining the length\n\
-of the vector argument accepted by @var{af}.  @var{af} can be\n\
-a function handle, an inline function, or a string.  When @var{af} is a\n\
-string it holds the name of the function to use.\n\
-\n\
-@var{af} is a function of the form @code{y = af (x)}\n\
-where the required return value of @var{af} is determined by\n\
-the value of @var{sigma}.  The four possible forms are\n\
-\n\
-@table @code\n\
-@item A * x\n\
-if @var{sigma} is not given or is a string other than \"sm\".\n\
-\n\
-@item A \\ x\n\
-if @var{sigma} is 0 or \"sm\".\n\
-\n\
-@item (A - sigma * I) \\ x\n\
-for the standard eigenvalue problem, where @code{I} is the identity matrix of\n\
-the same size as @var{A}.\n\
-\n\
-@item (A - sigma * B) \\ x\n\
-for the general eigenvalue problem.\n\
-@end table\n\
-\n\
-The return arguments of @code{eigs} depend on the number of return arguments\n\
-requested.  With a single return argument, a vector @var{d} of length @var{k}\n\
-is returned containing the @var{k} eigenvalues that have been found.  With\n\
-two return arguments, @var{V} is a @var{n}-by-@var{k} matrix whose columns\n\
-are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The\n\
-eigenvalues themselves are returned in @var{d} in the form of a\n\
-@var{n}-by-@var{k} matrix, where the elements on the diagonal are the\n\
-eigenvalues.\n\
-\n\
-Given a third return argument @var{flag}, @code{eigs} returns the status\n\
-of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.\n\
-Any other value indicates a failure to converge.\n\
-\n\
-This function is based on the @sc{arpack} package, written by R. Lehoucq,\n\
-K. Maschhoff, D. Sorensen, and C. Yang.  For more information see\n\
-@url{http://www.caam.rice.edu/software/ARPACK/}.\n\
-\n\
-@seealso{eig, svds}\n\
+@deftypefn  {Loadable Function} {@var{d} =} __eigs__ (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} __eigs__ (@var{A}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{A}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} __eigs__ (@var{af}, @var{n}, @dots{})\n\
+Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 #ifdef HAVE_ARPACK
   int nargin = args.length ();
   std::string fcn_name;
   octave_idx_type n = 0;
   octave_idx_type k = 6;
@@ -761,761 +611,8 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
   return retval;
 }
-
-/* #### SPARSE MATRIX VERSIONS #### */
-
-/*
-## Real positive definite tests, n must be even
-%!shared n, k, A, d0, d2
-%! n = 20;
-%! k = 4;
-%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
-%! d0 = eig (A);
-%! d2 = sort (d0);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (d1, d0(end:-1:(end-k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "la");
-%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sa");
-%! assert (d1, d2(1:k), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "be");
-%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1, "be");
-%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs (A, speye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (d1, eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! AA = speye (10);
-%! fn = @(x) AA * x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! assert (eigs (fn, 10, AA, 3, "lm", opts), [1; 1; 1], 10*eps);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "la");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sa");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "be");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
-
-/*
-## Real unsymmetric tests
-%!shared n, k, A, d0
-%! n = 20;
-%! k = 4;
-%! A =  sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
-%! d0 = eig (A);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (abs (d1), abs (d0(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lr");
-%! [~, idx] = sort (real (d0));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "li");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "si");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
-%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs (A, speye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (abs (d1), d0(1:k), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "li");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "si");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
-
-/*
-## Complex hermitian tests
-%!shared n, k, A, d0
-%! n = 20;
-%! k = 4;
-%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
-%! d0 = eig (A);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (abs (d1), abs (d0(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "li");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "si");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
-%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_CHOLMOD
-%! d1 = eigs (A, speye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, speye (n), k, 4.1, opts);
-%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
-%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
-%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
-%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (abs (d1), d0(1:k), 1e-11);
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK, HAVE_UMFPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "li");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "si");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
-
-/* #### FULL MATRIX VERSIONS #### */
-
-/*
-## Real positive definite tests, n must be even
-%!shared n, k, A, d0, d2
-%! n = 20;
-%! k = 4;
-%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
-%! d0 = eig (A);
-%! d2 = sort (d0);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (d1, d0(end:-1:(end-k)),1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "la");
-%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sa");
-%! assert (d1, d2(1:k), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "be");
-%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1, "be");
-%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, eye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 1;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (d1, eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "la");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sa");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "be");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
-
-/*
-## Real unsymmetric tests
-%!shared n, k, A, d0
-%! n = 20;
-%! k = 4;
-%! A =  full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
-%! d0 = eig (A);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (abs (d1), abs (d0(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lr");
-%! [~, idx] = sort (real (d0));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "li");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "si");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
-%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, eye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (abs (d1), d0(1:k), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 0;  opts.isreal = 1;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "li");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "si");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
-
-/*
-## Complex hermitian tests
-%!shared n, k, A, d0
-%! n = 20;
-%! k = 4;
-%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
-%! d0 = eig (A);
-%! [~, idx] = sort (abs (d0));
-%! d0 = d0(idx);
-%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k+1);
-%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sm");
-%! assert (abs (d1), abs (d0(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "lr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "sr");
-%! [~, idx] = sort (real (abs (d0)));
-%! d2 = d0(idx);
-%! assert (real (d1), real (d2(1:k)), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "li");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, "si");
-%! [~, idx] = sort (imag (abs (d0)));
-%! d2 = d0(idx);
-%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, k, 4.1);
-%! [~, idx0] = sort (abs (d0 - 4.1));
-%! [~, idx1] = sort (abs (d1 - 4.1));
-%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
-%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_ARPACK
-%! d1 = eigs (A, eye (n), k, "lm");
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! d1 = eigs (A, eye (n), k, 4.1, opts);
-%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
-%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! opts.cholB = true;
-%! q = [2:n,1];
-%! opts.permB = q;
-%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
-%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
-%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
-%!testif HAVE_ARPACK
-%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A * x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, "lm", opts);
-%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) A \ x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, "sm", opts);
-%! assert (abs (d1), d0(1:k), 1e-11);
-%!testif HAVE_ARPACK
-%! fn = @(x) (A - 4.1 * eye (n)) \ x;
-%! opts.issym = 0;  opts.isreal = 0;
-%! d1 = eigs (fn, n, k, 4.1, opts);
-%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sm");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "lr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "sr");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "li");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-%!testif HAVE_ARPACK
-%! [v1,d1] = eigs (A, k, "si");
-%! d1 = diag (d1);
-%! for i=1:k
-%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
-%! endfor
-*/
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -1,11 +1,12 @@
 /*
 
 Copyright (C) 2005-2012 Nicolo' Giorgetti
+Copyright (C) 2013 Sbastien Villemot <sebastien@debian.org>
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -41,395 +42,278 @@ along with Octave; see the file COPYING.
 
 extern "C"
 {
 #if defined (HAVE_GLPK_GLPK_H)
 #include <glpk/glpk.h>
 #else
 #include <glpk.h>
 #endif
-
-#if 0
-#ifdef GLPK_PRE_4_14
-
-#ifndef _GLPLIB_H
-#include <glplib.h>
-#endif
-#ifndef lib_set_fault_hook
-#define lib_set_fault_hook lib_fault_hook
-#endif
-#ifndef lib_set_print_hook
-#define lib_set_print_hook lib_print_hook
-#endif
-
-#else
-
-void _glp_lib_print_hook (int (*func)(void *info, char *buf), void *info);
-void _glp_lib_fault_hook (int (*func)(void *info, char *buf), void *info);
-
-#endif
-#endif
 }
 
-#define NIntP 17
-#define NRealP 10
-
-int lpxIntParam[NIntP] = {
-  0,
-  1,
-  0,
-  1,
-  0,
-  -1,
-  0,
-  200,
-  1,
-  2,
-  0,
-  1,
-  0,
-  0,
-  2,
-  2,
-  1
-};
-
-int IParam[NIntP] = {
-  LPX_K_MSGLEV,
-  LPX_K_SCALE,
-  LPX_K_DUAL,
-  LPX_K_PRICE,
-  LPX_K_ROUND,
-  LPX_K_ITLIM,
-  LPX_K_ITCNT,
-  LPX_K_OUTFRQ,
-  LPX_K_MPSINFO,
-  LPX_K_MPSOBJ,
-  LPX_K_MPSORIG,
-  LPX_K_MPSWIDE,
-  LPX_K_MPSFREE,
-  LPX_K_MPSSKIP,
-  LPX_K_BRANCH,
-  LPX_K_BTRACK,
-  LPX_K_PRESOL
-};
-
-
-double lpxRealParam[NRealP] = {
-  0.07,
-  1e-7,
-  1e-7,
-  1e-9,
-  -std::numeric_limits<double>::max (),
-  std::numeric_limits<double>::max (),
-  -1.0,
-  0.0,
-  1e-6,
-  1e-7
-};
-
-int RParam[NRealP] = {
-  LPX_K_RELAX,
-  LPX_K_TOLBND,
-  LPX_K_TOLDJ,
-  LPX_K_TOLPIV,
-  LPX_K_OBJLL,
-  LPX_K_OBJUL,
-  LPX_K_TMLIM,
-  LPX_K_OUTDLY,
-  LPX_K_TOLINT,
-  LPX_K_TOLOBJ
+struct control_params
+{
+  int msglev;
+  int dual;
+  int price;
+  int itlim;
+  int outfrq;
+  int branch;
+  int btrack;
+  int presol;
+  int rtest;
+  int tmlim;
+  int outdly;
+  double tolbnd;
+  double toldj;
+  double tolpiv;
+  double objll;
+  double objul;
+  double tolint;
+  double tolobj;
 };
 
 static jmp_buf mark;  //-- Address for long jump to jump to
 
-#if 0
-int
-glpk_fault_hook (void * /* info */, char *msg)
-{
-  error ("CRITICAL ERROR in GLPK: %s", msg);
-  longjmp (mark, -1);
-}
-
-int
-glpk_print_hook (void * /* info */, char *msg)
-{
-  message (0, "%s", msg);
-  return 1;
-}
-#endif
-
 int
 glpk (int sense, int n, int m, double *c, int nz, int *rn, int *cn,
       double *a, double *b, char *ctype, int *freeLB, double *lb,
       int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
-      int save_pb, double *xmin, double *fmin, double *status,
-      double *lambda, double *redcosts, double *time, double *mem)
+      int save_pb, int scale, const control_params *par,
+      double *xmin, double *fmin, int *status,
+      double *lambda, double *redcosts, double *time)
 {
-  int errnum;
   int typx = 0;
-  int method;
+  int errnum = 0;
 
   clock_t t_start = clock ();
 
-#if 0
-#ifdef GLPK_PRE_4_14
-  lib_set_fault_hook (0, glpk_fault_hook);
-#else
-  _glp_lib_fault_hook (glpk_fault_hook, 0);
-#endif
-
-  if (lpxIntParam[0] > 1)
-#ifdef GLPK_PRE_4_14
-    lib_set_print_hook (0, glpk_print_hook);
-#else
-    _glp_lib_print_hook (glpk_print_hook, 0);
-#endif
-#endif
-
-  LPX *lp = lpx_create_prob ();
-
+  glp_prob *lp = glp_create_prob ();
 
   //-- Set the sense of optimization
   if (sense == 1)
-    lpx_set_obj_dir (lp, LPX_MIN);
+    glp_set_obj_dir (lp, GLP_MIN);
   else
-    lpx_set_obj_dir (lp, LPX_MAX);
+    glp_set_obj_dir (lp, GLP_MAX);
 
-  //-- If the problem has integer structural variables switch to MIP
-  if (isMIP)
-    lpx_set_class (lp, LPX_MIP);
-
-  lpx_add_cols (lp, n);
+  glp_add_cols (lp, n);
   for (int i = 0; i < n; i++)
     {
       //-- Define type of the structural variables
       if (! freeLB[i] && ! freeUB[i])
         {
           if (lb[i] != ub[i])
-            lpx_set_col_bnds (lp, i+1, LPX_DB, lb[i], ub[i]);
+            glp_set_col_bnds (lp, i+1, GLP_DB, lb[i], ub[i]);
           else
-            lpx_set_col_bnds (lp, i+1, LPX_FX, lb[i], ub[i]);
+            glp_set_col_bnds (lp, i+1, GLP_FX, lb[i], ub[i]);
         }
       else
         {
           if (! freeLB[i] && freeUB[i])
-            lpx_set_col_bnds (lp, i+1, LPX_LO, lb[i], ub[i]);
+            glp_set_col_bnds (lp, i+1, GLP_LO, lb[i], ub[i]);
           else
             {
               if (freeLB[i] && ! freeUB[i])
-                lpx_set_col_bnds (lp, i+1, LPX_UP, lb[i], ub[i]);
+                glp_set_col_bnds (lp, i+1, GLP_UP, lb[i], ub[i]);
               else
-                lpx_set_col_bnds (lp, i+1, LPX_FR, lb[i], ub[i]);
+                glp_set_col_bnds (lp, i+1, GLP_FR, lb[i], ub[i]);
             }
         }
 
       // -- Set the objective coefficient of the corresponding
       // -- structural variable. No constant term is assumed.
-      lpx_set_obj_coef(lp,i+1,c[i]);
+      glp_set_obj_coef(lp,i+1,c[i]);
 
       if (isMIP)
-        lpx_set_col_kind (lp, i+1, vartype[i]);
+        glp_set_col_kind (lp, i+1, vartype[i]);
     }
 
-  lpx_add_rows (lp, m);
+  glp_add_rows (lp, m);
 
   for (int i = 0; i < m; i++)
     {
       /* If the i-th row has no lower bound (types F,U), the
          corrispondent parameter will be ignored.
          If the i-th row has no upper bound (types F,L), the corrispondent
          parameter will be ignored.
          If the i-th row is of S type, the i-th LB is used, but
          the i-th UB is ignored.
       */
 
       switch (ctype[i])
         {
         case 'F':
-          typx = LPX_FR;
+          typx = GLP_FR;
           break;
 
         case 'U':
-          typx = LPX_UP;
+          typx = GLP_UP;
           break;
 
         case 'L':
-          typx = LPX_LO;
+          typx = GLP_LO;
           break;
 
         case 'S':
-          typx = LPX_FX;
+          typx = GLP_FX;
           break;
 
         case 'D':
-          typx = LPX_DB;
+          typx = GLP_DB;
           break;
         }
 
-      lpx_set_row_bnds (lp, i+1, typx, b[i], b[i]);
+      glp_set_row_bnds (lp, i+1, typx, b[i], b[i]);
 
     }
 
-  lpx_load_matrix (lp, nz, rn, cn, a);
+  glp_load_matrix (lp, nz, rn, cn, a);
 
   if (save_pb)
     {
       static char tmp[] = "outpb.lp";
-      if (lpx_write_cpxlp (lp, tmp) != 0)
+      if (glp_write_lp (lp, NULL, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
-  //-- scale the problem data (if required)
-  //-- if (scale && (!presol || method == 1)) lpx_scale_prob (lp);
-  //-- LPX_K_SCALE=IParam[1]  LPX_K_PRESOL=IParam[16]
-  if (lpxIntParam[1] && (! lpxIntParam[16] || lpsolver != 1))
-    lpx_scale_prob (lp);
+  //-- scale the problem data
+  if (!par->presol || lpsolver != 1)
+    glp_scale_prob (lp, scale);
 
   //-- build advanced initial basis (if required)
-  if (lpsolver == 1 && ! lpxIntParam[16])
-    lpx_adv_basis (lp);
-
-  for (int i = 0; i < NIntP; i++)
-    lpx_set_int_parm (lp, IParam[i], lpxIntParam[i]);
+  if (lpsolver == 1 && !par->presol)
+    glp_adv_basis (lp, 0);
 
-  for (int i = 0; i < NRealP; i++)
-    lpx_set_real_parm (lp, RParam[i], lpxRealParam[i]);
-
-  if (lpsolver == 1)
-    method = 'S';
-  else
-    method = 'T';
-
-  switch (method)
+  /* For MIP problems without a presolver, a first pass with glp_simplex
+     is required */
+  if ((!isMIP && lpsolver == 1)
+      || (isMIP && !par->presol))
     {
-    case 'S':
-      {
-        if (isMIP)
-          {
-            method = 'I';
-            errnum = lpx_simplex (lp);
-            errnum = lpx_integer (lp);
-          }
-        else
-          errnum = lpx_simplex (lp);
-      }
-     break;
-
-    case 'T':
-      errnum = lpx_interior (lp);
-      break;
-
-    default:
-      break;
-#if 0
-#ifdef GLPK_PRE_4_14
-      insist (method != method);
-#else
-      static char tmp[] = "method != method";
-      glpk_fault_hook (0, tmp);
-#endif
-#endif
+      glp_smcp smcp;
+      glp_init_smcp (&smcp);
+      smcp.msg_lev = par->msglev;
+      smcp.meth = par->dual;
+      smcp.pricing = par->price;
+      smcp.r_test = par->rtest;
+      smcp.tol_bnd = par->tolbnd;
+      smcp.tol_dj = par->toldj;
+      smcp.tol_piv = par->tolpiv;
+      smcp.obj_ll = par->objll;
+      smcp.obj_ul = par->objul;
+      smcp.it_lim = par->itlim;
+      smcp.tm_lim = par->tmlim;
+      smcp.out_frq = par->outfrq;
+      smcp.out_dly = par->outdly;
+      smcp.presolve = par->presol;
+      errnum = glp_simplex (lp, &smcp);
     }
 
-  /*  errnum assumes the following results:
-      errnum = 0 <=> No errors
-      errnum = 1 <=> Iteration limit exceeded.
-      errnum = 2 <=> Numerical problems with basis matrix.
-  */
-  if (errnum == LPX_E_OK)
+  if (isMIP)
+    {
+      glp_iocp iocp;
+      glp_init_iocp (&iocp);
+      iocp.msg_lev = par->msglev;
+      iocp.br_tech = par->branch;
+      iocp.bt_tech = par->btrack;
+      iocp.tol_int = par->tolint;
+      iocp.tol_obj = par->tolobj;
+      iocp.tm_lim = par->tmlim;
+      iocp.out_frq = par->outfrq;
+      iocp.out_dly = par->outdly;
+      iocp.presolve = par->presol;
+      errnum = glp_intopt (lp, &iocp);
+    }
+
+  if (!isMIP && lpsolver == 2)
+    {
+      glp_iptcp iptcp;
+      glp_init_iptcp (&iptcp);
+      iptcp.msg_lev = par->msglev;
+      errnum = glp_interior (lp, &iptcp);
+    }
+
+  if (errnum == 0)
     {
       if (isMIP)
         {
-          *status = lpx_mip_status (lp);
-          *fmin = lpx_mip_obj_val (lp);
+          *status = glp_mip_status (lp);
+          *fmin = glp_mip_obj_val (lp);
         }
       else
         {
           if (lpsolver == 1)
             {
-              *status = lpx_get_status (lp);
-              *fmin = lpx_get_obj_val (lp);
+              *status = glp_get_status (lp);
+              *fmin = glp_get_obj_val (lp);
             }
           else
             {
-              *status = lpx_ipt_status (lp);
-              *fmin = lpx_ipt_obj_val (lp);
+              *status = glp_ipt_status (lp);
+              *fmin = glp_ipt_obj_val (lp);
             }
         }
 
       if (isMIP)
         {
           for (int i = 0; i < n; i++)
-            xmin[i] = lpx_mip_col_val (lp, i+1);
+            xmin[i] = glp_mip_col_val (lp, i+1);
         }
       else
         {
           /* Primal values */
           for (int i = 0; i < n; i++)
             {
               if (lpsolver == 1)
-                xmin[i] = lpx_get_col_prim (lp, i+1);
+                xmin[i] = glp_get_col_prim (lp, i+1);
               else
-                xmin[i] = lpx_ipt_col_prim (lp, i+1);
+                xmin[i] = glp_ipt_col_prim (lp, i+1);
             }
 
           /* Dual values */
           for (int i = 0; i < m; i++)
             {
               if (lpsolver == 1)
-                lambda[i] = lpx_get_row_dual (lp, i+1);
+                lambda[i] = glp_get_row_dual (lp, i+1);
               else
-                lambda[i] = lpx_ipt_row_dual (lp, i+1);
+                lambda[i] = glp_ipt_row_dual (lp, i+1);
             }
 
           /* Reduced costs */
-          for (int i = 0; i < lpx_get_num_cols (lp); i++)
+          for (int i = 0; i < glp_get_num_cols (lp); i++)
             {
               if (lpsolver == 1)
-                redcosts[i] = lpx_get_col_dual (lp, i+1);
+                redcosts[i] = glp_get_col_dual (lp, i+1);
               else
-                redcosts[i] = lpx_ipt_col_dual (lp, i+1);
+                redcosts[i] = glp_ipt_col_dual (lp, i+1);
             }
         }
 
       *time = (clock () - t_start) / CLOCKS_PER_SEC;
-
-#ifdef GLPK_PRE_4_14
-      *mem = (lib_env_ptr () -> mem_tpeak);
-#else
-      *mem = 0;
-#endif
-
-      lpx_delete_prob (lp);
-      return 0;
     }
 
-   lpx_delete_prob (lp);
-
-   *status = errnum;
+   glp_delete_prob (lp);
 
    return errnum;
 }
 
 #endif
 
-#define OCTAVE_GLPK_GET_REAL_PARAM(NAME, IDX) \
+#define OCTAVE_GLPK_GET_REAL_PARAM(NAME, VAL) \
   do \
     { \
       octave_value tmp = PARAM.getfield (NAME); \
  \
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
             { \
-              lpxRealParam[IDX] = tmp.scalar_value (); \
+              VAL = tmp.scalar_value (); \
  \
               if (error_state) \
                 { \
                   error ("glpk: invalid value in PARAM." NAME); \
                   return retval; \
                 } \
             } \
           else \
@@ -654,20 +538,20 @@ Undocumented internal function.\n\
 
   Array<int> vartype (dim_vector (mrowsc, 1));
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
-          vartype(i) = LPX_IV;
+          vartype(i) = GLP_IV;
         }
       else
-        vartype(i) = LPX_CV;
+        vartype(i) = GLP_CV;
     }
 
   //-- 8th Input. Sense of optimization.
   volatile int sense;
   double SENSE = args(7).scalar_value ();
 
   if (error_state)
     {
@@ -684,170 +568,184 @@ Undocumented internal function.\n\
   octave_scalar_map PARAM = args(8).scalar_map_value ();
 
   if (error_state)
     {
       error ("__glpk__: invalid value of PARAM");
       return retval;
     }
 
+  control_params par;
+
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   //-- Integer parameters
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   //-- Level of messages output by the solver
-  OCTAVE_GLPK_GET_INT_PARAM ("msglev", lpxIntParam[0]);
-  if (lpxIntParam[0] < 0 || lpxIntParam[0] > 3)
+  par.msglev = 1;
+  OCTAVE_GLPK_GET_INT_PARAM ("msglev", par.msglev);
+  if (par.msglev < 0 || par.msglev > 3)
     {
-      error ("__glpk__: PARAM.msglev must be 0 (no output [default]) or 1 (error messages only) or 2 (normal output) or 3 (full output)");
+      error ("__glpk__: PARAM.msglev must be 0 (no output) or 1 (error and warning messages only [default]) or 2 (normal output) or 3 (full output)");
       return retval;
     }
 
   //-- scaling option
-  OCTAVE_GLPK_GET_INT_PARAM ("scale", lpxIntParam[1]);
-  if (lpxIntParam[1] < 0 || lpxIntParam[1] > 2)
+  volatile int scale = 16;
+  OCTAVE_GLPK_GET_INT_PARAM ("scale", scale);
+  if (scale < 0 || scale > 128)
     {
-      error ("__glpk__: PARAM.scale must be 0 (no scaling) or 1 (equilibration scaling [default]) or 2 (geometric mean scaling)");
+      error ("__glpk__: PARAM.scale must either be 128 (automatic selection of scaling options), or a bitwise or of: 1 (geometric mean scaling), 16 (equilibration scaling), 32 (round scale factors to power of two), 64 (skip if problem is well scaled");
       return retval;
     }
 
-  //-- Dual dimplex option
-  OCTAVE_GLPK_GET_INT_PARAM ("dual", lpxIntParam[2]);
-  if (lpxIntParam[2] < 0 || lpxIntParam[2] > 1)
+  //-- Dual simplex option
+  par.dual = 1;
+  OCTAVE_GLPK_GET_INT_PARAM ("dual", par.dual);
+  if (par.dual < 1 || par.dual > 3)
     {
-      error ("__glpk__: PARAM.dual must be 0 (do NOT use dual simplex [default]) or 1 (use dual simplex)");
+      error ("__glpk__: PARAM.dual must be 1 (use two-phase primal simplex [default]) or 2 (use two-phase dual simplex) or 3 (use two-phase dual simplex, and if it fails, switch to the primal simplex)");
       return retval;
     }
 
   //-- Pricing option
-  OCTAVE_GLPK_GET_INT_PARAM ("price", lpxIntParam[3]);
-  if (lpxIntParam[3] < 0 || lpxIntParam[3] > 1)
+  par.price = 34;
+  OCTAVE_GLPK_GET_INT_PARAM ("price", par.price);
+  if (par.price != 17 && par.price != 34)
     {
-      error ("__glpk__: PARAM.price must be 0 (textbook pricing) or 1 (steepest edge pricing [default])");
-      return retval;
-    }
-
-  //-- Solution rounding option
-  OCTAVE_GLPK_GET_INT_PARAM ("round", lpxIntParam[4]);
-  if (lpxIntParam[4] < 0 || lpxIntParam[4] > 1)
-    {
-      error ("__glpk__: PARAM.round must be 0 (report all primal and dual values [default]) or 1 (replace tiny primal and dual values by exact zero)");
+      error ("__glpk__: PARAM.price must be 17 (textbook pricing) or 34 (steepest edge pricing [default])");
       return retval;
     }
 
   //-- Simplex iterations limit
-  OCTAVE_GLPK_GET_INT_PARAM ("itlim", lpxIntParam[5]);
-
-  //-- Simplex iterations count
-  OCTAVE_GLPK_GET_INT_PARAM ("itcnt", lpxIntParam[6]);
+  par.itlim = std::numeric_limits<int>::max ();
+  OCTAVE_GLPK_GET_INT_PARAM ("itlim", par.itlim);
 
   //-- Output frequency, in iterations
-  OCTAVE_GLPK_GET_INT_PARAM ("outfrq", lpxIntParam[7]);
+  par.outfrq = 200;
+  OCTAVE_GLPK_GET_INT_PARAM ("outfrq", par.outfrq);
 
   //-- Branching heuristic option
-  OCTAVE_GLPK_GET_INT_PARAM ("branch", lpxIntParam[14]);
-  if (lpxIntParam[14] < 0 || lpxIntParam[14] > 2)
+  par.branch = 4;
+  OCTAVE_GLPK_GET_INT_PARAM ("branch", par.branch);
+  if (par.branch < 1 || par.branch > 5)
     {
-      error ("__glpk__: PARAM.branch must be (MIP only) 0 (branch on first variable) or 1 (branch on last variable) or 2 (branch using a heuristic by Driebeck and Tomlin [default]");
+      error ("__glpk__: PARAM.branch must be 1 (first fractional variable) or 2 (last fractional variable) or 3 (most fractional variable) or 4 (heuristic by Driebeck and Tomlin [default]) or 5 (hybrid pseudocost heuristic)");
       return retval;
     }
 
   //-- Backtracking heuristic option
-  OCTAVE_GLPK_GET_INT_PARAM ("btrack", lpxIntParam[15]);
-  if (lpxIntParam[15] < 0 || lpxIntParam[15] > 2)
+  par.btrack = 4;
+  OCTAVE_GLPK_GET_INT_PARAM ("btrack", par.btrack);
+  if (par.btrack < 1 || par.btrack > 4)
     {
-      error ("__glpk__: PARAM.btrack must be (MIP only) 0 (depth first search) or 1 (breadth first search) or 2 (backtrack using the best projection heuristic [default]");
+      error ("__glpk__: PARAM.btrack must be 1 (depth first search) or 2 (breadth first search) or 3 (best local bound) or 4 (best projection heuristic [default]");
       return retval;
     }
 
   //-- Presolver option
-  OCTAVE_GLPK_GET_INT_PARAM ("presol", lpxIntParam[16]);
-  if (lpxIntParam[16] < 0 || lpxIntParam[16] > 1)
+  par.presol = 1;
+  OCTAVE_GLPK_GET_INT_PARAM ("presol", par.presol);
+  if (par.presol < 0 || par.presol > 1)
     {
       error ("__glpk__: PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
       return retval;
     }
 
   //-- LPsolver option
   volatile int lpsolver = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("lpsolver", lpsolver);
   if (lpsolver < 1 || lpsolver > 2)
     {
       error ("__glpk__: PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");
       return retval;
     }
 
+  //-- Ratio test option
+  par.rtest = 34;
+  OCTAVE_GLPK_GET_INT_PARAM ("rtest", par.rtest);
+  if (par.rtest != 17 && par.rtest != 34)
+    {
+      error ("__glpk__: PARAM.rtest must be 17 (standard ratio test) or 34 (Harris' two-pass ratio test [default])");
+      return retval;
+    }
+
+  par.tmlim = std::numeric_limits<int>::max ();
+  OCTAVE_GLPK_GET_INT_PARAM ("tmlim", par.tmlim);
+
+  par.outdly = 0;
+  OCTAVE_GLPK_GET_INT_PARAM ("outdly", par.outdly);
+
   //-- Save option
   volatile int save_pb = 0;
   OCTAVE_GLPK_GET_INT_PARAM ("save", save_pb);
   save_pb = save_pb != 0;
 
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   //-- Real parameters
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
-  //-- Ratio test option
-  OCTAVE_GLPK_GET_REAL_PARAM ("relax", 0);
-
   //-- Relative tolerance used to check if the current basic solution
   //-- is primal feasible
-  OCTAVE_GLPK_GET_REAL_PARAM ("tolbnd", 1);
+  par.tolbnd = 1e-7;
+  OCTAVE_GLPK_GET_REAL_PARAM ("tolbnd", par.tolbnd);
 
   //-- Absolute tolerance used to check if the current basic solution
   //-- is dual feasible
-  OCTAVE_GLPK_GET_REAL_PARAM ("toldj", 2);
+  par.toldj = 1e-7;
+  OCTAVE_GLPK_GET_REAL_PARAM ("toldj", par.toldj);
 
   //-- Relative tolerance used to choose eligible pivotal elements of
   //--  the simplex table in the ratio test
-  OCTAVE_GLPK_GET_REAL_PARAM ("tolpiv", 3);
+  par.tolpiv = 1e-10;
+  OCTAVE_GLPK_GET_REAL_PARAM ("tolpiv", par.tolpiv);
 
-  OCTAVE_GLPK_GET_REAL_PARAM ("objll", 4);
-
-  OCTAVE_GLPK_GET_REAL_PARAM ("objul", 5);
+  par.objll = -std::numeric_limits<double>::max ();
+  OCTAVE_GLPK_GET_REAL_PARAM ("objll", par.objll);
 
-  OCTAVE_GLPK_GET_REAL_PARAM ("tmlim", 6);
-
-  OCTAVE_GLPK_GET_REAL_PARAM ("outdly", 7);
+  par.objul = std::numeric_limits<double>::max ();
+  OCTAVE_GLPK_GET_REAL_PARAM ("objul", par.objul);
 
-  OCTAVE_GLPK_GET_REAL_PARAM ("tolint", 8);
+  par.tolint = 1e-5;
+  OCTAVE_GLPK_GET_REAL_PARAM ("tolint", par.tolint);
 
-  OCTAVE_GLPK_GET_REAL_PARAM ("tolobj", 9);
+  par.tolobj = 1e-7;
+  OCTAVE_GLPK_GET_REAL_PARAM ("tolobj", par.tolobj);
 
   //-- Assign pointers to the output parameters
   ColumnVector xmin (mrowsc, octave_NA);
   double fmin = octave_NA;
-  double status;
   ColumnVector lambda (mrowsA, octave_NA);
   ColumnVector redcosts (mrowsc, octave_NA);
   double time;
-  double mem;
+  int status, errnum = 0;
 
   int jmpret = setjmp (mark);
 
   if (jmpret == 0)
-    glpk (sense, mrowsc, mrowsA, c, nz, rn.fortran_vec (),
-          cn.fortran_vec (), a.fortran_vec (), b, ctype,
-          freeLB.fortran_vec (), lb, freeUB.fortran_vec (), ub,
-          vartype.fortran_vec (), isMIP, lpsolver, save_pb,
-          xmin.fortran_vec (), &fmin, &status, lambda.fortran_vec (),
-          redcosts.fortran_vec (), &time, &mem);
+    errnum = glpk (sense, mrowsc, mrowsA, c, nz, rn.fortran_vec (),
+                   cn.fortran_vec (), a.fortran_vec (), b, ctype,
+                   freeLB.fortran_vec (), lb, freeUB.fortran_vec (), ub,
+                   vartype.fortran_vec (), isMIP, lpsolver, save_pb, scale, &par,
+                   xmin.fortran_vec (), &fmin, &status, lambda.fortran_vec (),
+                   redcosts.fortran_vec (), &time);
 
   octave_scalar_map extra;
 
   if (! isMIP)
     {
       extra.assign ("lambda", lambda);
       extra.assign ("redcosts", redcosts);
     }
 
   extra.assign ("time", time);
-  extra.assign ("mem", mem);
+  extra.assign ("status", status);
 
   retval(3) = extra;
-  retval(2) = status;
+  retval(2) = errnum;
   retval(1) = fmin;
   retval(0) = xmin;
 
 #else
 
   gripe_not_supported ("glpk");
 
 #endif
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -250,17 +250,17 @@ private:
         return 1;
       }
 
     return retval;
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
-static double wheel_zoom_speed = 0.05;
+static double Vwheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
 void script_cb (Fl_Widget*, void* data)
   {
     static_cast<uimenu::properties*> (data)->execute_callback ();
   }
 
@@ -657,73 +657,79 @@ private:
   Fl_Menu_Bar* menubar;
 };
 
 class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
 public:
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp)
-    : Fl_Window (xx, yy, ww, hh, "octave"), window_label (), shift (0),
-      ndim (2), fp (xfp), canvas (0), autoscale (0), togglegrid (0),
-      panzoom (0), rotate (0), help (0), status (0),
-      ax_obj (), pos_x (0), pos_y (0)
+    : Fl_Window (xx, yy - menu_h, ww, hh + menu_h + status_h, "octave"),
+      window_label (), shift (0), ndim (2), fp (xfp), canvas (0),
+      autoscale (0), togglegrid (0), panzoom (0), rotate (0), help (0),
+      status (0), ax_obj (), pos_x (0), pos_y (0)
   {
     callback (window_close, static_cast<void*> (this));
     size_range (4*status_h, 2*status_h);
 
     // FIXME: The function below is only available in FLTK >= 1.3
     // At some point support for FLTK 1.1 will be dropped in Octave.
     // At that point this function should be uncommented.
     // The current solution is to call xclass() before show() for each window.
     // Set WM_CLASS which allows window managers to properly group related
     // windows.  Otherwise, the class is just "FLTK"
     //default_xclass ("Octave");
 
     begin ();
     {
+      // bbox of plot canvas = [xx, yy, ww, hh];
+      // (xx, yy) = UL coordinate relative to UL window.
 
-      canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
+      canvas = new OpenGL_fltk (0, menu_h, ww, hh, number ());
 
       uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
-      bottom = new Fl_Box (0, hh - status_h, ww, status_h);
+      // Toolbar is a composite of "bottom", "autoscale", "togglegrid",
+      // "panzoom", "rotate", "help", and "status".
+
+      yy = hh + menu_h;
+      bottom = new Fl_Box (0, yy, ww, status_h);
       bottom->box (FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
-      autoscale = new Fl_Button (0, hh - status_h, status_h, status_h, "A");
+      autoscale = new Fl_Button (0, yy, status_h, status_h, "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
       autoscale->tooltip ("Autoscale");
 
-      togglegrid = new Fl_Button (status_h, hh - status_h, status_h,
+      togglegrid = new Fl_Button (status_h, yy, status_h,
                                   status_h, "G");
       togglegrid->callback (button_callback, static_cast<void*> (this));
       togglegrid->tooltip ("Toggle Grid");
 
-      panzoom = new Fl_Button (2 * status_h, hh - status_h, status_h,
+      panzoom = new Fl_Button (2 * status_h, yy, status_h,
                                status_h, "P");
       panzoom->callback (button_callback, static_cast<void*> (this));
       panzoom->tooltip ("Mouse Pan/Zoom");
 
-      rotate = new Fl_Button (3 * status_h, hh - status_h, status_h,
+      rotate = new Fl_Button (3 * status_h, yy, status_h,
                               status_h, "R");
       rotate->callback (button_callback, static_cast<void*> (this));
       rotate->tooltip ("Mouse Rotate");
 
       if (ndim == 2)
         rotate->deactivate ();
 
-      help = new Fl_Button (4 * status_h, hh - status_h, status_h,
+      help = new Fl_Button (4 * status_h, yy, status_h,
                             status_h, "?");
       help->callback (button_callback, static_cast<void*> (this));
       help->tooltip ("Help");
 
-      status = new Fl_Output (5 * status_h, hh - status_h,
+      status = new Fl_Output (5 * status_h, yy,
                               ww > 2*status_h ? ww - status_h : 0,
                               status_h, "");
 
       status->textcolor (FL_BLACK);
       status->color (FL_GRAY);
       status->textfont (FL_COURIER);
       status->textsize (10);
       status->box (FL_ENGRAVED_BOX);
@@ -794,33 +800,27 @@ public:
     mark_modified ();
     Fl::wait (fltk_maxtime);
   }
 
   void show_menubar (void)
   {
     if (!uimenu->is_visible ())
       {
-        canvas->resize (canvas->x (),
-                        canvas->y () + menu_h,
-                        canvas->w (),
-                        canvas->h () - menu_h);
+        // FIXME - Toolbar and menubar do not update
         uimenu->show ();
         mark_modified ();
       }
   }
 
   void hide_menubar (void)
   {
     if (uimenu->is_visible ())
       {
-        canvas->resize (canvas->x (),
-                        canvas->y () - menu_h,
-                        canvas->w (),
-                        canvas->h () + menu_h);
+        // FIXME - Toolbar and menubar do not update
         uimenu->hide ();
         mark_modified ();
       }
   }
 
   void uimenu_update (const graphics_handle& gh, int id)
   {
     graphics_object uimenu_obj = gh_manager::get_object (gh);
@@ -1103,18 +1103,22 @@ private:
   }
 
   void set_currentpoint (int px, int py)
   {
     if (!fp.is_beingdeleted ())
       {
         Matrix pos (1,2,0);
         pos(0) = px;
-        pos(1) = h () - status_h - menu_h - py;
+        pos(1) = h () - (py + status_h + menu_dy ());
         fp.set_currentpoint (pos);
+        graphics_object robj = gh_manager::get_object (fp.get_parent ());
+        root_figure::properties& rp =
+          dynamic_cast<root_figure::properties&> (robj.get_properties ());
+        rp.set_currentfigure (fp.get___myhandle__ ().value ());
       }
   }
 
   void set_axes_currentpoint (graphics_object ax, int px, int py)
   {
     if (ax.valid_object ())
       {
         axes::properties& ap =
@@ -1125,19 +1129,28 @@ private:
 
         Matrix pos (2,3,0);
         pos(0,0) = xx;
         pos(1,0) = yy;
         pos(0,1) = xx;
         pos(1,1) = yy;
 
         ap.set_currentpoint (pos);
+        fp.set_currentaxes (ap.get___myhandle__ ().value ());
       }
   }
 
+  int menu_dy ()
+    {
+      if (uimenu->is_visible ())
+        return menu_h;
+      else
+        return 0;
+    }
+
   int key2shift (int key)
   {
     if (key == FL_Shift_L || key == FL_Shift_R)
       return FL_SHIFT;
 
     if (key == FL_Control_L || key == FL_Control_R)
       return FL_CTRL;
 
@@ -1176,27 +1189,45 @@ private:
   }
 
   void resize (int xx,int yy,int ww,int hh)
   {
     Fl_Window::resize (xx, yy, ww, hh);
 
     Matrix pos (1,4,0);
     pos(0) = xx;
-    pos(1) = yy;
+    pos(1) = yy + menu_dy ();
     pos(2) = ww;
-    pos(3) = hh - status_h - menu_h;
+    pos(3) = hh - menu_dy () - status_h;
 
     fp.set_boundingbox (pos, true);
   }
 
   void draw (void)
   {
+    // FIXME - Toolbar and menubar do not update properly
     Matrix pos = fp.get_boundingbox (true);
-    Fl_Window::resize (pos(0), pos(1), pos(2), pos(3) + status_h + menu_h);
+    int canvas_h = pos(3);
+    int canvas_w = pos(2);
+    int canvas_y = menu_dy ();
+    int toolbar_y = menu_dy () + canvas_h;
+    pos(1) = pos(1) - menu_dy ();
+    pos(3) = pos(3) + menu_dy () + status_h;
+
+    Fl_Window::resize (pos(0), pos(1), pos(2), pos(3));
+
+    bottom->resize (0, toolbar_y, status_h, status_h);
+    autoscale->resize (0, toolbar_y, status_h, status_h);
+    togglegrid->resize (status_h, toolbar_y, status_h, status_h);
+    panzoom->resize (2 * status_h, toolbar_y, status_h, status_h);
+    rotate->resize (3 * status_h, toolbar_y, status_h, status_h);
+    help->resize (4 * status_h, toolbar_y, status_h, status_h);
+    status->resize (5 * status_h, toolbar_y, pos(2) - 4 * status_h, status_h);
+    if (canvas->valid ())
+      canvas->resize (0, canvas_y, canvas_w, canvas_h);
 
     return Fl_Window::draw ();
   }
 
   int handle (int event)
   {
     graphics_handle gh;
 
@@ -1263,25 +1294,25 @@ private:
                   evt.assign ("Key", octave_value (std::tolower (key_a)));
                   evt.assign ("Modifier", octave_value (modifier2cell ()));
                   fp.execute_keyreleasefcn (evt);
                 }
             }
             break;
 
           case FL_MOVE:
-            pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y ()),
-                          Fl::event_x (), Fl::event_y ());
+            pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y () - menu_dy ()),
+                          Fl::event_x (), Fl::event_y () - menu_dy ());
             break;
 
           case FL_PUSH:
             pos_x = Fl::event_x ();
-            pos_y = Fl::event_y ();
+            pos_y = Fl::event_y () - menu_dy ();
 
-            set_currentpoint (Fl::event_x (), Fl::event_y ());
+            set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
 
             gh = pixel2axes_or_ca (pos_x, pos_y);
 
             if (gh.ok ())
               {
                 ax_obj = gh_manager::get_object (gh);
                 set_axes_currentpoint (ax_obj, pos_x, pos_y);
               }
@@ -1291,97 +1322,98 @@ private:
             if (Fl::event_button () == 1 || Fl::event_button () == 3)
               return 1;
 
             break;
 
           case FL_DRAG:
             if (fp.get_windowbuttonmotionfcn ().is_defined ())
               {
-                set_currentpoint (Fl::event_x (), Fl::event_y ());
+                set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                 fp.execute_windowbuttonmotionfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
                 if (ax_obj && ax_obj.isa ("axes"))
                   {
                     if (gui_mode == pan_zoom)
                       pixel2status (ax_obj, pos_x, pos_y,
-                                    Fl::event_x (), Fl::event_y ());
+                                    Fl::event_x (), Fl::event_y () - menu_dy ());
                     else
                       view2status (ax_obj);
                     axes::properties& ap =
                       dynamic_cast<axes::properties&> (ax_obj.get_properties ());
 
                     double x0, y0, x1, y1;
                     Matrix pos = fp.get_boundingbox (true);
                     pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
-                    pixel2pos (ax_obj, Fl::event_x (), Fl::event_y (), x1, y1);
+                    pixel2pos (ax_obj, Fl::event_x (), Fl::event_y () - menu_dy (), x1, y1);
 
                     if (gui_mode == pan_zoom)
                       ap.translate_view (x0, x1, y0, y1);
                     else if (gui_mode == rotate_zoom)
                       {
                         double daz, del;
                         daz = (Fl::event_x () - pos_x) / pos(2) * 360;
-                        del = (Fl::event_y () - pos_y) / pos(3) * 360;
+                        del = (Fl::event_y () - menu_dy () - pos_y) / pos(3) * 360;
                         ap.rotate_view (del, daz);
                       }
 
                     pos_x = Fl::event_x ();
-                    pos_y = Fl::event_y ();
+                    pos_y = Fl::event_y () - menu_dy ();
                     mark_modified ();
                   }
                 return 1;
               }
             else if (Fl::event_button () == 3)
               {
                 pixel2status (ax_obj, pos_x, pos_y,
-                              Fl::event_x (), Fl::event_y ());
+                              Fl::event_x (), Fl::event_y () - menu_dy ());
                 Matrix zoom_box (1,4,0);
                 zoom_box (0) = pos_x;
                 zoom_box (1) = pos_y;
                 zoom_box (2) =  Fl::event_x ();
-                zoom_box (3) =  Fl::event_y ();
+                zoom_box (3) =  Fl::event_y () - menu_dy ();
                 canvas->set_zoom_box (zoom_box);
                 canvas->zoom (true);
                 canvas->redraw ();
               }
 
             break;
 
           case FL_MOUSEWHEEL:
             {
               graphics_object ax =
                 gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (),
-                                                          Fl::event_y ()));
+                                                          Fl::event_y () - menu_dy ()));
               if (ax && ax.isa ("axes"))
                 {
                   axes::properties& ap =
                     dynamic_cast<axes::properties&> (ax.get_properties ());
 
                   // Determine if we're zooming in or out.
                   const double factor =
-                    (Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
+                    (Fl::event_dy () > 0) ? 1 / (1.0 - Vwheel_zoom_speed)
+                                          : 1.0 - Vwheel_zoom_speed;
 
                   // Get the point we're zooming about.
                   double x1, y1;
-                  pixel2pos (ax, Fl::event_x (), Fl::event_y (), x1, y1);
+                  pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (), x1, y1);
 
                   ap.zoom_about_point (x1, y1, factor, false);
                   mark_modified ();
                 }
             }
           return 1;
 
           case FL_RELEASE:
             if (fp.get_windowbuttonupfcn ().is_defined ())
               {
-                set_currentpoint (Fl::event_x (), Fl::event_y ());
+                set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                 fp.execute_windowbuttonupfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
                 if ( Fl::event_clicks () == 1)
                   {
                     if (ax_obj && ax_obj.isa ("axes"))
@@ -1403,17 +1435,17 @@ private:
                     canvas->zoom (false);
                     double x0,y0,x1,y1;
                     if (ax_obj && ax_obj.isa ("axes"))
                       {
                         axes::properties& ap =
                           dynamic_cast<axes::properties&> (ax_obj.get_properties ());
                         pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
                         int pos_x1 = Fl::event_x ();
-                        int pos_y1 = Fl::event_y ();
+                        int pos_y1 = Fl::event_y () - menu_dy ();
                         pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
                         Matrix xl (1,2,0);
                         Matrix yl (1,2,0);
                         int dx = abs (pos_x - pos_x1);
                         int dy = abs (pos_y - pos_y1);
                         // Smallest zoom box must be 4 pixels square
                         if ((dx > 4) && (dy > 4))
                           {
@@ -1840,17 +1872,28 @@ public:
       input_event_hook_fcn_id ()
   { }
 
   ~fltk_graphics_toolkit (void) { }
 
   bool is_valid (void) const { return true; }
 
   bool initialize (const graphics_object& go)
-    { return go.isa ("figure"); }
+  {
+    if (go.isa ("figure")
+        || go.isa ("uimenu"))
+      {
+        if (go.isa ("uimenu"))
+          update (go, uimenu::properties::ID_LABEL);
+
+        return true;
+      }
+
+    return false;
+  }
 
   void finalize (const graphics_object& go)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
         if (! ov.is_empty ())
@@ -2081,66 +2124,66 @@ Undocumented internal function.\n\
   retval = true;
 #else
   retval = false;
 #endif
 
   return retval;
 }
 
-// FIXME -- This function should be abstracted and made potentially
+// FIXME: This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
-DEFUN_DLD (mouse_wheel_zoom, args, ,
+DEFUN_DLD (mouse_wheel_zoom, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {@var{speed} =} mouse_wheel_zoom ()\n\
-@deftypefnx {Built-in Function} {} mouse_wheel_zoom (@var{speed})\n\
+@deftypefn  {Loadable Function} {@var{val} =} mouse_wheel_zoom ()\n\
+@deftypefnx {Loadable Function} {@var{old_val} =} mouse_wheel_zoom (@var{new_val})\n\
+@deftypefnx {Loadable Function} {} mouse_wheel_zoom (@var{new_val}, \"local\")\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
+The zoom factor is a number in the range (0,1) which is the percentage of the\n\
+current axis limits that will be used when zooming.  For example, if the\n\
+current x-axis limits are [0, 50] and @code{mouse_wheel_zoom} is 0.4 (40%),\n\
+then a zoom operation will change the limits by 20.\n\
+\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
+\n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{gui_mode}\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
-  octave_value retval = wheel_zoom_speed;
-
-  if (args.length () == 1)
-    {
-      if (args(0).is_real_scalar ())
-        wheel_zoom_speed = args(0).double_value ();
-      else
-        error ("mouse_wheel_zoom: SPEED must be a real scalar");
-    }
-
-  return retval;
+  return SET_INTERNAL_VARIABLE_WITH_LIMITS(wheel_zoom_speed, 0.0001, 0.9999);
 #else
   error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
   return octave_value ();
 #endif
 }
 
 DEFUN_DLD (gui_mode, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
 \n\
 @table @asis\n\
-@item '2d'\n\
+@item @qcode{\"2d\"}\n\
 Allows panning and zooming of current axes.\n\
 \n\
-@item '3d'\n\
+@item @qcode{\"3d\"}\n\
 Allows rotating and zooming of current axes.\n\
 \n\
-@item 'none'\n\
+@item @qcode{\"none\"}\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 \n\
 This function is currently implemented only for the FLTK graphics toolkit.\n\
 @seealso{mouse_wheel_zoom}\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2013 Carn Draug
 Copyright (C) 2002-2012 Andy Adler
 Copyright (C) 2008 Thomas L. Scofield
 Copyright (C) 2010 David Grundberg
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -21,1196 +22,2137 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cmath>
-
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov-struct.h"
 
+#include "gripes.h"
+
 #ifdef HAVE_MAGICK
 
 #include <Magick++.h>
 #include <clocale>
 
-octave_value_list
-read_indexed_images (std::vector<Magick::Image>& imvec,
-                     const Array<int>& frameidx, bool wantalpha)
+// In theory, it should be enough to check the class:
+// Magick::ClassType
+// PseudoClass:
+// Image is composed of pixels which specify an index in a color palette.
+// DirectClass:
+// Image is composed of pixels which represent literal color values.
+//
+//  GraphicsMagick does not really distinguishes between indexed and
+//  normal images. After reading a file, it decides itself the optimal
+//  way to store the image in memory, independently of the how the
+//  image was stored in the file. That's what ClassType returns. While
+//  it seems to match the original file most of the times, this is
+//  not necessarily true all the times. See
+//    https://sourceforge.net/mailarchive/message.php?msg_id=31180507
+//  In addition to the ClassType, there is also ImageType which has a
+//  type for indexed images (PaletteType and PaletteMatteType). However,
+//  they also don't represent the original image. Not only does DirectClass
+//  can have a PaletteType, but also does a PseudoClass have non Palette
+//  types.
+//
+//        We can't do better without having format specific code which is
+//        what we are trying to avoid by using a library such as GM. We at
+//        least create workarounds for the most common problems.
+//
+// 1) A grayscale jpeg image can report being indexed even though the
+//    JPEG format has no support for indexed images. We can at least
+//    fix this one.
+// 2) A PNG file is only an indexed image if color type orig is 3 (value comes
+//    from libpng)
+static bool
+is_indexed (const Magick::Image& img)
 {
-  octave_value_list output;
-
-  int rows = imvec[0].baseRows ();
-  int columns = imvec[0].baseColumns ();
-  int nframes = frameidx.length ();
-
-  dim_vector idim = dim_vector ();
-  idim.resize (4);
-  idim(0) = rows;
-  idim(1) = columns;
-  idim(2) = 1;
-  idim(3) = nframes;
-
-  Array<int> idx (dim_vector (4, 1));
-
-  Magick::ImageType type = imvec[0].type ();
-
-  unsigned int mapsize = imvec[0].colorMapSize ();
-  unsigned int i = mapsize;
-  unsigned int depth = 0;
-  while (i >>= 1)
-    depth++;
-  i = 0;
-  depth--;
-  while (depth >>= 1)
-    i++;
-  depth = 1 << i;
+  bool retval = false;
+  const std::string format = img.magick ();
+  if (img.classType () == Magick::PseudoClass
+      && format != "JPEG"
+      && (format != "PNG"
+          || const_cast<Magick::Image&> (img).attribute ("PNG:IHDR.color-type-orig") == "3"))
+    retval = true;
 
-  switch (depth)
-    {
-    case 1:
-    case 2:
-    case 4:
-    case 8:
-      {
-        uint8NDArray im = uint8NDArray (idim);
-
-        idx(2) = 0;
-        for (int frame = 0; frame < nframes; frame++)
-          {
-            imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
-
-            const Magick::IndexPacket *pix
-              = imvec[frameidx(frame)].getConstIndexes ();
-
-            i = 0;
-            idx(3) = frame;
-
-            for (int y = 0; y < rows; y++)
-              {
-                idx(0) = y;
-                for (int x = 0; x < columns; x++)
-                  {
-                    idx(1) = x;
-                    im(idx) = static_cast<octave_uint8> (pix[i++]);
-                  }
-              }
-          }
-
-        output(0) = octave_value (im);
-      }
-      break;
-
-    case 16:
-      {
-        uint16NDArray im = uint16NDArray (idim);
+  return retval;
+}
 
-        idx(2) = 0;
-        for (int frame = 0; frame < nframes; frame++)
-          {
-            imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
-
-            const Magick::IndexPacket *pix
-              = imvec[frameidx(frame)].getConstIndexes ();
-
-            i = 0;
-            idx(3) = frame;
+//  The depth from depth() is not always correct for us but seems to be the
+//  best value we can get. For example, a grayscale png image with 1 bit
+//  per channel should return a depth of 1 but instead we get 8.
+//  We could check channelDepth() but then, which channel has the data
+//  is not straightforward. So we'd have to check all
+//  the channels and select the highest value. But then, I also
+//  have a 16bit TIFF whose depth returns 16 (correct), but all of the
+//  channels gives 8 (wrong). No idea why, maybe a bug in GM?
+//  Anyway, using depth() seems that only causes problems for binary
+//  images, and the problem with channelDepth() is not making set them
+//  all to 1. So we will guess that if all channels have depth of 1,
+//  then we must have a binary image.
+//  Note that we can't use AllChannels it doesn't work for this.
+//  Instead of checking all of the individual channels, we check one
+//  from RGB, CMYK, grayscale, and transparency.
+static octave_idx_type
+get_depth (Magick::Image& img)
+{
+  octave_idx_type depth = img.depth ();
+  if (depth == 8
+      && img.channelDepth (Magick::RedChannel)     == 1
+      && img.channelDepth (Magick::CyanChannel)    == 1
+      && img.channelDepth (Magick::OpacityChannel) == 1
+      && img.channelDepth (Magick::GrayChannel)    == 1)
+    depth = 1;
 
-            for (int y = 0; y < rows; y++)
-              {
-                idx(0) = y;
-                for (int x = 0; x < columns; x++)
-                  {
-                    idx(1) = x;
-                    im(idx) = static_cast<octave_uint16> (pix[i++]);
-                  }
-              }
-          }
+  return depth;
+}
 
-        output(0) = octave_value (im);
-      }
-      break;
-
-    default:
-      error ("__magic_read__: index depths greater than 16-bit are not supported");
-      return octave_value_list ();
-    }
-
-  Matrix map = Matrix (mapsize, 3);
-  Matrix alpha;
-
-  switch (type)
+// We need this in case one of the sides of the image being read has
+// width 1. In those cases, the type will come as scalar instead of range
+// since that's the behaviour of the colon operator (1:1:1 will be a scalar,
+// not a range).
+static Range
+get_region_range (const octave_value& region)
+{
+  Range output;
+  if (region.is_range ())
+    output = region.range_value ();
+  else if (region.is_scalar_type ())
     {
-    case Magick::PaletteMatteType:
-#if 0
-      warning ("palettematte");
-      Matrix map (mapsize, 3);
-      Matrix alpha (mapsize, 1);
-      for (i = 0; i < mapsize; i++)
-        {
-          warning ("%d", i);
-          Magick::ColorRGB c = imvec[0].colorMap (i);
-          map(i,0) = c.red ();
-          map(i,1) = c.green ();
-          map(i,2) = c.blue ();
-          alpha(i,1) = c.alpha ();
-        }
-      break;
-#endif
-
-    case Magick::PaletteType:
-      alpha = Matrix (0, 0);
-      for (i = 0; i < mapsize; i++)
-        {
-          Magick::ColorRGB c = imvec[0].colorMap (i);
-          map(i,0) = c.red ();
-          map(i,1) = c.green ();
-          map(i,2) = c.blue ();
-        }
-      break;
-
-    default:
-      error ("__magick_read__: unsupported indexed image type");
-      return octave_value_list ();
+      double value = region.scalar_value ();
+      output = Range (value, value);
     }
-
-  if (wantalpha)
-    output(2) = alpha;
-
-  output(1) = map;
+  else
+    error ("__magick_read__: unknow datatype for Region option");
 
   return output;
 }
 
+static std::map<std::string, octave_idx_type>
+calculate_region (const octave_scalar_map& options)
+{
+  std::map<std::string, octave_idx_type> region;
+  const Cell pixel_region = options.getfield ("region").cell_value ();
+
+  // Subtract 1 to account for 0 indexing.
+  const Range rows     = get_region_range (pixel_region (0));
+  const Range cols     = get_region_range (pixel_region (1));
+  region["row_start"]  = rows.base () -1;
+  region["col_start"]  = cols.base () -1;
+  region["row_end"]    = rows.max ()  -1;
+  region["col_end"]    = cols.max ()  -1;
+
+  // Length of the area to load into the Image Pixel Cache.  We use max and
+  // min to account for cases where last element of range is the range limit.
+  region["row_cache"] = region["row_end"] - region["row_start"] +1;
+  region["col_cache"] = region["col_end"] - region["col_start"] +1;
+
+  // How much we have to shift in the memory when doing the loops.
+  region["row_shift"] = region["col_cache"] * rows.inc ();
+  region["col_shift"] = region["col_cache"] *
+                        (region["row_cache"] + rows.inc () -1) - cols.inc ();
+
+  // The actual height and width of the output image
+  region["row_out"] = rows.nelem ();
+  region["col_out"] = cols.nelem ();
+
+  return region;
+}
+
+static octave_value_list
+read_maps (Magick::Image& img)
+{
+  // can't call colorMapSize on const Magick::Image
+  const octave_idx_type mapsize = img.colorMapSize ();
+  Matrix cmap                   = Matrix (mapsize, 3); // colormap
+  ColumnVector amap             = ColumnVector (mapsize); // alpha map
+  for (octave_idx_type i = 0; i < mapsize; i++)
+    {
+      const Magick::ColorRGB c = img.colorMap (i);
+      cmap(i,0) = c.red   ();
+      cmap(i,1) = c.green ();
+      cmap(i,2) = c.blue  ();
+      amap(i)   = c.alpha ();
+    }
+  octave_value_list maps;
+  maps(0) = cmap;
+  maps(1) = amap;
+  return maps;
+}
+
+template <class T>
+static octave_value_list
+read_indexed_images (const std::vector<Magick::Image>& imvec,
+                     const Array<octave_idx_type>& frameidx,
+                     const octave_idx_type& nargout,
+                     const octave_scalar_map& options)
+{
+  typedef typename T::element_type P;
+
+  octave_value_list retval (3, Matrix ());
+
+  std::map<std::string, octave_idx_type> region = calculate_region (options);
+  const octave_idx_type nFrames = frameidx.length ();
+  const octave_idx_type nRows = region["row_out"];
+  const octave_idx_type nCols = region["col_out"];
+
+  // imvec has all of the pages of a file, even the ones we are not
+  // interested in. We will use the first image that we will be actually
+  // reading to get information about the image.
+  const octave_idx_type def_elem = frameidx(0);
+
+  T img       = T (dim_vector (nRows, nCols, 1, nFrames));
+  P* img_fvec = img.fortran_vec ();
+
+  const octave_idx_type row_start  = region["row_start"];
+  const octave_idx_type col_start  = region["col_start"];
+  const octave_idx_type row_shift  = region["row_shift"];
+  const octave_idx_type col_shift  = region["col_shift"];
+  const octave_idx_type row_cache  = region["row_cache"];
+  const octave_idx_type col_cache  = region["col_cache"];
+
+  // When reading PixelPackets from the Image Pixel Cache, they come in
+  // row major order. So we keep moving back and forth there so we can
+  // write the image in column major order.
+  octave_idx_type idx = 0;
+  for (octave_idx_type frame = 0; frame < nFrames; frame++)
+    {
+      imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                             col_cache, row_cache);
+
+      const Magick::IndexPacket *pix
+        = imvec[frameidx(frame)].getConstIndexes ();
+
+      for (octave_idx_type col = 0; col < nCols; col++)
+        {
+          for (octave_idx_type row = 0; row < nRows; row++)
+            {
+              img_fvec[idx++] = static_cast<P> (*pix);
+              pix += row_shift;
+            }
+          pix -= col_shift;
+        }
+    }
+  retval(0) = octave_value (img);
+
+//   Only bother reading the colormap if it was requested as output.
+  if (nargout > 1)
+    {
+      // In theory, it should be possible for each frame of an image to
+      // have different colormaps but for Matlab compatibility, we only
+      // return the colormap of the first frame.  To obtain the colormaps
+      // of different frames, one needs can either use imfinfo or a for
+      // loop around imread.
+      const octave_value_list maps =
+        read_maps (const_cast<Magick::Image&> (imvec[frameidx(def_elem)]));
+
+      retval(1) = maps(0);
+
+      // only interpret alpha channel if it exists and was requested as output
+      if (imvec[def_elem].matte () && nargout >= 3)
+        {
+          const Matrix amap = maps(1).matrix_value ();
+          const double* amap_fvec = amap.fortran_vec ();
+
+          NDArray alpha (dim_vector (nRows, nCols, 1, nFrames));
+          double* alpha_fvec = alpha.fortran_vec ();
+
+          // GraphicsMagick stores the alpha values inverted, i.e.,
+          // 1 for transparent and 0 for opaque so we fix that here.
+          const octave_idx_type nPixels = alpha.numel ();
+          for (octave_idx_type pix = 0; pix < nPixels; pix++)
+            alpha_fvec[pix] = 1 - amap_fvec[static_cast<int> (img_fvec[3])];
+
+          retval(2) = alpha;
+        }
+    }
+
+  return retval;
+}
+
+// This function is highly repetitive, a bunch of for loops that are
+// very similar to account for different image types. They are different
+// enough that trying to reduce the copy and paste would decrease its
+// readability too much.
 template <class T>
 octave_value_list
-read_images (const std::vector<Magick::Image>& imvec,
-             const Array<int>& frameidx, unsigned int depth)
+read_images (std::vector<Magick::Image>& imvec,
+             const Array<octave_idx_type>& frameidx,
+             const octave_idx_type& nargout,
+             const octave_scalar_map& options)
 {
   typedef typename T::element_type P;
 
   octave_value_list retval (3, Matrix ());
 
-  T im;
+  std::map<std::string, octave_idx_type> region = calculate_region (options);
+  const octave_idx_type nFrames = frameidx.length ();
+  const octave_idx_type nRows = region["row_out"];
+  const octave_idx_type nCols = region["col_out"];
+  T img;
+
+  // imvec has all of the pages of a file, even the ones we are not
+  // interested in. We will use the first image that we will be actually
+  // reading to get information about the image.
+  const octave_idx_type def_elem = frameidx(0);
+
+  const octave_idx_type row_start  = region["row_start"];
+  const octave_idx_type col_start  = region["col_start"];
+  const octave_idx_type row_shift  = region["row_shift"];
+  const octave_idx_type col_shift  = region["col_shift"];
+  const octave_idx_type row_cache  = region["row_cache"];
+  const octave_idx_type col_cache  = region["col_cache"];
 
-  int rows = imvec[0].baseRows ();
-  int columns = imvec[0].baseColumns ();
-  int nframes = frameidx.length ();
+  // GraphicsMagick (GM) keeps the image values in memory using whatever
+  // QuantumDepth it was built with independently of the original image
+  // bitdepth. Basically this means that if GM was built with quantum 16
+  // all values are scaled in the uint16 range. If the original image
+  // had an 8 bit depth, we need to rescale it for that range.
+  // However, if the image had a bitdepth of 32, then we will be returning
+  // a floating point image. In this case, the values need to be rescaled
+  // for the range [0 1] (this is what Matlab has documented on the page
+  // about image types but in some cases seems to be doing something else.
+  // See bug #39249).
+  // Finally, we must do the division ourselves (set a divisor) instead of
+  // using quantumOperator for the cases where we will be returning floating
+  // point and want things in the range [0 1]. This is the same reason why
+  // the divisor is of type double.
+  // uint64_t is used in expression because default 32-bit value overflows
+  // when depth() is 32.
+  // TODO in the next release of GraphicsMagick, MaxRGB should be replaced
+  //      with QuantumRange since MaxRGB is already deprecated in ImageMagick.
+  double divisor;
+  if (imvec[def_elem].depth () == 32)
+    divisor = std::numeric_limits<uint32_t>::max ();
+  else
+    divisor = MaxRGB / ((uint64_t (1) << imvec[def_elem].depth ()) - 1);
+
+  // FIXME: this workaround should probably be fixed in GM by creating a
+  //        new ImageType BilevelMatteType
+  // Despite what GM documentation claims, opacity is not only on the types
+  // with Matte on the name. It is possible that an image is completely
+  // black (1 color), and have a second channel set for transparency (2nd
+  // color). Its type will be bilevel since there is no BilevelMatte. The
+  // only way to check for this seems to be by checking matte ().
+  Magick::ImageType type = imvec[def_elem].type ();
+  if (type == Magick::BilevelType && imvec[def_elem].matte ())
+    type = Magick::GrayscaleMatteType;
 
-  dim_vector idim = dim_vector ();
-  idim.resize (4);
-  idim(0) = rows;
-  idim(1) = columns;
-  idim(2) = 1;
-  idim(3) = nframes;
+  // FIXME: ImageType is the type being used to represent the image in memory
+  // by GM. The real type may be different (see among others bug #36820). For
+  // example, a png file where all channels are equal may report being
+  // grayscale or even bilevel. But we must always return the real image in
+  // file. In some cases, the original image attributes are stored in the
+  // attributes but this is undocumented. This should be fixed in GM so that
+  // a method such as original_type returns an actual Magick::ImageType
+  if (imvec[0].magick () == "PNG")
+    {
+      // These values come from libpng, not GM:
+      //      Grayscale         = 0
+      //      Palette           = 2 + 1
+      //      RGB               = 2
+      //      RGB + Alpha       = 2 + 4
+      //      Grayscale + Alpha = 4
+      // We won't bother with case 3 (palette) since those should be
+      // read by the function to read indexed images
+      const std::string type_str = imvec[0].attribute ("PNG:IHDR.color-type-orig");
+      if (type_str == "0")
+        type = Magick::GrayscaleType;
+      else if (type_str == "2")
+        type = Magick::TrueColorType;
+      else if (type_str == "6")
+        type = Magick::TrueColorMatteType;
+      else if (type_str == "4")
+        type = Magick::GrayscaleMatteType;
+      // Color types 0, 2, and 3 can also have alpha channel, conveyed
+      // via the "tRNS" chunk.  For 0 and 2, it's limited to GIF-style
+      // binary transparency, while 3 can have any level of alpha per
+      // palette entry. We thus must check matte() to see if the image
+      // really doesn't have an alpha channel.
+      if (imvec[0].matte ())
+        {
+          if (type == Magick::GrayscaleType)
+            type = Magick::GrayscaleMatteType;
+          else if (type == Magick::TrueColorType)
+            type = Magick::TrueColorMatteType;
+        }
+    }
 
-  Magick::ImageType type = imvec[0].type ();
-  const int divisor = ((uint64_t (1) << QuantumDepth) - 1) / 
-                      ((uint64_t (1) << depth) - 1);
+  // If the alpha channel was not requested, treat images as if
+  // it doesn't exist.
+  if (nargout < 3)
+    {
+      switch (type)
+        {
+        case Magick::GrayscaleMatteType:
+          type = Magick::GrayscaleType;
+          break;
+
+        case Magick::PaletteMatteType:
+          type = Magick::PaletteType;
+          break;
+
+        case Magick::TrueColorMatteType:
+          type = Magick::TrueColorType;
+          break;
+
+        case Magick::ColorSeparationMatteType:
+          type = Magick::ColorSeparationType;
+          break;
+
+        default:
+          // Do nothing other than silencing warnings about enumeration
+          // values not being handled in switch.
+          ;
+        }
+    }
 
   switch (type)
     {
-    case Magick::BilevelType:
-    case Magick::GrayscaleType:
+    case Magick::BilevelType:           // Monochrome bi-level image
+    case Magick::GrayscaleType:         // Grayscale image
       {
-        im = T (idim);
-        P *vec = im.fortran_vec ();
+        img = T (dim_vector (nRows, nCols, 1, nFrames));
+        P *img_fvec = img.fortran_vec ();
+
+        octave_idx_type idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            const Magick::PixelPacket *pix
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
 
-        for (int frame = 0; frame < nframes; frame++)
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    img_fvec[idx++] = pix->red / divisor;
+                    pix += row_shift;
+                  }
+                pix -= col_shift;
+              }
+          }
+        break;
+      }
+
+    case Magick::GrayscaleMatteType:    // Grayscale image with opacity
+      {
+        img   = T (dim_vector (nRows, nCols, 1, nFrames));
+        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        P *img_fvec = img.fortran_vec ();
+        P *a_fvec   = alpha.fortran_vec ();
+
+        octave_idx_type idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
-              = imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
-
-            P *rbuf = vec;
-            for (int y = 0; y < rows; y++)
-              {
-                for (int x = 0; x < columns; x++)
-                  {
-                    *rbuf = pix->red / divisor;
-                    pix++;
-                    rbuf += rows;
-                  }
-                rbuf -= rows * columns - 1;
-              }
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
 
-            // Next frame.
-            vec += rows * columns * idim(2);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    img_fvec[idx] = pix->red / divisor;
+                    a_fvec[idx]   = (MaxRGB - pix->opacity) / divisor;
+                    pix += row_shift;
+                    idx++;
+                  }
+                pix -= col_shift;
+              }
           }
-        }
-      break;
+        retval(2) = alpha;
+        break;
+      }
 
-    case Magick::GrayscaleMatteType:
+    case Magick::PaletteType:           // Indexed color (palette) image
+    case Magick::TrueColorType:         // Truecolor image
       {
-        idim(2) = 2;
-        im = T (idim);
-        P *vec = im.fortran_vec ();
+        img = T (dim_vector (nRows, nCols, 3, nFrames));
+        P *img_fvec = img.fortran_vec ();
 
-        for (int frame = 0; frame < nframes; frame++)
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
-              = imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
 
-            P *rbuf = vec;
-            P *obuf = vec + rows * columns;
-            for (int y = 0; y < rows; y++)
+            octave_idx_type idx = 0;
+            img_fvec += nRows * nCols * frame;
+            P *rbuf   = img_fvec;
+            P *gbuf   = img_fvec + nRows * nCols;
+            P *bbuf   = img_fvec + nRows * nCols * 2;
+
+            for (octave_idx_type col = 0; col < nCols; col++)
               {
-                for (int x = 0; x < columns; x++)
+                for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    *rbuf = pix->red / divisor;
-                    *obuf = pix->opacity / divisor;
-                    pix++;
-                    rbuf += rows;
-                    obuf += rows;
+                    rbuf[idx] = pix->red   / divisor;
+                    gbuf[idx] = pix->green / divisor;
+                    bbuf[idx] = pix->blue  / divisor;
+                    pix += row_shift;
+                    idx++;
                   }
-                rbuf -= rows * columns - 1;
-                obuf -= rows * columns - 1;
+                pix -= col_shift;
               }
-
-            // Next frame.
-            vec += rows * columns * idim(2);
           }
-        }
-      break;
+        break;
+      }
 
-    case Magick::PaletteType:
-    case Magick::TrueColorType:
+    case Magick::PaletteMatteType:      // Indexed color (palette) image with opacity
+    case Magick::TrueColorMatteType:    // Truecolor image with opacity
       {
-        idim(2) = 3;
-        im = T (idim);
-        P *vec = im.fortran_vec ();
+        img   = T (dim_vector (nRows, nCols, 3, nFrames));
+        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        P *img_fvec = img.fortran_vec ();
+        P *a_fvec   = alpha.fortran_vec ();
 
-        for (int frame = 0; frame < nframes; frame++)
+        // Unlike the index for the other channels, this one won't need
+        // to be reset on each frame since it's a separate matrix.
+        octave_idx_type a_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
-              = imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
 
-            P *rbuf = vec;
-            P *gbuf = vec + rows * columns;
-            P *bbuf = vec + rows * columns * 2;
-            for (int y = 0; y < rows; y++)
+            octave_idx_type idx = 0;
+            img_fvec += nRows * nCols * frame;
+            P *rbuf   = img_fvec;
+            P *gbuf   = img_fvec + nRows * nCols;
+            P *bbuf   = img_fvec + nRows * nCols * 2;
+
+            for (octave_idx_type col = 0; col < nCols; col++)
               {
-                for (int x = 0; x < columns; x++)
+                for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    *rbuf = pix->red / divisor;
-                    *gbuf = pix->green / divisor;
-                    *bbuf = pix->blue / divisor;
-                    pix++;
-                    rbuf += rows;
-                    gbuf += rows;
-                    bbuf += rows;
+                    rbuf[idx]     = pix->red     / divisor;
+                    gbuf[idx]     = pix->green   / divisor;
+                    bbuf[idx]     = pix->blue    / divisor;
+                    a_fvec[a_idx++] = (MaxRGB - pix->opacity) / divisor;
+                    pix += row_shift;
+                    idx++;
                   }
-                rbuf -= rows * columns - 1;
-                gbuf -= rows * columns - 1;
-                bbuf -= rows * columns - 1;
+                pix -= col_shift;
               }
-
-            // Next frame.
-            vec += rows * columns * idim(2);
           }
-        }
-      break;
+        retval(2) = alpha;
+        break;
+      }
 
-    case Magick::PaletteMatteType:
-    case Magick::TrueColorMatteType:
-    case Magick::ColorSeparationType:
+    case Magick::ColorSeparationType:   // Cyan/Yellow/Magenta/Black (CYMK) image
       {
-        idim(2) = 4;
-        im = T (idim);
-        P *vec = im.fortran_vec ();
+        img   = T (dim_vector (nRows, nCols, 4, nFrames));
+        P *img_fvec = img.fortran_vec ();
 
-        for (int frame = 0; frame < nframes; frame++)
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
-              = imvec[frameidx(frame)].getConstPixels (0, 0, columns, rows);
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
 
-            P *rbuf = vec;
-            P *gbuf = vec + rows * columns;
-            P *bbuf = vec + rows * columns * 2;
-            P *obuf = vec + rows * columns * 3;
-            for (int y = 0; y < rows; y++)
+            octave_idx_type idx = 0;
+            img_fvec += nRows * nCols * frame;
+            P *cbuf   = img_fvec;
+            P *mbuf   = img_fvec + nRows * nCols;
+            P *ybuf   = img_fvec + nRows * nCols * 2;
+            P *kbuf   = img_fvec + nRows * nCols * 3;
+
+            for (octave_idx_type col = 0; col < nCols; col++)
               {
-                for (int x = 0; x < columns; x++)
+                for (octave_idx_type row = 0; row < nRows; row++)
                   {
-                    *rbuf = pix->red / divisor;
-                    *gbuf = pix->green / divisor;
-                    *bbuf = pix->blue / divisor;
-                    *obuf = pix->opacity / divisor;
-                    pix++;
-                    rbuf += rows;
-                    gbuf += rows;
-                    bbuf += rows;
-                    obuf += rows;
+                    cbuf[idx] = pix->red     / divisor;
+                    mbuf[idx] = pix->green   / divisor;
+                    ybuf[idx] = pix->blue    / divisor;
+                    kbuf[idx] = pix->opacity / divisor;
+                    pix += row_shift;
+                    idx++;
                   }
-                rbuf -= rows * columns - 1;
-                gbuf -= rows * columns - 1;
-                bbuf -= rows * columns - 1;
-                obuf -= rows * columns - 1;
+                pix -= col_shift;
               }
+          }
+        break;
+      }
+
+    // Cyan, magenta, yellow, and black with alpha (opacity) channel
+    case Magick::ColorSeparationMatteType:
+      {
+        img   = T (dim_vector (nRows, nCols, 4, nFrames));
+        T alpha   (dim_vector (nRows, nCols, 1, nFrames));
+        P *img_fvec = img.fortran_vec ();
+        P *a_fvec   = alpha.fortran_vec ();
 
-            // Next frame.
-            vec += rows * columns * idim(2);
+        // Unlike the index for the other channels, this one won't need
+        // to be reset on each frame since it's a separate matrix.
+        octave_idx_type a_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            const Magick::PixelPacket *pix
+              = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
+                                                       col_cache, row_cache);
+            // Note that for CMYKColorspace + matte (CMYKA), the opacity is
+            // stored in the assocated IndexPacket.
+            const Magick::IndexPacket *apix
+              = imvec[frameidx(frame)].getConstIndexes ();
+
+            octave_idx_type idx = 0;
+            img_fvec += nRows * nCols * frame;
+            P *cbuf   = img_fvec;
+            P *mbuf   = img_fvec + nRows * nCols;
+            P *ybuf   = img_fvec + nRows * nCols * 2;
+            P *kbuf   = img_fvec + nRows * nCols * 3;
+
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    cbuf[idx]     = pix->red     / divisor;
+                    mbuf[idx]     = pix->green   / divisor;
+                    ybuf[idx]     = pix->blue    / divisor;
+                    kbuf[idx]     = pix->opacity / divisor;
+                    a_fvec[a_idx++] = (MaxRGB - *apix) / divisor;
+                    pix += row_shift;
+                    idx++;
+                  }
+                pix -= col_shift;
+              }
           }
-        }
-      break;
+        retval(2) = alpha;
+        break;
+      }
 
     default:
-      error ("__magick_read__: undefined ImageMagick image type");
+      error ("__magick_read__: unknown Magick++ image type");
       return retval;
     }
 
-  retval(0) = im;
-
+  retval(0) = img;
   return retval;
 }
 
-#endif
+// Read a file into vector of image objects.
+void static
+read_file (const std::string& filename, std::vector<Magick::Image>& imvec)
+{
+  try
+    {
+      Magick::readImages (&imvec, filename);
+    }
+  catch (Magick::Warning& w)
+    {
+      warning ("Magick++ warning: %s", w.what ());
+    }
+  catch (Magick::ErrorCoder& e)
+    {
+      // FIXME: there's a WarningCoder and ErrorCoder. Shouldn't this
+      // exception cause an error?
+      warning ("Magick++ coder error: %s", e.what ());
+    }
+  catch (Magick::Exception& e)
+    {
+      error ("Magick++ exception: %s", e.what ());
+      error_state = 1;
+    }
+}
 
 static void
 maybe_initialize_magick (void)
 {
-#ifdef HAVE_MAGICK
-
   static bool initialized = false;
 
   if (! initialized)
     {
-      // Save locale as GraphicsMagick might change this (depending on version)
+      // Save locale as GraphicsMagick might change this (fixed in
+      // GraphicsMagick since version 1.3.13 released on December 24, 2011)
       const char *static_locale = setlocale (LC_ALL, NULL);
       const std::string locale (static_locale);
 
-      std::string program_name = octave_env::get_program_invocation_name ();
-
+      const std::string program_name = octave_env::get_program_invocation_name ();
       Magick::InitializeMagick (program_name.c_str ());
 
       // Restore locale from before GraphicsMagick initialisation
       setlocale (LC_ALL, locale.c_str ());
 
       if (QuantumDepth < 32)
         warning ("your version of %s limits images to %d bits per pixel",
                  MagickPackageName, QuantumDepth);
 
       initialized = true;
     }
+}
 #endif
-}
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{m} =} __magick_read__ (@var{fname}, @var{index})\n\
-@deftypefnx {Loadable Function} {[@var{m}, @var{colormap}] =} __magick_read__ (@var{fname}, @var{index})\n\
-@deftypefnx {Loadable Function} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{index})\n\
-Read images with ImageMagick++.  In general you should not be using this\n\
-function.  Instead use @code{imread}.\n\
-@seealso{imread}\n\
+@deftypefn {Loadable Function} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
+Read image with GraphicsMagick or ImageMagick.\n\
+\n\
+This is a private internal function not intended for direct use.  Instead\n\
+use @code{imread}.\n\
+\n\
+@seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
-#ifdef HAVE_MAGICK
+#ifndef HAVE_MAGICK
+  gripe_disabled_feature ("imread", "Image IO");
+#else
 
   maybe_initialize_magick ();
 
-  if (args.length () > 3 || args.length () < 1 || ! args(0).is_string ()
-      || nargout > 3)
+  if (args.length () != 2 || ! args(0).is_string ())
     {
       print_usage ();
       return output;
     }
 
-  Array<int> frameidx;
-  bool all_frames = false;
+  const octave_scalar_map options = args(1).scalar_map_value ();
+  if (error_state)
+    {
+      error ("__magick_read__: OPTIONS must be a struct");
+      return output;
+    }
 
-  if (args.length () == 2 && args(1).is_real_type ())
-    frameidx = args(1).int_vector_value ();
-  else if (args.length () == 3 && args(1).is_string ()
-           && args(1).string_value () == "frames")
+  std::vector<Magick::Image> imvec;
+  read_file (args(0).string_value (), imvec);
+  if (error_state)
+    return output;
+
+  // Prepare an Array with the indexes for the requested frames.
+  const octave_idx_type nFrames = imvec.size ();
+  Array<octave_idx_type> frameidx;
+  const octave_value indexes = options.getfield ("index");
+  if (indexes.is_string () && indexes.string_value () == "all")
     {
-      if (args(2).is_string () && args(2).string_value () == "all")
-        all_frames = true;
-      else if (args(2).is_real_type ())
-        frameidx = args(2).int_vector_value ();
+      frameidx.resize (dim_vector (1, nFrames));
+      for (octave_idx_type i = 0; i < nFrames; i++)
+        frameidx(i) = i;
     }
   else
     {
-      frameidx = Array<int> (dim_vector (1, 1));
-      frameidx(0) = 1;
+      frameidx = indexes.int_vector_value ();
+      if (error_state)
+        {
+          error ("__magick_read__: invalid value for Index/Frame");
+          return output;
+        }
+      // Fix indexes from base 1 to base 0, and at the same time, make
+      // sure none of the indexes is outside the range of image number.
+      const octave_idx_type n = frameidx.nelem ();
+      for (octave_idx_type i = 0; i < n; i++)
+        {
+          frameidx(i)--;
+          if (frameidx(i) < 0 || frameidx(i) > nFrames - 1)
+            {
+              error ("imread: index/frames specified are outside the number of images");
+              return output;
+            }
+        }
+    }
+
+  const octave_idx_type depth = get_depth (imvec[frameidx(0)]);
+  if (is_indexed (imvec[frameidx(0)]))
+    {
+      if (depth <= 1)
+        output = read_indexed_images<boolNDArray>   (imvec, frameidx,
+                                                     nargout, options);
+      else if (depth <= 8)
+        output = read_indexed_images<uint8NDArray>  (imvec, frameidx,
+                                                     nargout, options);
+      else if (depth <= 16)
+        output = read_indexed_images<uint16NDArray> (imvec, frameidx,
+                                                     nargout, options);
+      else
+        {
+          error ("imread: indexed images with depths greater than 16-bit are not supported");
+          return output;
+        }
+    }
+
+  else
+    {
+      if (depth <= 1)
+        output = read_images<boolNDArray>   (imvec, frameidx, nargout, options);
+      else if (depth <= 8)
+        output = read_images<uint8NDArray>  (imvec, frameidx, nargout, options);
+      else if (depth <= 16)
+        output = read_images<uint16NDArray> (imvec, frameidx, nargout, options);
+      else if (depth <= 32)
+        output = read_images<FloatNDArray>  (imvec, frameidx, nargout, options);
+      else
+        {
+          error ("imread: reading of images with %i-bit depth is not supported",
+                 depth);
+        }
+    }
+
+#endif
+  return output;
+}
+
+/*
+## No test needed for internal helper function.
+%!assert (1)
+*/
+
+#ifdef HAVE_MAGICK
+
+template <class T>
+static uint32NDArray
+img_float2uint (const T& img)
+{
+  typedef typename T::element_type P;
+  uint32NDArray out (img.dims ());
+
+  octave_uint32* out_fvec = out.fortran_vec ();
+  const P*       img_fvec = img.fortran_vec ();
+
+  const octave_uint32 max = octave_uint32::max ();
+  const octave_idx_type numel = img.numel ();
+  for (octave_idx_type idx = 0; idx < numel; idx++)
+    out_fvec[idx] = img_fvec[idx] * max;
+
+  return out;
+}
+
+// Gets the bitdepth to be used for an Octave class, i.e, returns 8 for
+// uint8, 16 for uint16, and 32 for uint32
+template <class T>
+static octave_idx_type
+bitdepth_from_class ()
+{
+  typedef typename T::element_type P;
+  const octave_idx_type bitdepth =
+    sizeof (P) * std::numeric_limits<unsigned char>::digits;
+  return bitdepth;
+}
+
+static Magick::Image
+init_enconde_image (const octave_idx_type& nCols, const octave_idx_type& nRows,
+                    const octave_idx_type& bitdepth,
+                    const Magick::ImageType& type,
+                    const Magick::ClassType& klass)
+{
+  Magick::Image img (Magick::Geometry (nCols, nRows), "black");
+  // Ensure that there are no other references to this image.
+  img.modifyImage ();
+
+  img.classType (klass);
+  img.type (type);
+  // FIXME: for some reason, setting bitdepth doesn't seem to work for
+  //        indexed images.
+  img.depth (bitdepth);
+  switch (type)
+    {
+      case Magick::GrayscaleMatteType:
+      case Magick::TrueColorMatteType:
+      case Magick::ColorSeparationMatteType:
+      case Magick::PaletteMatteType:
+        img.matte (true);
+        break;
+
+      default:
+        img.matte (false);
     }
 
-  std::vector<Magick::Image> imvec;
+  return img;
+}
+
+template <class T>
+static void
+encode_indexed_images (std::vector<Magick::Image>& imvec,
+                       const T& img,
+                       const Matrix& cmap)
+{
+  typedef typename T::element_type P;
+  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nRows     = img.rows ();
+  const octave_idx_type nCols     = img.columns ();
+  const octave_idx_type cmap_size = cmap.rows ();
+  const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
+
+  // There is no colormap object, we need to build a new one for each frame,
+  // even if it's always the same. We can least get a vector for the Colors.
+  std::vector<Magick::ColorRGB> colormap;
+  {
+    const double* cmap_fvec = cmap.fortran_vec ();
+    const octave_idx_type G_offset = cmap_size;
+    const octave_idx_type B_offset = cmap_size * 2;
+    for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
+      colormap.push_back (Magick::ColorRGB (cmap_fvec[map_idx],
+                                            cmap_fvec[map_idx + G_offset],
+                                            cmap_fvec[map_idx + B_offset]));
+  }
+
+  for (octave_idx_type frame = 0; frame < nFrames; frame++)
+    {
+      Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                Magick::PaletteType,
+                                                Magick::PseudoClass);
+
+      // Insert colormap.
+      m_img.colorMapSize (cmap_size);
+      for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
+        m_img.colorMap (map_idx, colormap[map_idx]);
+
+      // Why are we also setting the pixel values instead of only the
+      // index values? We don't know if a file format supports indexed
+      // images. If we only set the indexes and then try to save the
+      // image as JPEG for example, the indexed values get discarded,
+      // there is no conversion from the indexes, it's the initial values
+      // that get used. An alternative would be to only set the pixel
+      // values (no indexes), then set the image as PseudoClass and GM
+      // would create a colormap for us. However, we wouldn't have control
+      // over the order of that colormap. And that's why we set both.
+      Magick::PixelPacket* pix  = m_img.getPixels (0, 0, nCols, nRows);
+      Magick::IndexPacket* ind  = m_img.getIndexes ();
+      const P* img_fvec         = img.fortran_vec ();
+
+      octave_idx_type GM_idx = 0;
+      for (octave_idx_type column = 0; column < nCols; column++)
+        {
+          for (octave_idx_type row = 0; row < nRows; row++)
+            {
+              ind[GM_idx] = double (*img_fvec);
+              pix[GM_idx] = m_img.colorMap (double (*img_fvec));
+              img_fvec++;
+              GM_idx += nCols;
+            }
+          GM_idx -= nCols * nRows - 1;
+        }
+
+      // Save changes to underlying image.
+      m_img.syncPixels ();
+      imvec.push_back (m_img);
+    }
+}
+
+static void
+encode_bool_image (std::vector<Magick::Image>& imvec, const boolNDArray& img)
+{
+  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nRows     = img.rows ();
+  const octave_idx_type nCols     = img.columns ();
+
+  // The initialized image will be black, this is for the other pixels
+  const Magick::Color white ("white");
+
+  const bool *img_fvec = img.fortran_vec ();
+  octave_idx_type img_idx = 0;
+  for (octave_idx_type frame = 0; frame < nFrames; frame++)
+    {
+      // For some reason, we can't set the type to Magick::BilevelType or
+      // the output image will be black, changing to white has no effect.
+      // However, this will still work fine and a binary image will be
+      // saved because we are setting the bitdepth to 1.
+      Magick::Image m_img = init_enconde_image (nCols, nRows, 1,
+                                                Magick::GrayscaleType,
+                                                Magick::DirectClass);
+
+      Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+      octave_idx_type GM_idx = 0;
+      for (octave_idx_type col = 0; col < nCols; col++)
+        {
+          for (octave_idx_type row = 0; row < nRows; row++)
+            {
+              if (img_fvec[img_idx])
+                pix[GM_idx] = white;
+
+              img_idx++;
+              GM_idx += nCols;
+            }
+          GM_idx -= nCols * nRows - 1;
+        }
+      // Save changes to underlying image.
+      m_img.syncPixels ();
+      // While we could not set it to Bilevel at the start, we can do it
+      // here otherwise some coders won't save it as binary.
+      m_img.type (Magick::BilevelType);
+      imvec.push_back (m_img);
+    }
+}
+
+template <class T>
+static void
+encode_uint_image (std::vector<Magick::Image>& imvec,
+                   const T& img, const T& alpha)
+{
+  typedef typename T::element_type P;
+  const octave_idx_type channels  = img.ndims () < 3 ? 1 : img.dims ()(2);
+  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nRows     = img.rows ();
+  const octave_idx_type nCols     = img.columns ();
+  const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
+
+  Magick::ImageType type;
+  const bool has_alpha = ! alpha.is_empty ();
+  switch (channels)
+    {
+    case 1:
+      if (has_alpha)
+        type = Magick::GrayscaleMatteType;
+      else
+        type = Magick::GrayscaleType;
+      break;
+
+    case 3:
+      if (has_alpha)
+        type = Magick::TrueColorMatteType;
+      else
+        type = Magick::TrueColorType;
+      break;
+
+    case 4:
+      if (has_alpha)
+        type = Magick::ColorSeparationMatteType;
+      else
+        type = Magick::ColorSeparationType;
+      break;
+
+    default:
+      {
+        // __imwrite should have already filtered this cases
+        error ("__magick_write__: wrong size on 3rd dimension");
+        return;
+      }
+    }
+
+  // We will be passing the values as integers with depth as specified
+  // by QuantumDepth (maximum value specified by MaxRGB). This is independent
+  // of the actual depth of the image. GM will then convert the values but
+  // while in memory, it always keeps the values as specified by QuantumDepth.
+  // From GM documentation:
+  //  Color arguments are must be scaled to fit the Quantum size according to
+  //  the range of MaxRGB
+  const double divisor = static_cast<double>((uint64_t (1) << bitdepth) - 1) / MaxRGB;
+
+  const P *img_fvec = img.fortran_vec ();
+  const P *a_fvec   = alpha.fortran_vec ();
+  switch (type)
+    {
+    case Magick::GrayscaleType:
+      {
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
 
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c;
+                    c.redQuantum (double (*img_fvec) / divisor);
+                    pix[GM_idx] = c;
+                    img_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    case Magick::GrayscaleMatteType:
+      {
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
+
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c;
+                    c.redQuantum   (double (*img_fvec) / divisor);
+                    c.alphaQuantum (MaxRGB - (double (*a_fvec) / divisor));
+                    pix[GM_idx] = c;
+                    img_fvec++;
+                    a_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    case Magick::TrueColorType:
+      {
+        // The fortran_vec offset for the green and blue channels
+        const octave_idx_type G_offset = nCols * nRows;
+        const octave_idx_type B_offset = nCols * nRows * 2;
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
+
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c (double (*img_fvec)          / divisor,
+                                     double (img_fvec[G_offset]) / divisor,
+                                     double (img_fvec[B_offset]) / divisor);
+                    pix[GM_idx] = c;
+                    img_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    case Magick::TrueColorMatteType:
+      {
+        // The fortran_vec offset for the green and blue channels
+        const octave_idx_type G_offset = nCols * nRows;
+        const octave_idx_type B_offset = nCols * nRows * 2;
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
+
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c (double (*img_fvec)          / divisor,
+                                     double (img_fvec[G_offset]) / divisor,
+                                     double (img_fvec[B_offset]) / divisor,
+                                     MaxRGB - (double (*a_fvec) / divisor));
+                    pix[GM_idx] = c;
+                    img_fvec++;
+                    a_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    case Magick::ColorSeparationType:
+      {
+        // The fortran_vec offset for the Magenta, Yellow, and blacK channels
+        const octave_idx_type M_offset = nCols * nRows;
+        const octave_idx_type Y_offset = nCols * nRows * 2;
+        const octave_idx_type K_offset = nCols * nRows * 3;
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
+
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c (double (*img_fvec)          / divisor,
+                                     double (img_fvec[M_offset]) / divisor,
+                                     double (img_fvec[Y_offset]) / divisor,
+                                     double (img_fvec[K_offset]) / divisor);
+                    pix[GM_idx] = c;
+                    img_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    case Magick::ColorSeparationMatteType:
+      {
+        // The fortran_vec offset for the Magenta, Yellow, and blacK channels
+        const octave_idx_type M_offset = nCols * nRows;
+        const octave_idx_type Y_offset = nCols * nRows * 2;
+        const octave_idx_type K_offset = nCols * nRows * 3;
+        octave_idx_type GM_idx = 0;
+        for (octave_idx_type frame = 0; frame < nFrames; frame++)
+          {
+            Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
+                                                      type,
+                                                      Magick::DirectClass);
+
+            Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
+            Magick::IndexPacket *ind = m_img.getIndexes ();
+            for (octave_idx_type col = 0; col < nCols; col++)
+              {
+                for (octave_idx_type row = 0; row < nRows; row++)
+                  {
+                    Magick::Color c (double (*img_fvec)          / divisor,
+                                     double (img_fvec[M_offset]) / divisor,
+                                     double (img_fvec[Y_offset]) / divisor,
+                                     double (img_fvec[K_offset]) / divisor);
+                    pix[GM_idx] = c;
+                    ind[GM_idx] = MaxRGB - (double (*a_fvec) / divisor);
+                    img_fvec++;
+                    a_fvec++;
+                    GM_idx += nCols;
+                  }
+                GM_idx -= nCols * nRows - 1;
+              }
+            // Save changes to underlying image.
+            m_img.syncPixels ();
+            imvec.push_back (m_img);
+          }
+        break;
+      }
+
+    default:
+      {
+        error ("__magick_write__: unrecognized Magick::ImageType");
+        return;
+      }
+    }
+  return;
+}
+
+void static
+write_file (const std::string& filename,
+            const std::string& ext,
+            std::vector<Magick::Image>& imvec)
+{
   try
     {
-      // Read a file into vector of image objects
-      Magick::readImages (&imvec, args(0).string_value ());
+      Magick::writeImages (imvec.begin (), imvec.end (), ext + ":" + filename);
     }
   catch (Magick::Warning& w)
     {
       warning ("Magick++ warning: %s", w.what ());
     }
   catch (Magick::ErrorCoder& e)
     {
       warning ("Magick++ coder error: %s", e.what ());
     }
   catch (Magick::Exception& e)
     {
       error ("Magick++ exception: %s", e.what ());
-      return output;
-    }
-
-  int nframes = imvec.size ();
-  if (all_frames)
-    {
-      frameidx = Array<int> (dim_vector (1, nframes));
-      for (int i = 0; i < frameidx.length (); i++)
-        frameidx(i) = i;
-    }
-  else
-    {
-      for (int i = 0; i < frameidx.length (); i++)
-        {
-          frameidx(i) = frameidx(i) - 1;
-
-          if (frameidx(i) >= nframes || frameidx(i) < 0)
-            {
-              error ("__magick_read__: invalid INDEX vector");
-              return output;
-            }
-        }
-    }
-
-  Magick::ClassType klass = imvec[0].classType ();
-
-  if (klass == Magick::PseudoClass && nargout > 1)
-    output = read_indexed_images (imvec, frameidx, (nargout == 3));
-  else
-    {
-      unsigned int depth = imvec[0].modulusDepth ();
-      if (depth > 1)
-        {
-          --depth;
-          int i = 1;
-          while (depth >>= 1)
-            i++;
-          depth = 1 << i;
-        }
-
-      switch (depth)
-        {
-        case 1:
-          output = read_images<boolNDArray> (imvec, frameidx, depth);
-          break;
-
-        case 2:
-        case 4:
-        case 8:
-          output = read_images<uint8NDArray> (imvec, frameidx, depth) ;
-          break;
-
-        case 16:
-          output = read_images<uint16NDArray> (imvec, frameidx, depth);
-          break;
-
-        case 32:
-        case 64:
-        default:
-          error ("__magick_read__: image depths greater than 16-bit are not supported");
-        }
-    }
-#else
-
-  error ("imread: image reading capabilities were disabled when Octave was compiled");
-
-#endif
-
-  return output;
-}
-
-/*
-## No test needed for internal helper function.
-%!assert (1)
-*/
-
-#ifdef HAVE_MAGICK
-
-static void
-jpg_settings (std::vector<Magick::Image>& imvec,
-              const octave_map& options,
-              bool)
-{
-  bool something_set = false;
-
-  // Quality setting
-  octave_value result;
-  octave_map::const_iterator p;
-  bool found_it = false;
-
-  for (p = options.begin (); p != options.end (); p++)
-    {
-      if (options.key (p) == "Quality")
-        {
-          found_it = true;
-          result = options.contents (p).elem (0);
-          break;
-        }
-    }
-
-  if (found_it && (! result.is_empty ()))
-    {
-      something_set = true;
-
-      if (result.is_real_type ())
-        {
-          int qlev = result.int_value ();
-
-          if (qlev < 0 || qlev > 100)
-            warning ("warning: Quality setting invalid--use default of 75");
-          else
-            {
-              for (size_t fnum = 0; fnum < imvec.size (); fnum++)
-                imvec[fnum].quality (static_cast<unsigned int>(qlev));
-            }
-        }
-      else
-        warning ("warning: Quality setting invalid--use default of 75");
-    }
-
-  // Other settings go here
-
-  if (! something_set)
-    warning ("__magick_write__ warning: all write parameters ignored");
-}
-
-static void
-encode_bool_image (std::vector<Magick::Image>& imvec, const octave_value& img)
-{
-  unsigned int nframes = 1;
-  boolNDArray m = img.bool_array_value ();
-
-  dim_vector dsizes = m.dims ();
-  if (dsizes.length () == 4)
-    nframes = dsizes(3);
-
-  Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
-
-  octave_idx_type rows = m.rows ();
-  octave_idx_type columns = m.columns ();
-
-  for (unsigned int ii = 0; ii < nframes; ii++)
-    {
-      Magick::Image im (Magick::Geometry (columns, rows), "black");
-      im.classType (Magick::DirectClass);
-      im.depth (1);
-
-      for (int y = 0; y < columns; y++)
-        {
-          idx(1) = y;
-
-          for (int x = 0; x < rows; x++)
-            {
-              if (nframes > 1)
-                {
-                  idx(2) = 0;
-                  idx(3) = ii;
-                }
-
-              idx(0) = x;
-
-              if (m(idx))
-                im.pixelColor (y, x, "white");
-            }
-        }
-
-      im.quantizeColorSpace (Magick::GRAYColorspace);
-      im.quantizeColors (2);
-      im.quantize ();
-
-      imvec.push_back (im);
-    }
-}
-
-template <class T>
-static void
-encode_uint_image (std::vector<Magick::Image>& imvec,
-                   const octave_value& img,
-                   bool has_map)
-{
-  unsigned int bitdepth = 0;
-  T m;
-
-  if (img.is_uint8_type ())
-    {
-      bitdepth = 8;
-      m = img.uint8_array_value ();
-    }
-  else if (img.is_uint16_type ())
-    {
-      bitdepth = 16;
-      m = img.uint16_array_value ();
-    }
-  else
-    error ("__magick_write__: invalid image class");
-
-  dim_vector dsizes = m.dims ();
-  unsigned int nframes = 1;
-  if (dsizes.length () == 4)
-    nframes = dsizes(3);
-
-  bool is_color = ((dsizes.length () > 2) && (dsizes(2) > 2));
-  bool has_alpha = (dsizes.length () > 2 && (dsizes(2) == 2 || dsizes(2) == 4));
-
-  Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
-  octave_idx_type rows = m.rows ();
-  octave_idx_type columns = m.columns ();
-
-  unsigned int div_factor = (1 << bitdepth) - 1;
-
-  for (unsigned int ii = 0; ii < nframes; ii++)
-    {
-      Magick::Image im (Magick::Geometry (columns, rows), "black");
-
-      im.depth (bitdepth);
-
-      if (has_map)
-        im.classType (Magick::PseudoClass);
-      else
-        im.classType (Magick::DirectClass);
-
-      if (is_color)
-        {
-          if (has_alpha)
-            im.type (Magick::TrueColorMatteType);
-          else
-            im.type (Magick::TrueColorType);
-
-          Magick::ColorRGB c;
-
-          for (int y = 0; y < columns; y++)
-            {
-              idx(1) = y;
-
-              for (int x = 0; x < rows; x++)
-                {
-                  idx(0) = x;
-
-                  if (nframes > 1)
-                    idx(3) = ii;
-
-                  idx(2) = 0;
-                  c.red (static_cast<double>(m(idx)) / div_factor);
-
-                  idx(2) = 1;
-                  c.green (static_cast<double>(m(idx)) / div_factor);
-
-                  idx(2) = 2;
-                  c.blue (static_cast<double>(m(idx)) / div_factor);
-
-                  if (has_alpha)
-                    {
-                      idx(2) = 3;
-                      c.alpha (static_cast<double>(m(idx)) / div_factor);
-                    }
-
-                  im.pixelColor (y, x, c);
-                }
-            }
-        }
-      else
-        {
-          if (has_alpha)
-            im.type (Magick::GrayscaleMatteType);
-          else
-            im.type (Magick::GrayscaleType);
-
-          Magick::ColorGray c;
-
-          for (int y = 0; y < columns; y++)
-            {
-              idx(1) = y;
-
-              for (int x=0; x < rows; x++)
-                {
-                  idx(0) = x;
-
-                  if (nframes > 1)
-                    {
-                      idx(2) = 0;
-                      idx(3) = ii;
-                    }
-
-                  if (has_alpha)
-                    {
-                      idx(2) = 1;
-                      c.alpha (static_cast<double>(m(idx)) / div_factor);
-                      idx(2) = 0;
-                    }
-
-                  c.shade (static_cast<double>(m(idx)) / div_factor);
-
-                  im.pixelColor (y, x, c);
-                }
-            }
-
-          im.quantizeColorSpace (Magick::GRAYColorspace);
-          im.quantizeColors (1 << bitdepth);
-          im.quantize ();
-        }
-
-      imvec.push_back (im);
-    }
-}
-
-static void
-encode_map (std::vector<Magick::Image>& imvec, const NDArray& cmap)
-{
-  unsigned int mapsize = cmap.dim1 ();
-
-  for (size_t fnum = 0; fnum < imvec.size (); fnum++)
-    {
-      imvec[fnum].colorMapSize (mapsize);
-      imvec[fnum].type (Magick::PaletteType);
-    }
-
-  for (unsigned int ii = 0; ii < mapsize; ii++)
-    {
-      Magick::ColorRGB c (cmap(ii,0), cmap(ii,1), cmap(ii,2));
-
-      // FIXME -- is this case needed?
-      if (cmap.dim2 () == 4)
-        c.alpha (cmap(ii,3));
-
-      try
-        {
-          for_each (imvec.begin (), imvec.end (),
-                    Magick::colorMapImage (ii, c));
-        }
-      catch (Magick::Warning& w)
-        {
-          warning ("Magick++ warning: %s", w.what ());
-        }
-      catch (Magick::ErrorCoder& e)
-        {
-          warning ("Magick++ coder error: %s", e.what ());
-        }
-      catch (Magick::Exception& e)
-        {
-          error ("Magick++ exception: %s", e.what ());
-        }
-    }
-}
-
-static void
-write_image (const std::string& filename, const std::string& fmt,
-             const octave_value& img,
-             const octave_value& map = octave_value (),
-             const octave_value& params = octave_value ())
-{
-  std::vector<Magick::Image> imvec;
-
-  bool has_map = map.is_defined ();
-
-  if (has_map)
-    {
-      error ("__magick_write__: direct saving of indexed images not currently supported; use ind2rgb and save converted image");
-      return;
-    }
-
-  if (img.is_bool_type ())
-    encode_bool_image (imvec, img);
-  else if (img.is_uint8_type ())
-    encode_uint_image<uint8NDArray> (imvec, img, has_map);
-  else if (img.is_uint16_type ())
-    encode_uint_image<uint16NDArray> (imvec, img, has_map);
-  else
-    error ("__magick_write__: image type not supported");
-
-  if (! error_state && has_map)
-    {
-      NDArray cmap = map.array_value ();
-
-      if (! error_state)
-        encode_map (imvec, cmap);
-    }
-
-  if (! error_state && params.is_defined ())
-    {
-      octave_map options = params.map_value ();
-
-      // Insert calls here to handle parameters for various image formats
-      if (fmt == "jpg" || fmt == "jpeg")
-        jpg_settings (imvec, options, has_map);
-      else
-        warning ("warning: your parameter(s) currently not supported");
-    }
-
-  try
-    {
-      Magick::writeImages (imvec.begin (), imvec.end (), fmt + ":" + filename);
-    }
-  catch (Magick::Warning& w)
-    {
-      warning ("Magick++ warning: %s", w.what ());
-    }
-  catch (Magick::ErrorCoder& e)
-    {
-      warning ("Magick++ coder error: %s", e.what ());
-    }
-  catch (Magick::Exception& e)
-    {
-      error ("Magick++ exception: %s", e.what ());
+      error_state = 1;
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img})\n\
-@deftypefnx {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
-Write images with ImageMagick++.  In general you should not be using this\n\
-function.  Instead use @code{imwrite}.\n\
-@seealso{imread}\n\
+@deftypefn {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
+Write image with GraphicsMagick or ImageMagick.\n\
+\n\
+This is a private internal function not intended for direct use.  Instead\n\
+use @code{imwrite}.\n\
+\n\
+@seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-#ifdef HAVE_MAGICK
-  maybe_initialize_magick ();
-
-  int nargin = args.length ();
-
-  if (nargin > 2)
-    {
-      std::string filename = args(0).string_value ();
-
-      if (! error_state)
-        {
-          std::string fmt = args(1).string_value ();
-
-          if (! error_state)
-            {
-              if (nargin > 4)
-                write_image (filename, fmt, args(2), args(3), args(4));
-              else if (nargin > 3)
-                if (args(3).is_real_type ())
-                  write_image (filename, fmt, args(2), args(3));
-                else
-                  write_image (filename, fmt, args(2), octave_value (), args(3));
-              else
-                write_image (filename, fmt, args(2));
-            }
-          else
-            error ("__magick_write__: FMT must be string");
-        }
-      else
-        error ("__magick_write__: FNAME must be a string");
-    }
-  else
-    print_usage ();
+#ifndef HAVE_MAGICK
+  gripe_disabled_feature ("imwrite", "Image IO");
 #else
 
-  error ("__magick_write__: not available in this version of Octave");
-
-#endif
-
-return retval;
-}
-
-/*
-## No test needed for internal helper function.
-%!assert (1)
-*/
-
-#ifdef HAVE_MAGICK
-
-template<class T>
-static octave_value
-magick_to_octave_value (const T magick)
-{
-  return octave_value (magick);
-}
-
-static octave_value
-magick_to_octave_value (const Magick::EndianType magick)
-{
-  switch (magick)
-    {
-      case Magick::LSBEndian:
-        return octave_value ("little-endian");
-
-      case Magick::MSBEndian:
-        return octave_value ("big-endian");
-
-      default:
-        return octave_value ("undefined");
-    }
-}
-
-static octave_value
-magick_to_octave_value (const Magick::ResolutionType magick)
-{
-  switch (magick)
-    {
-      case Magick::PixelsPerInchResolution:
-        return octave_value ("pixels per inch");
-
-      case Magick::PixelsPerCentimeterResolution:
-        return octave_value ("pixels per centimeter");
-
-      default:
-        return octave_value ("undefined");
-    }
-}
-
-static octave_value
-magick_to_octave_value (const Magick::ImageType magick)
-{
-  switch (magick)
-    {
-      case Magick::BilevelType:
-      case Magick::GrayscaleType:
-      case Magick::GrayscaleMatteType:
-        return octave_value ("grayscale");
-
-      case Magick::PaletteType:
-      case Magick::PaletteMatteType:
-        return octave_value ("indexed");
-
-      case Magick::TrueColorType:
-      case Magick::TrueColorMatteType:
-      case Magick::ColorSeparationType:
-        return octave_value ("truecolor");
-
-      default:
-        return octave_value ("undefined");
-    }
-}
-
-// We put this in a try-block because GraphicsMagick will throw
-// exceptions if a parameter isn't present in the current image.
-#define GET_PARAM(NAME, OUTNAME) \
-  try \
-    { \
-      info.contents (OUTNAME)(frame,0) = magick_to_octave_value (im.NAME ()); \
-    } \
-  catch (Magick::Warning& w) \
-    { \
-    }
-
-#endif
-
-DEFUN_DLD (__magick_finfo__, args, ,
-  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
-Read image information with GraphicsMagick++.  In general you should\n\
-not be using this function.  Instead use @code{imfinfo}.\n\
-@seealso{imfinfo, imread}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-#ifdef HAVE_MAGICK
-
   maybe_initialize_magick ();
 
-  if (args.length () < 1 || ! args (0).is_string ())
+  if (args.length () != 5 || ! args(0).is_string () || ! args(1).is_string ())
     {
       print_usage ();
       return retval;
     }
+  const std::string filename = args(0).string_value ();
+  const std::string ext      = args(1).string_value ();
 
-  const std::string filename = args (0).string_value ();
+  const octave_scalar_map options = args(4).scalar_map_value ();
+  if (error_state)
+    {
+      error ("__magick_write__: OPTIONS must be a struct");
+      return retval;
+    }
 
-  try
+  const octave_value img  = args(2);
+  const Matrix       cmap = args(3).matrix_value ();
+  if (error_state)
     {
-      // Read the file.
-      std::vector<Magick::Image> imvec;
-      Magick::readImages (&imvec, args(0).string_value ());
-      int nframes = imvec.size ();
+      error ("__magick_write__: invalid IMG or MAP");
+      return retval;
+    }
+
+  std::vector<Magick::Image> imvec;
 
-      // Create the right size for the output.
-
-      static const char *fields[] =
+  if (cmap.is_empty ())
+    {
+      const octave_value alpha = options.getfield ("alpha");
+      if (img.is_bool_type ())
+        encode_bool_image (imvec, img.bool_array_value ());
+      else if (img.is_uint8_type ())
+        encode_uint_image<uint8NDArray>  (imvec, img.uint8_array_value (),
+                                          alpha.uint8_array_value ());
+      else if (img.is_uint16_type ())
+        encode_uint_image<uint16NDArray> (imvec, img.uint16_array_value (),
+                                          alpha.uint16_array_value ());
+      else if (img.is_uint32_type ())
+        encode_uint_image<uint32NDArray> (imvec, img.uint32_array_value (),
+                                          alpha.uint32_array_value ());
+      else if (img.is_float_type ())
         {
-          "Filename",
-          "FileModDate",
-          "FileSize",
-          "Height",
-          "Width",
-          "BitDepth",
-          "Format",
-          "LongFormat",
-          "XResolution",
-          "YResolution",
-          "TotalColors",
-          "TileName",
-          "AnimationDelay",
-          "AnimationIterations",
-          "ByteOrder",
-          "Gamma",
-          "Matte",
-          "ModulusDepth",
-          "Quality",
-          "QuantizeColors",
-          "ResolutionUnits",
-          "ColorType",
-          "View",
-          0
-        };
-
-      octave_map info (dim_vector (nframes, 1), string_vector (fields));
-
-      file_stat fs (filename);
-
-      std::string filetime;
-
-      if (fs)
-        {
-          octave_localtime mtime = fs.mtime ();
-
-          filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
+          // For image formats that support floating point values, we write
+          // the actual values. For those who don't, we only use the values
+          // on the range [0 1] and save integer values.
+          // But here, even for formats that would support floating point
+          // values, GM seems unable to do that so we at least make them uint32.
+          uint32NDArray clip_img;
+          uint32NDArray clip_alpha;
+          if (img.is_single_type ())
+            {
+              clip_img   = img_float2uint<FloatNDArray> (img.float_array_value ());
+              clip_alpha = img_float2uint<FloatNDArray> (alpha.float_array_value ());
+            }
+          else
+            {
+              clip_img   = img_float2uint<NDArray> (img.array_value ());
+              clip_alpha = img_float2uint<NDArray> (alpha.array_value ());
+            }
+          encode_uint_image<uint32NDArray> (imvec, clip_img, clip_alpha);
         }
       else
         {
-          std::string msg = fs.error ();
-
-          error ("imfinfo: error reading '%s': %s",
-                 filename.c_str (), msg.c_str ());
-
+          error ("__magick_write__: image type not supported");
+          return retval;
+        }
+    }
+  else
+    {
+      // We should not get floating point indexed images here because we
+      // converted them in __imwrite__.m. We should probably do it here
+      // but it would look much messier.
+      if (img.is_uint8_type ())
+        encode_indexed_images<uint8NDArray>  (imvec, img.uint8_array_value (),
+                                              cmap);
+      else if (img.is_uint16_type ())
+        encode_indexed_images<uint16NDArray> (imvec, img.uint16_array_value (),
+                                              cmap);
+      else
+        {
+          error ("__magick_write__: indexed image must be uint8, uint16 or float.");
           return retval;
         }
-
-      // For each frame in the image (some images contain multiple
-      // layers, each to be treated like a separate image).
-      for (int frame = 0; frame < nframes; frame++)
-        {
-          Magick::Image im = imvec[frame];
-
-          // Add file name and timestamp.
-          info.contents ("Filename")(frame,0) = filename;
-          info.contents ("FileModDate")(frame,0) = filetime;
-
-          // Annoying CamelCase naming is for Matlab compatibility.
-          GET_PARAM (fileSize, "FileSize")
-          GET_PARAM (rows, "Height")
-          GET_PARAM (columns, "Width")
-          GET_PARAM (depth, "BitDepth")
-          GET_PARAM (magick, "Format")
-          GET_PARAM (format, "LongFormat")
-          GET_PARAM (xResolution, "XResolution")
-          GET_PARAM (yResolution, "YResolution")
-          GET_PARAM (totalColors, "TotalColors")
-          GET_PARAM (tileName, "TileName")
-          GET_PARAM (animationDelay, "AnimationDelay")
-          GET_PARAM (animationIterations, "AnimationIterations")
-          GET_PARAM (endian, "ByteOrder")
-          GET_PARAM (gamma, "Gamma")
-          GET_PARAM (matte, "Matte")
-          GET_PARAM (modulusDepth, "ModulusDepth")
-          GET_PARAM (quality, "Quality")
-          GET_PARAM (quantizeColors, "QuantizeColors")
-          GET_PARAM (resolutionUnits, "ResolutionUnits")
-          GET_PARAM (type, "ColorType")
-          GET_PARAM (view, "View")
-        }
-
-      retval = octave_value (info);
-    }
-  catch (Magick::Warning& w)
-    {
-      warning ("Magick++ warning: %s", w.what ());
-    }
-  catch (Magick::ErrorCoder& e)
-    {
-      warning ("Magick++ coder error: %s", e.what ());
-    }
-  catch (Magick::Exception& e)
-    {
-      error ("Magick++ exception: %s", e.what ());
-      return retval;
     }
 
-#else
+  const octave_idx_type nFrames = imvec.size ();
+
+  // FIXME What happens when we try to set with formats that do not support it?
+  const octave_idx_type quality = options.getfield ("quality").int_value ();
+  for (octave_idx_type i = 0; i < nFrames; i++)
+    imvec[i].quality (quality);
 
-  error ("imfinfo: not available in this version of Octave");
+  // If writemode is set to append, read the image and append to it. Even
+  // if set to append, make sure that something was read at all.
+  const std::string writemode = options.getfield ("writemode").string_value ();
+  if (writemode == "append" && file_stat (filename).exists ())
+    {
+      std::vector<Magick::Image> ini_imvec;
+      read_file (filename, ini_imvec);
+      if (error_state)
+          return retval;
+      if (ini_imvec.size () > 0)
+        {
+          ini_imvec.insert (ini_imvec.end (), imvec.begin (), imvec.end ());
+          ini_imvec.swap (imvec);
+        }
+    }
+
+  write_file (filename, ext, imvec);
+  if (error_state)
+    return retval;
 
 #endif
-
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
-#undef GET_PARAM
+// Gets the minimum information from images such as its size and format. Much
+// faster than using imfinfo, which slows down a lot since. Note than without
+// this, we need to read the image once for imfinfo to set defaults (which is
+// done in Octave language), and then again for the actual reading.
+DEFUN_DLD (__magick_ping__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} __magick_ping__ (@var{fname}, @var{idx})\n\
+Ping image information with GraphicsMagick or ImageMagick.\n\
+\n\
+This is a private internal function not intended for direct use.\n\
+\n\
+@seealso{imfinfo}\n\
+@end deftypefn")
+{
+  octave_value retval;
+#ifndef HAVE_MAGICK
+  gripe_disabled_feature ("imfinfo", "Image IO");
+#else
+  maybe_initialize_magick ();
+
+  if (args.length () < 1 || ! args(0).is_string ())
+    {
+      print_usage ();
+      return retval;
+    }
+  const std::string filename = args(0).string_value ();
+  int idx;
+  if (args.length () > 1)
+    idx = args(1).int_value () -1;
+  else
+    idx = 0;
+
+  Magick::Image img;
+  img.subImage (idx);
+  img.subRange (1);
+  img.ping (filename);
+  static const char *fields[] = {"rows", "columns", "format", 0};
+  octave_scalar_map ping = octave_scalar_map (string_vector (fields));
+  ping.setfield ("rows",    octave_value (img.rows ()));
+  ping.setfield ("columns", octave_value (img.columns ()));
+  ping.setfield ("format",  octave_value (img.magick ()));
+  retval = octave_value (ping);
+#endif
+  return retval;
+}
+
+#ifdef HAVE_MAGICK
+static octave_value
+magick_to_octave_value (const Magick::CompressionType& magick)
+{
+  switch (magick)
+    {
+      case Magick::NoCompression:
+        return octave_value ("none");
+      case Magick::BZipCompression:
+        return octave_value ("bzip");
+      case Magick::FaxCompression:
+        return octave_value ("fax3");
+      case Magick::Group4Compression:
+        return octave_value ("fax4");
+      case Magick::JPEGCompression:
+        return octave_value ("jpeg");
+      case Magick::LZWCompression:
+        return octave_value ("lzw");
+      case Magick::RLECompression:
+        // This is named "rle" for the HDF, but the same thing is named
+        // "ccitt" and "PackBits" for binary and non-binary images in TIFF.
+        return octave_value ("rle");
+      case Magick::ZipCompression:
+        return octave_value ("deflate");
+
+      // The following are present only in recent versions of GraphicsMagick.
+      // At the moment the only use of this would be to have imfinfo report
+      // the compression method. In the future, someone could implement
+      // the Compression option for imwrite in which case a macro in
+      // configure.ac will have to check for their presence of this.
+      // See bug #39913
+//      case Magick::LZMACompression:
+//        return octave_value ("lzma");
+//      case Magick::JPEG2000Compression:
+//        return octave_value ("jpeg2000");
+//      case Magick::JBIG1Compression:
+//        return octave_value ("jbig1");
+//      case Magick::JBIG2Compression:
+//        return octave_value ("jbig2");
+      default:
+        return octave_value ("undefined");
+    }
+}
+
+static octave_value
+magick_to_octave_value (const Magick::EndianType& magick)
+{
+  switch (magick)
+    {
+      case Magick::LSBEndian:
+        return octave_value ("little-endian");
+      case Magick::MSBEndian:
+        return octave_value ("big-endian");
+      default:
+        return octave_value ("undefined");
+    }
+}
 
-// Determine the file formats supported by GraphicsMagick.  This is
-// called once at the beginning of imread or imwrite to determine
-// exactly which file formats are supported, so error messages can be
-// displayed properly.
+static octave_value
+magick_to_octave_value (const Magick::OrientationType& magick)
+{
+  switch (magick)
+    {
+      // Values come from the TIFF6 spec
+      case Magick::TopLeftOrientation:
+        return octave_value (1);
+      case Magick::TopRightOrientation:
+        return octave_value (2);
+      case Magick::BottomRightOrientation:
+        return octave_value (3);
+      case Magick::BottomLeftOrientation:
+        return octave_value (4);
+      case Magick::LeftTopOrientation:
+        return octave_value (5);
+      case Magick::RightTopOrientation:
+        return octave_value (6);
+      case Magick::RightBottomOrientation:
+        return octave_value (7);
+      case Magick::LeftBottomOrientation:
+        return octave_value (8);
+      default:
+        return octave_value (1);
+    }
+}
+
+static octave_value
+magick_to_octave_value (const Magick::ResolutionType& magick)
+{
+  switch (magick)
+    {
+      case Magick::PixelsPerInchResolution:
+        return octave_value ("Inch");
+      case Magick::PixelsPerCentimeterResolution:
+        return octave_value ("Centimeter");
+      default:
+        return octave_value ("undefined");
+    }
+}
+
+// Meant to be shared with both imfinfo and imwrite.
+static std::map<octave_idx_type, std::string>
+init_disposal_methods ()
+{
+  //  GIF Specifications:
+  //
+  // Disposal Method - Indicates the way in which the graphic is to
+  //                    be treated after being displayed.
+  //
+  //  0 -   No disposal specified. The decoder is
+  //        not required to take any action.
+  //  1 -   Do not dispose. The graphic is to be left
+  //        in place.
+  //  2 -   Restore to background color. The area used by the
+  //        graphic must be restored to the background color.
+  //  3 -   Restore to previous. The decoder is required to
+  //        restore the area overwritten by the graphic with
+  //        what was there prior to rendering the graphic.
+  //  4-7 - To be defined.
+  static std::map<octave_idx_type, std::string> methods;
+  if (methods.empty ())
+    {
+      methods[0] = "doNotSpecify";
+      methods[1] = "leaveInPlace";
+      methods[2] = "restoreBG";
+      methods[3] = "restorePrevious";
+    }
+  return methods;
+}
 
-DEFUN_DLD (__magick_format_list__, args, ,
+static bool
+is_valid_exif (const std::string& val)
+{
+  // Sometimes GM will return the string "unknown" instead of empty
+  // for an empty value.
+  return (! val.empty () && val != "unknown");
+}
+
+static void
+fill_exif (octave_scalar_map& map, Magick::Image& img,
+           const std::string& key)
+{
+  const std::string attr = img.attribute ("EXIF:" + key);
+  if (is_valid_exif (attr))
+    map.setfield (key, octave_value (attr));
+  return;
+}
+
+static void
+fill_exif_ints (octave_scalar_map& map, Magick::Image& img,
+                const std::string& key)
+{
+  const std::string attr = img.attribute ("EXIF:" + key);
+  if (is_valid_exif (attr))
+    {
+      // string of the type "float,float,float....."
+      float number;
+      ColumnVector values (std::count (attr.begin (), attr.end (), ',') +1);
+      std::string sub;
+      std::istringstream sstream (attr);
+      octave_idx_type n = 0;
+      while (std::getline (sstream, sub, char (',')))
+        {
+          sscanf (sub.c_str (), "%f", &number);
+          values(n++) = number;
+        }
+      map.setfield (key, octave_value (values));
+    }
+  return;
+}
+
+static void
+fill_exif_floats (octave_scalar_map& map, Magick::Image& img,
+                  const std::string& key)
+{
+  const std::string attr = img.attribute ("EXIF:" + key);
+  if (is_valid_exif (attr))
+    {
+      // string of the type "int/int,int/int,int/int....."
+      int numerator;
+      int denominator;
+      ColumnVector values (std::count (attr.begin (), attr.end (), ',') +1);
+      std::string sub;
+      std::istringstream sstream (attr);
+      octave_idx_type n = 0;
+      while (std::getline (sstream, sub, ','))
+        {
+          sscanf (sub.c_str (), "%i/%i", &numerator, &denominator);
+          values(n++) = double (numerator) / double (denominator);
+        }
+      map.setfield (key, octave_value (values));
+    }
+  return;
+}
+
+#endif
+
+DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_format_list__ (@var{formats})\n\
-Undocumented internal function.\n\
+@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
+Read image information with GraphicsMagick or ImageMagick.\n\
+\n\
+This is a private internal function not intended for direct use.  Instead\n\
+use @code{imfinfo}.\n\
+\n\
+@seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-#ifdef HAVE_MAGICK
+#ifndef HAVE_MAGICK
+  gripe_disabled_feature ("imfinfo", "Image IO");
+#else
   maybe_initialize_magick ();
 
-  std::list<std::string> accepted_formats;
+  if (args.length () < 1 || ! args(0).is_string ())
+    {
+      print_usage ();
+      return retval;
+    }
+  const std::string filename = args(0).string_value ();
 
-  if (args.length () == 1)
-    {
-      Cell c = args (0).cell_value ();
+  std::vector<Magick::Image> imvec;
+  read_file (filename, imvec);
+  if (error_state)
+    return retval;
+  const octave_idx_type nFrames = imvec.size ();
+  const std::string format = imvec[0].magick ();
 
-      if (! error_state)
-        {
-          for (octave_idx_type i = 0; i < c.nelem (); i++)
-            {
-              try
-                {
-                  std::string fmt = c.elem (i).string_value ();
+  // Here's how this function works. We need to return a struct array, one
+  // struct for each image in the file (remember, there are image
+  // that allow for multiple images in the same file). Now, Matlab seems
+  // to have format specific code so the fields on the struct are different
+  // for each format. It only has a small subset that is common to all
+  // of them, the others are undocumented. Because we try to abstract from
+  // the formats we always return the same list of fields (note that with
+  // GM we support more than 88 formats. That's way more than Matlab, and
+  // I don't want to write specific code for each of them).
+  //
+  // So what we do is we create an octave_scalar_map, fill it with the
+  // information for that image, and then insert it into an octave_map.
+  // Because in the same file, different images may have values for
+  // different fields, we can't create a field only if there's a value.
+  // Bad things happen if we merge octave_scalar_maps with different
+  // fields from the others (suppose for example a TIFF file with 4 images,
+  // where only the third image has a colormap.
+
+  static const char *fields[] =
+    {
+      // These are fields that must always appear for Matlab.
+      "Filename",
+      "FileModDate",
+      "FileSize",
+      "Format",
+      "FormatVersion",
+      "Width",
+      "Height",
+      "BitDepth",
+      "ColorType",
 
-                  Magick::CoderInfo info(fmt);
+      // These are format specific or not existent in Matlab. The most
+      // annoying thing is that Matlab may have different names for the
+      // same thing in different formats.
+      "DelayTime",
+      "DisposalMethod",
+      "LoopCount",
+      "ByteOrder",
+      "Gamma",
+      "Chromaticities",
+      "Comment",
+      "Quality",
+      "Compression",        // same as CompressionType
+      "Colormap",           // same as ColorTable (in PNG)
+      "Orientation",
+      "ResolutionUnit",
+      "XResolution",
+      "YResolution",
+      "Software",           // sometimes is an Exif tag
+      "Make",               // actually an Exif tag
+      "Model",              // actually an Exif tag
+      "DateTime",           // actually an Exif tag
+      "ImageDescription",   // actually an Exif tag
+      "Artist",             // actually an Exif tag
+      "Copyright",          // actually an Exif tag
+      "DigitalCamera",
+      "GPSInfo",
+      // Notes for the future: GM allows to get many attributes, and even has
+      // attribute() to obtain arbitrary ones, that may exist in only some
+      // cases. The following is a list of some methods and into what possible
+      // Matlab compatible values they may be converted.
+      //
+      //  colorSpace()      -> PhotometricInterpretation
+      //  backgroundColor() -> BackgroundColor
+      //  interlaceType()   -> Interlaced, InterlaceType, and PlanarConfiguration
+      //  label()           -> Title
+      0
+    };
 
-                  if (info.isReadable () && info.isWritable ())
-                    accepted_formats.push_back (fmt);
-                }
-              catch (Magick::Exception& e)
-                {
-                  // Do nothing: exception here are simply missing formats.
-                }
-            }
-        }
-      else
-        error ("__magick_format_list__: expecting a cell array of image format names");
+  // The one we will return at the end
+  octave_map info (dim_vector (nFrames, 1), string_vector (fields));
+
+  // Some of the fields in the struct are about file information and will be
+  // the same for all images in the file. So we create a template, fill in
+  // those values, and make a copy of the template for each image.
+  octave_scalar_map template_info = (string_vector (fields));
+
+  template_info.setfield ("Format", octave_value (format));
+  // We can't actually get FormatVersion but even Matlab sometimes can't.
+  template_info.setfield ("FormatVersion", octave_value (""));
+
+  const file_stat fs (filename);
+  if (fs)
+    {
+      const octave_localtime mtime (fs.mtime ());
+      const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
+      template_info.setfield ("Filename",    octave_value (filename));
+      template_info.setfield ("FileModDate", octave_value (filetime));
+      template_info.setfield ("FileSize",    octave_value (fs.size ()));
     }
   else
-    print_usage ();
+    {
+      error ("imfinfo: error reading '%s': %s",
+             filename.c_str (), fs.error ().c_str ());
+      return retval;
+    }
+
+  for (octave_idx_type frame = 0; frame < nFrames; frame++)
+    {
+      octave_scalar_map info_frame (template_info);
+      const Magick::Image img = imvec[frame];
+
+      info_frame.setfield ("Width",  octave_value (img.columns ()));
+      info_frame.setfield ("Height", octave_value (img.rows ()));
+      info_frame.setfield ("BitDepth",
+        octave_value (get_depth (const_cast<Magick::Image&> (img))));
+
+      // Stuff related to colormap, image class and type
+      // Because GM is too smart for us... Read the comments in is_indexed()
+      {
+        std::string color_type;
+        Matrix cmap;
+        if (is_indexed (img))
+          {
+            color_type = "indexed";
+            cmap = read_maps (const_cast<Magick::Image&> (img))(0).matrix_value ();
+          }
+        else
+          {
+            switch (img.type ())
+              {
+                case Magick::BilevelType:
+                case Magick::GrayscaleType:
+                case Magick::GrayscaleMatteType:
+                  color_type = "grayscale";
+                  break;
+
+                case Magick::TrueColorType:
+                case Magick::TrueColorMatteType:
+                  color_type = "truecolor";
+                  break;
+
+                case Magick::PaletteType:
+                case Magick::PaletteMatteType:
+                  // we should never get here or is_indexed needs to be fixed
+                  color_type = "indexed";
+                  break;
+
+                case Magick::ColorSeparationType:
+                case Magick::ColorSeparationMatteType:
+                  color_type = "CMYK";
+                  break;
+
+                default:
+                  color_type = "undefined";
+              }
+          }
+        info_frame.setfield ("ColorType", octave_value (color_type));
+        info_frame.setfield ("Colormap",  octave_value (cmap));
+      }
+
+      {
+        // Not all images have chroma values. In such cases, they'll
+        // be all zeros. So rather than send a matrix of zeros, we will
+        // check for that, and send an empty vector instead.
+        RowVector chromaticities (8);
+        double* chroma_fvec = chromaticities.fortran_vec ();
+        img.chromaWhitePoint    (&chroma_fvec[0], &chroma_fvec[1]);
+        img.chromaRedPrimary    (&chroma_fvec[2], &chroma_fvec[3]);
+        img.chromaGreenPrimary  (&chroma_fvec[4], &chroma_fvec[5]);
+        img.chromaBluePrimary   (&chroma_fvec[6], &chroma_fvec[7]);
+        if (chromaticities.nnz () == 0)
+          chromaticities = RowVector (0);
+        info_frame.setfield ("Chromaticities", octave_value (chromaticities));
+      }
 
-  retval = Cell (accepted_formats);
+      info_frame.setfield ("Gamma",         octave_value (img.gamma ()));
+      info_frame.setfield ("XResolution",   octave_value (img.xResolution ()));
+      info_frame.setfield ("YResolution",   octave_value (img.yResolution ()));
+      info_frame.setfield ("DelayTime",     octave_value (img.animationDelay ()));
+      info_frame.setfield ("LoopCount",     octave_value (img.animationIterations ()));
+      info_frame.setfield ("Quality",       octave_value (img.quality ()));
+      info_frame.setfield ("Comment",       octave_value (img.comment ()));
+
+      info_frame.setfield ("Compression",
+        magick_to_octave_value (img.compressType ()));
+      info_frame.setfield ("Orientation",
+        magick_to_octave_value (img.orientation ()));
+      info_frame.setfield ("ResolutionUnit",
+        magick_to_octave_value (img.resolutionUnits ()));
+      info_frame.setfield ("ByteOrder",
+        magick_to_octave_value (img.endian ()));
+
+      // It is not possible to know if there's an Exif field so we just
+      // check for the Exif Version value. If it does exists, then we
+      // bother about looking for specific fields.
+      {
+        Magick::Image& cimg = const_cast<Magick::Image&> (img);
+
+        // These will be in Exif tags but must appear as fields in the
+        // base struct array, not as another struct in one of its fields.
+        // This is likely because they belong to the Baseline TIFF specs
+        // and may appear out of the Exif tag. So first we check if it
+        // exists outside the Exif tag.
+        // See Section 4.6.4, table 4, page 28 of Exif specs version 2.3
+        // (CIPA DC- 008-Translation- 2010)
+        static const char *base_exif_str_fields[] = {
+          "DateTime",
+          "ImageDescription",
+          "Make",
+          "Model",
+          "Software",
+          "Artist",
+          "Copyright",
+          0,
+        };
+        static const string_vector base_exif_str (base_exif_str_fields);
+        static const octave_idx_type n_base_exif_str = base_exif_str.numel ();
+        for (octave_idx_type field = 0; field < n_base_exif_str; field++)
+          {
+            info_frame.setfield (base_exif_str[field],
+              octave_value (cimg.attribute (base_exif_str[field])));
+            fill_exif (info_frame, cimg, base_exif_str[field]);
+          }
+
+        octave_scalar_map camera;
+        octave_scalar_map gps;
+        if (! cimg.attribute ("EXIF:ExifVersion").empty ())
+          {
+            // See Section 4.6.5, table 7 and 8, over pages page 42 to 43
+            // of Exif specs version 2.3 (CIPA DC- 008-Translation- 2010)
+
+            // Listed on the Exif specs as being of type ASCII.
+            static const char *exif_str_fields[] = {
+              "RelatedSoundFile",
+              "DateTimeOriginal",
+              "DateTimeDigitized",
+              "SubSecTime",
+              "DateTimeOriginal",
+              "SubSecTimeOriginal",
+              "SubSecTimeDigitized",
+              "ImageUniqueID",
+              "CameraOwnerName",
+              "BodySerialNumber",
+              "LensMake",
+              "LensModel",
+              "LensSerialNumber",
+              "SpectralSensitivity",
+              // These last two are of type undefined but most likely will
+              // be strings. Even if they're not GM returns a string anyway.
+              "UserComment",
+              "MakerComment",
+              0
+            };
+            static const string_vector exif_str (exif_str_fields);
+            static const octave_idx_type n_exif_str = exif_str.numel ();
+            for (octave_idx_type field = 0; field < n_exif_str; field++)
+              fill_exif (camera, cimg, exif_str[field]);
 
-#else
+            // Listed on the Exif specs as being of type SHORT or LONG.
+            static const char *exif_int_fields[] = {
+              "ColorSpace",
+              "ExifImageWidth",  // PixelXDimension (CPixelXDimension in Matlab)
+              "ExifImageHeight", // PixelYDimension (CPixelYDimension in Matlab)
+              "PhotographicSensitivity",
+              "StandardOutputSensitivity",
+              "RecommendedExposureIndex",
+              "ISOSpeed",
+              "ISOSpeedLatitudeyyy",
+              "ISOSpeedLatitudezzz",
+              "FocalPlaneResolutionUnit",
+              "FocalLengthIn35mmFilm",
+              // Listed as SHORT or LONG but with more than 1 count.
+              "SubjectArea",
+              "SubjectLocation",
+              // While the following are an integer, their value have a meaning
+              // that must be represented as a string for Matlab compatibility.
+              // For example, a 3 on ExposureProgram, would return
+              // "Aperture priority" as defined on the Exif specs.
+              "ExposureProgram",
+              "SensitivityType",
+              "MeteringMode",
+              "LightSource",
+              "Flash",
+              "SensingMethod",
+              "FileSource",
+              "CustomRendered",
+              "ExposureMode",
+              "WhiteBalance",
+              "SceneCaptureType",
+              "GainControl",
+              "Contrast",
+              "Saturation",
+              "Sharpness",
+              "SubjectDistanceRange",
+              0
+            };
+            static const string_vector exif_int (exif_int_fields);
+            static const octave_idx_type n_exif_int = exif_int.numel ();
+            for (octave_idx_type field = 0; field < n_exif_int; field++)
+              fill_exif_ints (camera, cimg, exif_int[field]);
+
+            // Listed as RATIONAL or SRATIONAL
+            static const char *exif_float_fields[] = {
+              "Gamma",
+              "CompressedBitsPerPixel",
+              "ExposureTime",
+              "FNumber",
+              "ShutterSpeedValue",  // SRATIONAL
+              "ApertureValue",
+              "BrightnessValue",    // SRATIONAL
+              "ExposureBiasValue",  // SRATIONAL
+              "MaxApertureValue",
+              "SubjectDistance",
+              "FocalLength",
+              "FlashEnergy",
+              "FocalPlaneXResolution",
+              "FocalPlaneYResolution",
+              "ExposureIndex",
+              "DigitalZoomRatio",
+              // Listed as RATIONAL or SRATIONAL with more than 1 count.
+              "LensSpecification",
+              0
+            };
+            static const string_vector exif_float (exif_float_fields);
+            static const octave_idx_type n_exif_float = exif_float.numel ();
+            for (octave_idx_type field = 0; field < n_exif_float; field++)
+              fill_exif_floats (camera, cimg, exif_float[field]);
+
+            // Inside a Exif field, it is possible that there is also a
+            // GPS field. This is not the same as ExifVersion but seems
+            // to be how we have to check for it.
+            if (cimg.attribute ("EXIF:GPSInfo") != "unknown")
+              {
+                // The story here is the same as with Exif.
+                // See Section 4.6.6, table 15 on page 68 of Exif specs
+                // version 2.3 (CIPA DC- 008-Translation- 2010)
 
-  error ("__magick_format_list__: not available in this version of Octave");
+                static const char *gps_str_fields[] = {
+                  "GPSLatitudeRef",
+                  "GPSLongitudeRef",
+                  "GPSAltitudeRef",
+                  "GPSSatellites",
+                  "GPSStatus",
+                  "GPSMeasureMode",
+                  "GPSSpeedRef",
+                  "GPSTrackRef",
+                  "GPSImgDirectionRef",
+                  "GPSMapDatum",
+                  "GPSDestLatitudeRef",
+                  "GPSDestLongitudeRef",
+                  "GPSDestBearingRef",
+                  "GPSDestDistanceRef",
+                  "GPSDateStamp",
+                  0
+                };
+                static const string_vector gps_str (gps_str_fields);
+                static const octave_idx_type n_gps_str = gps_str.numel ();
+                for (octave_idx_type field = 0; field < n_gps_str; field++)
+                  fill_exif (gps, cimg, gps_str[field]);
+
+                static const char *gps_int_fields[] = {
+                  "GPSDifferential",
+                  0
+                };
+                static const string_vector gps_int (gps_int_fields);
+                static const octave_idx_type n_gps_int = gps_int.numel ();
+                for (octave_idx_type field = 0; field < n_gps_int; field++)
+                  fill_exif_ints (gps, cimg, gps_int[field]);
 
+                static const char *gps_float_fields[] = {
+                  "GPSAltitude",
+                  "GPSDOP",
+                  "GPSSpeed",
+                  "GPSTrack",
+                  "GPSImgDirection",
+                  "GPSDestBearing",
+                  "GPSDestDistance",
+                  "GPSHPositioningError",
+                  // Listed as RATIONAL or SRATIONAL with more than 1 count.
+                  "GPSLatitude",
+                  "GPSLongitude",
+                  "GPSTimeStamp",
+                  "GPSDestLatitude",
+                  "GPSDestLongitude",
+                  0
+                };
+                static const string_vector gps_float (gps_float_fields);
+                static const octave_idx_type n_gps_float = gps_float.numel ();
+                for (octave_idx_type field = 0; field < n_gps_float; field++)
+                  fill_exif_floats (gps, cimg, gps_float[field]);
+
+              }
+          }
+        info_frame.setfield ("DigitalCamera", octave_value (camera));
+        info_frame.setfield ("GPSInfo",       octave_value (gps));
+      }
+
+      info.fast_elem_insert (frame, info_frame);
+    }
+
+  if (format == "GIF")
+    {
+      static std::map<octave_idx_type, std::string> disposal_methods
+        = init_disposal_methods ();
+      string_vector methods (nFrames);
+      for (octave_idx_type frame = 0; frame < nFrames; frame++)
+        methods[frame] = disposal_methods[imvec[frame].gifDisposeMethod ()];
+      info.setfield ("DisposalMethod", Cell (methods));
+    }
+  else
+    info.setfield ("DisposalMethod",
+                   Cell (dim_vector (nFrames, 1), octave_value ("")));
+
+  retval = octave_value (info);
 #endif
-
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
+
+DEFUN_DLD (__magick_formats__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} __magick_imformats__ (@var{formats})\n\
+Fill formats info with GraphicsMagick CoderInfo.\n\
+\n\
+@seealso{imfinfo, imformats, imread, imwrite}\n\
+@end deftypefn")
+{
+  octave_value retval;
+#ifndef HAVE_MAGICK
+  gripe_disabled_feature ("imformats", "Image IO");
+#else
+  if (args.length () != 1 || ! args(0).is_map ())
+    {
+      print_usage ();
+      return retval;
+    }
+  octave_map formats = args(0).map_value ();
+
+  maybe_initialize_magick ();
+  for (octave_idx_type idx = 0; idx < formats.numel (); idx++)
+    {
+      try
+        {
+          octave_scalar_map fmt = formats.checkelem (idx);
+          Magick::CoderInfo coder (fmt.getfield ("coder").string_value ());
+
+          fmt.setfield ("description", octave_value (coder.description ()));
+          fmt.setfield ("multipage", coder.isMultiFrame () ? true : false);
+          // default for read and write is a function handle. If we can't
+          // read or write them, them set it to an empty value
+          if (! coder.isReadable ())
+            fmt.setfield ("read",  Matrix ());
+          if (! coder.isWritable ())
+            fmt.setfield ("write", Matrix ());
+          formats.fast_elem_insert (idx, fmt);
+        }
+      catch (Magick::Exception& e)
+        {
+          // Exception here are missing formats. So we remove the format
+          // from the structure and reduce idx.
+          formats.delete_elements (idx);
+          idx--;
+        }
+    }
+  retval = formats;
+#endif
+  return retval;
+}
+
+/*
+## No test needed for internal helper function.
+%!assert (1)
+*/
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -98,49 +98,49 @@ is the factorization of @code{@var{A}(@v
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{Q}' * @var{A} * @var{Q}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
-However, given the flag \"vector\", @var{Q} will be returned as a vector\n\
-such that\n\
+However, given the flag @qcode{\"vector\"}, @var{Q} will be returned as a\n\
+vector such that\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{A}(@var{Q}, @var{Q}).\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-Called with either a sparse or full matrix and using the \"lower\" flag,\n\
-@code{chol} returns the lower triangular factorization such that\n\
+Called with either a sparse or full matrix and using the @qcode{\"lower\"}\n\
+flag, @code{chol} returns the lower triangular factorization such that\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-For full matrices, if the \"lower\" flag is set only the lower triangular\n\
-part of the matrix is used for the factorization, otherwise the upper\n\
-triangular part is used.\n\
+For full matrices, if the @qcode{\"lower\"} flag is set only the lower\n\
+triangular part of the matrix is used for the factorization, otherwise the\n\
+upper triangular part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
-@seealso{cholinv, chol2inv}\n\
+@seealso{hess, lu, qr, qz, schur, svd, cholinv, chol2inv, cholupdate, cholinsert, choldelete, cholshift}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool LLt = false;
   bool vecout = false;
 
   if (nargin < 1 || nargin > 3 || nargout > 3
@@ -626,35 +626,35 @@ DEFUN_DLD (cholupdate, args, nargout,
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
 \n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
-if @var{op} is \"+\"\n\
+if @var{op} is @qcode{\"+\"}\n\
 \n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'\n\
-if @var{op} is \"-\"\n\
+if @var{op} is @qcode{\"-\"}\n\
 @end itemize\n\
 \n\
-If @var{op} is \"-\", @var{info} is set to\n\
+If @var{op} is @qcode{\"-\"}, @var{info} is set to\n\
 \n\
 @itemize\n\
 @item 0 if the downdate was successful,\n\
 \n\
 @item 1 if @var{R}'*@var{R} - @var{u}*@var{u}' is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
-@seealso{chol, qrupdate}\n\
+@seealso{chol, cholinsert, choldelete, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin > 3 || nargin < 2)
     {
@@ -844,17 +844,17 @@ On return, @var{info} is set to\n\
 @item 0 if the insertion was successful,\n\
 \n\
 @item 1 if @var{A1} is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
-@seealso{chol, cholupdate, choldelete}\n\
+@seealso{chol, cholupdate, choldelete, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 3)
     {
@@ -1092,17 +1092,17 @@ If @var{info} is not present, an error m
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
 @w{p = [1:j-1,j+1:n+1]}.\n\
-@seealso{chol, cholupdate, cholinsert}\n\
+@seealso{chol, cholupdate, cholinsert, cholshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 2)
     {
@@ -1229,17 +1229,17 @@ DEFUN_DLD (cholshift, args, ,
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
-@seealso{chol, cholinsert, choldelete}\n\
+@seealso{chol, cholupdate, cholinsert, choldelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 3)
     {
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -646,17 +646,18 @@ DEFUN_DLD (etree, args, nargout,
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
 Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
-\"sym\" or \"col\", for symmetric or column elimination tree respectively\n\
+@qcode{\"sym\"} or @qcode{\"col\"}, for symmetric or column elimination tree\n\
+respectively.\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -65,41 +65,42 @@ fftw (\"dwisdom\", @var{wisdom})\n\
 If @var{wisdom} is an empty string, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
 The fashion in which this wisdom is generated is also controlled by\n\
 the @code{fftw} function.  There are five different manners in which the\n\
 wisdom can be treated:\n\
 \n\
 @table @asis\n\
-@item \"estimate\"\n\
+@item @qcode{\"estimate\"}\n\
 Specifies that no run-time measurement of the optimal means of\n\
 calculating a particular is performed, and a simple heuristic is used\n\
 to pick a (probably sub-optimal) plan.  The advantage of this method is\n\
 that there is little or no overhead in the generation of the plan, which\n\
 is appropriate for a Fourier transform that will be calculated once.\n\
 \n\
-@item \"measure\"\n\
+@item @qcode{\"measure\"}\n\
 In this case a range of algorithms to perform the transform is considered\n\
 and the best is selected based on their execution time.\n\
 \n\
-@item \"patient\"\n\
-Similar to \"measure\", but a wider range of algorithms is considered.\n\
+@item @qcode{\"patient\"}\n\
+Similar to @qcode{\"measure\"}, but a wider range of algorithms is\n\
+considered.\n\
 \n\
-@item \"exhaustive\"\n\
-Like \"measure\", but all possible algorithms that may be used to\n\
+@item @qcode{\"exhaustive\"}\n\
+Like @qcode{\"measure\"}, but all possible algorithms that may be used to\n\
 treat the transform are considered.\n\
 \n\
-@item \"hybrid\"\n\
+@item @qcode{\"hybrid\"}\n\
 As run-time measurement of the algorithm can be expensive, this is a\n\
-compromise where \"measure\" is used for transforms up to the size of 8192\n\
-and beyond that the \"estimate\" method is used.\n\
+compromise where @qcode{\"measure\"} is used for transforms up to the size\n\
+of 8192 and beyond that the @qcode{\"estimate\"} method is used.\n\
 @end table\n\
 \n\
-The default method is \"estimate\".  The current method can\n\
+The default method is @qcode{\"estimate\"}.  The current method can\n\
 be queried with\n\
 \n\
 @example\n\
 @var{method} = fftw (\"planner\")\n\
 @end example\n\
 \n\
 @noindent\n\
 or set by using\n\
diff --git a/libinterp/dldfcn/module-files b/libinterp/dldfcn/module-files
--- a/libinterp/dldfcn/module-files
+++ b/libinterp/dldfcn/module-files
@@ -1,22 +1,21 @@
 # FILE|CPPFLAGS|LDFLAGS|LIBRARIES
 __delaunayn__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 __dsearchn__.cc
+__eigs__.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 __fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
-__init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
+__init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS) $(OPENGL_LIBS)
 __init_gnuplot__.cc
 __magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
 __voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 ccolamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 chol.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 tsearch.cc
-urlwrite.cc|$(CURL_CPPFLAGS)|$(CURL_LDFLAGS)|$(CURL_LIBS)
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -128,17 +128,17 @@ for overdetermined systems of equations 
 @tex\n\
 $QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.\n\
 @end tex\n\
 @ifnottex\n\
 @code{@var{Q} * @var{Q} = @var{A}} where @var{Q} is an orthogonal matrix and\n\
 @var{R} is upper triangular.\n\
 @end ifnottex\n\
 \n\
-If given a second argument of '0', @code{qr} returns an economy-sized\n\
+If given a second argument of @qcode{'0'}, @code{qr} returns an economy-sized\n\
 QR@tie{}factorization, omitting zero rows of @var{R} and the corresponding\n\
 columns of @var{Q}.\n\
 \n\
 If the matrix @var{A} is full, the permuted QR@tie{}factorization\n\
 @code{[@var{Q}, @var{R}, @var{P}] = qr (@var{A})} forms the\n\
 QR@tie{}factorization such that the diagonal entries of @var{R} are\n\
 decreasing in magnitude order.  For example, given the matrix @code{a = [1,\n\
 2; 3, 4]},\n\
@@ -189,16 +189,17 @@ least squares approximation of @code{@va
 as\n\
 \n\
 @example\n\
 @group\n\
 [@var{C}, @var{R}] = qr (@var{A}, @var{B})\n\
 x = @var{R} \\ @var{C}\n\
 @end group\n\
 @end example\n\
+@seealso{chol, hess, lu, qz, schur, svd, qrupdate, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > (args(0).is_sparse_type () ? 3 : 2))
     {
@@ -764,17 +765,17 @@ of @w{@var{A} + @var{u}*@var{v}'}, where
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
 updates; thus, for k large enough, it will be both faster and more accurate\n\
 to recompute the factorization from scratch.\n\
 \n\
 The QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
-@seealso{qr, qrinsert, qrdelete}\n\
+@seealso{qr, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
     {
       print_usage ();
@@ -936,36 +937,36 @@ The QR@tie{}factorization supplied may b
 
 DEFUN_DLD (qrinsert, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be\n\
-inserted into @var{A} (if @var{orient} is @code{\"col\"}), or the\n\
+inserted into @var{A} (if @var{orient} is @qcode{\"col\"}), or the\n\
 QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x}\n\
 is a row vector to be inserted into @var{A} (if @var{orient} is\n\
-@code{\"row\"}).\n\
+@qcode{\"row\"}).\n\
 \n\
-The default value of @var{orient} is @code{\"col\"}.\n\
-If @var{orient} is @code{\"col\"},\n\
+The default value of @var{orient} is @qcode{\"col\"}.\n\
+If @var{orient} is @qcode{\"col\"},\n\
 @var{u} may be a matrix and @var{j} an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{B(:,@var{j})} gives @var{u} and @w{B(:,@var{j}) = []} gives @var{A}.\n\
 Notice that the latter case is done as a sequence of k insertions;\n\
 thus, for k large enough, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
 \n\
-If @var{orient} is @code{\"col\"},\n\
+If @var{orient} is @qcode{\"col\"},\n\
 the QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
-If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
-@seealso{qr, qrupdate, qrdelete}\n\
+If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
+@seealso{qr, qrupdate, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 4 || nargin > 5)
     {
       print_usage ();
@@ -1155,36 +1156,36 @@ If @var{orient} is @code{\"row\"}, full 
 
 DEFUN_DLD (qrdelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
-(if @var{orient} is \"col\"), or the QR@tie{}factorization of\n\
+(if @var{orient} is @qcode{\"col\"}), or the QR@tie{}factorization of\n\
 @w{[A(1:j-1,:);A(j+1:n,:)]}, i.e., @var{A} with one row deleted (if\n\
-@var{orient} is \"row\").\n\
+@var{orient} is @qcode{\"row\"}).\n\
 \n\
-The default value of @var{orient} is \"col\".\n\
+The default value of @var{orient} is @qcode{\"col\"}.\n\
 \n\
-If @var{orient} is @code{\"col\"},\n\
+If @var{orient} is @qcode{\"col\"},\n\
 @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{A(:,@var{j}) = []} gives @var{B}.\n\
 Notice that the latter case is done as a sequence of k deletions;\n\
 thus, for k large enough, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
 \n\
-If @var{orient} is @code{\"col\"},\n\
+If @var{orient} is @qcode{\"col\"},\n\
 the QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
-If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
-@seealso{qr, qrinsert, qrupdate}\n\
+If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
+@seealso{qr, qrupdate, qrinsert, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 3 || nargin > 4)
     {
       print_usage ();
@@ -1386,17 +1387,17 @@ If @var{orient} is @code{\"row\"}, full 
 %!               0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrdelete (Q, R, 3, "row");
 %! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1.5e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
 %!testif HAVE_QRUPDATE
-%! # Same test as above but with more precicision
+%! ## Same test as above but with more precicision
 %! AA = single ([0.091364  0.613038  0.027504  0.999083;
 %!               0.594638  0.425302  0.562834  0.603537;
 %!               0.383594  0.291238  0.742073  0.085574;
 %!               0.265712  0.268003  0.783553  0.238409;
 %!               0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrdelete (Q, R, 3, "row");
@@ -1424,17 +1425,17 @@ DEFUN_DLD (qrshift, args, ,
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A}(:,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
 \n\
-@seealso{qr, qrinsert, qrdelete}\n\
+@seealso{qr, qrupdate, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
     {
       print_usage ();
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -58,28 +58,28 @@ Is the type of the factorization and can
 @table @samp\n\
 @item sym\n\
 Factorize @var{S}.  This is the default.\n\
 \n\
 @item col\n\
 Factorize @code{@var{S}' * @var{S}}.\n\
 \n\
 @item row\n\
-Factorize @xcode{@var{S} * @var{S}'}.\n\
+Factorize @tcode{@var{S} * @var{S}'}.\n\
 \n\
 @item lo\n\
-Factorize @xcode{@var{S}'}\n\
+Factorize @tcode{@var{S}'}\n\
 @end table\n\
 \n\
 @item mode\n\
 The default is to return the Cholesky@tie{}factorization for @var{r}, and if\n\
-@var{mode} is 'L', the conjugate transpose of the Cholesky@tie{}factorization\n\
-is returned.  The conjugate transpose version is faster and uses less\n\
-memory, but returns the same values for @var{count}, @var{h}, @var{parent}\n\
-and @var{post} outputs.\n\
+@var{mode} is @qcode{'L'}, the conjugate transpose of the\n\
+Cholesky@tie{}factorization is returned.  The conjugate transpose version is\n\
+faster and uses less memory, but returns the same values for @var{count},\n\
+@var{h}, @var{parent} and @var{post} outputs.\n\
 @end table\n\
 \n\
 The output variables are\n\
 \n\
 @table @var\n\
 @item count\n\
 The row counts of the Cholesky@tie{}factorization as determined by @var{typ}.\n\
 \n\
diff --git a/libinterp/gendoc.pl b/libinterp/gendoc.pl
--- a/libinterp/gendoc.pl
+++ b/libinterp/gendoc.pl
@@ -59,15 +59,15 @@ DFFILE: foreach $df_fname (@ARGV)
     }
   }
   close (DF_FH);
 
   ## Print results in DOCSTRING format
   foreach $i (0 .. $#func_list)
   {
     $func = $func_list[$i];
-    print "$func\n";
+    print "\x{1d}$func\n";
     print "\@c $func $src_fname\n";
     print $docstr[$i],"\n";
   }
 
 }
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1560,19 +1560,19 @@ typeinfo (s)\n\
 @result{} sparse matrix\n\
 sparse_auto_mutate (true);\n\
 s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
 %!test
 %! s = speye (3);
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -268,17 +268,17 @@ octave_sparse_bool_matrix::load_binary (
   int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error ("load: only 2D sparse matrices are supported");
+    error ("load: only 2-D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1234,23 +1234,29 @@ octave_class::reconstruct_exemplar (void
           // Something has gone terribly wrong if
           // symbol_table::find_method (c_name, c_name) does not return
           // a class constructor for the class c_name...
           assert (have_ctor);
         }
 
       if (have_ctor)
         {
+          unwind_protect frame;
+
+          // Simulate try/catch.
+
+          interpreter_try (frame);
+
           octave_value_list result
             = ctor.do_multi_index_op (1, octave_value_list ());
 
-          if (result.length () == 1)
+          if (! error_state && result.length () == 1)
             retval = true;
-          else
-            warning ("call to constructor for class %s failed", c_name.c_str ());
+
+          error_state = false;
         }
       else
         warning ("no constructor for class %s", c_name.c_str ());
     }
 
   return retval;
 }
 
@@ -1396,29 +1402,27 @@ octave_class::load_ascii (std::istream& 
                 {
                   c_name = classname;
                   reconstruct_exemplar ();
 
                   map = m;
 
                   if (! reconstruct_parents ())
                     warning ("load: unable to reconstruct object inheritance");
-                  else
+
+                  if (load_path::find_method (classname, "loadobj")
+                      != std::string ())
                     {
-                      if (load_path::find_method (classname, "loadobj")
-                          != std::string ())
-                        {
-                          octave_value in = new octave_class (*this);
-                          octave_value_list tmp = feval ("loadobj", in, 1);
+                      octave_value in = new octave_class (*this);
+                      octave_value_list tmp = feval ("loadobj", in, 1);
 
-                          if (! error_state)
-                            map = tmp(0).map_value ();
-                          else
-                            success = false;
-                        }
+                      if (! error_state)
+                        map = tmp(0).map_value ();
+                      else
+                        success = false;
                     }
                 }
               else
                 {
                   error ("load: failed to load class");
                   success = false;
                 }
             }
@@ -1543,28 +1547,26 @@ octave_class::load_binary (std::istream&
         }
 
       if (is)
         {
           map = m;
 
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
-          else
+
+          if (load_path::find_method (c_name, "loadobj") != std::string ())
             {
-              if (load_path::find_method (c_name, "loadobj") != std::string ())
-                {
-                  octave_value in = new octave_class (*this);
-                  octave_value_list tmp = feval ("loadobj", in, 1);
+              octave_value in = new octave_class (*this);
+              octave_value_list tmp = feval ("loadobj", in, 1);
 
-                  if (! error_state)
-                    map = tmp(0).map_value ();
-                  else
-                    success = false;
-                }
+              if (! error_state)
+                map = tmp(0).map_value ();
+              else
+                success = false;
             }
         }
       else
         {
           warning ("load: failed to load class");
           success = false;
         }
     }
@@ -1783,33 +1785,29 @@ octave_class::load_hdf5 (hid_t loc_id, c
     }
 
   if (retval2 >= 0)
     {
       map = m;
 
       if (!reconstruct_parents ())
         warning ("load: unable to reconstruct object inheritance");
-      else
-        {
-          if (load_path::find_method (c_name, "loadobj") != std::string ())
-            {
-              octave_value in = new octave_class (*this);
-              octave_value_list tmp = feval ("loadobj", in, 1);
 
-              if (! error_state)
-                {
-                  map = tmp(0).map_value ();
-                  retval = true;
-                }
-              else
-                retval = false;
+      if (load_path::find_method (c_name, "loadobj") != std::string ())
+        {
+          octave_value in = new octave_class (*this);
+          octave_value_list tmp = feval ("loadobj", in, 1);
+
+          if (! error_state)
+            {
+              map = tmp(0).map_value ();
+              retval = true;
             }
           else
-            retval = true;
+            retval = false;
         }
     }
 
  error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -300,17 +300,17 @@ octave_sparse_complex_matrix::load_binar
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error ("load: only 2D sparse matrices are supported");
+    error ("load: only 2-D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1324,24 +1324,24 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 %!   unwind_protect_cleanup
 %!     unlink (nm);
 %!   end_unwind_protect
 %! endfor
 */
 
 /*
 %!function fcn_handle_save_recurse (n, mode, nm, f2, g2, hm2, hdld2, hbi2)
-%!  if n == 0
+%!  if (n == 0)
 %!    save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!  else
 %!    fcn_handle_save_recurse (n - 1, mode, nm, f2, g2, hm2, hdld2, hbi2);
 %!  endif
 %!endfunction
 %!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
-%!  if n == 0
+%!  if (n == 0)
 %!    load (nm)
 %!  else
 %!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
 %!  endif
 %!endfunction
 
 Test for bug #35876
 %!test
@@ -1787,18 +1787,18 @@ the function handle @var{fcn_handle}.\n\
   return retval;
 }
 
 DEFUN (str2func, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
-If the optional \"global\" argument is passed, locally visible functions\n\
-are ignored in the lookup.\n\
+If the optional @qcode{\"global\"} argument is passed, locally visible\n\
+functions are ignored in the lookup.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string nm = args(0).string_value ();
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -647,17 +647,17 @@ ambiguity between their use as a variabl
 constant.  All arguments followed by a parenthesis are considered\n\
 to be functions.  If no arguments are found, a function taking a single\n\
 argument named @code{x} will be created.\n\
 \n\
 If the second and subsequent arguments are character strings,\n\
 they are the names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
-@code{\"x\"}, @code{\"P1\"}, @dots{}, @code{\"P@var{N}\"}.\n\
+@qcode{\"x\"}, @qcode{\"P1\"}, @dots{}, @qcode{\"P@var{N}\"}.\n\
 @seealso{argnames, formula, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2299,19 +2299,19 @@ Undocumented internal function.\n\
 DEFUN (java_matrix_autoconversion, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
 automatically converted to Octave matrices.  The default value is false.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
   error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
   return octave_value ();
@@ -2323,19 +2323,19 @@ DEFUN (java_unsigned_autoconversion, arg
 @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
 converted when @code{java_matrix_autoconversion} is enabled.  When enabled,\n\
 Java arrays of class Byte or Integer are converted to matrices of class\n\
 uint8 or uint32 respectively.  The default value is true.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
 #else
   error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
   return octave_value ();
@@ -2346,19 +2346,19 @@ DEFUN (debug_java, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_java ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_java (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether extra debugging\n\
 information regarding the initialization of the JVM and any Java exceptions\n\
 is printed.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (debug_java);
 #else
   error ("debug_java: Octave was not compiled with Java interface");
   return octave_value ();
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -683,19 +683,19 @@ DEFUN (allow_noninteger_range_as_index, 
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
 ranges are allowed as indices.  This might be useful for @sc{matlab}\n\
 compatibility; however, it is still not entirely compatible because\n\
 @sc{matlab} treats the range expression differently in different contexts.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (allow_noninteger_range_as_index);
 }
 
 /*
 %!test
 %! x = 0:10;
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -333,17 +333,17 @@ octave_sparse_matrix::load_binary (std::
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error ("load: only 2D sparse matrices are supported");
+    error ("load: only 2-D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -2280,19 +2280,19 @@ each of the named fields.\n\
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
   "-*- texinfo -*-\n\
@@ -2300,15 +2300,15 @@ DEFUN (print_struct_array_contents, args
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
 array contents.  If true, values of struct array elements are printed.\n\
 This variable does not affect scalar structures.  Their elements\n\
 are always printed.  In both cases, however, printing will be limited to\n\
 the number of levels specified by @var{struct_levels_to_print}.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_struct_array_contents);
 }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -1009,19 +1009,19 @@ DEFUN (optimize_subsasgn_calls, args, na
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 subsasgn method of a user-defined class.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
 
 static bool val_in_table (const Matrix& table, double val)
 {
   if (table.is_empty ())
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <cassert>
 #include <cstdlib>
 #include <cstring>
 #include <ctime>
 
 #include <iostream>
 
+#include <fcntl.h>
 #include <getopt.h>
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "f77-fcn.h"
 #include "file-ops.h"
 #include "file-stat.h"
@@ -121,16 +122,20 @@ static bool inhibit_startup_message = fa
 // If TRUE, print verbose info in some cases.
 // (--verbose; -V)
 static bool verbose_flag = false;
 
 // If TRUE, force the GUI to start.
 // (--force-gui)
 static bool force_gui_option = false;
 
+// If TRUE don't fork when starting the GUI.
+// (--no-fork)
+static bool no_fork_option = false;
+
 // If TRUE don't start the GUI.
 // (--no-gui)
 static bool no_gui_option = false;
 
 // If TRUE, force readline command line editing.
 // (--line-editing)
 static bool forced_line_editing = false;
 
@@ -155,17 +160,17 @@ static std::string image_path;
 static bool no_window_system = false;
 
 // Usage message
 static const char *usage_string =
   "octave [-HVWdfhiqvx] [--debug] [--debug-jit] [--doc-cache-file file]\n\
        [--echo-commands] [--eval CODE] [--exec-path path]\n\
        [--force-gui] [--help] [--image-path path]\n\
        [--info-file file] [--info-program prog] [--interactive]\n\
-       [--line-editing] [--no-gui] [--no-history]\n\
+       [--line-editing] [--no-fork] [--no-gui] [--no-history]\n\
        [--no-init-file] [--no-init-path] [--no-jit-compiler]\n\
        [--no-line-editing] [--no-site-file] [--no-window-system]\n\
        [--norc] [-p path] [--path path] [--persist] [--silent]\n\
        [--traditional] [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
 // the real set of options will agree.  Note: the '+' must come first
 // to prevent getopt from permuting arguments!
@@ -190,41 +195,43 @@ static bool traditional = false;
 #define EVAL_OPTION 3
 #define EXEC_PATH_OPTION 4
 #define FORCE_GUI_OPTION 5
 #define IMAGE_PATH_OPTION 6
 #define INFO_FILE_OPTION 7
 #define INFO_PROG_OPTION 8
 #define DEBUG_JIT_OPTION 9
 #define LINE_EDITING_OPTION 10
-#define NO_GUI_OPTION 11
-#define NO_INIT_FILE_OPTION 12
-#define NO_INIT_PATH_OPTION 13
-#define NO_JIT_COMPILER_OPTION 14
-#define NO_LINE_EDITING_OPTION 15
-#define NO_SITE_FILE_OPTION 16
-#define PERSIST_OPTION 17
-#define TEXI_MACROS_FILE_OPTION 18
-#define TRADITIONAL_OPTION 19
+#define NO_FORK_OPTION 11
+#define NO_GUI_OPTION 12
+#define NO_INIT_FILE_OPTION 13
+#define NO_INIT_PATH_OPTION 14
+#define NO_JIT_COMPILER_OPTION 15
+#define NO_LINE_EDITING_OPTION 16
+#define NO_SITE_FILE_OPTION 17
+#define PERSIST_OPTION 18
+#define TEXI_MACROS_FILE_OPTION 19
+#define TRADITIONAL_OPTION 20
 struct option long_opts[] = {
   { "braindead",                no_argument,       0, TRADITIONAL_OPTION },
   { "built-in-docstrings-file", required_argument, 0, BUILT_IN_DOCSTRINGS_FILE_OPTION },
   { "debug",                    no_argument,       0, 'd' },
   { "debug-jit",                no_argument,       0, DEBUG_JIT_OPTION },
   { "doc-cache-file",           required_argument, 0, DOC_CACHE_FILE_OPTION },
   { "echo-commands",            no_argument,       0, 'x' },
   { "eval",                     required_argument, 0, EVAL_OPTION },
   { "exec-path",                required_argument, 0, EXEC_PATH_OPTION },
   { "force-gui",                no_argument,       0, FORCE_GUI_OPTION },
   { "help",                     no_argument,       0, 'h' },
   { "image-path",               required_argument, 0, IMAGE_PATH_OPTION },
   { "info-file",                required_argument, 0, INFO_FILE_OPTION },
   { "info-program",             required_argument, 0, INFO_PROG_OPTION },
   { "interactive",              no_argument,       0, 'i' },
   { "line-editing",             no_argument,       0, LINE_EDITING_OPTION },
+  { "no-fork",                  no_argument,       0, NO_FORK_OPTION },
   { "no-gui",                   no_argument,       0, NO_GUI_OPTION },
   { "no-history",               no_argument,       0, 'H' },
   { "no-init-file",             no_argument,       0, NO_INIT_FILE_OPTION },
   { "no-init-path",             no_argument,       0, NO_INIT_PATH_OPTION },
   { "no-jit-compiler",          no_argument,       0, NO_JIT_COMPILER_OPTION },
   { "no-line-editing",          no_argument,       0, NO_LINE_EDITING_OPTION },
   { "no-site-file",             no_argument,       0, NO_SITE_FILE_OPTION },
   { "no-window-system",         no_argument,       0, 'W' },
@@ -512,17 +519,18 @@ execute_command_line_file (const std::st
   safe_source_file (fname, context, verbose, require_file, "octave");
 }
 
 // Usage message with extra help.
 
 static void
 verbose_usage (void)
 {
-  std::cout << OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY "\n\
+  std::cout << octave_name_version_copyright_copying_and_warranty ()
+            << "\n\
 \n\
 Usage: octave [options] [FILE]\n\
 \n\
 Options:\n\
 \n\
   --built-in-docstrings-file FILE Use docs for built-ins from FILE.\n\
   --debug, -d             Enter parser debugging mode.\n\
   --debug-jit             Enable JIT compiler debugging/tracing.\n\
@@ -532,16 +540,17 @@ Options:\n\
   --exec-path PATH        Set path for executing subprograms.\n\
   --force-gui             Force graphical user interface to start.\n\
   --help, -h,             Print short help message and exit.\n\
   --image-path PATH       Add PATH to head of image search path.\n\
   --info-file FILE        Use top-level info file FILE.\n\
   --info-program PROGRAM  Use PROGRAM for reading info files.\n\
   --interactive, -i       Force interactive behavior.\n\
   --line-editing          Force readline use for command-line editing.\n\
+  --no-fork               Don't fork when starting the graphical user interface.\n\
   --no-gui                Disable the graphical user interface.\n\
   --no-history, -H        Don't save commands to the history list\n\
   --no-init-file          Don't read the ~/.octaverc or .octaverc files.\n\
   --no-init-path          Don't initialize function search path.\n\
   --no-jit-compiler       Disable the JIT compiler.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
   --no-window-system, -W  Disable window system, including graphics.\n\
@@ -552,38 +561,40 @@ Options:\n\
   --texi-macros-file FILE Use Texinfo macros in FILE for makeinfo command.\n\
   --traditional           Set variables for closer MATLAB compatibility.\n\
   --verbose, -V           Enable verbose output in some cases.\n\
   --version, -v           Print version number and exit.\n\
 \n\
   FILE                    Execute commands from FILE.  Exit when done\n\
                           unless --persist is also specified.\n\
 \n"
-OCTAVE_WWW_STATEMENT "\n\
-\n"
-OCTAVE_CONTRIB_STATEMENT "\n\
-\n"
-OCTAVE_BUGS_STATEMENT "\n";
+            << octave_www_statement ()
+            << "\n\n"
+            << octave_contrib_statement ()
+            << "\n\n"
+            << octave_bugs_statement ()
+            << "\n";
 
   exit (0);
 }
 
 // Terse usage messsage.
 
 static void
 usage (void)
 {
   std::cerr << "\nusage: " << usage_string << "\n\n";
   exit (1);
 }
 
 static void
 print_version_and_exit (void)
 {
-  std::cout << OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS "\n";
+  std::cout << octave_name_version_copyright_copying_warranty_and_bugs ()
+            << "\n";
   exit (0);
 }
 
 static void
 lo_error_handler (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
@@ -780,16 +791,20 @@ octave_process_command_line (int argc, c
         case DEBUG_JIT_OPTION:
           Fdebug_jit (octave_value (true));
           break;
 
         case LINE_EDITING_OPTION:
           forced_line_editing = true;
           break;
 
+        case NO_FORK_OPTION:
+          no_fork_option = true;
+          break;
+
         case NO_GUI_OPTION:
           no_gui_option = true;
           break;
 
         case NO_INIT_FILE_OPTION:
           read_init_files = false;
           break;
 
@@ -939,17 +954,17 @@ octave_initialize_interpreter (int argc,
 
   initialize_history (read_history_file);
 }
 
 int
 octave_execute_interpreter (void)
 {
   if (! inhibit_startup_message)
-    std::cout << OCTAVE_STARTUP_MESSAGE "\n" << std::endl;
+    std::cout << octave_startup_message () << "\n" << std::endl;
 
   execute_startup_files ();
 
   if (! inhibit_startup_message && reading_startup_message_printed)
     std::cout << std::endl;
 
   // If there is an extra argument, see if it names a file to read.
   // Additional arguments are taken as command line options for the
@@ -1066,16 +1081,36 @@ check_starting_gui (void)
 
 int
 octave_starting_gui (void)
 {
   start_gui = check_starting_gui ();
   return start_gui;
 }
 
+int
+octave_fork_gui (void)
+{
+  bool have_ctty = false;
+
+#if ! (defined (__WIN32__) || defined (__APPLE__)) || defined (__CYGWIN__)
+
+#if defined (HAVE_CTERMID)
+  const char *ctty = ctermid (0);
+#else
+  const char *ctty = "/dev/tty";
+#endif
+
+  have_ctty = gnulib::open (ctty, O_RDWR, 0) > 0;
+
+#endif
+
+  return (have_ctty && ! no_fork_option);
+}
+
 DEFUN (isguirunning, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isguirunning ()\n\
 Return true if Octave is running in GUI mode and false otherwise.\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -36,14 +36,15 @@ octave_initialize_interpreter (int argc,
 
 extern OCTINTERP_API int octave_execute_interpreter (void);
 
 extern OCTINTERP_API int octave_cmdline_argc;
 extern OCTINTERP_API char **octave_cmdline_argv;
 extern OCTINTERP_API int octave_embedded;
 
 extern OCTINTERP_API int octave_starting_gui (void);
+extern OCTINTERP_API int octave_fork_gui (void);
 
 #ifdef  __cplusplus
 }
 #endif
 
 #endif
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -277,16 +277,17 @@ public:
       quote_is_transpose (false), force_script (false),
       reading_fcn_file (false), reading_script_file (false),
       reading_classdef_file (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
       block_comment_nesting_level (0), token_count (0),
       current_input_line (), comment_text (), help_text (),
+      string_text (), string_line (0), string_column (0),
       fcn_file_name (), fcn_file_full_name (), looking_at_object_index (),
       parsed_function_name (), pending_local_variables (),
       symtab_context (), nesting_level (), tokens ()
   {
     init ();
   }
 
   ~lexical_feedback (void);
@@ -414,16 +415,23 @@ public:
   std::string current_input_line;
 
   // The current comment text.
   std::string comment_text;
 
   // The current help text.
   std::string help_text;
 
+  // The current character string text.
+  std::string string_text;
+
+  // The position of the beginning of the current character string.
+  int string_line;
+  int string_column;
+
   // Simple name of function file we are reading.
   std::string fcn_file_name;
 
   // Full name of file we are reading.
   std::string fcn_file_full_name;
 
   // if the front of the list is true, the closest paren, brace, or
   // bracket nesting is an index for an object.
@@ -504,16 +512,18 @@ public:
   void init (void);
 
   virtual bool is_push_lexer (void) const { return false; }
 
   virtual void reset (void);
 
   void prep_for_file (void);
 
+  void begin_string (int state);
+
   virtual int fill_flex_buffer (char *buf, unsigned int max_size) = 0;
 
   bool at_end_of_buffer (void) const { return input_buf.empty (); }
 
   bool at_end_of_file (void) const { return input_buf.at_eof (); }
 
   int handle_end_of_input (void);
 
@@ -538,22 +548,16 @@ public:
   bool whitespace_is_significant (void);
 
   void handle_number (void);
 
   void handle_continuation (void);
 
   void finish_comment (octave_comment_elt::comment_type typ);
 
-  bool have_continuation (bool trailing_comments_ok = true);
-
-  bool have_ellipsis_continuation (bool trailing_comments_ok = true);
-
-  int handle_string (char delim);
-
   int handle_close_bracket (int bracket_type);
 
   bool looks_like_command_arg (void);
 
   int handle_superclass_identifier (void);
 
   int handle_meta_identifier (void);
 
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -46,16 +46,19 @@ object) relevant global values before an
 %s COMMAND_START
 %s MATRIX_START
 
 %x INPUT_FILE_START
 
 %x BLOCK_COMMENT_START
 %x LINE_COMMENT_START
 
+%x DQ_STRING_START
+%x SQ_STRING_START
+
 %{
 
 #include <cctype>
 #include <cstring>
 
 #include <iostream>
 #include <set>
 #include <sstream>
@@ -200,16 +203,41 @@ object) relevant global values before an
           else \
             { \
               return tok; \
             } \
         } \
     } \
   while (0)
 
+// We can't rely on the trick used elsewhere of sticking ASCII 1 in
+// the input buffer and recognizing it as a special case because ASCII
+// 1 is a valid character for a character string.  If we are at the
+// end of the buffer, ask for more input.  If we are at the end of the
+// file, deal with it.  Otherwise, just keep going with the text from
+// the current buffer.
+#define HANDLE_STRING_CONTINUATION \
+  do \
+    { \
+      curr_lexer->decrement_promptflag (); \
+      curr_lexer->input_line_number++; \
+      curr_lexer->current_input_column = 1; \
+ \
+      if (curr_lexer->is_push_lexer ()) \
+        { \
+          if (curr_lexer->at_end_of_buffer ()) \
+            return -1; \
+ \
+          if (curr_lexer->at_end_of_file ()) \
+            return curr_lexer->handle_end_of_input (); \
+        } \
+    } \
+  while (0)
+
+
 static bool Vdisplay_tokens = false;
 
 static unsigned int Vtoken_count = 0;
 
 // Internal variable for lexer debugging state.
 static bool lexer_debug_flag = false;
 
 // Forward declarations for functions defined at the bottom of this
@@ -217,17 +245,16 @@ static bool lexer_debug_flag = false;
 
 static std::string strip_trailing_whitespace (char *s);
 
 %}
 
 D       [0-9]
 S       [ \t]
 NL      ((\n)|(\r)|(\r\n))
-CONT    ((\.\.\.)|(\\))
 Im      [iIjJ]
 CCHAR   [#%]
 IDENT   ([_$a-zA-Z][_$a-zA-Z0-9]*)
 EXPON   ([DdEe][+-]?{D}+)
 NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 
 ANY_INCLUDING_NL (.|{NL})
 
@@ -285,19 +312,19 @@ ANY_INCLUDING_NL (.|{NL})
   }
 
 <COMMAND_START>[\"\'] {
     curr_lexer->lexer_debug ("<COMMAND_START>[\\\"\\']");
 
     curr_lexer->at_beginning_of_statement = false;
 
     curr_lexer->current_input_column++;
-    int tok = curr_lexer->handle_string (yytext[0]);
-
-    return curr_lexer->count_token_internal (tok);
+
+    curr_lexer->begin_string (yytext[0] == '"'
+                              ? DQ_STRING_START : SQ_STRING_START);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     curr_lexer->lexer_debug ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
 
     curr_lexer->looking_for_object_index = false;
@@ -444,17 +471,17 @@ ANY_INCLUDING_NL (.|{NL})
 
 %{
 // Start of a block comment.  If the comment marker appears immediately
 // after a block of full-line comments, finish the full line comment
 // block.
 %}
 
 ^{S}*{CCHAR}\{{S}*{NL} {
-    curr_lexer->lexer_debug ("^{S}*{CCHAR}\{{S}*{NL}");
+    curr_lexer->lexer_debug ("^{S}*{CCHAR}\\{{S}*{NL}");
 
     yyless (0);
 
     if (curr_lexer->start_state () == LINE_COMMENT_START)
       {
         if (! curr_lexer->comment_text.empty ())
           curr_lexer->finish_comment (octave_comment_elt::full_line);
 
@@ -463,17 +490,17 @@ ANY_INCLUDING_NL (.|{NL})
 
     curr_lexer->decrement_promptflag ();
 
     curr_lexer->push_start_state (BLOCK_COMMENT_START);
 
   }
 
 <BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL} {
-    curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\{{S}*{NL}");
+    curr_lexer->lexer_debug ("<BLOCK_COMMENT_START>^{S}*{CCHAR}\\{{S}*{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     if (curr_lexer->block_comment_nesting_level)
       curr_lexer->comment_text = "\n";
 
     curr_lexer->block_comment_nesting_level++;
@@ -617,16 +644,248 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->xunput (yytext[0]);
 
     curr_lexer->finish_comment (octave_comment_elt::full_line);  
 
     curr_lexer->pop_start_state ();
   }
 
 %{
+// Double-quoted character strings.
+%}
+
+<DQ_STRING_START>\"\" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\"\\\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '"';
+  }
+
+<DQ_STRING_START>\" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\"");
+
+    curr_lexer->current_input_column++;
+
+    curr_lexer->pop_start_state ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->push_token (new token (DQ_STRING,
+                                       curr_lexer->string_text,
+                                       curr_lexer->string_line,
+                                       curr_lexer->string_column));
+
+    curr_lexer->string_text = "";
+
+    return curr_lexer->count_token_internal (DQ_STRING);
+  }
+
+<DQ_STRING_START>\\[0-7]{1,3} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\[0-7]{1,3}");
+
+    curr_lexer->current_input_column += yyleng;
+
+    int result;
+    sscanf (yytext+1, "%o", &result);
+
+    if (result > 0xff)
+      error ("invalid octal escape sequence in character string");
+    else
+      curr_lexer->string_text += static_cast<unsigned char> (result);
+  }
+
+<DQ_STRING_START>\\x[0-9a-fA-F]+ {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\x[0-9a-fA-F]+");
+
+    curr_lexer->current_input_column += yyleng;
+
+    int result;
+    sscanf (yytext+2, "%x", &result);
+
+    // Truncate the value silently instead of checking the range like
+    // we do for octal above.  This is to match C/C++ where any number
+    // of digits is allowed but the value is implementation-defined if
+    // it exceeds the range of the character type.
+    curr_lexer->string_text += static_cast<unsigned char> (result);
+  }
+
+<DQ_STRING_START>"\\a" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\a\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\a';
+  }
+
+<DQ_STRING_START>"\\b" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\b\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\b';
+  }
+
+<DQ_STRING_START>"\\f" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\f\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\f';
+  }
+
+<DQ_STRING_START>"\\n" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\n\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\n';
+  }
+
+<DQ_STRING_START>"\\r" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\r\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\r';
+  }
+
+<DQ_STRING_START>"\\t" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\t\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\t';
+  }
+
+<DQ_STRING_START>"\\v" {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\v\"");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\v';
+  }
+
+<DQ_STRING_START>(\.\.\.){S}*{NL} |
+<DQ_STRING_START>(\.\.\.){S}*{CCHAR}.*{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>(\\.\\.\\.){S}*{NL}|<DQ_STRING_START>(\\.\\.\\.){S}*{CCHAR}.*{NL}");
+
+    static const char *msg = "'...' continuations in double-quoted character strings are obsolete and will not be allowed in a future version of Octave; please use '\\' instead";
+
+    std::string nm = curr_lexer->fcn_file_full_name;
+
+    if (nm.empty ())
+      warning_with_id ("Octave:deprecated-syntax", "%s", msg);
+    else
+      warning_with_id ("Octave:deprecated-syntax",
+                       "%s; near line %d of file '%s'", msg,
+                       curr_lexer->input_line_number, nm.c_str ());
+
+    HANDLE_STRING_CONTINUATION;
+  }
+
+<DQ_STRING_START>\\{S}+{NL} |
+<DQ_STRING_START>\\{S}*{CCHAR}.*{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{S}+{NL}|<DQ_STRING_START>\\\\{S}*{CCHAR}.*{NL}");
+
+    static const char *msg = "white space and comments after continuation markers in double-quoted character strings are obsolete and will not be allowed in a future version of Octave";
+
+    std::string nm = curr_lexer->fcn_file_full_name;
+
+    if (nm.empty ())
+      warning_with_id ("Octave:deprecated-syntax", "%s", msg);
+    else
+      warning_with_id ("Octave:deprecated-syntax",
+                       "%s; near line %d of file '%s'", msg,
+                       curr_lexer->input_line_number, nm.c_str ());
+
+    HANDLE_STRING_CONTINUATION;
+  }
+
+<DQ_STRING_START>\\{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{NL}");
+
+    HANDLE_STRING_CONTINUATION;
+  }
+
+<DQ_STRING_START>\\. {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\.");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += yytext[1];
+  }
+
+<DQ_STRING_START>\. {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\.");
+
+    curr_lexer->current_input_column++;
+    curr_lexer->string_text += yytext[0];
+  }
+
+<DQ_STRING_START>[^\.\\\r\n\"]+ {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>[^\\.\\\\\\r\\n\\\"]+");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += yytext;
+  }
+
+<DQ_STRING_START>{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>{NL}");
+
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    error ("unterminated character string constant");
+
+    return LEXICAL_ERROR;
+  }
+
+%{
+// Single-quoted character strings.
+%}
+
+<SQ_STRING_START>\'\' {
+    curr_lexer->lexer_debug ("<SQ_STRING_START>\\'\\'");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += '\'';
+  }
+
+<SQ_STRING_START>\' {
+    curr_lexer->lexer_debug ("<SQ_STRING_START>\\'");
+
+    curr_lexer->current_input_column++;
+
+    curr_lexer->pop_start_state ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->push_token (new token (SQ_STRING,
+                                       curr_lexer->string_text,
+                                       curr_lexer->string_line,
+                                       curr_lexer->string_column));
+
+    curr_lexer->string_text = "";
+
+    return curr_lexer->count_token_internal (SQ_STRING);
+  }
+
+<SQ_STRING_START>[^\'\n\r]+ {
+    curr_lexer->lexer_debug ("<SQ_STRING_START>[^\\'\\n\\r]+");
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->string_text += yytext;
+  }
+
+<SQ_STRING_START>{NL} {
+    curr_lexer->lexer_debug ("<SQ_STRING_START>{NL}");
+
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    error ("unterminated character string constant");
+
+    return LEXICAL_ERROR;
+  }
+
+%{
 // Imaginary numbers.
 %}
 
 {NUMBER}{Im} {
     curr_lexer->lexer_debug ("{NUMBER}{Im}");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
@@ -656,17 +915,17 @@ ANY_INCLUDING_NL (.|{NL})
 
 %{
 // Real numbers.  Don't grab the '.' part of a dot operator as part of
 // the constant.
 %}
 
 {D}+/\.[\*/\\^\'] |
 {NUMBER} {
-    curr_lexer->lexer_debug ("{D}+/\\.[\\*/\\^\\']|{NUMBER}");
+    curr_lexer->lexer_debug ("{D}+/\\.[\\*/\\\\^\\']|{NUMBER}");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
         yyless (0);
         curr_lexer->push_start_state (COMMAND_START);
       }
     else
@@ -696,22 +955,43 @@ ANY_INCLUDING_NL (.|{NL})
 
 {S}+ {
     curr_lexer->current_input_column += yyleng;
 
     curr_lexer->mark_previous_token_trailing_space ();
   }
 
 %{
-// Continuation lines.  Allow comments after continuations.
+// Continuation lines.  Allow arbitrary text after continuations.
+%}
+
+\.\.\..*{NL} {
+    curr_lexer->lexer_debug ("\\.\\.\\..*{NL}");
+
+    curr_lexer->handle_continuation ();
+  }
+
+%{
+// Deprecated C preprocessor style continuation markers.
 %}
 
-{CONT}{S}*{NL} |
-{CONT}{S}*{CCHAR}.*{NL} {
-    curr_lexer->lexer_debug ("{CONT}{S}*{NL}|{CONT}{S}*{CCHAR}.*{NL}");
+\\{S}*{NL} |
+\\{S}*{CCHAR}.*{NL} {
+    curr_lexer->lexer_debug ("\\\\{S}*{NL}|\\\\{S}*{CCHAR}.*{NL}");
+
+    static const char *msg = "using continuation marker \\ outside of double quoted strings is deprecated and will be removed in a future version of Octave";
+
+    std::string nm = curr_lexer->fcn_file_full_name;
+
+    if (nm.empty ())
+      warning_with_id ("Octave:deprecated-syntax", "%s", msg);
+    else
+      warning_with_id ("Octave:deprecated-syntax",
+                       "%s; near line %d of file '%s'", msg,
+                       curr_lexer->input_line_number, nm.c_str ());
 
     curr_lexer->handle_continuation ();
   }
 
 %{
 // End of file.
 %}
 
@@ -862,126 +1142,121 @@ ANY_INCLUDING_NL (.|{NL})
 %}
 
 "'" {
     curr_lexer->lexer_debug ("'");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
-        yyless (0);
+        curr_lexer->current_input_column++;
         curr_lexer->push_start_state (COMMAND_START);
+        curr_lexer->begin_string (SQ_STRING_START);
       }
     else if (curr_lexer->at_beginning_of_statement)
       {
         curr_lexer->current_input_column++;
-        int retval = curr_lexer->handle_string ('\'');
-        return curr_lexer->count_token_internal (retval);
+        curr_lexer->begin_string (SQ_STRING_START);
       }
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (curr_lexer->whitespace_is_significant ())
           {
             if (curr_lexer->space_follows_previous_token ())
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ())
                   {
                     curr_lexer->current_input_column++;
-                    int retval = curr_lexer->handle_string ('\'');
-                    return curr_lexer->count_token_internal (retval);
+                    curr_lexer->begin_string (SQ_STRING_START);
                   }
                 else
                   {
                     yyless (0);
                     curr_lexer->xunput (',');
                     // Adjust for comma that was not really in the input stream.
                     curr_lexer->current_input_column--;
                   }
               }
             else
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ()
                     || curr_lexer->previous_token_is_keyword ())
                   {
                     curr_lexer->current_input_column++;
-                    int retval = curr_lexer->handle_string ('\'');
-                    return curr_lexer->count_token_internal (retval);
+                    curr_lexer->begin_string (SQ_STRING_START);
                   }
                 else
                   return curr_lexer->count_token (HERMITIAN);
               }
           }
         else
           {
             if (! tok || tok == '[' || tok == '{' || tok == '('
                 || curr_lexer->previous_token_is_binop ()
                 || curr_lexer->previous_token_is_keyword ())
               {
                 curr_lexer->current_input_column++;
-                int retval = curr_lexer->handle_string ('\'');
-                return curr_lexer->count_token_internal (retval);
+                curr_lexer->begin_string (SQ_STRING_START);
               }
             else
               return curr_lexer->count_token (HERMITIAN);
           }
       }
   }
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
-    curr_lexer->lexer_debug ("\"");
+    curr_lexer->lexer_debug ("\\\"");
 
     if (curr_lexer->previous_token_may_be_command ()
         &&  curr_lexer->space_follows_previous_token ())
       {
-        yyless (0);
+        curr_lexer->current_input_column++;
         curr_lexer->push_start_state (COMMAND_START);
+        curr_lexer->begin_string (DQ_STRING_START);
       }
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (curr_lexer->whitespace_is_significant ())
           {
             if (curr_lexer->space_follows_previous_token ())
               {
                 if (tok == '[' || tok == '{'
                     || curr_lexer->previous_token_is_binop ())
                   {
                     curr_lexer->current_input_column++;
-                    int retval = curr_lexer->handle_string ('"');
-                    return curr_lexer->count_token_internal (retval);
+                    curr_lexer->begin_string (DQ_STRING_START);
                   }
                 else
                   {
                     yyless (0);
                     curr_lexer->xunput (',');
                     // Adjust for comma that was not really in the input stream.
                     curr_lexer->current_input_column--;
                   }
               }
             else
               {
                 curr_lexer->current_input_column++;
-                int retval = curr_lexer->handle_string ('"');
-                return curr_lexer->count_token_internal (retval);
+                curr_lexer->begin_string (DQ_STRING_START);
               }
           }
         else
           {
             curr_lexer->current_input_column++;
-            int retval = curr_lexer->handle_string ('"');
-            return curr_lexer->count_token_internal (retval);
+            curr_lexer->begin_string (DQ_STRING_START);
           }
       }
   }
 
 %{
 // Other operators.
 %}
 
@@ -1552,16 +1827,19 @@ lexical_feedback::reset (void)
   looping = 0;
   defining_func = 0;
   looking_at_function_handle = 0;
   block_comment_nesting_level = 0;
   token_count = 0;
   current_input_line = "";
   comment_text = "";
   help_text = "";
+  string_text = "";
+  string_line = 0;
+  string_column = 0;
   fcn_file_name = "";
   fcn_file_full_name = "";
   looking_at_object_index.clear ();
   looking_at_object_index.push_front (false);
 
   while (! parsed_function_name.empty ())
     parsed_function_name.pop ();
 
@@ -1766,16 +2044,25 @@ octave_base_lexer::reset (void)
 void
 octave_base_lexer::prep_for_file (void)
 {
   reading_script_file = true;
 
   push_start_state (INPUT_FILE_START);
 }
 
+void
+octave_base_lexer::begin_string (int state)
+{
+  string_line = input_line_number;
+  string_column = current_input_column;
+
+  push_start_state (state);
+}
+
 int
 octave_base_lexer::handle_end_of_input (void)
 {
   lexer_debug ("<<EOF>>");
 
   if (block_comment_nesting_level != 0)
     {
       warning ("block comment open at end of input");
@@ -2254,228 +2541,16 @@ octave_base_lexer::finish_comment (octav
 
   octave_comment_buffer::append (comment_text, typ);
 
   comment_text = "";
 
   at_beginning_of_statement = true;
 }
 
-// We have seen a backslash and need to find out if it should be
-// treated as a continuation character.  If so, this eats it, up to
-// and including the new line character.
-//
-// Match whitespace only, followed by a comment character or newline.
-// Once a comment character is found, discard all input until newline.
-// If non-whitespace characters are found before comment
-// characters, return 0.  Otherwise, return 1.
-
-// FIXME -- we need to handle block comments here.
-
-bool
-octave_base_lexer::have_continuation (bool trailing_comments_ok)
-{
-  std::ostringstream buf;
-
-  std::string comment_buf;
-
-  bool in_comment = false;
-  bool beginning_of_comment = false;
-
-  int c = 0;
-
-  while ((c = text_yyinput ()) != EOF)
-    {
-      buf << static_cast<char> (c);
-
-      switch (c)
-        {
-        case ' ':
-        case '\t':
-          if (in_comment)
-            {
-              comment_buf += static_cast<char> (c);
-              beginning_of_comment = false;
-            }
-          break;
-
-        case '%':
-        case '#':
-          if (trailing_comments_ok)
-            {
-              if (in_comment)
-                {
-                  if (! beginning_of_comment)
-                    comment_buf += static_cast<char> (c);
-                }
-              else
-                {
-                  maybe_gripe_matlab_incompatible_comment (c);
-                  in_comment = true;
-                  beginning_of_comment = true;
-                }
-            }
-          else
-            goto cleanup;
-          break;
-
-        case '\n':
-          if (in_comment)
-            {
-              comment_buf += static_cast<char> (c);
-              octave_comment_buffer::append (comment_buf);
-            }
-          current_input_column = 0;
-          decrement_promptflag ();
-          gripe_matlab_incompatible_continuation ();
-          return true;
-
-        default:
-          if (in_comment)
-            {
-              comment_buf += static_cast<char> (c);
-              beginning_of_comment = false;
-            }
-          else
-            goto cleanup;
-          break;
-        }
-    }
-
-  xunput (c);
-  return false;
-
-cleanup:
-
-  std::string s = buf.str ();
-
-  int len = s.length ();
-  while (len--)
-    xunput (s[len]);
-
-  return false;
-}
-
-// We have seen a '.' and need to see if it is the start of a
-// continuation.  If so, this eats it, up to and including the new
-// line character.
-
-bool
-octave_base_lexer::have_ellipsis_continuation (bool trailing_comments_ok)
-{
-  char c1 = text_yyinput ();
-  if (c1 == '.')
-    {
-      char c2 = text_yyinput ();
-      if (c2 == '.' && have_continuation (trailing_comments_ok))
-        return true;
-      else
-        {
-          xunput (c2);
-          xunput (c1);
-        }
-    }
-  else
-    xunput (c1);
-
-  return false;
-}
-
-int
-octave_base_lexer::handle_string (char delim)
-{
-  std::ostringstream buf;
-
-  int bos_line = input_line_number;
-  int bos_col = current_input_column;
-
-  int c;
-  int escape_pending = 0;
-
-  while ((c = text_yyinput ()) != EOF)
-    {
-      current_input_column++;
-
-      if (c == '\\')
-        {
-          if (delim == '\'' || escape_pending)
-            {
-              buf << static_cast<char> (c);
-              escape_pending = 0;
-            }
-          else
-            {
-              if (have_continuation (false))
-                escape_pending = 0;
-              else
-                {
-                  buf << static_cast<char> (c);
-                  escape_pending = 1;
-                }
-            }
-          continue;
-        }
-      else if (c == '.')
-        {
-          if (delim == '\'' || ! have_ellipsis_continuation (false))
-            buf << static_cast<char> (c);
-        }
-      else if (c == '\n')
-        {
-          error ("unterminated string constant");
-          break;
-        }
-      else if (c == delim)
-        {
-          if (escape_pending)
-            buf << static_cast<char> (c);
-          else
-            {
-              c = text_yyinput ();
-              if (c == delim)
-                {
-                  buf << static_cast<char> (c);
-                }
-              else
-                {
-                  std::string s;
-                  xunput (c);
-
-                  if (delim == '\'')
-                    s = buf.str ();
-                  else
-                    s = do_string_escapes (buf.str ());
-
-                  if (delim == '"')
-                    gripe_matlab_incompatible ("\" used as string delimiter");
-                  else if (delim == '\'')
-                    gripe_single_quote_string ();
-
-                  looking_for_object_index = true;
-                  at_beginning_of_statement = false;
-
-                  int tok = delim == '"' ? DQ_STRING : SQ_STRING;
-
-                  push_token (new token (tok, s, bos_line, bos_col));
-
-                  return tok;
-                }
-            }
-        }
-      else
-        {
-          buf << static_cast<char> (c);
-        }
-
-      escape_pending = 0;
-    }
-
-  return LEXICAL_ERROR;
-}
-
 int
 octave_base_lexer::handle_close_bracket (int bracket_type)
 {
   int retval = bracket_type;
 
   if (! nesting_level.none ())
     {
       nesting_level.remove ();
@@ -2633,21 +2708,17 @@ octave_base_lexer::handle_identifier (vo
           looking_for_object_index = false;
         }
 
       // The call to is_keyword_token set at_beginning_of_statement.
 
       return kw_token;
     }
 
-  // Find the token in the symbol table.  Beware the magic
-  // transformation of the end keyword...
-
-  if (tok == "end")
-    tok = "__end__";
+  // Find the token in the symbol table.
 
   symbol_table::scope_id sid = symtab_context.curr_scope ();
 
   token *tok_val = new token (NAME, &(symbol_table::insert (tok, sid)),
                               input_line_number, current_input_column);
 
   // The following symbols are handled specially so that things like
   //
@@ -2664,17 +2735,19 @@ octave_base_lexer::handle_identifier (vo
              || tok == "Inf" || tok == "inf"
              || tok == "NaN" || tok == "nan")))
     tok_val->mark_may_be_command ();
 
   push_token (tok_val);
 
   current_input_column += flex_yyleng ();
 
-  if (tok != "__end__")
+  // The magic end index can't be indexed.
+
+  if (tok != "end")
     looking_for_object_index = true;
 
   at_beginning_of_statement = false;
 
   return NAME;
 }
 
 void
@@ -2975,16 +3048,24 @@ octave_base_lexer::display_start_state (
     case BLOCK_COMMENT_START:
       std::cerr << "BLOCK_COMMENT_START" << std::endl;
       break;
 
     case LINE_COMMENT_START:
       std::cerr << "LINE_COMMENT_START" << std::endl;
       break;
 
+    case DQ_STRING_START:
+      std::cerr << "DQ_STRING_START" << std::endl;
+      break;
+
+    case SQ_STRING_START:
+      std::cerr << "SQ_STRING_START" << std::endl;
+      break;
+
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
 
 int
 octave_base_lexer::handle_op (const char *pattern, int tok, bool bos)
diff --git a/libinterp/parse-tree/module.mk b/libinterp/parse-tree/module.mk
--- a/libinterp/parse-tree/module.mk
+++ b/libinterp/parse-tree/module.mk
@@ -1,10 +1,11 @@
 EXTRA_DIST += \
   parse-tree/module.mk \
+  parse-tree/oct-parse.in.yy \
   parse-tree/octave.gperf
 
 PARSER_INC = \
   parse-tree/lex.h \
   parse-tree/parse.h
 
 PARSER_SRC = \
   parse-tree/lex.ll \
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -252,18 +252,18 @@ make_statement (T *arg)
 // Nonterminals we construct.
 %type <comment_type> stash_comment
 %type <tok_type> function_beg classdef_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl nl opt_nl sep opt_sep
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
-%type <tree_matrix_type> matrix_rows matrix_rows1
-%type <tree_cell_type> cell_rows cell_rows1
+%type <tree_matrix_type> matrix_rows
+%type <tree_cell_type> cell_rows
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr oper_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name magic_tilde
 %type <tree_funcall_type> superclass_identifier meta_identifier
 %type <octave_user_function_type> function1 function2
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
@@ -277,23 +277,22 @@ make_statement (T *arg)
 %type <tree_classdef_type> classdef
 %type <tree_command_type> file
 %type <tree_if_command_type> if_command
 %type <tree_if_clause_type> elseif_clause else_clause
 %type <tree_if_command_list_type> if_cmd_list1 if_cmd_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
-%type <tree_decl_elt_type> decl2
+%type <tree_decl_elt_type> decl2 param_list_elt
 %type <tree_decl_init_list_type> decl1
 %type <tree_decl_command_type> declaration
 %type <tree_statement_type> statement function_end
 %type <tree_statement_list_type> simple_list simple_list1 list list1
-%type <tree_statement_list_type> opt_list input1
-
+%type <tree_statement_list_type> opt_list
 %type <tree_classdef_attribute_type> attr
 %type <tree_classdef_attribute_list_type> attr_list opt_attr_list
 %type <tree_classdef_superclass_type> superclass
 %type <tree_classdef_superclass_list_type> superclass_list opt_superclass_list
 %type <tree_classdef_body_type> class_body
 %type <tree_classdef_property_type> class_property
 %type <tree_classdef_property_list_type> property_list
 %type <tree_classdef_properties_block_type> properties_block
@@ -326,43 +325,34 @@ make_statement (T *arg)
 %start input
 
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
-input           : input1
+input           : simple_list '\n'
                   {
                     parser.stmt_list = $1;
                     YYACCEPT;
                   }
-                | simple_list parse_error
-                  { ABORT_PARSE; }
+                | simple_list END_OF_INPUT
+                  {
+                    lexer.end_of_input = true;
+                    parser.stmt_list = $1;
+                    YYACCEPT;
+                  }
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
-input1          : '\n'
+simple_list     : opt_sep_no_nl
                   { $$ = 0; }
-                | END_OF_INPUT
-                  {
-                    lexer.end_of_input = true;
-                    $$ = 0;
-                  }
-                | simple_list
-                  { $$ = $1; }
-                | simple_list '\n'
-                  { $$ = $1; }
-                | simple_list END_OF_INPUT
-                  { $$ = $1; }
-                ;
-
-simple_list     : simple_list1 opt_sep_no_nl
+                | simple_list1 opt_sep_no_nl
                   { $$ = parser.set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
                   { $$ = parser.make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
                   { $$ = parser.append_statement_list ($1, $2, $3, false); }
                 ;
@@ -460,69 +450,72 @@ string          : DQ_STRING
 constant        : NUM
                   { $$ = parser.make_constant (NUM, $1); }
                 | IMAG_NUM
                   { $$ = parser.make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
-matrix          : '[' ']'
-                  { $$ = new tree_constant (octave_null_matrix::instance); }
-                | '[' ';' ']'
-                  { $$ = new tree_constant (octave_null_matrix::instance); }
-                | '[' ',' ']'
-                  { $$ = new tree_constant (octave_null_matrix::instance); }
-                | '[' matrix_rows ']'
+matrix          : '[' matrix_rows ']'
                   { $$ = parser.finish_matrix ($2); }
                 ;
 
-matrix_rows     : matrix_rows1
-                  { $$ = $1; }
-                | matrix_rows1 ';'      // Ignore trailing semicolon.
-                  { $$ = $1; }
-                ;
-
-matrix_rows1    : cell_or_matrix_row
-                  { $$ = new tree_matrix ($1); }
-                | matrix_rows1 ';' cell_or_matrix_row
+matrix_rows     : cell_or_matrix_row
+                  { $$ = $1 ? new tree_matrix ($1) : 0; }
+                | matrix_rows ';' cell_or_matrix_row
                   {
-                    $1->append ($3);
-                    $$ = $1;
+                    if ($1)
+                      {
+                        if ($3)
+                          $1->append ($3);
+
+                        $$ = $1;
+                      }
+                    else
+                      $$ = $3 ? new tree_matrix ($3) : 0;
                   }
                 ;
 
-cell            : '{' '}'
-                  { $$ = new tree_constant (octave_value (Cell ())); }
-                | '{' ';' '}'
-                  { $$ = new tree_constant (octave_value (Cell ())); }
-                | '{' cell_rows '}'
+cell            : '{' cell_rows '}'
                   { $$ = parser.finish_cell ($2); }
                 ;
 
-cell_rows       : cell_rows1
-                  { $$ = $1; }
-                | cell_rows1 ';'        // Ignore trailing semicolon.
-                  { $$ = $1; }
-                ;
-
-cell_rows1      : cell_or_matrix_row
-                  { $$ = new tree_cell ($1); }
-                | cell_rows1 ';' cell_or_matrix_row
+cell_rows       : cell_or_matrix_row
+                  { $$ = $1 ? new tree_cell ($1) : 0; }
+                | cell_rows ';' cell_or_matrix_row
                   {
-                    $1->append ($3);
-                    $$ = $1;
+                    if ($1)
+                      {
+                        if ($3)
+                          $1->append ($3);
+
+                        $$ = $1;
+                      }
+                    else
+                      $$ = $3 ? new tree_cell ($3) : 0;
                   }
                 ;
 
+// tree_argument_list objects can't be empty or have leading or trailing
+// commas, but those are all allowed in matrix and cell array rows.
+
 cell_or_matrix_row
-                : arg_list
+                : // empty
+                  { $$ = 0; }
+                | ','
+                  { $$ = 0; }
+                | arg_list
                   { $$ = $1; }
-                | arg_list ','          // Ignore trailing comma.
+                | arg_list ','
                   { $$ = $1; }
+                | ',' arg_list
+                  { $$ = $2; }
+                | ',' arg_list ','
+                  { $$ = $2; }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = parser.make_fcn_handle ($2);
                     lexer.looking_at_function_handle--;
                   }
                 ;
@@ -827,20 +820,16 @@ decl_param_init : // empty
 
 decl2           : identifier
                   { $$ = new tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
                     lexer.looking_at_initializer_expression = false;
                     $$ = new tree_decl_elt ($1, $4);
                   }
-                | magic_tilde
-                  {
-                    $$ = new tree_decl_elt ($1);
-                  }
                 ;
 
 // ====================
 // Selection statements
 // ====================
 
 select_command  : if_command
                   { $$ = $1; }
@@ -1004,25 +993,25 @@ jump_command    : BREAK
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
                     if (! ($$ = parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
-                | TRY stash_comment opt_sep opt_list CATCH
-                  stash_comment opt_sep opt_list END
+                | TRY stash_comment opt_sep opt_list CATCH stash_comment
+                  opt_sep opt_list END
                   {
-                    if (! ($$ = parser.make_try_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = parser.make_try_command ($1, $4, $7, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = parser.make_try_command ($1, $4, 0, $5, $2, 0)))
+                    if (! ($$ = parser.make_try_command ($1, $4, 0, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
@@ -1099,45 +1088,63 @@ param_list1     : // empty
                         lexer.mark_as_variables ($1->variable_names ());
                         $$ = $1;
                       }
                     else
                       ABORT_PARSE;
                   }
                 ;
 
-param_list2     : decl2
+param_list2     : param_list_elt
                   { $$ = new tree_parameter_list ($1); }
-                | param_list2 ',' decl2
+                | param_list2 ',' param_list_elt
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
+param_list_elt  : decl2
+                  { $$ = $1; }
+                | magic_tilde
+                  { $$ = new tree_decl_elt ($1); }
+                ;
+
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
                     lexer.looking_at_return_list = false;
+
                     $$ = new tree_parameter_list ();
                   }
-                | return_list1
+                | identifier
                   {
                     lexer.looking_at_return_list = false;
-                    if ($1->validate (tree_parameter_list::out))
-                      $$ = $1;
+
+                    tree_parameter_list *tmp = new tree_parameter_list ($1);
+
+                    // Even though this parameter list can contain only
+                    // a single identifier, we still need to validate it
+                    // to check for varargin or varargout.
+
+                    if (tmp->validate (tree_parameter_list::out))
+                      $$ = tmp;
                     else
                       ABORT_PARSE;
                   }
                 | '[' return_list1 ']'
                   {
                     lexer.looking_at_return_list = false;
+
+                    // Check for duplicate parameter names, varargin,
+                    // or varargout.
+
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 return_list1    : identifier
@@ -2278,31 +2285,51 @@ octave_base_parser::make_unwind_command 
   return retval;
 }
 
 // Build a try-catch command.
 
 tree_command *
 octave_base_parser::make_try_command (token *try_tok,
                                       tree_statement_list *body,
+                                      char catch_sep,
                                       tree_statement_list *cleanup_stmts,
                                       token *end_tok,
                                       octave_comment_list *lc,
                                       octave_comment_list *mc)
 {
   tree_command *retval = 0;
 
   if (end_token_ok (end_tok, token::try_catch_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       int l = try_tok->line ();
       int c = try_tok->column ();
 
-      retval = new tree_try_catch_command (body, cleanup_stmts,
+      tree_identifier *id = 0;
+
+      if (! catch_sep && cleanup_stmts && ! cleanup_stmts->empty ())
+        {
+          tree_statement *stmt = cleanup_stmts->front ();
+
+          if (stmt)
+            {
+              tree_expression *expr = stmt->expression ();
+
+              if (expr && expr->is_identifier ())
+                {
+                  id = dynamic_cast<tree_identifier *> (expr);
+
+                  cleanup_stmts->pop_front ();
+                }
+            }
+        }
+
+      retval = new tree_try_catch_command (body, cleanup_stmts, id,
                                            lc, mc, tc, l, c);
     }
 
   return retval;
 }
 
 // Build a while command.
 
@@ -3335,25 +3362,29 @@ octave_base_parser::finish_array_list (t
   return retval;
 }
 
 // Finish building a matrix list.
 
 tree_expression *
 octave_base_parser::finish_matrix (tree_matrix *m)
 {
-  return finish_array_list (m);
+  return (m
+          ? finish_array_list (m)
+          : new tree_constant (octave_null_matrix::instance));
 }
 
 // Finish building a cell list.
 
 tree_expression *
 octave_base_parser::finish_cell (tree_cell *c)
 {
-  return finish_array_list (c);
+  return (c
+          ? finish_array_list (c)
+          : new tree_constant (octave_value (Cell ())));
 }
 
 void
 octave_base_parser::maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (curr_fcn_depth > 0)
     {
       tree_statement *tmp = t->back ();
@@ -3799,17 +3830,17 @@ load_fcn_from_file (const std::string& f
         }
     }
 
   return retval;
 }
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} autoload (@var{function}, @var{file})\n\
+@deftypefn  {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 @deftypefnx {Built-in Function} {} autoload (@dots{}, @asis{\"remove\"})\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
 The second argument, @var{file}, should be an absolute file name or\n\
 a file name in the same directory as the function or script from which\n\
 the autoload command was run.  @var{file} should not depend on the\n\
 Octave load path.\n\
 \n\
@@ -4029,19 +4060,19 @@ source_file (const std::string& file_nam
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpathext\")\n\
 Return the name of the currently executing file.  At the top-level,\n\
-return the empty string.  Given the argument @code{\"fullpath\"},\n\
+return the empty string.  Given the argument @qcode{\"fullpath\"},\n\
 include the directory part of the file name, but not the extension.\n\
-Given the argument @code{\"fullpathext\"}, include the directory part\n\
+Given the argument @qcode{\"fullpathext\"}, include the directory part\n\
 of the file name and the extension.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
@@ -4550,17 +4581,17 @@ code strings.\n\
 %! [a,b,] = gcd (1, 2);
 
 */
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
-may be either @code{\"base\"} or @code{\"caller\"}.\n\
+may be either @qcode{\"base\"} or @qcode{\"caller\"}.\n\
 @seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
@@ -4604,18 +4635,18 @@ may be either @code{\"base\"} or @code{\
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} evalin (@var{context}, @var{try})\n\
 @deftypefnx {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
 Like @code{eval}, except that the expressions are evaluated in the\n\
-context @var{context}, which may be either @code{\"caller\"} or\n\
-@code{\"base\"}.\n\
+context @var{context}, which may be either @qcode{\"caller\"} or\n\
+@qcode{\"base\"}.\n\
 @seealso{eval, assignin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
@@ -4688,8 +4719,59 @@ Undocumented internal function.\n\
 
   retval = set_internal_variable (debug_flag, args, nargout,
                                   "__parser_debug_flag__");
 
   octave_debug = debug_flag;
 
   return retval;
 }
+
+DEFUN (__parse_file__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __parse_file__ (@var{file}, @var{verbose})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1 || nargin == 2)
+    {
+      std::string file = args(0).string_value ();
+      
+      std::string full_file = octave_env::make_absolute (file);
+
+      size_t file_len = file.length ();
+
+      if ((file_len > 4 && file.substr (file_len-4) == ".oct")
+          || (file_len > 4 && file.substr (file_len-4) == ".mex")
+          || (file_len > 2 && file.substr (file_len-2) == ".m"))
+        {
+          file = octave_env::base_pathname (file);
+          file = file.substr (0, file.find_last_of ('.'));
+
+          size_t pos = file.find_last_of (file_ops::dir_sep_str ());
+          if (pos != std::string::npos)
+            file = file.substr (pos+1);
+        }
+
+      if (! error_state)
+        {
+          if (nargin == 2)
+            octave_stdout << "parsing " << full_file << std::endl;
+
+          octave_function *fcn = parse_fcn_file (full_file, file, "", "",
+                                                 true, false, false,
+                                                 false, "__parse_file__");
+
+          if (fcn)
+            delete fcn;
+        }
+      else
+        error ("__parse_file__: expecting file name as argument");
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -210,18 +210,19 @@ public:
   tree_command *
   make_unwind_command (token *unwind_tok, tree_statement_list *body,
                        tree_statement_list *cleanup, token *end_tok,
                        octave_comment_list *lc, octave_comment_list *mc);
 
   // Build a try-catch command.
   tree_command *
   make_try_command (token *try_tok, tree_statement_list *body,
-                    tree_statement_list *cleanup, token *end_tok,
-                    octave_comment_list *lc, octave_comment_list *mc);
+                    char catch_sep, tree_statement_list *cleanup,
+                    token *end_tok, octave_comment_list *lc,
+                    octave_comment_list *mc);
 
   // Build a while command.
   tree_command *
   make_while_command (token *while_tok, tree_expression *expr,
                       tree_statement_list *body, token *end_tok,
                       octave_comment_list *lc);
 
   // Build a do-until command.
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -121,17 +121,17 @@ tree_argument_list::is_valid_lvalue_list
 
   return retval;
 }
 
 static const octave_value *indexed_object = 0;
 static int index_position = 0;
 static int num_indices = 0;
 
-DEFCONSTFUN (__end__, , ,
+DEFCONSTFUN (end, , ,
   "internal function")
 {
   octave_value retval;
 
   if (indexed_object)
     {
       if (indexed_object->is_object ())
         {
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -288,19 +288,19 @@ do short-circuit evaluation of @samp{|} 
 conditions of if or while statements.\n\
 \n\
 This feature is only provided for compatibility with @sc{matlab} and should\n\
 not be used unless you are porting old code that relies on this feature.\n\
 \n\
 To obtain short-circuit behavior for logical expressions in new programs,\n\
 you should always use the @samp{&&} and @samp{||} operators.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
 
 /*
 %!test
 %! x = 0;
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -499,16 +499,25 @@ tree_checker::visit_switch_command (tree
     list->accept (*this);
 }
 
 void
 tree_checker::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   tree_statement_list *try_code = cmd.body ();
 
+  tree_identifier *expr_id = cmd.identifier ();
+
+  if (expr_id)
+    {
+      if (! expr_id->lvalue_ok ())
+        gripe ("invalid lvalue used for identifier in try-catch command",
+               cmd.line ());
+    }
+
   if (try_code)
     try_code->accept (*this);
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   if (catch_code)
     catch_code->accept (*this);
 }
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -811,28 +811,28 @@ tree_evaluator::visit_statement_list (tr
 
               if (tree_return_command::returning)
                 break;
 
               if (p == lst.end ())
                 break;
               else
                 {
-                  // Clear preivous values before next statement is
+                  // Clear previous values before next statement is
                   // evaluated so that we aren't holding an extra
                   // reference to a value that may be used next.  For
                   // example, in code like this:
                   //
-                  //   X = rand (N);  ## refcount for X should be 1
-                  //                  ## after this statement
+                  //   X = rand (N);  # refcount for X should be 1
+                  //                  # after this statement
                   //
-                  //   X(idx) = val;  ## no extra copy of X should be
-                  //                  ## needed, but we will be faked
-                  //                  ## out if retval is not cleared
-                  //                  ## between statements here
+                  //   X(idx) = val;  # no extra copy of X should be
+                  //                  # needed, but we will be faked
+                  //                  # out if retval is not cleared
+                  //                  # between statements here
 
                   //              result_values = empty_list;
                 }
             }
           else
             error ("invalid statement found in statement list!");
         }
     }
@@ -922,16 +922,37 @@ tree_evaluator::visit_try_catch_command 
 
       if (catch_code)
         {
           // Set up for letting the user print any messages from errors that
           // occurred in the body of the try_catch statement.
 
           buffer_error_messages--;
 
+          tree_identifier *expr_id = cmd.identifier ();
+          octave_lvalue ult;
+
+          if (expr_id)
+            {
+
+              octave_scalar_map err;
+
+              ult = expr_id->lvalue ();
+
+              if (error_state)
+                return;
+
+              err.assign ("message", last_error_message ());
+              err.assign ("identifier", last_error_id ());
+
+              if (! error_state)
+                ult.assign (octave_value::op_asn_eq, err);
+
+            }
+
           if (catch_code)
             catch_code->accept (*this);
         }
     }
 }
 
 void
 tree_evaluator::do_unwind_protect_cleanup_code (tree_statement_list *list)
@@ -1239,19 +1260,19 @@ DEFUN (max_recursion_depth, args, nargou
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} max_recursion_depth (@var{new_val}, \"local\")\n\
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.  If the limit is exceeded, an error message is\n\
 printed and control returns to the top level.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.\n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 /*
 %!test
 %! orig_val = max_recursion_depth ();
@@ -1269,19 +1290,19 @@ DEFUN (silent_functions, args, nargout,
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.\n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
 
 /*
 %!test
 %! orig_val = silent_functions ();
diff --git a/libinterp/parse-tree/pt-except.cc b/libinterp/parse-tree/pt-except.cc
--- a/libinterp/parse-tree/pt-except.cc
+++ b/libinterp/parse-tree/pt-except.cc
@@ -28,40 +28,43 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-except.h"
 #include "pt-exp.h"
+#include "pt-id.h"
 #include "pt-jump.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 // Simple exception handling.
 
 tree_try_catch_command::~tree_try_catch_command (void)
 {
+  delete expr_id;
   delete try_code;
   delete catch_code;
   delete lead_comm;
   delete mid_comm;
   delete trail_comm;
 }
 
 tree_command *
 tree_try_catch_command::dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const
 {
   return new
     tree_try_catch_command (try_code ? try_code->dup (scope, context) : 0,
                             catch_code ? catch_code->dup (scope, context) : 0,
+                            expr_id ? expr_id->dup (scope, context) : 0,
                             lead_comm ? lead_comm->dup () : 0,
                             mid_comm ? mid_comm->dup () : 0,
                             trail_comm ? trail_comm->dup () : 0,
                             line (), column ());
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -24,39 +24,43 @@ along with Octave; see the file COPYING.
 #define octave_tree_except_h 1
 
 class tree_statement_list;
 
 class tree_walker;
 
 #include "comment-list.h"
 #include "pt-cmd.h"
+#include "pt-id.h"
 #include "symtab.h"
 
 // Simple exception handling.
 
 class
 tree_try_catch_command : public tree_command
 {
 public:
 
   tree_try_catch_command (int l = -1, int c = -1)
-    : tree_command (l, c), try_code (0), catch_code (0), lead_comm (0),
+    : tree_command (l, c), try_code (0), catch_code (0), expr_id (0), lead_comm (0),
       mid_comm (0), trail_comm (0) { }
 
   tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
+                          tree_identifier *id,
                           octave_comment_list *cl = 0,
                           octave_comment_list *cm = 0,
                           octave_comment_list *ct = 0,
                           int l = -1, int c = -1)
-    : tree_command (l, c), try_code (tc), catch_code (cc),
+    : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
       lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
   ~tree_try_catch_command (void);
 
+  tree_identifier *identifier (void) { return expr_id; }
+
   tree_statement_list *body (void) { return try_code; }
 
   tree_statement_list *cleanup (void) { return catch_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
@@ -70,16 +74,19 @@ public:
 private:
 
   // The first block of code to attempt to execute.
   tree_statement_list *try_code;
 
   // The code to execute if an error occurs in the first block.
   tree_statement_list *catch_code;
 
+  // Identifier to modify.
+  tree_identifier *expr_id;
+
   // Comment preceding TRY token.
   octave_comment_list *lead_comm;
 
   // Comment preceding CATCH token.
   octave_comment_list *mid_comm;
 
   // Comment preceding END_TRY_CATCH token.
   octave_comment_list *trail_comm;
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -51,17 +51,17 @@ public:
 
   tree_identifier (const symbol_table::symbol_record& s,
                    int l = -1, int c = -1,
                    symbol_table::scope_id sc = symbol_table::current_scope ())
     : tree_expression (l, c), sym (s, sc) { }
 
   ~tree_identifier (void) { }
 
-  bool has_magic_end (void) const { return (name () == "__end__"); }
+  bool has_magic_end (void) const { return (name () == "end"); }
 
   bool is_identifier (void) const { return true; }
 
   // The name doesn't change with scope, so use sym instead of
   // accessing it through sym so that this function may remain const.
   std::string name (void) const { return sym.name (); }
 
   bool is_defined (void) { return sym->is_defined (); }
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -355,17 +355,17 @@ tree_index_expression::rvalue (int nargo
                   // We have an expression like
                   //
                   //   x{end}.a(end)
                   //
                   // and we are looking at the argument list that
                   // contains the second (or third, etc.) "end" token,
                   // so we must evaluate everything up to the point of
                   // that argument list so we can pass the appropriate
-                  // value to the built-in __end__ function.
+                  // value to the built-in end function.
 
                   const octave_value_list tmp_list
                     = tmp.subsref (type.substr (tmpi, i - tmpi), idx, nargout);
 
                   tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
                   tmpi = i;
                   idx.clear ();
 
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1331,40 +1331,68 @@ tree_matrix::accept (tree_walker& tw)
 %!assert (class (["a", single(1)]), "char")
 %!assert (class (["a", double(1)]), "char")
 %!assert (class (["a", cell(1)]), "cell")
 %!assert (class (["a", true]), "char")
 %!assert (class (["a", "a"]), "char")
 
 %!assert (class ([cell(1), struct("foo", "bar")]), "cell")
 %!error [struct("foo", "bar"), cell(1)]
+
+%!assert ([,1], 1)
+%!assert ([1,], 1)
+%!assert ([,1,], 1)
+%!assert ([,1,;;], 1)
+%!assert ([,1,;,;], 1)
+
+%!assert ([1,1], ones (1, 2))
+%!assert ([,1,1], ones (1, 2))
+%!assert ([1,1,], ones (1, 2))
+%!assert ([,1,1,], ones (1, 2))
+%!assert ([,1,1,;;], ones (1, 2))
+%!assert ([,1,1,;,;], ones (1, 2))
+%!assert ([,;,1,1], ones (1, 2))
+
+%!assert ([1;1], ones (2, 1))
+%!assert ([1,;1], ones (2, 1))
+%!assert ([1,;,;1], ones (2, 1))
+
+%!error eval ("[,,]")
+%!error eval ("[,,;,]")
+%!error eval ("[,;,,;,]")
+
+%!assert (isnull ([,]))
+%!assert (isnull ([;]))
+%!assert (isnull ([;;]))
+%!assert (isnull ([;,;]))
+%!assert (isnull ([,;,;,]))
 */
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
-value is @code{\" \"} (a single space).  For example:\n\
+value is @qcode{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
       @result{}  \"theseXX\"\n\
           \"areXXXX\"\n\
           \"strings\"\n\
 @end group\n\
 @end example\n\
 \n\
-When called from inside a function with the \"local\" option, the variable is\n\
-changed locally for the function and any subroutines it calls.  The original\n\
-variable value is restored when exiting the function.\n\
+When called from inside a function with the @qcode{\"local\"} option, the\n\
+variable is changed locally for the function and any subroutines it calls.  \n\
+The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
 ## string_fill_char() function call must be outside of %!test block
 ## due to the way a %!test block is wrapped inside a function
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -54,16 +54,19 @@ public:
     };
 
   tree_parameter_list (void)
     : marked_for_varargs (0) { }
 
   tree_parameter_list (tree_decl_elt *t)
     : marked_for_varargs (0) { append (t); }
 
+  tree_parameter_list (tree_identifier *id)
+    : marked_for_varargs (0) { append (new tree_decl_elt (id)); }
+
   ~tree_parameter_list (void);
 
   void mark_as_formal_parameters (void);
 
   bool validate (in_or_out type);
 
   bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -1000,32 +1000,39 @@ tree_print_code::visit_try_catch_command
 
   indent ();
 
   os << "try";
 
   newline ();
 
   tree_statement_list *try_code = cmd.body ();
+  tree_identifier *expr_id = cmd.identifier ();
 
   if (try_code)
     {
       increment_indent_level ();
 
       try_code->accept (*this);
 
       decrement_indent_level ();
     }
 
   print_indented_comment (cmd.middle_comment ());
 
   indent ();
 
   os << "catch";
 
+  if (expr_id)
+    {
+      os << " ";
+      expr_id->accept (*this);
+    }
+
   newline ();
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   if (catch_code)
     {
       increment_indent_level ();
 
diff --git a/libinterp/version.cc b/libinterp/version.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/version.cc
@@ -0,0 +1,131 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string>
+
+#include "defaults.h"
+#include "version.h"
+
+static std::string
+octave_warranty_statement (const std::string& extra_info = std::string ())
+{
+  return "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\n\
+FITNESS FOR A PARTICULAR PURPOSE."
+    + extra_info;
+}
+
+static std::string
+format_url (bool html, const std::string& url)
+{
+  return html ? "<a href=\"" + url + "\">" + url + "</a>" : url;
+}
+
+std::string
+octave_www_statement (bool html)
+{
+  return "Additional information about Octave is available at "
+    + format_url (html, "http://www.octave.org.");
+}
+
+std::string
+octave_contrib_statement (bool html)
+{
+  return "Please contribute if you find this software useful.\n\
+For more information, visit "
+    + format_url (html, "http://www.octave.org/get-involved.html");
+}
+
+std::string
+octave_bugs_statement (bool html)
+{
+  return "Read " + format_url (html, "http://www.octave.org/bugs.html")
+    + " to learn how to submit bug reports.";
+}
+
+std::string
+octave_name_version_and_copyright (void)
+{
+  // The GNU coding standards say that on the first line printed by
+  // --version, the version number should follow the last space on the
+  // line.
+
+  return "GNU Octave, version " OCTAVE_VERSION "\n" OCTAVE_COPYRIGHT;
+}
+
+std::string
+octave_name_version_copyright_copying_and_warranty
+ (bool html, const std::string& extra_info)
+{
+  std::string br = html ? "<br>\n" : "\n";
+  std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
+
+  return octave_name_version_and_copyright ()
+    + br
+    + "This is free software; see the source code for copying conditions."
+    + br
+    + octave_warranty_statement (extra_info)
+    + sep
+    + "Octave was configured for \"" OCTAVE_CANONICAL_HOST_TYPE "\".";
+}
+
+std::string
+octave_name_version_copyright_copying_warranty_and_bugs
+  (bool html, const std::string& extra_info)
+{
+  std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
+
+  std::string msg;
+
+  if (html)
+    msg = "<p>\n";
+
+  msg += octave_name_version_copyright_copying_and_warranty (html, extra_info)
+    + sep
+    + octave_www_statement (html)
+    + sep
+    + octave_contrib_statement (html)
+    + sep
+    + octave_bugs_statement (html)
+    + (html ? "\n</p>" : "");
+
+  return msg;
+}
+
+std::string
+octave_startup_message (bool html)
+{
+  std::string msg
+    = octave_name_version_copyright_copying_warranty_and_bugs
+        (html, "  For details, type 'warranty'.");
+
+  msg += (html ? "<p>\n" : "\n");
+
+  msg += "For information about changes from previous versions, type 'news'.";
+
+  msg += (html ? "\n</p>" : "");
+
+  return msg;
+}
diff --git a/libinterp/version.in.h b/libinterp/version.in.h
--- a/libinterp/version.in.h
+++ b/libinterp/version.in.h
@@ -21,72 +21,33 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_version_h)
 #define octave_version_h 1
 
 #define OCTAVE_VERSION %OCTAVE_VERSION%
 
-#define OCTAVE_API_VERSION_NUMBER %OCTAVE_API_VERSION_NUMBER%
-
 #define OCTAVE_API_VERSION %OCTAVE_API_VERSION%
 
 #define OCTAVE_RELEASE_DATE %OCTAVE_RELEASE_DATE%
 
 #define OCTAVE_COPYRIGHT %OCTAVE_COPYRIGHT%
 
-// This is the first line printed by --version.  The GNU coding
-// standards say that the version number should follow the last space
-// on the line.
-
-#define OCTAVE_NAME_AND_VERSION "GNU Octave, version " OCTAVE_VERSION
+extern std::string octave_www_statement (bool html = false);
 
-#define OCTAVE_CONFIG_STATEMENT \
-  "Octave was configured for \"" OCTAVE_CANONICAL_HOST_TYPE "\"."
-
-#define OCTAVE_COPYING_STATEMENT \
-  "This is free software; see the source code for copying conditions."
+extern std::string octave_contrib_statement (bool html = false);
 
-#define X_OCTAVE_WARRANTY_STATEMENT(ARG) \
-  "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\n\
-FITNESS FOR A PARTICULAR PURPOSE." ARG
-
-#define OCTAVE_WARRANTY_STATEMENT \
-  X_OCTAVE_WARRANTY_STATEMENT ("")
+extern std::string octave_bugs_statement (bool html = false);
 
-#define OCTAVE_WWW_STATEMENT \
-  "Additional information about Octave is available at http://www.octave.org."
-
-#define OCTAVE_CONTRIB_STATEMENT \
-  "Please contribute if you find this software useful.\n\
-For more information, visit http://www.octave.org/get-involved.html"
+extern std::string octave_name_version_and_copyright (void);
 
-#define OCTAVE_BUGS_STATEMENT \
-  "Read http://www.octave.org/bugs.html to learn how to submit bug reports."
-
-#define OCTAVE_NAME_VERSION_AND_COPYRIGHT \
-  OCTAVE_NAME_AND_VERSION "\n" \
-  OCTAVE_COPYRIGHT
-
-#define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY \
-  X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY("") \
+extern std::string
+octave_name_version_copyright_copying_and_warranty
+  (bool html = false, const std::string& extra_info = std::string ());
 
-#define X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY(ARG) \
-  OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n" \
-  OCTAVE_COPYING_STATEMENT "\n" \
-  X_OCTAVE_WARRANTY_STATEMENT (ARG) "\n\n" \
-  OCTAVE_CONFIG_STATEMENT
+extern std::string
+octave_name_version_copyright_copying_warranty_and_bugs
+  (bool html = false, const std::string& extra_info = std::string ());
 
-#define X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS(ARG) \
-  X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY(ARG) "\n\n" \
-  OCTAVE_WWW_STATEMENT "\n\n" \
-  OCTAVE_CONTRIB_STATEMENT "\n\n" \
-  OCTAVE_BUGS_STATEMENT
+extern std::string octave_startup_message (bool html = false);
 
-#define OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
-  X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS ("")
-
-#define OCTAVE_STARTUP_MESSAGE \
-  X_OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_WARRANTY_AND_BUGS \
-    ("  For details, type 'warranty'.") "\n\n" \
-  "For information about changes from previous versions, type 'news'."
 #endif
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -15,18 +15,16 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AUTOMAKE_OPTIONS = subdir-objects
-
 ## Run cruft dir with stand-alone Makefile.
 ## Eventually this will use module.mk syntax.
 SUBDIRS = cruft
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I$(srcdir)/array \
   -I$(srcdir)/cruft/misc \
@@ -120,17 +118,18 @@ liboctave_la_LDFLAGS = \
   $(LIBOCTAVE_LINK_OPTS)
 
 ## Rules to build test files
 
 LIBOCTAVE_TST_SRC = \
   $(array_libarray_la_SOURCES) \
   $(numeric_libnumeric_la_SOURCES) \
   $(system_libsystem_la_SOURCES) \
-  $(util_libutil_la_SOURCES)
+  $(util_libutil_la_SOURCES) \
+  $(TEMPLATE_SRC)
 
 TST_FILES_SRC := $(shell $(top_srcdir)/build-aux/find-files-with-tests.sh "$(srcdir)" $(LIBOCTAVE_TST_SRC))
 
 TST_FILES := $(addsuffix -tst,$(TST_FILES_SRC))
 
 liboctavetestsdir := $(octtestsdir)/liboctave
 
 nobase_liboctavetests_DATA = $(TST_FILES)
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2618,30 +2618,30 @@ Sparse<T>::array_value () const
   return retval;
 }
 
 /*
  * Tests
  *
 
 %!function x = set_slice (x, dim, slice, arg)
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    otherwise
 %!      error ("invalid dim, '%d'", dim);
 %!  endswitch
 %!endfunction
 
 %!function x = set_slice2 (x, dim, slice)
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2 * ones (size (slice));
 %!    case 21
 %!      x(slice, :) = 2 * ones (length (slice), columns (x));
 %!    case 22
 %!      x(:, slice) = 2 * ones (rows (x), length (slice));
 %!    otherwise
 %!      error ("invalid dim, '%d'", dim);
@@ -2788,16 +2788,33 @@ bug #35570:
 %! s(:,2:4) = [];
 %! assert (s, sparse (magic (5)(:, [1,5])));
 
 %!test
 %! s = sparse ([], [], [], 1, 1);
 %! s(1,:) = [];
 %! assert (s, sparse ([], [], [], 0, 1));
 
+## Test (bug #37321)
+%!test a=sparse (0,0); assert (all (a) == sparse ([1]));
+%!test a=sparse (0,1); assert (all (a) == sparse ([1]));
+%!test a=sparse (1,0); assert (all (a) == sparse ([1]));
+%!test a=sparse (1,0); assert (all (a,2) == sparse ([1]));
+%!test a=sparse (1,0); assert (size (all (a,1)), [1 0]);
+%!test a=sparse (1,1);
+%! assert (all (a) == sparse ([0]));
+%! assert (size (all (a)), [1 1]);
+%!test a=sparse (2,1);
+%! assert (all (a) == sparse ([0]));
+%! assert (size (all (a)), [1 1]);
+%!test a=sparse (1,2);
+%! assert (all (a) == sparse ([0]));
+%! assert (size (all (a)), [1 1]);
+%!test a=sparse (2,2); assert (isequal (all (a), sparse ([0 0])));
+
 */
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << "\n"
      << prefix << "rep->nzmx:   " << rep->nzmx  << "\n"
diff --git a/liboctave/cruft/Makefile.am b/liboctave/cruft/Makefile.am
--- a/liboctave/cruft/Makefile.am
+++ b/liboctave/cruft/Makefile.am
@@ -15,18 +15,16 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AUTOMAKE_OPTIONS = subdir-objects
-
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I$(top_builddir)/libgnu -I$(top_srcdir)/libgnu
 
 EXTRA_DIST = mkf77def.in
 
 noinst_LTLIBRARIES = libcruft.la
 
diff --git a/liboctave/link-deps.mk b/liboctave/link-deps.mk
--- a/liboctave/link-deps.mk
+++ b/liboctave/link-deps.mk
@@ -10,28 +10,30 @@ GNULIB_LINK_DEPS = \
   $(LTLIBINTL)\
   $(ROUNDF_LIBM)\
   $(ROUND_LIBM)\
   $(TRUNCF_LIBM)\
   $(TRUNC_LIBM)
 
 LIBOCTAVE_LINK_DEPS = \
   $(GNULIB_LINK_DEPS) \
+  $(CURL_LIBS) \
   $(SPARSE_XLIBS) \
   $(ARPACK_LIBS) \
   $(QRUPDATE_LIBS) \
   $(FFTW_XLIBS) \
   $(LAPACK_LIBS) \
   $(BLAS_LIBS) \
   $(READLINE_LIBS) \
   $(TERM_LIBS) \
   $(LIBGLOB) \
   $(REGEX_LIBS) \
   $(DL_LIBS) \
   $(PTHREAD_LIBS) \
   $(FLIBS) \
   $(LIBS)
 
 LIBOCTAVE_LINK_OPTS = \
+  $(CURL_LDFLAGS) \
   $(SPARSE_XLDFLAGS) \
   $(ARPACK_LDFLAGS) \
   $(QRUPDATE_LDFLAGS) \
   $(FFTW_XLDFLAGS)
diff --git a/liboctave/numeric/DASPK-opts.in b/liboctave/numeric/DASPK-opts.in
--- a/liboctave/numeric/DASPK-opts.in
+++ b/liboctave/numeric/DASPK-opts.in
@@ -98,17 +98,17 @@ one of two initialization problems:
 
 In either case, initial values for the given components are input, and
 initial guesses for the unknown components must also be provided as
 input.  Set this option to 1 to solve the first problem, or 2 to solve
 the second (the default is 0, so you must provide a set of
 initial conditions that are consistent).
 
 If this option is set to a nonzero value, you must also set the
-@code{\"algebraic variables\"} option to declare which variables in the
+@qcode{\"algebraic variables\"} option to declare which variables in the
 problem are algebraic.
 
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
@@ -134,21 +134,21 @@ initial condition calculation.
 @item MXNIT
 Maximum number of Newton iterations (default is 5).
 
 @item MXNJ
 Maximum number of Jacobian evaluations (default is 6).
 
 @item MXNH
 Maximum number of values of the artificial stepsize parameter to be
-tried if the @code{\"compute consistent initial condition\"} option has
+tried if the @qcode{\"compute consistent initial condition\"} option has
 been set to 1 (default is 5).
 
 Note that the maximum total number of Newton iterations allowed is
-@code{MXNIT*MXNJ*MXNH} if the @code{\"compute consistent initial
+@code{MXNIT*MXNJ*MXNH} if the @qcode{\"compute consistent initial
 condition\"} option has been set to 1 and @code{MXNIT*MXNJ} if it is
 set to 2.
 
 @item LSOFF
 Set to a nonzero value to disable the linesearch algorithm (default is
 0).
 
 @item STPTOL
@@ -189,17 +189,17 @@ about the initial condition calculation 
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "exclude algebraic variables from error test"
   DOC_ITEM
 Set to a nonzero value to exclude algebraic variables from the error
-test.  You must also set the @code{\"algebraic variables\"} option to
+test.  You must also set the @qcode{\"algebraic variables\"} option to
 declare which variables in the problem are algebraic (default is 0).
 
   END_DOC_ITEM
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
@@ -207,18 +207,18 @@ OPTION
   NAME = "algebraic variables"
   DOC_ITEM
 A vector of the same length as the state vector.  A nonzero element
 indicates that the corresponding element of the state vector is an
 algebraic variable (i.e., its derivative does not appear explicitly
 in the equation set.
 
 This option is required by the
-@code{compute consistent initial condition\"} and
-@code{\"exclude algebraic variables from error test\"} options.
+@qcode{compute consistent initial condition\"} and
+@qcode{\"exclude algebraic variables from error test\"} options.
 
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = 0;
   END_INIT_BODY
@@ -234,17 +234,17 @@ This option is required by the
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
   NAME = "enforce inequality constraints"
   DOC_ITEM
 Set to one of the following values to enforce the inequality
-constraints specified by the @code{\"inequality constraint types\"}
+constraints specified by the @qcode{\"inequality constraint types\"}
 option (default is 0).
 
 @enumerate
 @item To have constraint checking only in the initial condition calculation.
 
 @item To enforce constraint checking during the integration.
 
 @item To enforce both options 1 and 2.
@@ -277,17 +277,17 @@ Not constrained.
 @item 1
 Greater than or equal to zero.
 
 @item 2
 Greater than zero.
 @end table
 
 This option only has an effect if the
-@code{\"enforce inequality constraints\"} option is nonzero.
+@qcode{\"enforce inequality constraints\"} option is nonzero.
 
   END_DOC_ITEM
   TYPE = "Array<octave_idx_type>"
   SET_ARG_TYPE = const $TYPE&
   INIT_BODY
     $OPTVAR.resize (dim_vector (1, 1));
     $OPTVAR(0) = 0;
   END_INIT_BODY
diff --git a/liboctave/numeric/LSODE-opts.in b/liboctave/numeric/LSODE-opts.in
--- a/liboctave/numeric/LSODE-opts.in
+++ b/liboctave/numeric/LSODE-opts.in
@@ -69,22 +69,22 @@ END_OPTION
 
 OPTION
   NAME = "integration method"
   DOC_ITEM
 A string specifying the method of integration to use to solve the ODE
 system.  Valid values are
 
 @table @asis
-@item \"adams\"
-@itemx \"non-stiff\"
+@item  @qcode{\"adams\"}
+@itemx @qcode{\"non-stiff\"}
 No Jacobian used (even if it is available).
 
-@item \"bdf\"
-@itemx \"stiff\"
+@item  @qcode{\"bdf\"}
+@itemx @qcode{\"stiff\"}
 Use stiff backward differentiation formula (BDF) method.  If a
 function to compute the Jacobian is not supplied, @code{lsode} will
 compute a finite difference approximation of the Jacobian matrix.
 @end table
 
   END_DOC_ITEM
   TYPE = "std::string"
   SET_ARG_TYPE = "const $TYPE&"
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -229,17 +229,17 @@ extern OCTAVE_API octave_idx_type NINTbi
 
 extern OCTAVE_API int NINT (double x);
 extern OCTAVE_API int NINT (float x);
 
 template <typename T>
 T
 X_NINT (T x)
 {
-  return (xisinf (x) || xisnan (x)) ? x : xfloor (x + 0.5);
+  return (xfinite (x) ? xfloor (x + 0.5) : x);
 }
 
 inline OCTAVE_API double D_NINT (double x) { return X_NINT (x); }
 inline OCTAVE_API float F_NINT (float x) { return X_NINT (x); }
 
 // Template functions can have either float or double arguments.
 
 template <typename T>
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3563,8 +3563,105 @@ betaincinv (const Array<double>& x, cons
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betaincinv (x(i), a(i), b(i));
     }
   else
     gripe_betaincinv_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
+
+void
+ellipj (double u, double m, double& sn, double& cn, double& dn, double& err)
+{
+  static const int Nmax = 16;
+  double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
+  int n, Nn, ii;
+
+  if (m < 0 || m > 1)
+    {
+      (*current_liboctave_warning_handler)
+        ("ellipj: expecting 0 <= M <= 1");
+      sn = cn = dn = lo_ieee_nan_value ();
+      return;
+    }
+
+  double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
+  if (m < sqrt_eps)
+    {
+      // For small m, ( Abramowitz and Stegun, Section 16.13 )
+      si_u = sin (u);
+      co_u = cos (u);
+      t = 0.25*m*(u - si_u*co_u);
+      sn = si_u - t * co_u;
+      cn = co_u + t * si_u;
+      dn = 1 - 0.5*m*si_u*si_u;
+    }
+  else if ((1 - m) < sqrt_eps)
+    {
+      // For m1 = (1-m) small ( Abramowitz and Stegun, Section 16.15 )
+      m1 = 1 - m;
+      si_u = sinh (u);
+      co_u = cosh (u);
+      ta_u = tanh (u);
+      se_u = 1/co_u;
+      sn = ta_u + 0.25*m1*(si_u*co_u - u)*se_u*se_u;
+      cn = se_u - 0.25*m1*(si_u*co_u - u)*ta_u*se_u;
+      dn = se_u + 0.25*m1*(si_u*co_u + u)*ta_u*se_u;
+    }
+  else
+    {
+      //  Arithmetic-Geometric Mean (AGM) algorithm
+      //    ( Abramowitz and Stegun, Section 16.4 )
+      a[0] = 1;
+      b    = sqrt (1 - m);
+      c[0] = sqrt (m);
+      for (n = 1; n < Nmax; ++n)
+        {
+          a[n] = (a[n - 1] + b)/2;
+          c[n] = (a[n - 1] - b)/2;
+          b = sqrt (a[n - 1]*b);
+          if (c[n]/a[n] < std::numeric_limits<double>::epsilon ()) break;
+        }
+      if (n >= Nmax - 1)
+        {
+          err = 1;
+          return;
+        }
+      Nn = n;
+      for (ii = 1; n > 0; ii = ii*2, --n) ; // ii = pow(2,Nn)
+      phi = ii*a[Nn]*u;
+      for (n = Nn; n > 0; --n)
+        {
+          t = phi;
+          phi = (asin ((c[n]/a[n])* sin (phi)) + phi)/2;
+        }
+      sn = sin (phi);
+      cn = cos (phi);
+      dn = cn/cos (t - phi);
+    }
+}
+
+void
+ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err)
+{
+  double m1 = 1 - m, ss1, cc1, dd1;
+
+  ellipj (imag (u), m1, ss1, cc1, dd1, err);
+  if (real (u) == 0)
+    {
+      // u is pure imag: Jacoby imag. transf.
+      sn = Complex (0, ss1/cc1);
+      cn = 1/cc1;         //    cn.imag = 0;
+      dn = dd1/cc1;       //    dn.imag = 0;
+    }
+  else
+    {
+      // u is generic complex
+      double ss, cc, dd, ddd;
+
+      ellipj (real (u), m, ss, cc, dd, err);
+      ddd = cc1*cc1 + m*ss*ss*ss1*ss1;
+      sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
+      cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
+      dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
+    }
+}
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -602,9 +602,12 @@ extern OCTAVE_API Array<double> betainci
 extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
 extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
 
+extern OCTAVE_API void ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
+extern OCTAVE_API void ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err);
+
 #endif
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -163,21 +163,23 @@ TEMPLATE_SRC += \
   numeric/base-qr.cc \
   numeric/bsxfun-defs.cc \
   numeric/eigs-base.cc \
   numeric/sparse-base-chol.cc \
   numeric/sparse-base-lu.cc \
   numeric/sparse-dmsolve.cc
 
 ## Special rules for sources which must be built before rest of compilation.
-$(OPT_INC) : %.h : %.in $(top_srcdir)/build-aux/mk-opts.pl
+$(OPT_INC) : %.h : %.in
 	@echo making $@ from $<
 	@$(PERL) $(top_srcdir)/build-aux/mk-opts.pl --opt-class-header $< > $@-t
 	mv $@-t $@
 
+$(OPT_INC) : $(top_srcdir)/build-aux/mk-opts.pl
+
 noinst_LTLIBRARIES += numeric/libnumeric.la
 
 numeric_libnumeric_la_SOURCES = $(NUMERIC_SRC)
 numeric_libnumeric_la_CPPFLAGS = \
   $(liboctave_la_CPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
   -I$(srcdir)/cruft/Faddeeva \
   $(FFTW_XCPPFLAGS) \
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -355,28 +355,28 @@ octave_rand::do_scalar (double a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
           break;
 
         case poisson_dist:
-          if (a < 0.0 || xisnan (a) || xisinf (a))
+          if (a < 0.0 || ! xfinite (a))
             retval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
               F77_FUNC (dignpoi, DIGNPOI) (a, retval);
             }
           break;
 
         case gamma_dist:
-          if (a <= 0.0 || xisnan (a) || xisinf (a))
+          if (a <= 0.0 || ! xfinite (a))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -438,28 +438,28 @@ octave_rand::do_float_scalar (float a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, dretval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, dretval);
           break;
 
         case poisson_dist:
-          if (da < 0.0 || xisnan (da) || xisinf (da))
+          if (da < 0.0 || ! xfinite (a))
             dretval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
-          if (da <= 0.0 || xisnan (da) || xisinf (da))
+          if (da <= 0.0 || ! xfinite (a))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -658,26 +658,50 @@ octave_rand::get_dist_id (const std::str
     retval = gamma_dist;
   else
     (*current_liboctave_error_handler)
       ("rand: invalid distribution '%s'", d.c_str ());
 
   return retval;
 }
 
+// Guarantee reproducible conversion of negative initialization values to
+// random number algorithm.  Note that Matlab employs slightly different rules.
+// 1) Seed saturates at 2^32-1 for any value larger than that.
+// 2) NaN, Inf are translated to 2^32-1.
+// 3) -Inf is translated to 0.
+static uint32_t
+double2uint32 (double d)
+{
+  uint32_t u;
+  static const double TWOUP32 = std::numeric_limits<uint32_t>::max() + 1.0;
+
+  if (! xfinite (d))
+    u = 0;
+  else
+    {
+      d = fmod (d, TWOUP32);
+      if (d < 0)
+        d += TWOUP32;
+      u = static_cast<uint32_t> (d);
+    }
+
+  return u;
+}
+
 void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.length ();
   octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   for (octave_idx_type i = 0; i < n; i++)
-    tmp[i] = static_cast<uint32_t> (s.elem (i));
+    tmp[i] = double2uint32 (s.elem (i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
     oct_set_state (tmp);
   else
     oct_init_by_array (tmp, len);
 }
 
 void
@@ -743,17 +767,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
-          if (a < 0.0 || xisnan (a) || xisinf (a))
+          if (a < 0.0 || ! xfinite (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
@@ -764,17 +788,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
-          if (a <= 0.0 || xisnan (a) || xisinf (a))
+          if (a <= 0.0 || ! xfinite (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
@@ -833,17 +857,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da < 0.0 || xisnan (da) || xisinf (da))
+          if (da < 0.0 || ! xfinite (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
@@ -855,17 +879,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da <= 0.0 || xisnan (da) || xisinf (da))
+          if (da <= 0.0 || ! xfinite (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, da, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
diff --git a/liboctave/numeric/randmtzig.c b/liboctave/numeric/randmtzig.c
--- a/liboctave/numeric/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -263,17 +263,17 @@ oct_init_by_entropy (void)
     FILE* urandom = fopen ("/dev/urandom", "rb");
     if (urandom)
       {
         while (n < MT_N)
           {
             unsigned char word[4];
             if (fread (word, 4, 1, urandom) != 1)
               break;
-            entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
+            entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+((uint32_t)word[3]<<24);
           }
         fclose (urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N)
       entropy[n++] = time (NULL); /* Current time in seconds */
     if (n < MT_N)
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1761,17 +1761,17 @@ along with Octave; see the file COPYING.
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nc); \
           retval.cidx (0) = 0; \
           for (octave_idx_type i = 0; i < nc ; i++) \
             { \
               retval.ridx (i) = 0; \
-              retval.cidx (i+1) = i; \
+              retval.cidx (i+1) = i+1; \
               retval.data (i) = MT_RESULT; \
             } \
         } \
       else \
         retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, \
                            static_cast<octave_idx_type> (0)); \
     } \
   else if (nc == 0 && dim == 1) \
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -70,50 +70,30 @@ equiv_compare (const equiv *std, const e
   return 1;
 }
 
 static oct_mach_info::float_format
 get_float_format (void)
 {
   oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
 
-#if defined (CRAY)
-
-  // FIXME -- this should be determined automatically.
-
-  native_float_fmt = oct_mach_info::flt_fmt_cray;
-
-#else
-
   float_params fp[5];
 
   INIT_FLT_PAR (fp[0], oct_mach_info::flt_fmt_ieee_big_endian,
                    1048576,  0,
                 2146435071, -1,
                 1017118720,  0,
                 1018167296,  0);
 
   INIT_FLT_PAR (fp[1], oct_mach_info::flt_fmt_ieee_little_endian,
                  0,    1048576,
                 -1, 2146435071,
                  0, 1017118720,
                  0, 1018167296);
 
-  INIT_FLT_PAR (fp[2], oct_mach_info::flt_fmt_vax_d,
-                   128,  0,
-                -32769, -1,
-                  9344,  0,
-                  9344,  0);
-
-  INIT_FLT_PAR (fp[3], oct_mach_info::flt_fmt_vax_g,
-                    16,  0,
-                -32769, -1,
-                 15552,  0,
-                 15552,  0);
-
   INIT_FLT_PAR (fp[4], oct_mach_info::flt_fmt_unknown,
                 0, 0,
                 0, 0,
                 0, 0,
                 0, 0);
 
   equiv mach_fp_par[4];
 
@@ -128,18 +108,16 @@ get_float_format (void)
       if (equiv_compare (fp[i].fp_par, mach_fp_par, 4))
         {
           retval = fp[i].fp_fmt;
           break;
         }
     }
   while (fp[++i].fp_fmt != oct_mach_info::flt_fmt_unknown);
 
-#endif
-
   return retval;
 }
 
 static bool
 ten_little_endians (void)
 {
   // Are we little or big endian?  From Harbison & Steele.
 
@@ -209,22 +187,16 @@ oct_mach_info::string_to_float_format (c
   oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
 
   if (s == "native" || s == "n")
     retval = oct_mach_info::native_float_format ();
   else if (s == "ieee-be" || s == "b")
     retval = oct_mach_info::flt_fmt_ieee_big_endian;
   else if (s == "ieee-le" || s == "l")
     retval = oct_mach_info::flt_fmt_ieee_little_endian;
-  else if (s == "vaxd" || s == "d")
-    retval = oct_mach_info::flt_fmt_vax_d;
-  else if (s == "vaxg" || s == "g")
-    retval = oct_mach_info::flt_fmt_vax_g;
-  else if (s == "cray" || s == "c")
-    retval = oct_mach_info::flt_fmt_cray;
   else if (s == "unknown")
     retval = oct_mach_info::flt_fmt_unknown;
   else
     (*current_liboctave_error_handler)
       ("invalid architecture type specified");
 
   return retval;
 }
@@ -239,26 +211,14 @@ oct_mach_info::float_format_as_string (f
     case flt_fmt_ieee_big_endian:
       retval = "ieee-be";
       break;
 
     case flt_fmt_ieee_little_endian:
       retval = "ieee-le";
       break;
 
-    case flt_fmt_vax_d:
-      retval = "vaxd";
-      break;
-
-    case flt_fmt_vax_g:
-      retval = "vaxg";
-      break;
-
-    case flt_fmt_cray:
-      retval = "cray";
-      break;
-
     default:
       break;
     }
 
   return retval;
 }
diff --git a/liboctave/system/mach-info.h b/liboctave/system/mach-info.h
--- a/liboctave/system/mach-info.h
+++ b/liboctave/system/mach-info.h
@@ -35,19 +35,16 @@ protected:
 
 public:
 
   enum float_format
     {
       flt_fmt_unknown,
       flt_fmt_ieee_little_endian,
       flt_fmt_ieee_big_endian,
-      flt_fmt_vax_d,
-      flt_fmt_vax_g,
-      flt_fmt_cray
     };
 
   static bool instance_ok (void);
 
   static float_format native_float_format (void);
 
   static bool words_big_endian (void);
 
diff --git a/libinterp/corefcn/action-container.h b/liboctave/util/action-container.h
rename from libinterp/corefcn/action-container.h
rename to liboctave/util/action-container.h
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -44,34 +44,38 @@ public:
   size_t size (void) const { return lst.size (); }
   size_t length (void) const { return size (); }
 
   iterator erase (iterator pos) { return lst.erase (pos); }
 
   template <class P>
   void remove_if (P pred)
   {
+    lst.remove_if (pred);
+
+    // FIXME: kluge removed 8/7/13.  Eventually this commented
+    //        code should be deleted.
+    //
+    // FIXME: this kluge should be removed at some point.
     // We would like to simply call
     //
     //   lst.remove_if (pred);
     //
     // but the Sun Studio compiler chokes on that.
     //
-    // FIXME -- this kluge should be removed at some point.
-
-    iterator b = lst.begin ();
-    iterator e = lst.end ();
-    while (b != e)
-      {
-        iterator n = b;
-        n++;
-        if (pred (*b))
-          lst.erase (b);
-        b = n;
-      }
+    // iterator b = lst.begin ();
+    // iterator e = lst.end ();
+    // while (b != e)
+    //   {
+    //     iterator n = b;
+    //     n++;
+    //     if (pred (*b))
+    //       lst.erase (b);
+    //     b = n;
+    //   }
   }
 
   void clear (void) { lst.clear (); }
 
   iterator begin (void) { return iterator (lst.begin ()); }
   const_iterator begin (void) const { return const_iterator (lst.begin ()); }
 
   iterator end (void) { return iterator (lst.end ()); }
diff --git a/liboctave/util/byte-swap.h b/liboctave/util/byte-swap.h
--- a/liboctave/util/byte-swap.h
+++ b/liboctave/util/byte-swap.h
@@ -18,80 +18,77 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_byte_swap_h)
 #define octave_byte_swap_h 1
 
-// FIXME -- not sure these volatile qualifiers are really
-// needed or appropriate here.
-
 static inline void
-swap_bytes (volatile void *ptr, unsigned int i, unsigned int j)
+swap_bytes (void *ptr, unsigned int i, unsigned int j)
 {
-  volatile char *t = static_cast<volatile char *> (ptr);
+  char *t = static_cast<char *> (ptr);
 
   char tmp = t[i];
   t[i] = t[j];
   t[j] = tmp;
 }
 
 template <int n>
 void
-swap_bytes (volatile void *ptr)
+swap_bytes (void *ptr)
 {
   for (int i = 0; i < n/2; i++)
     swap_bytes (ptr, i, n-1-i);
 }
 
 template <>
 inline void
-swap_bytes <1> (volatile void *)
+swap_bytes<1> (void *)
 {
 }
 
 template <>
 inline void
-swap_bytes <2> (volatile void *ptr)
+swap_bytes<2> (void *ptr)
 {
   swap_bytes (ptr, 0, 1);
 }
 
 template <>
 inline void
-swap_bytes <4> (volatile void *ptr)
+swap_bytes<4> (void *ptr)
 {
   swap_bytes (ptr, 0, 3);
   swap_bytes (ptr, 1, 2);
 }
 
 template <>
 inline void
-swap_bytes <8> (volatile void *ptr)
+swap_bytes<8> (void *ptr)
 {
   swap_bytes (ptr, 0, 7);
   swap_bytes (ptr, 1, 6);
   swap_bytes (ptr, 2, 5);
   swap_bytes (ptr, 3, 4);
 }
 
 template <int n>
 void
-swap_bytes (volatile void *ptr, int len)
+swap_bytes (void *ptr, int len)
 {
-  volatile char *t = static_cast<volatile char *> (ptr);
+  char *t = static_cast<char *> (ptr);
 
   for (int i = 0; i < len; i++)
     {
       swap_bytes<n> (t);
       t += n;
     }
 }
 
 template <>
 inline void
-swap_bytes<1> (volatile void *, int)
+swap_bytes<1> (void *, int)
 {
 }
 
 #endif
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -60,17 +60,17 @@ public:
     : command_history (), mark (0) { }
 
   ~gnu_history (void) { }
 
   void do_process_histcontrol (const std::string&);
 
   std::string do_histcontrol (void) const;
 
-  void do_add (const std::string&);
+  bool do_add (const std::string&);
 
   void do_remove (int);
 
   void do_clear (void);
 
   int do_where (void) const;
 
   int do_length (void) const;
@@ -179,33 +179,36 @@ gnu_history::do_histcontrol (void) const
         retval.append (":");
 
       retval.append ("erasedups");
     }
 
   return retval;
 }
 
-void
+bool
 gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
           || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
-        return;
+        return false;
      
       // Strip newline before adding to list
       std::string stmp = s;
       int stmp_len = stmp.length ();
       if (stmp[stmp_len - 1] == '\n')
         stmp.resize (stmp_len - 1);
 
-      lines_this_session += ::octave_add_history (stmp.c_str (), history_control);
+      int added = ::octave_add_history (stmp.c_str (), history_control);
+      lines_this_session += added;
+      return (added > 0) ? true : false;
     }
+  return false;
 }
 
 void
 gnu_history::do_remove (int n)
 {
   ::octave_remove_history (n);
 }
 
@@ -582,21 +585,22 @@ command_history::ignore_entries (bool fl
 
 bool
 command_history::ignoring_entries (void)
 {
   return (instance_ok ())
     ? instance->do_ignoring_entries () : false;
 }
 
-void
+bool
 command_history::add (const std::string& s)
 {
   if (instance_ok ())
-    instance->do_add (s);
+    return instance->do_add (s);
+  return false;
 }
 
 void
 command_history::remove (int n)
 {
   if (instance_ok ())
     instance->do_remove (n);
 }
@@ -813,19 +817,20 @@ command_history::do_ignore_entries (bool
 }
 
 bool
 command_history::do_ignoring_entries (void) const
 {
   return ignoring_additions;
 }
 
-void
+bool
 command_history::do_add (const std::string&)
 {
+  return false;
 }
 
 void
 command_history::do_remove (int)
 {
 }
 
 void
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -56,17 +56,17 @@ public:
   static void set_size (int);
 
   static int size (void);
 
   static void ignore_entries (bool = true);
 
   static bool ignoring_entries (void);
 
-  static void add (const std::string&);
+  static bool add (const std::string&);
 
   static void remove (int);
 
   static void clear (void);
 
   static int where (void);
 
   static int length (void);
@@ -151,17 +151,17 @@ protected:
   virtual void do_set_size (int);
 
   virtual int do_size (void) const;
 
   virtual void do_ignore_entries (bool);
 
   virtual bool do_ignoring_entries (void) const;
 
-  virtual void do_add (const std::string&);
+  virtual bool do_add (const std::string&);
 
   virtual void do_remove (int);
 
   virtual void do_clear (void);
 
   virtual int do_where (void) const;
 
   virtual int do_length (void) const;
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -20,37 +20,33 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
-#include <climits>
 #include <cstdlib>
 
 #include <iostream>
+#include <limits>
 #include <vector>
 
 #include "byte-swap.h"
 #include "data-conv.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "oct-locbuf.h"
 
-template void swap_bytes<2> (volatile void *, int);
-template void swap_bytes<4> (volatile void *, int);
-template void swap_bytes<8> (volatile void *, int);
-
 #if defined HAVE_LONG_LONG_INT
 #define FIND_SIZED_INT_TYPE(VAL, BITS, TQ, Q) \
   do \
     { \
-      int sz = BITS / CHAR_BIT; \
+      int sz = BITS / std::numeric_limits<unsigned char>::digits; \
       if (sizeof (TQ char) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## char; \
       else if (sizeof (TQ short) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## short; \
       else if (sizeof (TQ int) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## int; \
       else if (sizeof (TQ long) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## long; \
@@ -59,17 +55,17 @@ template void swap_bytes<8> (volatile vo
       else \
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 #else
 #define FIND_SIZED_INT_TYPE(VAL, BITS, TQ, Q) \
   do \
     { \
-      int sz = BITS / CHAR_BIT; \
+      int sz = BITS / std::numeric_limits<unsigned char>::digits; \
       if (sizeof (TQ char) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## char; \
       else if (sizeof (TQ short) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## short; \
       else if (sizeof (TQ int) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## int; \
       else if (sizeof (TQ long) == sz) \
         VAL = oct_data_conv::dt_ ## Q ## long; \
@@ -77,30 +73,31 @@ template void swap_bytes<8> (volatile vo
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 #endif
 
 #define FIND_SIZED_FLOAT_TYPE(VAL, BITS) \
   do \
     { \
-      int sz = BITS / CHAR_BIT; \
+      int sz = BITS / std::numeric_limits<unsigned char>::digits; \
       if (sizeof (float) == sz) \
         VAL = oct_data_conv::dt_float; \
       else if (sizeof (double) == sz) \
         VAL = oct_data_conv::dt_double; \
       else \
         VAL = oct_data_conv::dt_unknown; \
     } \
   while (0)
 
 // I'm not sure it is worth the trouble, but let's use a lookup table
 // for the types that are supposed to be a specific number of bits
-// wide.  Given the macros above, this should work as long as CHAR_BIT
-// is a multiple of 8 and there are types with the right sizes.
+// wide.  Given the macros above, this should work as long as
+// std::numeric_limits<unsigned char>::digits is a multiple of 8 and
+// there are types with the right sizes.
 //
 // The sized data type lookup table has the following format:
 //
 //                            bits
 //                    +----+----+----+----+
 //                    |  8 | 16 | 32 | 64 |
 //                    +----+----+----+----+
 //     signed integer |    |    |    |    |
@@ -172,16 +169,121 @@ strip_spaces (const std::string& str)
  \
         default: \
           retval = dt_unknown; \
           break; \
         } \
     } \
   while (0)
 
+size_t
+oct_data_conv::data_type_size (data_type dt)
+{
+  size_t retval = -1;
+
+  switch (dt)
+    {
+    case oct_data_conv::dt_int8:
+      retval = sizeof (int8_t);
+      break;
+
+    case oct_data_conv::dt_uint8:
+      retval = sizeof (uint8_t);
+      break;
+
+    case oct_data_conv::dt_int16:
+      retval = sizeof (int16_t);
+      break;
+
+    case oct_data_conv::dt_uint16:
+      retval = sizeof (uint16_t);
+      break;
+
+    case oct_data_conv::dt_int32:
+      retval = sizeof (int32_t);
+      break;
+
+    case oct_data_conv::dt_uint32:
+      retval = sizeof (uint32_t);
+      break;
+
+    case oct_data_conv::dt_int64:
+      retval = sizeof (int64_t);
+      break;
+
+    case oct_data_conv::dt_uint64:
+      retval = sizeof (uint64_t);
+      break;
+
+    case oct_data_conv::dt_float:
+    case oct_data_conv::dt_single:
+      retval = sizeof (float);
+      break;
+
+    case oct_data_conv::dt_double:
+      retval = sizeof (double);
+      break;
+
+    case oct_data_conv::dt_char:
+      retval = sizeof (char);
+      break;
+
+    case oct_data_conv::dt_schar:
+      retval = sizeof (signed char);
+      break;
+
+    case oct_data_conv::dt_uchar:
+      retval = sizeof (unsigned char);
+      break;
+
+    case oct_data_conv::dt_short:
+      retval = sizeof (short);
+      break;
+
+    case oct_data_conv::dt_ushort:
+      retval = sizeof (unsigned short);
+      break;
+
+    case oct_data_conv::dt_int:
+      retval = sizeof (int);
+      break;
+
+    case oct_data_conv::dt_uint:
+      retval = sizeof (unsigned int);
+      break;
+
+    case oct_data_conv::dt_long:
+      retval = sizeof (long);
+      break;
+
+    case oct_data_conv::dt_ulong:
+      retval = sizeof (unsigned long);
+      break;
+
+    case oct_data_conv::dt_longlong:
+      retval = sizeof (long long);
+      break;
+
+    case oct_data_conv::dt_ulonglong:
+      retval = sizeof (unsigned long long);
+      break;
+
+    case oct_data_conv::dt_logical:
+      retval = sizeof (bool);
+      break;
+
+    case oct_data_conv::dt_unknown:
+    default:
+      abort ();
+      break;
+    }
+
+  return retval;
+}
+
 oct_data_conv::data_type
 oct_data_conv::string_to_data_type (const std::string& str)
 {
   data_type retval = dt_unknown;
 
   static bool initialized = false;
 
   static data_type sized_type_table[3][4];
@@ -424,41 +526,41 @@ oct_data_conv::data_type_as_string (oct_
       retval = "char";
       break;
 
     case oct_data_conv::dt_schar:
       retval = "signed char";
       break;
 
     case oct_data_conv::dt_uchar:
-      retval = "usigned char";
+      retval = "unsigned char";
       break;
 
     case oct_data_conv::dt_short:
       retval = "short";
       break;
 
     case oct_data_conv::dt_ushort:
       retval = "unsigned short";
       break;
 
     case oct_data_conv::dt_int:
       retval = "int";
       break;
 
     case oct_data_conv::dt_uint:
-      retval = "usigned int";
+      retval = "unsigned int";
       break;
 
     case oct_data_conv::dt_long:
       retval = "long";
       break;
 
     case oct_data_conv::dt_ulong:
-      retval = "usigned long";
+      retval = "unsigned long";
       break;
 
     case oct_data_conv::dt_longlong:
       retval = "long long";
       break;
 
     case oct_data_conv::dt_ulonglong:
       retval = "unsigned long long";
@@ -543,201 +645,33 @@ gripe_data_conversion (const char *from,
 
 static void
 IEEE_big_double_to_IEEE_little_double (void *d, octave_idx_type len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "IEEE little endian format");
-}
-
-static void
-VAX_G_double_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "IEEE little endian format");
-}
-
-static void
-Cray_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "IEEE little endian format");
-}
-
-static void
 IEEE_big_float_to_IEEE_little_float (void *d, octave_idx_type len)
 {
   swap_bytes<4> (d, len);
 }
 
 static void
-VAX_D_float_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "IEEE little endian format");
-}
-
-static void
-VAX_G_float_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "IEEE little endian format");
-}
-
-static void
-Cray_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "IEEE little endian format");
-}
-
-static void
 IEEE_little_double_to_IEEE_big_double (void *d, octave_idx_type len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "IEEE big endian format");
-}
-
-static void
-VAX_G_double_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "IEEE big endian format");
-}
-
-static void
-Cray_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "IEEE big endian format");
-}
-
-static void
 IEEE_little_float_to_IEEE_big_float (void *d, octave_idx_type len)
 {
   swap_bytes<4> (d, len);
 }
 
-static void
-VAX_D_float_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "IEEE big endian format");
-}
-
-static void
-VAX_G_float_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "IEEE big endian format");
-}
-
-static void
-Cray_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "IEEE big endian format");
-}
-
-static void
-IEEE_little_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE little endian", "VAX D");
-}
-
-static void
-IEEE_big_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE big endian", "VAX D");
-}
-
-static void
-VAX_G_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "VAX D");
-}
-
-static void
-Cray_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "VAX D");
-}
-
-static void
-IEEE_little_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE little endian", "VAX D");
-}
-
-static void
-IEEE_big_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE big endian", "VAX D");
-}
-
-static void
-VAX_G_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "VAX D");
-}
-
-static void
-Cray_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("Cray", "VAX D");
-}
-
-static void
-IEEE_little_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE little endian", "VAX G");
-}
-
-static void
-IEEE_big_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE big endian", "VAX G");
-}
-
-static void
-VAX_D_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "VAX G");
-}
-
-static void
-Cray_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "VAX G");
-}
-
-static void
-IEEE_little_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE little endian", "VAX G");
-}
-
-static void
-IEEE_big_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("IEEE big endian", "VAX G");
-}
-
-static void
-VAX_D_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX D float", "VAX G");
-}
-
-static void
-Cray_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
-{
-  gripe_data_conversion ("VAX G float", "VAX G");
-}
-
 void
 do_double_format_conversion (void *data, octave_idx_type len,
                              oct_mach_info::float_format from_fmt,
                              oct_mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
     case oct_mach_info::flt_fmt_ieee_little_endian:
@@ -745,112 +679,32 @@ do_double_format_conversion (void *data,
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_double_to_IEEE_little_double (data, len);
           break;
 
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_double_to_IEEE_little_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_double_to_IEEE_little_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_IEEE_little_double (data, len);
-          break;
-
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_double_to_IEEE_big_double (data, len);
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           break;
 
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_double_to_IEEE_big_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_double_to_IEEE_big_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_IEEE_big_double (data, len);
-          break;
-
-        default:
-          gripe_unrecognized_float_fmt ();
-          break;
-        }
-      break;
-
-    case oct_mach_info::flt_fmt_vax_d:
-      switch (from_fmt)
-        {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
-          IEEE_little_double_to_VAX_D_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_ieee_big_endian:
-          IEEE_big_double_to_VAX_D_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_d:
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_double_to_VAX_D_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_VAX_D_double (data, len);
-          break;
-
-        default:
-          gripe_unrecognized_float_fmt ();
-          break;
-        }
-      break;
-
-    case oct_mach_info::flt_fmt_vax_g:
-      switch (from_fmt)
-        {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
-          IEEE_little_double_to_VAX_G_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_ieee_big_endian:
-          IEEE_big_double_to_VAX_G_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_double_to_VAX_G_double (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_VAX_G_double (data, len);
-          break;
-
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
@@ -872,112 +726,32 @@ do_float_format_conversion (void *data, 
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_float_to_IEEE_little_float (data, len);
           break;
 
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_float_to_IEEE_little_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_float_to_IEEE_little_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_IEEE_little_float (data, len);
-          break;
-
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_float_to_IEEE_big_float (data, len);
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           break;
 
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_float_to_IEEE_big_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_float_to_IEEE_big_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_IEEE_big_float (data, len);
-          break;
-
-        default:
-          gripe_unrecognized_float_fmt ();
-          break;
-        }
-      break;
-
-    case oct_mach_info::flt_fmt_vax_d:
-      switch (from_fmt)
-        {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
-          IEEE_little_float_to_VAX_D_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_ieee_big_endian:
-          IEEE_big_float_to_VAX_D_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_d:
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          VAX_G_float_to_VAX_D_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_VAX_D_float (data, len);
-          break;
-
-        default:
-          gripe_unrecognized_float_fmt ();
-          break;
-        }
-      break;
-
-    case oct_mach_info::flt_fmt_vax_g:
-      switch (from_fmt)
-        {
-        case oct_mach_info::flt_fmt_ieee_little_endian:
-          IEEE_little_float_to_VAX_G_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_ieee_big_endian:
-          IEEE_big_float_to_VAX_G_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_d:
-          VAX_D_float_to_VAX_G_float (data, len);
-          break;
-
-        case oct_mach_info::flt_fmt_vax_g:
-          break;
-
-        case oct_mach_info::flt_fmt_cray:
-          Cray_to_VAX_G_float (data, len);
-          break;
-
         default:
           gripe_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
diff --git a/liboctave/util/data-conv.h b/liboctave/util/data-conv.h
--- a/liboctave/util/data-conv.h
+++ b/liboctave/util/data-conv.h
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_data_conv_h)
 #define octave_data_conv_h 1
 
 #include <limits>
 
 #include "mach-info.h"
+#include "oct-inttypes.h"
 
 class
 OCTAVE_API
 oct_data_conv
 {
 public:
 
   enum data_type
@@ -56,16 +57,18 @@ public:
       dt_long      = 18,
       dt_ulong     = 19,
       dt_longlong  = 20,
       dt_ulonglong = 21,
       dt_float     = 22,
       dt_unknown   = 23 // Must be last, have largest value!
     };
 
+  static size_t data_type_size (data_type dt);
+
   static data_type string_to_data_type (const std::string& s);
 
   static void string_to_data_type (const std::string& s, int& block_size,
                                    data_type& input_type,
                                    data_type& output_type);
 
   static void string_to_data_type (const std::string& s, int& block_size,
                                    data_type& output_type);
@@ -120,9 +123,142 @@ write_doubles (std::ostream& os, const d
 extern OCTAVE_API void
 read_floats (std::istream& is, float *data, save_type type,
              octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
 
 extern OCTAVE_API void
 write_floats (std::ostream& os, const float *data, save_type type,
               octave_idx_type len);
 
+template <typename T>
+inline bool
+is_equivalent_type (oct_data_conv::data_type)
+{
+  return false;
+}
+
+template <>
+inline bool
+is_equivalent_type<int8_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int8;
+}
+
+template <>
+inline bool
+is_equivalent_type<int16_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int16;
+}
+
+template <>
+inline bool
+is_equivalent_type<int32_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int32;
+}
+
+template <>
+inline bool
+is_equivalent_type<int64_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int64;
+}
+
+template <>
+inline bool
+is_equivalent_type<uint8_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint8;
+}
+
+template <>
+inline bool
+is_equivalent_type<uint16_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint16;
+}
+
+template <>
+inline bool
+is_equivalent_type<uint32_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint32;
+}
+
+template <>
+inline bool
+is_equivalent_type<uint64_t> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint64;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_int8> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int8;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_int16> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int16;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_int32> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int32;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_int64> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_int64;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_uint8> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint8;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_uint16> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint16;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_uint32> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint32;
+}
+
+template <>
+inline bool
+is_equivalent_type<octave_uint64> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_uint64;
+}
+
+template <>
+inline bool
+is_equivalent_type<double> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_double;
+}
+
+template <>
+inline bool
+is_equivalent_type<float> (oct_data_conv::data_type t)
+{
+  return t == oct_data_conv::dt_single || t == oct_data_conv::dt_float;
+}
+
 #endif
diff --git a/liboctave/util/lo-ieee.cc b/liboctave/util/lo-ieee.cc
--- a/liboctave/util/lo-ieee.cc
+++ b/liboctave/util/lo-ieee.cc
@@ -68,19 +68,16 @@ octave_ieee_init (void)
         octave_NA = t.value;
 
         lo_ieee_float tf;
         tf.word = LO_IEEE_NA_FLOAT;
         octave_Float_NA = tf.value;
       }
       break;
 
-    case oct_mach_info::flt_fmt_cray:
-    case oct_mach_info::flt_fmt_vax_d:
-    case oct_mach_info::flt_fmt_vax_g:
     default:
       // If the format is unknown, then you will probably not have a
       // useful system, so we will abort here.  Anyone wishing to
       // experiment with building Octave on a system without IEEE
       // floating point should be capable of removing this check and
       // the configure test.
       (*current_liboctave_error_handler)
         ("lo_ieee_init: floating point format is not IEEE!  Maybe DLAMCH is miscompiled, or you are using some strange system without IEEE floating point math?");
diff --git a/liboctave/util/regexp.cc b/liboctave/util/lo-regexp.cc
rename from liboctave/util/regexp.cc
rename to liboctave/util/lo-regexp.cc
--- a/liboctave/util/regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include <pcre/pcre.h>
 #endif
 
 #include "Matrix.h"
 #include "base-list.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "quit.h"
-#include "regexp.h"
+#include "lo-regexp.h"
 #include "str-vec.h"
 
 // Define the maximum number of retries for a pattern that possibly
 // results in an infinite recursion.
 #define PCRE_MATCHLIMIT_MAX 10
 
 // FIXME -- should this be configurable?
 #define MAXLOOKBEHIND 10
@@ -545,17 +545,17 @@ regexp::replace (const std::string& buff
         {
           OCTAVE_QUIT;
 
           double start = p->start ();
           double end = p->end ();
 
           const Matrix pairs (p->token_extents ());
           rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
-          from = static_cast<size_t> (end - 1) + 1;
+          from = static_cast<size_t> (end);
 
           size_t cur_pos = 0;
 
           for (int j = 0; j < num_tokens; j++)
             {
               rep.append (&repstr[cur_pos], (tokens[j].pos) - cur_pos);
               cur_pos = tokens[j].pos+2;
 
@@ -603,17 +603,17 @@ regexp::replace (const std::string& buff
       rep.reserve (buffer.size () + delta);
       size_t from = 0;
       p = rx_lst.begin ();
       for (size_t i = 0; i < num_matches; i++)
         {
           OCTAVE_QUIT;
           rep.append (&buffer[from],
                       static_cast<size_t> (p->start () - 1) - from);
-          from = static_cast<size_t> (p->end () - 1) + 1;
+          from = static_cast<size_t> (p->end ());
           rep.append (repstr);
           p++;
         }
       rep.append (&buffer[from], buffer.size () - from);
     }
 
   retval = rep;
   return retval;
diff --git a/liboctave/util/regexp.h b/liboctave/util/lo-regexp.h
rename from liboctave/util/regexp.h
rename to liboctave/util/lo-regexp.h
--- a/liboctave/util/regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if !defined (octave_regexp_match_h)
-#define octave_regexp_match_h 1
+#if !defined (octave_liboctave_regexp_match_h)
+#define octave_liboctave_regexp_match_h 1
 
 #include <list>
 #include <sstream>
 #include <string>
 
 #include "Array.h"
 #include "Matrix.h"
 #include "base-list.h"
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -50,18 +50,17 @@ bool xis_int_or_inf_or_nan (double x)
 bool xis_one_or_zero (double x)
 { return x == 0 || x == 1; }
 
 bool xis_zero (double x)
 { return x == 0; }
 
 bool xtoo_large_for_float (double x)
 {
-  return (! (xisnan (x) || xisinf (x))
-          && fabs (x) > std::numeric_limits<float>::max ());
+  return (xfinite (x) && fabs (x) > std::numeric_limits<float>::max ());
 }
 
 bool xtoo_large_for_float (const Complex& x)
 {
   return (xtoo_large_for_float (x.real ())
           || xtoo_large_for_float (x.imag ()));
 }
 
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -1,12 +1,13 @@
 EXTRA_DIST += \
   util/module.mk
 
 UTIL_INC = \
+  util/action-container.h \
   util/base-list.h \
   util/byte-swap.h \
   util/caseless-str.h \
   util/cmd-edit.h \
   util/cmd-hist.h \
   util/data-conv.h \
   util/functor.h \
   util/glob-match.h \
@@ -29,23 +30,25 @@ UTIL_INC = \
   util/oct-mutex.h \
   util/oct-refcount.h \
   util/oct-rl-edit.h \
   util/oct-rl-hist.h \
   util/oct-shlib.h \
   util/oct-sort.h \
   util/oct-sparse.h \
   util/pathsearch.h \
-  util/regexp.h \
+  util/lo-regexp.h \
   util/singleton-cleanup.h \
   util/sparse-sort.h \
   util/sparse-util.h \
   util/statdefs.h \
   util/str-vec.h \
-  util/sun-utils.h 
+  util/sun-utils.h \
+  util/unwind-prot.h \
+  util/url-transfer.h
 
 UTIL_C_SRC = \
   util/f2c-main.c \
   util/lo-cieee.c \
   util/lo-cutils.c \
   util/oct-rl-edit.c \
   util/oct-rl-hist.c 
 
@@ -61,21 +64,23 @@ UTIL_SRC = \
   util/oct-base64.cc \
   util/oct-glob.cc \
   util/oct-inttypes.cc \
   util/oct-locbuf.cc \
   util/oct-md5.cc \
   util/oct-mutex.cc \
   util/oct-shlib.cc \
   util/pathsearch.cc \
-  util/regexp.cc \
+  util/lo-regexp.cc \
   util/singleton-cleanup.cc \
   util/sparse-sort.cc \
   util/sparse-util.cc \
   util/str-vec.cc \
+  util/unwind-prot.cc \
+  util/url-transfer.cc \
   $(UTIL_C_SRC)
 
 TEMPLATE_SRC += \
   util/oct-sort.cc
 
 OTHER_INC += \
   util/kpse.cc
 
diff --git a/liboctave/util/oct-rl-hist.c b/liboctave/util/oct-rl-hist.c
--- a/liboctave/util/oct-rl-hist.c
+++ b/liboctave/util/oct-rl-hist.c
@@ -284,22 +284,20 @@ octave_history_list (int limit, int numb
       k = 0;
       for (i = beg; i < end; i++)
         {
           char *line = hlist[i]->line;
           int len = line ? strlen (line) : 0;
           char *tmp = malloc (len + 64);
 
           if (number_lines)
-            sprintf (tmp, "%5d%c%s", i + history_base,
-                     hlist[i]->data ? '*' : ' ',
+            sprintf (tmp, "%5d %s", i + history_base,
                      line ? line : "");
           else
-            sprintf (tmp, "%c%s", hlist[i]->data ? '*' : ' ',
-                     line ? line : "");
+            strcpy (tmp, line ? line : "");
 
           retval[k++] = tmp;
         }
 
       retval[k] = 0;
     }
 
   return retval;
diff --git a/libinterp/corefcn/unwind-prot.cc b/liboctave/util/unwind-prot.cc
rename from libinterp/corefcn/unwind-prot.cc
rename to liboctave/util/unwind-prot.cc
--- a/libinterp/corefcn/unwind-prot.cc
+++ b/liboctave/util/unwind-prot.cc
@@ -20,16 +20,19 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "error.h"
+#include "lo-error.h"
 #include "unwind-prot.h"
 
-void unwind_protect_safe::gripe_exception (void)
+void
+unwind_protect_safe::gripe_exception (void)
 {
   // FIXME: can this throw an exception?
-  error ("internal: unhandled exception in unwind_protect handler");
+
+  (*current_liboctave_error_handler)
+    ("internal: unhandled exception in unwind_protect handler");
 }
diff --git a/libinterp/corefcn/unwind-prot.h b/liboctave/util/unwind-prot.h
rename from libinterp/corefcn/unwind-prot.h
rename to liboctave/util/unwind-prot.h
--- a/libinterp/corefcn/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -19,16 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_unwind_prot_h)
 #define octave_unwind_prot_h 1
 
+#include <cstddef>
+
 #include <stack>
 #include <memory>
 
 #include "action-container.h"
 
 class
 OCTINTERP_API
 unwind_protect : public action_container
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/util/url-transfer.cc
@@ -0,0 +1,799 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+Copyright (C) 2006-2012 Alexander Barth
+Copyright (C) 2009 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// Author: Alexander Barth <abarth@marine.usf.edu>
+// Author: jwe
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <fstream>
+#include <iomanip>
+#include <iostream>
+
+#include "dir-ops.h"
+#include "file-ops.h"
+#include "file-stat.h"
+#include "unwind-prot.h"
+#include "url-transfer.h"
+
+#ifdef HAVE_CURL
+#include <curl/curl.h>
+#include <curl/curlver.h>
+#include <curl/easy.h>
+#endif
+
+void base_url_transfer::delete_file (const std::string& file)
+{
+  octave_unlink (file);
+}
+
+void
+base_url_transfer::mget_directory (const std::string& directory,
+                                   const std::string& target)
+{
+  std::string sep = file_ops::dir_sep_str ();
+  file_stat fs (directory);
+
+  if (!fs || !fs.is_dir ())
+    {
+      std::string msg;
+      int status = octave_mkdir (directory, 0777, msg);
+
+      if (status < 0)
+        {
+          ok = false;
+          errmsg = "__ftp_mget__: can not create directory '"
+            + target + sep + directory + "': " + msg;
+          return;
+        }
+    }
+
+  cwd (directory);
+
+  if (good ())
+    {
+      unwind_protect_safe frame;
+
+      frame.add_fcn (reset_path, this);
+
+      string_vector sv = list ();
+
+      for (octave_idx_type i = 0; i < sv.length (); i++)
+        {
+          time_t ftime;
+          bool fisdir;
+          double fsize;
+
+          get_fileinfo (sv(i), fsize, ftime, fisdir);
+
+          if (fisdir)
+            mget_directory (sv(i), target + directory + sep);
+          else
+            {
+              std::string realfile = target + directory + sep + sv(i);
+
+              std::ofstream ofile (realfile.c_str (),
+                                   std::ios::out | std::ios::binary);
+
+              if (! ofile.is_open ())
+                {
+                  ok = false;
+                  errmsg = "__ftp_mget__: unable to open file";
+                  break;
+                }
+
+              unwind_protect_safe frame2;
+
+              frame2.add_fcn (delete_file, realfile);
+
+              get (sv(i), ofile);
+
+              ofile.close ();
+
+              if (good ())
+                frame2.discard ();
+            }
+
+          if (! good ())
+            break;
+        }
+    }
+}
+
+string_vector
+base_url_transfer::mput_directory (const std::string& base,
+                                   const std::string& directory)
+{
+  string_vector file_list;
+
+  std::string realdir
+    = (base.length () == 0
+       ? directory : base + file_ops::dir_sep_str () + directory);
+
+  mkdir (directory);
+
+  if (! good ())
+    return file_list;
+
+  cwd (directory);
+
+  if (good ())
+    {
+      unwind_protect_safe frame;
+
+      frame.add_fcn (reset_path, this);
+
+      dir_entry dirlist (realdir);
+
+      if (dirlist)
+        {
+          string_vector files = dirlist.read ();
+
+          for (octave_idx_type i = 0; i < files.length (); i++)
+            {
+              std::string file = files (i);
+
+              if (file == "." || file == "..")
+                continue;
+
+              std::string realfile = realdir + file_ops::dir_sep_str () + file;
+              file_stat fs (realfile);
+
+              if (! fs.exists ())
+                {
+                  ok = false;
+                  errmsg = "__ftp__mput: file '" + realfile
+                    + "' does not exist";
+                  break;
+                }
+
+              if (fs.is_dir ())
+                {
+                  file_list.append (mput_directory (realdir, file));
+
+                  if (! good ())
+                    break;
+                }
+              else
+                {
+                  // FIXME Does ascii mode need to be flagged here?
+                  std::ifstream ifile (realfile.c_str (), std::ios::in |
+                                       std::ios::binary);
+
+                  if (! ifile.is_open ())
+                    {
+                      ok = false;
+                      errmsg = "__ftp_mput__: unable to open file '"
+                        + realfile + "'";
+                      break;
+                    }
+
+                  put (file, ifile);
+
+                  ifile.close ();
+
+                  if (! good ())
+                    break;
+
+                  file_list.append (realfile);
+                }
+            }
+        }
+      else
+        {
+          ok = false;
+          errmsg = "__ftp_mput__: can not read the directory '"
+            + realdir + "'";
+        }
+    }
+}
+
+#if defined (HAVE_CURL)
+
+static int
+write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
+{
+  std::ostream& stream = *(static_cast<std::ostream*> (streamp));
+  stream.write (static_cast<const char*> (buffer), size*nmemb);
+  return (stream.fail () ? 0 : size * nmemb);
+}
+
+static int
+read_data (void *buffer, size_t size, size_t nmemb, void *streamp)
+{
+  std::istream& stream = *(static_cast<std::istream*> (streamp));
+  stream.read (static_cast<char*> (buffer), size*nmemb);
+  if (stream.eof ())
+    return stream.gcount ();
+  else
+    return (stream.fail () ? 0 : size * nmemb);
+}
+
+static size_t
+throw_away (void *, size_t size, size_t nmemb, void *)
+{
+  return static_cast<size_t>(size * nmemb);
+}
+
+// I'd love to rewrite this as a private method of the url_transfer
+// class, but you can't pass the va_list from the wrapper SETOPT to
+// the curl_easy_setopt function.
+#define SETOPT(option, parameter) \
+  do \
+    { \
+      CURLcode res = curl_easy_setopt (curl, option, parameter); \
+      if (res != CURLE_OK) \
+        { \
+          ok = false; \
+          errmsg = curl_easy_strerror (res); \
+          return; \
+        } \
+    } \
+  while (0)
+
+// Same as above but with a return value.
+#define SETOPTR(option, parameter) \
+  do \
+    { \
+      CURLcode res = curl_easy_setopt (curl, option, parameter); \
+      if (res != CURLE_OK) \
+        { \
+          ok = false; \
+          errmsg = curl_easy_strerror (res); \
+          return retval; \
+        } \
+    } \
+  while (0)
+
+class curl_transfer : public base_url_transfer
+{
+public:
+
+  curl_transfer (void)
+    : base_url_transfer (), curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      errmsg = "can not create curl object";
+  }
+
+  curl_transfer (const std::string& host_arg, const std::string& user_arg,
+                 const std::string& passwd, std::ostream& os)
+    : base_url_transfer (host_arg, user_arg, passwd, os),
+      curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      {
+        errmsg = "can not create curl object";
+        return;
+      }
+
+    init (user_arg, passwd, std::cin, os);
+
+    std::string url ("ftp://" + host_arg);
+    SETOPT (CURLOPT_URL, url.c_str ());
+
+    // Setup the link, with no transfer.
+    perform ();
+  }
+
+  curl_transfer (const std::string& url, const std::string& method,
+                 const Array<std::string>& param, std::ostream& os)
+    : base_url_transfer (url, method, param, os),
+      curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      {
+        errmsg = "can not create curl object";
+        return;
+      }
+
+    init ("", "", std::cin, os);
+
+    SETOPT (CURLOPT_NOBODY, 0);
+
+    // Restore the default HTTP request method to GET after setting
+    // NOBODY to true and back to false.  This is needed for backward
+    // compatibility with versions of libcurl < 7.18.2.
+    SETOPT (CURLOPT_HTTPGET, 1);
+
+    // Don't need to store the parameters here as we can't change
+    // the URL after the object is created
+    std::string query_string = form_query_string (param);
+
+    if (method == "get")
+      {
+        query_string = url + "?" + query_string;
+        SETOPT (CURLOPT_URL, query_string.c_str ());
+      }
+    else if (method == "post")
+      {
+        SETOPT (CURLOPT_URL, url.c_str ());
+        SETOPT (CURLOPT_POSTFIELDS, query_string.c_str ());
+      }
+    else
+      SETOPT (CURLOPT_URL, url.c_str ());
+
+    perform ();
+  }
+
+  ~curl_transfer (void)
+  {
+    if (curl)
+      curl_easy_cleanup (curl);
+  }
+
+  void perform (void)
+  {
+    BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+    errnum = curl_easy_perform (curl);
+
+    if (errnum != CURLE_OK)
+      {
+        ok = false;
+        errmsg = curl_easy_strerror (errnum);
+      }
+
+    END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+  }
+
+  std::string lasterror (void) const
+  {
+    return std::string (curl_easy_strerror (errnum));
+  }
+
+  std::ostream& set_ostream (std::ostream& os)
+  {
+    std::ostream& retval = *curr_ostream;
+    curr_ostream = &os;
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+    return retval;
+  }
+
+  std::istream& set_istream (std::istream& is)
+  {
+    std::istream& retval = *curr_istream;
+    curr_istream = &is;
+    SETOPTR (CURLOPT_READDATA, static_cast<void*> (curr_istream));
+    return retval;
+  }
+
+  void ascii (void)
+  {
+    ascii_mode = true;
+    SETOPT (CURLOPT_TRANSFERTEXT, 1);
+  }
+
+  void binary (void)
+  {
+    ascii_mode = false;
+    SETOPT (CURLOPT_TRANSFERTEXT, 0);
+  }
+
+  void cwd (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "cwd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void del (const std::string& file)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "dele " + file;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void rmdir (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "rmd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void mkdir (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "mkd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void rename (const std::string& oldname, const std::string& newname)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "rnfr " + oldname;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    cmd = "rnto " + newname;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void put (const std::string& file, std::istream& is)
+  {
+    std::string url = "ftp://" + host + "/" + file;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_UPLOAD, 1);
+    SETOPT (CURLOPT_NOBODY, 0);
+    std::istream& old_is = set_istream (is);
+
+    perform ();
+    if (! good ())
+      return;
+
+    set_istream (old_is);
+    SETOPT (CURLOPT_NOBODY, 1);
+    SETOPT (CURLOPT_UPLOAD, 0);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  void get (const std::string& file, std::ostream& os)
+  {
+    std::string url = "ftp://" + host + "/" + file;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_NOBODY, 0);
+    std::ostream& old_os = set_ostream (os);
+
+    perform ();
+    if (! good ())
+      return;
+
+    set_ostream (old_os);
+    SETOPT (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  void dir (void)
+  {
+    std::string url = "ftp://" + host + "/";
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_NOBODY, 0);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  string_vector list (void)
+  {
+    string_vector retval;
+
+    std::ostringstream buf;
+    std::string url = "ftp://" + host + "/";
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
+    SETOPTR (CURLOPT_URL, url.c_str ());
+    SETOPTR (CURLOPT_DIRLISTONLY, 1);
+    SETOPTR (CURLOPT_NOBODY, 0);
+
+    perform ();
+    if (! good ())
+      return retval;
+
+    SETOPTR (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+    SETOPTR (CURLOPT_DIRLISTONLY, 0);
+    SETOPTR (CURLOPT_URL, url.c_str ());
+
+    // Count number of directory entries
+    std::string str = buf.str ();
+    octave_idx_type n = 0;
+    size_t pos = 0;
+    while (true)
+      {
+        pos = str.find_first_of ('\n', pos);
+        if (pos == std::string::npos)
+          break;
+        pos++;
+        n++;
+      }
+    retval.resize (n);
+    pos = 0;
+    for (octave_idx_type i = 0; i < n; i++)
+      {
+        size_t newpos = str.find_first_of ('\n', pos);
+        if (newpos == std::string::npos)
+          break;
+
+        retval(i) = str.substr(pos, newpos - pos);
+        pos = newpos + 1;
+      }
+
+    return retval;
+  }
+
+  void get_fileinfo (const std::string& filename, double& filesize,
+                     time_t& filetime, bool& fileisdir)
+  {
+    std::string path = pwd ();
+
+    std::string url = "ftp://" + host + "/" + path + "/" + filename;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_FILETIME, 1);
+    SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
+    SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
+
+    // FIXME
+    // The MDTM command fails for a directory on the servers I tested
+    // so this is a means of testing for directories. It also means
+    // I can't get the date of directories!
+
+    perform ();
+    if (! good ())
+      {
+        fileisdir = true;
+        filetime = -1;
+        filesize = 0;
+
+        return;
+      }
+
+    fileisdir = false;
+    time_t ft;
+    curl_easy_getinfo (curl, CURLINFO_FILETIME, &ft);
+    filetime = ft;
+    double fs;
+    curl_easy_getinfo (curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+    filesize = fs;
+
+    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
+    SETOPT (CURLOPT_HEADERFUNCTION, 0);
+    SETOPT (CURLOPT_FILETIME, 0);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+
+    // The MDTM command seems to reset the path to the root with the
+    // servers I tested with, so cd again into the correct path. Make
+    // the path absolute so that this will work even with servers that
+    // don't end up in the root after an MDTM command.
+    cwd ("/" + path);
+  }
+
+  std::string pwd (void)
+  {
+    std::string retval;
+
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    slist = curl_slist_append (slist, "pwd");
+    SETOPTR (CURLOPT_POSTQUOTE, slist);
+    SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
+
+    std::ostringstream buf;
+    SETOPTR (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
+
+    perform ();
+    if (! good ())
+      return retval;
+
+    retval = buf.str ();
+
+    // Can I assume that the path is alway in "" on the last line
+    size_t pos2 = retval.rfind ('"');
+    size_t pos1 = retval.rfind ('"', pos2 - 1);
+    retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
+
+    SETOPTR (CURLOPT_HEADERFUNCTION, 0);
+    SETOPTR (CURLOPT_WRITEHEADER, 0);
+    SETOPTR (CURLOPT_POSTQUOTE, 0);
+
+    return retval;
+  }
+
+private:
+
+  CURL *curl;
+  CURLcode errnum;
+
+  // No copying!
+
+  curl_transfer (const curl_transfer&);
+
+  curl_transfer& operator = (const curl_transfer&);
+
+  void init (const std::string& user, const std::string& passwd,
+             std::istream& is, std::ostream& os)
+  {
+    // No data transfer by default
+    SETOPT (CURLOPT_NOBODY, 1);
+
+    // Set the username and password
+    userpwd = user;
+    if (! passwd.empty ())
+      userpwd += ":" + passwd;
+    if (! userpwd.empty ())
+      SETOPT (CURLOPT_USERPWD, userpwd.c_str ());
+
+    // Define our callback to get called when there's data to be written.
+    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
+
+    // Set a pointer to our struct to pass to the callback.
+    SETOPT (CURLOPT_WRITEDATA, static_cast<void*> (&os));
+
+    // Define our callback to get called when there's data to be read
+    SETOPT (CURLOPT_READFUNCTION, read_data);
+
+    // Set a pointer to our struct to pass to the callback.
+    SETOPT (CURLOPT_READDATA, static_cast<void*> (&is));
+
+    // Follow redirects.
+    SETOPT (CURLOPT_FOLLOWLOCATION, true);
+
+    // Don't use EPSV since connecting to sites that don't support it
+    // will hang for some time (3 minutes?) before moving on to try PASV
+    // instead.
+    SETOPT (CURLOPT_FTP_USE_EPSV, false);
+
+    SETOPT (CURLOPT_NOPROGRESS, true);
+    SETOPT (CURLOPT_FAILONERROR, true);
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+    SETOPT (CURLOPT_QUOTE, 0);
+  }
+
+  std::string form_query_string (const Array<std::string>& param)
+  {
+    std::ostringstream query;
+
+    for (int i = 0; i < param.numel (); i += 2)
+      {
+        std::string name = param(i);
+        std::string text = param(i+1);
+
+        // Encode strings.
+        char *enc_name = curl_easy_escape (curl, name.c_str (),
+                                           name.length ());
+        char *enc_text = curl_easy_escape (curl, text.c_str (),
+                                           text.length ());
+
+        query << enc_name << "=" << enc_text;
+
+        curl_free (enc_name);
+        curl_free (enc_text);
+
+        if (i < param.numel ()-1)
+          query << "&";
+      }
+
+    query.flush ();
+
+    return query.str ();
+  }
+};
+
+#undef SETOPT
+
+#else
+
+static void
+disabled_error (void)
+{
+  (*current_liboctave_error_handler)
+    ("support for url transfers was disabled when Octave was built");
+}
+
+#endif
+
+#if defined (HAVE_CURL)
+# define REP_CLASS curl_transfer
+#else
+# define REP_CLASS base_url_transfer
+#endif
+
+url_transfer::url_transfer (void) : rep (new REP_CLASS ())
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+url_transfer::url_transfer (const std::string& host, const std::string& user,
+                            const std::string& passwd, std::ostream& os)
+  : rep (new REP_CLASS (host, user, passwd, os))
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+url_transfer::url_transfer (const std::string& url, const std::string& method,
+                            const Array<std::string>& param, std::ostream& os)
+  : rep (new REP_CLASS (url, method, param, os))
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+#undef REP_CLASS
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
new file mode 100644
--- /dev/null
+++ b/liboctave/util/url-transfer.h
@@ -0,0 +1,265 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+Copyright (C) 2006-2012 Alexander Barth
+Copyright (C) 2009 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// Author: Alexander Barth <abarth@marine.usf.edu>
+// Author: jwe
+
+#if !defined (octave_url_transfer_h)
+#define octave_url_transfer_h 1
+
+#include <iosfwd>
+#include <string>
+
+class base_url_transfer
+{
+private:
+
+  static void delete_file (const std::string& file);
+
+  static void reset_path (base_url_transfer *curl_xfer)
+  {
+    curl_xfer->cwd ("..");
+  }
+
+public:
+
+  friend class url_transfer;
+
+  base_url_transfer (void)
+    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
+      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&std::cout)
+  { }
+
+  base_url_transfer (const std::string& host_arg,
+                     const std::string& /* user_arg */,
+                     const std::string& /* passwd */,
+                     std::ostream& os)
+    : count (1), host (host_arg), userpwd (), valid (false),
+      ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
+      curr_ostream (&os) { }
+
+  base_url_transfer (const std::string& /* url */,
+                     const std::string& /* method */,
+                     const Array<std::string>& /* param */,
+                     std::ostream& os)
+    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
+      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&os) { }
+
+  virtual ~base_url_transfer (void) { }
+
+  bool is_valid (void) const { return valid; }
+
+  bool good (void) const { return valid && ok; }
+
+  virtual void perform (void) { }
+
+  virtual std::string lasterror (void) const { return errmsg; }
+
+  virtual std::ostream& set_ostream (std::ostream& /* os */)
+  {
+    return *curr_ostream;
+  }
+
+  virtual std::istream& set_istream (std::istream& /* is */)
+  {
+    return *curr_istream;
+  }
+
+  virtual void ascii (void) { }
+
+  virtual void binary (void) { }
+
+  bool is_ascii (void) const { return ascii_mode; }
+
+  bool is_binary (void) const { return !ascii_mode; }
+
+  virtual void cwd (const std::string& /* path */) { } 
+
+  virtual void del (const std::string& /* file */) { }
+
+  virtual void rmdir (const std::string& /* path */) { }
+
+  virtual void mkdir (const std::string& /* path */) { }
+
+  virtual void rename (const std::string& /* oldname */,
+                       const std::string& /* newname */) { }
+
+  virtual void put (const std::string& /* file */,
+                    std::istream& /* is */) { }
+
+  virtual void get (const std::string& /* file */,
+                    std::ostream& /* os */) { }
+
+  void mget_directory (const std::string& directory,
+                       const std::string& target);
+
+  string_vector mput_directory (const std::string& base,
+                                const std::string& directory);
+
+  virtual void dir (void) { }
+
+  virtual string_vector list (void) { return string_vector (); }
+
+  virtual void get_fileinfo (const std::string& /* filename */,
+                             double& /* filesize */,
+                             time_t& /* filetime */,
+                             bool& /* fileisdir */) { }
+
+  virtual std::string pwd (void) { return std::string (); }
+
+protected:
+
+  octave_refcount<size_t> count;
+  std::string host;
+  std::string userpwd;
+  bool valid;
+  bool ascii_mode;
+  bool ok;
+  std::string errmsg;
+  std::istream *curr_istream;
+  std::ostream *curr_ostream;
+
+private:
+
+  // No copying!
+
+  base_url_transfer (const base_url_transfer&);
+
+  base_url_transfer& operator = (const base_url_transfer&);
+};
+
+class url_transfer
+{
+public:
+
+  url_transfer (void);
+
+  url_transfer (const std::string& host, const std::string& user,
+                const std::string& passwd, std::ostream& os);
+
+  url_transfer (const std::string& url, const std::string& method,
+                const Array<std::string>& param, std::ostream& os);
+
+  url_transfer (const url_transfer& h) : rep (h.rep)
+  {
+    rep->count++;
+  }
+
+  ~url_transfer (void)
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
+
+  url_transfer& operator = (const url_transfer& h)
+  {
+    if (this != &h)
+      {
+        if (--rep->count == 0)
+          delete rep;
+
+        rep = h.rep;
+        rep->count++;
+      }
+
+    return *this;
+  }
+
+  bool is_valid (void) const { return rep->is_valid (); }
+
+  bool good (void) const { return rep->good (); }
+
+  std::string lasterror (void) const { return rep->lasterror (); }
+
+  std::ostream& set_ostream (std::ostream& os)
+  {
+    return rep->set_ostream (os);
+  }
+
+  std::istream& set_istream (std::istream& is)
+  {
+    return rep->set_istream (is);
+  }
+
+  void ascii (void) { rep->ascii (); }
+
+  void binary (void) { rep->binary (); }
+
+  bool is_ascii (void) const { return rep->is_ascii (); }
+
+  bool is_binary (void) const { return rep->is_binary (); }
+
+  void cwd (const std::string& path) { rep->cwd (path); }
+
+  void del (const std::string& file) { rep->del (file); }
+
+  void rmdir (const std::string& path) { rep->rmdir (path); }
+
+  void mkdir (const std::string& path) { rep->mkdir (path); }
+
+  void rename (const std::string& oldname, const std::string& newname)
+  {
+    rep->rename (oldname, newname);
+  }
+
+  void put (const std::string& file, std::istream& is)
+  {
+    rep->put (file, is);
+  }
+
+  void get (const std::string& file, std::ostream& os)
+  {
+    rep->get (file, os);
+  }
+
+  void mget_directory (const std::string& directory,
+                       const std::string& target)
+  {
+    rep->mget_directory (directory, target);
+  }
+
+  string_vector mput_directory (const std::string& base,
+                                const std::string& directory)
+  {
+    return rep->mput_directory (base, directory);
+  }
+
+  void dir (void) { rep->dir (); }
+
+  string_vector list (void) { return rep->list (); }
+
+  void get_fileinfo (const std::string& filename, double& filesize,
+                     time_t& filetime, bool& fileisdir)
+  {
+    rep->get_fileinfo (filename, filesize, filetime, fileisdir);
+  }
+
+  std::string pwd (void) { return rep->pwd (); }
+
+private:
+
+  base_url_transfer *rep;
+};
+
+#endif
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1,24 +1,24 @@
 dnl aclocal.m4 -- extra macros for configuring Octave
 dnl
 dnl Copyright (C) 1995-2012 John W. Eaton
-dnl 
+dnl
 dnl This file is part of Octave.
-dnl 
+dnl
 dnl Octave is free software; you can redistribute it and/or modify it
 dnl under the terms of the GNU General Public License as published by the
 dnl Free Software Foundation; either version 3 of the License, or (at
 dnl your option) any later version.
-dnl 
+dnl
 dnl Octave is distributed in the hope that it will be useful, but WITHOUT
 dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 dnl for more details.
-dnl 
+dnl
 dnl You should have received a copy of the GNU General Public License
 dnl along with Octave; see the file COPYING.  If not, see
 dnl <http://www.gnu.org/licenses/>.
 dnl
 dnl
 dnl Copyright (C) 2008 - 2009 Free Software Foundation, Inc.
 dnl
 dnl If needed, define the m4_ifblank and m4_ifnblank macros from autoconf 2.64
@@ -79,17 +79,17 @@ AC_DEFUN([OCTAVE_CC_FLAG], [
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
       [eval "octave_cv_cc_flag_$ac_safe=yes"],
       [eval "octave_cv_cc_flag_$ac_safe=no"])
     CFLAGS="$ac_octave_save_CFLAGS"
     AC_LANG_POP(C)
   ])
   if eval "test \"`echo '$octave_cv_cc_flag_'$ac_safe`\" = yes"; then
     AC_MSG_RESULT([yes])
-    ifelse([$2], , 
+    ifelse([$2], ,
       [CFLAGS="$CFLAGS $1"
       AC_MSG_RESULT([adding $1 to CFLAGS])], [$2])
   else
     AC_MSG_RESULT([no])
     ifelse([$3], , , [$3])
   fi
 ])
 dnl
@@ -142,17 +142,17 @@ AC_DEFUN([OCTAVE_CHECK_FFTW_THREADS], [
   CPPFLAGS="$ac_octave_save_CPPFLAGS"
   LDFLAGS="$ac_octave_save_LDFLAGS"
   LIBS="$ac_octave_save_LIBS"
 ])
 dnl
 dnl Check whether a math mapper function is available in <cmath>.
 dnl Will define HAVE_CMATH_FUNC if there is a double variant and
 dnl HAVE_CMATH_FUNCF if there is a float variant.
-dnl Currently capable of checking for functions with single 
+dnl Currently capable of checking for functions with single
 dnl argument and returning bool/int/real.
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_CMATH], [
   ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
 
   AC_CACHE_CHECK([for std::$1 in <cmath>],
     [octave_cv_func_cmath_$ac_safe],
     [AC_LANG_PUSH(C++)
@@ -237,17 +237,17 @@ AC_DEFUN([OCTAVE_CHECK_FUNC_FORTRAN_ISNA
         print *, 'x is NaN'
       end if
       if (isnan(y)) then
         print *, 'y is NaN'
       end if
       end program
 ]],
       octave_cv_func_fortran_isnan=yes, octave_cv_func_fortran_isnan=no)
-    AC_LANG_POP(Fortran 77)      
+    AC_LANG_POP(Fortran 77)
   ])
 ])
 dnl
 dnl Check if function gluTessCallback is called with "(...)".
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_GLUTESSCALLBACK_THREEDOTS], [
   AC_CACHE_CHECK([whether gluTessCallback is called with "(...)"],
     [octave_cv_func_glutesscallback_threedots],
@@ -262,17 +262,17 @@ AC_DEFUN([OCTAVE_CHECK_FUNC_GLUTESSCALLB
         GLvoid (*func)(...);
         gluTessCallback(0, 0, func);
         ]])],
       octave_cv_func_glutesscallback_threedots=yes,
       octave_cv_func_glutesscallback_threedots=no)
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_func_glutesscallback_threedots = yes; then
-    AC_DEFINE(HAVE_GLUTESSCALLBACK_THREEDOTS, 1, 
+    AC_DEFINE(HAVE_GLUTESSCALLBACK_THREEDOTS, 1,
       [Define to 1 if gluTessCallback is called with (...).])
   fi
 ])
 dnl
 dnl Check whether Qscintilla SetPlaceholderText function exists.
 dnl FIXME: This test uses a version number.  It potentially could
 dnl        be re-written to actually call the function, but is it worth it?
 dnl
@@ -290,21 +290,64 @@ AC_DEFUN([OCTAVE_CHECK_FUNC_SETPLACEHOLD
         #endif
         ]])],
       octave_cv_func_setplaceholdertext=yes,
       octave_cv_func_setplaceholdertext=no)
     CPPFLAGS="$ac_octave_save_CPPFLAGS"
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_func_setplaceholdertext = yes; then
-    AC_DEFINE(HAVE_SETPLACEHOLDERTEXT, 1, 
+    AC_DEFINE(HAVE_SETPLACEHOLDERTEXT, 1,
       [Define to 1 if you have the Qt SetPlaceholderText function.])
   fi
 ])
 dnl
+dnl Check whether the Qt QAbstractItemModel::beginResetModel() function exists.
+dnl Also checks for QAbstractItemModel::endResetModel().  These are two of the
+dnl newest Qt functions that the Octave GUI depends on, added in Qt 4.6.
+dnl
+AC_DEFUN([OCTAVE_CHECK_FUNC_QABSTRACTITEMMODEL_BEGINRESETMODEL], [
+  AC_CACHE_CHECK([whether Qt has the QAbstractItemModel::beginResetModel() function],
+    [octave_cv_func_qabstractitemmodel_beginresetmodel],
+    [AC_LANG_PUSH(C++)
+    ac_octave_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+        #include <QAbstractItemModel>
+        class item_model : public QAbstractItemModel
+        {
+        public:
+          item_model (QObject *parent = 0) : QAbstractItemModel (parent) {}
+          ~item_model () {}
+          QModelIndex index (int, int, const QModelIndex& m) const { return m; }
+          QModelIndex parent (const QModelIndex& m) const { return m; }
+          int columnCount (const QModelIndex&) const { return 0; }
+          int rowCount (const QModelIndex&) const { return 0; }
+          QVariant data (const QModelIndex&, int) const { return QVariant(); }
+          void update_model ()
+          {
+            this->beginResetModel ();
+            this->endResetModel ();
+          }
+        };
+        ]], [[
+        item_model model;
+        model.update_model ();
+        ]])],
+      octave_cv_func_qabstractitemmodel_beginresetmodel=yes,
+      octave_cv_func_qabstractitemmodel_beginresetmodel=no)
+    CPPFLAGS="$ac_octave_save_CPPFLAGS"
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_func_qabstractitemmodel_beginresetmodel = yes; then
+    AC_DEFINE(HAVE_QABSTRACTITEMMODEL_BEGINRESETMODEL, 1,
+      [Define to 1 if Qt has the QAbstractItemModel::beginResetModel() function.])
+  fi
+])
+dnl
 dnl Check whether HDF5 library has version 1.6 API functions.
 dnl
 AC_DEFUN([OCTAVE_CHECK_HDF5_HAS_VER_16_API], [
   AC_CACHE_CHECK([whether HDF5 library has enforced version 1.6 API],
     [octave_cv_hdf5_has_ver_16_api],
     [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
       #include <hdf5.h>
       ]], [[
@@ -465,33 +508,33 @@ doit (void)
   ip[3] = 1;   // NB blocksize in recurrence
   ip[4] = 0;   // nconv, number of Ritz values that satisfy convergence
   ip[5] = 0;   // ip[5] not referenced
   ip[6] = 1;   // mode
   ip[7] = 0;   // ip[7] to ip[10] are return values
   ip[8] = 0;
   ip[9] = 0;
   ip[10] = 0;
- 
+
   int *ipntr = new int [14];
 
   int k = 1;
   int p = 3;
   int lwork = 3 * p * (p + 2);
 
   double *v = new double [n * (p + 1)];
   double *workl = new double [lwork + 1];
   double *workd = new double [3 * n + 1];
 
   int ido = 0;
   int info = 0;
 
   double tol = DBL_EPSILON;
 
-  do 
+  do
     {
       F77_FUNC (dnaupd, DNAUPD) (ido, "I", n, "LM", k, tol, resid, p,
                                  v, n, ip, ipntr, workd, workl, lwork,
                                  info, 1L, 2L);
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *x = workd + ipntr[0] - 1;
@@ -504,17 +547,17 @@ doit (void)
         {
           if (info < 0)
             {
               return;  // Error
             }
 
           break;
         }
-    } 
+    }
   while (1);
 
   int *sel = new int [p];
 
   // In Octave, the dimensions of dr and di are k+1, but k+2 avoids segfault
   double *dr = new double [k + 1];
   double *di = new double [k + 1];
   double *workev = new double [3 * p];
@@ -550,16 +593,52 @@ doit (void)
     $1
     :
   else
     $2
     :
   fi
 ])
 dnl
+dnl Check whether GLPK provides the latest API functions required
+dnl for the glpk function. The glp_iptcp structure was introduced
+dnl in GLPK version 4.38.
+dnl
+AC_DEFUN([OCTAVE_CHECK_LIB_GLPK_OK], [
+  AC_CACHE_CHECK([whether the glpk library has glp_interior(glp_prob*, glp_iptcp*)],
+    [octave_cv_lib_glpk_ok],
+    [AC_LANG_PUSH(C++)
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+        extern "C"
+        {
+        #if defined (HAVE_GLPK_GLPK_H)
+        #include <glpk/glpk.h>
+        #else
+        #include <glpk.h>
+        #endif
+        }
+        ]], [[
+        glp_prob *lp = glp_create_prob ();
+        glp_iptcp iptcp;
+        glp_init_iptcp (&iptcp);
+        int retval = glp_interior (lp, &iptcp);
+        ]])],
+      octave_cv_lib_glpk_ok=yes,
+      octave_cv_lib_glpk_ok=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_lib_glpk_ok = yes; then
+    $1
+    :
+  else
+    $2
+    :
+  fi
+])
+dnl
 dnl Check whether using HDF5 DLL under Windows.  This is done by
 dnl testing for a data symbol in the HDF5 library, which would
 dnl require the definition of _HDF5USEDL_ under MSVC compiler.
 dnl
 AC_DEFUN([OCTAVE_CHECK_LIB_HDF5_DLL], [
   AC_CACHE_CHECK([if _HDF5USEDLL_ needs to be defined],
     [octave_cv_lib_hdf5_dll],
     [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
@@ -632,32 +711,32 @@ AC_DEFUN([OCTAVE_CHECK_LIB_OPENGL], [
       ])
       break
       ], [], [
 #ifdef HAVE_WINDOWS_H
 # include <windows.h>
 #endif
     ])
 
-    if test "$have_opengl_incs" = yes; then
+    if test $have_opengl_incs = yes; then
       case $canonical_host_type in
         *-*-mingw32* | *-*-msdosmsvc)
           save_LIBS="$LIBS"
           LIBS="$LIBS -lopengl32"
           AC_MSG_CHECKING([for glEnable in -lopengl32])
           AC_LINK_IFELSE([AC_LANG_PROGRAM([[
             #if HAVE_WINDOWS_H
             # include <windows.h>
             #endif
             #if defined (HAVE_GL_GL_H)
             # include <GL/gl.h>
             #elif defined (HAVE_OPENGL_GL_H)
             # include <OpenGL/gl.h>
             #endif
-            ]], [[ 
+            ]], [[
             glEnable(GL_SMOOTH);
             ]])], [OPENGL_LIBS="-lopengl32 -lglu32"])
 
           LIBS="$save_LIBS"
           if test "x$OPENGL_LIBS" != "x"; then
             AC_MSG_RESULT([yes])
           else
             AC_MSG_RESULT([no])
@@ -710,17 +789,17 @@ AC_DEFUN([OCTAVE_CHECK_LIB_QHULL_OK], [
         #ifdef NEED_QHULL_VERSION
           char *qh_version = "version";
         #endif
         ]], [[
         int dim = 2;
         int n = 4;
         coordT points[8] = { -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5 };
         boolT ismalloc = 0;
-        return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr); 
+        return qh_new_qhull (dim, n, points, ismalloc, "qhull ", 0, stderr);
       ]])],
       octave_cv_lib_qhull_ok=yes,
       octave_cv_lib_qhull_ok=no,
       octave_cv_lib_qhull_ok=yes)
   ])
   if test $octave_cv_lib_qhull_ok = yes; then
     $1
     :
@@ -735,17 +814,17 @@ dnl
 AC_DEFUN([OCTAVE_CHECK_LIB_TERMLIB], [
   TERM_LIBS=
   ac_octave_save_LIBS="$LIBS"
   AC_SEARCH_LIBS([tputs],
                  [ncurses curses termcap terminfo termlib],
                  [], [])
   LIBS="$ac_octave_save_LIBS"
   case "$ac_cv_search_tputs" in
-    -l*)  
+    -l*)
       TERM_LIBS="$ac_cv_search_tputs"
     ;;
     no)
       warn_termlibs="I couldn't find -ltermcap, -lterminfo, -lncurses, -lcurses, or -ltermlib!"
       AC_MSG_WARN([$warn_termlibs])
     ;;
   esac
 
@@ -771,17 +850,17 @@ AC_DEFUN([OCTAVE_CHECK_OPENMP], [
   CFLAGS="$CFLAGS $1"
   AC_CACHE_VAL([octave_cv_check_openmp],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <omp.h>
         #include <stdio.h>
         ]], [[
         int main(int argc, char* argv[])
         {
-          _Pragma("omp parallel")  
+          _Pragma("omp parallel")
           printf("Hello, world.\n");
           return 0;
         }
       ]])],
       octave_cv_openmp=yes, octave_cv_openmmp=no, octave_cv_openmp=no)
   ])
   AC_MSG_RESULT([$octave_cv_openmp])
   if test $octave_cv_openmp = yes; then
@@ -823,17 +902,17 @@ AC_DEFUN([OCTAVE_CHECK_QHULL_VERSION], [
         # endif
         # include <qset.h>
         # include <geom.h>
         # include <poly.h>
         # include <io.h>
         #endif
         ]], [[
         const char *tmp = qh_version;
-      ]])], 
+      ]])],
       octave_cv_lib_qhull_version=yes, octave_cv_lib_qhull_version=no)
   ])
   if test $octave_cv_lib_qhull_version = no; then
     AC_DEFINE(NEED_QHULL_VERSION, 1,
       [Define to 1 if the Qhull library needs a qh_version variable defined.])
   fi
 ])
 dnl
@@ -993,34 +1072,34 @@ AC_DEFUN([OCTAVE_CXX_COMPLEX_SETTERS], [
         std::complex<double> x;
         x.real (1.0);
         x.imag (2.0);
       ]])],
       octave_cv_cxx_complex_setters=yes, octave_cv_cxx_complex_setters=no)
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_cxx_complex_setters = yes; then
-    AC_DEFINE(HAVE_CXX_COMPLEX_SETTERS, 1, 
+    AC_DEFINE(HAVE_CXX_COMPLEX_SETTERS, 1,
       [Define to 1 if C++ complex class has void real (T) and void imag (T) methods.])
   fi
 ])
 dnl
 dnl Check if the compiler supports dynamic auto arrays.
 dnl
 AC_DEFUN([OCTAVE_CXX_DYNAMIC_AUTO_ARRAYS], [
   AC_CACHE_CHECK([whether C++ supports dynamic auto arrays],
     [octave_cv_cxx_dynamic_auto_arrays],
     [AC_LANG_PUSH(C++)
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[
         void test(char *);
         int length();
         char x[length()];
         test(x);
       ]])],
-      octave_cv_cxx_dynamic_auto_arrays=yes, 
+      octave_cv_cxx_dynamic_auto_arrays=yes,
       octave_cv_cxx_dynamic_auto_arrays=no)
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_cxx_dynamic_auto_arrays = yes; then
     AC_DEFINE(HAVE_DYNAMIC_AUTO_ARRAYS, 1,
       [Define to 1 if C++ supports dynamic auto arrays.])
   fi
 ])
@@ -1082,23 +1161,23 @@ AC_DEFUN([OCTAVE_CXX_ISO_COMPLIANT_LIBRA
         digits = 0;
       ]])],
       octave_cv_cxx_iso_compliant_library=yes,
       octave_cv_cxx_iso_compliant_library=no)
     AC_LANG_POP(C++)
   ])
   AC_MSG_RESULT([$octave_cv_cxx_iso_compliant_library])
   if test $octave_cv_cxx_iso_compliant_library = yes; then
-    AC_DEFINE(CXX_ISO_COMPLIANT_LIBRARY, 1, 
+    AC_DEFINE(CXX_ISO_COMPLIANT_LIBRARY, 1,
       [Define to 1 if your C++ runtime library is ISO compliant.])
   fi
 ])
 dnl
 dnl Check if C++ compiler needs the new friend template declaration
-dnl syntax. 
+dnl syntax.
 dnl
 AC_DEFUN([OCTAVE_CXX_NEW_FRIEND_TEMPLATE_DECL], [
   AC_REQUIRE([AC_PROG_CXX])
   AC_MSG_CHECKING([for C++ support for new friend template declaration])
   AC_CACHE_VAL([octave_cv_cxx_new_friend_template_decl],
     [AC_LANG_PUSH(C++)
     rm -f conftest.h
     cat > conftest.h <<EOB
@@ -1136,17 +1215,17 @@ AC_DEFUN([OCTAVE_CXX_PLACEMENT_DELETE], 
   AC_CACHE_CHECK([whether <new> defines placement delete operator],
     [octave_cv_cxx_placement_delete],
     [AC_LANG_PUSH(C++)
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <new>
         ]], [[
         operator delete((void *)0, (void *)0);
       ]])],
-      octave_cv_cxx_placement_delete=yes, 
+      octave_cv_cxx_placement_delete=yes,
       octave_cv_cxx_placement_delete=no)
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_cxx_placement_delete = yes; then
     AC_DEFINE(HAVE_PLACEMENT_DELETE, 1,
       [Define to 1 if C++ supports operator delete(void *, void *).])
   fi
 ])
@@ -1225,44 +1304,44 @@ dnl    except for the shifts.  Shifts ar
 dnl
 AC_DEFUN([OCTAVE_FAST_INT_OPS], [
   AC_CACHE_CHECK([whether fast integer arithmetics is usable],
     [octave_cv_fast_int_ops],
     [AC_LANG_PUSH(C++)
     AC_RUN_IFELSE([AC_LANG_PROGRAM([[
         #include <limits>
         template<class UT, class ST>
-        static bool 
+        static bool
         do_test (UT, ST)
         {
           volatile ST s = std::numeric_limits<ST>::min () / 3;
           volatile UT u = static_cast<UT> (s);
           if (*(reinterpret_cast<volatile ST *> (&u)) != s) return true;
-          
+
           u = 0; u = ~u;
           if (*(reinterpret_cast<volatile ST *> (&u)) != -1) return true;
-          
+
           ST sx, sy;
           sx = std::numeric_limits<ST>::max () / 2 + 1;
           sy = std::numeric_limits<ST>::max () / 2 + 2;
           if (static_cast<ST> (static_cast<UT> (sx) + static_cast<UT> (sy))
               != std::numeric_limits<ST>::min () + 1) return true;
           if (static_cast<ST> (static_cast<UT> (sx) - static_cast<UT> (sy))
               != -1) return true;
-          
+
           if ((sx & sy) != (static_cast<UT> (sx) & static_cast<UT> (sy)))
             return true;
           if ((sx | sy) != (static_cast<UT> (sx) | static_cast<UT> (sy)))
             return true;
           if ((sx ^ sy) != (static_cast<UT> (sx) ^ static_cast<UT> (sy)))
             return true;
           if ((-1 >> 1) != -1) return true;
           return false;
         }
-      
+
         #define DO_TEST(T) \
           if (do_test (static_cast<unsigned T> (0), static_cast<signed T> (0)))\
             return sizeof (T);
 
         ]],[[
 
         DO_TEST(char)
         DO_TEST(short)
@@ -1300,17 +1379,17 @@ AC_DEFUN([OCTAVE_HAVE_FRAMEWORK], [
       eval "octave_cv_framework_$1=yes",
       eval "octave_cv_framework_$1=no")
     AC_LANG_POP(C++)
     LDFLAGS="$ac_octave_save_LDFLAGS"
   ])
   if test "$octave_cv_framework_$1" = yes; then
     AC_MSG_RESULT([yes])
     AC_ARG_WITH(framework-m4_tolower($1),
-      [AS_HELP_STRING([--without-framework-m4_tolower($1)], 
+      [AS_HELP_STRING([--without-framework-m4_tolower($1)],
         [don't use framework $1])],
          with_have_framework=$withval, with_have_framework=yes)
     if test "$with_have_framework" = yes; then
       [$4]
       :
     else
       AC_MSG_NOTICE([framework rejected by --without-framework-m4_tolower($1)])
       [$5]
@@ -1344,20 +1423,20 @@ AC_DEFUN([OCTAVE_CANONICAL_HOST], [
 dnl
 dnl Check for IEEE 754 data format.
 dnl
 AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
   AC_MSG_CHECKING([for IEEE 754 data format])
   AC_CACHE_VAL([octave_cv_ieee754_data_format],
     [AC_RUN_IFELSE([AC_LANG_SOURCE([[
         int
-        main (void) 
+        main (void)
         {
           typedef union { unsigned char c[8]; double d; } ieeebytes;
-           
+
           ieeebytes l = {0x1c, 0xbc, 0x6e, 0xf2, 0x54, 0x8b, 0x11, 0x43};
           ieeebytes b = {0x43, 0x11, 0x8b, 0x54, 0xf2, 0x6e, 0xbc, 0x1c};
 
           return l.d != 1234567891234567.0 && b.d != 1234567891234567.0;
         }
       ]])],
       octave_cv_ieee754_data_format=yes,
       octave_cv_ieee754_data_format=no,
@@ -1376,16 +1455,111 @@ AC_DEFUN([OCTAVE_IEEE754_DATA_FORMAT], [
     ## useful system, so we will abort here.  Anyone wishing to
     ## experiment with building Octave on a system without IEEE
     ## floating point should be capable of removing this check and
     ## the one in the octave_ieee_init function in liboctave/lo-ieee.cc.
     AC_MSG_ERROR([IEEE 754 data format required for building Octave])
   fi
 ])
 dnl
+dnl Check for CallInst::addAttribute API
+dnl
+AC_DEFUN([OCTAVE_LLVM_CALLINST_ADDATTRIBUTE_API], [
+  AC_CACHE_CHECK([check LLVM::CallInst::addAttribute arg type is llvm::Attributes],
+    [octave_cv_callinst_addattribute_arg_is_attributes],
+    [AC_LANG_PUSH(C++)
+      AC_COMPILE_IFELSE(
+        [AC_LANG_PROGRAM([
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+          #include <llvm/IR/Instructions.h>
+          #include <llvm/IR/Attributes.h>
+#else
+          #include <llvm/Instructions.h>
+          #include <llvm/Attributes.h>
+#endif
+          ], [[
+          llvm::CallInst *callinst;
+          llvm::AttrBuilder attr_builder;
+          attr_builder.addAttribute(llvm::Attributes::StructRet);
+          llvm::Attributes attrs = llvm::Attributes::get(llvm::getGlobalContext(), attr_builder);
+          callinst->addAttribute (1, attrs);
+        ]])],
+        octave_cv_callinst_addattribute_arg_is_attributes=yes,
+        octave_cv_callinst_addattribute_arg_is_attributes=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_callinst_addattribute_arg_is_attributes = yes; then
+    AC_DEFINE(CALLINST_ADDATTRIBUTE_ARG_IS_ATTRIBUTES, 1,
+      [Define to 1 if llvm::CallInst:addAttribute arg type is llvm::Attributes.])
+  fi
+])
+dnl
+dnl Check for Function::addAttribute API
+dnl
+AC_DEFUN([OCTAVE_LLVM_FUNCTION_ADDATTRIBUTE_API], [
+  AC_CACHE_CHECK([check llvm::Function::addAttribute arg type is llvm::Attributes],
+    [octave_cv_function_addattribute_arg_is_attributes],
+    [AC_LANG_PUSH(C++)
+      AC_COMPILE_IFELSE(
+        [AC_LANG_PROGRAM([[
+#ifdef HAVE_LLVM_IR_FUNCTION_H
+          #include <llvm/IR/Function.h>
+          #include <llvm/IR/Attributes.h>
+          #include <llvm/IR/LLVMContext.h>
+#else
+          #include <llvm/Function.h>
+          #include <llvm/Attributes.h>
+          #include <llvm/LLVMContext.h>
+#endif
+          ]], [[
+          llvm::Function *llvm_function;
+          llvm::AttrBuilder attr_builder;
+          attr_builder.addAttribute(llvm::Attributes::StructRet);
+          llvm::Attributes attrs = llvm::Attributes::get(llvm::getGlobalContext(), attr_builder);
+          llvm_function->addAttribute (1, attrs);
+        ]])],
+        octave_cv_function_addattribute_arg_is_attributes=yes,
+        octave_cv_function_addattribute_arg_is_attributes=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_function_addattribute_arg_is_attributes = yes; then
+    AC_DEFINE(FUNCTION_ADDATTRIBUTE_ARG_IS_ATTRIBUTES, 1,
+      [Define to 1 if llvm::Function:addAttribute arg type is llvm::Attributes.])
+  fi
+])
+dnl
+dnl Check for Function::addFnAttr API
+dnl
+AC_DEFUN([OCTAVE_LLVM_FUNCTION_ADDFNATTR_API], [
+  AC_CACHE_CHECK([check LLVM::Function::addFnAttr arg type is llvm::Attributes],
+    [octave_cv_function_addfnattr_arg_is_attributes],
+    [AC_LANG_PUSH(C++)
+      AC_COMPILE_IFELSE(
+        [AC_LANG_PROGRAM([[
+#ifdef LLVM_HAVE_IR_FUNCTION_H
+          #include <llvm/Function.h>
+          #include <llvm/Attributes.h>
+#else
+          #include <llvm/Function.h>
+          #include <llvm/Attributes.h>
+#endif
+          ]], [[
+          llvm::Function *llvm_function;
+          llvm_function->addFnAttr (llvm::Attributes::AlwaysInline);
+        ]])],
+        octave_cv_function_addfnattr_arg_is_attributes=yes,
+        octave_cv_function_addfnattr_arg_is_attributes=no)
+    AC_LANG_POP(C++)
+  ])
+  if test $octave_cv_function_addfnattr_arg_is_attributes = yes; then
+    AC_DEFINE(FUNCTION_ADDFNATTR_ARG_IS_ATTRIBUTES, 1,
+      [Define to 1 if llvm::Function:addFnAttr arg type is llvm::Attributes.])
+  fi
+])
+dnl
 dnl Check for ar.
 dnl
 AC_DEFUN([OCTAVE_PROG_AR], [
   if test -z "$AR"; then
     AR=ar
   fi
   AC_SUBST(AR)
 
@@ -1396,21 +1570,21 @@ AC_DEFUN([OCTAVE_PROG_AR], [
 ])
 dnl
 dnl Check for bison.
 dnl
 AC_DEFUN([OCTAVE_PROG_BISON], [
   AC_PROG_YACC
 
   case "`$YACC --version`" in
-    *bison*) tmp_have_bison="yes" ;;
+    *bison*) tmp_have_bison=yes ;;
     *) tmp_have_bison=no ;;
   esac
 
-  if test "$tmp_have_bison" = yes; then
+  if test $tmp_have_bison = yes; then
     AC_CACHE_CHECK([syntax of bison push/pull declaration],
                    [octave_cv_bison_push_pull_decl_style], [
       style="dash underscore"
       quote="noquote quote"
       for s in $style; do
         for q in $quote; do
           if test $s = "dash"; then
             def="%define api.push-pull"
@@ -1454,17 +1628,17 @@ EOF
     warn_bison_push_pull_decl_style="
 
 I wasn't able to find a suitable style for declaring a push-pull
 parser in a bison input file so I'm disabling bison.
 "
     OCTAVE_CONFIGURE_WARNING([warn_bison_push_pull_decl_style])
   fi
 
-  if test "$tmp_have_bison" = no; then
+  if test $tmp_have_bison = no; then
     YACC='$(top_srcdir)/build-aux/missing bison'
     warn_bison="
 
 I didn't find bison, but it's only a problem if you need to
 reconstruct parse.cc, which is the case if you're building from VCS
 sources.
 "
     OCTAVE_CONFIGURE_WARNING([warn_bison])
@@ -1569,17 +1743,17 @@ dnl Check for gperf.
 dnl
 AC_DEFUN([OCTAVE_PROG_GPERF], [
   AC_CHECK_PROG(GPERF, gperf, gperf, [])
   if test -z "$GPERF"; then
     GPERF='$(top_srcdir)/build-aux/missing gperf'
     warn_gperf="
 
 I didn't find gperf, but it's only a problem if you need to
-reconstruct oct-gperf.h 
+reconstruct oct-gperf.h
 "
     OCTAVE_CONFIGURE_WARNING([warn_gperf])
     GPERF='$(top_srcdir)/build-aux/missing gperf'
   fi
   AC_SUBST(GPERF)
 ])
 dnl
 dnl Check for makeinfo.
@@ -1756,17 +1930,17 @@ AC_DEFUN([OCTAVE_SET_DEFAULT], [
 ])
 dnl
 dnl Check whether SuiteSparse_time is required by UMFPACK.
 dnl UMFPACK >= 4 requires linking in another library for SuiteSparse_time.
 dnl
 dnl Macro assumes that the check for umfpack has already been performed.
 dnl
 AC_DEFUN([OCTAVE_UMFPACK_NEED_SUITESPARSE_TIME], [
-  AC_CACHE_CHECK([whether UMFPACK needs SuiteSparse_time function], 
+  AC_CACHE_CHECK([whether UMFPACK needs SuiteSparse_time function],
     [octave_cv_umfpack_need_suitesparse_time],
     [AC_LANG_PUSH(C)
     AC_LINK_IFELSE([AC_LANG_PROGRAM([[
         #if defined (HAVE_SUITESPARSE_UMFPACK_H)
         # include <suitesparse/umfpack.h>
         #elif defined (HAVE_UFSPARSE_UMFPACK_H)
         # include <ufsparse/umfpack.h>
         #elif defined (HAVE_UMFPACK_UMFPACK_H)
@@ -1809,81 +1983,81 @@ AC_DEFUN([OCTAVE_UMFPACK_SEPARATE_SPLIT]
         #define UMFPACK_NAME(name) umfpack_zl_ ## name
         #else
         typedef int idx_type;
         #define UMFPACK_NAME(name) umfpack_zi_ ## name
         #endif
         idx_type n = 5;
         idx_type Ap[] = {0, 2, 5, 9, 10, 12};
         idx_type Ai[]  = {0, 1, 0, 2, 4, 1, 2, 3, 4, 2, 1, 4};
-        double Ax[] = {2., 0., 3., 0., 3., 0., -1., 0., 4., 0., 4., 0., 
+        double Ax[] = {2., 0., 3., 0., 3., 0., -1., 0., 4., 0., 4., 0.,
                       -3., 0., 1., 0., 2., 0., 2., 0., 6., 0., 1., 0.};
         double br[] = {8., 45., -3., 3., 19.};
         double bi[] = {0., 0., 0., 0., 0.};
         int main (void)
         {
           double *null = (double *) NULL ;
           double *x = (double *)malloc (2 * n * sizeof(double));
           idx_type i ;
           void *Symbolic, *Numeric ;
           (void) UMFPACK_NAME (symbolic) (n, n, Ap, Ai, Ax, null, &Symbolic, null, null) ;
           (void) UMFPACK_NAME (numeric) (Ap, Ai, Ax, null, Symbolic, &Numeric, null, null) ;
           UMFPACK_NAME (free_symbolic) (&Symbolic) ;
-          (void) UMFPACK_NAME (solve) (0, Ap, Ai, Ax, null, x, null, br, bi, 
+          (void) UMFPACK_NAME (solve) (0, Ap, Ai, Ax, null, x, null, br, bi,
                                    Numeric, null, null) ;
           UMFPACK_NAME (free_numeric) (&Numeric) ;
-          for (i = 0; i < n; i++, x+=2) 
+          for (i = 0; i < n; i++, x+=2)
             if (fabs (*x - i - 1.) > 1.e-13)
               return (1);
           return (0) ;
         }
       ]])],
       octave_cv_umfpack_separate_split=yes,
       octave_cv_umfpack_separate_split=no,
       octave_cv_umfpack_separate_split=yes)
   ])
   if test "$cross_compiling" = yes; then
     AC_MSG_RESULT([$octave_cv_umfpack_separate_split assumed for cross compilation])
   else
     AC_MSG_RESULT([$octave_cv_umfpack_separate_split])
   fi
   if test $octave_cv_umfpack_separate_split = yes; then
-    AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1, 
+    AC_DEFINE(UMFPACK_SEPARATE_SPLIT, 1,
       [Define to 1 if the UMFPACK Complex solver allows matrix and RHS to be split independently.])
   fi
 ])
 dnl
 dnl Check for unordered map headers and whether tr1 namespace is
 dnl required.
 dnl
 AC_DEFUN([OCTAVE_UNORDERED_MAP_HEADERS], [
   AC_CHECK_HEADERS([unordered_map], [],
     [AC_CHECK_HEADERS([tr1/unordered_map])])
-  AC_CACHE_CHECK([whether unordered_map requires tr1 namespace], 
+  AC_CACHE_CHECK([whether unordered_map requires tr1 namespace],
     [octave_cv_header_require_tr1_namespace],
     [AC_LANG_PUSH(C++)
     octave_cv_header_require_tr1_namespace=no
     if test $ac_cv_header_unordered_map = yes; then
       ## Have <unordered_map>, but still have to check whether
       ## tr1 namespace is required (like MSVC, for instance).
       AC_COMPILE_IFELSE(
         [AC_LANG_PROGRAM([[
           #include <unordered_map>
           ]], [[
           std::unordered_map<int,int> m;
         ]])],
-        octave_cv_header_require_tr1_namespace=no, 
+        octave_cv_header_require_tr1_namespace=no,
         octave_cv_header_require_tr1_namespace=yes)
     elif test $ac_cv_header_tr1_unordered_map = yes; then
       octave_cv_header_require_tr1_namespace=yes
     fi
     AC_LANG_POP(C++)
   ])
   if test $octave_cv_header_require_tr1_namespace = yes; then
-    AC_DEFINE(USE_UNORDERED_MAP_WITH_TR1, 1, 
+    AC_DEFINE(USE_UNORDERED_MAP_WITH_TR1, 1,
       [Define to 1 if unordered_map requires the use of tr1 namespace.])
   fi
 ])
 
 dnl         End of macros written by Octave developers
 dnl ------------------------------------------------------------
 dnl
 
diff --git a/scripts/@ftp/ascii.m b/scripts/@ftp/ascii.m
--- a/scripts/@ftp/ascii.m
+++ b/scripts/@ftp/ascii.m
@@ -24,8 +24,9 @@
 ## representation.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function ascii (f)
   __ftp_ascii__ (f.curlhandle);
 endfunction
+
diff --git a/scripts/@ftp/binary.m b/scripts/@ftp/binary.m
--- a/scripts/@ftp/binary.m
+++ b/scripts/@ftp/binary.m
@@ -23,8 +23,9 @@
 ## representation to the local representation.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function binary (f)
   __ftp_binary__ (f.curlhandle);
 endfunction
+
diff --git a/scripts/@ftp/cd.m b/scripts/@ftp/cd.m
--- a/scripts/@ftp/cd.m
+++ b/scripts/@ftp/cd.m
@@ -36,8 +36,9 @@ function path = cd (f, path)
     print_usage ();
   endif
 
   if (nargin == 2)
     __ftp_cwd__ (f.curlhandle, path);
   endif
   path = __ftp_pwd__ (f.curlhandle);
 endfunction
+
diff --git a/scripts/@ftp/close.m b/scripts/@ftp/close.m
--- a/scripts/@ftp/close.m
+++ b/scripts/@ftp/close.m
@@ -18,11 +18,12 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} close (@var{f})
 ## Close the FTP connection represented by the FTP object @var{f}.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function dir (f)
+function close (f)
   __ftp_close__ (f.curlhandle);
 endfunction
+
diff --git a/scripts/@ftp/delete.m b/scripts/@ftp/delete.m
--- a/scripts/@ftp/delete.m
+++ b/scripts/@ftp/delete.m
@@ -21,8 +21,9 @@
 ## Delete the remote file @var{file} over the FTP connection @var{f}.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function delete (f, file)
   __ftp_delete__ (f.curlhandle, file);
 endfunction
+
diff --git a/scripts/@ftp/dir.m b/scripts/@ftp/dir.m
--- a/scripts/@ftp/dir.m
+++ b/scripts/@ftp/dir.m
@@ -26,8 +26,9 @@
 
 function lst = dir (f)
   if (nargout == 0)
     __ftp_dir__ (f.curlhandle);
   else
     lst = __ftp_dir__ (f.curlhandle);
   endif
 endfunction
+
diff --git a/scripts/@ftp/display.m b/scripts/@ftp/display.m
--- a/scripts/@ftp/display.m
+++ b/scripts/@ftp/display.m
@@ -17,9 +17,10 @@
 ## <http://www.gnu.org/licenses/>.
 
 function display (obj)
   printf ("FTP Object\n");
   printf (" host: %s\n", obj.host);
   printf (" user: %s\n", obj.username);
   printf ("  dir: %s\n", __ftp_pwd__ (obj.curlhandle));
   printf (" mode: %s\n", __ftp_mode__ (obj.curlhandle));
-endfunction
\ No newline at end of file
+endfunction
+
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{f} =} ftp (@var{host})
 ## @deftypefnx {Function File} {@var{f} =} ftp (@var{host}, @var{username}, @var{password})
 ## Connect to the FTP server @var{host} with @var{username} and @var{password}.
-## If @var{username} and @var{password} are not specified, user "anonymous"
-## with no password is used.  The returned FTP object @var{f} represents the
-## established FTP connection.
+## If @var{username} and @var{password} are not specified, user
+## @qcode{"anonymous"} with no password is used.  The returned FTP object
+## @var{f} represents the established FTP connection.
 ##
 ## The list of actions for an FTP object are shown below.  All functions
 ## require an FTP object as the first argument.
 ##
 ## @multitable @columnfractions 0.15 0.8
 ## @headitem Method @tab Description
 ## @item ascii @tab Set transfer type to ascii
 ## @item binary @tab Set transfer type to binary
@@ -48,13 +48,14 @@ function obj = ftp (host = "", username 
   if (nargin == 1 && isa (host, "ftp"))
     obj = host;   # Copy constructor
   else
     p.host = host;
     p.username = username;
     p.password = password;
     p.curlhandle = tmpnam ("ftp-");
     if (nargin > 0)
-      __ftp__ (p.curlhandle, host, username, password);
+      p.curlhandle = __ftp__ (host, username, password);
     endif
     obj = class (p, "ftp");
   endif
 endfunction
+
diff --git a/scripts/@ftp/loadobj.m b/scripts/@ftp/loadobj.m
--- a/scripts/@ftp/loadobj.m
+++ b/scripts/@ftp/loadobj.m
@@ -16,21 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function b = loadobj (a)
   b = a;
   if (isfield (b, "jobject"))
     b = rmfield (b, "jobject");
   endif
-  b.curlhandle = tmpnam ("ftp-");
-  __ftp__ (b.curlhandle, b.host, b.username, b.password);
+  b.curlhandle = __ftp__ (b.host, b.username, b.password);
   if (isfield (b, "dir"))
     if (! isempty (b.dir))
       __ftp_cwd__ (b.curlhandle, b.dir);
     endif
     b = rmfield (b, "dir");
   elseif (isfield (b, "remotePwd"))
     ## FIXME: Can we read matlab java stringBuffer objects?
     warning ("can not change remote directory in loaded FTP object");
     b = rmfield (b, "remotePwd");
   endif
 endfunction
+
diff --git a/scripts/@ftp/mget.m b/scripts/@ftp/mget.m
--- a/scripts/@ftp/mget.m
+++ b/scripts/@ftp/mget.m
@@ -30,8 +30,9 @@
 ## If a third argument @var{target} is given, then a single file or
 ## directory will be downloaded to the local directory and the local name
 ## will be changed to @var{target}.
 ## @end deftypefn
 
 function mget (f, file)
   __ftp_mget__ (f.curlhandle, file);
 endfunction
+
diff --git a/scripts/@ftp/mkdir.m b/scripts/@ftp/mkdir.m
--- a/scripts/@ftp/mkdir.m
+++ b/scripts/@ftp/mkdir.m
@@ -21,8 +21,9 @@
 ## Create the remote directory @var{path}, over the FTP connection @var{f}.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function mkdir (f, path)
   __ftp_mkdir__ (f.curlhandle, path);
 endfunction
+
diff --git a/scripts/@ftp/mput.m b/scripts/@ftp/mput.m
--- a/scripts/@ftp/mput.m
+++ b/scripts/@ftp/mput.m
@@ -28,8 +28,9 @@
 
 function retval = mput (f, file)
   if (nargout == 0)
     __ftp_mput__ (f.curlhandle, file);
   else
     retval = __ftp_mput__ (f.curlhandle, file);
   endif
 endfunction
+
diff --git a/scripts/@ftp/rename.m b/scripts/@ftp/rename.m
--- a/scripts/@ftp/rename.m
+++ b/scripts/@ftp/rename.m
@@ -22,8 +22,9 @@
 ## over the FTP connection @var{f}.
 ##
 ## @var{f} is an FTP object returned by the ftp function.
 ## @end deftypefn
 
 function rename (f, oldname, newname)
   __ftp_rename__ (f.curlhandle, oldname, newname);
 endfunction
+
diff --git a/scripts/@ftp/rmdir.m b/scripts/@ftp/rmdir.m
--- a/scripts/@ftp/rmdir.m
+++ b/scripts/@ftp/rmdir.m
@@ -21,8 +21,9 @@
 ## Remove the remote directory @var{path}, over the FTP connection @var{f}.
 ##
 ## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function rmdir (f, path)
   __ftp_rmdir__ (f.curlhandle, path);
 endfunction
+
diff --git a/scripts/@ftp/saveobj.m b/scripts/@ftp/saveobj.m
--- a/scripts/@ftp/saveobj.m
+++ b/scripts/@ftp/saveobj.m
@@ -14,10 +14,11 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function b = saveobj (a)
   b = a;
   b = rmfield (b, "curlhandle");
-  b.dir = __ftp_pwd (a.curlhandle);
+  b.dir = __ftp_pwd__ (a.curlhandle);
 endfunction
+
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -15,18 +15,16 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AUTOMAKE_OPTIONS = subdir-objects
-
 EXTRA_DIST =
 
 CLEANFILES =
 
 DISTCLEANFILES =
 
 FCN_FILE_DIRS =
 
@@ -44,26 +42,29 @@ JAR_FILES =
 
 ## Read subdirs to set all variables above
 include @ftp/module.mk
 include audio/module.mk
 include deprecated/module.mk
 include elfun/module.mk
 include general/module.mk
 include geometry/module.mk
+include gui/module.mk
 include help/module.mk
 include image/module.mk
 include io/module.mk
 include java/module.mk
 include linear-algebra/module.mk
 include miscellaneous/module.mk
 include optimization/module.mk
 include path/module.mk
 include pkg/module.mk
-include plot/module.mk
+include plot/appearance/module.mk
+include plot/draw/module.mk
+include plot/util/module.mk
 include polynomial/module.mk
 include prefs/module.mk
 include set/module.mk
 include signal/module.mk
 include sparse/module.mk
 include specfun/module.mk
 include special-matrix/module.mk
 include startup/module.mk
@@ -109,16 +110,20 @@ elfun/PKG_ADD: $(elfun_FCN_FILES) $(elfu
 general/PKG_ADD: $(general_FCN_FILES) $(general_GEN_FCN_FILES) general/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(general_FCN_FILES) -- $(general_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 geometry/PKG_ADD: $(geometry_FCN_FILES) $(geometry_GEN_FCN_FILES) geometry/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(geometry_FCN_FILES) -- $(geometry_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
+gui/PKG_ADD: $(gui_FCN_FILES) $(gui_GEN_FCN_FILES) gui/$(octave_dirstamp) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(srcdir) $(gui_FCN_FILES) -- $(gui_GEN_FCN_FILES) > $@-t
+	mv $@-t $@
+
 help/PKG_ADD: $(help_FCN_FILES) $(help_GEN_FCN_FILES) help/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(help_FCN_FILES) -- $(help_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 image/PKG_ADD: $(image_FCN_FILES) $(image_GEN_FCN_FILES) image/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(image_FCN_FILES) -- $(image_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
@@ -145,18 +150,26 @@ optimization/PKG_ADD: $(optimization_FCN
 path/PKG_ADD: $(path_FCN_FILES) $(path_GEN_FCN_FILES) path/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(path_FCN_FILES) -- $(path_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 pkg/PKG_ADD: $(pkg_FCN_FILES) $(pkg_GEN_FCN_FILES) pkg/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(pkg_FCN_FILES) -- $(pkg_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
-plot/PKG_ADD: $(plot_FCN_FILES) $(plot_GEN_FCN_FILES) plot/$(octave_dirstamp) mk-pkg-add
-	$(srcdir)/mk-pkg-add $(srcdir) $(plot_FCN_FILES) -- $(plot_GEN_FCN_FILES) > $@-t
+plot/appearance/PKG_ADD: $(plot_appearance_FCN_FILES) $(plot_appearance_GEN_FCN_FILES) plot/appearance/$(octave_dirstamp) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(srcdir) $(plot_appearance_FCN_FILES) -- $(plot_appearance_GEN_FCN_FILES) > $@-t
+	mv $@-t $@
+
+plot/draw/PKG_ADD: $(plot_draw_FCN_FILES) $(plot_draw_GEN_FCN_FILES) plot/draw/$(octave_dirstamp) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(srcdir) $(plot_draw_FCN_FILES) -- $(plot_draw_GEN_FCN_FILES) > $@-t
+	mv $@-t $@
+
+plot/util/PKG_ADD: $(plot_util_FCN_FILES) $(plot_util_GEN_FCN_FILES) plot/util/$(octave_dirstamp) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(srcdir) $(plot_util_FCN_FILES) -- $(plot_util_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 polynomial/PKG_ADD: $(polynomial_FCN_FILES) $(polynomial_GEN_FCN_FILES) polynomial/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(polynomial_FCN_FILES) -- $(polynomial_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 prefs/PKG_ADD: $(prefs_FCN_FILES) $(prefs_GEN_FCN_FILES) prefs/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(prefs_FCN_FILES) -- $(prefs_GEN_FCN_FILES) > $@-t
@@ -219,26 +232,29 @@ ui/PKG_ADD: $(ui_FCN_FILES) $(ui_GEN_FCN
 	mv $@-t $@
 
 $(@ftp_GEN_FCN_FILES): @ftp/$(octave_dirstamp)
 $(audio_GEN_FCN_FILES): audio/$(octave_dirstamp)
 $(deprecated_GEN_FCN_FILES): deprecated/$(octave_dirstamp)
 $(elfun_GEN_FCN_FILES): elfun/$(octave_dirstamp)
 $(general_GEN_FCN_FILES): general/$(octave_dirstamp)
 $(geometry_GEN_FCN_FILES): geometry/$(octave_dirstamp)
+$(gui_GEN_FCN_FILES): gui/$(octave_dirstamp)
 $(help_GEN_FCN_FILES): help/$(octave_dirstamp)
 $(image_GEN_FCN_FILES): image/$(octave_dirstamp)
 $(io_GEN_FCN_FILES): io/$(octave_dirstamp)
 $(java_GEN_FCN_FILES): java/$(octave_dirstamp)
 $(linear_algebra_GEN_FCN_FILES): linear-algebra/$(octave_dirstamp)
 $(miscellaneous_GEN_FCN_FILES): miscellaneous/$(octave_dirstamp)
 $(optimization_GEN_FCN_FILES): optimization/$(octave_dirstamp)
 $(path_GEN_FCN_FILES): path/$(octave_dirstamp)
 $(pkg_GEN_FCN_FILES): pkg/$(octave_dirstamp)
-$(plot_GEN_FCN_FILES): plot/$(octave_dirstamp)
+$(plot_appearance_GEN_FCN_FILES): plot/appearance/$(octave_dirstamp)
+$(plot_draw_GEN_FCN_FILES): plot/draw/$(octave_dirstamp)
+$(plot_util_GEN_FCN_FILES): plot/util/$(octave_dirstamp)
 $(polynomial_GEN_FCN_FILES): polynomial/$(octave_dirstamp)
 $(prefs_GEN_FCN_FILES): prefs/$(octave_dirstamp)
 $(set_GEN_FCN_FILES): set/$(octave_dirstamp)
 $(signal_GEN_FCN_FILES): signal/$(octave_dirstamp)
 $(sparse_GEN_FCN_FILES): sparse/$(octave_dirstamp)
 $(specfun_GEN_FCN_FILES): specfun/$(octave_dirstamp)
 $(special_matrix_GEN_FCN_FILES): special-matrix/$(octave_dirstamp)
 $(startup_GEN_FCN_FILES): startup/$(octave_dirstamp)
@@ -264,16 +280,19 @@ elfun/$(octave_dirstamp):
 	$(MKDIR_P) elfun
 	: > elfun/$(octave_dirstamp)
 general/$(octave_dirstamp):
 	$(MKDIR_P) general
 	: > general/$(octave_dirstamp)
 geometry/$(octave_dirstamp):
 	$(MKDIR_P) geometry
 	: > geometry/$(octave_dirstamp)
+gui/$(octave_dirstamp):
+	$(MKDIR_P) gui
+	: > gui/$(octave_dirstamp)
 help/$(octave_dirstamp):
 	$(MKDIR_P) help
 	: > help/$(octave_dirstamp)
 image/$(octave_dirstamp):
 	$(MKDIR_P) image
 	: > image/$(octave_dirstamp)
 io/$(octave_dirstamp):
 	$(MKDIR_P) io
@@ -291,19 +310,25 @@ optimization/$(octave_dirstamp):
 	$(MKDIR_P) optimization
 	: > optimization/$(octave_dirstamp)
 path/$(octave_dirstamp):
 	$(MKDIR_P) path
 	: > path/$(octave_dirstamp)
 pkg/$(octave_dirstamp):
 	$(MKDIR_P) pkg
 	: > pkg/$(octave_dirstamp)
-plot/$(octave_dirstamp):
-	$(MKDIR_P) plot
-	: > plot/$(octave_dirstamp)
+plot/appearance/$(octave_dirstamp):
+	$(MKDIR_P) plot/appearance
+	: > plot/appearance/$(octave_dirstamp)
+plot/draw/$(octave_dirstamp):
+	$(MKDIR_P) plot/draw
+	: > plot/draw/$(octave_dirstamp)
+plot/util/$(octave_dirstamp):
+	$(MKDIR_P) plot/util
+	: > plot/util/$(octave_dirstamp)
 polynomial/$(octave_dirstamp):
 	$(MKDIR_P) polynomial
 	: > polynomial/$(octave_dirstamp)
 prefs/$(octave_dirstamp):
 	$(MKDIR_P) prefs
 	: > prefs/$(octave_dirstamp)
 set/$(octave_dirstamp):
 	$(MKDIR_P) set
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -69,8 +69,9 @@ function y = lin2mu (x, n)
   x = min (abs (x), 32635) + 132;
 
   ## Find exponent and fraction of bineary representation.
   [f, e] = log2 (x);
 
   y = 64 * sig - 16 * e - fix (32 * f) + 335;
 
 endfunction
+
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -74,8 +74,9 @@ function X = loadaudio (name, ext, bps)
   else
     fclose (num);
     error ("loadaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
+
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -75,8 +75,9 @@ function y = mu2lin (x, n = 0)
       sc = 64 / ld;
     else
       sc = 1 / 256;
     endif
     y = fix (y * sc);
   endif
 
 endfunction
+
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -58,8 +58,9 @@ function X = record (sec, sampling_rate)
 
     unlink (file);
 
   end_unwind_protect
 
   X = Y - 127;
 
 endfunction
+
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -81,8 +81,9 @@ function saveaudio (name, x, ext, bps)
   else
     fclose (num);
     error ("saveaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
+
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -36,8 +36,9 @@ function setaudio (w_type, value)
     system (sprintf ("mixer %s", w_type));
   elseif (nargin == 2)
     system (sprintf ("mixer %s %d", w_type, value));
   else
     print_usage ();
   endif
 
 endfunction
+
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -172,18 +172,18 @@ function [y, samples_per_sec, bits_per_s
       elseif (nparams == 2)
         ## Sample range is given.
         if (fseek (fid, (param(1)-1) * channels * (bits_per_sample/8), "cof") < 0)
           warning ("wavread: seeking failed");
         endif
         length = (param(2)-param(1)+1) * channels;
       elseif (nparams == 4 && char (param) == "size")
         ## Size of the file is requested.
-        tmp = idivide (8 * data_size, channels * bits_per_sample);
-        y = [tmp, channels];
+        y = idivide (8 * data_size, channels * bits_per_sample);
+        samples_per_sec = channels;
         return;
       else
         error ("wavread: invalid PARAM argument");
       endif
     endif
 
     ## Read samples and close file.
     if (bits_per_sample == 24)
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -149,51 +149,70 @@ function wavwrite (y, varargin)
 
 endfunction
 
 
 %!shared fname
 %! fname = tmpnam ();
 
 %!test
-%! A = [-1:0.1:1; -1:0.1:1];
+%! A = [-1:0.1:1; -1:0.1:1]';
 %! wavwrite (A, fname);
 %! [B, samples_per_sec, bits_per_sample] = wavread (fname);
+%! unlink (fname);
 %! assert (A,B, 1/2^15);
 %! assert (samples_per_sec, 8000);
 %! assert (bits_per_sample, 16);
-%! unlink (fname);
-%
+
 %!test
-%! A = [-1:0.1:1; -1:0.1:1];
+%! A = [-1:0.1:1; -1:0.1:1]';
 %! wavwrite (A, 4000, fname);
 %! [B, samples_per_sec, bits_per_sample] = wavread (fname);
+%! unlink (fname);
 %! assert (A,B, 1/2^15);
 %! assert (samples_per_sec, 4000);
 %! assert (bits_per_sample, 16);
-%! unlink (fname);
-%
+
 %!test
-%! A = [-1:0.1:1; -1:0.1:1];
+%! A = [-1:0.1:1; -1:0.1:1]';
 %! wavwrite (A, 4000, 8, fname);
 %! [B, samples_per_sec, bits_per_sample] = wavread (fname);
+%! unlink (fname);
 %! assert (A,B, 1/128);
 %! assert (samples_per_sec, 4000);
 %! assert (bits_per_sample, 8);
-%! unlink (fname);
-%
+
 %!test
 %! A = [-2:2]';
 %! wavwrite (A, fname);
 %! B = wavread (fname);
+%! unlink (fname);
 %! B *= 32768;
 %! assert (B, [-32768 -32768 0 32767 32767]');
-%! unlink (fname);
-%
+
 %!test
 %! A = [-1:0.1:1];
 %! wavwrite (A, fname);
 %! [B, samples_per_sec, bits_per_sample] = wavread (fname);
+%! unlink (fname);
 %! assert (A', B, 1/2^15);
 %! assert (samples_per_sec, 8000);
 %! assert (bits_per_sample, 16);
+
+%!test
+%! A = [-1:0.1:1; -1:0.1:1]';
+%! wavwrite (A, fname);
+%! B = wavread (fname, 15);
 %! unlink (fname);
+%! assert (A(1:15,:) ,B, 1/2^15);
+%! wavwrite (A, fname);
+%! B = wavread (fname, [10, 20]);
+%! unlink (fname);
+%! assert (A(10:20,:) ,B, 1/2^15);
 
+%!test
+%! A = [-1:0.1:1; -1:0.1:1]';
+%! wavwrite (A, fname);
+%! [nsamp, nchan] = wavread (fname, "size");
+%! unlink (fname);
+%! assert (nsamp, 21);
+%! assert (nchan, 2);
+
diff --git a/scripts/deprecated/__error_text__.m b/scripts/deprecated/__error_text__.m
--- a/scripts/deprecated/__error_text__.m
+++ b/scripts/deprecated/__error_text__.m
@@ -29,8 +29,9 @@ function [msg, msgid] = __error_text__ (
     warned = true;
     warning ("Octave:deprecated-function",
              "__error_text__ is obsolete and will be removed from a future version of Octave, please use lasterr instead");
   endif
 
   [msg, msgid] = lasterr (varargin{:});
 
 endfunction
+
diff --git a/scripts/deprecated/cut.m b/scripts/deprecated/cut.m
--- a/scripts/deprecated/cut.m
+++ b/scripts/deprecated/cut.m
@@ -64,8 +64,9 @@ function group = cut (x, breaks)
   m = length (breaks);
   if (any (k = find ((x >= min (breaks)) & (x < max (breaks)))))
     n = length (k);
     group(k) = sum ((ones (m, 1) * reshape (x(k), 1, n))
                     >= (reshape (breaks, m, 1) * ones (1, n)));
   endif
 
 endfunction
+
diff --git a/scripts/deprecated/error_text.m b/scripts/deprecated/error_text.m
--- a/scripts/deprecated/error_text.m
+++ b/scripts/deprecated/error_text.m
@@ -29,8 +29,9 @@ function [msg, msgid] = error_text (vara
     warned = true;
     warning ("Octave:deprecated-function",
              "error_text is obsolete and will be removed from a future version of Octave, please use lasterr instead");
   endif
 
   [msg, msgid] = lasterr (varargin{:});
 
 endfunction
+
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/deprecated/isequalwithequalnans.m
rename from scripts/general/isequalwithequalnans.m
rename to scripts/deprecated/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/deprecated/isequalwithequalnans.m
@@ -13,28 +13,32 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequalwithequalnans (@var{x1}, @var{x2}, @dots{})
-## Assuming NaN == NaN, return true if all of @var{x1}, @var{x2}, @dots{}
-## are equal.
-## @seealso{isequal}
+## This function has been deprecated.  Use @code{@file{isequaln}} instead.
+## @seealso{isequaln}
 ## @end deftypefn
 
-function retval = isequalwithequalnans (x1, varargin)
+## Deprecated in 3.8
+
+function retval = isequalwithequalnans (varargin)
 
-  if (nargin < 2)
-    print_usage ();
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "isequalwithequalnans is obsolete and will be removed from a future version of Octave, please use isequaln instead");
   endif
 
-  retval = __isequal__ (true, x1, varargin{:});
+  retval = isequaln (varargin{:});
 
 endfunction
 
 
 ## test for equality
 %!assert (isequalwithequalnans ({1,2,NaN,4},{1,2,NaN,4}), true)
 %!assert (isequalwithequalnans ([1,2,NaN,4],[1,2,NaN,4]), true)
 ## test for inequality
diff --git a/scripts/deprecated/isstr.m b/scripts/deprecated/isstr.m
--- a/scripts/deprecated/isstr.m
+++ b/scripts/deprecated/isstr.m
@@ -33,8 +33,9 @@ function retval = isstr (varargin)
     warned = true;
     warning ("Octave:deprecated-function",
              "isstr is obsolete and will be removed from a future version of Octave, please use ischar instead");
   endif
 
   retval = ischar (varargin{:});
 
 endfunction
+
diff --git a/scripts/deprecated/java_convert_matrix.m b/scripts/deprecated/java_convert_matrix.m
--- a/scripts/deprecated/java_convert_matrix.m
+++ b/scripts/deprecated/java_convert_matrix.m
@@ -18,19 +18,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_convert_matrix ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_convert_matrix (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_convert_matrix (@var{new_val}, "local")
 ## Query or set the internal variable that controls whether Java arrays are
 ## automatically converted to Octave matrices.  The default value is false.
 ## 
-## When called from inside a function with the "local" option, the variable is
-## changed locally for the function and any subroutines it calls.  The original
-## variable value is restored when exiting the function.
+## When called from inside a function with the @qcode{"local"} option, the
+## variable is changed locally for the function and any subroutines it calls.
+##  The original variable value is restored when exiting the function.
 ## @seealso{java_matrix_autoconversion, java_unsigned_conversion, java_debug}
 ## @end deftypefn
 
 function old_val = java_convert_matrix (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/java_debug.m b/scripts/deprecated/java_debug.m
--- a/scripts/deprecated/java_debug.m
+++ b/scripts/deprecated/java_debug.m
@@ -19,19 +19,19 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{val} =} java_debug ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_debug (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_debug (@var{new_val}, "local")
 ## Query or set the internal variable that determines whether extra debugging
 ## information regarding the initialization of the JVM and any Java exceptions
 ## is printed.
 ## 
-## When called from inside a function with the "local" option, the variable is
-## changed locally for the function and any subroutines it calls.  The original
-## variable value is restored when exiting the function.
+## When called from inside a function with the @qcode{"local"} option, the
+## variable is changed locally for the function and any subroutines it calls.
+##  The original variable value is restored when exiting the function.
 ## @seealso{debug_java, java_convert_matrix, java_unsigned_conversion}
 ## @end deftypefn
 
 function old_val = java_debug (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/java_unsigned_conversion.m b/scripts/deprecated/java_unsigned_conversion.m
--- a/scripts/deprecated/java_unsigned_conversion.m
+++ b/scripts/deprecated/java_unsigned_conversion.m
@@ -20,19 +20,19 @@
 ## @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_conversion ()
 ## @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_conversion (@var{new_val})
 ## @deftypefnx {Built-in Function} {} java_unsigned_conversion (@var{new_val}, "local")
 ## Query or set the internal variable that controls how integer classes are
 ## converted when Java matrix autoconversion is enabled.  When enabled, Java
 ## arrays of class Byte or Integer are converted to matrices of class uint8 or
 ## uint32 respectively.
 ## 
-## When called from inside a function with the "local" option, the variable is
-## changed locally for the function and any subroutines it calls.  The original
-## variable value is restored when exiting the function.
+## When called from inside a function with the @qcode{"local"} option, the
+## variable is changed locally for the function and any subroutines it calls.
+##  The original variable value is restored when exiting the function.
 ## @seealso{java_unsigned_autoconversion, java_convert_matrix, debug_java}
 ## @end deftypefn
 
 function old_val = java_unsigned_conversion (varargin)
 
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -4,16 +4,17 @@ deprecated_FCN_FILES = \
   deprecated/__error_text__.m \
   deprecated/cor.m \
   deprecated/corrcoef.m \
   deprecated/cut.m \
   deprecated/default_save_options.m \
   deprecated/java_debug.m \
   deprecated/error_text.m \
   deprecated/gen_doc_cache.m \
+  deprecated/isequalwithequalnans.m \
   deprecated/isstr.m \
   deprecated/java_convert_matrix.m \
   deprecated/java_get.m \
   deprecated/java_invoke.m \
   deprecated/java_new.m \
   deprecated/java_unsigned_conversion.m \
   deprecated/java_set.m \
   deprecated/javafields.m \
diff --git a/scripts/deprecated/polyderiv.m b/scripts/deprecated/polyderiv.m
--- a/scripts/deprecated/polyderiv.m
+++ b/scripts/deprecated/polyderiv.m
@@ -93,16 +93,17 @@ function [q, d] = polyderiv (p, a)
       q = p(1:(lp-1)) .* [(lp-1):-1:1];
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!assert(all (all (polyderiv ([1, 2, 3]) == [2, 2])));
 
 %!assert(polyderiv (13) == 0);
 
 %!error polyderiv ([]);
 
 %!error polyderiv ([1, 2; 3, 4]);
 
diff --git a/scripts/deprecated/shell_cmd.m b/scripts/deprecated/shell_cmd.m
--- a/scripts/deprecated/shell_cmd.m
+++ b/scripts/deprecated/shell_cmd.m
@@ -18,21 +18,21 @@
 
 ## "-*- texinfo -*-
 ## @deftypefn  {Built-in Function} {} shell_cmd (@var{string})
 ## @deftypefnx {Built-in Function} {} shell_cmd (@var{string}, @var{return_output})
 ## @deftypefnx {Built-in Function} {} shell_cmd (@var{string}, @var{return_output}, @var{type})
 ## @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} shell_cmd (@dots{})
 ## @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} shell_cmd (@var{string}, @var{return_output}, @var{type})
 ## Execute a shell command specified by @var{string}.
-## If the optional argument @var{type} is "async", the process
+## If the optional argument @var{type} is @qcode{"async"}, the process
 ## is started in the background and the process id of the child process
 ## is returned immediately.  Otherwise, the process is started and
 ## Octave waits until it exits.  If the @var{type} argument is omitted, it
-## defaults to a value of "sync".
+## defaults to a value of @qcode{"sync"}.
 ## 
 ## If the optional argument @var{return_output} is true and the subprocess
 ## is started synchronously, or if @var{shell_cmd} is called with one input
 ## argument and one or more output arguments, then the output from the command
 ## is returned.  Otherwise, if the subprocess is executed synchronously, its
 ## output is sent to the standard output.
 ##
 ## The @code{shell_cmd} function can return two values.  The first is the
diff --git a/scripts/deprecated/studentize.m b/scripts/deprecated/studentize.m
--- a/scripts/deprecated/studentize.m
+++ b/scripts/deprecated/studentize.m
@@ -73,16 +73,17 @@ function t = studentize (x, dim)
     idx = ones (1, nd);
     idx(dim) = c;
     t = x - repmat (mean (x, dim), idx);
     t = t ./ repmat (max (cat (dim, std(t, [], dim), ! any (t, dim)), [], dim), idx);
   endif
 
 endfunction
 
+
 %!assert(studentize ([1,2,3]), [-1,0,1])
 %!assert(studentize (int8 ([1,2,3])), [-1,0,1])
 #%!assert(studentize (ones (3,2,0,2)), zeros (3,2,0,2))
 %!assert(studentize ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
 
 %% Test input validation
 %!error studentize ()
 %!error studentize (1, 2, 3)
diff --git a/scripts/deprecated/sylvester_matrix.m b/scripts/deprecated/sylvester_matrix.m
--- a/scripts/deprecated/sylvester_matrix.m
+++ b/scripts/deprecated/sylvester_matrix.m
@@ -52,16 +52,17 @@ function retval = sylvester_matrix (k)
       retval = [tmp, tmp; tmp, -tmp];
     endif
   else
     error ("sylvester_matrix: expecting scalar argument");
   endif
 
 endfunction
 
+
 %!assert((sylvester_matrix (1) == [1, 1; 1, -1]
 %! && (sylvester_matrix (2)
 %! == [1, 1, 1, 1; 1, -1, 1, -1; 1, 1, -1, -1; 1, -1, -1, 1])));
 
 %!error sylvester_matrix ([1, 2; 3, 4]);
 
 %!error sylvester_matrix ();
 
diff --git a/scripts/elfun/atan2d.m b/scripts/elfun/atan2d.m
new file mode 100644
--- /dev/null
+++ b/scripts/elfun/atan2d.m
@@ -0,0 +1,41 @@
+## Copyright (C) 2013 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} atan2d (@var{y}, @var{x})
+## Compute atan2 (@var{y} / @var{x}) in degrees for corresponding elements
+## from @var{y} and @var{x}.
+## @seealso{tand, atan2}
+## @end deftypefn
+
+function retval = atan2d (y, x)
+
+  if (nargin != 2)
+    print_usage ();
+  endif
+
+  retval = 180 ./ pi .* atan2 (y, x);
+
+endfunction
+
+
+%!assert (atan2d (-1:.1:1, 1:-.1:-1), 180/pi * atan2 (-1:.1:1, 1:-.1:-1), -10*eps)
+
+%!error atan2d ()
+%!error atan2d (1)
+
diff --git a/scripts/elfun/module.mk b/scripts/elfun/module.mk
--- a/scripts/elfun/module.mk
+++ b/scripts/elfun/module.mk
@@ -7,16 +7,17 @@ elfun_FCN_FILES = \
   elfun/acoth.m \
   elfun/acsc.m \
   elfun/acscd.m \
   elfun/acsch.m \
   elfun/asec.m \
   elfun/asecd.m \
   elfun/asech.m \
   elfun/asind.m \
+  elfun/atan2d.m \
   elfun/atand.m \
   elfun/cosd.m \
   elfun/cot.m \
   elfun/cotd.m \
   elfun/coth.m \
   elfun/csc.m \
   elfun/cscd.m \
   elfun/csch.m \
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -56,17 +56,17 @@
 ## By default @code{accumarray} returns a full matrix.  If
 ## @var{issparse} is logically true, then a sparse matrix is returned
 ## instead.
 ##
 ## The following @code{accumarray} example constructs a frequency table
 ## that in the first column counts how many occurrences each number in
 ## the second column has, taken from the vector @var{x}.  Note the usage
 ## of @code{unique}  for assigning to all repeated elements of @var{x}
-## the same index (@pxref{docXunique}).
+## the same index (@pxref{XREFunique,,unique}).
 ##
 ## @example
 ## @group
 ## @var{x} = [91, 92, 90, 92, 90, 89, 91, 89, 90, 100, 100, 100];
 ## [@var{u}, ~, @var{j}] = unique (@var{x});
 ## [accumarray(@var{j}', 1), @var{u}']
 ##   @result{}  2    89
 ##       3    90
@@ -87,17 +87,17 @@
 ##              2, 1, 2;
 ##              2, 3, 2], 101:105)
 ## @result{} ans(:,:,1) = [101, 0, 0; 0, 0, 0]
 ## @result{} ans(:,:,2) = [0, 0, 0; 206, 0, 208]
 ## @end group
 ## @end example
 ##
 ## The sparse option can be used as an alternative to the @code{sparse}
-## constructor (@pxref{docXsparse}).  Thus
+## constructor (@pxref{XREFsparse,,sparse}).  Thus
 ##
 ## @example
 ## sparse (@var{i}, @var{j}, @var{sv})
 ## @end example
 ##
 ## @noindent
 ## can be written with @code{accumarray} as
 ##
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -103,17 +103,17 @@ function A = accumdim (subs, vals, dim, 
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
       subsc = {':'}(ones (1, length (sz)));
       subsc{dim} = mask;
       A(subsc{:}) = fillval;
     endif
-    return
+    return;
   endif
 
   ## The general case.
   ns = length (subs);
   ## Sort indices.
   [subs, idx] = sort (subs(:));
   ## Identify runs.
   jdx = find (subs(1:ns-1) != subs(2:ns));
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -216,16 +216,17 @@ function zi = bicubic (x, y, z, xi, yi, 
     zi(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     zi([yfirst_ind; ylast_ind], :) = extrapval;
   endif
 
 endfunction
 
+
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
 %! x = [0,1,4]+10;
 %! y = [-10,-9,-8];
 %! xi = linspace (min (x), max (x), 17);
 %! yi = linspace (min (y), max (y), 26)';
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -44,16 +44,19 @@ function C = bitcmp (A, k)
 
   if (nargin == 2 && (! isscalar (k) || (floor (k) != k)))
     error ("bitcmp: K must be a scalar integer");
   endif
 
   if (isa (A, "double"))
     bmax = bitmax;
     amax = ceil (log2 (bmax));
+  elseif (isa (A, "single"))
+    bmax = bitmax ("single");
+    amax = ceil (log2 (bmax));
   else
     if (isa (A, "uint8"))
       amax = 8;
     elseif (isa (A, "uint16"))
       amax = 16;
     elseif (isa (A, "uint32"))
       amax = 32;
     elseif (isa (A, "uint64"))
@@ -88,16 +91,23 @@ endfunction
 %!test
 %! Amax = 53;
 %! Bmax = bitmax;
 %! A = bitshift (Bmax,-2);
 %! assert (bitcmp (A,Amax),bitor (bitshift (1,Amax-1), bitshift (1,Amax-2)));
 %! assert (bitcmp (A,Amax-1), bitshift (1,Amax-2));
 %! assert (bitcmp (A,Amax-2), 0);
 %!test
+%! Amax = 24;
+%! Bmax = bitmax ("single");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (single (1),Amax-1), bitshift (single (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (single (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), single (0));
+%!test
 %! Amax = 8;
 %! Bmax = intmax ("uint8");
 %! A = bitshift (Bmax,-2);
 %! assert (bitcmp (A,Amax),bitor (bitshift (uint8 (1),Amax-1), bitshift (uint8 (1),Amax-2)));
 %! assert (bitcmp (A,Amax-1), bitshift (uint8 (1),Amax-2));
 %! assert (bitcmp (A,Amax-2), uint8 (0));
 %!test
 %! Amax = 16;
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -34,18 +34,21 @@
 
 function C = bitget (A, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (isa (A, "double"))
-    Amax = log2 (bitmax) + 1;
+    Amax = ceil (log2 (bitmax));
     _conv = @double;
+  elseif (isa (A, "single"))
+    Amax = ceil (log2 (bitmax ("single")));
+    _conv = @single;
   else
     if (isa (A, "uint8"))
       Amax = 8;
       _conv = @uint8;
     elseif (isa (A, "uint16"))
       Amax = 16;
       _conv = @uint16;
     elseif (isa (A, "uint32"))
@@ -78,27 +81,31 @@ function C = bitget (A, n)
 
   C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
 
 endfunction
 
 
 %!test
 %! assert (bitget ([4, 14], [3, 3]), logical ([1, 1]));
+%! assert (bitget (single ([4, 14]), [3, 3]), logical ([1, 1]));
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitget (fcn ([4, 14]), [3, 3]), logical ([1, 1]));
 %!   endfor
 %! endfor
 
 %!error bitget (0, 0)
 %!error bitget (0, 55)
 
+%!error bitget (single (0), 0)
+%!error bitget (single (0), 26)
+
 %!error bitget (int8 (0), 9)
 %!error bitget (uint8 (0), 9)
 
 %!error bitget (int16 (0), 17)
 %!error bitget (uint16 (0), 17)
 
 %!error bitget (int32 (0), 33)
 %!error bitget (uint32 (0), 33)
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -49,20 +49,20 @@ function C = bitset (A, n, val)
   if (nargin == 2)
     val = true (sz);
   endif
 
   cl = class (A);
 
   if (isfloat (A) && isreal (A))
     Bmax = bitmax (cl);
-    Amax = log2 (Bmax);
+    Amax = ceil (log2 (Bmax));
   elseif (isinteger (A))
     Bmax = intmax (cl);
-    Amax = round (log2 (Bmax));
+    Amax = ceil (log2 (Bmax));
   else
     error ("bitset: invalid class %s", cl);
   endif
 
   if (any ((n < 1)(:)) || any ((n > Amax)(:)))
     error ("bitset: N must be in the range [1,%d]", Amax);
   endif
 
@@ -86,16 +86,17 @@ function C = bitset (A, n, val)
   C(on) = bitor (A(on), onmask);
   C(off) = bitand (A(off), bitcmp (offmask));
 
 endfunction
 
 
 %!test
 %! assert (bitset ([0, 10], [3, 3]), [4, 14]);
+%! assert (bitset (single ([0, 10]), [3, 3]), single ([4, 14]));
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
@@ -103,16 +104,18 @@ endfunction
 %!assert (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]), uint8 ([0, 3; 2 5]))
 
 %!error bitset (1)
 %!error bitset (1, 2, 3, 4)
 %!error <A must be .= 0> bitset (-1, 2)
 %!error <invalid class char> bitset ("1", 2)
 %!error <N must be in the range \[1,53\]> bitset (0, 0)
 %!error <N must be in the range \[1,53\]> bitset (0, 55)
+%!error <N must be in the range \[1,24\]> bitset (single (0), 0)
+%!error <N must be in the range \[1,24\]> bitset (single (0), 26)
 %!error <N must be in the range \[1,8\]> bitset (uint8 (0), 0)
 %!error <N must be in the range \[1,8\]> bitset (uint8 (0), 9)
 %!error <N must be in the range \[1,7\]> bitset (int8 (0), 9)
 %!error <N must be in the range \[1,15\]> bitset (int16 (0), 17)
 %!error <N must be in the range \[1,16\]> bitset (uint16 (0), 17)
 %!error <N must be in the range \[1,31\]> bitset (int32 (0), 33)
 %!error <N must be in the range \[1,32\]> bitset (uint32 (0), 33)
 %!error <N must be in the range \[1,63\]> bitset (int64 (0), 65)
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -16,18 +16,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{m} =} cell2mat (@var{c})
 ## Convert the cell array @var{c} into a matrix by concatenating all
 ## elements of @var{c} into a hyperrectangle.  Elements of @var{c} must
-## be numeric, logical or char matrices, or cell arrays, and @code{cat}
-## must be able to concatenate them together.
+## be numeric, logical, or char matrices; or cell arrays; or structs; and
+## @code{cat} must be able to concatenate them together.
 ## @seealso{mat2cell, num2cell}
 ## @end deftypefn
 
 function m = cell2mat (c)
 
   if (nargin != 1)
     print_usage ();
   endif
@@ -37,48 +37,58 @@ function m = cell2mat (c)
   endif
 
   nb = numel (c);
 
   if (nb == 0)
     m = [];
   else
 
-    ## We only want numeric, logical, and char matrices.
+    ## Check first for valid matrix types
     valid = cellfun ("isnumeric", c);
-    valid |= cellfun ("islogical", c);
-    valid |= cellfun ("isclass", c, "char");
-    validc = cellfun ("isclass", c, "cell");
-    valids = cellfun ("isclass", c, "struct");
-
-    if (! all (valid(:)) && ! all (validc(:)) && ! all (valids(:)))
-      error ("cell2mat: wrong type elements or mixed cells, structs and matrices");
+    valid = cellfun ("islogical", c(! valid));
+    valid = cellfun ("isclass", c(! valid), "char");
+    if (! all (valid(:)))
+      valid = cellfun ("isclass", c, "cell");
+      if (! all (valid(:)))
+        valid = cellfun ("isclass", c, "struct");
+        if (! all (valid(:)))
+          error ("cell2mat: wrong type elements or mixed cells, structs, and matrices");
+        endif
+      endif
     endif
 
-    ## The goal is to minimize the total number of cat() calls.
-    ## The dimensions can be concatenated along in arbitrary order.
-    ## The numbers of concatenations are:
-    ## n / d1
-    ## n / (d1 * d2)
-    ## n / (d1 * d2 * d3)
-    ## etc.
-    ## This is minimized if d1 >= d2 >= d3...
+    sz = size (c);
+    if (all (cellfun ("numel", c)(:) == 1))
+      ## Special case of all scalars
+      m = reshape (cat (1, c{:}), sz);
+    else
 
-    sc = size (c);
-    nd = ndims (c);
-    [~, isc] = sort (sc);
-    for idim = isc
-      if (sc(idim) == 1)
-        continue;
-      endif
-      xdim = [1:idim-1, idim+1:nd];
-      cc = num2cell (c, xdim);
-      c = cellfun ("cat", {idim}, cc{:}, "uniformoutput", false);
-    endfor
-    m = c{1};
+      ## The goal is to minimize the total number of cat() calls.
+      ## The dimensions can be concatenated along in arbitrary order.
+      ## The numbers of concatenations are:
+      ## n / d1
+      ## n / (d1 * d2)
+      ## n / (d1 * d2 * d3)
+      ## etc.
+      ## This is minimized if d1 >= d2 >= d3...
+
+      nd = ndims (c);
+      [~, isz] = sort (sz, "descend");
+      for idim = isz
+        if (sz(idim) == 1)
+          continue;
+        endif
+        xdim = [1:idim-1, idim+1:nd];
+        cc = num2cell (c, xdim);
+        c = cellfun ("cat", {idim}, cc{:}, "uniformoutput", false);
+      endfor
+      m = c{1};
+
+    endif
   endif
 
 endfunction
 
 
 %!demo
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! cell2mat (C)
@@ -98,8 +108,15 @@ endfunction
 %!test
 %! m = int8 (256*rand (4, 5, 6, 7, 8));
 %! c = mat2cell (m, [1 2 1], [1 2 2], [3 1 1 1], [4 1 2], [3 1 4]);
 %! assert (cell2mat (c), m);
 %!test
 %! m = {1, 2, 3};
 %! assert (cell2mat (mat2cell (m, 1, [1 1 1])), m);
 
+%!error cell2mat ()
+%!error cell2mat (1,2)
+%!error <C is not a cell array> cell2mat ([1,2])
+%!error <mixed cells, structs, and matrices> cell2mat ({[1], struct()})
+%!error <mixed cells, structs, and matrices> cell2mat ({[1], {1}})
+%!error <mixed cells, structs, and matrices> cell2mat ({struct(), {1}})
+
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -84,8 +84,9 @@ endfunction
 %!demo
 %! c = {1, 2, {31, 32}};
 %! celldisp (c, "b")
 
 ## Test input validation
 %!error celldisp ()
 %!error celldisp ({}, "name", 1)
 %!error <C must be a cell array> celldisp (1)
+
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -38,8 +38,9 @@ function r = colon (varargin)
     error ('colon: not defined for class "%s"', class (varargin{1}));
   endif
 endfunction
 
 
 %!error colon (1)
 
 ## FIXME -- what does colon () mean since it doesn't set a return value?
+
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -156,11 +156,11 @@ endfunction
 %! z = exp (2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
 %!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
-%!## tolerance test
+## tolerance test
 %!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
- 
+
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -35,17 +35,18 @@
 ## The optional argument @var{tol} defines the absolute tolerance used to
 ## integrate each sub-integral.  The default value is @math{1e^{-6}}.
 ##
 ## The optional argument @var{quadf} specifies which underlying integrator
 ## function to use.  Any choice but @code{quad} is available and the default
 ## is @code{quadcc}.
 ##
 ## Additional arguments, are passed directly to @var{f}.  To use the default
-## value for @var{tol} or @var{quadf} one may pass ':' or an empty matrix ([]).
+## value for @var{tol} or @var{quadf} one may pass @qcode{':'} or an empty
+## matrix ([]).
 ## @seealso{triplequad, quad, quadv, quadl, quadgk, quadcc, trapz}
 ## @end deftypefn
 
 function q = dblquad (f, xa, xb, ya, yb, tol = 1e-6, quadf = @quadcc, varargin)
 
   if (nargin < 5)
     print_usage ();
   endif
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -152,8 +152,9 @@ function D = del2 (M, varargin)
       endif
 
       D += DD;
     endif
   endfor
 
   D = D ./ nd;
 endfunction
+
diff --git a/scripts/general/display.m b/scripts/general/display.m
--- a/scripts/general/display.m
+++ b/scripts/general/display.m
@@ -14,25 +14,25 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} display (@var{a})
 ## Display the contents of an object.  If @var{a} is an object of the
-## class "myclass", then @code{display} is called in a case like
+## class @qcode{"myclass"}, then @code{display} is called in a case like
 ##
 ## @example
 ## myclass (@dots{})
 ## @end example
 ##
 ## @noindent
 ## where Octave is required to display the contents of a variable of the
-## type "myclass".
+## type @qcode{"myclass"}.
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function idx = display (a)
 
   if (nargin != 1)
     print_usage ();
@@ -43,8 +43,9 @@ function idx = display (a)
   str = disp (a);
   if (isempty (strfind (str, "<class ")))
     disp (str);   
   else
     error ('display: not defined for class "%s"', class (a));
   endif
 
 endfunction
+
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
--- a/scripts/general/fieldnames.m
+++ b/scripts/general/fieldnames.m
@@ -26,17 +26,17 @@
 ##
 ## When the input is a structure @var{struct}, the names are the elements
 ## of the structure.
 ##
 ## When the input is an Octave object @var{obj}, the names are the public
 ## properties of the object.
 ##
 ## When the input is a Java object @var{javaobj} or Java classname
-## @var{jclassname}) the name are the public data elements of the object or
+## @var{jclassname} the name are the public data elements of the object or
 ## class.
 ## @seealso{struct, methods}
 ## @end deftypefn
 
 function names = fieldnames (obj)
   
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -77,24 +77,25 @@
 ## @end group
 ## @end example
 ##
 ## Since variable names may only contain letters, digits and underscores,
 ## genvarname replaces any sequence of disallowed characters with
 ## an underscore.  Also, variables may not begin with a digit; in this
 ## case an underscore is added before the variable name.
 ##
-## Variable names beginning and ending with two underscores "__" are valid but
-## they are used internally by octave and should generally be avoided, therefore
-## genvarname will not generate such names.
+## Variable names beginning and ending with two underscores @qcode{"__"} are
+## valid but they are used internally by octave and should generally be
+## avoided, therefore genvarname will not generate such names.
 ##
 ## genvarname will also make sure that returned names do not clash with
-## keywords such as "for" and "if".  A number will be appended if necessary.
-## Note, however, that this does @strong{not} include function names,
-## such as "sin".  Such names should be included in @var{avoid} if necessary.
+## keywords such as @qcode{"for"} and @qcode{"if"}.  A number will be
+## appended if necessary.  Note, however, that this does @strong{not} include
+## function names, such as @qcode{"sin"}.  Such names should be included in
+## @var{avoid} if necessary.
 ## @seealso{isvarname, exist, tmpnam, eval}
 ## @end deftypefn
 
 ## Authors: Rob Platt <robert.platt@postgrad.manchester.ac.uk>
 ##          Bill Denney <bill@denney.ws>
 
 function varname = genvarname (str, exclusions)
 
@@ -114,43 +115,43 @@ function varname = genvarname (str, excl
     if (rows (str) != 1)
       error ("genvarname: if more than one STR is given, it must be a cellstr");
     endif
     str = {str};
   elseif (! iscellstr (str))
     error ("genvarname: STR must be a string or a cellstr");
   endif
 
-  validchars = cstrcat ("A":"Z", "a":"z", "0":"9", "_");
+  validchars = ["A":"Z", "a":"z", "0":"9", "_"];
 
   varname = cell (size (str));
   for i = 1:numel (str)
     ## Perform any modifications to the varname to make sure that it is
     ## a valid variable name.
 
     ## remove invalid characters
     str{i}(! ismember (str{i}, validchars)) = "_";
     ## do not use keywords
     if (iskeyword (str{i}))
-      str{i} = cstrcat ("_", str{i});
+      str{i} = ["_" str{i}];
     endif
     ## double underscores at the beginning and end are reserved variables
     underscores = (str{i} == "_");
     if (any (underscores))
       firstnon = find (!underscores, 1);
       lastnon = find (!underscores, 1, "last");
       str{i}([1:firstnon-2, lastnon+2:end]) = [];
     endif
     ## The variable cannot be empty
     if (isempty (str{i}))
       str{i} = "x";
     endif
     ## it cannot start with a number
     if (ismember (str{i}(1), "0":"9"))
-      str{i} = cstrcat ("_", str{i});
+      str{i} = ["_" str{i}];
     endif
 
     ## make sure that the variable is unique relative to other variables
     ## and the exclusions list
     excluded = any (strcmp (str{i}, exclusions));
     if (excluded && ismember (str{i}(end), "0":"9"))
       ## if it is not unique and ends with a digit, add an underscore to
       ## make the variable name more readable ("x1_1" instead of "x11")
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -23,35 +23,35 @@
 ## The standard behavior of integer division such as @code{@var{a} ./ @var{b}}
 ## is to round the result to the nearest integer.  This is not always the
 ## desired behavior and @code{idivide} permits integer element-by-element
 ## division to be performed with different treatment for the fractional
 ## part of the division as determined by the @var{op} flag.  @var{op} is
 ## a string with one of the values:
 ##
 ## @table @asis
-## @item "fix"
+## @item @qcode{"fix"}
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards zero.
 ##
-## @item "round"
+## @item @qcode{"round"}
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards the nearest integer.
 ##
-## @item "floor"
+## @item @qcode{"floor"}
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards negative infinity.
 ##
-## @item "ceil"
+## @item @qcode{"ceil"}
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards positive infinity.
 ## @end table
 ##
 ## @noindent
-## If @var{op} is not given it defaults to @code{"fix"}.
+## If @var{op} is not given it defaults to @qcode{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
 ## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
 ##   @result{} int8 ([0, 0])
 ## idivide (int8 ([-3, 3]), int8 (4), "round")
 ##   @result{} int8 ([-1, 1])
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -62,36 +62,36 @@ function retval = int2str (n)
   nd = ndims (n);
   nc = columns (n);
   if (nc > 1)
     idx = repmat ({':'}, nd, 1);
     idx(2) = 1;
     ifmt = get_fmt (n(idx{:}), 0);
     idx(2) = 2:sz(2);
     rfmt = get_fmt (n(idx{:}), 2);
-    fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
+    fmt = [ifmt repmat(rfmt,1,nc-1) "\n"];
   else
-    fmt = cstrcat (get_fmt (n, 0), "\n");
+    fmt = [get_fmt(n, 0) "\n"];
   endif
   tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
   tmp(end) = "";
   retval = char (ostrsplit (tmp, "\n"));
 
 endfunction
 
 function fmt = get_fmt (x, sep)
 
   t = x(:);
   t = t(t != 0);
   if (isempty (t))
     ## All zeros.
     fmt = sprintf ("%%%dd", 1 + sep);
   else
     ## Maybe have some zeros.
-    nan_inf = isinf (t) | isnan (t);
+    nan_inf = ! isfinite (t);
     if (any (nan_inf))
       if (any (t(nan_inf) < 0))
         min_fw = 4 + sep;
       else
         min_fw = 3 + sep;
       endif
     else
       min_fw = 1 + sep;
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -21,65 +21,66 @@
 ## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, "pp")
 ##
 ## One-dimensional interpolation.  Interpolates to determine the value of
 ## @var{yi} at the points, @var{xi}.  If not specified, @var{x} is taken
-## to be the indices of @var{y}.  If @var{y} is an array, treat the columns
-## of @var{y} separately.
+## to be the indices of @var{y}.  If @var{y} is a matrix or an N-dimensional
+## array, the interpolation is performed on each column of @var{y}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item "nearest"
+## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
-## @item "linear"
+## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors
 ##
-## @item "pchip"
+## @item @qcode{"pchip"}
 ## Piecewise cubic Hermite interpolating polynomial
 ##
-## @item "cubic"
+## @item @qcode{"cubic"}
 ## Cubic interpolation (same as @code{pchip})
 ##
-## @item "spline"
+## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve
 ## @end table
 ##
 ## Appending '*' to the start of the above method forces @code{interp1}
 ## to assume that @var{x} is uniformly spaced, and only @code{@var{x}(1)}
 ## and @code{@var{x}(2)} are referenced.  This is usually faster,
-## and is never slower.  The default method is "linear".
+## and is never slower.  The default method is @qcode{"linear"}.
 ##
-## If @var{extrap} is the string "extrap", then extrapolate values beyond
-## the endpoints.  If @var{extrap} is a number, replace values beyond the
-## endpoints with that number.  If @var{extrap} is missing, assume NA.
+## If @var{extrap} is the string @qcode{"extrap"}, then extrapolate values
+## beyond the endpoints.  If @var{extrap} is a number, replace values beyond
+## the endpoints with that number.  If @var{extrap} is missing, assume NA.
 ##
-## If the string argument "pp" is specified, then @var{xi} should not be
+## If the string argument @qcode{"pp"} is specified, then @var{xi} should not be
 ## supplied and @code{interp1} returns the piecewise polynomial that
 ## can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
-## @var{y}, @var{method}, "pp"), @var{xi}) == interp1 (@var{x}, @var{y},
-## @var{xi}, @var{method}, "extrap")}.
+## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x}, @var{y},
+## @var{xi}, @var{method}, @qcode{"extrap"})}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## may be at most 2 consecutive points with the same value.
 ## If @var{x} is increasing, the default discontinuous interpolant is
 ## right-continuous.  If @var{x} is decreasing, the default discontinuous
 ## interpolant is left-continuous.
 ## The continuity condition of the interpolant may be specified by using
-## the options, "-left" or "-right", to select a left-continuous
+## the options, @qcode{"-left"} or @qcode{"-right"}, to select a left-continuous
 ## or right-continuous interpolant, respectively.
-## Discontinuous interpolation is only allowed for "nearest" and "linear"
-## methods; in all other cases, the @var{x}-values must be unique.
+## Discontinuous interpolation is only allowed for @qcode{"nearest"} and
+## @qcode{"linear"} methods; in all other cases, the @var{x}-values must be
+## unique.
 ##
 ## An example of the use of @code{interp1} is
 ##
 ## @example
 ## @group
 ## xf = [0:0.05:10];
 ## yf = sin (2*pi*xf/5);
 ## xp = [0:10];
@@ -144,17 +145,21 @@ function yi = interp1 (x, y, varargin)
         endif
       endif
     endfor
   endif
 
   if (isempty (xi) && firstnumeric && ! ispp)
     xi = y;
     y = x;
-    x = 1:numel (y);
+    if (isvector (y))
+      x = 1:numel (y);
+    else
+      x = 1:rows (y);
+    endif
   endif
 
   ## reshape matrices for convenience
   x = x(:);
   nx = rows (x);
   szx = size (xi);
   if (isvector (y))
     y = y(:);
@@ -177,25 +182,25 @@ function yi = interp1 (x, y, varargin)
   endif
 
   if (isempty (rightcontinuous))
     ## If not specified, set the continuity condition
     if (x(end) < x(1))
       rightcontinuous = false;
     else
       rightcontinuous = true;
-    end
+    endif
   endif
 
   if ((rightcontinuous && (x(end) < x(1)))
-      || (~ rightcontinuous && (x(end) > x(1))))
+      || (! rightcontinuous && (x(end) > x(1))))
     ## Switch between left-continuous and right-continuous
     x = flipud (x);
     y = flipud (y);
-  end
+  endif
 
   starmethod = method(1) == "*";
 
   if (starmethod)
     dx = x(2) - x(1);
   else
     jumps = x(1:end-1) == x(2:end);
     have_jumps = any (jumps);
@@ -207,101 +212,103 @@ function yi = interp1 (x, y, varargin)
       else
         error ("interp1: discontinuities not supported for method '%s'", method);
       endif
     endif
   endif
 
   ## Proceed with interpolating by all methods.
   switch (method)
-  case "nearest"
-    pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)], shiftdim (y, 1), szy(2:end));
-    pp.orient = "first";
+    case "nearest"
+      pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)],
+                 shiftdim (y, 1), szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
-  case "*nearest"
-    pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)], shiftdim (y, 1), szy(2:end));
-    pp.orient = "first";
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
-  case "linear"
-    dy = diff (y);
-    dx = diff (x);
-    dx = repmat (dx, [1 size(dy)(2:end)]);
-    coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
-    xx = x;
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
+    case "*nearest"
+      pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)],
+                 shiftdim (y, 1), szy(2:end));
+      pp.orient = "first";
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
+    case "linear"
+      dy = diff (y);
+      dx = diff (x);
+      dx = repmat (dx, [1 size(dy)(2:end)]);
+      coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
+      xx = x;
 
-    if (have_jumps)
-      ## Omit zero-size intervals.
-      coefs(jumps, :) = [];
-      xx(jumps) = [];
-    endif
+      if (have_jumps)
+        ## Omit zero-size intervals.
+        coefs(jumps, :) = [];
+        xx(jumps) = [];
+      endif
 
-    pp = mkpp (xx, coefs, szy(2:end));
-    pp.orient = "first";
+      pp = mkpp (xx, coefs, szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
 
-  case "*linear"
-    dy = diff (y);
-    coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
-    pp = mkpp (x, coefs, szy(2:end));
-    pp.orient = "first";
+    case "*linear"
+      dy = diff (y);
+      coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
+      pp = mkpp (x, coefs, szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
 
-  case {"pchip", "*pchip", "cubic", "*cubic"}
-    if (nx == 2 || starmethod)
-      x = linspace (x(1), x(nx), ny);
-    endif
+    case {"pchip", "*pchip", "cubic", "*cubic"}
+      if (nx == 2 || starmethod)
+        x = linspace (x(1), x(nx), ny);
+      endif
 
-    if (ispp)
-      y = shiftdim (reshape (y, szy), 1);
-      yi = pchip (x, y);
-      yi.orient = "first";
-    else
-      y = shiftdim (y, 1);
-      yi = pchip (x, y, reshape (xi, szx));
-      if (! isvector (y))
-        yi = shiftdim (yi, 1);
+      if (ispp)
+        y = shiftdim (reshape (y, szy), 1);
+        yi = pchip (x, y);
+        yi.orient = "first";
+      else
+        y = shiftdim (y, 1);
+        yi = pchip (x, y, reshape (xi, szx));
+        if (! isvector (y))
+          yi = shiftdim (yi, 1);
+        endif
+      endif
+    case {"spline", "*spline"}
+      if (nx == 2 || starmethod)
+        x = linspace (x(1), x(nx), ny);
       endif
-    endif
-  case {"spline", "*spline"}
-    if (nx == 2 || starmethod)
-      x = linspace (x(1), x(nx), ny);
-    endif
 
-    if (ispp)
-      y = shiftdim (reshape (y, szy), 1);
-      yi = spline (x, y);
-      yi.orient = "first";
-    else
-      y = shiftdim (y, 1);
-      yi = spline (x, y, reshape (xi, szx));
-      if (! isvector (y))
-        yi = shiftdim (yi, 1);
+      if (ispp)
+        y = shiftdim (reshape (y, szy), 1);
+        yi = spline (x, y);
+        yi.orient = "first";
+      else
+        y = shiftdim (y, 1);
+        yi = spline (x, y, reshape (xi, szx));
+        if (! isvector (y))
+          yi = shiftdim (yi, 1);
+        endif
       endif
-    endif
-  otherwise
-    error ("interp1: invalid method '%s'", method);
+    otherwise
+      error ("interp1: invalid method '%s'", method);
   endswitch
 
   if (! ispp)
     if (! ischar (extrap))
       ## determine which values are out of range and set them to extrap,
       ## unless extrap == "extrap".
       minx = min (x(1), x(nx));
       maxx = max (x(1), x(nx));
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -16,19 +16,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} interp1q (@var{x}, @var{y}, @var{xi})
 ## One-dimensional linear interpolation without error checking.
 ## Interpolates @var{y}, defined at the points @var{x}, at the points
 ## @var{xi}.  The sample points @var{x} must be a strictly monotonically
-## increasing column vector.  If @var{y} is an array, treat the columns
-## of @var{y} separately.  If @var{y} is a vector, it must be a column
-## vector of the same length as @var{x}.
+## increasing column vector.  If @var{y} is a matrix or an N-dimensional
+## array, the interpolation is performed on each column of @var{y}.  If
+## @var{y} is a vector, it must be a column vector of the same length as
+## @var{x}.
 ##
 ## Values of @var{xi} beyond the endpoints of the interpolation result
 ## in NA being returned.
 ##
 ## Note that the error checking is only a significant portion of the
 ## execution time of this @code{interp1} if the size of the input arguments
 ## is relatively small.  Therefore, the benefit of using @code{interp1q}
 ## is relatively small.
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -31,45 +31,46 @@
 ## format.
 ##
 ## @table @code
 ## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{})
 ## Returns a matrix corresponding to the points described by the
 ## matrices @var{xi}, @var{yi}.
 ##
 ## If the last argument is a string, the interpolation method can
-## be specified.  The method can be "linear", "nearest" or "cubic".
-## If it is omitted "linear" interpolation is assumed.
+## be specified.  The method can be @qcode{"linear"}, @qcode{"nearest"} or
+## @qcode{"cubic"}.  If it is omitted @qcode{"linear"} interpolation is
+## assumed.
 ##
 ## @item interp2 (@var{z}, @var{xi}, @var{yi})
 ## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} =
 ## 1:columns (@var{z})}
 ##
 ## @item interp2 (@var{z}, @var{n})
 ## Interleaves the matrix @var{z} n-times.  If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
 ## interpolation.  It can take one of the following values
 ##
 ## @table @asis
-## @item "nearest"
+## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
-## @item "linear"
+## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors.
 ##
-## @item "pchip"
+## @item @qcode{"pchip"}
 ## Piecewise cubic Hermite interpolating polynomial.
 ##
-## @item "cubic"
+## @item @qcode{"cubic"}
 ## Cubic interpolation from four nearest neighbors.
 ##
-## @item "spline"
+## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## If a scalar value @var{extrapval} is defined as the final value, then
 ## values outside the mesh as set to this value.  Note that in this case
 ## @var{method} must be defined as well.  If @var{extrapval} is not
 ## defined then NA is assumed.
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -23,49 +23,49 @@
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform 3-dimensional interpolation.  Each element of the 3-dimensional
 ## array @var{v} represents a value at a location given by the parameters
 ## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and
 ## @var{z} are either 3-dimensional arrays of the same size as the array
-## @var{v} in the "meshgrid" format or vectors.  The parameters @var{xi}, etc.
-## respect a similar format to @var{x}, etc., and they represent the points
-## at which the array @var{vi} is interpolated.
+## @var{v} in the @qcode{"meshgrid"} format or vectors.  The parameters
+## @var{xi}, etc. respect a similar format to @var{x}, etc., and they
+## represent the points at which the array @var{vi} is interpolated.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item "nearest"
+## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
-## @item "linear"
+## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors.
 ##
-## @item "cubic"
+## @item @qcode{"cubic"}
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item "spline"
+## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is "linear".
+## The default method is @qcode{"linear"}.
 ##
-## If @var{extrap} is the string "extrap", then extrapolate values beyond
-## the endpoints.  If @var{extrap} is a number, replace values beyond the
-## endpoints with that number.  If @var{extrap} is missing, assume NA.
+## If @var{extrap} is the string @qcode{"extrap"}, then extrapolate values
+## beyond the endpoints.  If @var{extrap} is a number, replace values beyond
+## the endpoints with that number.  If @var{extrap} is missing, assume NA.
 ## @seealso{interp1, interp2, spline, meshgrid}
 ## @end deftypefn
 
 function vi = interp3 (varargin)
   method = "linear";
   extrapval = NA;
   nargs = nargin;
 
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} interpft (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} interpft (@var{x}, @var{n}, @var{dim})
 ##
 ## Fourier interpolation.  If @var{x} is a vector, then @var{x} is
 ## resampled with @var{n} points.  The data in @var{x} is assumed to be
-## equispaced.  If @var{x} is an array, then operate along each column of
-## the array separately.  If @var{dim} is specified, then interpolate
-## along the dimension @var{dim}.
+## equispaced.  If @var{x} is a matrix or an N-dimensional array, the
+## interpolation is performed on each column of @var{x}.  If @var{dim} is
+## specified, then interpolate along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
 ## and so assumptions are made about the endpoints of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
@@ -63,27 +63,39 @@ function z = interpft (x, n, dim)
   if (dim < 1 || dim > nd)
     error ("interpft: invalid dimension DIM");
   endif
 
   perm = [dim:nd, 1:(dim-1)];
   x = permute (x, perm);
   m = rows (x);
 
-  inc = max (1, fix (m/n));
+  inc = ceil (m/n);
   y = fft (x) / m;
-  k = floor (m / 2);
+  k = ceil (m / 2);
   sz = size (x);
   sz(1) = n * inc - m;
 
   idx = repmat ({':'}, nd, 1);
   idx{1} = 1:k;
   z = cat (1, y(idx{:}), zeros (sz));
   idx{1} = k+1:m;
   z = cat (1, z, y(idx{:}));
+
+  ## When m is an even number of rows, the FFT has a single Nyquist bin.
+  ## If zero-padded above, distribute the value of the Nyquist bin evenly
+  ## between the new corresponding positive and negative frequency bins.
+  if (sz(1) > 0 && k == m/2)
+    idx{1} = n * inc - k + 1;
+    tmp = z(idx{:}) / 2;
+    z(idx{:}) = tmp;
+    idx{1} = k + 1;
+    z(idx{:}) = tmp;
+  endif
+
   z = n * ifft (z);
 
   if (inc != 1)
     sz(1) = n;
     z = inc * reshape (z(1:inc:end), sz);
   endif
 
   z = ipermute (z, perm);
@@ -103,16 +115,28 @@ endfunction
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps);
 %!assert (interpft (y', n), y', 20*eps);
 %!assert (interpft ([y,y],n), [y,y], 20*eps);
 
+%% Test case with complex input from bug #39566
+%!test
+%! x = (1 + j) * [1:4]';
+%! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
+%! assert (interpft (x, 6), y, 10*eps);
+
+%% Test for correct spectral symmetry with even/odd lengths
+%!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps);
+%!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps);
+%!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps);
+%!assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps);
+
 %% Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
 %!error <N must be a scalar integer> interpft (1,[2,2])
 %!error <N must be a scalar integer> interpft (1,2.1)
 %!error <invalid dimension DIM> interpft (1,2,0)
 %!error <invalid dimension DIM> interpft (1,2,3)
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -24,44 +24,44 @@
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two.
 ## Each element of the @var{n}-dimensional array @var{v} represents a value
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}.
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in
-## the "ndgrid" format or vectors.  The parameters @var{y1}, etc. respect a
-## similar format to @var{x1}, etc., and they represent the points at which
-## the array @var{vi} is interpolated.
+## the @qcode{"ndgrid"} format or vectors.  The parameters @var{y1}, etc.
+## respect a similar format to @var{x1}, etc., and they represent the points
+## at which the array @var{vi} is interpolated.
 ##
 ## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item "nearest"
+## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
-## @item "linear"
+## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors.
 ##
-## @item "cubic"
+## @item @qcode{"cubic"}
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item "spline"
+## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is "linear".
+## The default method is @qcode{"linear"}.
 ##
 ## If @var{extrapval} is the scalar value, use it to replace the values
 ## beyond the endpoints with that number.  If @var{extrapval} is missing,
 ## assume NA.
 ## @seealso{interp1, interp2, spline, ndgrid}
 ## @end deftypefn
 
 function vi = interpn (varargin)
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -18,23 +18,24 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isa (@var{obj}, @var{classname})
 ## Return true if @var{obj} is an object from the class @var{classname}.
 ##
 ## @var{classname} may also be one of the following class categories: 
 ##
 ## @table @asis
-## @item "float"
-## Floating point value comprising classes "double" and "single".
+## @item @qcode{"float"}
+## Floating point value comprising classes @qcode{"double"} and
+## @qcode{"single"}.
 ##
-## @item "integer"
+## @item @qcode{"integer"}
 ## Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.
 ##
-## @item "numeric"
+## @item @qcode{"numeric"}
 ## Numeric value comprising either a floating point or integer value.
 ## @end table
 ## @seealso{class, typeinfo}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-by: jwe
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -14,27 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isdir (@var{f})
 ## Return true if @var{f} is a directory.
-## @seealso{is_absolute_filename, is_rooted_relative_filename}
+## @seealso{exist, stat, is_absolute_filename, is_rooted_relative_filename}
 ## @end deftypefn
 
 function retval = isdir (f)
   if (nargin != 1)
     print_usage ("isdir");
   endif
 
   ## Exist returns an integer but isdir should return a logical.
   retval = (exist (f, "dir") == 7);
 
 endfunction
 
+
 %!assert (isdir (pwd ()))
 %!assert (! isdir ("this is highly unlikely to be a directory name"))
 
 %!error isdir ()
 %!error isdir (1, 2)
 
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequal (@var{x1}, @var{x2}, @dots{})
 ## Return true if all of @var{x1}, @var{x2}, @dots{} are equal.
-## @seealso{isequalwithequalnans}
+## @seealso{isequaln}
 ## @end deftypefn
 
 function retval = isequal (x1, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
@@ -69,8 +69,17 @@ endfunction
 %!assert (isequal ({'a','b','c','d'},{'a';'b';'c';'d'}), false)
 ## test for equality (struct)
 %!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
 %!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
 %!assert (isequal (struct ('a',"abc",'b',2),struct ('a',"abc",'b',2)), true)
 ## test for inequality (struct)
 %!assert (isequal (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), false)
 
+## test for sparse matrices
+%!assert (isequal (sparse (0,1), sparse (0,1)), true)
+%!assert (isequal (sparse (0,1), sparse (1,0)), false)
+%!assert (isequal (sparse (2, 2), sparse (2, 2)), true)
+
+## Input validation
+%!error isequal ()
+%!error isequal (1)
+
diff --git a/scripts/general/isequaln.m b/scripts/general/isequaln.m
new file mode 100644
--- /dev/null
+++ b/scripts/general/isequaln.m
@@ -0,0 +1,51 @@
+## Copyright (C) 2005-2012 William Poetra Yoga Hadisoeseno
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} isequaln (@var{x1}, @var{x2}, @dots{})
+## Return true if all of @var{x1}, @var{x2}, @dots{} are equal under the
+## additional assumption that NaN == NaN (no comparison of NaN placeholders
+## in dataset).
+## @seealso{isequal}
+## @end deftypefn
+
+function retval = isequaln (x1, varargin)
+
+  if (nargin < 2)
+    print_usage ();
+  endif
+
+  retval = __isequal__ (true, x1, varargin{:});
+
+endfunction
+
+
+## test for equality
+%!assert (isequaln ({1,2,NaN,4},{1,2,NaN,4}), true)
+%!assert (isequaln ([1,2,NaN,4],[1,2,NaN,4]), true)
+## test for inequality
+%!assert (isequaln ([1,2,NaN,4],[1,NaN,3,4]), false)
+%!assert (isequaln ([1,2,NaN,4],[1,2,3,4]), false)
+## test for equality (struct)
+%!assert (isequaln (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), true)
+%!assert (isequaln (1,2,1), false)
+
+## Input validation
+%!error isequaln ()
+%!error isequaln (1)
+
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -34,8 +34,9 @@
 ## @end example
 ##
 ## @seealso{saveobj, class}
 ## @end deftypefn
 
 function b = loadobj (a)
   error ('loadobj: not defined for class "%s"', class (a));
 endfunction
+
diff --git a/scripts/general/module.mk b/scripts/general/module.mk
--- a/scripts/general/module.mk
+++ b/scripts/general/module.mk
@@ -41,17 +41,17 @@ general_FCN_FILES = \
   general/interp2.m \
   general/interp3.m \
   general/interpn.m \
   general/interpft.m \
   general/isa.m \
   general/iscolumn.m \
   general/isdir.m \
   general/isequal.m \
-  general/isequalwithequalnans.m \
+  general/isequaln.m \
   general/isrow.m \
   general/isscalar.m \
   general/issquare.m \
   general/isvector.m \
   general/loadobj.m \
   general/logspace.m \
   general/methods.m \
   general/nargchk.m \
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -87,20 +87,19 @@ function retval = num2str (x, arg)
         fmt = sprintf ("%%%d.%dg", arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       if (isnumeric (x))
         ## Setup a suitable format string, ignoring inf entries
         dgt = floor (log10 (max (abs (x(!isinf (x(:)))))));
-
-        ## If the whole input array is inf...
         if (isempty (dgt))
-          dgt = 0;
+          ## If the whole input array is inf...
+          dgt = 1;
         endif
 
         if (any (x(:) != fix (x(:))))
           ## Floating point input
           dgt = max (dgt + 4, 5);   # Keep 4 sig. figures after decimal point
           dgt = min (dgt, 16);      # Cap significant digits at 16
           fmt = sprintf ("%%%d.%dg", dgt+7+any (x(:) < 0), dgt);
         else
@@ -110,33 +109,38 @@ function retval = num2str (x, arg)
           ##        See %!xtest below
           fmt = sprintf ("%%%d.%dg", dgt+2+any (x(:) < 0), dgt);
         endif
       else
         ## Logical input
         fmt = "%3d";
       endif
     endif
-    fmt = cstrcat (deblank (repmat (fmt, 1, columns (x))), "\n");
+    fmt = [deblank(repmat(fmt, 1, columns(x))), "\n"];
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     retval = strtrim (char (ostrsplit (tmp(1:end-1), "\n")));
   else   # Complex matrix input
     if (nargin == 2)
       if (ischar (arg))
-        fmt = cstrcat (arg, "%-+", arg(2:end), "i");
+        fmt = [arg "%-+" arg(2:end) "i"];
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0)
         fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       ## Setup a suitable format string
-      dgt = floor (log10 (max (max (abs (real (x(:)))),
-                               max (abs (imag (x(:)))))));
+      dgt = floor (log10 (max (max (abs (real (x(!isinf (real (x(:))))))),
+                               max (abs (imag (x(!isinf (imag (x(:))))))))));
+      if (isempty (dgt))
+        ## If the whole input array is inf...
+        dgt = 1;
+      endif
+
       if (any (x(:) != fix (x(:))))
         ## Floating point input
           dgt = max (dgt + 4, 5);   # Keep 4 sig. figures after decimal point
           dgt = min (dgt, 16);      # Cap significant digits at 16
           fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", dgt+7, dgt, dgt+7, dgt);
       else
         ## Integer input
         dgt = max (1 + dgt, 1);
@@ -152,17 +156,17 @@ function retval = num2str (x, arg)
     nd = ndims (x);
     idx = repmat ({':'}, nd, 1);
     perm(1:2:2*nc) = 1:nc;
     perm(2:2:2*nc) = nc + (1:nc);
     idx{2} = perm;
     x = horzcat (real (x), imag (x));
     x = x(idx{:});
 
-    fmt = cstrcat (deblank (repmat (fmt, 1, nc)), "\n");
+    fmt = [deblank(repmat(fmt, 1, nc)), "\n"];
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     tmp = regexprep (tmp, " +i\n", "i\n");
     tmp = regexprep (tmp, "( +)i", "i$1");
 
     retval = strtrim (char (ostrsplit (tmp(1:end-1), "\n")));
   endif
@@ -178,17 +182,26 @@ endfunction
 %!assert (num2str ([true false true]), "1  0  1");
 
 %!assert (num2str (19440606), "19440606")
 %!assert (num2str (2^33), "8589934592")
 %!assert (num2str (-2^33), "-8589934592")
 %!assert (num2str (2^33+1i), "8589934592+1i")
 %!assert (num2str (-2^33+1i), "-8589934592+1i")
 %!assert (num2str (inf), "Inf")
+%!assert (num2str ([inf -inf]), "Inf -Inf")
+%!assert (num2str ([complex(Inf,0), complex(0,-Inf)]), "Inf+0i   0-Infi")
+%!assert (num2str (complex(Inf,1)), "Inf+1i")
+%!assert (num2str (complex(1,Inf)), "1+Infi")
 %!assert (num2str (nan), "NaN")
+%!assert (num2str (complex (NaN, 1)), "NaN+1i")
+%!assert (num2str (complex (1, NaN)), "1+NaNi")
+%!assert (num2str (NA), "NA")
+%!assert (num2str (complex (NA, 1)), "NA+1i")
+%!assert (num2str (complex (1, NA)), "1+NAi")
 
 ## FIXME: Integers greater than bitmax() should be masked to show just
 ##        16 digits of precision.
 %!xtest
 %! assert (num2str (1e23), "100000000000000000000000");
 
 %!error num2str ()
 %!error num2str (1, 2, 3)
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -50,17 +50,17 @@ function [x, y, z] = pol2cart (theta, r,
       if (columns (theta) == 3)
         z = theta(:,3);
       else
         z = [];
       endif
       r = theta(:,2);
       theta = theta(:,1);
     else
-      error ("pol2car: matrix input must have 2 or 3 columns [THETA, R (, Z)]");
+      error ("pol2cart: matrix input must have 2 or 3 columns [THETA, R (, Z)]");
     endif
   elseif (nargin == 2)
     if (! ((ismatrix (theta) && ismatrix (r))
             && (size_equal (theta, r) || isscalar (theta) || isscalar (r))))
       error ("pol2cart: arguments must be matrices of same size, or scalar");
     endif
   elseif (nargin == 3)
     if (! ((ismatrix (theta) && ismatrix (r) && ismatrix (z))
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -43,20 +43,16 @@
 ##    a. struct     compare each member by name, not by order (recursive)
 ##    b. cell/list  compare each member by order (recursive)
 ##    c. char       compare each member with strcmp
 ##    d. <other>    compare each nonzero member, and assume NaN == NaN
 ##                  if nans_compare_equal is nonzero.
 
 function t = __isequal__ (nans_compare_equal, x, varargin)
 
-  if (nargin < 3)
-    print_usage ();
-  endif
-
   l_v = nargin - 2;
 
   ## Generic tests.
 
   ## All arguments must either be of the same class or they must be
   ## numeric values.
   t = (all (strcmp (class (x),
                     cellfun ("class", varargin, "uniformoutput", false)))
@@ -155,28 +151,35 @@ function t = __isequal__ (nans_compare_e
       l_f_x = length (f_x);
       x = x(f_x);
       for argn = 1:l_v
         y = varargin{argn};
         f_y = find (y);
 
         t = (l_f_x == length (f_y)) && all (f_x == f_y);
         if (!t)
-          return;
+          break;
         endif
 
         y = y(f_y);
         m = (x == y);
         t = all (m);
 
         if (!t && nans_compare_equal)
           t = isnan (x(!m)) && isnan (y(!m));
         endif
 
         if (!t)
-          return;
+          break;
         endif
       endfor
 
     endif
   endif
 
+  if (!t)
+    t = false;
+  else
+    t = true;
+  endif
+
 endfunction
+
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -21,29 +21,27 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} __splinen__ (@var{x}, @var{y}, @var{xi})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
-  if (nargin != 5)
-    error ("__splinen__: Incorrect number of arguments");
-  endif
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
   if (!iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
       || !iscell (xi) || length (xi) < ndims (y) || any (! cellfun (isvec, xi)))
-    error ("__splinen__: %s: non gridded data or dimensions inconsistent", f);
+    error ("__splinen__: %s: non-gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length (x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
   idx = zeros (size (xi{1}));
   for i = 1 : length (x)
     idx |= xi{i} < min (x{i}(:)) | xi{i} > max (x{i}(:));
   endfor
   yi(idx) = extrapval;
 endfunction
+
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -12,32 +12,36 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} profexplore (@var{data})
+## @deftypefn  {Function File} {} profexplore ()
+## @deftypefnx {Function File} {} profexplore (@var{data})
 ## Interactively explore hierarchical profiler output.
 ##
 ## Assuming @var{data} is the structure with profile data returned by
-## @code{profile ("info")}, this command opens an interactive prompt
+## @code{profile (@qcode{"info"})}, this command opens an interactive prompt
 ## that can be used to explore the call-tree.  Type @kbd{help} to get a list
-## of possible commands.
+## of possible commands.  If @var{data} is omitted, @code{profile ("info")}
+## is called and used in its place.
 ## @seealso{profile, profshow}
 ## @end deftypefn
 
 ## Built-in profiler.
 ## Author: Daniel Kraft <d@domob.eu>
 
 function profexplore (data)
 
-  if (nargin != 1)
+  if (nargin == 0)
+    data = profile ("info");
+  elseif (nargin != 1)
     print_usage ();
   endif
 
   ## The actual work is done by a recursive worker function, since that
   ## is an easy way to traverse the tree datastructure.  Here, we just check
   ## the arguments (already done) and give over to it.
 
   __profexplore_worker (data.FunctionTable, data.Hierarchical, "Top\n", "  ");
@@ -73,22 +77,23 @@ function rv = __profexplore_worker (fcn_
                             tree(i).TotalTime, tree(i).SelfTime);
       printf ("%s%d) %s\n", prefix, i, strings{i});
     endfor
     printf ("\n");
 
     cmd = input ("profexplore> ", "s");
     option = fix (str2double (cmd));
 
-    if (strcmp (cmd, "exit"))
+    if (strcmp (cmd, "exit") || strcmp (cmd, "quit"))
       rv = 0;
       return;
     elseif (strcmp (cmd, "help"))
       printf ("\nCommands for profile explorer:\n\n");
       printf ("exit   Return to Octave prompt.\n");
+      printf ("quit   Return to Octave prompt.\n");
       printf ("help   Display this help message.\n");
       printf ("up [N] Go up N levels, where N is an integer.  Default is 1.\n");
       printf ("N      Go down a level into option N.\n");
     elseif (! isnan (option))
       if (option < 1 || option > length (tree))
         printf ("The chosen option is out of range!\n");
       else
         newParents = sprintf ("%s%s%s\n", parents, prefix, strings{option});
@@ -125,8 +130,9 @@ function rv = __profexplore_worker (fcn_
       printf (" information.\n");
     else
       printf ("Unrecognized input.  Type 'help' to get a list of possible");
       printf (" commands.\n");
     endif
 
   endwhile
 endfunction
+
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -39,17 +39,17 @@
 ##
 ## @item profile resume
 ## Restart profiling without cleaning up the old data and instead
 ## all newly collected statistics are added to the already existing ones.
 ##
 ## @item @var{S} = profile ("status")
 ## Return a structure filled with certain information about the current status
 ## of the profiler.  At the moment, the only field is @code{ProfilerStatus}
-## which is either "on" or "off".
+## which is either @qcode{"on"} or @qcode{"off"}.
 ##
 ## @item @var{T} = profile ("info")
 ## Return the collected profiling statistics in the structure @var{T}.
 ## The flat profile is returned in the field @code{FunctionTable} which is an
 ## array of structures, each entry corresponding to a function which was called
 ## and for which profiling statistics are present.  Furthermore, the field
 ## @code{Hierarchical} contains the hierarchical call-tree.  Each node
 ## has an index into the @code{FunctionTable} identifying the function it
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -56,39 +56,39 @@
 ## The algorithm used by @code{quadgk} involves subdividing the
 ## integration interval and evaluating each subinterval.
 ## If @var{trace} is true then after computing each of these partial
 ## integrals display: (1) the number of subintervals at this step,
 ## (2) the current estimate of the error @var{err}, (3) the current estimate
 ## for the integral @var{q}.
 ##
 ## Alternatively, properties of @code{quadgk} can be passed to the function as
-## pairs @code{"@var{prop}", @var{val}}.  Valid properties are
+## pairs @qcode{"@var{prop}", @var{val}}.  Valid properties are
 ##
 ## @table @code
 ## @item AbsTol
 ## Define the absolute error tolerance for the quadrature.  The default
 ## absolute tolerance is 1e-10.
 ##
 ## @item RelTol
 ## Define the relative error tolerance for the quadrature.  The default
 ## relative tolerance is 1e-5.
 ##
 ## @item MaxIntervalCount
 ## @code{quadgk} initially subdivides the interval on which to perform
 ## the quadrature into 10 intervals.  Subintervals that have an
 ## unacceptable error are subdivided and re-evaluated.  If the number of
 ## subintervals exceeds 650 subintervals at any point then a poor
 ## convergence is signaled and the current estimate of the integral is
-## returned.  The property "MaxIntervalCount" can be used to alter the
+## returned.  The property @qcode{"MaxIntervalCount"} can be used to alter the
 ## number of subintervals that can exist before exiting.
 ##
 ## @item WayPoints
 ## Discontinuities in the first derivative of the function to integrate can be
-## flagged with the  @code{"WayPoints"} property.  This forces the ends of
+## flagged with the @qcode{"WayPoints"} property.  This forces the ends of
 ## a subinterval to fall on the breakpoints of the function and can result in
 ## significantly improved estimation of the error in the integral, faster
 ## computation, or both.  For example,
 ##
 ## @example
 ## quadgk (@@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)
 ## @end example
 ##
@@ -449,11 +449,12 @@ endfunction
 %!assert (quadgk (@(x) 1./sqrt (x),0,1), 2, 1e-6)
 %!assert (quadgk (@(x) abs (1 - x.^2),0,2, "Waypoints", 1), 2, 1e-6)
 %!assert (quadgk (@(x) 1./(sqrt (x) .* (x+1)),0,Inf), pi, 1e-6)
 %!assert (quadgk (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
 
 %!assert (quadgk (@(x) exp (-x .^ 2),-Inf,Inf), sqrt (pi), 1e-6)
 %!assert (quadgk (@(x) exp (-x .^ 2),-Inf,0), sqrt (pi)/2, 1e-6)
 
-%error (quadgk (@sin))
-%error (quadgk (@sin, -pi))
-%error (quadgk (@sin, -pi, pi, "DummyArg"))
+%!error (quadgk (@sin))
+%!error (quadgk (@sin, -pi))
+%!error (quadgk (@sin, -pi, pi, "DummyArg"))
+
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -101,17 +101,17 @@ function [q, nfun] = quadv (f, a, b, tol
   h = (b - a);
   q = (b - a) / 6 * (fa + 4 * fc + fb);
 
   [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, nfun, abs (h),
                                 tol, trace, varargin{:});
 
   if (nfun > 10000)
     warning ("maximum iteration count reached");
-  elseif (any (isnan (q)(:) | isinf (q)(:)))
+  elseif (any (! isfinite (q(:))))
     warning ("infinite or NaN function evaluations were returned");
   elseif (hmin < (b - a) * myeps)
     warning ("minimum step size reached -- possibly singular integral");
   endif
 endfunction
 
 function [q, nfun, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0,
                                        nfun, hmin, tol, trace, varargin)
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -29,27 +29,27 @@
 ## argument @var{n} is specified then a square matrix @w{(@var{n} x @var{n})} is
 ## returned.  Two or more arguments will return a multi-dimensional
 ## matrix @w{(@var{m} x @var{n} x @dots{})}.
 ##
 ## The integer range may optionally be described by a two element matrix
 ## with a lower and upper bound in which case the returned integers will be
 ## on the interval @w{[@var{imin}, @var{imax}]}.
 ##
-## The optional argument "@var{class}" will return a matrix of the requested
-## type.  The default is "double".
+## The optional argument @var{class} will return a matrix of the requested
+## type.  The default is @qcode{"double"}.
 ##
 ## The following example returns 150 integers in the range 1-10.
 ##
 ## @example
 ## ri = randi (10, 150, 1)
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
-## uses class "double" to represent numbers.  This limits the maximum
+## uses class @qcode{"double"} to represent numbers.  This limits the maximum
 ## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
 ## this value is @w{@math{2^{53} - 1}}.
 ##
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
@@ -106,16 +106,17 @@ function ri = randi (bounds, varargin)
   ri = imin + floor ( (imax-imin+1)*rand (varargin{:}) );
 
   if (! strcmp (rclass, "double"))
     ri = cast (ri, rclass);
   endif
 
 endfunction
 
+
 %!test
 %! ri = randi (10, 1000, 1);
 %! assert (ri, fix (ri));
 %! assert (min (ri), 1);
 %! assert (max (ri), 10);
 %! assert (rows (ri), 1000);
 %! assert (columns (ri), 1);
 %! assert (class (ri), "double");
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -112,24 +112,25 @@ function x = repmat (A, m, n)
     aidx(end+1:length (idx)) = 1;
     ## create subscript array
     cidx = cell (2, length (aidx));
     for i = 1:length (aidx)
       cidx{1,i} = ':';
       cidx{2,i} = ones (1, idx (i));
     endfor
     aaidx = aidx;
-    # add singleton dims
+    ## add singleton dims
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
+
 # Tests for ML compatibility
 %!shared x
 %! x = [1 2 3];
 %!assert (repmat (x, [3, 1]), repmat (x, 3, []))
 %!assert (repmat (x, [3, 1]), repmat (x, [], 3))
 %!assert (repmat (x, [1, 3]), repmat (x, [], [1, 3]))
 %!assert (repmat (x, [1, 3]), repmat (x, [1, 3], []))
 %!assert (repmat (x, [1 3]), repmat (x, [1 3; 3 3]))
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -37,8 +37,9 @@
 ## @end example
 ##
 ## @seealso{loadobj, class}
 ## @end deftypefn
 
 function b = saveobj (a)
   error ('saveobj: not defined for class "%s"', class (a));
 endfunction
+
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -29,51 +29,51 @@
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of
 ## an inline function, function handle, or the name of a function (in a
 ## character string).  In the case of a character string argument, the
 ## function must accept a single argument named @var{x}, and it must return
 ## a string value.  If the function returns more than one argument, they are
 ## returned as separate output variables.
 ##
-## If the parameter "UniformOutput" is set to true (the default), then the
-## function
-## must return a single element which will be concatenated into the
-## return value.  If "UniformOutput" is false, the outputs are placed into a
-## structure
-## with the same fieldnames as the input structure.
+## If the parameter @qcode{"UniformOutput"} is set to true (the default),
+## then the function must return a single element which will be concatenated
+## into the return value.  If @qcode{"UniformOutput"} is false, the outputs
+## are placed into a structure with the same fieldnames as the input
+## structure.
 ##
 ## @example
 ## @group
 ## s.name1 = "John Smith";
 ## s.name2 = "Jill Jones";
 ## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s,
 ##            "UniformOutput", false)
 ## @result{}
 ##    @{
 ##      name1 = Smith
 ##      name2 = Jones
 ##    @}
 ## @end group
 ## @end example
 ##
-## Given the parameter "ErrorHandler", @var{errfunc} defines a function to
-## call in case @var{func} generates an error.  The form of the function is
+## Given the parameter @qcode{"ErrorHandler"}, @var{errfunc} defines a
+## function to call in case @var{func} generates an error.  The form of the
+## function is
 ##
 ## @example
 ## function [@dots{}] = errfunc (@var{se}, @dots{})
 ## @end example
 ##
 ## @noindent
 ## where there is an additional input argument to @var{errfunc} relative to
 ## @var{func}, given by @nospell{@var{se}}.  This is a structure with the
-## elements "identifier", "message" and "index", giving respectively the error
-## identifier, the error message, and the index into the input arguments
-## of the element that caused the error.  For an example on how to use
-## an error handler, @pxref{docXcellfun, @code{cellfun}}.
+## elements @qcode{"identifier"}, @qcode{"message"} and @qcode{"index"},
+## giving respectively the error identifier, the error message, and the index
+## into the input arguments of the element that caused the error.  For an
+## example on how to use an error handler, @pxref{XREFcellfun,,cellfun}.
 ##
 ## @seealso{cellfun, arrayfun, spfun}
 ## @end deftypefn
 
 function varargout = structfun (func, S, varargin);
 
   if (nargin < 2)
     print_usage ();
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} subsindex (@var{a})
 ## Convert an object to an index vector.  When @var{a} is a class object
 ## defined with a class constructor, then @code{subsindex} is the
 ## overloading method that allows the conversion of this class object to
 ## a valid indexing vector.  It is important to note that
 ## @code{subsindex} must return a zero-based real integer vector of the
-## class "double".  For example, if the class constructor
+## class @qcode{"double"}.  For example, if the class constructor
 ##
 ## @example
 ## @group
 ## function b = myclass (a)
 ##   b = class (struct ("a", a), "myclass");
 ## endfunction
 ## @end group
 ## @end example
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -35,17 +35,18 @@
 ## The optional argument @var{tol} defines the absolute tolerance used to
 ## integrate each sub-integral.  The default value is @math{1e^{-6}}.
 ##
 ## The optional argument @var{quadf} specifies which underlying integrator
 ## function to use.  Any choice but @code{quad} is available and the default
 ## is @code{quadcc}.
 ##
 ## Additional arguments, are passed directly to @var{f}.  To use the default
-## value for @var{tol} or @var{quadf} one may pass ':' or an empty matrix ([]).
+## value for @var{tol} or @var{quadf} one may pass @qcode{':'} or an empty
+## matrix ([]).
 ## @seealso{dblquad, quad, quadv, quadl, quadgk, quadcc, trapz}
 ## @end deftypefn
 
 function q = triplequad (f, xa, xb, ya, yb, za, zb, tol = 1e-6, quadf = @quadcc, varargin)
 
   if (nargin < 7)
     print_usage ();
   endif
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -13,30 +13,33 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} delaunay (@var{x}, @var{y})
-## @deftypefnx {Function File} {@var{tri} =} delaunay (@var{x}, @var{y})
-## @deftypefnx {Function File} {@var{tri} =} delaunay (@var{x}, @var{y}, @var{options})
+## @deftypefnx {Function File} {} delaunay (@var{x})
+## @deftypefnx {Function File} {} delaunay (@dots{}, @var{options})
+## @deftypefnx {Function File} {@var{tri} =} delaunay (@dots{})
 ## Compute the Delaunay triangulation for a 2-D set of points.
 ## The return value @var{tri} is a set of triangles which satisfies the
 ## Delaunay circum-circle criterion, i.e., only a single data point from
 ## [@var{x}, @var{y}] is within the circum-circle of the defining triangle.
+## The input @var{x} may also be a matrix with two columns where the first
+## column contains x-data and the second y-data.
 ##
 ## The set of triangles @var{tri} is a matrix of size [n, 3].  Each
 ## row defines a triangle and the three columns are the three vertices
 ## of the triangle.  The value of @code{@var{tri}(i,j)} is an index into
 ## @var{x} and @var{y} for the location of the j-th vertex of the i-th
 ## triangle.
 ##
-## An optional third argument, which must be a string or cell array of strings,
+## The optional last argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ## The default options are @code{@{"Qt", "Qbb", "Qc", "Qz"@}}.
 ##
 ## If @var{options} is not present or @code{[]} then the default arguments are
 ## used.  Otherwise, @var{options} replaces the default argument list. 
 ## To append user options to the defaults it is necessary to repeat the 
@@ -56,34 +59,66 @@
 ## plot (VX, VY, "b", x, y, "r*");
 ## @end group
 ## @end example
 ## @seealso{delaunay3, delaunayn, convhull, voronoi, triplot, trimesh, trisurf}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
-function tri = delaunay (x, y, options)
+function tri = delaunay (varargin)
 
-  if (nargin != 2 && nargin != 3)
+  if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (! (isvector (x) && isvector (y) && length (x) == length (y))
-      && ! size_equal (x, y))
+  options = [];
+
+  switch (nargin)
+
+    case 1
+      if (! ismatrix (varargin{1}) || columns (varargin{1}) != 2)
+          error ("delaunay: X must be a matrix with 2 columns");
+      else
+        x = varargin{1}(:,1);
+        y = varargin{1}(:,2);
+      endif
+    
+    case 2
+      if (isnumeric (varargin{2}))
+        x = varargin{1};
+        y = varargin{2};
+      elseif (ischar (varargin{2}) || iscellstr (varargin{2}))
+        options = varargin{2};
+        if (! ismatrix (varargin{1}) && columns (varargin{1}) != 2)
+            error ("delaunay: X must be a matrix with 2 columns");
+        else
+          x = varargin{1}(:,1);
+          y = varargin{1}(:,2);
+        endif
+      else
+        error ("delaunay: OPTIONS must be a string or cell array of strings");
+      endif
+
+    case 3
+      x = varargin{1};
+      y = varargin{2};
+      options = varargin{3};
+
+      if (! (ischar (options) || iscellstr (options)))
+        error ("delaunay: OPTIONS must be a string or cell array of strings");
+      endif
+
+  endswitch
+
+  if (! (isequal(size(x),size(y))))
     error ("delaunay: X and Y must be the same size");
-  elseif (nargin == 3 && ! (ischar (options) || iscellstr (options)))
-    error ("delaunay: OPTIONS must be a string or cell array of strings");
   endif
 
-  if (nargin == 2)
-    T = delaunayn ([x(:), y(:)]);
-  else
-    T = delaunayn ([x(:), y(:)], options);
-  endif
+  T = delaunayn ([x(:), y(:)], options);
 
   if (nargout == 0)
     x = x(:).';
     y = y(:).';
     VX = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
     VY = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
     plot (VX, VY, "b", x, y, "r*");
   else
@@ -107,14 +142,28 @@ endfunction
 %! axis ([0,1,0,1]);
 
 %!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0];
 %! y = [0, 1, 0, -1];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;2,3,4]);
 
 %!testif HAVE_QHULL
+%! x = [-1, 0, 1, 0];
+%! y = [0, 1, 0, -1];
+%! assert (sortrows (sort (delaunay ([x(:) y(:)]), 2)), [1,2,4;2,3,4]);
+
+%!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0, 0];
 %! y = [0, 1, 0, -1, 0];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,5;1,4,5;2,3,5;3,4,5]);
 
+%!testif HAVE_QHULL
+%! x = [-1, 0; 0, 1; 1, 0; 0, -1; 0, 0];
+%! assert (sortrows (sort (delaunay (x), 2)), [1,2,5;1,4,5;2,3,5;3,4,5]);
+
+%!testif HAVE_QHULL
+%! x = [1 5 2; 5 6 7];
+%! y = [5 7 8; 1 2 3];
+%! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;1,3,4;1,3,5;3,4,6]);
+
 %% FIXME: Need input validation tests
 
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -24,18 +24,18 @@
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{z} = f (@var{x}, @var{y})}.
 ## Inputs @code{@var{x}, @var{y}, @var{z}} are vectors of the same length
 ## or @code{@var{x}, @var{y}} are vectors and @code{@var{z}} is matrix.
 ##
 ## The interpolation points are all @code{(@var{xi}, @var{yi})}.  If
 ## @var{xi}, @var{yi} are vectors then they are made into a 2-D mesh.
 ##
-## The interpolation method can be @code{"nearest"}, @code{"cubic"} or
-## @code{"linear"}.  If method is omitted it defaults to @code{"linear"}.
+## The interpolation method can be @qcode{"nearest"}, @qcode{"cubic"} or
+## @qcode{"linear"}.  If method is omitted it defaults to @qcode{"linear"}.
 ## @seealso{griddata3, griddatan, delaunay}
 ## @end deftypefn
 
 ## Author:      Kai Habel <kai.habel@gmx.de>
 ## Adapted-by:  Alexander Barth <barth.alexander@gmail.com>
 ##              xi and yi are not "meshgridded" if both are vectors
 ##              of the same size (for compatibility)
 
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -20,18 +20,18 @@
 ## @deftypefn  {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{v} = f (@var{x}, @var{y}, @var{z})}.
 ## The interpolation points are specified by @var{xi}, @var{yi}, @var{zi}.
 ##
-## The interpolation method can be @code{"nearest"} or @code{"linear"}.
-## If method is omitted it defaults to @code{"linear"}.
+## The interpolation method can be @qcode{"nearest"} or @qcode{"linear"}.
+## If method is omitted it defaults to @qcode{"linear"}.
 ##
 ## The optional argument @var{options} is passed directly to Qhull when
 ## computing the Delaunay triangulation used for interpolation.  See
 ## @code{delaunayn} for information on the defaults and how to pass different
 ## values.
 ## @seealso{griddata, griddatan, delaunayn}
 ## @end deftypefn
 
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -20,18 +20,18 @@
 ## @deftypefn  {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x})}.
 ## The interpolation points are all @var{xi}.
 ##
-## The interpolation method can be @code{"nearest"} or @code{"linear"}.
-## If method is omitted it defaults to @code{"linear"}.
+## The interpolation method can be @qcode{"nearest"} or @qcode{"linear"}.
+## If method is omitted it defaults to @qcode{"linear"}.
 ## 
 ## The optional argument @var{options} is passed directly to Qhull when
 ## computing the Delaunay triangulation used for interpolation.  See
 ## @code{delaunayn} for information on the defaults and how to pass different
 ## values.
 ## @seealso{griddata, griddata3, delaunayn}
 ## @end deftypefn
 
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006-2012 Frederick (Rick) A Niles
-##               and Sren Hauberg
+##               and Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,17 +25,17 @@
 ## The variables @var{x}, @var{y}, must have the same dimension.  The optional
 ## output @var{on} gives the points that are on the polygon.
 ##
 ## @end deftypefn
 
 ## Author: Frederick (Rick) A Niles <niles@rickniles.com>
 ## Created: 14 November 2006
 
-## Vectorized by Sren Hauberg <soren@hauberg.org>
+## Vectorized by Sren Hauberg <soren@hauberg.org>
 
 ## The method for determining if a point is in in a polygon is based on
 ## the algorithm shown on
 ## http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/ and is
 ## credited to Randolph Franklin.
 
 function [in, on] = inpolygon (x, y, xv, yv)
 
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -21,19 +21,20 @@
 ## @deftypefnx {Function File} {} voronoi (@var{x}, @var{y}, @var{options})
 ## @deftypefnx {Function File} {} voronoi (@dots{}, "linespec")
 ## @deftypefnx {Function File} {} voronoi (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} voronoi (@dots{})
 ## @deftypefnx {Function File} {[@var{vx}, @var{vy}] =} voronoi (@dots{})
 ## Plot the Voronoi diagram of points @code{(@var{x}, @var{y})}.
 ## The Voronoi facets with points at infinity are not drawn.
 ## 
-## If "linespec" is given it is used to set the color and line style of the
-## plot.  If an axis graphics handle @var{hax} is supplied then the Voronoi
-## diagram is drawn on the specified axis rather than in a new figure.
+## If @qcode{"linespec"} is given it is used to set the color and line style
+## of the plot.  If an axis graphics handle @var{hax} is supplied then the
+## Voronoi diagram is drawn on the specified axis rather than in a new
+## figure.
 ##
 ## The @var{options} argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
 ## plotted and a graphics handle @var{h} to the plot is returned.
@@ -69,23 +70,23 @@
 function [vx, vy] = voronoi (varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   narg = 1;
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    handl = varargin{1};
-    if (! strcmp (get (handl, "type"), "axes"))
-      error ("voronoi: expecting first argument to be an axes object");
+    hax = varargin{1};
+    if (! isaxes (harg))
+      error ("imagesc: HAX argument must be an axes object");
     endif
     narg++;
   elseif (nargout < 2)
-    handl = gca ();
+    hax = gca ();
   endif
 
   if (nargin < 1 + narg || nargin > 3 + narg)
     print_usage ();
   endif
 
   x = varargin{narg++};
   y = varargin{narg++};
@@ -149,17 +150,17 @@ function [vx, vy] = voronoi (varargin)
                 ismember (edges(2, :), poutside);
   edges(:, edgeoutside) = [];
 
   ## Get points of the diagram
   Vvx = reshape (p(edges, 1), size (edges));
   Vvy = reshape (p(edges, 2), size (edges));
 
   if (nargout < 2)
-    h = plot (handl, Vvx, Vvy, linespec{:}, x, y, '+');
+    h = plot (hax, Vvx, Vvy, linespec{:}, x, y, '+');
     lim = [xmin, xmax, ymin, ymax];
     axis (lim + 0.1 * [[-1, 1] * xdelta, [-1, 1] * ydelta]);
     if (nargout == 1)
       vx = h;
     endif
   else
     vx = Vvx;
     vy = Vvy;
diff --git a/scripts/plot/guidata.m b/scripts/gui/guidata.m
rename from scripts/plot/guidata.m
rename to scripts/gui/guidata.m
--- a/scripts/plot/guidata.m
+++ b/scripts/gui/guidata.m
@@ -12,41 +12,56 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{data} =} guidata (@var{handle})
-## @deftypefnx {Function File} {} guidata (@var{handle}, @var{data})
+## @deftypefn  {Function File} {@var{data} =} guidata (@var{h})
+## @deftypefnx {Function File} {} guidata (@var{h}, @var{data})
+## Query or set user-custom GUI data.
+##
+## The GUI data is stored in the figure handle @var{h}.  If @var{h} is not a
+## figure handle then it's parent figure will be used for storage.
+##
+## @var{data} must be a single object which means it is usually preferable
+## for it to be a data container such as a cell array or struct so that
+## additional data items can be added easily.
+##
+## @seealso{getappdata, setappdata, get, set, getpref, setpref}
 ## @end deftypefn
 
 ## Author: goffioul
 
-function varargout = guidata (varargin)
+function dataout = guidata (h, data)
 
-  if (nargin == 1 || nargin == 2)
-    h = varargin{1};
-    if (ishandle (h))
-      h = ancestor (h, "figure");
-      if (! isempty (h))
-        if (nargin == 1)
-          varargout{1} = get (h, "__guidata__");
-        else
-          data = varargin{2};
-          set (h, "__guidata__", data);
-          if (nargout == 1)
-            varargout{1} = data;
-          endif
-        endif
-      else
-        error ("no ancestor figure found");
-      endif
-    else
-      error ("invalid object handle");
-    endif
-  else
+  if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
+  if (! ishandle (h))
+    error ("guidata: H must be a valid object handle");
+  endif
+  h = ancestor (h, "figure");
+  if (isempty (h))
+    error ("guidata: no ancestor figure of H found");
+  endif
+
+  if (nargin == 1)
+    dataout = get (h, "__guidata__");
+  else
+    set (h, "__guidata__", data);
+    if (nargout == 1)
+      dataout = data;
+    endif
+  endif
+
 endfunction
+
+
+%% Test input validation
+%!error guidata ()
+%!error guidata (1,2,3)
+%!error <H must be a valid object handle> guidata ({1})
+%!error <no ancestor figure of H found> guidata (0)
+
diff --git a/scripts/plot/guihandles.m b/scripts/gui/guihandles.m
rename from scripts/plot/guihandles.m
rename to scripts/gui/guihandles.m
--- a/scripts/plot/guihandles.m
+++ b/scripts/gui/guihandles.m
@@ -12,45 +12,54 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{hdata} =} guihandles (@var{handle})
+## @deftypefn  {Function File} {@var{hdata} =} guihandles (@var{h})
 ## @deftypefnx {Function File} {@var{hdata} =} guihandles
+## Return a structure of object handles for the figure associated with
+## handle @var{h}.
+## 
+## If no handle is specified the current figure returned by @code{gcf} is used.
+##
+## The fieldname for each entry of @var{hdata} is taken from the @qcode{"tag"}
+## property of the graphic object.  If the tag is empty then the handle is not
+## returned.  If there are multiple graphic objects with the same tag then
+## the entry in @var{hdata} will be a vector of handles.  @code{guihandles}
+## includes all possible handles, including those for
+## which @qcode{"HandleVisibility"} is @qcode{"off"}.
+## @seealso{guidata, findobj, findall, allchild}
 ## @end deftypefn
 
 ## Author: goffioul
 
-function hdata = guihandles (varargin)
-
-  hdata = [];
+function hdata = guihandles (h)
 
-  if (nargin == 0 || nargin == 1)
-    if (nargin == 1)
-      h = varargin{1};
-      if (ishandle (h))
-        h = ancestor (h, "figure");
-        if (isempty (h))
-          error ("no ancestor figure found");
-        endif
-      else
-        error ("invalid object handle");
-      endif
-    else
-      h = gcf ();
-    endif
-    hdata = __make_guihandles_struct__ (h, hdata);
-  else
+  if (nargin > 2)
     print_usage ();
   endif
 
+  if (nargin == 1)
+    if (! ishandle (h))
+      error ("guidata: H must be a valid object handle");
+    endif
+    h = ancestor (h, "figure");
+    if (isempty (h))
+      error ("guidata: no ancestor figure of H found");
+    endif
+  else
+    h = gcf ();
+  endif
+
+  hdata = __make_guihandles_struct__ (h, []);
+
 endfunction
 
 function hdata = __make_guihandles_struct__ (h, hdata)
 
   tag = get (h, "tag");
   if (! isempty (tag))
     if (isfield (hdata, tag))
       hdata.(tag) = [hdata.(tag), h];
@@ -58,13 +67,14 @@ function hdata = __make_guihandles_struc
       try
         hdata.(tag) = h;
       catch
       end_try_catch
     endif
   endif
 
   kids = allchild (h);
-  for i = 1 : length (kids)
-    hdata = __make_guihandles_struct__ (kids(i), hdata);
+  for hkid = kids'
+    hdata = __make_guihandles_struct__ (hkid, hdata);
   endfor
 
 endfunction
+
diff --git a/scripts/gui/module.mk b/scripts/gui/module.mk
new file mode 100644
--- /dev/null
+++ b/scripts/gui/module.mk
@@ -0,0 +1,35 @@
+FCN_FILE_DIRS += gui
+
+gui_PRIVATE_FCN_FILES = \
+  gui/private/__file_filter__.m \
+  gui/private/__fltk_file_filter__.m \
+  gui/private/__is_function__.m \
+  gui/private/__uigetdir_fltk__.m \
+  gui/private/__uigetfile_fltk__.m \
+  gui/private/__uiobject_split_args__.m \
+  gui/private/__uiputfile_fltk__.m
+
+gui_FCN_FILES = \
+  gui/guidata.m \
+  gui/guihandles.m \
+  gui/uicontextmenu.m \
+  gui/uicontrol.m \
+  gui/uigetdir.m \
+  gui/uigetfile.m \
+  gui/uimenu.m \
+  gui/uipanel.m \
+  gui/uipushtool.m \
+  gui/uiputfile.m \
+  gui/uiresume.m \
+  gui/uitoggletool.m \
+  gui/uitoolbar.m \
+  gui/uiwait.m \
+  gui/waitbar.m \
+  gui/waitforbuttonpress.m \
+  $(gui_PRIVATE_FCN_FILES)
+
+FCN_FILES += $(gui_FCN_FILES)
+
+PKG_ADD_FILES += gui/PKG_ADD
+
+DIRSTAMP_FILES += gui/$(octave_dirstamp)
diff --git a/scripts/plot/private/__file_filter__.m b/scripts/gui/private/__file_filter__.m
rename from scripts/plot/private/__file_filter__.m
rename to scripts/gui/private/__file_filter__.m
--- a/scripts/plot/private/__file_filter__.m
+++ b/scripts/gui/private/__file_filter__.m
@@ -86,8 +86,9 @@ function name = __default_filtername__ (
     extlist = toupper (extlist);
     extlist(end+1, :) = repmat ({","}, 1, length (extlist));
     extlist = strcat (extlist{:});
     extlist = extlist(1:end-1);
     name = strcat (extlist, "-Files");
   endif
 
 endfunction
+
diff --git a/scripts/plot/private/__fltk_file_filter__.m b/scripts/gui/private/__fltk_file_filter__.m
rename from scripts/plot/private/__fltk_file_filter__.m
rename to scripts/gui/private/__fltk_file_filter__.m
--- a/scripts/plot/private/__fltk_file_filter__.m
+++ b/scripts/gui/private/__fltk_file_filter__.m
@@ -57,8 +57,9 @@ function retval = __fltk_file_filter__ (
     else
       fltk_str = strcat (curr_desc, " (", curr_ext, ")");
     endif
 
   endfor
   retval = fltk_str;
 
 endfunction
+
diff --git a/scripts/plot/private/__is_function__.m b/scripts/gui/private/__is_function__.m
rename from scripts/plot/private/__is_function__.m
rename to scripts/gui/private/__is_function__.m
--- a/scripts/plot/private/__is_function__.m
+++ b/scripts/gui/private/__is_function__.m
@@ -24,8 +24,9 @@
 ## Author: Michael Goffioul
 
 function result = __is_function__ (func)
 
   existval = exist (func);
   result = (existval == 2 || existval == 3 || existval == 5 || existval == 6);
 
 endfunction
+
diff --git a/scripts/plot/private/__uigetdir_fltk__.m b/scripts/gui/private/__uigetdir_fltk__.m
rename from scripts/plot/private/__uigetdir_fltk__.m
rename to scripts/gui/private/__uigetdir_fltk__.m
--- a/scripts/plot/private/__uigetdir_fltk__.m
+++ b/scripts/gui/private/__uigetdir_fltk__.m
@@ -27,8 +27,9 @@ function dirname = __uigetdir_fltk__ (st
 
   if (exist ("__fltk_uigetfile__") != 3)
     error ("uigetdir: fltk graphics toolkit required");
   endif
 
   dirname = __fltk_uigetfile__ ("", dialog_title, start_path, [240, 120], "dir");
 
 endfunction
+
diff --git a/scripts/plot/private/__uigetfile_fltk__.m b/scripts/gui/private/__uigetfile_fltk__.m
rename from scripts/plot/private/__uigetfile_fltk__.m
rename to scripts/gui/private/__uigetfile_fltk__.m
--- a/scripts/plot/private/__uigetfile_fltk__.m
+++ b/scripts/gui/private/__uigetfile_fltk__.m
@@ -31,8 +31,9 @@ function [retval, retpath, retindex] = _
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
   [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, multiselect);
 
 endfunction
+
diff --git a/scripts/plot/private/__uiobject_split_args__.m b/scripts/gui/private/__uiobject_split_args__.m
rename from scripts/plot/private/__uiobject_split_args__.m
rename to scripts/gui/private/__uiobject_split_args__.m
--- a/scripts/plot/private/__uiobject_split_args__.m
+++ b/scripts/gui/private/__uiobject_split_args__.m
@@ -59,8 +59,9 @@ function [parent, args] = __uiobject_spl
       error ("%s: invalid parent, the parent type must be: %s", ...
              who, sprintf ("%s, ", parent_type{:})(1:end-2));
     endif
   elseif (use_gcf)
     parent = gcf ();
   endif
 
 endfunction
+
diff --git a/scripts/plot/private/__uiputfile_fltk__.m b/scripts/gui/private/__uiputfile_fltk__.m
rename from scripts/plot/private/__uiputfile_fltk__.m
rename to scripts/gui/private/__uiputfile_fltk__.m
--- a/scripts/plot/private/__uiputfile_fltk__.m
+++ b/scripts/gui/private/__uiputfile_fltk__.m
@@ -31,8 +31,9 @@ function [retval, retpath, retindex] = _
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
   [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, tag);
 
 endfunction
+
diff --git a/scripts/plot/uicontextmenu.m b/scripts/gui/uicontextmenu.m
rename from scripts/plot/uicontextmenu.m
rename to scripts/gui/uicontextmenu.m
--- a/scripts/plot/uicontextmenu.m
+++ b/scripts/gui/uicontextmenu.m
@@ -23,8 +23,9 @@
 ## Author: goffioul
 
 function handle = uicontextmenu (varargin)
 
   [h, args] = __uiobject_split_args__ ("uicontextmenu", varargin, {"figure"});
   handle = __go_uicontextmenu__ (h, args{:});
 
 endfunction
+
diff --git a/scripts/plot/uicontrol.m b/scripts/gui/uicontrol.m
rename from scripts/plot/uicontrol.m
rename to scripts/gui/uicontrol.m
--- a/scripts/plot/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -29,8 +29,9 @@ function handle = uicontrol (varargin)
   if (nargin == 1 && ishandle (varargin{1}) && strcmpi (get (varargin{1}, "type"), "uicontrol"))
     error ("uicontrol focusing not implemented yet.");
   else
     [h, args] = __uiobject_split_args__ ("uicontrol", varargin, {"figure", "uipanel", "uibuttongroup"});
     handle = __go_uicontrol__ (h, args{:});
   endif
 
 endfunction
+
diff --git a/scripts/plot/uigetdir.m b/scripts/gui/uigetdir.m
rename from scripts/plot/uigetdir.m
rename to scripts/gui/uigetdir.m
diff --git a/scripts/plot/uigetfile.m b/scripts/gui/uigetfile.m
rename from scripts/plot/uigetfile.m
rename to scripts/gui/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/gui/uigetfile.m
@@ -25,22 +25,22 @@
 ## @deftypefnx {Function File} {[@dots{}] =} uigetfile (@dots{}, "MultiSelect", @var{mode})
 ##
 ## Open a GUI dialog for selecting a file and return the filename @var{fname},
 ## the path to this file @var{fpath}, and the filter index @var{fltidx}.
 ## @var{flt} contains a (list of) file filter string(s) in one of the following
 ## formats:
 ##
 ## @table @asis
-## @item "/path/to/filename.ext"
+## @item @qcode{"/path/to/filename.ext"}
 ## If a filename is given then the file extension is extracted and used as
 ## filter.  In addition, the path is selected as current path and the filename
 ## is selected as default file.  Example: @code{uigetfile ("myfun.m")}
 ##
-## @item A single file extension "*.ext"
+## @item A single file extension @qcode{"*.ext"}
 ## Example: @code{uigetfile ("*.ext")}
 ##
 ## @item A 2-column cell array
 ## containing a file extension in the first column and a brief description
 ## in the second column.
 ## Example: @code{uigetfile (@{"*.ext", "My Description";"*.xyz",
 ## "XYZ-Format"@})}
 ##
@@ -49,20 +49,21 @@
 ## Example: @code{uigetfile (@{"*.gif;*.png;*.jpg", "Supported Picture
 ## Formats"@})}
 ## @end table
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
 ## If @var{default_file} is given then it will be selected in the GUI dialog.
 ## If, in addition, a path is given it is also used as current path.
 ##
-## The screen position of the GUI dialog can be set using the "Position" key
-## and a 2-element vector containing the pixel coordinates.
-## Two or more files can be selected when setting the "MultiSelect" key to "on".
-## In that case @var{fname} is a cell array containing the files.
+## The screen position of the GUI dialog can be set using the
+## @qcode{"Position"} key and a 2-element vector containing the pixel
+## coordinates.  Two or more files can be selected when setting the
+## @qcode{"MultiSelect"} key to @qcode{"on"}.  In that case @var{fname} is a
+## cell array containing the files.
 ## @seealso{uiputfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uigetfile (varargin)
 
   if (! __octave_link_enabled__ ())
@@ -97,19 +98,19 @@ function [retfile, retpath, retindex] = 
   endfor
 
   idx1 = idx2 = [];
   if (length (varargin) > 0)
     for i = 1 : length (varargin)
       val = varargin{i};
       if (ischar (val))
         val = tolower (val);
-        if (strncmp (val, "multiselect", 11))
+        if (strcmp (val, "multiselect"))
           idx1 = i;
-        elseif (strncmp (val, "position", 8))
+        elseif (strcmp (val, "position"))
           idx2 = i;
         endif
       endif
     endfor
   endif
 
   stridx = [idx1, idx2, 0];
   if (length (stridx) > 1)
@@ -162,23 +163,23 @@ function [retfile, retpath, retindex] = 
     ## check for even number of remaining arguments, prop/value pair(s)
     if (rem (nargin - stridx + 1, 2))
       error ("uigetfile: expecting property/value pairs");
     endif
 
     for i = stridx : 2 : nargin
       prop = varargin{i};
       val = varargin{i + 1};
-      if (strncmp (tolower (prop), "position", 8))
+      if (strcmpi (prop, "position"))
         if (ismatrix (val) && length (val) == 2)
           outargs{4} = val;
         else
           error ("uigetfile: expecting 2-element vector for position argument");
         endif
-      elseif (strncmp (tolower (prop), "multiselect", 11))
+      elseif (strcmpi (prop, "multiselect"))
         if (ischar (val))
           outargs{5} = tolower (val);
         else
           error ("uigetfile: expecting string argument (on/off) for multiselect");
         endif
       else
         error ("uigetfile: unknown argument");
       endif
diff --git a/scripts/plot/uimenu.m b/scripts/gui/uimenu.m
rename from scripts/plot/uimenu.m
rename to scripts/gui/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/gui/uimenu.m
@@ -14,54 +14,55 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} uimenu (@var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} uimenu (@var{h}, @var{property}, @var{value}, @dots{})
-## Create a uimenu object and return a handle to it.  If @var{h} is ommited
+## Create a uimenu object and return a handle to it.  If @var{h} is omitted
 ## then a top-level menu for the current figure is created.  If @var{h}
 ## is given then a submenu relative to @var{h} is created.
 ##
 ## uimenu objects have the following specific properties:
 ##
 ## @table @asis
-## @item "accelerator"
+## @item @qcode{"accelerator"}
 ## A string containing the key combination together with CTRL to execute this
-## menu entry (e.g., "x" for CTRL+x).
+## menu entry (e.g., @qcode{"x"} for CTRL+x).
 ##
-## @item "callback"
+## @item @qcode{"callback"}
 ## Is the function called when this menu entry is executed.  It can be either a
-## function string (e.g., "myfun"), a function handle (e.g., @@myfun) or a cell
-## array containing the function handle and arguments for the callback
-## function (e.g., @{@@myfun, arg1, arg2@}).
+## function string (e.g., @qcode{"myfun"}), a function handle (e.g., @@myfun)
+## or a cell array containing the function handle and arguments for the
+## callback function (e.g., @{@@myfun, arg1, arg2@}).
 ##
-## @item "checked"
-## Can be set "on" or "off".  Sets a mark at this menu entry.
+## @item @qcode{"checked"}
+## Can be set @qcode{"on"} or @qcode{"off"}.  Sets a mark at this menu entry.
 ##
-## @item "enable"
-## Can be set "on" or "off".  If disabled the menu entry cannot be selected
-## and it is grayed out.
+## @item @qcode{"enable"}
+## Can be set @qcode{"on"} or @qcode{"off"}.  If disabled the menu entry
+## cannot be selected and it is grayed out.
 ##
-## @item "foregroundcolor"
+## @item @qcode{"foregroundcolor"}
 ## A color value setting the text color for this menu entry.
 ##
-## @item "label"
-## A string containing the label for this menu entry.  A "&"-symbol can be
-## used to mark the "accelerator" character (e.g., @nospell{"E&xit"})
+## @item @qcode{"label"}
+## A string containing the label for this menu entry.  A @qcode{"&"}-symbol
+## can be used to mark the @qcode{"accelerator"} character (e.g.,
+## @nospell{@qcode{"E&xit"}})
 ##
-## @item "position"
+## @item @qcode{"position"}
 ## An scalar value containing the relative menu position.  The entry with the
 ## lowest value is at the first position starting from left or top.
 ##
-## @item "separator"
-## Can be set "on" or "off".  If enabled it draws a separator line above the
-## current position.  It is ignored for top level entries.
+## @item @qcode{"separator"}
+## Can be set @qcode{"on"} or @qcode{"off"}.  If enabled it draws a separator
+## line above the current position.  It is ignored for top level entries.
 ##
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## f = uimenu ("label", "&File", "accelerator", "f");
@@ -96,52 +97,49 @@ endfunction
 %! colormap (copper (64));
 %! shading ('interp');
 %! f = uimenu ('label', '&File', 'accelerator', 'f');
 %! e = uimenu ('label', '&Edit', 'accelerator', 'e');
 %! uimenu (f, 'label', 'Close', 'accelerator', 'q', 'callback', 'close (gcf)');
 %! uimenu (e, 'label', 'Toggle &Grid', 'accelerator', 'g', 'callback', 'grid (gca)');
 
 %!testif HAVE_FLTK
-%! toolkit = graphics_toolkit ();
-%! graphics_toolkit ("fltk");
+%! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ui = uimenu ("label", "mylabel");
 %!   assert (findobj (hf, "type", "uimenu"), ui);
 %!   assert (get (ui, "label"), "mylabel");
 %!   assert (get (ui, "checked"), "off");
 %!   assert (get (ui, "separator"), "off");
 %!   assert (get (ui, "enable"), "on");
 %!   assert (get (ui, "position"), 9);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
 %% check for top level menus file, edit, and help
 %!testif HAVE_FLTK
-%! toolkit = graphics_toolkit ();
-%! graphics_toolkit ("fltk");
+%! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uif = findall (hf, "label", "&file");
 %!   assert (ishghandle (uif));
 %!   uie = findall (hf, "label", "&edit");
 %!   assert (ishghandle (uie));
 %!   uih = findall (hf, "label", "&help");
 %!   assert (ishghandle (uih));
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
-%! toolkit = graphics_toolkit ();
-%! graphics_toolkit ("fltk");
+%! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uie = findall (hf, "label", "&edit");
 %!   myui = uimenu (uie, "label", "mylabel");
 %!   assert (ancestor (myui, "uimenu", "toplevel"), uie);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
diff --git a/scripts/plot/uipanel.m b/scripts/gui/uipanel.m
rename from scripts/plot/uipanel.m
rename to scripts/gui/uipanel.m
--- a/scripts/plot/uipanel.m
+++ b/scripts/gui/uipanel.m
@@ -24,8 +24,9 @@
 ## Author: goffioul
 
 function handle = uipanel (varargin)
 
   [h, args] = __uiobject_split_args__ ("uipanel", varargin, {"figure", "uipanel", "uibuttongroup"});
   handle = __go_uipanel__ (h, args{:});
 
 endfunction
+
diff --git a/scripts/plot/uipushtool.m b/scripts/gui/uipushtool.m
rename from scripts/plot/uipushtool.m
rename to scripts/gui/uipushtool.m
--- a/scripts/plot/uipushtool.m
+++ b/scripts/gui/uipushtool.m
@@ -32,8 +32,9 @@ function handle = uipushtool (varargin)
       h = uitoolbar ();
     else
       h = h(1);
     endif
   endif
   handle = __go_uipushtool__ (h, args{:});
 
 endfunction
+
diff --git a/scripts/plot/uiputfile.m b/scripts/gui/uiputfile.m
rename from scripts/plot/uiputfile.m
rename to scripts/gui/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/gui/uiputfile.m
@@ -19,37 +19,37 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile ()
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt}, @var{dialog_name})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt}, @var{dialog_name}, @var{default_file})
 ## Open a GUI dialog for selecting a file.  @var{flt} contains a (list of) file
 ## filter string(s) in one of the following formats:
 ##
-## @table @code
-## @item "/path/to/filename.ext"
-## If a filename is given the file extension is
-## extracted and used as filter.
-## In addition the path is selected as current path and the filename is selected
-## as default file.
-## Example: uiputfile ("myfun.m");
+## @table @asis
+## @item @qcode{"/path/to/filename.ext"}
+## If a filename is given the file extension is extracted and used as filter.
+## In addition the path is selected as current path and the filename is
+## selected as default file.  Example: @code{uiputfile ("myfun.m")}
 ##
-## @item "*.ext"
+## @item @qcode{"*.ext"}
 ## A single file extension.
-## Example: uiputfile ("*.ext");
+## Example: @code{uiputfile ("*.ext")}
 ##
-## @item @{"*.ext","My Description"@}
+## @item @code{@{"*.ext", "My Description"@}}
 ## A 2-column cell array containing the file extension in the 1st column and
 ## a brief description in the 2nd column.
-## Example: uiputfile (@{"*.ext","My Description";"*.xyz","XYZ-Format"@});
+## Example: @code{uiputfile (@{"*.ext","My Description";"*.xyz",
+## "XYZ-Format"@})}
 ## @end table
 ##
 ## The filter string can also contain a semicolon separated list of filter
 ## extensions.
-## Example: uiputfile (@{"*.gif;*.png;*.jpg", "Supported Picture Formats"@});
+## Example: @code{uiputfile (@{"*.gif;*.png;*.jpg",
+## "Supported Picture Formats"@})}
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
 ## If @var{default_file} is given it is preselected in the GUI dialog.
 ## If, in addition, a path is given it is also used as current path.
 ## @seealso{uigetfile, uigetdir}
 ## @end deftypefn
 
 ## Author: Kai Habel
diff --git a/scripts/plot/uiresume.m b/scripts/gui/uiresume.m
rename from scripts/plot/uiresume.m
rename to scripts/gui/uiresume.m
--- a/scripts/plot/uiresume.m
+++ b/scripts/gui/uiresume.m
@@ -34,12 +34,13 @@ function uiresume (h)
   endif
 
   try
     uiwait_state = get (h, "__uiwait_state__");
     if (strcmp (uiwait_state, "active"))
       set (h, "__uiwait_state__", "triggered");
     endif
   catch
-    # Ignore exception
+    ## Ignore exception
   end_try_catch
 
 endfunction
+
diff --git a/scripts/plot/uitoggletool.m b/scripts/gui/uitoggletool.m
rename from scripts/plot/uitoggletool.m
rename to scripts/gui/uitoggletool.m
--- a/scripts/plot/uitoggletool.m
+++ b/scripts/gui/uitoggletool.m
@@ -32,8 +32,9 @@ function handle = uitoggletool (varargin
       h = uitoolbar ();
     else
       h = h(1);
     endif
   endif
   handle = __go_uitoggletool__ (h, args{:});
 
 endfunction
+
diff --git a/scripts/plot/uitoolbar.m b/scripts/gui/uitoolbar.m
rename from scripts/plot/uitoolbar.m
rename to scripts/gui/uitoolbar.m
--- a/scripts/plot/uitoolbar.m
+++ b/scripts/gui/uitoolbar.m
@@ -24,8 +24,9 @@
 ## Author: goffioul
 
 function handle = uitoolbar (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoolbar", varargin, {"figure"});
   handle = __go_uitoolbar__ (h, args{:});
 
 endfunction
+
diff --git a/scripts/plot/uiwait.m b/scripts/gui/uiwait.m
rename from scripts/plot/uiwait.m
rename to scripts/gui/uiwait.m
--- a/scripts/plot/uiwait.m
+++ b/scripts/gui/uiwait.m
@@ -73,8 +73,9 @@ function uiwait (varargin)
     unwind_protect_cleanup
       if (ishandle (h) && isprop (h, "__uiwait_state__"))
         set (h, "__uiwait_state__", "none");
       endif
     end_unwind_protect
   endif
 
 endfunction
+
diff --git a/scripts/plot/waitbar.m b/scripts/gui/waitbar.m
rename from scripts/plot/waitbar.m
rename to scripts/gui/waitbar.m
--- a/scripts/plot/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -18,124 +18,135 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} waitbar (@var{frac})
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@var{frac}, @var{msg})
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@dots{}, "FigureProperty", "Value", @dots{})
 ## @deftypefnx {Function File} {} waitbar (@var{frac})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar}, @var{msg})
-## Return a handle @var{h} to a new waitbar object.  The waitbar is
-## filled to fraction @var{frac} which must be in the range [0, 1].  The
-## optional message @var{msg} is centered and displayed above the waitbar.
-## The appearance of the waitbar figure window can be configured by passing
-## property/value pairs to the function.
+## Return a handle @var{h} to a new waitbar object.
+##
+## The waitbar is filled to fraction @var{frac} which must be in the range
+## [0, 1].  The optional message @var{msg} is centered and displayed above the
+## waitbar.  The appearance of the waitbar figure window can be configured by
+## passing property/value pairs to the function.
 ## 
 ## When called with a single input the current waitbar, if it exists, is
 ## updated to the new value @var{frac}.  If there are multiple outstanding
 ## waitbars they can be updated individually by passing the handle @var{hwbar}
 ## of the specific waitbar to modify.
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = waitbar (varargin)
+function h = waitbar (varargin)
 
   persistent curr_waitbar;
 
   if (nargin < 1)
     print_usage ();
   endif
 
   frac = varargin{1};
   varargin(1) = [];
 
   if (! (isnumeric (frac) && isscalar (frac) && frac >= 0 && frac <= 1))
     error ("waitbar: FRAC must be between 0 and 1");
   endif
 
   ## Use existing waitbar if it still points to a valid graphics handle.
   if (nargin == 1 && ishandle (curr_waitbar))
-    h = curr_waitbar;
+    hf = curr_waitbar;
   else
-    h = false;
+    hf = false;
   endif
 
   if (! isempty (varargin) && isnumeric (varargin{1}))
-    if (! ishandle (varargin{1}))
+    hf = varargin{1};
+    varargin(1) = [];
+    if (! isfigure (hf) || ! strcmp (get (hf, "tag"), "waitbar"))
       error ("waitbar: H must be a handle to a waitbar object");
-    else
-      h = varargin{1};
-      varargin(1) = [];
-      if (! isfigure (h) || ! strcmp (get (h, "tag"), "waitbar"))
-        error ("waitbar: H must be a handle to a waitbar object");
-      endif
     endif
   endif
 
   msg = false;
 
   if (! isempty (varargin))
     msg = varargin{1};
     varargin(1) = [];
     if (! (ischar (msg) || iscellstr (msg)))
       error ("waitbar: MSG must be a character string or cell array of strings");
     endif
   endif
 
   if (rem (numel (varargin), 2) != 0)
-    error ("waitbar: invalid number of property-value pairs");
+    error ("waitbar: invalid number of property/value pairs");
   endif
 
-  if (h)
-    p = findobj (h, "type", "patch");
-    set (p, "xdata", [0; frac; frac; 0]);
-    ax = findobj (h, "type", "axes");
+  if (hf)
+    gd = get (hf, "__guidata__");
+    ## Get the cached handles.
+    ax = gd(1);
+    hp = gd(2);
+
+    set (hp, "xdata", [0; frac; frac; 0]);
+
     if (ischar (msg) || iscellstr (msg))
       th = get (ax, "title");
       curr_msg = get (th, "string");
       ## graphics handles always store data as column vectors
       if (iscellstr (msg))
         msg = msg(:);  
       endif
       cmp = strcmp (msg, curr_msg);
       if (! all (cmp(:)))
         set (th, "string", msg);
       endif
     endif
   else
-    h = __go_figure__ (NaN, "position", [250, 500, 400, 100],
-                       "numbertitle", "off",
-                       "toolbar", "none", "menubar", "none",
-                       "integerhandle", "off",
-                       "handlevisibility", "callback",
-                       "tag", "waitbar",
-                       varargin{:});
+    ## Save and restore current figure
+    cf = get (0, "currentfigure");
 
-    ax = axes ("parent", h, "xtick", [], "ytick", [],
+    hf = figure ("position", [250, 500, 400, 100],
+                 "numbertitle", "off",
+                 "menubar", "none", "toolbar", "none",
+                 "integerhandle", "off",
+                 "handlevisibility", "callback",
+                 "tag", "waitbar",
+                 varargin{:});
+
+    ax = axes ("parent", hf,
+               "xtick", [], "ytick", [],
                "xlim", [0, 1], "ylim", [0, 1],
-               "xlimmode", "manual", "ylimmode", "manual",
                "position", [0.1, 0.3, 0.8, 0.2]);
 
-    patch (ax, [0; frac; frac; 0], [0; 0; 1; 1], [0, 0.35, 0.75]);
+    hp = patch (ax, [0; frac; frac; 0], [0; 0; 1; 1], [0, 0.35, 0.75]);
+
+    ## Cache the axes and patch handles.
+    set (hf, "__guidata__", [ax hp]);
 
     if (! (ischar (msg) || iscellstr (msg)))
       msg = "Please wait...";
     endif
     title (ax, msg);
+
+    if (! isempty (cf))
+      set (0, "currentfigure", cf);
+    endif
   endif
 
   drawnow ();
 
   if (nargout > 0)
-    retval = h;
+    h = hf;
   endif
 
   ## If there were no errors, update current waitbar.
-  curr_waitbar = h;
+  curr_waitbar = hf;
 
 endfunction
 
 
 %!demo
 %! h = waitbar (0, '0.00%');
 %! for i = 0:0.01:1
 %!   waitbar (i, h, sprintf ('%.2f%%', 100*i));
@@ -179,10 +190,10 @@ endfunction
 %! pause (0.5);
 %! close (h1);
 %! close (h2);
 
 %% Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
-%!error <invalid number of property-value pairs> waitbar (0.5, "msg", "Name")
+%!error <invalid number of property/value pairs> waitbar (0.5, "msg", "Name")
 
diff --git a/scripts/plot/waitforbuttonpress.m b/scripts/gui/waitforbuttonpress.m
rename from scripts/plot/waitforbuttonpress.m
rename to scripts/gui/waitforbuttonpress.m
--- a/scripts/plot/waitforbuttonpress.m
+++ b/scripts/gui/waitforbuttonpress.m
@@ -12,36 +12,44 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{b} =} waitforbuttonpress ()
-## Wait for button or mouse press.over a figure window.  The value of
-## @var{b} returns 0 if a mouse button was pressed or 1 is a key was
-## pressed.
-## @seealso{ginput}
+## @deftypefn  {Function File} {} waitforbuttonpress ()
+## @deftypefnx {Function File} {@var{a} =} waitforbuttonpress ()
+## Wait for mouse click or key press over the current figure window.
+##
+## The return value of @var{b} is 0 if a mouse button was pressed or 1 if a
+## key was pressed.
+## @seealso{waitfor, ginput, kbhit}
 ## @end deftypefn
 
 ## The original version of this code bore the copyright
 ## Author: Petr Mikulik
 ## License: public domain
 
-function a = waitforbuttonpress ()
+function b = waitforbuttonpress ()
 
   if (nargin != 0 || nargout > 1)
     print_usage ();
   endif
 
   [x, y, k] = ginput (1);
 
   if (nargout == 1)
     if (k <= 5)
-      a = 0;
+      b = 0;
     else
-      a = 1;
+      b = 1;
     endif
   endif
 
 endfunction
+
+
+%% Test input validation
+%!error waitforbuttonpress (1)
+%!error [a,b,c] = waitforbuttonpress ()
+
diff --git a/scripts/help/__gripe_missing_component__.m b/scripts/help/__gripe_missing_component__.m
new file mode 100644
--- /dev/null
+++ b/scripts/help/__gripe_missing_component__.m
@@ -0,0 +1,56 @@
+## Copyright (C) 2013 Mike Miller
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} __gripe_missing_component__ (@var{caller}, @var{component})
+## Undocumented internal function.
+## @end deftypefn
+
+function __gripe_missing_component__ (caller, component)
+
+  if (nargin != 2)
+    print_usage ();
+  endif
+
+  msg = "";
+  fcn = missing_component_hook ();
+
+  ftype = exist (fcn);
+  if (ftype == 2 || ftype == 3 || ftype == 5 || ftype == 103)
+    msg = feval (fcn, component);
+  endif
+
+  if (isempty (msg))
+    switch (component)
+      case "info-file"
+        msg = "unable to find the Octave info manual, Octave installation is incomplete";
+      case "mkoctfile"
+        msg = "unable to find the mkoctfile command, Octave installation is incomplete";
+      case "octave"
+        msg = "unable to find the octave executable, Octave installation is incomplete";
+      case "octave-config"
+        msg = "unable to find the octave-config command, Octave installation is incomplete";
+      otherwise
+        msg = ["unable to find required Octave component \"" component "\""];
+    endswitch
+  endif
+
+  error ("%s: %s\n", caller, msg);
+
+endfunction
+
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -67,16 +67,19 @@ function [retval, status] = __makeinfo__
   if (! ischar (text))
     error ("__makeinfo__: first input argument must be a string");
   endif
 
   if (! ischar (output_type))
     error ("__makeinfo__: second input argument must be a string");
   endif
 
+  ## NOTE: The 3rd argument is used by Octave-Forge function
+  ##       generate_package_html, not by core Octave.  This functionality
+  ##       can only be removed when that function has been updated.
   if (nargin < 3)
     if (strcmpi (output_type, "plain text"))
       fsee_also = @(T) strcat ...
           ("\nSee also:", sprintf (" %s,", T{:})(1:end-1), "\n");
     else
       fsee_also = @(T) strcat ...
           ("\nSee also:", sprintf (" @ref{%s},", T{:})(1:end-1), "\n");
     endif
@@ -95,17 +98,17 @@ function [retval, status] = __makeinfo__
   text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
   file = texi_macros_file ();
   fid = fopen (file, "r");
   if (fid < 0)
     error ("unable to open %s for reading", file);
   else
     macros_text = fread (fid, Inf, "*char")';
-    text = cstrcat (macros_text, text);
+    text = [macros_text text];
   endif
   fclose (fid);
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -35,97 +35,521 @@ function txt = __unimplemented__ (fcn)
   if (nargin != 1)
     print_usage ();
   endif
 
   is_matlab_function = true;
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
+    case {"avifile", "aviinfo", "aviread"}
+      txt = ["Basic video file support is provided in the video package.  ", ...
+             "See @url{http://octave.sf.net/video/}."];
 
-  case "quad2d"
-    txt = ["quad2d is not implemented.  Consider using dblquad."];
+    case "exifread"
+      txt = ["exifread is deprecated.  " ...
+             "The functionality is available in the imfinfo function."];
+
+    case "gsvd"
+      txt = ["gsvd is not currently part of core Octave.  ", ...
+             "See the linear-algebra package at ", ...
+             "@url{http://octave.sourceforge.net/linear-algebra/}."];
+
+    case "funm"
+      txt = ["funm is not currently part of core Octave.  ", ...
+             "See the linear-algebra package at ", ...
+             "@url{http://octave.sourceforge.net/linear-algebra/}."];
+
+    case "griddedInterpolant"
+      txt = ["griddedInterpolant is not implemented.  ", ...
+             "Consider using griddata."];
+
+    case "integral"
+      txt = ["Octave provides many routines for 1-D numerical integration.  ", ...
+             "Consider quadcc, quad, quadv, quadl, quadgk."];
+
+    case "integral2"
+      txt = ["integral2 is not implemented.  Consider using dblquad."];
 
-  case "gsvd"
-    txt = ["gsvd is not currently part of core Octave.  See the ",...
-    "linear-algebra package at ",...
-    "@url{http://octave.sourceforge.net/linear-algebra/}."];
+    case "integral3"
+      txt = ["integral3 is not implemented.  Consider using triplequad"];
+
+    case "linprog"
+      txt = ["Octave does not currently provide linprog.  ", ...
+             "Linear programming problems may be solved using @code{glpk}.  ", ...
+             "Try @code{help glpk} for more info."];
+
+    case "matlabrc"
+      txt = ["matlabrc is not implemented.  ", ...
+             'Octave uses the file ".octaverc" instead.'];
+
+    case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", ...
+          "ode23tb", "ode45", "odeget", "odeset"}
+      txt = ["Octave provides lsode for solving differential equations.  ", ...
+             "For more information try @code{help lsode}.  ", ...
+             "Matlab-compatible ODE functions are provided by the odepkg ", ...
+             "package.  See @url{http://octave.sourceforge.net/odepkg/}."];
+
+    case "startup"
+      txt = ["startup is not implemented.  ", ...
+             'Octave uses the file ".octaverc" instead.'];
+
+    case "quad2d"
+      txt = ["quad2d is not implemented.  Consider using dblquad."];
+
+    case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
+      txt = ["Functions for spreadsheet style I/O ", ...
+             "(.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
+             "are provided in the io package. ", ...
+             "See @url{http://octave.sf.net/io/}."];
 
-  case "funm"
-    txt = ["funm is not currently part of core Octave.  See the ",...
-    "linear-algebra package at @url{http://octave.sf.net/linear-algebra/}."];
+    ## control system
+    case {"absorbDelay", "allmargin", "append", "augstate", "balreal", ...
+          "balred", "balredOptions", "bandwidth", "bdschur", "bode", ...
+          "bodemag", "bodeoptions", "bodeplot", "c2d", "c2dOptions", ...
+          "canon", "care", "chgFreqUnit", "chgTimeUnit", "connect", ...
+          "connectOptions", "covar", "ctrb", "ctrbf", "ctrlpref", "d2c", ...
+          "d2cOptions", "d2d", "d2dOptions", "damp", "dare", "db2mag", ...
+          "dcgain", "delay2z", "delayss", "dlqr", "dlyap", "dlyapchol", ...
+          "drss", "dsort", "dss", "dssdata", "esort", "estim", "evalfr", ...
+          "feedback", "filt", "frd", "frdata", "freqresp", "gcare", "gdare", ...
+          "genfrd", "genmat", "gensig", "genss", "get", "getBlockValue", ...
+          "getDelayModel", "getGainCrossover", "getIOTransfer", ...
+          "getLFTModel", "getLoopTransfer", "getNominal", "getoptions", ...
+          "getPeakGain", "getSwitches", "getValue", "gram", "hasdelay", ...
+          "hasInternalDelay", "hsvd", "hsvdOptions", "hsvoptions", ...
+          "hsvplot", "imp2exp", "impulse", "impulseplot", "initial", ...
+          "initialplot", "iopzmap", "iopzplot", "isct", "isdt", "isempty", ...
+          "isfinite", "isParametric", "isproper", "isreal", "issiso", ...
+          "isstable", "isstatic", "kalman", "kalmd", "lft", "loopswitch", ...
+          "lqg", "lqgreg", "lqgtrack", "lqi", "lqr", "lqrd", "lqry", "lsim", ...
+          "lsiminfo", "lsimplot", "ltiview", "lyap", "lyapchol", "mag2db", ...
+          "margin", "minreal", "modred", "modsep", "nblocks", "ndims", ...
+          "ngrid", "nichols", "nicholsoptions", "nicholsplot", "nmodels", ...
+          "norm", "nyquist", "nyquistoptions", "nyquistplot", "obsv", ...
+          "obsvf", "order", "pade", "parallel", "permute", "pid", "piddata", ...
+          "pidstd", "pidstddata", "pidtool", "pidtune", "pidtuneOptions", ...
+          "place", "pole", "prescale", "pzmap", "pzoptions", "pzplot", ...
+          "realp", "reg", "replaceBlock", "repsys", "reshape", "rlocus", ...
+          "rlocusplot", "rss", "series", "set", "setBlockValue", ...
+          "setDelayModel", "setoptions", "setValue", "sgrid", ...
+          "showBlockValue", "showTunable", "sigma", "sigmaoptions", ...
+          "sigmaplot", "sisoinit", "sisotool", "size", "sminreal", "ss", ...
+          "ss2ss", "ssdata", "stabsep", "stabsepOptions", "stack", "step", ...
+          "stepDataOptions", "stepinfo", "stepplot", "sumblk", "tf", ...
+          "tfdata", "thiran", "timeoptions", "totaldelay", "tzero", ...
+          "updateSystem", "upsample", "xperm", "zero", "zgrid", "zpk", ...
+          "zpkdata"}
+      txt = check_package (fcn, "control");
 
-  case "linprog"
-    txt = ["Octave does not currently provide linprog.  ",...
-    "Linear programming problems may be solved using @code{glpk}.  ",...
-    "Try @code{help glpk} for more info."];
-
-  case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
-    txt = ["Octave provides lsode for solving differential equations.  ",...
-    "For more information try @code{help lsode}.  ",...
-    "Matlab-compatible ODE functions are provided by the odepkg package.  ",...
-    "See @url{http://octave.sourceforge.net/odepkg/}."];
+    ## communications
+    case {"algdeintrlv", "algintrlv", "alignsignals", "amdemod", "ammod", ...
+          "arithdeco", "arithenco", "awgn", "bchdec", "bchenc", ...
+          "bchgenpoly", "bchnumerr", "berawgn", "bercoding", "berconfint", ...
+          "berfading", "berfit", "bersync", "bertool", "bi2de", "bin2gray", ...
+          "biterr", "bsc", "cma", "commscope", "compand", "convdeintrlv", ...
+          "convenc", "convintrlv", "convmtx", "cosets", "cyclgen", ...
+          "cyclpoly", "de2bi", "decode", "deintrlv", "dfe", "dftmtx", ...
+          "distspec", "doppler", "dpcmdeco", "dpcmenco", "dpcmopt", ...
+          "dpskdemod", "dpskmod", "dvbs2ldpc", "encode", "equalize", ...
+          "eyediagram", "EyeScope", "finddelay", "fmdemod", "fmmod", ...
+          "fskdemod", "fskmod", "gaussdesign", "gen2par", "genqamdemod", ...
+          "genqammod", "gf", "gfadd", "gfconv", "gfcosets", "gfdeconv", ...
+          "gfdiv", "gffilter", "gflineq", "gfminpol", "gfmul", "gfpretty", ...
+          "gfprimck", "gfprimdf", "gfprimfd", "gfrank", "gfrepcov", ...
+          "gfroots", "gfsub", "gftable", "gftrunc", "gftuple", "gfweight", ...
+          "gray2bin", "hammgen", "heldeintrlv", "helintrlv", ...
+          "helscandeintrlv", "helscanintrlv", "huffmandeco", "huffmandict", ...
+          "huffmanenco", "intdump", "intrlv", "iscatastrophic", ...
+          "isprimitive", "istrellis", "legacychannelsim", "lineareq", ...
+          "lloyds", "lms", "log", "lteZadoffChuSeq", "marcumq", ...
+          "mask2shift", "matdeintrlv", "matintrlv", "minpol", "mldivide", ...
+          "mlseeq", "modnorm", "muxdeintrlv", "muxintrlv", "noisebw", ...
+          "normlms", "oct2dec", "oqpskdemod", "oqpskmod", "pamdemod", ...
+          "pammod", "pmdemod", "pmmod", "poly2trellis", "primpoly", ...
+          "pskdemod", "pskmod", "qamdemod", "qammod", "qfunc", "qfuncinv", ...
+          "quantiz", "randdeintrlv", "randerr", "randintrlv", "randsrc", ...
+          "rayleighchan", "rcosdesign", "rectpulse", "reset", "ricianchan", ...
+          "rls", "rsdec", "rsenc", "rsgenpoly", "rsgenpolycoeffs", ...
+          "scatterplot", "sdrexamples", "sdrfgensysace", "sdrfroot", ...
+          "sdrinfo", "sdrload", "sdrsetup", "semianalytic", "shift2mask", ...
+          "signlms", "ssbdemod", "ssbmod", "stdchan", ...
+          "supportPackageInstaller", "symerr", "syndtable", "varlms", ...
+          "vec2mat", "vitdec", "wgn"}
+      txt = check_package (fcn, "communications");
 
-  case {"javaArray", "javaMethod", "javaMethodEDT", "javaObject", "javaObjectEDT", "javaaddpath", "javaclasspath", "javarmpath"}
-    txt = ["Java objects and methods can be used with the java package. ",...
-    "See @url{http://octave.sf.net/java/}."];
-
-  case {"errordlg", "helpdlg", "inputdlg", "listdlg", "questdlg", "warndlg"}
-    txt = ["Several dialog functions are provided in the java package. ",...
-    "See @url{http://octave.sf.net/java/}."];
+    ## finance
+    case {"abs2active", "accrfrac", "acrubond", "acrudisc", "active2abs", ...
+          "addEquality", "addEquality", "addEquality", "addGroupRatio", ...
+          "addGroupRatio", "addGroupRatio", "addGroups", "addGroups", ...
+          "addGroups", "addInequality", "addInequality", "addInequality", ...
+          "adline", "adosc", "amortize", "annurate", "annuterm", ...
+          "arith2geom", "ascii2fts", "beytbill", "binprice", "blkimpv", ...
+          "blkprice", "blsdelta", "blsgamma", "blsimpv", "blslambda", ...
+          "blsprice", "blsrho", "blstheta", "blsvega", "bndconvp", ...
+          "bndconvy", "bnddurp", "bnddury", "bndkrdur", "bndprice", ...
+          "bndspread", "bndtotalreturn", "bndyield", "bolling", "bollinger", ...
+          "boxcox", "busdate", "busdays", "candle", "cdai", "cdprice", ...
+          "cdyield", "cfamounts", "cfbyzero", "cfconv", "cfdates", "cfdur", ...
+          "cfplot", "cfport", "cfprice", "cfspread", "cftimes", "cfyield", ...
+          "chaikosc", "chaikvolat", "chartfts", "checkFeasibility", ...
+          "checkFeasibility", "checkFeasibility", "chfield", "convert2sur", ...
+          "convertto", "corr2cov", "cov2corr", "cpncount", "cpndaten", ...
+          "cpndatenq", "cpndatep", "cpndaysp", "cpnpersz", "createholidays", ...
+          "cumsum", "cur2frac", "cur2str", "date2time", "dateaxis", ...
+          "datedisp", "datefind", "datemnth", "datewrkdy", "day", "days360", ...
+          "days360e", "days360isda", "days360psa", "days365", "daysact", ...
+          "daysadd", "daysdif", "dec2thirtytwo", "depfixdb", "depgendb", ...
+          "deprdv", "depsoyd", "depstln", "diff", "disc2zero", "discrate", ...
+          "ecmmvnrfish", "ecmmvnrmle", "ecmmvnrobj", "ecmmvnrstd", ...
+          "ecmnfish", "ecmnhess", "ecmninit", "ecmnmle", "ecmnobj", ...
+          "ecmnstd", "effrr", "elpm", "emaxdrawdown", "end", "eomdate", ...
+          "estimateAssetMoments", "estimateBounds", "estimateBounds", ...
+          "estimateBounds", "estimateFrontier", "estimateFrontier", ...
+          "estimateFrontier", "estimateFrontierByReturn", ...
+          "estimateFrontierByReturn", "estimateFrontierByReturn", ...
+          "estimateFrontierByRisk", "estimateFrontierByRisk", ...
+          "estimateFrontierByRisk", "estimateFrontierLimits", ...
+          "estimateFrontierLimits", "estimateFrontierLimits", ...
+          "estimateMaxSharpeRatio", "estimatePortMoments", ...
+          "estimatePortReturn", "estimatePortReturn", "estimatePortReturn", ...
+          "estimatePortRisk", "estimatePortRisk", "estimatePortRisk", ...
+          "estimatePortStd", "estimatePortStd", "estimatePortVaR", ...
+          "estimateScenarioMoments", "estimateScenarioMoments", "ewstats", ...
+          "exp", "extfield", "fbusdate", "fetch", "fieldnames", "fillts", ...
+          "fints", "floatdiscmargin", "floatmargin", "fpctkd", "frac2cur", ...
+          "freqnum", "freqstr", "frontcon", "frontier", "fts2ascii", ...
+          "fts2mat", "ftsbound", "ftsgui", "ftsinfo", "ftstool", "ftsuniq", ...
+          "fvdisc", "fvfix", "fvvar", "fwd2zero", "geom2arith", ...
+          "getAssetMoments", "getBounds", "getBounds", "getBounds", ...
+          "getBudget", "getBudget", "getBudget", "getCosts", "getCosts", ...
+          "getCosts", "getEquality", "getEquality", "getEquality", ...
+          "getGroupRatio", "getGroupRatio", "getGroupRatio", "getGroups", ...
+          "getGroups", "getGroups", "getInequality", "getInequality", ...
+          "getInequality", "getnameidx", "getOneWayTurnover", ...
+          "getOneWayTurnover", "getOneWayTurnover", "getScenarios", ...
+          "getScenarios", "hhigh", "highlow", "holdings2weights", ...
+          "holidays", "horzcat", "hour", "inforatio", "irr", "isbusday", ...
+          "iscompatible", "isempty", "isfield", "issorted", "kagi", "lagts", ...
+          "lbusdate", "leadts", "length", "linebreak", "llow", "log", ...
+          "log10", "log2", "lpm", "lweekdate", "m2xdate", "macd", ...
+          "maxdrawdown", "medprice", "merge", "minus", "minute", "mirr", ...
+          "month", "months", "movavg", "mrdivide", "mtimes", "mvnrfish", ...
+          "mvnrmle", "mvnrobj", "mvnrstd", "nancov", "nanmax", "nanmean", ...
+          "nanmedian", "nanmin", "nanstd", "nansum", "nanvar", "negvolidx", ...
+          "nomrr", "nweekdate", "nyseclosures", "onbalvol", "opprofit", ...
+          "payadv", "payodd", "payper", "payuni", "pcalims", "pcgcomp", ...
+          "pcglims", "pcpval", "peravg", "periodicreturns", "plotFrontier", ...
+          "plotFrontier", "plotFrontier", "plus", "pointfig", "portalloc", ...
+          "portalpha", "portcons", "Portfolio", "PortfolioCVaR", ...
+          "PortfolioMAD", "portopt", "portrand", "portror", "portsim", ...
+          "portstats", "portvar", "portvrisk", "posvolidx", "power", ...
+          "prbyzero", "prcroc", "prdisc", "priceandvol", "prmat", "prtbill", ...
+          "pvfix", "pvtrend", "pvvar", "pyld2zero", "rdivide", "renko", ...
+          "resamplets", "ret2tick", "rmfield", "rsindex", "selectreturn", ...
+          "setAssetList", "setAssetList", "setAssetList", "setAssetMoments", ...
+          "setBounds", "setBounds", "setBounds", "setBudget", "setBudget", ...
+          "setBudget", "setCosts", "setCosts", "setCosts", ...
+          "setDefaultConstraints", "setDefaultConstraints", ...
+          "setDefaultConstraints", "setEquality", "setEquality", ...
+          "setEquality", "setGroupRatio", "setGroupRatio", "setGroupRatio", ...
+          "setGroups", "setGroups", "setGroups", "setInequality", ...
+          "setInequality", "setInequality", "setInitPort", "setInitPort", ...
+          "setInitPort", "setOneWayTurnover", "setOneWayTurnover", ...
+          "setOneWayTurnover", "setProbabilityLevel", "setScenarios", ...
+          "setScenarios", "setSolver", "setSolver", "setSolver", ...
+          "setTurnover", "setTurnover", "setTurnover", "sharpe", ...
+          "simulateNormalScenariosByData", "simulateNormalScenariosByData", ...
+          "simulateNormalScenariosByMoments", ...
+          "simulateNormalScenariosByMoments", "size", "smoothts", "sortfts", ...
+          "spctkd", "stochosc", "subsasgn", "subsref", "targetreturn", ...
+          "taxedrr", "tbilldisc2yield", "tbillprice", "tbillrepo", ...
+          "tbillval01", "tbillyield", "tbillyield2disc", "tbl2bond", ...
+          "thirdwednesday", "thirtytwo2dec", "tick2ret", "time2date", ...
+          "times", "toannual", "todaily", "today", "todecimal", "tomonthly", ...
+          "toquarterly", "toquoted", "tosemi", "totalreturnprice", ...
+          "toweekly", "tr2bonds", "transprob", "transprobbytotals", ...
+          "transprobfromthresholds", "transprobgrouptotals", ...
+          "transprobprep", "transprobtothresholds", "tsaccel", "tsmom", ...
+          "tsmovavg", "typprice", "ugarch", "ugarchllf", "ugarchpred", ...
+          "ugarchsim", "uicalendar", "uminus", "uplus", "vertcat", ...
+          "volarea", "volroc", "wclose", "weeknum", "weights2holdings", ...
+          "willad", "willpctr", "wrkdydif", "x2mdate", "xirr", "year", ...
+          "yeardays", "yearfrac", "ylddisc", "yldmat", "yldtbill", ...
+          "zbtprice", "zbtyield", "zero2disc", "zero2fwd", "zero2pyld"}
+      txt = check_package (fcn, "financial");
 
-  case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
-    txt = ["Functions for spreadsheet style I/O (.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
-    "are provided in the io package. ",...
-    "See @url{http://octave.sf.net/io/}."];
+    ## image processing
+    case {"activecontour", "adapthisteq", "affine2d", "affine3d", ...
+          "analyze75info", "analyze75read", "applycform", "applylut", ...
+          "axes2pix", "bestblk", "blockproc", "bwarea", "bwareaopen", ...
+          "bwboundaries", "bwconncomp", "bwconvhull", "bwdist", ...
+          "bwdistgeodesic", "bweuler", "bwhitmiss", "bwlabel", "bwlabeln", ...
+          "bwlookup", "bwmorph", "bwpack", "bwperim", "bwselect", ...
+          "bwtraceboundary", "bwulterode", "bwunpack", "checkerboard", ...
+          "col2im", "colfilt", "conndef", "convmtx2", "corner", ...
+          "cornermetric", "corr2", "cp2tform", "cpcorr", "cpselect", ...
+          "cpstruct2pairs", "dct2", "dctmtx", "deconvblind", "deconvlucy", ...
+          "deconvreg", "deconvwnr", "decorrstretch", "demosaic", ...
+          "dicomanon", "dicomdict", "dicominfo", "dicomlookup", "dicomread", ...
+          "dicomuid", "dicomwrite", "edge", "edgetaper", "entropy", ...
+          "entropyfilt", "fan2para", "fanbeam", "findbounds", "fitgeotrans", ...
+          "fliptform", "freqz2", "fsamp2", "fspecial", "ftrans2", "fwind1", ...
+          "fwind2", "getheight", "getimage", "getimagemodel", "getline", ...
+          "getneighbors", "getnhood", "getpts", "getrect", "getsequence", ...
+          "graycomatrix", "graycoprops", "graydist", "grayslice", ...
+          "graythresh", "hdrread", "hdrwrite", "histeq", "hough", ...
+          "houghlines", "houghpeaks", "iccfind", "iccread", "iccroot", ...
+          "iccwrite", "idct2", "ifanbeam", "im2bw", "im2col", "im2double", ...
+          "im2int16", "im2java2d", "im2single", "im2uint16", "im2uint8", ...
+          "imabsdiff", "imadd", "imadjust", "ImageAdapter", "imageinfo", ...
+          "imapplymatrix", "imapprox", "imattributes", "imbothat", ...
+          "imclearborder", "imclose", "imcolormaptool", "imcomplement", ...
+          "imcontour", "imcontrast", "imcrop", "imdilate", "imdisplayrange", ...
+          "imdistline", "imdivide", "imellipse", "imerode", "imextendedmax", ...
+          "imextendedmin", "imfill", "imfilter", "imfindcircles", ...
+          "imfreehand", "imfuse", "imgca", "imgcf", "imgetfile", ...
+          "imgradient", "imgradientxy", "imhandles", "imhist", ...
+          "imhistmatch", "imhmax", "imhmin", "imimposemin", "imlincomb", ...
+          "imline", "immagbox", "immovie", "immultiply", "imnoise", ...
+          "imopen", "imoverview", "imoverviewpanel", "impixel", ...
+          "impixelinfo", "impixelinfoval", "impixelregion", ...
+          "impixelregionpanel", "implay", "impoint", "impoly", "improfile", ...
+          "impyramid", "imquantize", "imreconstruct", "imrect", "imref2d", ...
+          "imref3d", "imregconfig", "imregionalmax", "imregionalmin", ...
+          "imregister", "imregtform", "imresize", "imroi", "imrotate", ...
+          "imsave", "imscrollpanel", "imsharpen", "imshowpair", ...
+          "imsubtract", "imtool", "imtophat", "imtransform", "imwarp", ...
+          "interfileinfo", "interfileread", "intlut", "iptaddcallback", ...
+          "iptcheckconn", "iptcheckhandle", "iptgetapi", ...
+          "iptGetPointerBehavior", "iptgetpref", "ipticondir", ...
+          "iptPointerManager", "iptprefs", "iptremovecallback", ...
+          "iptSetPointerBehavior", "iptsetpref", "iptwindowalign", "iradon", ...
+          "isflat", "isicc", "isrset", "lab2double", "lab2uint16", ...
+          "lab2uint8", "label2rgb", "labelmatrix", "makecform", ...
+          "makeConstrainToRectFcn", "makehdr", "makelut", "makeresampler", ...
+          "maketform", "mat2gray", "mean2", "medfilt2", "montage", ...
+          "multithresh", "nitfinfo", "nitfread", "nlfilter", "normxcorr2", ...
+          "openrset", "ordfilt2", "otf2psf", "padarray", "para2fan", ...
+          "phantom", "poly2mask", "projective2d", "psf2otf", "qtdecomp", ...
+          "qtgetblk", "qtsetblk", "radon", "rangefilt", "reflect", ...
+          "regionprops", "rgb2gray", "rgb2ycbcr", "roicolor", "roifill", ...
+          "roifilt2", "roipoly", "rsetwrite", "std2", "stdfilt", "strel", ...
+          "stretchlim", "subimage", "tformarray", "tformfwd", "tforminv", ...
+          "tonemap", "translate", "truesize", "viscircles", "warp", ...
+          "watershed", "whitepoint", "wiener2", "xyz2double", "xyz2uint16", ...
+          "ycbcr2rgb"}
+      txt = check_package (fcn, "image");
+
+    ## signal processing
+    case {"ac2poly", "ac2rc", "angle", "arburg", "arcov", "armcov", ...
+          "aryule", "bandpower", "barthannwin", "besselap", "besself", ...
+          "bilinear", "bitrevorder", "blackmanharris", "bohmanwin", ...
+          "buffer", "buttap", "butter", "buttord", "cceps", "cconv", ...
+          "cell2sos", "cfirpm", "cheb1ap", "cheb1ord", "cheb2ap", ...
+          "cheb2ord", "chebwin", "cheby1", "cheby2", "chirp", "convmtx", ...
+          "corrmtx", "cpsd", "czt", "db", "db2mag", "db2pow", "dct", ...
+          "decimate", "demod", "design", "designmethods", "designopts", ...
+          "dfilt", "dftmtx", "digitrevorder", "diric", "downsample", "dpss", ...
+          "dpssclear", "dpssdir", "dpssload", "dspdata", "dspfwiz", ...
+          "dutycycle", "ellip", "ellipap", "ellipord", "enbw", "equiripple", ...
+          "falltime", "fdatool", "fdesign", "filt2block", "filterbuilder", ...
+          "filternorm", "filtfilt", "filtic", "filtord", "findpeaks", ...
+          "fir1", "fir2", "fircls", "fircls1", "firls", "firpm", "firpmord", ...
+          "firrcos", "firtype", "flattopwin", "freqs", "freqsamp", "fvtool", ...
+          "fwht", "gauspuls", "gaussdesign", "gaussfir", "gausswin", ...
+          "gmonopuls", "goertzel", "grpdelay", "hann", "hilbert", "icceps", ...
+          "idct", "ifwht", "impinvar", "impz", "impzlength", "interp", ...
+          "intfilt", "invfreqs", "invfreqz", "is2rc", "isallpass", ...
+          "islinphase", "ismaxphase", "isminphase", "isstable", "kaiser", ...
+          "kaiserord", "kaiserwin", "lar2rc", "latc2tf", "latcfilt", ...
+          "levinson", "lp2bp", "lp2bs", "lp2hp", "lp2lp", "lpc", "lsf2poly", ...
+          "mag2db", "marcumq", "maxflat", "medfilt1", "midcross", ...
+          "modulate", "mscohere", "nuttallwin", "overshoot", "parzenwin", ...
+          "pburg", "pcov", "peak2peak", "peak2rms", "peig", "phasedelay", ...
+          "phasez", "pmcov", "pmtm", "pmusic", "poly2ac", "poly2lsf", ...
+          "poly2rc", "polyscale", "polystab", "pow2db", "prony", ...
+          "pulseperiod", "pulsesep", "pulsewidth", "pulstran", "pwelch", ...
+          "pyulear", "rc2ac", "rc2is", "rc2lar", "rc2poly", "rceps", ...
+          "rcosdesign", "realizemdl", "rectpuls", "rectwin", "resample", ...
+          "residuez", "risetime", "rlevinson", "rms", "rooteig", ...
+          "rootmusic", "rssq", "sawtooth", "schurrc", "seqperiod", ...
+          "setspecs", "settlingtime", "sfdr", "sgolay", "sgolayfilt", ...
+          "shiftdata", "sigwin", "sinad", "slewrate", "snr", "sos2cell", ...
+          "sos2ss", "sos2tf", "sos2zp", "sosfilt", "spectrogram", ...
+          "spectrum", "sptool", "square", "ss2sos", "ss2tf", "ss2zp", ...
+          "statelevels", "stepz", "stmcb", "strips", "taylorwin", "tf2latc", ...
+          "tf2sos", "tf2ss", "tf2zp", "tf2zpk", "tfestimate", "thd", "toi", ...
+          "triang", "tripuls", "tukeywin", "udecode", "uencode", ...
+          "undershoot", "unshiftdata", "upfirdn", "upsample", ...
+          "validstructures", "vco", "window", "wintool", "wvtool", "xcorr", ...
+          "xcorr2", "xcov", "yulewalk", "zerophase", "zp2sos", "zp2ss", ...
+          "zp2tf", "zplane"}
+      txt = check_package (fcn, "signal");
 
-  case {"avifile", "aviinfo", "aviread"}
-    txt = ["Basic video file support is provided in the video package. ",...
-    "See @url{http://octave.sf.net/video/}."];
+    ## statistics
+    case {"addedvarplot", "addlevels", "addTerms", "addTerms", "adtest", ...
+          "andrewsplot", "anova1", "anova2", "anovan", "ansaribradley", ...
+          "aoctool", "barttest", "bbdesign", "betafit", "betalike", ...
+          "betastat", "binofit", "binostat", "biplot", "bootci", "bootstrp", ...
+          "boxplot", "candexch", "candgen", "canoncorr", "capability", ...
+          "capaplot", "caseread", "casewrite", "ccdesign", "cdf", "cdf", ...
+          "cdfplot", "cell2dataset", "chi2gof", "chi2stat", "cholcov", ...
+          "ClassificationBaggedEnsemble", "ClassificationDiscriminant", ...
+          "ClassificationEnsemble", "ClassificationKNN", ...
+          "ClassificationPartitionedEnsemble", ...
+          "ClassificationPartitionedModel", "ClassificationTree", ...
+          "classify", "classregtree", "cluster", "clusterdata", "cmdscale", ...
+          "coefCI", "coefCI", "coefCI", "coefCI", "coefTest", "coefTest", ...
+          "coefTest", "coefTest", "combnk", "compact", ...
+          "CompactClassificationDiscriminant", ...
+          "CompactClassificationEnsemble", "CompactClassificationTree", ...
+          "CompactRegressionEnsemble", "CompactRegressionTree", ...
+          "CompactTreeBagger", "compare", "confusionmat", "controlchart", ...
+          "controlrules", "cophenet", "copulacdf", "copulafit", ...
+          "copulaparam", "copulapdf", "copularnd", "copulastat", "cordexch", ...
+          "corrcov", "covarianceParameters", "coxphfit", "createns", ...
+          "crosstab", "crossval", "cvpartition", "datasample", "dataset", ...
+          "dataset2cell", "dataset2struct", "dataset2table", "datasetfun", ...
+          "daugment", "dcovary", "dendrogram", "designMatrix", ...
+          "devianceTest", "dfittool", "disp", "disp", "disp", "disp", ...
+          "disttool", "droplevels", "dummyvar", "dwtest", "dwtest", "ecdf", ...
+          "ecdfhist", "evalclusters", "evcdf", "evfit", "evinv", "evlike", ...
+          "evpdf", "evrnd", "evstat", "ExhaustiveSearcher", "expfit", ...
+          "explike", "export", "expstat", "factoran", "feval", "feval", ...
+          "feval", "ff2n", "fitdist", "fitensemble", "fitglm", "fitlm", ...
+          "fitlme", "fitlmematrix", "fitnlm", "fitted", "fixedEffects", ...
+          "fracfact", "fracfactgen", "friedman", "fsurfht", "fullfact", ...
+          "gagerr", "gamfit", "gamlike", "gamstat", ...
+          "GeneralizedLinearModel", "geomean", "geostat", "getlabels", ...
+          "getlevels", "gevcdf", "gevfit", "gevinv", "gevlike", "gevpdf", ...
+          "gevrnd", "gevstat", "gline", "glmfit", "glmval", "glyphplot", ...
+          "gmdistribution", "gname", "gpcdf", "gpfit", "gpinv", "gplike", ...
+          "gplotmatrix", "gppdf", "gprnd", "gpstat", "grp2idx", "grpstats", ...
+          "gscatter", "haltonset", "harmmean", "hist3", "histfit", ...
+          "hmmdecode", "hmmestimate", "hmmgenerate", "hmmtrain", ...
+          "hmmviterbi", "hougen", "hygestat", "icdf", "icdf", ...
+          "inconsistent", "interactionplot", "invpred", "islevel", ...
+          "ismissing", "isundefined", "iwishrnd", "jackknife", "jbtest", ...
+          "johnsrnd", "join", "KDTreeSearcher", "kmeans", "knnsearch", ...
+          "kruskalwallis", "ksdensity", "kstest", "kstest2", "labels", ...
+          "lasso", "lassoglm", "lassoPlot", "levelcounts", "leverage", ...
+          "lhsdesign", "lhsnorm", "lillietest", "LinearMixedModel", ...
+          "LinearModel", "linhyptest", "linkage", "lognfit", "lognlike", ...
+          "lognstat", "lsline", "mad", "mahal", "maineffectsplot", ...
+          "makedist", "manova1", "manovacluster", "mat2dataset", "mdscale", ...
+          "mergelevels", "mhsample", "mle", "mlecov", "mnpdf", "mnrfit", ...
+          "mnrnd", "mnrval", "multcompare", "multivarichart", "mvncdf", ...
+          "mvnpdf", "mvnrnd", "mvregress", "mvregresslike", "mvtcdf", ...
+          "mvtpdf", "mvtrnd", "NaiveBayes", "nancov", "nanmax", "nanmean", ...
+          "nanmedian", "nanmin", "nanstd", "nansum", "nanvar", "nbinfit", ...
+          "nbinstat", "ncfcdf", "ncfinv", "ncfpdf", "ncfrnd", "ncfstat", ...
+          "nctcdf", "nctinv", "nctpdf", "nctrnd", "nctstat", "ncx2cdf", ...
+          "ncx2inv", "ncx2pdf", "ncx2rnd", "ncx2stat", "negloglik", ...
+          "negloglik", "nlinfit", "nlintool", "nlmefit", "nlmefitsa", ...
+          "nlparci", "nlpredci", "nnmf", "nominal", "NonLinearModel", ...
+          "normfit", "normlike", "normplot", "normspec", "normstat", ...
+          "optimalleaforder", "ordinal", "parallelcoords", "paramci", ...
+          "paretotails", "partialcorr", "partialcorri", "pca", "pcacov", ...
+          "pcares", "pdf", "pdf", "pdist", "pdist2", "pearsrnd", ...
+          "perfcurve", "plotAdded", "plotAdjustedResponse", ...
+          "plotDiagnostics", "plotDiagnostics", "plotDiagnostics", ...
+          "plotEffects", "plotInteraction", "plotResiduals", ...
+          "plotResiduals", "plotResiduals", "plotResiduals", "plotSlice", ...
+          "plotSlice", "plotSlice", "plsregress", "poissfit", "poisstat", ...
+          "polyconf", "polytool", "ppca", "predict", "predict", "predict", ...
+          "predict", "predict", "predict", "predict", "predict", "princomp", ...
+          "ProbDistUnivKernel", "ProbDistUnivParam", "probplot", ...
+          "procrustes", "proflik", "qrandset", "qrandstream", "random", ...
+          "random", "random", "random", "random", "random", "randomEffects", ...
+          "randsample", "randtool", "rangesearch", "ranksum", "raylcdf", ...
+          "raylfit", "raylinv", "raylpdf", "raylrnd", "raylstat", "rcoplot", ...
+          "refcurve", "refline", "regress", "RegressionBaggedEnsemble", ...
+          "RegressionEnsemble", "RegressionPartitionedEnsemble", ...
+          "RegressionPartitionedModel", "RegressionTree", "regstats", ...
+          "relieff", "removeTerms", "removeTerms", "residuals", "response", ...
+          "ridge", "robustdemo", "robustfit", "rotatefactors", "rowexch", ...
+          "rsmdemo", "rstool", "runstest", "sampsizepwr", "scatterhist", ...
+          "sequentialfs", "setlabels", "signrank", "signtest", "silhouette", ...
+          "slicesample", "sobolset", "squareform", "statget", "statset", ...
+          "step", "step", "stepwise", "stepwisefit", "stepwiseglm", ...
+          "stepwiselm", "struct2dataset", "surfht", "svmclassify", ...
+          "svmtrain", "table2dataset", "tabulate", "tblread", "tblwrite", ...
+          "tdfread", "tiedrank", "TreeBagger", "trimmean", "truncate", ...
+          "tstat", "ttest", "ttest2", "unidstat", "unifit", "unifstat", ...
+          "vartest", "vartest2", "vartestn", "wblfit", "wbllike", "wblplot", ...
+          "wblstat", "wishrnd", "x2fx", "xlsread", "xptread", "ztest"}
+      txt = check_package (fcn, "statistics");
 
-  otherwise
-    if (ismember (fcn, missing_functions ()))
-      txt = sprintf ("the '%s' function is not yet implemented in Octave", fcn);
-    else
-      is_matlab_function = false;
-      txt = "";
-    endif
+    ## optimization
+    case {"bintprog", "color", "fgoalattain", "fmincon", "fminimax", ...
+          "fminsearch", "fseminf", "fzmult", "gangstr", "ktrlink", ...
+          "linprog", "lsqcurvefit", "lsqlin", "lsqnonlin", "optimoptions", ...
+          "optimtool", "quadprog"}
+      txt = check_package (fcn, "optim");
+
+    otherwise
+      if (ismember (fcn, missing_functions ()))
+        txt = ["the '" fcn "' function is not yet implemented in Octave"];
+      else
+        is_matlab_function = false;
+        txt = "";
+      endif
   endswitch
 
   if (is_matlab_function)
-    txt = [txt, "\n\n@noindent\nPlease read ",...
-           "@url{http://www.octave.org/missing.html} to learn how ",...
+    txt = [txt, "\n\n@noindent\nPlease read ", ...
+           "@url{http://www.octave.org/missing.html} to learn how ", ...
            "you can contribute missing functionality."];
     txt = __makeinfo__ (txt);
   endif
 
   if (nargout == 0)
     warning ("Octave:missing-function", "%s", txt);
   endif
 
 endfunction
 
+function txt = check_package (fcn, name)
+  txt = sprintf ("the '%s' function belongs to the %s package from Octave Forge",
+                 fcn, name);
+
+  [~, status] = pkg ("describe", name);
+  switch (tolower (status{1}))
+    case "loaded",
+      txt = sprintf ("%s but has not yet been implemented.", txt);
+    case "not loaded",
+      txt = sprintf (["%s which you have installed but not loaded. To ", ...
+                      "load the package, run `pkg load %s' from the ", ...
+                      "Octave prompt."], txt, name);
+    otherwise
+      ## this includes "not installed" and anything else if pkg changes
+      ## the output of describe
+      txt = sprintf ("%s which seems to not be installed in your system.", txt);
+  endswitch
+endfunction
+
 function list = missing_functions ()
   persistent list = {
-  "DelaunayTri",
   "MException",
   "RandStream",
-  "TriRep",
-  "TriScatteredInterp",
+  "Tiff",
+  "VideoReader",
+  "VideoWriter",
   "align",
   "alim",
   "alpha",
   "alphamap",
   "annotation",
   "audiodevinfo",
+  "audioinfo",
   "audioplayer",
+  "audioread",
   "audiorecorder",
-  "aufinfo",
-  "auread",
-  "auwrite",
+  "audiowrite",
   "bar3",
   "bar3h",
   "bench",
   "bicgstabl",
   "brush",
   "builddocsearchdb",
   "bvp4c",
   "bvp5c",
@@ -150,102 +574,105 @@ function list = missing_functions ()
   "camzoom",
   "cdf2rdf",
   "cdfepoch",
   "cdfinfo",
   "cdfread",
   "cdfwrite",
   "cellplot",
   "checkin",
+  "checkcode",
   "checkout",
   "cholinc",
   "clearvars",
   "clipboard",
   "cmopts",
-  "cmpermute",
-  "cmunique",
   "colordef",
   "colormapeditor",
   "commandhistory",
   "commandwindow",
   "condeig",
   "coneplot",
+  "containers.Map",
   "contourslice",
   "createClassFromWsdl",
   "createSoapMessage",
   "customverctrl",
-  "daqread",
   "datacursormode",
-  "datatipinfo",
   "dbmex",
   "dde23",
   "ddeget",
+  "ddensd",
   "ddesd",
   "ddeset",
   "decic",
+  "delaunayTriangulation",
   "depdir",
   "depfun",
   "deval",
   "dialog",
   "dither",
-  "docopt",
   "docsearch",
   "dragrect",
   "dynamicprops",
   "echodemo",
   "evalc",
-  "exifread",
   "export2wsdlg",
   "figurepalette",
   "filebrowser",
   "fill3",
+  "fitsdisp",
   "fitsinfo",
   "fitsread",
+  "fitswrite",
   "flow",
   "frame2im",
   "freqspace",
   "funm",
   "gammaincinv",
   "getframe",
   "getpixelposition",
+  "gobjects",
   "grabcode",
   "graymon",
+  "griddedInterpolant",
   "gsvd",
   "guidata",
   "guide",
   "guihandles",
   "handle",
-  "hdf",
-  "hdf5",
-  "hdf5info",
-  "hdf5read",
-  "hdf5write",
+  "h5create",
+  "h5disp",
+  "h5info",
+  "h5read",
+  "h5readatt",
+  "h5write",
+  "h5writeatt",
   "hdfinfo",
   "hdfread",
-  "hdftool",
-  "helpbrowser",
-  "helpdesk",
-  "helpwin",
   "hgexport",
   "hgload",
   "hgsave",
   "hgsetget",
   "hgtransform",
-  "hostid",
+  "ichol",
   "ilu",
   "im2frame",
   "im2java",
   "imapprox",
-  "imformats",
   "import",
   "inmem",
   "inputParser",
   "inspect",
+  "instrcallback",
   "instrfind",
   "instrfindall",
+  "integral",
+  "integral2",
+  "integral3",
   "interpstreamspeed",
   "iscom",
   "isinterface",
   "isjava",
   "isocaps",
   "isstudent",
   "javachk",
   "ldl",
@@ -254,123 +681,127 @@ function list = missing_functions ()
   "libisloaded",
   "libpointer",
   "libstruct",
   "light",
   "lightangle",
   "lighting",
   "linkaxes",
   "linkdata",
-  "linsolve",
   "listfonts",
   "loadlibrary",
   "lscov",
   "lsqr",
   "makehgtform",
   "material",
+  "matfile",
   "matlabrc",
-  "maxNumCompThreads",
   "memmapfile",
   "memory",
   "metaclass",
   "methodsview",
   "minres",
-  "mlint",
   "mlintrpt",
   "mmfileinfo",
-  "mmreader",
   "movegui",
   "movie",
   "movie2avi",
-  "msgbox",
   "multibandread",
   "multibandwrite",
   "native2unicode",
+  "nccreate",
+  "ncdisp",
+  "ncinfo",
+  "ncread",
+  "ncreadatt",
+  "ncwrite",
+  "ncwriteatt",
+  "ncwriteschema",
   "noanimate",
+  "notebook",
   "ode113",
   "ode15i",
   "ode15s",
   "ode23",
   "ode23s",
   "ode23t",
   "ode23tb",
   "ode45",
-  "odefile",
   "odeget",
   "odeset",
   "odextend",
   "open",
   "openfig",
   "opengl",
   "openvar",
   "ordeig",
   "ordqz",
   "ordschur",
   "padecoef",
-  "pagesetupdlg",
   "pan",
   "parseSoapResponse",
-  "path2rc",
   "pathtool",
   "pcode",
   "pdepe",
   "pdeval",
-  "playshow",
   "plotbrowser",
   "plotedit",
   "plottools",
-  "prefdir",
-  "preferences",
   "printdlg",
   "printopt",
   "printpreview",
   "profsave",
   "propedit",
   "propertyeditor",
+  "psi",
   "publish",
   "qmr",
   "quad2d",
   "rbbox",
   "reducepatch",
   "reducevolume",
-  "root",
+  "readasync",
+  "rng",
   "rotate",
   "rotate3d",
+  "scatteredInterpolant",
   "selectmoveresize",
   "sendmail",
   "serial",
+  "serialbreak",
   "setpixelposition",
   "showplottool",
   "smooth3",
   "snapnow",
   "sound",
   "soundsc",
   "ss2tf",
+  "startup",
+  "stopasync",
   "stream2",
   "stream3",
   "streamline",
   "streamparticles",
   "streamribbon",
   "streamslice",
   "streamtube",
   "strings",
   "subvolume",
   "superclasses",
-  "support",
   "surf2patch",
   "symmlq",
   "syntax",
   "texlabel",
   "textwrap",
   "tfqmr",
   "timer",
-  "timerfind",
-  "timerfindall",
   "timeseries",
+  "todatenum",
   "toolboxdir",
+  "triangulation",
   "tscollection",
   "tstool",
   "uibuttongroup",
   "uicontextmenu",
   "uicontrol",
   "uigetpref",
   "uiimport",
   "uiopen",
@@ -387,37 +818,34 @@ function list = missing_functions ()
   "uitoolbar",
   "uiwait",
   "undocheckout",
   "unicode2native",
   "unloadlibrary",
   "unmesh",
   "userpath",
   "validateattributes",
+  "verctrl",
   "verLessThan",
   "viewmtx",
   "visdiff",
   "volumebounds",
-  "waitfor",
-  "wavfinfo",
-  "wavplay",
-  "wavrecord",
   "web",
   "whatsnew",
-  "wk1finfo",
-  "wk1read",
-  "wk1write",
+  "winopen",
+  "winqueryreg",
   "workspace",
   "xmlread",
   "xmlwrite",
   "xslt",
   "zoom",
   };
 endfunction
 
 
 %!test
 %! str = __unimplemented__ ("no_name_function");
 %! assert (isempty (str));
 %! str = __unimplemented__ ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
 %! str = __unimplemented__ ("MException");
 %! assert (str(1:58), "the 'MException' function is not yet implemented in Octave");
+
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2012 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -48,63 +48,74 @@ function retval = doc (fname)
         ftype = exist (fname);
       else
         error ("doc: expecting argument to be a character string");
       endif
     else
       fname = "";
     endif
 
-    if (ftype == 2 || ftype == 3)
-      ffile = which (fname);
-    else
-      ffile = "";
-    endif
-
-    if (isempty (ffile))
-      info_dir = octave_config_info ("infodir");
+    ## if GUI is running, let it display the function
+    if isguirunning ()
+      __octave_link_show_doc__ (fname);
     else
-      info_dir = fileparts (ffile);
-    endif
-
-    ## Determine if a file called doc.info exist in the same
-    ## directory as the function.
+  
+      if (ftype == 2 || ftype == 3)
+        ffile = which (fname);
+      else
+        ffile = "";
+      endif
 
-    info_file_name = fullfile (info_dir, "doc.info");
-
-    [stat_info, err] = stat (info_file_name);
+      if (isempty (ffile))
+        info_dir = octave_config_info ("infodir");
+      else
+        info_dir = fileparts (ffile);
+      endif
 
-    if (err < 0)
-      info_file_name = info_file ();
-    endif
+      ## Determine if a file called doc.info exist in the same
+      ## directory as the function.
+
+      info_file_name = fullfile (info_dir, "doc.info");
+
+      [stat_info, err] = stat (info_file_name);
+
+      if (err < 0)
+        info_file_name = info_file ();
 
-    ## FIXME -- don't change the order of the arguments below because
-    ## the info-emacs-info script currently expects --directory DIR as
-    ## the third and fourth arguments.  Someone should fix that.
+        if (! exist (info_file_name, "file"))
+          __gripe_missing_component__ ("doc", "info-file");
+        endif
+      endif
+
+      ## FIXME -- don't change the order of the arguments below because
+      ## the info-emacs-info script currently expects --directory DIR as
+      ## the third and fourth arguments.  Someone should fix that.
+
+      cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
+                     info_program (), info_file_name, info_dir);
+
+      have_fname = ! isempty (fname);
 
-    cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
-                   info_program (), info_file_name, info_dir);
+      if (have_fname)
+        status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
+      endif
+   
 
-    have_fname = ! isempty (fname);
+      if (! (have_fname && status == 0))
+        status = system (cmd);
+        if (status == 127)
+          warning ("unable to find info program '%s'", info_program ());
+        endif
+      endif
 
-    if (have_fname)
-      status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
+      if (nargout > 0)
+        retval = status;
+      endif
+
     endif
-
-    if (! (have_fname && status == 0))
-      status = system (cmd);
-      if (status == 127)
-        warning ("unable to find info program '%s'", info_program ());
-      endif
-    endif
-
-    if (nargout > 0)
-      retval = status;
-    endif
-
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!test
diff --git a/scripts/help/doc_cache_create.m b/scripts/help/doc_cache_create.m
--- a/scripts/help/doc_cache_create.m
+++ b/scripts/help/doc_cache_create.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -37,17 +37,17 @@ function doc_cache_create (out_file = "d
   if (! ischar (out_file))
     print_usage ();
   endif
 
   ## Generate cache
   if (isempty (directory))
     cache = gen_builtin_cache ();
   elseif (iscell (directory))
-    if (all (cellfun (@ischar, directory)))
+    if (all (cellfun ("isclass", directory, "char")))
       cache = gen_doc_cache_in_dir (directory);
     else
       error ("doc_cache_create: cell must contain only strings");
     endif
   elseif (ischar (directory))
      cache = gen_doc_cache_in_dir (directory);
   else
      error ("doc_cache_create: second input argument must be a string or a cell of strings");
@@ -90,61 +90,61 @@ function [text, first_sentence, status] 
   first_sentence = get_first_help_sentence (f);
 endfunction
 
 function cache = create_cache (list)
   cache = {};
 
   ## For each function:
   for n = 1:length (list)
-    f = list {n};
+    f = list{n};
 
     ## Get help text
     [text, format] = get_help_text (f);
 
     [text, first_sentence, status] = handle_function (f, text, format);
 
     ## Did we get the help text?
     if (status != 0)
       continue;
     endif
 
     ## Store the help text
-    cache (1, end+1) = f;
-    cache (2, end) = text;
-    cache (3, end) = first_sentence;
+    cache(1, end+1) = f;
+    cache(2, end) = text;
+    cache(3, end) = first_sentence;
   endfor
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
 
   ## If 'directory' is not in the current path, add it so we search it
   dir_in_path = ismember (directory, ostrsplit (path (), pathsep ()));
 
-  # dirs not in path
+  ## dirs not in path
   if (! iscell (directory))
     directory = {directory};
   endif
   dirs_notpath = {directory{!dir_in_path}};
 
-  # add them
+  ## add them
   if (! isempty (dirs_notpath))
-    cellfun (@addpath, dirs_notpath);
+    addpath (dirs_notpath{:});
   endif
 
-  # create cache
+  ## create cache
   func = @(s_) create_cache (__list_functions__ (s_));
-  cache = cellfun (func, directory, 'UniformOutput', false);
+  cache = cellfun (func, directory, "UniformOutput", false);
 
-  # concatenate results
+  ## concatenate results
   cache = [cache{:}];
 
-  #remove dirs form path
+  ## remove dirs form path
   if (! isempty (dirs_notpath))
-    cellfun (@rmpath, dirs_notpath);
+    rmpath (dirs_notpath{:});
   endif
 
 endfunction
 
 function cache = gen_builtin_cache ()
   operators = __operators__ ();
   keywords = __keywords__ ();
   builtins = __builtins__ ();
@@ -152,8 +152,9 @@ function cache = gen_builtin_cache ()
 
   cache = create_cache (list);
 endfunction
 
 
 %% No true tests desirable for this function.
 %% Test input validation
 %!error doc_cache_create (1)
+
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -152,17 +152,18 @@ function [text, status] = first_sentence
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
 
 
-%!assert (get_first_help_sentence ('get_first_help_sentence'), "Return the first sentence of a function's help text.")
+%!assert (get_first_help_sentence ('get_first_help_sentence'), ...
+%!        "Return the first sentence of a function's help text.")
 
 %% Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
 %!error <NAME must be a string> get_first_help_sentence (1)
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", "a")
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 0)
 %!error <MAX_LEN must be positive integer> get_first_help_sentence ("ls", 80.1)
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} help @var{name}
 ## @deftypefnx {Command} {} help @code{--list}
 ## @deftypefnx {Command} {} help @code{.}
-## Display the help text for @var{name}.   For example, the command
+## Display the help text for @var{name}.  For example, the command
 ## @kbd{help help} prints a short message describing the @code{help}
 ## command.
 ##
 ## Given the single argument @code{--list}, list all operators,
 ## keywords, built-in functions, and loadable functions available
 ## in the current session of Octave.
 ##
 ## Given the single argument @code{.}, list all operators available
@@ -150,17 +150,17 @@ function retval = do_list_functions ()
                    dir(fullfile (dirs{i}, "*.mex")).name});
 
     if (! isempty (files))
       flist = sprintf ("%s*** functions in %s:\n\n%s\n\n",
                        flist, dirs{i}, list_in_columns (files));
     endif
   endfor
 
-  retval = cstrcat (operators, keywords, builtins, flist);
+  retval = [operators, keywords, builtins, flist];
 
 endfunction
 
 function do_contents (name)
 
   found = false;
 
   dlist = find_dir_in_path (name, "all");
@@ -204,9 +204,8 @@ function do_contents (name)
   endif
 
 endfunction
 
 
 %!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!error <invalid input> help (42)
 
-
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,30 +19,31 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} lookfor @var{str}
 ## @deftypefnx {Command} {} lookfor -all @var{str}
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor (@var{str})
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ("-all", @var{str})
 ## Search for the string @var{str} in all functions found in the current
 ## function search path.  By default, @code{lookfor} searches for @var{str}
 ## in the first sentence of the help string of each function found.  The entire
-## help text of each function can be searched if the "-all" argument is
+## help text of each function can be searched if the @qcode{"-all"} argument is
 ## supplied.  All searches are case insensitive.
 ##
 ## Called with no output arguments, @code{lookfor} prints the list of
 ## matching functions to the terminal.  Otherwise, the output arguments
 ## @var{func} and @var{helpstring} define the matching functions and the
 ## first sentence of each of their help strings.
 ##
 ## The ability of @code{lookfor} to correctly identify the first
 ## sentence of the help text is dependent on the format of the
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
-## user-supplied functions.  Therefore, the use of the "-all" argument may
-## be necessary to find related functions that are not a part of Octave.
+## user-supplied functions.  Therefore, the use of the @qcode{"-all"}
+## argument may be necessary to find related functions that are not a part of
+## Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
 function [out_fun, out_help_text] = lookfor (str, arg2)
 
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
     ## we search.  The cache is organized such that the first column contains
diff --git a/scripts/help/module.mk b/scripts/help/module.mk
--- a/scripts/help/module.mk
+++ b/scripts/help/module.mk
@@ -1,15 +1,16 @@
 FCN_FILE_DIRS += help
 
 help_PRIVATE_FCN_FILES = \
   help/private/__additional_help_message__.m \
   help/private/__strip_html_tags__.m
 
 help_FCN_FILES = \
+  help/__gripe_missing_component__.m \
   help/__makeinfo__.m \
   help/__unimplemented__.m \
   help/doc.m \
   help/doc_cache_create.m \
   help/get_first_help_sentence.m \
   help/help.m \
   help/lookfor.m \
   help/print_usage.m \
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -26,32 +26,32 @@
 ## @end deftypefn
 
 function print_usage (name)
   x = dbstack ();
   ## Handle input
   if (nargin == 0)
     ## Determine the name of the calling function
     if (numel (x) > 1)
-      name = x (2).name;
+      name = x(2).name;
     else
       error ("Octave:invalid-context", "print_usage: invalid function\n");
     endif
-    fullpath = evalin ("caller", "mfilename (""fullpath"")");
+    fullpath = evalin ("caller", 'mfilename ("fullpath")');
     if (strcmp (fullpath(end-length(name)+1:end), name))
-      fullname = [fullpath, ".m"];
+      fullname = [fullpath ".m"];
     endif
-  elseif (!ischar (name))
+  elseif (! ischar (name))
     error ("Octave:invalid-input-arg",
-                                "print_usage: input argument must be a string");
+           "print_usage: input argument must be a string");
   else
     fullname = name;
   endif
 
-  ## Determine if we're called from top level.
+  ## Determine if we were called from top level.
   at_toplev = length (x) < 2 || (length (x) == 2 && strcmp (x(2).name, name));
 
   ## Do the actual work
   [text, format] = get_help_text (fullname);
   max_len = 80;
   switch (lower (format))
     case "plain text"
       [usage_string, status] = get_usage_plain_text (text, max_len);
@@ -69,17 +69,18 @@ function print_usage (name)
 
   ## Raise the final error
   if (status != 0)
     warning ("print_usage: Texinfo formatting filter exited abnormally");
     warning ("print_usage: raw Texinfo source of help text follows...\n");
   endif
 
   if (at_toplev)
-    error ("Octave:invalid-fun-call", "Invalid call to %s.  Correct usage is:\n\n%s\n%s",
+    error ("Octave:invalid-fun-call",
+           "Invalid call to %s.  Correct usage is:\n\n%s\n%s",
            name, usage_string, __additional_help_message__ ());
   else
     msg = sprintf ("Invalid call to %s.  Correct usage is:\n\n%s",
                    name, usage_string);
     ## Ensure that the error doesn't end up with a newline, as that disables
     ## backtraces.
     if (msg(end) == "\n")
       msg(end) = " ";
@@ -97,35 +98,33 @@ function [retval, status] = get_usage_pl
   status = 0;
 endfunction
 
 function [retval, status] = get_usage_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
-  ## Find, and keep, lines that start with @def or @end def. This should include things
-  ## such as @deftypefn, @deftypefnx, @defvar, etc. and their corresponding @end's
+  ## Find, and keep, lines that start with @def or @end def. This should
+  ## include things such as @deftypefn, @deftypefnx, @defvar, etc. and their
+  ## corresponding @end's.
   def_idx = strfind (help_text, "@def");
-  if (!isempty (def_idx))
-    buffer = "";
+  if (! isempty (def_idx))
+    endf_idx = strfind (help_text, "@end def");
+    def_idx = sort ([def_idx, endf_idx]);
     endl_idx = find (help_text == "\n");
+    buffer = "";
     for k = 1:length (def_idx)
-      endl = endl_idx (find (endl_idx > def_idx (k), 1));
+      endl = endl_idx (find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
-        buffer = strcat (buffer, help_text (def_idx (k):end), "\n");
+        buffer = strcat (buffer, help_text (def_idx(k):end), "\n");
       else
-        buffer = strcat (buffer, help_text (def_idx (k):endl));
+        buffer = strcat (buffer, help_text (def_idx(k):endl));
       endif
     endfor
-
-    end_def_idx = strfind (help_text, "@end def");
-    if (!isempty (end_def_idx))
-      buffer = strcat (buffer, help_text (end_def_idx:end));
-    endif
   else
     [retval, status] = get_usage_plain_text (help_text, max_len);
   endif
 
   ## Run makeinfo to generate plain text
   [retval, status] = __makeinfo__ (buffer, "plain text");
 endfunction
 
@@ -135,8 +134,9 @@ function [retval, status] = get_usage_ht
 
   ## Extract first line with plain text method.
   retval = get_usage_plain_text (help_text, max_len);
 endfunction
 
 
 ## Stop reporting function as missing tests.  No good tests possible.
 %!assert (1)
+
diff --git a/scripts/help/private/__additional_help_message__.m b/scripts/help/private/__additional_help_message__.m
--- a/scripts/help/private/__additional_help_message__.m
+++ b/scripts/help/private/__additional_help_message__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -32,8 +32,9 @@ available in the online version of the m
 'doc <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.octave.org and via the help@octave.org\n\
 mailing list.\n";
   endif
 
 endfunction
+
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -74,8 +74,9 @@ function text = strip_superfluous_endlin
     start = groups (idx (k), 1);
     stop = start + groups (idx (k), 2) - 1;
     keep (start+2:stop) = false;
   endfor
 
   ## Actually remove the elements
   text = text (keep);
 endfunction
+
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2009-2012 Sren Hauberg
+## Copyright (C) 2009-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,113 +14,127 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} type @var{name} @dots{}
 ## @deftypefnx {Command} {} type -q @var{name} @dots{}
-## @deftypefnx {Function File} {dfns =} type ("@var{name}", @dots{})
-## Display the definition of each @var{name} that refers to a function.
+## @deftypefnx {Function File} {text =} type ("@var{name}", @dots{})
+## Display the contents of @var{name} which may be a file, function (m-file),
+## variable, operator, or keyword.
 ##
-## Normally also displays whether each @var{name} is user-defined or built-in;
-## the @option{-q} option suppresses this behavior.
+## @code{type} normally prepends a header line describing the category
+## of @var{name} such as function or variable; The @option{-q} option
+## suppresses this behavior.
 ##
-## If an output argument is requested nothing is displayed.  Instead, a cell
-## array of strings is returned, where each element corresponds to the
-## definition of each requested function.
+## If no output variable is used the contents are displayed on screen.
+## Otherwise, a cell array of strings is returned, where each element
+## corresponds to the contents of each requested function.
 ## @end deftypefn
 
-function retval = type (varargin)
-  ## Parse input
+function text = type (varargin)
+
   if (nargin == 0)
-    error ("type: not enough input arguments");
-  endif
-
-  if (!iscellstr (varargin))
+    print_usage ();
+  elseif (! iscellstr (varargin))
     error ("type: input arguments must be strings");
   endif
 
   quiet = false;
   idx = strcmpi (varargin, "-q") | strcmpi (varargin, "-quiet");
   if (any (idx))
     quiet = true;
-    varargin (idx) = [];
+    varargin(idx) = [];
   endif
 
   if (nargout > 0)
-    retval = cell (size (varargin));
+    text = cell (size (varargin));
   endif
 
   for n = 1:length (varargin)
-    name = varargin {n};
+    name = varargin{n};
 
     ## Find function and get its code
-    text = "";
+    txt = "";
     cmd = sprintf ("exist ('%s')", name);
     e = evalin ("caller", cmd);
     if (e == 1)
       ## Variable
       cmd = sprintf ("disp (%s);", name);
       desc = evalin ("caller", cmd);
       if (quiet)
-        text = desc;
+        txt = desc;
       else
-        text = sprintf ("%s is a variable\n%s", name, desc);
+        txt = sprintf ("%s is a variable\n%s", name, desc);
       endif
     elseif (e == 2)
       ## m-file or ordinary file
       file = which (name);
-      if (isempty (file))
+      if (length (file) > 2)
+        ext = file(end-1:end);
+      endif
+      if (isempty (file) || ! strcmpi (ext, ".m"))
         ## 'name' is an ordinary file, and not a function name.
-        ## FIXME: Should we just print it anyway?
-        error ("type: '%s' undefined\n", name);
+        file = file_in_loadpath (name);
+        quiet = true;
       endif
 
       ## Read the file
       fid = fopen (file, "r");
       if (fid < 0)
         error ("type: couldn't open '%s' for reading", file);
       endif
       contents = char (fread (fid).');
       fclose (fid);
 
       if (quiet)
-        text = contents;
+        txt = contents;
       else
-        text = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
+        txt = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
                         name, file, contents);
       endif
     elseif (e == 3)
-      text = sprintf ("%s is a dynamically-linked function", name);
+      txt = sprintf ("%s is a dynamically-linked function", name);
     elseif (e == 5)
-      text = sprintf ("%s is a built-in function", name);
+      txt = sprintf ("%s is a built-in function", name);
     elseif (any (strcmp (__operators__ (), name)))
-      text = sprintf ("%s is an operator", name);
+      txt = sprintf ("%s is an operator", name);
     elseif (any (strcmp (__keywords__ (), name)))
-      text = sprintf ("%s is a keyword", name);
+      txt = sprintf ("%s is a keyword", name);
     else
       error ("type: '%s' undefined\n", name);
     endif
 
-    ## Should we return the text or print if
     if (nargout == 0)
-      disp (text);
+      disp (txt);
     else
-      retval {n} = text;
+      text{n} = txt;
     endif
   endfor
 endfunction
 
 
 %!test
 %! var = 1;
-%! typestr = type ("var");
-%! typestr = typestr{1}(1:17);
+%! text = type ("var");
+%! typestr = text{1}(1:17);
 %! assert (typestr, "var is a variable");
 
+%!test
+%! text = type ("ls");
+%! typestr = text{1}(1:31);
+%! assert (typestr, "ls is the user-defined function");
+
+%!test
+%! text = type ("ls", "-q");
+%! typestr = text{1}(1:21);
+%! assert (typestr, "## Copyright (C) 2006");
+
 %!assert (type ("amd"){1}, "amd is a dynamically-linked function")
 %!assert (type ("cat"){1}, "cat is a built-in function")
 %!assert (type ("+"){1}, "+ is an operator")
 %!assert (type ("end"){1}, "end is a keyword")
-%!error (type ('NO_NAME'))
+
+%!error type ()
+%!error <'__NO_NAME__' undefined> type ('__NO_NAME__')
  
diff --git a/scripts/image/cmpermute.m b/scripts/image/cmpermute.m
--- a/scripts/image/cmpermute.m
+++ b/scripts/image/cmpermute.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map})
 ## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map}, @var{index})
 ## Reorder colors in a colormap.
 ##
 ## When called with only two arguments, @code{cmpermute} randomly rearranges
 ## the colormap @var{map} and returns a new colormap @var{newmap}.  It also
 ## returns the indexed image @var{Y} which is the equivalent of the original
-## input image @var{X} when displayed using @var{newmap}.  
+## input image @var{X} when displayed using @var{newmap}.
 ##
 ## When called with an optional third argument the order of colors in the
 ## new colormap is defined by @var{index}.
 ##
 ## @strong{Caution:} @code{index} should not have repeated elements or the
 ## function will fail.
 ##
 ## @end deftypefn
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -73,22 +73,22 @@ function [Y, newmap] = cmunique (X, map)
     [newmap,i,j] = unique (map, "rows");  # calculate unique colormap
     if (isfloat (X))
       Y = j(X);               # find new indices
     else
       Y = j(double (X) + 1);  # find new indices, switch to 1-based index
     endif
   else
     switch (size (X,3))
-      case (1)
+      case 1
         ## I case
         [newmap,i,j] = unique (X);               # calculate unique colormap
         newmap = repmat (newmap,1,3);            # get a RGB colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
-      case (3)
+      case 3
         ## RGB case
         ## build a map with all values
         map = [X(:,:,1)(:), X(:,:,2)(:), X(:,:,3)(:)];
         [newmap,i,j] = unique (map, "rows");     # calculate unique colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
       otherwise
         error ("cmunique: X is not a valid image");
     endswitch
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
--- a/scripts/image/colorcube.m
+++ b/scripts/image/colorcube.m
@@ -41,41 +41,41 @@ function map = colorcube (n)
     print_usage ();
   endif
 
   if (n < 9)
     map = gray (n);
     return;
   endif
 
-  # Create colorcube of evenly spaced points with side length of n^1/3
+  ## Create colorcube of evenly spaced points with side length of n^1/3
   cubelen = fix (cbrt (n));
   reserve = n - cubelen^3; 
 
   if (reserve == 0)
-    # Steal space from blue to put the gray gradient
+    ## Steal space from blue to put the gray gradient
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
                           linspace (0,1,cubelen),
                           linspace (0,1,cubelen-1));
   else
     [r, g, b] = meshgrid (linspace (0,1,cubelen),
                           linspace (0,1,cubelen),
                           linspace (0,1,cubelen));
   endif
 
-  # Create map and weed out grays
+  ## Create map and weed out grays
   map = [r(:), g(:), b(:)];
   idx = any (bsxfun (@ne, map(:, 1), map(:, 2:3)), 2);
   map = map(idx, :);
 
-  # Weed out pure colors
+  ## Weed out pure colors
   idx = sum (map == 0, 2);
   map = map(idx != 2, :);
 
-  # Put in remaining gradients of pure red, green, blue, and gray
+  ## Put in remaining gradients of pure red, green, blue, and gray
   reserve = n - rows (map) - 1;
   csteps = fix (reserve/4);
   cstepsz = 1 / csteps;
   cgrad = (cstepsz:cstepsz:1)';
   gsteps = reserve - 3*csteps;
   gstepsz = 1 / gsteps;
   ggrad = (gstepsz:gstepsz:1)';
   map = [map
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -16,51 +16,71 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{cmap} =} colormap ()
 ## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{map})
 ## @deftypefnx {Function File} {@var{cmap} =} colormap ("default")
-## @deftypefnx {Function File} {@var{cmap} =} colormap ("list")
-## @deftypefnx {Function File} {@var{cmap} =} colormap ("register", "@var{name}")
-## @deftypefnx {Function File} {@var{cmap} =} colormap ("unregister", "@var{name}")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("@var{map_name}")
+## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{hax}, @dots{})
+## @deftypefnx {Command} {} colormap @var{map_name}
+## @deftypefnx {Function File} {@var{cmaps} =} colormap ("list")
+## @deftypefnx {Function File} {} colormap ("register", "@var{name}")
+## @deftypefnx {Function File} {} colormap ("unregister", "@var{name}")
 ## Query or set the current colormap.
 ##
+## With no input arguments, @code{colormap} returns the current color map.
+##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## colormap should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## must be between 0 and 1 inclusive.  The new colormap is returned.
 ##
 ## @code{colormap ("default")} restores the default colormap (the
 ## @code{jet} map with 64 entries).  The default colormap is returned.
 ##
-## @code{colormap ("list")} returns a cell array with all the available
-## colormaps.  The options @code{"register"} and @code{"unregister"}
-## will add or remove the colormap @var{name} to it.
+## The map may also be specified by a string, @qcode{"@var{map_name}"}, where
+## @var{map_name} is the name of a function that returns a colormap.
+##
+## If the first argument @var{hax} is an axes handle, then the colormap for
+## the parent figure of @var{hax} is queried or set.
 ##
-## With no arguments, @code{colormap} returns the current color map.
+## For convenience, it is also possible to use this function with the
+## command form, @code{colormap @var{map_name}}.
+##
+## @code{colormap ("list")} returns a cell array with all of the available
+## colormaps.  The options @qcode{"register"} and @qcode{"unregister"}
+## add or remove the colormap @var{name} from this list.
+##
 ## @seealso{jet}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function cmap = colormap (map, name)
+function cmap = colormap (varargin)
+  persistent map_list = cell ();
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("colormap", varargin{:});
 
   if (nargin > 2)
     print_usage ();
   endif
 
-  persistent map_list = cell ();
+  if (! isempty (hax))
+    cf = ancestor (hax, "figure");
+  else
+    cf = get (0, "currentfigure");
+  endif
 
   if (nargin == 1)
-
+    map = varargin{1};
     if (ischar (map))
       if (strcmp (map, "default"))
         map = jet (64);
       elseif (strcmp (map, "list"))
         cmap = map_list;
         return;
       else
         map = feval (map);
@@ -70,33 +90,95 @@ function cmap = colormap (map, name)
     if (! isempty (map))
       if (! (isnumeric (map) && isreal (map)
              && ndims (map) == 2 && columns (map) == 3))
         error ("colormap: MAP must be a real-valued N x 3 ([R,G,B]) matrix");
       endif
       if (any (map(:) < 0) || any (map(:) > 1))
         error ("colormap: all MAP values must be in the range [0,1]");
       endif
+      if (isempty (cf))
+        cf = gcf ();
+      endif
       ## Set the new color map
-      set (gcf (), "colormap", map);
+      set (cf, "colormap", map);
     endif
 
   elseif (nargin == 2)
-    if (! ischar (map) || all (! strcmp (map, {"register", "unregister"})))
+    opt = varargin{1};
+    name = varargin{2};
+    if (! ischar (opt) || ! any (strcmp (opt, {"register", "unregister"})))
       print_usage ();
     elseif (! ischar (name))
       error ("colormap: to register/unregister a colormap, NAME must be a string");
-    elseif (strcmp (map, "register"))
+    elseif (strcmp (opt, "register"))
       map_list{end+1} = name;
-    elseif (strcmp (map, "unregister"))
+    elseif (strcmp (opt, "unregister"))
       map_list(strcmp (name, map_list)) = [];
     endif
   endif
 
   ## Return current color map.
   if (nargout > 0 || (nargout == 0 && nargin == 0))
-    cmap = get (gcf (), "colormap");
+    if (isempty (cf))
+      cf = gcf ();
+    endif
+    cmap = get (cf, "colormap");
   endif
 
 endfunction
 
 
-%% FIXME: Need some demos/tests
+%!demo
+%! ## Create an image for displaying a colormap
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! ## Show 'jet' colormap
+%! colormap (jet (64));
+%! title "colormap (jet (64))"
+%! disp ("Press a key to continue");
+%! pause ();
+%! ## Show 'colorcube' colormap
+%! colormap (colorcube (64));
+%! title "colormap (colorcube (64))"
+
+%!test
+%! hf = figure ("visible", "off");
+%! cmaptst = [0 1 0; 1 0 1; 1 1 1];
+%! cmap = colormap (cmaptst);
+%! assert (cmap, cmaptst);
+%! cmap = colormap ();
+%! assert (cmap, cmaptst);
+%! cmap = (get (gcf, "colormap"));
+%! assert (cmap, cmaptst);
+%! colormap ("default");
+%! assert (colormap (), jet (64));
+%! colormap ("ocean");
+%! assert (colormap, ocean (64));
+%! close (hf);  # done with temp. figure
+
+%!test
+%! cmaplst = colormap ("list");
+%! assert (iscell (cmaplst));
+%! colormap ("register", "__mycmap__"); 
+%! cmaplst2 = colormap ("list");
+%! assert (numel (cmaplst2), numel (cmaplst) + 1);
+%! assert (any (strcmp (cmaplst2, "__mycmap__")));
+%! colormap ("unregister", "__mycmap__"); 
+%! cmaplst2 = colormap ("list");
+%! assert (numel (cmaplst2), numel (cmaplst));
+%! assert (! any (strcmp (cmaplst2, "__mycmap__")));
+%! ## Unregister again and verify that nothing has happened
+%! colormap ("unregister", "__mycmap__"); 
+%! cmaplst3 = colormap ("list");
+%! assert (isequal (cmaplst2, cmaplst3));
+
+## Test input validation
+%!error colormap (1,2,3)
+%!error <MAP must be a real-valued N x 3> colormap ({1,2,3})
+%!error <MAP must be a real-valued N x 3> colormap ([1 i 1])
+%!error <MAP must be a real-valued N x 3> colormap (ones(3,3,3))
+%!error <MAP must be a real-valued N x 3> colormap ([1 0 1 0])
+%!error <all MAP values must be in the range> colormap ([-1 0 0])
+%!error <all MAP values must be in the range> colormap ([2 0 0])
+%!error colormap ("invalid", "name")
+%!error <NAME must be a string> colormap ("register", 1)
+
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -70,18 +70,18 @@ function rgb_map = hsv2rgb (hsv_map)
   if (! isreal (hsv_map) || columns (hsv_map) != 3 || issparse (hsv_map))
     error ("hsv2rgb: input must be a matrix of size Nx3 or MxNx3");
   endif
 
   ## FIXME: Currently input is validated and an error results if values
   ##        are outside range [0, 1].  We could also simply allow those values
   ##        and re-instate this code to produce saturating semantics.
   ## Trim map to range [0, 1]
-  #hsv_map(hsv_map < 0) = 0;
-  #hsv_map(hsv_map > 1) = 1;
+  ## hsv_map(hsv_map < 0) = 0;
+  ## hsv_map(hsv_map > 1) = 1;
 
   h = hsv_map(:,1);
   s = hsv_map(:,2);
   v = hsv_map(:,3);
   ## Prefill rgb map with v*(1-s)
   rgb_map = repmat (v .* (1 - s), 1, 3);
 
   ## red = hue-2/3 : green = hue : blue = hue-1/3
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -34,31 +34,35 @@
 ## or earlier.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ##
 ## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
-## @code{ydir} property to "reverse".  This has implications whenever
+## @code{ydir} property to @qcode{"reverse"}.  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
 ## using, for example, @code{flipud (ydata)}.
 ##
 ## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = image (varargin)
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ ("image", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("image", varargin{:});
+  
+  if (isempty (hax))
+    hax = gca ();
+  endif
 
   chararg = find (cellfun ("isclass", varargin, "char"), 1, "first");
   
   if (nargin == 0 || chararg == 1)
     img = imread ("default.img");
     x = y = [];
   elseif (nargin == 1 || chararg == 2)
     img = varargin{1};
@@ -66,25 +70,19 @@ function h = image (varargin)
   elseif (nargin == 2 || chararg == 3)
     print_usage ();
   else
     x = varargin{1};
     y = varargin{2};
     img = varargin{3};
     chararg = 4;
   endif
-
-  oldax = gca ();
-  unwind_protect
-    axes (ax);
-    htmp = __img__ (x, y, img, varargin{chararg:end});
-    set (ax, "layer", "top");
-  unwind_protect_cleanup
-    axes (oldax);
-  end_unwind_protect
+  
+  htmp = __img__ (hax, x, y, img, varargin{chararg:end});
+  set (hax, "layer", "top");
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
 ## Generic image creation.
@@ -92,19 +90,17 @@ endfunction
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function h = __img__ (x, y, img, varargin)
-  
-  newplot ();
+function h = __img__ (hax, x, y, img, varargin)
 
   if (isempty (img))
     error ("__img__: matrix is empty");
   endif
 
   ## FIXME: Hack for integer formats which use zero-based indexing
   ##        Hack favors correctness of display over size of image in memory.
   ##        True fix will be done in C++ code. 
@@ -131,19 +127,17 @@ function h = __img__ (x, y, img, varargi
     dy = diff (y);
     dx = std (dx) / mean (abs (dx));
     dy = std (dy) / mean (abs (dy));
     if (any (dx > tol) || any (dy > tol))
       warning ("image: non-linear X, Y data is ignored.  IMG will be shown with linear mapping");
     endif
   endif
 
-  ca = gca ();
-
-  htmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
+  htmp = __go_image__ (hax, "cdata", img, "xdata", xdata, "ydata", ydata,
                        "cdatamapping", "direct", varargin {:});
 
   px = __image_pixel_size__ (htmp);
 
   if (xdata(2) < xdata(1))
     xdata = fliplr (xdata);
   elseif (xdata(2) == xdata(1))
     xdata = xdata(1) + [0, columns(img)-1];
@@ -157,32 +151,32 @@ function h = __img__ (x, y, img, varargi
   ylim = ydata + [-px(2), px(2)];
 
   ## FIXME -- how can we do this and also get the {x,y}limmode
   ## properties to remain "auto"?  I suppose this adjustment should
   ## happen automatically in axes::update_axis_limits instead of
   ## explicitly setting the values here.  But then what information is
   ## available to axes::update_axis_limits to determine that the
   ## adjustment is necessary?
-  set (ca, "xlim", xlim, "ylim", ylim);
+  set (hax, "xlim", xlim, "ylim", ylim);
 
   if (ndims (img) == 3)
     if (isinteger (img))
       cls = class (img);
       mn = intmin (cls);
       mx = intmax (cls);
-      set (ca, "clim", double ([mn, mx]));
+      set (hax, "clim", double ([mn, mx]));
     endif
   endif
 
-  set (ca, "view", [0, 90]);
+  set (hax, "view", [0, 90]);
 
-  if (strcmp (get (ca, "nextplot"), "replace"))
-    # Always reverse y-axis for images, unless hold is on
-    set (ca, "ydir", "reverse");
+  if (strcmp (get (hax, "nextplot"), "replace"))
+    ## Always reverse y-axis for images, unless hold is on
+    set (hax, "ydir", "reverse");
   endif
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -15,22 +15,22 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} imagesc (@var{img})
 ## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{img})
 ## @deftypefnx {Function File} {} imagesc (@dots{}, @var{climits})
-## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
+## @deftypefnx {Function File} {} imagesc (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
 ## Display a scaled version of the matrix @var{img} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
 ## colormap.  If @code{@var{climits} = [@var{lo}, @var{hi}]} is given, then that
-## range is set to the "clim" of the current axes.
+## range is set to the @qcode{"clim"} of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{img}.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
@@ -40,24 +40,24 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function h = imagesc (varargin)
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    harg = varargin{1};
-    if (! strcmp (get (harg, "type"), "axes"))
-      error ("imagesc: expecting first argument to be an axes object");
+    hax = varargin{1};
+    if (! isaxes (hax))
+      error ("imagesc: HAX argument must be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
-      htmp = __imagesc__ (harg, varargin{2:end});
+      htmp = __imagesc__ (hax, varargin{2:end});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   else
     htmp = __imagesc__ (gca (), varargin{:});
   endif
 
   if (nargout > 0)
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -13,145 +13,149 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{info} =} imfinfo (@var{filename})
+## @deftypefnx {Function File} {@var{info} =} imfinfo (@var{filename}, @var{ext})
 ## @deftypefnx {Function File} {@var{info} =} imfinfo (@var{url})
 ## Read image information from a file.
 ##
 ## @code{imfinfo} returns a structure containing information about the image
-## stored in the file @var{filename}.  The output structure contains the
-## following fields.
+## stored in the file @var{filename}.  If there is no file @var{filename},
+## and @var{ext} was specified, it will look for a file named @var{filename}
+## and extension @var{ext}, i.e., a file named @var{filename}.@var{ext}.
+##
+## The output structure @var{info} contains the following fields:
 ##
 ## @table @samp
 ## @item Filename
 ## The full name of the image file.
 ##
+## @item FileModDate
+## Date of last modification to the file.
+##
 ## @item FileSize
 ## Number of bytes of the image on disk
 ##
-## @item FileModDate
-## Date of last modification to the file.
+## @item Format
+## Image format (e.g., @qcode{"jpeg"}).
 ##
 ## @item Height
 ## Image height in pixels.
 ##
 ## @item Width
 ## Image Width in pixels.
 ##
 ## @item BitDepth
 ## Number of bits per channel per pixel.
 ##
-## @item Format
-## Image format (e.g., @code{"jpeg"}).
-##
-## @item LongFormat
-## Long form image format description.
+## @item ColorType
+## Image type.  Value is @qcode{"grayscale"}, @qcode{"indexed"},
+## @qcode{"truecolor"}, @qcode{"CMYK"}, or @qcode{"undefined"}.
 ##
 ## @item XResolution
 ## X resolution of the image.
 ##
 ## @item YResolution
 ## Y resolution of the image.
 ##
-## @item TotalColors
-## Number of unique colors in the image.
+## @item ResolutionUnit
+## Units of image resolution.  Value is @qcode{"Inch"},
+## @qcode{"Centimeter"}, or @qcode{"undefined"}.
 ##
-## @item TileName
-## Tile name.
-##
-## @item AnimationDelay
+## @item DelayTime
 ## Time in 1/100ths of a second (0 to 65535) which must expire before displaying
 ## the next image in an animated sequence.
 ##
-## @item AnimationIterations
-## Number of iterations to loop an animation (e.g., Netscape loop extension)
-## for.
+## @item LoopCount
+## Number of iterations to loop an animation.
 ##
 ## @item ByteOrder
-## Endian option for formats that support it.  Value is @code{"little-endian"},
-## @code{"big-endian"}, or @code{"undefined"}.
+## Endian option for formats that support it.  Value is @qcode{"little-endian"},
+## @qcode{"big-endian"}, or @qcode{"undefined"}.
 ##
 ## @item Gamma
 ## Gamma level of the image.  The same color image displayed on two different
 ## workstations may look different due to differences in the display monitor.
 ##
-## @item Matte
-## @code{true} if the image has transparency.
+## @item Quality
+## JPEG/MIFF/PNG compression level.  Value is an integer in the range [0 100].
+##
+## @item DisposalMethod
+## Only valid for GIF images, control how successive frames are rendered (how
+## the preceding frame is disposed of) when creating a GIF animation.  Values
+## can be @qcode{"doNotSpecify"}, @qcode{"leaveInPlace"}, @qcode{"restoreBG"},
+## or @qcode{"restorePrevious"}.  For non-GIF files, value is an empty string.
+##
+## @item Chromaticities
+## Value is a 1x8 Matrix with the x,y chromaticity values for white, red,
+## green, and blue points, in that order.
 ##
-## @item ModulusDepth
-## Image modulus depth (minimum number of bits required to support
-## red/green/blue components without loss of accuracy).
+## @item Comment
+## Image comment.
 ##
-## @item Quality
-## JPEG/MIFF/PNG compression level.
+## @item Compression
+## Compression type.  Value can be @qcode{"none"}, @qcode{"bzip"},
+## @qcode{"fax3"}, @qcode{"fax4"}, @qcode{"jpeg"}, @qcode{"lzw"},
+## @qcode{"rle"}, @qcode{"deflate"}, @qcode{"lzma"}, @qcode{"jpeg2000"},
+## @qcode{"jbig2"}, @qcode{"jbig2"}, or @qcode{"undefined"}.
+##
+## @item Colormap
+## Colormap for each image.
+##
+## @item Orientation
+## The orientation of the image with respect to the rows and columns.  Value
+## is an integer between 1 and 8 as defined in the TIFF 6 specifications, and
+## for @sc{matlab} compatibility.
 ##
-## @item QuantizeColors
-## Preferred number of colors in the image.
+## @item Software
+## Name and version of the software or firmware of the camera or image input
+## device used to generate the image.
 ##
-## @item ResolutionUnits
-## Units of image resolution.  Value is @code{"pixels per inch"},
-## @code{"pixels per centimeter"}, or @code{"undefined"}.
+## @item Make
+## The manufacturer of the recording equipment.  This is the manufacture of the
+## @nospell{DSC}, scanner, video digitizer or other equipment that generated
+## the image.
+##
+## @item Model
+## The model name or model number of the recording equipment as mentioned
+## on the field @qcode{"Make"}.
 ##
-## @item ColorType
-## Image type.  Value is @code{"grayscale"}, @code{"indexed"},
-## @code{"truecolor"}, or @code{"undefined"}.
+## @item DateTime
+## The date and time of image creation as defined by the Exif standard, i.e.,
+## it is the date and time the file was changed.
+##
+## @item ImageDescription
+## The title of the image as defined by the Exif standard.
 ##
-## @item View
-## FlashPix viewing parameters.
+## @item Artist
+## Name of the camera owner, photographer or image creator.
+##
+## @item Copyright
+## Copyright notice of the person or organization claiming rights to the image.
+##
+## @item DigitalCamera
+## A struct with information retrieved from the Exif tag.
+##
+## @item GPSInfo
+## A struct with geotagging information retrieved from the Exif tag.
 ## @end table
 ##
-## @seealso{imread, imwrite, imshow}
+## @seealso{imread, imwrite, imshow, imformats}
 ## @end deftypefn
 
 ## Author: Soren Hauberg <hauberg@gmail.com>
 
-function info = imfinfo (filename)
-
-  if (nargin < 1)
+function info = imfinfo (varargin)
+  if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif
-
-  if (! ischar (filename))
+  elseif (! ischar (varargin{1}))
     error ("imfinfo: FILENAME must be a string");
+  elseif (nargin > 1 && ! ischar (varargin{2}))
+    error ("imfinfo: EXT must be a string");
   endif
-
-  filename = tilde_expand (filename);
-
-  delete_file = false;
-
-  unwind_protect
-
-    fn = file_in_path (IMAGE_PATH, filename);
-
-    if (isempty (fn))
-
-      ## Couldn't find file. See if it's an URL.
-
-      tmp = tmpnam ();
+  info = imageIO (@__imfinfo__, "info", varargin, varargin{:});
+endfunction
 
-      [fn, status, msg] = urlwrite (filename, tmp);
-
-      if (! status)
-        error ("imfinfo: cannot find %s", filename);
-      endif
-
-      if (! isempty (fn))
-        delete_file = true;
-      endif
-
-    endif
-
-    info = __magick_finfo__ (fn);
-
-  unwind_protect_cleanup
-
-    if (delete_file)
-      unlink (fn);
-    endif
-
-  end_unwind_protect
-
-endfunction
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/imformats.m
@@ -0,0 +1,329 @@
+## Copyright (C) 2013 Carn Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} imformats ()
+## @deftypefnx {Function File} {@var{formats} =} imformats (@var{ext})
+## @deftypefnx {Function File} {@var{formats} =} imformats (@var{format})
+## @deftypefnx {Function File} {@var{formats} =} imformats ("add", @var{format})
+## @deftypefnx {Function File} {@var{formats} =} imformats ("remove", @var{ext})
+## @deftypefnx {Function File} {@var{formats} =} imformats ("update", @var{ext}, @var{format})
+## @deftypefnx {Function File} {@var{formats} =} imformats ("factory")
+## Manage supported image formats.
+##
+## @var{formats} is a structure with information about each supported file
+## format, or from a specific format @var{ext}, the value displayed on the
+## field @code{ext}.  It contains the following fields:
+##
+## @table @asis
+## @item ext
+## The name of the file format.  This may match the file extension but Octave
+## will automatically detect the file format.
+##
+## @item description
+## A long description of the file format.
+##
+## @item @nospell{isa}
+## A function handle to confirm if a file is of the specified format.
+##
+## @item write
+## A function handle to write if a file is of the specified format.
+##
+## @item read
+## A function handle to open files the specified format.
+##
+## @item info
+## A function handle to obtain image information of the specified format.
+##
+## @item alpha
+## Logical value if format supports alpha channel (transparency or matte).
+##
+## @item multipage
+## Logical value if format supports multipage (multiple images per file).
+## @end table
+##
+## It is possible to change the way Octave manages file formats with the options
+## @qcode{"add"}, @qcode{"remove"}, and @qcode{"update"}, and supplying a
+## structure @var{format} with the required fields.  The option
+## @qcode{"factory"} resets the configuration to the default.
+##
+## This can be used by Octave packages to extend the image reading capabilities
+## Octave, through use of the PKG_ADD and PKG_DEL commands.
+##
+## @seealso{imfinfo, imread, imwrite}
+## @end deftypefn
+
+## Author: Carn Draug <carandraug@octave.org>
+
+function varargout = imformats (arg1, arg2, arg3)
+  if (nargin > 3)
+    print_usage ();
+  endif
+
+  persistent formats = default_formats ();
+
+  if (nargin == 0 && nargout == 0)
+    error ("imformats: pretty print not yet implemented.");
+  elseif (nargin >= 1)
+    if (isstruct (arg1))
+      arrayfun (@is_valid_format, arg1);
+      ## FIXME: what is the return value in this situation?
+      formats = arg1;
+
+    elseif (ischar (arg1))
+      switch (tolower (arg1))
+        case "add",
+          if (! isstruct (arg2))
+            error ("imformats: FORMAT to %s must be a structure.", arg1);
+          endif
+          arrayfun (@is_valid_format, arg2);
+          formats(end + 1: end + numel (arg2)) = arg2;
+          varargout{1} = formats;
+
+        case {"remove", "update"},
+          if (! ischar (arg2))
+            error ("imformats: EXT to %s must be a string.", arg1);
+          endif
+          ## FIXME: suppose a format with multiple extensions. If one of
+          ##        them is requested to be removed, should we remove the
+          ##        whole format, or just that extension from the format?
+          match = find_ext_idx (formats, arg2);
+          if (! any (match))
+            error ("imformats: no EXT `%s' found.", arg2);
+          endif
+          if (strcmpi (arg1, "remove"))
+            formats(match) = [];
+          else
+            ## then it's update
+            if (! isstruct (arg3))
+              error ("imformats: FORMAT to update must be a structure.");
+            endif
+            is_valid_format (arg3);
+            formats(match) = arg3;
+          endif
+          varargout{1} = formats;
+
+        case "factory",
+          formats = default_formats ();
+        otherwise
+          ## then we look for a format with that extension.
+          match = find_ext_idx (formats, arg1);
+          ## For matlab compatibility, if we don't find any format we must
+          ## return an empty struct with NO fields. We can't use match as mask
+          if (any (match))
+            varargout{1} = formats(match);
+          else
+            varargout{1} = struct ();
+          endif
+      endswitch
+    else
+      error ("imformats: first argument must be either a structure or string.");
+    endif
+  else
+    varargout{1} = formats;
+  endif
+endfunction
+
+function formats = default_formats ()
+
+  ## The available formats are dependent on what the user has installed at
+  ## a given time, and how GraphicsMagick was built. Checking for
+  ## GraphicsMagick features when building Octave is not enough since it
+  ## delegates some of them to external programs which can be removed or
+  ## installed at any time.
+  ## The recommended method would be to use CoderInfoList() to get a list of
+  ## all available coders and try to write and read back a small test image.
+  ## But this will not work since some coders are readable or writable only.
+  ## It will still fail if we test only the ones marked as readable and
+  ## writable because some RW coders are not of image formats (NULL, 8BIM,
+  ## or EXIF for example).
+  ## So we'd need a blacklist (unacceptable because a `bad' coder may be
+  ## added later) or a whitelist. A whitelist means that even with a
+  ## super-fancy recent build of GraphicsMagick, some formats won't be listed
+  ## by imformats but in truth, we will still be able to read and write them
+  ## since imread() and imwrite() will give it a try anyway.
+  ##
+  ## For more info and comments from the GraphicsMagick main developer, see
+  ## http://sourceforge.net/mailarchive/forum.php?thread_name=alpine.GSO.2.01.1304301916050.2267%40freddy.simplesystems.org&forum_name=graphicsmagick-help
+
+  persistent formats = struct ( "coder", {},
+                                "ext", {},
+                                "isa", {},
+                                "info", {},
+                                "read", {},
+                                "write", {},
+                                "alpha", {},
+                                "description", {},
+                                "multipage", {});
+
+  ## Image IO abilities won't change during the same Octave session,
+  ## there's no need to go and calculate it all over again if we are
+  ## requested to reset back to factory.
+  if (! isempty (formats))
+    return;
+  endif
+
+  ##      Building the formats info
+  ##
+  ## As mentioned above we start with a whitelist of coders. Since the
+  ## GraphicsMagick build may be missing some coders, we will remove those
+  ## from the list. Some info can be obtained directly from GraphicsMagick
+  ## through the CoderInfo object. However, some will need to be hardcoded.
+  ##
+  ## The association between file extensions and coders needs to be done
+  ## with a manually coded list (file extensions do not define the image
+  ## format and GraphicsMagick will not be fooled by changing the extension).
+  ##
+  ## We can get the read, write, description and multipage fields from
+  ## CoderInfo in C++. We should do the same for alpha (GraphicsMagick
+  ## calls it matte) but it's not available from CoderInfo. The only way to
+  ## check it is to create a sample image with each coder, then try to read
+  ## it back with GraphicsMagick and use the matte method on the Image class.
+  ## But making such test for each Octave session... meh! While technically
+  ## it may be possible that the same coder has different support for alpha
+  ## channel in different versions and builds, this doesn't seem to happen.
+  ## So we also hardcode those. In the future, maybe the CoderInfo class will
+  ## have a matte method like it does for multipage.
+  ##
+  ## Other notes: some formats have more than one coder that do the same. For
+  ## example, for jpeg images there is both the JPG and JPEG coders. However,
+  ## it seems that when reading images, GraphicsMagick only uses one of them
+  ## and that's the one we list (it's the one reported by imfinfo and that we
+  ## can use for isa). However, in some cases GraphicsMagick seems to rely
+  ## uniquely on the file extension ((JBIG and JBG at least. Create an image
+  ## with each of those coders, swap their extension and it will report the
+  ## other coder). We don't have such cases on the whitelist but if we did, we
+  ## would need two entries for such cases.
+
+  ## each row: 1st => Coder, 2nd=> file extensions, 3rd=> alpha
+  coders = {"BMP",  {"bmp"},          true;
+            "CUR",  {"cur"},          false;
+            "GIF",  {"gif"},          true;
+            "ICO",  {"ico"},          true;
+            "JBG",  {"jbg"},          false;
+            "JBIG", {"jbig"},         false;
+            "JP2",  {"jp2", "jpx"},   true;
+            "JPEG", {"jpg", "jpeg"},  false; # there is also a JPG coder
+            "PBM",  {"pbm"},          false;
+            "PCX",  {"pcx"},          true;
+            "PGM",  {"pgm"},          false;
+            "PGM",  {"pgm"},          false;
+            "PNG",  {"png"},          true;
+            ## PNM is a family of formats supporting portable bitmaps (PBM),
+            ## graymaps (PGM), and pixmaps (PPM). There is no file format
+            ## associated with pnm itself. If PNM is used as the output format
+            ## specifier, then GraphicsMagick automatically selects the most
+            ## appropriate format to represent the image.
+            "PNM",  {"pnm"},          true;
+            "PPM",  {"ppm"},          false;
+            "SUN",  {"ras"},          true; # SUN Rasterfile
+            "TGA",  {"tga", "tpic"},  true;
+            "TIFF", {"tif", "tiff"},  true;
+            "XBM",  {"xbm"},          false;
+            "XPM",  {"xpm"},          true;
+            "XWD",  {"xwd"},          false;
+            };
+
+  for fidx = 1: rows(coders)
+    formats(fidx).coder = coders{fidx, 1};
+    formats(fidx).ext   = coders{fidx, 2};
+    formats(fidx).alpha = coders{fidx, 3};
+    ## default isa is to check if the format returned by imfinfo is the coder
+    formats(fidx).isa   = @(x) isa_magick (coders{fidx,1}, x);
+  endfor
+
+  ## the default info, read, and write functions
+  [formats.info ] = deal (@__imfinfo__);
+  [formats.read ] = deal (@__imread__);
+  [formats.write] = deal (@__imwrite__);
+
+  ## fills rest of format information by checking with GraphicsMagick
+  formats = __magick_formats__ (formats);
+endfunction
+
+function is_valid_format (format)
+  ## the minimal list of fields required in the structure. We don't
+  ## require multipage because it doesn't exist in matlab
+  min_fields  = {"ext", "read", "isa", "write", "info", "alpha", "description"};
+  fields_mask = isfield (format, min_fields);
+  if (! all (fields_mask))
+    error ("imformats: structure has missing field `%s'.", min_fields(! fields_mask){1});
+  endif
+endfunction
+
+function match = find_ext_idx (formats, ext)
+  ## FIXME: is matlab sensitive to file extensions?
+  ## XXX: what should we do if there's more than one hit?
+  ##      Should this function prevent the addition of
+  ##      duplicated extensions?
+  match = cellfun (@(x) any (strcmp (x, ext)), {formats.ext});
+endfunction
+
+function bool = isa_magick (coder, filename)
+  bool = false;
+  try
+    info = __magick_ping__ (filename, 1);
+    bool = strcmp (coder, info.Format);
+  end_try_catch
+endfunction
+
+
+## changing the function to read
+%!testif HAVE_MAGICK
+%! fmt = imformats ("jpg");
+%! fmt.read = @(x) size (x, 2);
+%! imformats ("update", "jpg", fmt);
+%! assert (imread ("this is 30 characters long.jpg"), 30);
+
+## adding a new format
+%!testif HAVE_MAGICK
+%! fmt = imformats ("jpg");
+%! fmt.ext = "junk";
+%! fmt.read = @(x) true();
+%! imformats ("add", fmt);
+%! assert (imread ("some file.junk"), true);
+
+## adding multiple formats in one way
+%!testif HAVE_MAGICK
+%! fmt = imformats ("jpg");
+%! fmt.ext = "junk1";
+%! fmt.read = @(x) true();
+%! fmt(2) = fmt(1);
+%! fmt(2).ext = "junk2";
+%! imformats ("add", fmt);
+%! assert (imread ("some file.junk1"), true);
+%! assert (imread ("some file.junk2"), true);
+
+## changing format
+%!testif HAVE_MAGICK
+%! ori_fmt = mod_fmt = imformats ("jpg");
+%! mod_fmt.description = "Another description";
+%! imformats ("update", "jpg", mod_fmt);
+%! new_fmt = imformats ("jpg");
+%! assert (new_fmt.description, mod_fmt.description);
+%! imformats ("factory");
+%! new_fmt = imformats ("jpg");
+%! assert (new_fmt.description, ori_fmt.description);
+
+## FIXME: how to test for error together with testif?
+## update to an invalid format
+#%!testif HAVE_MAGICK
+#%! fmt = imformats ("jpg");
+#%! fmt = rmfield (fmt, "read");
+#%! error imformats ("update", "jpg", fmt);
+
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -1,8 +1,9 @@
+## Copyright (C) 2013 Carn Draug
 ## Copyright (C) 2008-2012 Thomas L. Scofield
 ## Copyright (C) 2008 Kristian Rumberg
 ## Copyright (C) 2006 Thomas Weber
 ## Copyright (C) 2005 Stefan van der Walt
 ## Copyright (C) 2002 Andy Adler
 ##
 ## This file is part of Octave.
 ##
@@ -15,89 +16,100 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
+## -*- texinfo -*-
+## @deftypefn  {Function File} {[@var{img}, @var{map}, @var{alpha}] =} imread (@var{filename})
+## @deftypefnx {Function File} {[@dots{}] =} imread (@var{filename}, @var{ext})
+## @deftypefnx {Function File} {[@dots{}] =} imread (@var{url})
+## @deftypefnx {Function File} {[@dots{}] =} imread (@dots{}, @var{idx})
+## @deftypefnx {Function File} {[@dots{}] =} imread (@dots{}, @var{param1}, @var{val1}, @dots{})
+## Read images from various file formats.
+##
+## Reads an image as a matrix from the file @var{filename}.  If there is
+## no file @var{filename}, and @var{ext} was specified, it will look for
+## a file named @var{filename} and extension @var{ext}, i.e., a file named
+## @var{filename}.@var{ext}.
+##
+## The size and class of the output depends on the
+## format of the image.  A color image is returned as an
+## @nospell{MxNx3} matrix.  Gray-level and black-and-white images are
+## of size @nospell{MxN}.  Multipage images will have an additional 4th
+## dimension.
+##
+## The bit depth of the image determines the
+## class of the output: @qcode{"uint8"}, @qcode{"uint16"} or @qcode{"single"}
+## for gray and color, and @qcode{"logical"} for black and white.
+## Note that indexed images always return the indexes for a colormap,
+## independent if @var{map} is a requested output.  To obtain the actual
+## RGB image, use @code{ind2rgb}.  When more than one indexed image is being
+## read, @var{map} is obtained from the first.  In some rare cases this
+## may be incorrect and @code{imfinfo} can be used to obtain the colormap of
+## each image.
+##
+## See the Octave manual for more information in representing images.
+##
+## Some file formats, such as TIFF and GIF, are able to store multiple
+## images in a single file.  @var{idx} can be a scalar or vector
+## specifying the index of the images to read.  By default, Octave
+## will only read the first page.
+##
+## Depending on the file format, it is possible to configure the reading
+## of images with @var{param}, @var{val} pairs.  The following options
+## are supported:
+##
+## @table @samp
+## @item @qcode{"Frames"} or @qcode{"Index"}
+## This is an alternative method to specify @var{idx}.  When specifying it
+## in this way, its value can also be the string @qcode{"all"}.
+##
+## @item @qcode{"Info"}
+## This option exists for @sc{matlab} compatibility and has no effect.  For
+## maximum performance while reading multiple images from a single file,
+## use the Index option.
+##
+## @item @qcode{"PixelRegion"}
+## Controls the image region that is read.  Takes as value a cell array
+## with two arrays of 3 elements @code{@{@var{rows} @var{cols}@}}.  The
+## elements in the array are the start, increment and end pixel to be
+## read.  If the increment value is omitted, defaults to 1.
+## @end table
+##
+## @seealso{imwrite, imfinfo, imformats}
+## @end deftypefn
+
+## Author: Carn Draug <carandraug@octave.org>
 ## Author: Thomas L. Scofield <scofield@calvin.edu>
 ## Author: Kristian Rumberg <kristianrumberg@gmail.com>
 ## Author: Thomas Weber <thomas.weber.mail@gmail.com>
 ## Author: Stefan van der Walt <stefan@sun.ac.za>
 ## Author: Andy Adler
 
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{img}, @var{map}, @var{alpha}] =} imread (@var{filename})
-## Read images from various file formats.
-##
-## The size and numeric class of the output depends on the
-## format of the image.  A color image is returned as an
-## @nospell{MxNx3} matrix.  Gray-level and black-and-white images are
-## of size @nospell{MxN}.
-## The color depth of the image determines the numeric
-## class of the output: "uint8" or "uint16" for gray
-## and color, and "logical" for black and white.
-##
-## @seealso{imwrite, imfinfo}
-## @end deftypefn
-
-function varargout = imread (filename, varargin)
-
+function [img, varargout] = imread (varargin)
   if (nargin < 1)
     print_usage ();
-  endif
-
-  if (! ischar (filename))
+  elseif (! ischar (varargin{1}))
     error ("imread: FILENAME must be a string");
   endif
-
-  filename = tilde_expand (filename);
-
-  fn = file_in_path (IMAGE_PATH, filename);
-
-  if (isempty (fn))
-    error ("imread: cannot find %s", filename);
+  ## In case the file format was specified as a separate argument we
+  ## do this. imageIO() will ignore the second part if filename on its
+  ## own is enough. And if the second argument was a parameter name instead
+  ## of an extension, it is still going to be passed to the next function
+  ## since we are passing the whole function input as well.
+  filename = {varargin{1}};
+  if (nargin > 1 && ischar (varargin {2}))
+    filename{2} = varargin{2};
   endif
 
-  try
-    [varargout{1:nargout}] = __magick_read__ (fn, varargin{:});
-  catch
-
-    magick_error = lasterr ();
-
-    img_field = false;
-    x_field = false;
-    map_field = false;
-
-    try
-      vars = load (fn);
-      if (isstruct (vars))
-        img_field = isfield (vars, "img");
-        x_field = isfield (vars, "X");
-        map_field = isfield (vars, "map");
-      endif
-    catch
-      error ("imread: invalid image file: %s", magick_error);
-    end_try_catch
-
-    if (map_field && (img_field || x_field))
-      varargout{2} = vars.map;
-      if (img_field)
-        varargout{1} = vars.img;
-      else
-        varargout{1} = vars.X;
-      endif
-    else
-      error ("imread: invalid Octave image file format");
-    endif
-
-  end_try_catch
-
+  [img, varargout{1:nargout-1}] = imageIO (@__imread__, "read", filename, varargin{:});
 endfunction
 
 
 %!testif HAVE_MAGICK
 %! vpng = [ ...
 %!  137,  80,  78,  71,  13,  10,  26,  10,   0,   0, ...
 %!    0,  13,  73,  72,  68,  82,   0,   0,   0,   3, ...
 %!    0,   0,   0,   3,   8,   2,   0,   0,   0, 217, ...
@@ -109,17 +121,21 @@ endfunction
 %!  250,   0,   0,   0, 128, 232,   0,   0, 117,  48, ...
 %!    0,   0, 234,  96,   0,   0,  58, 152,   0,   0, ...
 %!   23, 112, 156, 186,  81,  60,   0,   0,   0,  25, ...
 %!   73,  68,  65,  84,  24,  87,  99,  96,  96,  96, ...
 %!  248, 255, 255,  63, 144,   4,  81, 111, 101,  84, ...
 %!   16,  28, 160,  16,   0, 197, 214,  13,  34,  74, ...
 %!  117, 213,  17,   0,   0,   0,   0,  73,  69,  78, ...
 %!   68, 174,  66,  96, 130];
-%! fid = fopen ("test.png", "wb");
-%! fwrite (fid, vpng);
-%! fclose (fid);
-%! A = imread ("test.png");
-%! delete ("test.png");
+%! filename = [tmpnam() ".png"];
+%! unwind_protect
+%!   fid = fopen (filename, "wb");
+%!   fwrite (fid, vpng);
+%!   fclose (fid);
+%!   A = imread (filename);
+%! unwind_protect_cleanup
+%!   unlink (filename);
+%! end_unwind_protect
 %! assert (A(:,:,1), uint8 ([0, 255, 0; 255, 237, 255; 0, 255, 0]));
 %! assert (A(:,:,2), uint8 ([0, 255, 0; 255,  28, 255; 0, 255, 0]));
 %! assert (A(:,:,3), uint8 ([0, 255, 0; 255,  36, 255; 0, 255, 0]));
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -38,17 +38,17 @@
 ##
 ## If a file name is given instead of an image, the file will be read and
 ## shown.
 ##
 ## If given, the parameter @var{string_param1} has value
 ## @var{value1}.  @var{string_param1} can be any of the following:
 ##
 ## @table @asis
-## @item "displayrange"
+## @item @qcode{"displayrange"}
 ## @var{value1} is the display range as described above.
 ## @end table
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imagesc, colormap, gray2ind, rgb2ind}
 ## @end deftypefn
 
 ## Author: Stefan van der Walt  <stefan@sun.ac.za>
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2008-2012 John W. Eaton
+## Copyright (C) 2013 Carn Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,184 +14,104 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} imwrite (@var{img}, @var{filename})
-## @deftypefnx {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt})
-## @deftypefnx {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
-## @deftypefnx {Function File} {} imwrite (@var{img}, @var{map}, @var{filename}, @dots{})
+## @deftypefnx {Function File} {} imwrite (@var{img}, @var{filename}, @var{ext})
+## @deftypefnx {Function File} {} imwrite (@var{img}, @var{map}, @var{filename})
+## @deftypefnx {Function File} {} imwrite (@dots{}, @var{param1}, @var{val1}, @dots{})
 ## Write images in various file formats.
 ##
-## If @var{fmt} is not supplied, the file extension of @var{filename} is used
-## to determine the format.
+## The image @var{img} can be a binary, grayscale, RGB, or multi-dimensional
+## image.  The size and class of @var{img} should be the same as what should
+## be expected when reading it with @code{imread}: the 3rd and 4th dimensions
+## reserved for color space, and multiple pages respectively.  If it's an
+## indexed image, the colormap @var{map} must also be specified.
 ##
-## The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional.
-## Currently the following options are supported for @t{JPEG} images:
+## If @var{ext} is not supplied, the file extension of @var{filename} is used
+## to determine the format.  The actual supported formats are dependent on
+## options made during the build of Octave.  Use @code{imformats} to check
+## the support of the different image formats.
+##
+## Depending on the file format, it is possible to configure the writing
+## of images with @var{param}, @var{val} pairs.  The following options
+## are supported:
 ##
 ## @table @samp
+## @item Alpha
+## Alpha (transparency) channel for the image.  This must be a matrix with
+## same class, and number of rows and columns of @var{img}.  In case of a
+## multipage image, the size of the 4th dimension must also match and the third
+## dimension must be a singleton.  By default, image will be completely
+## opaque.
+##
 ## @item Quality
 ## Set the quality of the compression.  The value should be an
 ## integer between 0 and 100, with larger values indicating higher visual
-## quality and lower compression.
+## quality and lower compression.  Defaults to 75.
+##
+## @item WriteMode
+## Some file formats, such as TIFF and GIF, are able to store multiple
+## images in a single file.  This option specifies if @var{img} should be
+## appended to the file (if it exists) or if a new file should be created
+## for it (possibly overwriting an existing file).  The value should be
+## the string @qcode{"Overwrite"} (default), or @qcode{"Append"}.
+##
+## Despite this option, the most efficient method of writing a multipage
+## image is to pass a 4 dimensional @var{img} to @code{imwrite}, the
+## same matrix that could be expected when using @code{imread} with the
+## option @qcode{"Index"} set to @qcode{"all"}.
+##
 ## @end table
 ##
-## @strong{Supported Formats}
-## @multitable @columnfractions .33 .66
-## @headitem Extension @tab Format
-## @item bmp @tab Windows Bitmap
-## @item gif @tab Graphics Interchange Format
-## @item jpg and jpeg @tab Joint Photographic Experts Group
-## @item pbm @tab Portable Bitmap
-## @item pcx @tab
-## @item pgm @tab Portable Graymap
-## @item png @tab Portable Network Graphics
-## @item pnm @tab Portable Anymap
-## @item ppm @tab Portable Pixmap
-## @item ras @tab Sun Raster
-## @item tif and tiff @tab Tagged Image File Format
-## @item xwd @tab X11 Dump
-## @end multitable
-##
-## @strong{Unsupported Formats}
-## @multitable @columnfractions .33 .66
-## @headitem Extension @tab Format
-## @item hdf @tab Hierarchical Data Format V4
-## @item @nospell{jp2} and jpx @tab Joint Photographic Experts Group 2000
-## @end multitable
-##
-## @seealso{imread, imfinfo}
+## @seealso{imread, imfinfo, imformats}
 ## @end deftypefn
 
-function imwrite (img, varargin)
-
-  persistent imwrite_possible_formats = {
-    "bmp"; "gif"; "jp2"; "jpg"; "jpx"; "jpeg"; "hdf"; "pbm"; "pcx";
-    "pgm"; "png"; "pnm"; "ppm"; "ras"; "tif"; "tiff"; "xwd" };
-
-  persistent accepted_formats = __magick_format_list__ (imwrite_possible_formats);
-
-  if (nargin < 2 || ! (isnumeric (img) || islogical (img)))
-    print_usage ();
-  endif
-
-  map = [];
-  fmt = "";
-
-  offset = 1;
-  if (isnumeric (varargin{1}))
-    map = varargin{1};
-    if (isempty (map))
-      error ("imwrite: colormap must not be empty");
-    endif
-    offset = 2;
-  endif
-  if (offset <= length (varargin) && ischar (varargin{offset}))
-    filename = varargin{offset};
-    offset++;
-    if (rem (length (varargin) - offset, 2) == 0 && ischar (varargin{offset}))
-      fmt = varargin{offset};
-      offset++;
-    endif
-  else
+function imwrite (varargin)
+  if (nargin < 2)
     print_usage ();
   endif
-  if (offset < length (varargin))
-    has_param_list = 1;
-    for ii = offset:2:(length (varargin) - 1)
-      options.(varargin{ii}) = varargin{ii + 1};
-    endfor
-  else
-    has_param_list = 0;
-  endif
-
-  filename = tilde_expand (filename);
-
-  if (isempty (fmt))
-    [d, n, fmt] = fileparts (filename);
-    if (! isempty (fmt))
-      fmt = fmt(2:end);
-    endif
-  endif
-
-  if (isempty (img))
-    error ("imwrite: invalid empty image");
-  endif
-
-  if (issparse (img) || issparse (map))
-    error ("imwrite: sparse images not supported");
-  endif
-
-  if (! strcmp (fmt, accepted_formats))
-    error ("imwrite: %s: unsupported or invalid image format", fmt);
-  endif
-
-  img_class = class (img);
-  map_class = class (map);
-  nd = ndims (img);
+  [filename, ext] = imwrite_filename (varargin{2:end});
 
-  if (isempty (map))
-    if (any (strcmp (img_class, {"logical", "uint8", "uint16", "double"})))
-      if ((nd == 2 || nd == 3) && strcmp (img_class, "double"))
-        img = uint8 (img * 255);
-      endif
-      ## FIXME: should we handle color images with alpha channel here?
-      if (nd == 3 && size (img, 3) < 3)
-        error ("imwrite: invalid dimensions for truecolor image");
-      endif
-      if (nd > 5)
-        error ("imwrite: invalid %d-dimensional image data", nd);
-      endif
-    else
-      error ("imwrite: %s: invalid class for truecolor image", img_class);
+  fmt = imformats (ext);
+  ## When there is no match, fmt will be a 1x1 structure with
+  ## no fields, so we can't just use `isempty (fmt)'.
+  if (isempty (fieldnames (fmt)))
+    if (isempty (ext))
+      error ("imwrite: no extension found for %s to identify the image format",
+             filename);
     endif
-    if (has_param_list)
-      __magick_write__ (filename, fmt, img, options);
-    else
-      __magick_write__ (filename, fmt, img);
-    endif
+    warning ("imwrite: unlisted image format %s (see imformats). Trying to save anyway.",
+             ext);
+    __imwrite__ (varargin{:});
   else
-    if (any (strcmp (img_class, {"uint8", "uint16", "double"})))
-      if (strcmp (img_class, "double"))
-        img = uint8 (img - 1);
-      endif
-      if (nd != 2 && nd != 4)
-        error ("imwrite: invalid size for indexed image");
-      endif
-    else
-      error ("imwrite: %s: invalid class for indexed image data", img_class);
-    endif
-    if (! iscolormap (map))
-      error ("imwrite: invalid indexed image colormap");
-    endif
-
-    ## FIXME: we should really be writing indexed images here but
-    ##        __magick_write__ needs to be fixed to handle them.
-
-    [r, g, b] = ind2rgb (img, map);
-    tmp = uint8 (cat (3, r, g, b) * 255);
-
-    if (has_param_list)
-      __magick_write__ (filename, fmt, tmp, options);
-      ## __magick_write__ (filename, fmt, img, map, options);
-    else
-      __magick_write__ (filename, fmt, tmp);
-      ## __magick_write__ (filename, fmt, img, map);
-    endif
+    fmt.write (varargin{:});
   endif
 
 endfunction
 
 
 %% Test input validation
 %!error imwrite ()                            # Wrong # of args
 %!error imwrite (1)                           # Wrong # of args
 %!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
 %!error imwrite (1, [], "filename.jpg")       # Empty image map
 %!error imwrite (1, 2, 3)                     # No filename specified
 %!error imwrite (1, "filename")               # No fmt specified
 %!error imwrite (1, "filename", "junk")       # Invalid fmt specified
 %!error imwrite ([], "filename.jpg")          # Empty img matrix
 %!error imwrite (spones (2), "filename.jpg")  # Invalid sparse img
 
+%!testif HAVE_MAGICK
+%! imw = randi (255, 100, "uint8");
+%! filename = [tmpnam() ".png"];
+%! unwind_protect
+%!   imwrite (imw, filename);
+%!   imr = imread (filename);
+%! unwind_protect_cleanup
+%!   unlink (filename);
+%! end_unwind_protect
+%! assert (imw, imr)
+
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -25,17 +25,17 @@
 ## image, pixels in @var{x} outside the range are mapped to the last color in
 ## the map before conversion to grayscale.
 ##
 ## The output @var{I} is of the same class as the input @var{x} and may be
 ## one of @code{uint8}, @code{uint16}, @code{single}, or @code{double}.
 ##
 ## Implementation Note: There are several ways of converting colors to
 ## grayscale intensities.  This functions uses the luminance value obtained
-## from @code{rgb2ntsc} which is @code{I = 0.299*R + 0.587*G + 0.114*B}.  
+## from @code{rgb2ntsc} which is @code{I = 0.299*R + 0.587*G + 0.114*B}.
 ## Other possibilities include the value component from @code{rgb2hsv} or
 ## using a single color channel from @code{ind2rgb}.
 ## @seealso{gray2ind, ind2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
diff --git a/scripts/image/lines.m b/scripts/image/lines.m
--- a/scripts/image/lines.m
+++ b/scripts/image/lines.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} lines ()
 ## @deftypefnx {Function File} {@var{map} =} lines (@var{n})
 ## Create color colormap.  This colormap is composed of the list of colors
-## in the current axes "ColorOrder" property.  The default is blue,
+## in the current axes @qcode{"ColorOrder"} property.  The default is blue,
 ## green, red, cyan, pink, yellow, and gray.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## PKG_ADD: colormap ("register", "lines");
 ## PKG_DEL: colormap ("unregister", "lines");
diff --git a/scripts/image/module.mk b/scripts/image/module.mk
--- a/scripts/image/module.mk
+++ b/scripts/image/module.mk
@@ -1,11 +1,16 @@
 FCN_FILE_DIRS += image
 
 image_PRIVATE_FCN_FILES = \
+  image/private/__imfinfo__.m \
+  image/private/__imread__.m \
+  image/private/__imwrite__.m \
+  image/private/imageIO.m \
+  image/private/imwrite_filename.m \
   image/private/ind2x.m
 
 image_FCN_FILES = \
   image/autumn.m \
   image/bone.m \
   image/brighten.m \
   image/cmpermute.m \
   image/cmunique.m \
@@ -20,16 +25,17 @@ image_FCN_FILES = \
   image/gray2ind.m \
   image/hot.m \
   image/hsv.m \
   image/hsv2rgb.m \
   image/iscolormap.m \
   image/image.m \
   image/imagesc.m \
   image/imfinfo.m \
+  image/imformats.m \
   image/imread.m \
   image/imshow.m \
   image/imwrite.m \
   image/ind2gray.m \
   image/ind2rgb.m \
   image/jet.m \
   image/lines.m \
   image/ntsc2rgb.m \
diff --git a/scripts/image/private/__imfinfo__.m b/scripts/image/private/__imfinfo__.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/__imfinfo__.m
@@ -0,0 +1,72 @@
+## Copyright (C) 2008-2012 Soren Hauberg
+## Copyright (C) 2013 Carn Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## This function does al the work of imfinfo. It exists here as private
+## function so that imfinfo can use other functions if imformats is
+## configured to. It is also needed so that imformats can create a
+## function handle for it.
+
+## Author: Soren Hauberg <hauberg@gmail.com>
+
+function info = __imfinfo__ (filename, ext)
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ("imfinfo");
+  endif
+
+  if (! ischar (filename))
+    error ("imfinfo: FILENAME must be a string");
+  elseif (nargin >= 2 && ! ischar (ext))
+    error ("imfinfo: EXT must be a string");
+  endif
+  filename = tilde_expand (filename);
+
+  delete_file = false;
+  unwind_protect
+
+    fn = file_in_path (IMAGE_PATH, filename);
+    if (isempty (fn))
+      ## We couldn't find the file so...
+      if (nargin >= 2)
+        ## try adding a possible file extesion
+        filename  = [filename "." ext];
+        fn        = file_in_path (IMAGE_PATH, filename);
+        if (isempty (fn))
+          error ("imfinfo: cannot find file %s", filename);
+        endif
+      else
+        ## try filename as an URL
+        [fn, status, msg] = urlwrite (filename, tmpnam ());
+        if (! status)
+          error ("imfinfo: cannot find or download %s: %s", filename, msg);
+        endif
+        delete_file = true;
+      endif
+    endif
+
+    info = __magick_finfo__ (fn);
+
+  unwind_protect_cleanup
+    if (delete_file)
+      unlink (fn);
+    endif
+  end_unwind_protect
+
+endfunction
+
diff --git a/scripts/image/private/__imread__.m b/scripts/image/private/__imread__.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/__imread__.m
@@ -0,0 +1,207 @@
+## Copyright (C) 2013 Carn Draug
+## Copyright (C) 2008-2012 Thomas L. Scofield
+## Copyright (C) 2008 Kristian Rumberg
+## Copyright (C) 2006 Thomas Weber
+## Copyright (C) 2005 Stefan van der Walt
+## Copyright (C) 2002 Andy Adler
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## This function does all the work of imread. It exists here as private
+## function so that imread can use other functions if imformats is
+## configured to. It is also needed so that imformats can create a
+## function handle for it.
+
+## Author: Carn Draug <carandraug@octave.org>
+## Author: Thomas L. Scofield <scofield@calvin.edu>
+## Author: Kristian Rumberg <kristianrumberg@gmail.com>
+## Author: Thomas Weber <thomas.weber.mail@gmail.com>
+## Author: Stefan van der Walt <stefan@sun.ac.za>
+## Author: Andy Adler
+
+function varargout = __imread__ (filename, varargin)
+
+  if (nargin < 1)
+    print_usage ("imread");
+  elseif (! ischar (filename))
+    error ("imread: FILENAME must be a string");
+  endif
+
+  ## keep track of the varargin offset we're looking at each moment
+  offset    = 1;
+
+  filename  = tilde_expand (filename);
+  fn        = file_in_path (IMAGE_PATH, filename);
+  if (isempty (fn) && nargin >= offset + 1 && ischar (varargin{offset}))
+    ## if we can't find the file, check if the next input is the file extension
+    filename  = [filename "." varargin{offset}];
+    fn        = file_in_path (IMAGE_PATH, filename);
+    offset++;
+  endif
+  if (isempty (fn))
+    error ("imread: cannot find %s", filename);
+  endif
+
+  ## It is possible for an file with multiple pages to have very different
+  ## images on each page. Specifically, they may have different sizes. Because
+  ## of this, we need to first find out the index of the images to read so
+  ## we can set up defaults for things such as PixelRegion later on.
+  options = struct ("index", 1);  # default image index
+
+  ## Index is the only option that can be defined without the parameter/value
+  ## pair style. When defining it here, the string "all" is invalid though.
+  ## Also, for matlab compatibility, if index is defined both as an option here
+  ## and parameter/value pair, silently ignore the first.
+  if (nargin >= offset + 1 && ! ischar (varargin{offset}))
+    if (! is_valid_index_option (options.index))
+      error ("imread: IDX must be a numeric vector");
+    endif
+    options.index = varargin{offset};
+    offset++;
+  endif
+
+  if (rem (numel (varargin) - offset + 1, 2) != 0)
+    error ("imread: no pair for all arguments (odd number left over)");
+  endif
+
+  ## Check key/value options.
+  indexes = cellfun ("isclass", varargin, "char");
+  indexes(indexes) &= ismember (varargin(indexes), {"frames", "index"});
+  indexes = find (indexes);
+  if (indexes)
+    options.index = varargin{indexes+1};
+    if (! (is_valid_index_option (options.index)) &&
+        ! (ischar (options.index) && strcmpi (options.index, "all")))
+      error ("imread: value for %s must be a vector or the string `all'");
+    endif
+  endif
+
+  try
+    ## Use information from the first image to be read to set defaults.
+    info = __magick_ping__ (fn, options.index(1));
+
+    ## Set default for options.
+    options.region = {1:1:info.rows 1:1:info.columns};
+
+    for idx = offset:2:(numel (varargin) - offset + 1)
+      switch (tolower (varargin{idx}))
+
+        case "pixelregion",
+          options.region = varargin{idx+1};
+          if (! iscell (options.region) || numel (options.region) != 2)
+            error ("imread: value for %s must be a 2 element cell array",
+                   varargin{idx});
+          endif
+          for reg_idx = 1:2
+            if (numel (options.region{reg_idx}) == 3)
+              ## do nothing
+            elseif (numel (options.region{reg_idx}) == 2)
+              options.region{reg_idx}(3) = options.region{reg_idx}(2);
+              options.region{reg_idx}(2) = 1;
+            else
+              error ("imread: range for %s must be a 2 or 3 element vector",
+                     varargin{idx});
+            endif
+            options.region{reg_idx} = floor (options.region{reg_idx}(1)): ...
+                                      floor (options.region{reg_idx}(2)): ...
+                                      floor (options.region{reg_idx}(3));
+          endfor
+          if (options.region{1}(end) > info.rows)
+            error ("imread: end ROWS for PixelRegions option is larger than image height");
+          elseif (options.region{2}(end) > info.columns)
+            error ("imread: end COLS for PixelRegions option is larger than image width");
+          endif
+
+        case "info",
+          ## We ignore this option. This parameter exists in Matlab to
+          ## speed up the reading of multipage TIFF by passing a structure
+          ## that contains information about the start on the file of each
+          ## page.  We can't control it through GraphicsMagic but at least
+          ## we allow to load multiple pages with one command.
+
+        otherwise
+          error ("imread: invalid PARAMETER `%s'", varargin{idx});
+
+      endswitch
+    endfor
+
+    [varargout{1:nargout}] = __magick_read__ (fn, options);
+
+  catch
+    ## If we can't read it with Magick, maybe the image is in Octave's
+    ## native image format.  This is from back before Octave had 'imread'
+    ## and 'imwrite'. Then we had the functions 'loadimage' and 'saveimage'.
+    ##
+    ## This "image format" seems to be any file that can be read with
+    ## load() and contains 2 variables.  The variable named "map" is a
+    ## colormap and must exist whether the image is indexed or not. The
+    ## other variable must be named "img" or "X" for a "normal" or
+    ## indexed image.
+    ##
+    ## FIXME: this has been deprecated for the next major release (3.8 or 4.0).
+    ##        If someone wants to revive this as yet another image format, a
+    ##        separate Octave package can be written for it, that register the
+    ##        format through imformats.
+
+    magick_error = lasterr ();
+
+    img_field = false;
+    x_field   = false;
+    map_field = false;
+
+    try
+      vars = load (fn);
+      if (isstruct (vars))
+        img_field = isfield (vars, "img");
+        x_field   = isfield (vars, "X");
+        map_field = isfield (vars, "map");
+      endif
+    catch
+      error ("imread: invalid image file: %s", magick_error);
+    end_try_catch
+
+    if (map_field && (img_field || x_field))
+      varargout{2} = vars.map;
+      if (img_field)
+        varargout{1} = vars.img;
+      else
+        varargout{1} = vars.X;
+      endif
+      persistent warned = false;
+      if (! warned)
+        warning ("Octave's native image format has been deprecated.");
+        warned = true;
+      endif
+    else
+      error ("imread: invalid Octave image file format");
+    endif
+
+  end_try_catch
+
+endfunction
+
+## Tests if the value passed to the Index or Frames is valid. This option
+## can be defined in two places, but only in one place can it also be the
+## string "all"
+function bool = is_valid_index_option (arg)
+  ## is the index option
+  bool = false;
+  if (isvector (arg) && isnumeric (arg) && isreal (arg))
+    bool = true;
+  endif
+endfunction
+
diff --git a/scripts/image/private/__imwrite__.m b/scripts/image/private/__imwrite__.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/__imwrite__.m
@@ -0,0 +1,119 @@
+## Copyright (C) 2008-2012 John W. Eaton
+## Copyright (C) 2013 Carn Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## This function does all the work of imwrite. It exists here as private
+## function so that imwrite can use other functions if imformats is
+## configured to. It is also needed so that imformats can create a
+## function handle for it.
+
+function __imwrite__ (img, varargin)
+
+  if (nargin < 2 || ! (isnumeric (img) || islogical (img)))
+    print_usage ("imwrite");
+  endif
+
+  [filename, ext, map, param_list] = imwrite_filename (varargin{:});
+
+  if (isempty (img))
+    error ("imwrite: invalid empty image");
+  elseif (issparse (img) || issparse (map))
+    error ("imwrite: sparse images are not supported");
+  endif
+
+  if (rem (numel (param_list), 2) != 0)
+    error ("imwrite: no pair for all arguments (odd number left)");
+  endif
+
+  ## set default for options
+  options = struct ("writemode", "overwrite",
+                    "quality",   75,
+                    "alpha",     cast ([], class (img)));
+
+  for idx = 1:2:numel (param_list)
+
+    switch (tolower (param_list{idx}))
+
+      case "alpha"
+        options.alpha = param_list{idx+1};
+        if (! isnumeric (options.alpha))
+          error ("imwrite: value for %s option must be a numeric matrix",
+                 param_list{idx});
+        elseif (size (options.alpha, 3) != 1)
+          error ("imwrite: 3rd dimension of matrix for %s must be singleton",
+                 param_list{idx});
+        elseif (ndims (options.alpha) > 4 ||
+                any (size (options.alpha)([1 2]) != size (img)([1 2])) ||
+                size (options.alpha, 4) != size (img, 4))
+          error ("imwrite: matrix for %s must have same dimension as image",
+                 param_list{idx});
+        endif
+
+      case "writemode",
+        options.writemode = param_list{idx+1};
+        if (! ischar (options.writemode)
+            || ! any (strcmpi (options.writemode, {"append", "overwrite"})))
+          error ('imwrite: value for %s option must be "append" or "overwrite"',
+                 param_list{idx});
+        endif
+        options.writemode = tolower (options.writemode);
+
+      case "quality",
+        options.quality = param_list{idx+1};
+        if (! isnumeric (options.quality) || ! isscalar (options.quality)
+            || options.quality < 0 || options.quality > 100)
+          error ("imwrite: value for %s option must be a scalar between 0 and 100",
+                 param_list{idx});
+        endif
+        options.quality = round (options.quality);
+
+      otherwise
+        error ("imwrite: invalid PARAMETER `%s'", varargin{idx});
+
+    endswitch
+  endfor
+
+  if (! isempty (map))
+    if (! iscolormap (map))
+      error ("imwrite: invalid MAP for indexed image");
+    elseif (ndims (img) != 2 && ndims (img) != 4)
+      error ("imwrite: indexed image must have 2 or 4 dimensions (found %i)", ndims (img));
+    endif
+    ## If the image is floating point, then we convert it to integer (makes
+    ## it easier in __magick_write__ since it only handles integers. Also,
+    ## if it's floating point, it has an offset of 1
+    if (isfloat (img))
+      if (rows (map) <= 256)
+        img = uint8 (img - 1);
+      else
+        img = uint16 (img - 1);
+      endif
+    endif
+  endif
+
+  if (ndims (img) > 4)
+    error ("imwrite: invalid %d-dimensional image data", ndims (img));
+  elseif (all (size (img, 3) != [1 3 4]))
+    ## 1, 3, or 4 for grayscle, RGB, and CMYK respectively
+    error ("imwrite: IMG 3rd dimension must be 1, 3, or 4");
+  endif
+
+  __magick_write__ (filename, ext, img, map, options);
+
+endfunction
+
diff --git a/scripts/image/private/imageIO.m b/scripts/image/private/imageIO.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/imageIO.m
@@ -0,0 +1,69 @@
+## Copyright (C) 2013 Carn Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## This function simply connects imread and imfinfo() to the function
+## to be used based on their format. It does it by checking the file extension
+## of the file and redirecting to the appropriate function after checking
+## with imformats.
+##
+## First argument is a function handle for the default imageIO function (what
+## to use if the file extension for the image file is not listed by imformats).
+## Second argument is the fieldname in the struct returned by imformats with a
+## function handle for the function to use. Third argument is a cell array, its
+## first element the filename, and the second, an optional file extension to
+## add to filename, if filename alone does not exist. All the others are the
+## original input arguments passed to the original imageIO function which will
+## be passed on to the destination function.
+##
+## No input checking whatsoever is performed. That should be performed by the
+## function calling it.
+
+function varargout = imageIO (core_func, fieldname, filename, varargin)
+
+  ## It should not be this function job to check if the file exists or not.
+  ## However, we need to know the file extension to use with imformats and
+  ## that means we need to know the actual filename that will be used which
+  ## is dependent on whether a file exists.
+  ##
+  ## If a file named filename{1} exists, then that's it, we will use that
+  ## wether it has an extension or not. If it does not exist and we have
+  ## something in filename{2}, then we will consider it the file extension.
+  ## Note the detail that if we find a file using filename{1} only, then we
+  ## should completely ignore filename{2}. It won't even be used by
+  ## imformats() at all, even if filename{1} has no extension to use with
+  ## imformats().
+  if (isscalar (filename) || ! isempty (file_in_path (IMAGE_PATH, filename{1})))
+    [~, ~, ext] = fileparts (filename{1});
+    if (! isempty (ext))
+      ## remove dot from extension
+      ext = ext(2:end);
+    endif
+  else
+    ext = filename{2};
+  endif
+
+  fmt = imformats (ext);
+  ## When there is no match, fmt will be a 1x1 structure with no fields,
+  ## so we can't just use `isempty (fmt)'.
+  if (isempty (fieldnames (fmt)))
+    [varargout{1:nargout}] = core_func (varargin{:});
+  else
+    [varargout{1:nargout}] = fmt.(fieldname) (varargin{:});
+  endif
+endfunction
+
diff --git a/scripts/image/private/imwrite_filename.m b/scripts/image/private/imwrite_filename.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/imwrite_filename.m
@@ -0,0 +1,69 @@
+## Copyright (C) 2013 Carn Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## The input check for imwrite needs to be done twice, once when imwrite
+## is called the first time to find where the filename is, and a second
+## time by __imwrite__ after imformats decides what function to use.
+## Because a user can, and is encouraged to, get a function handle to
+## __imwrite__, the input check is also done there.
+## In addition, the input check for imwrite is not that straightforward
+## in order to support the multiple ways the function can be called,
+## and interpretations of Matlab documentation.
+##
+## Anyway, this will only do the input check until it finds the filename
+## to be used, the only part that imwrite actually needs.
+
+function [filename, ext, cmap, options] = imwrite_filename (varargin)
+
+  ## First, we check if the first argument is a colormap or a filename.
+  cmap = [];
+  if (ischar (varargin{1}))
+    filename_idx = 1;
+  elseif (numel (varargin) >= 2 && iscolormap (varargin{1}) && ischar (varargin{2}))
+    filename_idx = 2;
+    cmap = varargin{1};
+  else
+    error ("imwrite: no FILENAME specified");
+  endif
+  filename = tilde_expand (varargin{filename_idx});
+
+  ## Next, we get the file extension.
+  ## if we have an odd number of leftover arguments, and the next argument
+  ## is a string, we consider it the file extension. Otherwise we will
+  ## extract what we can from the previously found filename.
+  options_idx = filename_idx + 1;
+  if (numel (varargin) > filename_idx &&
+      rem (length (varargin) - filename_idx, 2) != 0 &&
+      ischar (varargin{filename_idx + 1}))
+    ext = varargin{filename_idx + 1};
+    filename = [filename "." ext];
+    options_idx++;
+  else
+    [~, ~, ext] = fileparts (filename);
+    if (! isempty (ext))
+      ## remove dot from extension
+      ext = ext(2:end);
+    endif
+  endif
+
+  ## After all the work finding where the filename was, we might as well
+  ## send the leftovers list (they should be in key value pairs)
+  options = varargin(options_idx:end);
+
+endfunction
+
diff --git a/scripts/image/private/ind2x.m b/scripts/image/private/ind2x.m
--- a/scripts/image/private/ind2x.m
+++ b/scripts/image/private/ind2x.m
@@ -17,18 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## private function for the ind2XXX functions which have a lot of code in common
 
 function [x, map] = ind2x (caller, x, map)
 
   ## Check if X is an indexed image.
-  ## an indexed image is defined has having only 2D, and that's how matlab
-  ## behaves. But we want to support ND images, so we will allow up to 4D
+  ## an indexed image is defined has having only 2D, and that's how Matlab
+  ## behaves.  But we want to support ND images, so we will allow up to 4D
   ## and check that the 3rd is a singleton
   if (all (ndims (x) != [2 4]) || size (x, 3) != 1 || issparse (x) ||
       (isfloat (x) && ! isindex (x)) ||
       ! any (strcmp (class (x), {"uint8", "uint16", "single", "double"})))
     error ("%s: X must be an indexed image", caller);
   endif
 
   ## Check if map is a valid colormap.
@@ -46,14 +46,15 @@ function [x, map] = ind2x (caller, x, ma
       x = single (x);
     endif
     x      += 1;
     maxidx += 1;
   endif
 
   num_colors = rows (map);
   if (num_colors < maxidx)
-    ## Pad with the last color in the map for matlab compatibility
+    ## Pad with the last color in the map for Matlab compatibility
     pad = repmat (map(end,:), maxidx - num_colors, 1);
     map(end+1:maxidx, :) = pad;
   endif
 
 endfunction
+
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -32,46 +32,44 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B}, @var{tol})
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B}, @var{map}, @var{dither_option})
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B}, @var{n}, @var{dither_option})
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B}, @var{tol}, @var{dither_option})
 ## Convert an image in red-green-blue (RGB) color space to an indexed image.
 ##
 ## The input image @var{rgb} must be an N-dimensional RGB image
 ## (@nospell{MxNxO}@dots{}x3 array) where M,N,O@dots{} are the image
-## dimensions, and the
-## final dimension contains the values in the red, green and blue
-## channels.  Alternatively, the red, green and blue color channels can
-## be input as separate arrays @var{R}, @var{G} and  @var{B}.
+## dimensions, and the final dimension contains the values in the red, green
+## and blue channels.  Alternatively, the red, green and blue color channels
+## can be input as separate arrays @var{R}, @var{G}, and @var{B}.
 ##
-## The input @var{map} defines the colormap to be used.  Alternatively,
-## @var{n} or @var{tol} may be used to define the maximum number of
-## colors to use in an automatically generated colormap.  @var{n} is
-## related to @var{tol} by:  @var{n} = (floor (1/@var{tol}) + 1)^3;
-## @var{tol} must be >0 and @leq{}1.
+## The input @var{map} defines the colormap to be used.  Alternatively, @var{n}
+## or @var{tol} may be used to define the maximum number of colors to use in an
+## automatically generated colormap.  @var{n} is related to @var{tol} by:
+## @var{n} = (floor (1/@var{tol}) + 1)^3; where 0 < @var{tol} @leq{} 1.
 ##
 ## @var{dither_option} is a string which enables or disables dithering:
-## 'dither' (default) or 'nodither'.
+## @qcode{"dither"} (default) or @qcode{"nodither"}.
 ##
 ## @seealso{ind2rgb, rgb2hsv, rgb2ntsc}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [x, map] = rgb2ind (varargin)
 
   ## Gather the inputs
   if (nargin < 1 || nargin > 6)
     print_usage ();
   else
 
     ## Test for dither_option, by checking if the final input is a string
-    if ischar (varargin{end})
+    if (ischar (varargin{end}))
       dither_option = varargin{end};
       dither_check  = true;
     else
       dither_option = "dither";
       dither_check  = false;
     endif
 
     ## Read the rgb input
@@ -138,41 +136,41 @@ function [x, map] = rgb2ind (varargin)
       map = reshape (map, size (map, 1), 1, 3);
       imwrite (map, fnmap, "tiff");
       optionstr = sprintf ("-map %s", fnmap);
       
     endif
   
     ## If image is an ND array, convert it to a tiled 2D image
     ## before processing it with Graphicsmagick
-    if numel (sz)>3
+    if (numel (sz) > 3)
      rgb = reshape (rgb, [prod(sz(1:end-2)), sz(end-1), 3]);
-    end
+    endif
 
     ## Prepare the Graphicsmagick dithering option
-    if strcmp (dither_option, "nodither")
+    if (strcmp (dither_option, "nodither"))
       ditherstr = "+dither";
-    elseif strcmp (dither_option, "dither")
+    elseif (strcmp (dither_option, "dither"))
       ditherstr = "-dither";
     endif
       
     ## Perform the image processing using Graphicsmagick
     fna = tmpnam;
     fnb = tmpnam;
     imwrite (rgb, fna, "tiff");
     gmstr = sprintf ("gm convert %s %s %s %s", fna, ditherstr, optionstr, fnb);
     system (gmstr);
     rgb = imread (fnb);
     
   endif
 
   ## Conversion of rgb image to x,map
   pr = prod (sz(1:end-1));
   x = zeros (sz(1:end-1));
-  [map,~,x(:)] = unique (reshape(rgb, [pr, 3]), "rows");
+  [map,~,x(:)] = unique (reshape (rgb, [pr, 3]), "rows");
 
   ## a colormap is of class double and values between 0 and 1
   switch (class (rgb))
     case {"single", "double", "logical"}
       ## do nothing, return the same
     case {"uint8", "uint16"}
       map = double (map) / double (intmax (class (rgb)));
     case "int16"
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -93,19 +93,19 @@ function yiq = rgb2ntsc (rgb)
   if (is_image)
     yiq = reshape (yiq, sz);
   endif
 
 endfunction
 
 
 %% Test pure RED, GREEN, BLUE colors
-%assert (rgb2ntsc ([1 0 0]), [.299  .587  .114])
-%assert (rgb2ntsc ([0 1 0]), [.596 -.274 -.322])
-%assert (rgb2ntsc ([1 0 1]), [.211 -.523  .312])
+%!assert (rgb2ntsc ([1 0 0]), [.299  .596  .211])
+%!assert (rgb2ntsc ([0 1 0]), [.587 -.274 -.523])
+%!assert (rgb2ntsc ([0 0 1]), [.114 -.322  .312])
 
 %!test
 %! rgb_map = rand (64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
 
 %!test
 %! rgb_img = rand (64, 64, 3);
 %! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
diff --git a/scripts/image/spinmap.m b/scripts/image/spinmap.m
--- a/scripts/image/spinmap.m
+++ b/scripts/image/spinmap.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} spinmap ()
 ## @deftypefnx {Function File} {} spinmap (@var{t})
 ## @deftypefnx {Function File} {} spinmap (@var{t}, @var{inc})
 ## @deftypefnx {Function File} {} spinmap ("inf")
 ## Cycle the colormap for @var{t} seconds with a color increment of @var{inc}.
 ## Both parameters are optional.  The default cycle time is 5 seconds and the
-## default increment is 2.  If the option "inf" is given then cycle
+## default increment is 2.  If the option @qcode{"inf"} is given then cycle
 ## continuously until @kbd{Control-C} is pressed.
 ##
 ## When rotating the original color 1 becomes color 2, color 2 becomes
 ## color 3, etc.  A positive or negative increment is allowed and a higher
 ## value of @var{inc} will cause faster cycling through the colormap.
 ## @seealso{colormap}
 ## @end deftypefn
 
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -31,8 +31,9 @@ function beep ()
   endif
 
   puts ("\a");
 
 endfunction
 
 
 %!error (beep (1))
+
diff --git a/scripts/io/csvwrite.m b/scripts/io/csvwrite.m
--- a/scripts/io/csvwrite.m
+++ b/scripts/io/csvwrite.m
@@ -36,19 +36,20 @@ function csvwrite (filename, x, varargin
 endfunction
 
 
 %!shared fname
 %! fname = tmpnam ();
 
 %!test
 %! csvwrite (fname, magic (3));
-%! assert (csvread (fname), magic (3));
+%! data = csvread (fname);
 %! unlink (fname);
+%! assert (data, magic (3));
 
 %!test
 %! csvwrite (fname, magic (3), "precision", "%2.1f", "newline", "unix");
 %! fid = fopen (fname, "rt");
 %! txt = char (fread (fid,Inf,'char')');
 %! fclose (fid);
+%! unlink (fname);
 %! assert (txt, "8.0,1.0,6.0\n3.0,5.0,7.0\n4.0,9.0,2.0\n");
-%! unlink (fname);
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -30,42 +30,42 @@
 ## values on a row.
 ##
 ## The value of @var{r} specifies the number of delimiter-only lines to
 ## add to the start of the file.
 ##
 ## The value of @var{c} specifies the number of delimiters to prepend to
 ## each line of data.
 ##
-## If the argument @code{"-append"} is given, append to the end of
+## If the argument @qcode{"-append"} is given, append to the end of
 ## @var{file}.
 ##
 ## In addition, the following keyword value pairs may appear at the end
 ## of the argument list:
 ##
 ## @table @asis
-## @item "append"
-## Either @samp{"on"} or @samp{"off"}.  See @samp{"-append"} above.
+## @item @qcode{"append"}
+## Either @qcode{"on"} or @qcode{"off"}.  See @qcode{"-append"} above.
 ##
-## @item "delimiter"
+## @item @qcode{"delimiter"}
 ## See @var{delim} above.
 ##
-## @item "newline"
+## @item @qcode{"newline"}
 ## The character(s) to use to separate each row.  Three special cases
-## exist for this option.  @samp{"unix"} is changed into "\n",
-## @samp{"pc"} is changed into "\r\n", and @samp{"mac"} is changed
-## into "\r".  Other values for this option are kept as is.
+## exist for this option.  @qcode{"unix"} is changed into @qcode{"\n"},
+## @qcode{"pc"} is changed into @qcode{"\r\n"}, and @qcode{"mac"} is changed
+## into @qcode{"\r"}.  Other values for this option are kept as is.
 ##
-## @item "roffset"
+## @item @qcode{"roffset"}
 ## See @var{r} above.
 ##
-## @item "coffset"
+## @item @qcode{"coffset"}
 ## See @var{c} above.
 ##
-## @item "precision"
+## @item @qcode{"precision"}
 ## The precision to use when writing the file.  It can either be a
 ## format string (as used by fprintf) or a number of significant digits.
 ## @end table
 ##
 ## @example
 ## dlmwrite ("file.csv", reshape (1:16, 4, 4));
 ## @end example
 ##
@@ -146,16 +146,21 @@ function dlmwrite (file, M, varargin)
       elseif (i == 3)
         c = varargin{i};
       else
         print_usage ();
       endif
     endif
   endwhile
 
+  ## Expand '\t' to TAB for Matlab compatibility
+  if (strcmp (delim, '\t'))
+    delim = "\t";
+  endif
+
   if (ischar (file))
     [fid, msg] = fopen (file, opentype);
   elseif (isscalar (file) && isnumeric (file))
     [fid, msg] = deal (file, "invalid file number");
   else
     error ("dlmwrite: FILE must be a filename string or numeric FID");
   endif
 
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -48,16 +48,16 @@ endfunction
 
 %!test
 %! cstr = {"Hello World", "The answer is 42", "Goodbye World"};
 %! fname = tmpnam ();
 %! fid = fopen (fname, "w");
 %! fprintf (fid, "%s\n", cstr{:});
 %! fclose (fid);
 %! str = fileread (fname);
+%! unlink (fname);
 %! assert (str, [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
-%! unlink (fname);
 
 %% Test input validation
 %!error fileread ()
 %!error fileread (1, 2)
 %!error <FILENAME argument must be a string> fileread (1)
 
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -17,40 +17,39 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{A} =} importdata (@var{fname})
 ## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter})
 ## @deftypefnx {Function File} {@var{A} =} importdata (@var{fname}, @var{delimiter}, @var{header_rows})
 ## @deftypefnx {Function File} {[@var{A}, @var{delimiter}] =} importdata (@dots{})
 ## @deftypefnx {Function File} {[@var{A}, @var{delimiter}, @var{header_rows}] =} importdata (@dots{})
-## Importing data from file.
-##
-## Importing the contents of file @var{fname} into workspace.
+## Import data from the file @var{fname}.
 ##
 ## Input parameters:
 ##
 ## @itemize
 ## @item @var{fname}
-## The file name for the file to import.
+## The name of the file containing data.
 ## 
 ## @item @var{delimiter}
 ## The character separating columns of data.  Use @code{\t} for tab.
-## (Only valid for ascii files)
+## (Only valid for ASCII files)
 ##
 ## @item @var{header_rows}
-## Number of header rows before the data begins.  (Only valid for ascii files)
+## The number of header rows before the data begins.  (Only valid for ASCII
+## files)
 ## @end itemize
 ##
 ## Different file types are supported:
 ##
 ## @itemize
 ## @item ASCII table
 ##
-## Importing ASCII table using the specified number of header rows and
+## Import ASCII table using the specified number of header rows and
 ## the specified delimiter.
 ##
 ## @item Image file
 ##
 ## @item @sc{matlab} file
 ##
 ## @item Spreadsheet files (depending on external software)
 ##
@@ -58,392 +57,453 @@
 ##
 ## @end itemize
 ##
 ## @seealso{textscan, dlmread, csvread, load}
 ## @end deftypefn
 
 ## Author: Erik Kjellson <erikiiofph7@users.sourceforge.net>
 
-function [output, delimiter, header_rows] = importdata (varargin)
+function [output, delimiter, header_rows] = importdata (fname, delimiter = "", header_rows = -1)
 
-  ## Default values
-  fname   = "";
-  delimiter  = "";
-  header_rows = -1;
-
-  ##########
-
-  ## Check input arguments
-
-  if (nargin < 1)
+  if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  fname = varargin{1};
-  ## Check that the file name really is a string
   if (! ischar (fname))
-    error ("importdata: file name needs to be a string");
-  endif
-  if ( strcmpi (fname, "-pastespecial"))
+    error ("importdata: FNAME must be a string");
+  elseif (strcmpi (fname, "-pastespecial"))
     error ("importdata: option -pastespecial not implemented");
   endif
 
   if (nargin > 1)
-    delimiter = varargin{2};
-    ## Check that the delimiter really is a string
-    if (!ischar (delimiter))
-      error("importdata: delimiter needs to be a character");
+    if (! ischar (delimiter)
+        || (length (delimiter) > 1 && ! strcmp (delimiter, '\t')))
+      error("importdata: DELIMITER must be a single character");
     endif
-    if (length (delimiter) > 1 && !strcmpi (delimiter, "\\t"))
-      error("importdata: delimiter cannot be longer than 1 character");
-    endif
-    if (strcmpi (delimiter, "\\"))
-      delimiter = "\\\\";
+    if (strcmp (delimiter, '\t'))
+      delimiter = "\t";
     endif
   endif
 
   if (nargin > 2)
-    header_rows = varargin{3};
-    if (!isnumeric (header_rows) || header_rows < 0)
-      error ("importdata: number of header rows needs to be an integer number >= 0");
+    if (! isnumeric (header_rows) || header_rows < 0
+        || header_rows != fix (header_rows))
+      error ("importdata: HEADER_ROWS must be an integer >= 0");
     endif
   endif
 
-  if (nargin > 3)
-    error ("importdata: too many input arguments");
-  endif
-
-  ##########
-
   ## Check file format
   ## Get the extension from the file name.
-  [d n fileExt v] = fileparts (fname);
-  ## Make sure file extension is in lower case.
-  fileExt = lower (fileExt);
+  [~, ~, ext, ~] = fileparts (fname);
+  ext = lower (ext);
 
-  switch fileExt
-    case {".au", ".snd"}
-      error ("importdata: not implemented for file format %s", fileExt);
-    case ".avi"
-      error ("importdata: not implemented for file format %s", fileExt);
-    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", \
-          ".pbm", ".pcx", ".pgm", ".png", ".pnm", ".ppm", ".ras", \
-          ".tif", ".tiff", ".xwd"}
-      delimiter  = NaN;
+  switch (ext)
+    case {".au", ".snd", ".flac", ".ogg"}
+      error ("importdata: not implemented for file format %s", ext);
+    case {".avi", ".mj2", ".mpg", ".asf", ".asx", ".wmv", ".mp4", ".m4v", ...
+          ".mov"} 
+      error ("importdata: not implemented for file format %s", ext);
+    case {".bmp", ".cur", ".gif", ".hdf", ".ico", ".jpe", ".jpeg", ".jpg", ...
+          ".jp2", ".jpf", ".jpx", ".j2c", ".j2k", ".pbm", ".pcx", ".pgm", ...
+          ".png", ".pnm", ".ppm", ".ras", ".tif", ".tiff", ".xwd"}
+      delimiter = NaN;
       header_rows = 0;
       [output.cdata, output.colormap, output.alpha] = imread (fname);
     case ".mat"
-      delimiter  = NaN;
+      delimiter = NaN;
       header_rows = 0;
       output = load (fname);
-    case {".wk1", ".xls", ".xlsx", ".dbf", ".pxl"}
+    case {".xls", ".xlsx", ".wk1", ".dbf", ".pxl"}
       ## If there's no Excel file support simply fall back to unimplemented.m
       output = xlsread (fname);
     case {".ods", ".sxc", ".fods", ".uos", ".xml"}
       ## unimplemented.m only knows ML functions; odsread isn't one but is in OF
       try
         output = odsread (fname);
       catch
         ## Fall back to unimplemented.m.
         output = xlsread (fname);
       end_try_catch
     case {".wav", ".wave"}
-      delimiter  = NaN;
+      delimiter = NaN;
       header_rows = 0;
       [output.data, output.fs] = wavread (fname);
     otherwise
-      ## Assume the file is in ascii format.
-      [output, delimiter, header_rows]  = \
+      ## Assume the file is in ASCII format.
+      [output, delimiter, header_rows]  = ...
           importdata_ascii (fname, delimiter, header_rows);
   endswitch
 
   ## If there are any empty fields in the output structure, then remove them
-  if (isstruct (output) && length (output) == 1)
+  if (isstruct (output) && numel (output) == 1)
     fields = fieldnames (output);
     for i=1:length (fields)
-      if (isempty (getfield (output, fields{i})))
+      if (isempty (output.(fields{i})))
         output = rmfield (output, fields{i});
       endif
     endfor
 
     ## If only one field is left, replace the structure with the field,
-    ## i.e. output = output.onlyFieldLeft
+    ## i.e., output = output.onlyFieldLeft
 
     ## Update the list of fields
     fields = fieldnames (output);
-    if (length (fields) == 1)
-      output = getfield (output, fields{1});
+    if (numel (fields) == 1)
+      output = output.(fields{1});
     endif
   endif
-endfunction
-
-
-########################################
-
-function [output, delimiter, header_rows] = \
-      importdata_ascii (fname, delimiter, header_rows)
-
-  ## Define the fields in the output structure so that the order will be
-  ## correct.
-
-  output.data       = [];
-  output.textdata   = [];
-  output.rowheaders = [];
-  output.colheaders = [];
-
-  ## Read file into string and count the number of header rows
-  file_content = fileread (fname);
-
-  ## Split the file into rows (using \n and/or \r as delimiters between rows).
-  file_content_rows = regexp (file_content, "\n|\n\r|\r|\r\n", "split");
-
-  ## FIXME: guess delimiter, if it isn't defined
-  if (isempty (delimiter))
-    error ("importdata: Guessing delimiter is not implemented yet, you have to specify it.");
-  endif
 
-  ## FIXME: A more intelligent way to count number of header rows. This
-  ## is needed e.g. when delimiter=' ' and the header contains spaces...
+endfunction
+
+function [output, delimiter, header_rows] = importdata_ascii (fname, delimiter, num_header_rows)
 
-  ## If number of header rows is undefined, then count the number of
-  ## header rows by step through row by row and look for the delimiter.
-  ## Assume that the header can't contain any delimiter.
-  if (header_rows < 0)
-    header_rows = 0;
-    for i=1:length (file_content_rows)
-      if (isempty (regexp(file_content_rows{i}, delimiter, "once")))
-        header_rows++;
-      else
-        ## Data part has begun and therefore no more header rows can be
-        ## found
-        break;
-      endif
-    endfor
-  endif
+  ## Define fields in the output structure so that the order will be correct.
+  output.data       = [];
+  output.textdata   = {};
+  output.rowheaders = {};
+  output.colheaders = {};
 
-  ## Put the header rows in output.textdata.
-  if (header_rows > 0)
-    output.textdata   = file_content_rows (1:header_rows)';
-  endif
-
-  ## If space is the delimiter, then remove spaces in the beginning of
-  ## each data row.
-  if (strcmpi (delimiter, " "))
-    for i=(header_rows+1):length (file_content_rows)
-      ## strtrim does not only remove the leading spaces but also the
-      ## tailing spaces, but that doesn't really matter.
-      file_content_rows{i} = strtrim (file_content_rows{i});
-    endfor
+  [fid, msg] = fopen (fname, "r");
+  if (fid == -1)
+    error (msg);
   endif
 
-  ## Remove empty data rows. Go through them backwards so that you wont
-  ## get out of bounds.
-  for i=length (file_content_rows):-1:(header_rows + 1)
-    if (length (file_content_rows{i}) < 1)
-      file_content_rows = [file_content_rows(1:i-1), \
-                           file_content_rows(i+1:length(file_content_rows))];
-    endif
-  endfor
+  header_rows = 0;
+  header_cols = 0;
+    
+  ## Work through first few rows line by line until a delimiter is found.
+  while (ischar (row = fgetl (fid)))
 
-  ## Count the number of data columns. If there are different number of
-  ## columns, use the greatest value.
-  data_columns = 0;
-  delimiter_pattern = delimiter;
-  ## If space is the delimiter, then multiple spaces should count as ONE
-  ## delimiter. Also ignore leading spaces.
-  if (strcmpi (delimiter, " "))
-    delimiter_pattern = ' +';
-  endif
-  for i=(header_rows+1):length(file_content_rows)
-    data_columns = max (data_columns,
-                        length (regexp (file_content_rows{i},
-                                        delimiter_pattern, "split")));
-  endfor
+    ## If no delimiter determined yet, make a guess.
+    if (isempty (delimiter))
+      ## This pattern can be fooled, but mostly does the job just fine.
+      delim = regexp (row, '[+-\d.eE\*ij ]+([^+-\d.ij])[+-\d.ij]',
+                           'tokens', 'once');
+      if (! isempty (delim))
+        delimiter = delim{1};
+      endif
+    endif
 
-  ## FIXME: Make it behave like Matlab when importing a table where a whole
-  ## column is text only. E.g.
-  ##    abc  12  34
-  ##    def  56  78
-  ## This would give a 3x2 data matrix with the left column = nan(2,1), and 
-  ## the text would end up in textdata.
-  ## In Matlab the data matrix would only be a 2x2 matrix, see example at:
-  ## http://www.mathworks.se/help/matlab/import_export/import-numeric-data-and-header-text-from-a-text-file.html
-
-  ## Go through the data and put it in either output.data or
-  ## output.textdata depending on if it is numeric or not.
-  output.data = NaN (length (file_content_rows) - header_rows, data_columns);
-  for i=(header_rows+1):length(file_content_rows)
-    ## Only use the row if it contains anything other than white-space
-    ## characters.
-    if (any (file_content_rows{i} != " "))
-      row_data = regexp (file_content_rows{i}, delimiter_pattern, "split");
+    if (delimiter == " ")
+      row_entries = regexp (strtrim (row), ' +', 'split');
+    else
+      row_entries = ostrsplit (row, delimiter);
+    endif
+    row_data = str2double (row_entries);
+    if (all (isnan (row_data)) || header_rows < num_header_rows)
+      header_rows++;
+      output.textdata{end+1, 1} = row;
+    else
+      if (! isempty (output.textdata))
+        if (delimiter == " ")
+          output.colheaders = regexp (strtrim (output.textdata{end}),
+                                      ' +', 'split');
+        else
+          output.colheaders = ostrsplit (output.textdata{end}, delimiter);
+        endif
+      endif
+      header_cols = find (! isnan (row_data), 1) - 1;
+      ## The number of header rows and header columns is now known.
+      break;
+    endif
 
-      for j=1:length(row_data)
-        ## Try to convert the column to a number, if it works put it in
-        ## output.data, otherwise in output.textdata
-        if (!isempty (row_data{j}))
-          data_numeric = str2double (row_data{j});
-          if (!isnan (data_numeric))
-            output.data(i-header_rows, j) = data_numeric;
-          else
-            output.textdata{i,j} = row_data{j};
-          endif
-        endif
-      endfor
+  endwhile
+
+  fclose (fid);
 
-    endif
-  endfor
-
-  ## Check wether rowheaders or colheaders should be used
-  if ((header_rows == data_columns) && (size (output.textdata, 2) == 1))
-    output.rowheaders = output.textdata;
-  elseif (size (output.textdata, 2) == data_columns)
-    output.colheaders = output.textdata(end,:);
+  if (row == -1)
+    error ("importdata: Unable to determine delimiter");
+  endif
+  if (num_header_rows >= 0)
+    header_rows = num_header_rows;
   endif
 
-  ## When delimiter = "\\t" convert it to a tab, done for Matlab compatibility.
-  if (strcmp (delimiter, '\t'))
-    delimiter = "\t";
+  ## Now, let the efficient built-in routine do the bulk of the work.
+  if (delimiter == " ")
+    output.data = dlmread (fname, "", header_rows, header_cols,
+                           "emptyvalue", NA);
+  else
+    output.data = dlmread (fname, delimiter, header_rows, header_cols,
+                           "emptyvalue", NA);
+  endif
+
+  ## Go back and correct any individual values that did not convert.
+  na_idx = isna (output.data);
+  if (header_cols > 0)
+    na_idx = [(true (rows (na_idx), header_cols)), na_idx];
+  endif
+  if (any (na_idx(:)))
+
+    file_content = ostrsplit (fileread (fname), "\n");
+
+    na_rows = find (any (na_idx, 2));
+    for ridx = na_rows(:)'
+      row = file_content{ridx+header_rows};
+      if (delimiter == " ")
+        fields = regexp (strtrim (row), ' +', 'split');
+      else
+        fields = ostrsplit (row, delimiter);
+      endif
+      
+      text = fields(na_idx(ridx,:));
+      text = text(! strcmpi (text, "NA"));  #  Remove valid "NA" entries
+      if (! isempty (text))
+        output.textdata(end+1:end+numel (text), 1) = text;
+      endif
+      if (header_cols)
+        output.rowheaders(end+1, :) = fields(1:header_cols);
+      endif
+    endfor
+
+  endif
+
+  ## Final cleanup to satisfy output configuration
+  if (all (cellfun ("isempty", output.textdata)))
+    output = output.data;
+  elseif (! isempty (output.rowheaders) && ! isempty (output.colheaders))
+    output = struct ("data", {output.data}, "textdata", {output.textdata});
   endif
 
 endfunction
 
 
-########################################
-
 %!test
-%! # Comma separated values
+%! ## Comma separated values
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1,-7.2,0\n0.012,6.5,128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, ",");
+%! [a1,d1,h1] = importdata (fn, ",");
+%! [a2,d2,h2] = importdata (fn);
 %! unlink (fn);
-%! assert (a, A);
-%! assert (d, ",");
-%! assert (h, 0);
+%! assert (a1, A);
+%! assert (d1, ",");
+%! assert (h1, 0);
+%! assert (a2, A);
+%! assert (d2, ",");
+%! assert (h2, 0);
 
 %!test
-%! # Tab separated values
+%! ## Tab separated values
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a1,d1,h1] = importdata (fn, "\t");
+%! [a2,d2,h2] = importdata (fn);
+%! unlink (fn);
+%! assert (a1, A);
+%! assert (d1, "\t");
+%! assert (h1, 0);
+%! assert (a2, A);
+%! assert (d2, "\t");
+%! assert (h2, 0);
+
+%!test
+%! ## Space separated values, using multiple spaces to align in columns.
+%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A');
+%! fclose (fid);
+%! [a1,d1,h1] = importdata (fn, " ");
+%! [a2,d2,h2] = importdata (fn);
+%! unlink (fn);
+%! assert (a1, A);
+%! assert (d1, " ");
+%! assert (h1, 0);
+%! assert (a2, A);
+%! assert (d2, " ");
+%! assert (h2, 0);
+
+%!test
+%! ## No separator, 1 column of data only
+%! A = [3.1;-7.2;0;0.012;6.5;128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%f\n", A);
+%! fclose (fid);
+%! [a1,d1,h1] = importdata (fn, "");
+%! [a2,d2,h2] = importdata (fn);
+%! unlink (fn);
+%! assert (a1, A);
+%! assert (d1, "");
+%! assert (h1, 0);
+%! assert (a2, A);
+%! assert (d2, "");
+%! assert (h2, 0);
+
+%!test
+%! ## Header text
+%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
+%! A.textdata = {"This is a header row."; ...
+%!               "this row does not contain any data, but the next one does."};
+%! A.colheaders = A.textdata (2);
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%s\n", A.textdata{:});
+%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, '\t');
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 2);
+
+%!test
+%! ## Column headers, only last row is returned in colheaders
+%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
+%! A.textdata = {"Label1\tLabel2\tLabel3";
+%!               "col 1\tcol 2\tcol 3"};
+%! A.colheaders = {"col 1", "col 2", "col 3"};
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fprintf (fid, "%s\n", A.textdata{:});
+%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, '\t');
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 2);
+
+%!test
+%! ## Row headers
+%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
+%! A.textdata = {"row1"; "row2"};
+%! A.rowheaders = A.textdata;
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "row1\t3.1\t-7.2\t0\nrow2\t0.012\t6.5\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
 %!test
-%! # Space separated values, using multiple spaces to align in columns.
-%! A = [3.1 -7.2 0; 0.012 6.5 128];
+%! ## Row/Column headers and Header Text
+%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
+%! A.textdata = {"This is introductory header text"
+%!               "      col1 col2 col3"
+%!               "row1"
+%!               "row2"};
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
-%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(1,:));
-%! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(2,:));
+%! fprintf (fid, "%s\n", A.textdata{1:2});
+%! fputs (fid, "row1\t3.1\t-7.2\t0\nrow2\t0.012\t6.5\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, " ");
-%! unlink (fn);
-%! assert (a, A);
-%! assert (d, " ");
-%! assert (h, 0);
-
-%!test
-%! # Header
-%! A.data = [3.1 -7.2 0; 0.012 6.5 128];
-%! A.textdata = {"This is a header row."; \
-%!               "this row does not contain any data, but the next one does."};
-%! fn  = tmpnam ();
-%! fid = fopen (fn, "w");
-%! fputs (fid, [A.textdata{1} "\n"]);
-%! fputs (fid, [A.textdata{2} "\n"]);
-%! fputs (fid, "3.1\t-7.2\t0\n0.012\t6.5\t128");
-%! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 2);
 
 %!test
-%! # Ignore empty rows containing only spaces
+%! ## Ignore empty rows containing only spaces
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(1,:));
 %! fputs (fid, "      ");
 %! fprintf (fid, "%10.3f %10.3f %10.3f\n", A(2,:));
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, " ");
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, " ");
 %! assert (h, 0);
 
 %!test
-%! # Exponentials
+%! ## Exponentials
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "+3.1e0\t-72E-1\t0\n12e-3\t6.5\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
 %!test
-%! # Complex numbers
+%! ## Complex numbers
 %! A = [3.1 -7.2 0-3.4i; 0.012 -6.5+7.2i 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1\t-7.2\t0-3.4i\n0.012\t-6.5+7.2i\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
+%!test
+%! ## Exceptional values (Inf, NaN, NA)
+%! A = [3.1 Inf NA; -Inf NaN 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\tInf\tNA\n-Inf\tNaN\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
 %!test
-%! # Missing values
-%! A = [3.1 NaN 0; 0.012 6.5 128];
+%! ## Missing values and Text Values
+%! A.data = [3.1 NA 0; 0.012 NA 128];
+%! A.textdata = {char(zeros(1,0))
+%!               "NO DATA"};
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
-%! fputs (fid, "3.1\t\t0\n0.012\t6.5\t128");
+%! fputs (fid, "3.1\t\t0\n0.012\tNO DATA\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
-%!test
-%! # CRLF for line breaks
+%!#test
+%! ## CRLF for line breaks
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1\t-7.2\t0\r\n0.012\t6.5\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
-%!test
-%! # CR for line breaks
+%!#test
+%! ## CR for line breaks
 %! A = [3.1 -7.2 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1\t-7.2\t0\r0.012\t6.5\t128");
 %! fclose (fid);
-%! [a,d,h] = importdata (fn, "\\t");
+%! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
+%!error importdata ()
+%!error importdata (1,2,3,4)
+%!error <FNAME must be a string> importdata (1)
+%!error <option -pastespecial not implemented> importdata ("-pastespecial")
+%!error <DELIMITER must be a single character> importdata ("foo", 1)
+%!error <DELIMITER must be a single character> importdata ("foo", "ab")
+%!error <HEADER_ROWS must be an integer> importdata ("foo", " ", "1")
+%!error <HEADER_ROWS must be an integer> importdata ("foo", " ", 1.5)
+%!error <not implemented for file format .au> importdata ("foo.au")
+%!error <not implemented for file format .avi> importdata ("foo.avi")
+
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -94,81 +94,81 @@
 ## Read N times @var{nargout} items.  0 (zero) is an acceptable
 ## value for @var{format_repeat}.
 ## @end table
 ##
 ## The behavior of @code{strread} can be changed via property-value
 ## pairs.  The following properties are recognized:
 ##
 ## @table @asis
-## @item "commentstyle"
+## @item @qcode{"commentstyle"}
 ## Parts of @var{str} are considered comments and will be skipped.
 ## @var{value} is the comment style and can be any of the following.
 ##
 ## @itemize
-## @item "shell"
+## @item @qcode{"shell"}
 ## Everything from @code{#} characters to the nearest end-of-line is skipped.
 ##
-## @item "c"
+## @item @qcode{"c"}
 ## Everything between @code{/*} and @code{*/} is skipped.
 ##
-## @item "c++"
+## @item @qcode{"c++"}
 ## Everything from @code{//} characters to the nearest end-of-line is skipped.
 ##
-## @item "matlab"
+## @item @qcode{"matlab"}
 ## Everything from @code{%} characters to the nearest end-of-line is skipped.
 ##
 ## @item user-supplied.  Two options:
 ## (1) One string, or 1x1 cell string: Skip everything to the right of it;
 ## (2) 2x1 cell string array: Everything between the left and right strings
 ## is skipped.
 ## @end itemize
 ##
-## @item "delimiter"
+## @item @qcode{"delimiter"}
 ## Any character in @var{value} will be used to split @var{str} into words
 ## (default value = any whitespace).
 ##
-## @item "emptyvalue":
+## @item @qcode{"emptyvalue"}:
 ## Value to return for empty numeric values in non-whitespace delimited data.
 ## The default is NaN@.  When the data type does not support NaN
 ## (int32 for example), then default is zero.
 ##
-## @item "multipledelimsasone"
+## @item @qcode{"multipledelimsasone"}
 ## Treat a series of consecutive delimiters, without whitespace in between,
 ## as a single delimiter.  Consecutive delimiter series need not be vertically
-## "aligned".
+## @qcode{"aligned"}.
 ##
-## @item "treatasempty"
+## @item @qcode{"treatasempty"}
 ## Treat single occurrences (surrounded by delimiters or whitespace) of the
 ## string(s) in @var{value} as missing values.
 ##
-## @item "returnonerror"
+## @item @qcode{"returnonerror"}
 ## If @var{value} true (1, default), ignore read errors and return normally.
 ## If false (0), return an error.
 ##
-## @item "whitespace"
+## @item @qcode{"whitespace"}
 ## Any character in @var{value} will be interpreted as whitespace and
 ## trimmed; the string defining whitespace must be enclosed in double
 ## quotes for proper processing of special characters like \t.
-## The default value for whitespace = " \b\r\n\t" (note the space).
-## Unless whitespace is set to '' (empty) AND at least one "%s" format
+## The default value for whitespace = @qcode{" \b\r\n\t"} (note the space).
+## Unless whitespace is set to '' (empty) AND at least one @qcode{"%s"} format
 ## conversion specifier is supplied, a space is always part of whitespace.
 ##
 ## @end table
 ##
 ## When the number of words in @var{str} doesn't match an exact multiple
 ## of the number of format conversion specifiers, strread's behavior
 ## depends on the last character of @var{str}:
 ##
 ## @table @asis
-## @item last character = "\n"
+## @item last character = @qcode{"\n"}
 ## Data columns are padded with empty fields or Nan so that all columns
 ## have equal length 
 ##
-## @item last character is not "\n"
+## @item last character is not @qcode{"\n"}
 ## Data columns are not padded; strread returns columns of unequal length
 ##
 ## @end table
 ##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
@@ -474,17 +474,17 @@ function varargout = strread (str, forma
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
       ## and matching fmt_words to words until the fmt_words array is exhausted.
       ## iwrd: ptr to current analyzed word; iwrdp: ptr to pos before analyzed char
       iwrd = 1; iwrdp = 0; iwrdl = length (words{1});
       fwptr = zeros (1, numel (fmt_words));
       ii = 1;
-      while ii <= numel (fmt_words)
+      while (ii <= numel (fmt_words))
 
         nxt_wrd = 0;
         ## Keep track of which words nr. every fmt_words{} is (starts) in.
         fwptr(ii) = iwrd;
 
         if (idf(ii))
           ## Literal expected
           if (isempty (strfind (fmt_words{ii}, words(iwrd))))
@@ -674,17 +674,17 @@ function varargout = strread (str, forma
         lastline = ...
           min (num_words_per_line * format_repeat_count + m - 1, numel (words));
         data = words(m:num_words_per_line:lastline);
       endif
 
       ## Map to format
       ## FIXME - add support for formats like "<%s>", "%[a-zA-Z]"
       ##         Someone with regexp experience is needed.
-      switch fmt_words{m}(1:min (2, length (fmt_words{m})))
+      switch (fmt_words{m}(1:min (2, length (fmt_words{m}))))
         case "%s"
           if (pad_out)
             data(end+1:num_lines) = {""};
           endif
           varargout{k} = data';
           k++;
         case {"%d", "%u", "%f", "%n"}
           n = cellfun ("isempty", data);
@@ -701,17 +701,17 @@ function varargout = strread (str, forma
           endif
           varargout{k} = data.';
           k++;
         case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
           sw = regexp (fmt_words{m}, '\d', "once");
           ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
           nfmt = ostrsplit (fmt_words{m}(2:ew), ".");
           swidth = str2double (nfmt{1});
-          switch fmt_words{m}(ew+1)
+          switch (fmt_words{m}(ew+1))
             case {"d", "u", "f", "n"}
               n = cellfun ("isempty", data);
               ### FIXME - erroneously formatted data lead to NaN, not an error
               ###         => ReturnOnError can't be implemented for numeric data
               data = str2double (strtrunc (data, swidth));
               data(n) = numeric_fill_value;
               if (pad_out)
                 data(end+1:num_lines) = numeric_fill_value;
@@ -835,24 +835,24 @@ endfunction
 %! assert (c{1}, {"Tom"; "Dick"; "Harry"})
 %! assert (c{2}, [100; 90; 80])
 
 %!test
 %! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
 %! assert (a, {"a b c"; "d e"; ""; "f"});
 
 %!test
-%! # Bug #33536
+%! ## Bug #33536
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
 %! assert (a{1}, "1");
 %! assert (b{1}, "");
 %! assert (c{1}, "2");
 
 %!test
-%! # Bug #33536
+%! ## Bug #33536
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
 %! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
 %! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);
@@ -863,34 +863,34 @@ endfunction
 %! assert (d, NaN);
 
 %!test
 %! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
 %! assert (c, [3; NaN]);
 %! assert (d, int32 ([0; 0]));
 
 %!test
-%! # Default format (= %f)
+%! ## Default format (= %f)
 %1 [a, b, c] = strread ("0.12 0.234 0.3567");
 %1 assert (a, 0.12);
 %1 assert (b, 0.234);
 %1 assert (c, 0.3567);
 
 %!test
 %! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
 %1 assert (a, [0.41; 3.57]);
 
 %!test
-%! # TreatAsEmpty
+%! ## TreatAsEmpty
 %! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
-%! # No delimiters at all besides EOL.  Plain reading numbers & strings
+%! ## No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
 %! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
@@ -953,24 +953,24 @@ endfunction
 %! assert (b, NaN);
 
 %!test
 %! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
 %! assert (a, NaN);
 %! assert (b, NaN);
 
 %!test
-%! # Bug #35999
+%! ## Bug #35999
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
-%% bug #37023
 %!test
+%! ## bug #37023
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
 %% Test for no output arg (interactive use)
 %!test
 %! assert (strread (",2,,4\n5,,7,", "", "delimiter", ","), [NaN; 2; NaN; 4; 5; NaN; 7]);
 
@@ -989,8 +989,9 @@ endfunction
 %!error <format specifiers are not supported> strread ("a", "%f64")
 %!error <format specifiers are not supported> strread ("a", "%*f64 %s")
 %!error <format specifiers are not supported> strread ("a", "%u32")
 %!error <format specifiers are not supported> strread ("a", "%*u32 %d")
 
 %% Illegal format specifiers
 %!test
 %!error <unknown format specifier> strread ("1.0", "%z")
+
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -27,23 +27,23 @@
 ## The file @var{filename} is read and parsed according to @var{format}.  The
 ## function behaves like @code{strread} except it works by parsing a file
 ## instead of a string.  See the documentation of @code{strread} for details.
 ##
 ## In addition to the options supported by @code{strread}, this function
 ## supports two more:
 ##
 ## @itemize
-## @item "headerlines":
+## @item @qcode{"headerlines"}:
 ## The first @var{value} number of lines of @var{filename} are skipped.
 ##
-## @item "endofline":
-## Specify a single character or "\r\n".  If no value is given, it will be
-## inferred from the file.  If set to "" (empty string) EOLs are ignored as
-## delimiters.
+## @item @qcode{"endofline"}:
+## Specify a single character or @qcode{"\r\n"}.  If no value is given, it
+## will be inferred from the file.  If set to "" (empty string) EOLs are
+## ignored as delimiters.
 ## @end itemize
 ##
 ## The optional input @var{n} specifies the number of data lines to read; in
 ## this sense it differs slightly from the format repeat count in strread.
 ##
 ## If the format string is empty (not: omitted) and the file contains only
 ## numeric data (excluding headerlines), textread will return a rectangular
 ## matrix with the number of columns matching the number of numeric fields on
@@ -68,17 +68,17 @@ function varargout = textread (filename,
   if (! isempty (varargin) && isnumeric (varargin{1}))
     nlines = varargin{1};
   else
     nlines = Inf;
   endif
   if (nlines < 1)
     printf ("textread: N = 0, no data read\n");
     varargout = cell (1, nargout);
-    return
+    return;
   endif
 
   ## Read file
   fid = fopen (filename, "r");
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
   endif
 
@@ -214,16 +214,17 @@ function varargout = textread (filename,
     endif
     varargout{1} = reshape (varargout{1}, ncols, nrows)';
     ## ML replaces empty values with NaNs
     varargout{1}(find (isnan (varargout{1}))) = 0;
   endif
 
 endfunction
 
+
 %!test
 %! f = tmpnam ();
 %! d = rand (5, 3);
 %! dlmwrite (f, d, "precision", "%5.2f");
 %! [a, b, c] = textread (f, "%f %f %f", "delimiter", ",", "headerlines", 3);
 %! unlink (f);
 %! assert (a, d(4:5, 1), 1e-2);
 %! assert (b, d(4:5, 2), 1e-2);
@@ -310,8 +311,9 @@ endfunction
 %% Test input validation
 %!error textread ()
 %!error textread (1)
 %!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
 %!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines")
 %!error <missing or illegal value for> textread (file_in_loadpath ("textread.m"), "", "headerlines", 'hh')
 %!error <character value required for> textread (file_in_loadpath ("textread.m"), "%s", "endofline", true)
+
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -29,30 +29,31 @@
 ## parsed according to @var{format}.  The function behaves like @code{strread}
 ## except it can also read from file instead of a string.  See the documentation
 ## of @code{strread} for details.
 ##
 ## In addition to the options supported by @code{strread}, this function
 ## supports a few more:
 ##
 ## @itemize
-## @item "collectoutput":
+## @item @qcode{"collectoutput"}:
 ## A value of 1 or true instructs textscan to concatenate consecutive columns
 ## of the same class in the output cell array.  A value of 0 or false (default)
 ## leaves output in distinct columns.
 ##
-## @item "endofline":
-## Specify "\r", "\n" or "\r\n" (for CR, LF, or CRLF).  If no value is given,
-## it will be inferred from the file.  If set to "" (empty string) EOLs are
-## ignored as delimiters and added to whitespace.
+## @item @qcode{"endofline"}:
+## Specify @qcode{"\r"}, @qcode{"\n"} or @qcode{"\r\n"} (for CR, LF, or
+## CRLF).  If no value is given, it will be inferred from the file.  If set
+## to "" (empty string) EOLs are ignored as delimiters and added to
+## whitespace.
 ##
-## @item "headerlines":
+## @item @qcode{"headerlines"}:
 ## The first @var{value} number of lines of @var{fid} are skipped.
 ##
-## @item "returnonerror":
+## @item @qcode{"returnonerror"}:
 ## If set to numerical 1 or true (default), return normally when read errors
 ## have been encountered.  If set to 0 or false, return an error and no data.
 ## As the string or file is read by columns rather than by rows, and because
 ## textscan is fairly forgiving as regards read errors, setting this option
 ## may have little or no actual effect.
 ## @end itemize
 ##
 ## When reading from a character string, optional input argument @var{n}
@@ -74,18 +75,18 @@
 ##
 ## @seealso{dlmread, fscanf, load, strread, textread}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function [C, position] = textscan (fid, format = "%f", varargin)
 
-  BUFLENGTH = 4096;               ## Read buffer
-  emptfmt = 0;                    ## Signals deliberately empty format string
+  BUFLENGTH = 4096;               # Read buffer
+  emptfmt = 0;                    # Signals deliberately empty format string
 
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
 
   if (isempty (format))
     emptfmt = 1;
@@ -107,18 +108,17 @@ function [C, position] = textscan (fid, 
   args = varargin;
   if (nargin > 2 && isnumeric (args{1}))
     nlines = args{1};
   else
     nlines = Inf;
   endif
   if (nlines < 1)
     printf ("textscan: N = 0, no data read\n");
-    return
-  endif
+    return;  endif
 
   if (! any (strcmpi (args, "emptyvalue")))
     ## Matlab returns NaNs for missing values
     args(end+1:end+2) = {'emptyvalue', NaN};
   endif
 
   ## Check default parameter values that differ for strread & textread
 
@@ -271,17 +271,17 @@ function [C, position] = textscan (fid, 
         endif
       endwhile
       ## OK, found EOL delimiting last requested line. Compute ptr (incl. EOL)
       if (isempty (eoi))
         printf ("textscan: format repeat count specified but no endofline found\n");
         data_size = nblks * BUFLENGTH + count;
       else
         ## Compute data size to read incl complete EOL
-        data_size = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi) \
+        data_size = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi) ...
                     + l_eol_char - 1;
       endif
       fseek (fid, st_pos, "bof");
       str = fscanf (fid, "%c", data_size);
     else
       fseek (fid, st_pos, "bof");
       str = fread (fid, "char=>char").';
     endif
@@ -434,17 +434,17 @@ endfunction
 %! assert (c{:}, {"L1"; "L2"});
 
 %% Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
 %! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8 (c{:}{:}), int8 ([ 76,  49,  10,  76,  50 ]));
 
 %!test
-%! # No delimiters at all besides EOL.  Skip fields, even empty fields
+%! ## No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
 %!test
 %% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
@@ -655,8 +655,9 @@ endfunction
 %! fseek (fid, 0, "bof");
 %! msg1 = "textscan: character value required for EndOfLine";
 %! try
 %! A = textscan (fid, "%f", "EndOfLine", 33);
 %! end_try_catch;
 %! fclose (fid);
 %! unlink (f);
 %! assert (msg1, lasterr);
+
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -37,23 +37,23 @@
 ## @item If two output values@var{dpath} and @var{spath} are 
 ## requested, the first variable will contain the dynamic classpath and
 ## the second will be contain the static classpath.
 ## @end itemize
 ## 
 ## If called with a single input parameter @var{what}:
 ##
 ## @table @asis
-## @item "-dynamic"
+## @item @qcode{"-dynamic"}
 ## Return the dynamic classpath.
 ##
-## @item "-static"
+## @item @qcode{"-static"}
 ## Return the static classpath.
 ##
-## @item "-all"
+## @item @qcode{"-all"}
 ## Return both the static and dynamic classpath in a single cellstr.
 ## @end table
 ## @seealso{javaaddpath, javarmpath}
 ## @end deftypefn
 
 function varargout = javaclasspath (which)
 
   ## dynamic classpath
diff --git a/scripts/java/usejava.m b/scripts/java/usejava.m
--- a/scripts/java/usejava.m
+++ b/scripts/java/usejava.m
@@ -19,35 +19,35 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} usejava (@var{feature})
 ## Return true if the Java element @var{feature} is available.
 ##
 ## Possible features are:
 ##
 ## @table @asis
-## @item "awt"
+## @item @qcode{"awt"}
 ## Abstract Window Toolkit for GUIs.
 ##
-## @item "desktop"
+## @item @qcode{"desktop"}
 ## Interactive desktop is running.
 ##
-## @item "jvm"
+## @item @qcode{"jvm"}
 ## Java Virtual Machine.
 ##
-## @item "swing"
+## @item @qcode{"swing"}
 ## Swing components for lightweight GUIs.
 ## @end table
 ##
 ## @code{usejava} determines if specific Java features are available in an
 ## Octave session.  This function is provided for scripts which may alter
-## their behavior based on the availability of Java.  The feature "desktop"
-## always returns @code{false} as Octave has no Java-based desktop.  Other
-## features may be available if Octave was compiled with the Java Interface
-## and Java is installed.
+## their behavior based on the availability of Java.  The feature
+## @qcode{"desktop"} always returns @code{false} as Octave has no Java-based
+## desktop.  Other features may be available if Octave was compiled with the
+## Java Interface and Java is installed.
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 ## Author: Philip Nienhuis <prnienhuis@users.sf.net>
 
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -16,65 +16,67 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} cond (@var{A})
 ## @deftypefnx {Function File} {} cond (@var{A}, @var{p})
 ## Compute the @var{p}-norm condition number of a matrix.
 ##
-## @code{cond (@var{A})} is ## defined as
+## @code{cond (@var{A})} is defined as
 ## @tex
 ## $ {\parallel A \parallel_p * \parallel A^{-1} \parallel_p .} $
 ## @end tex
 ## @ifnottex
 ## @code{norm (@var{A}, @var{p}) * norm (inv (@var{A}), @var{p})}.
 ## @end ifnottex
 ##
-## By default @code{@var{p} = 2} is used which implies a (relatively slow)
+## By default, @code{@var{p} = 2} is used which implies a (relatively slow)
 ## singular value decomposition.  Other possible selections are
 ## @code{@var{p} = 1, Inf, "fro"} which are generally faster.  See
 ## @code{norm} for a full discussion of possible @var{p} values.
+##
+## The condition number of a matrix quantifies the sensitivity of the matrix
+## inversion operation when small changes are made to matrix elements.  Ideally
+## the condition number will be close to 1.  When the number is large this
+## indicates small changes (such as underflow or round-off error) will produce
+## large changes in the resulting output.  In such cases the solution results
+## from numerical computing are not likely to be accurate.
 ## @seealso{condest, rcond, norm, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = cond (A, p)
+function retval = cond (A, p = 2)
 
-  if (nargin && nargin < 3)
-    if (ndims (A) > 2)
-      error ("cond: only valid on 2-D objects");
-    endif
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
 
-    if (nargin <2)
-      p = 2;
-    endif
+  if (ndims (A) > 2)
+    error ("cond: A must be a 2-D matrix");
+  endif
 
-    if (! ischar (p) && p == 2)
-      [nr, nc] = size (A);
-      if (nr == 0 || nc == 0)
-        retval = 0.0;
-      elseif (any (any (isinf (A) | isnan (A))))
-        error ("cond: argument must not contain Inf or NaN values");
+  if (p == 2)
+    if (isempty (A))
+      retval = 0.0;
+    elseif (any (! isfinite (A(:))))
+      error ("cond: A must not contain Inf or NaN values");
+    else
+      sigma   = svd (A);
+      sigma_1 = sigma(1);
+      sigma_n = sigma(end);
+      if (sigma_1 == 0 || sigma_n == 0)
+        retval = Inf;
       else
-        sigma   = svd (A);
-        sigma_1 = sigma(1);
-        sigma_n = sigma(end);
-        if (sigma_1 == 0 || sigma_n == 0)
-          retval = Inf;
-        else
-          retval = sigma_1 / sigma_n;
-        endif
+        retval = sigma_1 / sigma_n;
       endif
-    else
-      retval = norm (A, p) * norm (inv (A), p);
     endif
   else
-    print_usage ();
+    retval = norm (A, p) * norm (inv (A), p);
   endif
 
 endfunction
 
 
 %!test
 %! y = [7, 2, 3; 1, 3, 4; 6, 4, 5];
 %! tol = 1e-6;
@@ -84,9 +86,12 @@ endfunction
 %! endfor
 %! assert (rcondition, [0.017460, 0.019597, 0.018714, 0.012022, 0.012022], tol);
 
 %!assert (cond ([1, 2; 2, 1]), 3, sqrt (eps))
 %!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16)
 
 %!error cond ()
 %!error cond (1, 2, 3)
+%!error <A must be a 2-D matrix> cond (ones (1,3,3))
+%!error <A must not contain Inf or NaN value> cond ([1, 2;Inf 4])
+%!error <A must not contain Inf or NaN value> cond ([1, 2;NaN 4])
 
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -78,20 +78,20 @@ function r = expm (A)
   endif
 
   if (! ismatrix (A) || ! issquare (A))
     error ("expm: A must be a square matrix");
   endif
 
   if (isscalar (A))
     r = exp (A);
-    return
+    return;
   elseif (strfind (typeinfo (A), "diagonal matrix"))
     r = diag (exp (diag (A)));
-    return
+    return;
   endif
 
   n = rows (A);
   ## Trace reduction.
   A(A == -Inf) = -realmax;
   trshift = trace (A) / length (A);
   if (trshift > 0)
     A -= trshift*eye (n);
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -23,18 +23,18 @@
 ## @example
 ## [v a*v a^2*v @dots{} a^(k+1)*v]
 ## @end example
 ##
 ## @noindent
 ## Using Householder reflections to guard against loss of orthogonality.
 ##
 ## If @var{V} is a vector, then @var{h} contains the Hessenberg matrix
-## such that @nospell{@xcode{a*u == u*h+rk*ek'}}, in which @code{rk =
-## a*u(:,k)-u*h(:,k)}, and @nospell{@xcode{ek'}} is the vector
+## such that @nospell{@tcode{a*u == u*h+rk*ek'}}, in which @code{rk =
+## a*u(:,k)-u*h(:,k)}, and @nospell{@tcode{ek'}} is the vector
 ## @code{[0, 0, @dots{}, 1]} of length @code{k}.  Otherwise, @var{h} is
 ## meaningless.
 ##
 ## If @var{V} is a vector and @var{k} is greater than
 ## @code{length (A) - 1}, then @var{h} contains the Hessenberg matrix such
 ## that @code{a*u == u*h}.
 ##
 ## The value of @var{nu} is the dimension of the span of the Krylov
@@ -239,8 +239,9 @@ endfunction
 
 
 function [a1, b1] = swap (a, b)
 
   a1 = b;
   b1 = a;
 
 endfunction
+
diff --git a/scripts/linear-algebra/linsolve.m b/scripts/linear-algebra/linsolve.m
new file mode 100644
--- /dev/null
+++ b/scripts/linear-algebra/linsolve.m
@@ -0,0 +1,135 @@
+## Copyright (C) 2013 Nir Krakauer
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; If not, see <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{x} =} linsolve (@var{A}, @var{b})
+## @deftypefnx {Function File} {@var{x} =} linsolve (@var{A}, @var{b}, @var{opts})
+## @deftypefnx {Function File} {[@var{x}, @var{R}] =} linsolve (@dots{})
+## Solve the linear system @code{A*x = b}.
+##
+## With no options, this function is equivalent to the left division operator
+## @w{(@code{x = A \ b})} or the matrix-left-divide function
+## @w{(@code{x = mldivide (A, b)})}.
+##
+## Octave ordinarily examines the properties of the matrix @var{A} and chooses
+## a solver that best matches the matrix.  By passing a structure @var{opts}
+## to @code{linsolve} you can inform Octave directly about the matrix @var{A}.
+## In this case Octave will skip the matrix examination and proceed directly
+## to solving the linear system.
+##
+## @strong{Warning:} If the matrix @var{A} does not have the properties
+## listed in the @var{opts} structure then the result will not be accurate
+## AND no warning will be given.  When in doubt, let Octave examine the matrix
+## and choose the appropriate solver as this step takes little time and the
+## result is cached so that it is only done once per linear system.
+##
+## Possible @var{opts} fields (set value to true/false):
+##
+## @table @asis
+## @item LT
+##   @var{A} is lower triangular
+##
+## @item UT
+##   @var{A} is upper triangular
+##
+## @item UHESS
+##   @var{A} is upper Hessenberg (currently makes no difference)
+##
+## @item SYM
+##   @var{A} is symmetric or complex Hermitian (currently makes no difference)
+##
+## @item POSDEF
+##   @var{A} is positive definite
+##
+## @item RECT
+##   @var{A} is general rectangular (currently makes no difference)
+##
+## @item TRANSA
+##   Solve @code{A'*x = b} by @code{transpose (A) \ b}
+## @end table
+##
+## The optional second output @var{R} is the inverse condition number of
+## @var{A} (zero if matrix is singular).
+## @seealso{mldivide, matrix_type, rcond}
+## @end deftypefn
+
+## Author: Nir Krakauer <nkrakauer@ccny.cuny.edu>
+
+function [x, R] = linsolve (A, b, opts)
+
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+  endif
+
+  if (! (isnumeric (A) && isnumeric (b)))
+    error ("linsolve: A and B must be numeric");
+  endif
+
+  ## Process any opts
+  if (nargin > 2)
+    if (! isstruct (opts))
+      error ("linsolve: OPTS must be a structure");
+    endif
+    trans_A = false;
+    if (isfield (opts, "TRANSA") && opts.TRANSA)
+      trans_A = true;
+      A = A';
+    endif
+    if (isfield (opts, "POSDEF") && opts.POSDEF)
+      A = matrix_type (A, "positive definite");
+    endif  
+    if (isfield (opts, "LT") && opts.LT)
+      if (trans_A)
+        A = matrix_type (A, "upper");
+      else
+        A = matrix_type (A, "lower");
+      endif
+    endif
+    if (isfield (opts, "UT") && opts.UT)
+      if (trans_A)
+        A = matrix_type (A, "lower");
+      else
+        A = matrix_type (A, "upper");
+      endif
+    endif        
+  endif
+
+  x = A \ b;
+
+  if (nargout > 1)
+    if (issquare (A))
+      R = rcond (A);
+    else
+      R = 0;
+    endif
+  endif
+endfunction
+
+
+%!test
+%! n = 4;
+%! A = triu (rand (n));
+%! x = rand (n, 1);
+%! b = A' * x;
+%! opts.UT = true;
+%! opts.TRANSA = true;
+%! assert (linsolve (A, b, opts), A' \ b);
+
+%!error linsolve ()
+%!error linsolve (1)
+%!error linsolve (1,2,3)
+%!error <A and B must be numeric> linsolve ({1},2)
+%!error <A and B must be numeric> linsolve (1,{2})
+%!error <OPTS must be a structure> linsolve (1,2,3)
diff --git a/scripts/linear-algebra/module.mk b/scripts/linear-algebra/module.mk
--- a/scripts/linear-algebra/module.mk
+++ b/scripts/linear-algebra/module.mk
@@ -7,16 +7,17 @@ linear_algebra_FCN_FILES = \
   linear-algebra/cross.m \
   linear-algebra/duplication_matrix.m \
   linear-algebra/expm.m \
   linear-algebra/housh.m \
   linear-algebra/isdefinite.m \
   linear-algebra/ishermitian.m \
   linear-algebra/issymmetric.m \
   linear-algebra/krylov.m \
+  linear-algebra/linsolve.m \
   linear-algebra/logm.m \
   linear-algebra/normest.m \
   linear-algebra/null.m \
   linear-algebra/onenormest.m \
   linear-algebra/orth.m \
   linear-algebra/planerot.m \
   linear-algebra/qzhess.m \
   linear-algebra/rank.m \
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -34,16 +34,18 @@
 ## @end group
 ## @end example
 ##
 ## The Hessenberg-triangular decomposition is the first step in
 ## Moler and Stewart's QZ@tie{}decomposition algorithm.
 ##
 ## Algorithm taken from Golub and Van Loan,
 ## @cite{Matrix Computations, 2nd edition}.
+## 
+## @seealso{lu, chol, hess, qr, qz, schur, svd}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (A, B)
 
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -14,28 +14,52 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rank (@var{A})
 ## @deftypefnx {Function File} {} rank (@var{A}, @var{tol})
-## Compute the rank of @var{A}, using the singular value decomposition.
+## Compute the rank of matrix @var{A}, using the singular value decomposition.
+##
 ## The rank is taken to be the number of singular values of @var{A} that
 ## are greater than the specified tolerance @var{tol}.  If the second
 ## argument is omitted, it is taken to be
 ##
 ## @example
 ## tol = max (size (@var{A})) * sigma(1) * eps;
 ## @end example
 ##
 ## @noindent
 ## where @code{eps} is machine precision and @code{sigma(1)} is the largest
 ## singular value of @var{A}.
+##
+## The rank of a matrix is the number of linearly independent rows or
+## columns and determines how many particular solutions exist to a system
+## of equations.  Use @code{null} for finding the remaining homogenous
+## solutions.
+##
+## Example:
+##
+## @example
+## @group
+## x = [1 2 3
+##      4 5 6
+##      7 8 9];
+## rank (x)
+##   @result{} 2
+## @end group
+## @end example
+##
+## @noindent
+## The number of linearly independent rows is only 2 because the final row
+## is a linear combination of -1*row1 + 2*row2.
+##
+## @seealso{null, sprank, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = rank (A, tol)
 
   if (nargin == 1)
     sigma = svd (A);
@@ -99,15 +123,19 @@ endfunction
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
 %! assert (rank (A), 3);
 
 %!test
 %! A = eye (100);
 %! assert (rank (A), 100);
 
+%!assert (rank ([]), 0)
+%!assert (rank ([1:9]), 1)
+%!assert (rank ([1:9]'), 1)
+
 %!test
 %! A = [1, 2, 3; 1, 2.001, 3; 1, 2, 3.0000001];
 %! assert (rank (A), 3);
 %! assert (rank (A,0.0009), 1);
 %! assert (rank (A,0.0006), 2);
 %! assert (rank (A,0.00000002), 3);
 
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -54,8 +54,9 @@ function ang = subspace (A, B)
     endif
     ssin = max (svd (c));
     ang = asin (min (ssin, 1));
   else
     ang = acos (scos);
   endif
 
 endfunction
+
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -13,42 +13,47 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} trace (@var{A})
-## Compute the trace of @var{A}, @code{sum (diag (@var{A}))}.
+## Compute the trace of @var{A}, the sum of the elements along the main
+## diagonal.
+##
+## The implementation is straightforward: @code{sum (diag (@var{A}))}.
+## @seealso{eig}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = trace (A)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (ndims (A) > 2)
     error ("trace: only valid on 2-D objects");
   elseif (isempty (A))
     y = 0;
-  elseif (any (size (A) == 1))
+  elseif (isvector (A))
     y = A(1);
   else
     y = sum (diag (A));
   endif
 
 endfunction
 
 
 %!assert (trace ([1, 2; 3, 4]), 5)
 %!assert (trace ([1, 2; 3, 4; 5, 6]), 5)
 %!assert (trace ([1, 3, 5; 2, 4, 6]), 5)
 %!assert (trace ([]), 0)
-%!assert (trace (randn (1,0)), 0)
+%!assert (trace (rand (1,0)), 0)
+%!assert (trace ([3:10]), 3)
 
 %!error trace ()
 %!error trace (1, 2)
 %!error <only valid on 2-D objects> trace (reshape (1:9,[1,3,3]))
 
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -42,8 +42,9 @@ function bug_report ()
   puts ("  quickly and efficiently.\n");
   puts ("\n");
 
 endfunction
 
 
 ## Mark file as being tested.  No real test needed for this function.
 %!assert (1)
+
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -35,8 +35,9 @@ function varargout = bunzip2 (bzfile, di
   if (nargout > 0)
     varargout = cell (1, nargout);
     [varargout{:}] = unpack (bzfile, dir, mfilename ());
   else
     unpack (bzfile, dir, mfilename ());
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -16,20 +16,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} bzip2 (@var{files}, @var{outdir})
 ## Compress the list of files specified in @var{files}.
-## Each file is compressed separately and a new file with a ".bz2" extension
-## is created.  The original files are not modified.  Existing compressed files
-## are silently overwritten.  If @var{outdir} is defined the compressed
-## files are placed in this directory.
+## Each file is compressed separately and a new file with a @file{".bz2"}
+## extension is created.  The original files are not modified.  Existing
+## compressed files are silently overwritten.  If @var{outdir} is defined the
+## compressed files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
   if (nargin == 1 || nargin == 2)
     if (nargout == 0)
       __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
@@ -39,17 +39,17 @@ function entries = bzip2 (varargin)
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!xtest
-%! # test for correct cleanup of temporary files
+%! ## test for correct cleanup of temporary files
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
 %!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   entry = bzip2 (filename);
 %!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   if (n_tmpfiles_before != n_tmpfiles_after)
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -38,8 +38,9 @@ function retval = cast (val, typ)
     else
       error ("cast: expecting TYPE name as second argument");
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -17,61 +17,61 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} compare_versions (@var{v1}, @var{v2}, @var{operator})
 ## Compare two version strings using the given @var{operator}.
 ##
 ## This function assumes that versions @var{v1} and @var{v2} are
 ## arbitrarily long strings made of numeric and period characters
-## possibly followed by an arbitrary string (e.g., "1.2.3", "0.3",
-## "0.1.2+", or "1.2.3.4-test1").
+## possibly followed by an arbitrary string (e.g., @qcode{"1.2.3"},
+## @qcode{"0.3"}, @qcode{"0.1.2+"}, or @qcode{"1.2.3.4-test1"}).
 ##
 ## The version is first split into numeric and character portions
-## and then the parts are padded to be the same length (i.e., "1.1" would be
-## padded to be "1.1.0" when being compared with "1.1.1", and
-## separately, the character parts of the strings are padded with
-## nulls).
+## and then the parts are padded to be the same length (i.e., @qcode{"1.1"}
+## would be padded to be @qcode{"1.1.0"} when being compared with
+## @qcode{"1.1.1"}, and separately, the character parts of the strings are
+## padded with nulls).
 ##
 ## The operator can be any logical operator from the set
 ##
 ## @itemize @bullet
 ## @item
-## "=="
+## @qcode{"=="}
 ## equal
 ##
 ## @item
-## "<"
+## @qcode{"<"}
 ## less than
 ##
 ## @item
-## "<="
+## @qcode{"<="}
 ## less than or equal to
 ##
 ## @item
-## ">"
+## @qcode{">"}
 ## greater than
 ##
 ## @item
-## ">="
+## @qcode{">="}
 ## greater than or equal to
 ##
 ## @item
-## "!="
+## @qcode{"!="}
 ## not equal
 ##
 ## @item
-## "~="
+## @qcode{"~="}
 ## not equal
 ## @end itemize
 ##
-## Note that version "1.1-test2" will compare as greater than
-## "1.1-test10".  Also, since the numeric part is compared first, "a"
-## compares less than "1a" because the second string starts with a
-## numeric part even though @code{double ("a")} is greater than
+## Note that version @qcode{"1.1-test2"} will compare as greater than
+## @qcode{"1.1-test10"}.  Also, since the numeric part is compared first,
+## @qcode{"a"} compares less than @qcode{"1a"} because the second string
+## starts with a numeric part even though @code{double ("a")} is greater than
 ## @code{double ("1").}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 function out = compare_versions (v1, v2, operator)
 
   if (nargin != 3)
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -33,20 +33,20 @@
 ##    @result{} x = "i586-pc-linux-gnu"
 ## @end group
 ## @end example
 ##
 ## If two output arguments are requested, also return the maximum number
 ## of elements for an array.
 ##
 ## If three output arguments are requested, also return the byte order
-## of the current system as a character (@code{"B"} for big-endian or
-## @code{"L"} for little-endian).
+## of the current system as a character (@qcode{"B"} for big-endian or
+## @qcode{"L"} for little-endian).
 ##
-## If the argument @code{"arch"} is specified, return a string
+## If the argument @qcode{"arch"} is specified, return a string
 ## indicating the architecture of the computer on which Octave is
 ## running.
 ## @end deftypefn
 
 function [c, maxsize, endian] = computer (a)
 
   if (nargin == 1 && ischar (a) && strcmpi (a, "arch"))
     tmp = ostrsplit (octave_config_info ("canonical_host_type"), "-");
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -14,117 +14,121 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@var{f1}, @var{f2})
 ## @deftypefnx {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@var{f1}, @var{f2}, 'f')
-## Copy the file @var{f1} to the new name @var{f2}.  The name @var{f1}
-## may contain globbing patterns.  If @var{f1} expands to multiple file
-## names, @var{f2} must be a directory.  If the force flag 'f' is given then
-## existing destination files will be overwritten without prompting.
+## Copy the file @var{f1} to the destination @var{f2}.
+##
+## The name @var{f1} may contain globbing patterns.  If @var{f1} expands to
+## multiple file names, @var{f2} must be a directory.
+## when the force flag @qcode{'f'} is given any existing files will be
+## overwritten without prompting.
 ##
-## If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty
-## character strings.  Otherwise, @var{status} is 0, @var{msg} contains a
-## system-dependent error message, and @var{msgid} contains a unique
-## message identifier.
-## @seealso{movefile}
+## If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty
+## character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a
+## system-dependent error message, and @var{msgid} contains a unique message
+## identifier.  Note that the status code is exactly opposite that of the
+## @code{system} command.
+## @seealso{movefile, rename, unlink, delete, glob}
 ## @end deftypefn
 
 function [status, msg, msgid] = copyfile (f1, f2, force)
 
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+  endif
+
   max_cmd_line = 1024;
   status = true;
   msg = "";
   msgid = "";
 
-  ## FIXME -- maybe use the same method as in ls to allow users control
+  ## FIXME: maybe use the same method as in ls to allow users control
   ## over the command that is executed.
 
   if (ispc () && ! isunix ()
       && isempty (file_in_path (getenv ("PATH"), "cp.exe")))
     ## Windows.
     cmd = "cmd /C xcopy /E";
     cmd_force_flag = "/Y";
   else
     cmd = "cp -r";
     cmd_force_flag = "-f";
   endif
 
-  if (nargin == 2 || nargin == 3)
-    ## Input type check.
-    if (! (ischar (f1) || iscellstr (f1)))
-      error ("copyfile: first argument must be a character string or a cell array of character strings");
-    endif
+  ## Input type check.
+  if (! (ischar (f1) || iscellstr (f1)))
+    error ("copyfile: F1 must be a character string or a cell array of character strings");
+  endif
 
-    if (! ischar (f2))
-      error ("copyfile: second argument must be a character string");
-    endif
+  if (! ischar (f2))
+    error ("copyfile: F2 must be a character string");
+  endif
 
-    if (nargin == 3 && strcmp (force, "f"))
-      cmd = cstrcat (cmd, " ", cmd_force_flag);
-    endif
+  if (nargin == 3 && strcmp (force, "f"))
+    cmd = [cmd " " cmd_force_flag];
+  endif
 
-    ## If f1 isn't a cellstr convert it to one.
-    if (ischar (f1))
-      f1 = cellstr (f1);
-    endif
-
-    ## If f1 has more than 1 element f2 must be a directory
-    isdir = (exist (f2, "dir") != 0);
-    if (length (f1) > 1 && ! isdir)
-      error ("copyfile: when copying multiple files, second argument must be a directory");
-    endif
+  ## If f1 isn't a cellstr convert it to one.
+  if (ischar (f1))
+    f1 = cellstr (f1);
+  endif
 
-    ## Protect the file name(s).
-    f1 = glob (f1);
-    if (isempty (f1))
-      error ("copyfile: no files to move");
-    endif
-    p1 = sprintf ("\"%s\" ", f1{:});
-    p2 = tilde_expand (f2);
+  ## If f1 has more than 1 element f2 must be a directory
+  isdir = (exist (f2, "dir") != 0);
+  if (length (f1) > 1 && ! isdir)
+    error ("copyfile: when copying multiple files, F2 must be a directory");
+  endif
 
-    if (isdir && length (p1) > max_cmd_line)
-      l2 = length (p2) + length (cmd) + 6;
-      while (! isempty (f1))
-        p1 = sprintf ("\"%s\" ", f1{1});
+  ## Protect the file name(s).
+  f1 = glob (f1);
+  if (isempty (f1))
+    error ("copyfile: no files to move");
+  endif
+  p1 = sprintf ('"%s" ', f1{:});
+  p2 = tilde_expand (f2);
+
+  if (isdir && length (p1) > max_cmd_line)
+    l2 = length (p2) + length (cmd) + 6;
+    while (! isempty (f1))
+      p1 = sprintf ('"%s" ', f1{1});
+      f1(1) = [];
+      while (! isempty (f1)
+             && (length (p1) + length (f1{1}) + l2 < max_cmd_line))
+        p1 = sprintf ('%s"%s" ', p1, f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length (p1) + length (f1{1}) + l2 <
-                                 max_cmd_line))
-          p1 = sprintf ("%s\"%s\" ", p1, f1{1});
-          f1(1) = [];
-        endwhile
+      endwhile
 
-        if (ispc () && ! isunix ()
-            && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
-          p1 = strrep (p1, "\\", "/");
-          p2 = strrep (p2, "\\", "/");
-        endif
-
-        ## Copy the files.
-        [err, msg] = system (sprintf ("%s %s\"%s\"", cmd, p1, p2));
-        if (err < 0)
-          status = false;
-          msgid = "copyfile";
-          break;
-        endif
-      endwhile
-    else
       if (ispc () && ! isunix ()
           && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
-        p1 = strrep (p1, "\\", "/");
-        p2 = strrep (p2, "\\", "/");
+        p1 = strrep (p1, '\', '/');
+        p2 = strrep (p2, '\', '/');
       endif
 
       ## Copy the files.
-      [err, msg] = system (sprintf ("%s %s\"%s\"", cmd, p1, p2));
-      if (err < 0)
+      [err, msg] = system (sprintf ('%s %s"%s"', cmd, p1, p2));
+      if (err != 0)
         status = false;
         msgid = "copyfile";
+        break;
       endif
+    endwhile
+  else
+    if (ispc () && ! isunix ()
+        && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
+      p1 = strrep (p1, '\', '/');
+      p2 = strrep (p2, '\', '/');
     endif
-  else
-    print_usage ();
+
+    ## Copy the files.
+    [err, msg] = system (sprintf ('%s %s"%s"', cmd, p1, p2));
+    if (err != 0)
+      status = false;
+      msgid = "copyfile";
+    endif
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -74,20 +74,21 @@
 ## Configure whether Octave enters debug mode when it encounters an interrupt.
 ##
 ## @item isdebugmode
 ## Return true if in debug mode.
 ## @end table
 ##
 ## @noindent
 ## When Octave encounters a breakpoint, or other reason to enter debug
-## mode, the prompt changes to @code{"debug>"}.  The workspace of the function
+## mode, the prompt changes to @qcode{"debug>"}.  The workspace of the function
 ## where the breakpoint was encountered becomes available and any Octave
 ## command that is valid in that workspace context may be executed.
 ##
 ## @seealso{dbstop, dbclear, dbstatus, dbwhere, dbtype, dbcont, dbquit,
-##          dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning,
-##          debug_on_interrupt, isdebugmode}
+## dbstack, dbup, dbdown, keyboard, debug_on_error, debug_on_warning,
+## debug_on_interrupt, isdebugmode}
 ## @end deftypefn
 
 function debug ()
   help ("debug");
 endfunction
+
diff --git a/scripts/miscellaneous/desktop.m b/scripts/miscellaneous/desktop.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/desktop.m
@@ -0,0 +1,50 @@
+## Copyright (C) 2013 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} @var{used} = desktop ("-inuse")
+## Return true if the desktop (GUI) is currently in use.
+## @seealso{isguirunning}
+## @end deftypefn
+
+function retval = desktop (arg)
+
+  if (nargin == 0)
+    if (isguirunning ())
+      return;  # desktop() is a NOP when GUI running
+    else
+      print_usage ();
+    endif
+  elseif (nargin > 1)
+    error ('desktop: only one argument, "-inuse", is allowed');
+  endif
+  
+  switch (tolower (arg))
+    case "-inuse"
+      retval = isguirunning ();
+    otherwise
+      print_usage ();
+  endswitch
+
+endfunction
+
+
+## Test input validation
+%!error <only one argument, "-inuse", is allowed> desktop (1,2)
+%!error desktop ("-invalid_option")
+
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -12,50 +12,61 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} dir (@var{directory})
+## @deftypefn  {Function File} {} dir
+## @deftypefnx {Function File} {} dir (@var{directory})
 ## @deftypefnx {Function File} {[@var{list}] =} dir (@var{directory})
-## Display file listing for directory @var{directory}.  If a return
-## value is requested, return a structure array with the fields
+## Display file listing for directory @var{directory}.
+##
+## If @var{directory} is not specified then list the present working directory.
+##
+## If a return value is requested, return a structure array with the fields
+##
+## @table @asis
+## @item name
+## File or directory name. 
+##
+## @item date
+## Timestamp of file modification (string value).
 ##
-## @example
-## @group
-## name
-## bytes
-## date
-## isdir
-## statinfo
-## @end group
-## @end example
+## @item bytes
+## File size in bytes.
+##
+## @item isdir
+## True if name is a directory. 
+##
+## @item datenum
+## Timestamp of file modification as serial date number (double).
 ##
-## @noindent
-## where @code{statinfo} is the structure returned from @code{stat}.
+## @item statinfo
+## Information structure returned from @code{stat}.
+## @end table
 ##
-## If @var{directory} is not a directory, return information about the
-## named @var{filename}.  @var{directory} may be a list of directories
-## specified either by name or with wildcard characters (like * and ?)
-## which will be expanded with glob.
+## If @var{directory} is a filename, rather than a directory, then return
+## information about the named file.  @var{directory} may be a list of
+## directories specified either by name or with wildcard characters (like *
+## and ?) which will be expanded with @code{glob}.
 ##
 ## Note that for symbolic links, @code{dir} returns information about
-## the file that the symbolic link points to instead of the link itself.
+## the file that the symbolic link points to rather than the link itself.
 ## However, if the link points to a nonexistent file, @code{dir} returns
 ## information about the link.
-## @seealso{ls, stat, lstat, readdir, glob, filesep}
+## @seealso{ls, readdir, glob, what, stat}
 ## @end deftypefn
 
 ## Author: jwe
 
-## FIXME -- this is quite slow for large directories, so perhaps
-## it should be converted to C++.
+## FIXME: This is quite slow for large directories, so perhaps
+##        it should be converted to C++.
 
 function retval = dir (directory)
 
   if (nargin == 0)
     directory = ".";
   elseif (nargin > 1)
     print_usage ();
   endif
@@ -106,17 +117,17 @@ function retval = dir (directory)
           ## info about the link itself.
           if (S_ISLNK (st.mode))
             [xst, err, msg] = stat (fn);
             if (! err)
               st = xst;
             endif
           endif
           [dummy, fn, ext] = fileparts (fn);
-          fn = cstrcat (fn, ext);
+          fn = [fn ext];
           info(i,1).name = fn;
           lt = localtime (st.mtime);
           info(i,1).date = strftime ("%d-%b-%Y %T", lt);
           info(i,1).bytes = st.size;
           info(i,1).isdir = S_ISDIR (st.mode);
           info(i,1).datenum = datenum (lt.year + 1900, lt.mon + 1, lt.mday,
                                        lt.hour, lt.min, lt.sec);
           info(i,1).statinfo = st;
@@ -135,8 +146,9 @@ function retval = dir (directory)
   elseif (length (info) > 0)
     ## Print the structure to the screen.
     printf ("%s", list_in_columns ({info.name}));
   else
     warning ("dir: nonexistent directory '%s'", directory);
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} dos ("@var{command}")
 ## @deftypefnx {Function File} {@var{status} =} dos ("@var{command}")
 ## @deftypefnx {Function File} {[@var{status}, @var{text}] =} dos ("@var{command"})
 ## @deftypefnx {Function File} {[@dots{}] =} dos ("@var{command}", "-echo")
 ## Execute a system command if running under a Windows-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
 ## in @var{status} and any output from the command in @var{text}.
-## When called with no output argument, or the "-echo" argument is
+## When called with no output argument, or the @qcode{"-echo"} argument is
 ## given, then @var{text} is also sent to standard output.
 ## @seealso{unix, system, isunix, ispc}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = dos (command, echo_arg)
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -91,8 +91,9 @@ function dump_prefs (file)
       endif
       fprintf (file, "  %s = %s\n", sym, val);
     catch
       fprintf (file, "# %s = <no value or error in displaying it>\n", sym);
     end_try_catch
   endfor
 
 endfunction
+
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -25,95 +25,97 @@
 ## If @code{edit} is called with the name of a file or function as
 ## its argument it will be opened in a text editor.
 ##
 ## @itemize @bullet
 ## @item
 ## If the function @var{name} is available in a file on your path and
 ## that file is modifiable, then it will be edited in place.  If it
 ## is a system function, then it will first be copied to the directory
-## @env{HOME} (see further down) and then edited.
+## @env{HOME} (see below) and then edited.
 ## If no file is found, then the m-file
 ## variant, ending with ".m", will be considered.  If still no file
 ## is found, then variants with a leading "@@" and then with both a
 ## leading "@@" and trailing ".m" will be considered.
 ##
 ## @item
 ## If @var{name} is the name of a function defined in the interpreter but
 ## not in an m-file, then an m-file will be created in @env{HOME}
 ## to contain that function along with its current definition.
 ##
 ## @item
-## If @code{name.cc} is specified, then it will search for @code{name.cc}
-## in the path and try to modify it, otherwise it will create a new
-## @file{.cc} file in @env{HOME}.  If @var{name} happens to be an
+## If @code{@var{name}.cc} is specified, then it will search for
+## @code{@var{name}.cc} in the path and try to modify it, otherwise it will
+## create a new @file{.cc} file in @env{HOME}.  If @var{name} happens to be an
 ## m-file or interpreter defined function, then the text of that
 ## function will be inserted into the .cc file as a comment.
 ##
 ## @item
-## If @var{name.ext} is on your path then it will be edited, otherwise
-## the editor will be started with @file{HOME/name.ext} as the
-## filename.  If @file{name.ext} is not modifiable, it will be copied to
+## If @file{@var{name}.ext} is on your path then it will be edited, otherwise
+## the editor will be started with @file{@env{HOME}/@var{name}.ext} as the
+## filename.  If @file{@var{name}.ext} is not modifiable, it will be copied to
 ## @env{HOME} before editing.
 ##
-## @strong{Warning:} You may need to clear name before the new definition
+## @strong{Warning:} You may need to clear @var{name} before the new definition
 ## is available.  If you are editing a .cc file, you will need
-## to mkoctfile @file{name.cc} before the definition will be available.
+## to execute @code{mkoctfile @file{@var{name}.cc}} before the definition
+## will be available.
 ## @end itemize
 ##
 ## If @code{edit} is called with @var{field} and @var{value} variables,
-## the value of the control field @var{field} will be @var{value}.
-## If an output argument is requested and the first argument is @code{get}
+## the value of the control field @var{field} will be set to @var{value}.
+## If an output argument is requested and the first input argument is @code{get}
 ## then @code{edit} will return the value of the control field @var{field}.
 ## If the control field does not exist, edit will return a structure
 ## containing all fields and values.  Thus, @code{edit get all} returns
 ## a complete control structure.
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item editor
 ## This is the editor to use to modify the functions.  By default it uses
 ## Octave's @env{EDITOR} built-in function, which comes from
 ## @code{getenv ("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
 ## In place of the function name.  For example,
 ##
-## @table @samp
-## @item [EDITOR, " %s"]
+## @table @asis
+## @item @code{[EDITOR, " %s"]}
 ## Use the editor which Octave uses for @code{edit_history}.
 ##
-## @item "xedit %s &"
+## @item @nospell{"xedit %s &"}
 ## pop up simple X11 editor in a separate window
 ##
-## @item "gnudoit -q \"(find-file \\\"%s\\\")\""
+## @item @nospell{"gnudoit -q \"(find-file \\\"%s\\\")\""}
 ## Send it to current Emacs; must have @code{(gnuserv-start)} in @file{.emacs}.
 ## @end table
 ##
-## See also field 'mode', which controls how the editor is run by Octave.
+## See also field @qcode{"mode"}, which controls how the editor is run by
+## Octave.
 ##
 ## On Cygwin, you will need to convert the Cygwin path to a Windows
 ## path if you are using a native Windows editor.  For example:
 ## @c Set example in small font to prevent overfull line in TeX
 ##
 ## @smallexample
 ## @exdent '"C:/Program Files/Good Editor/Editor.exe" "$(cygpath -wa %s)"'
 ## @end smallexample
 ##
 ## @item home
-## This is the location of user local m-files.  Be be sure it is in your
+## This is the location of user local m-files.  Be sure it is in your
 ## path.  The default is @file{~/octave}.
 ##
 ## @item author
 ## This is the name to put after the "## Author:" field of new functions.
-## By default it guesses from the @code{gecos} field of password database.
+## By default it guesses from the @code{gecos} field of the password database.
 ##
 ## @item email
 ## This is the e-mail address to list after the name in the author field.
 ## By default it guesses @code{<$LOGNAME@@$HOSTNAME>}, and if @code{$HOSTNAME}
 ## is not defined it uses @code{uname -n}.  You probably want to override this.
-## Be sure to use @code{<user@@host>} as your format.
+## Be sure to use the format @code{<user@@host>}.
 ##
 ## @item license
 ##
 ## @table @samp
 ## @item gpl
 ## GNU General Public License (default).
 ##
 ## @item bsd
@@ -127,144 +129,144 @@
 ## @end table
 ##
 ## Unless you specify @samp{pd}, edit will prepend the copyright statement
 ## with "Copyright (C) yyyy Function Author".
 ##
 ## @item mode
 ## This value determines whether the editor should be started in async mode
 ## (editor is started in the background and Octave continues) or sync mode
-## (Octave waits until the editor exits).  Set it to "sync" to start the editor
-## in sync mode.  The default is "async" (see also "system").
+## (Octave waits until the editor exits).  Set it to @qcode{"sync"} to start
+## the editor in sync mode.  The default is @qcode{"async"}
+## (@pxref{XREFsystem,,system}).
 ##
 ## @item editinplace
 ## Determines whether files should be edited in place, without regard to
 ## whether they are modifiable or not.  The default is @code{false}.
 ## @end table
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 function ret = edit (varargin)
 
   ## Pick up globals or default them.
 
-  persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
+  persistent FUNCTION = struct ("EDITOR", [EDITOR() " %s"],
                                 "HOME", fullfile (default_home, "octave"),
                                 "AUTHOR", default_user(1),
-                                "EMAIL",  [],
-                                "LICENSE",  "GPL",
+                                "EMAIL", [],
+                                "LICENSE", "GPL",
                                 "MODE", "async",
                                 "EDITINPLACE", false);
   ## Make sure the stateval variables survive "clear functions".
   mlock;
 
   if (nargin == 1)
     ## User has supplied one arg, this can be a single file name
-    ## or a cell array of strings containing multiple files to be
-    ## opened
-    if (iscellstr(varargin{1}))
-      ## If first arg is a cell array of strings, it becomes the
-      ## list of files to be edited
+    ## or a cell array of strings containing multiple files to be opened
+    if (iscellstr (varargin{1}))
+      ## If first arg is a cell array of strings, 
+      ## it becomes the list of files to be edited
       editfilelist = varargin{1};
-    elseif (ischar(varargin{1}))
+    elseif (ischar (varargin{1}))
       ## If first arg is a string, create a cell array of strings
-      ## of length one (by copying the input cell array)
+      ## of length 1 (by copying the input cell array)
       editfilelist = varargin(1);
     else
-      error('edit: expected file to be a string or cell array of strings');
+      error ("edit: expected file to be a string or cell array of strings");
     endif
   elseif (nargin == 2)
-    ## User has supplied two arguments, these could be two file
-    ## names, or a combination of editor state name and new value
-    ## for that state, so first check for the various states
+    ## User has supplied two arguments, these could be two file names,
+    ## or a combination of editor state name and new value for that state,
+    ## so first check for the various states
     statevar = varargin{1};
     stateval = varargin{2};
     switch (toupper (statevar))
-    case "EDITOR"
-      FUNCTION.EDITOR = stateval;
-      return
-    case "HOME"
-      if (! isempty (stateval) && stateval(1) == "~")
-        stateval = [ default_home, stateval(2:end) ];
-      endif
-      FUNCTION.HOME = stateval;
-      return
-    case "AUTHOR"
-      FUNCTION.AUTHOR = stateval;
-      return
-    case "EMAIL"
-      FUNCTION.EMAIL = stateval;
-      return
-    case "LICENSE"
-      FUNCTION.LICENSE = stateval;
-      return
-    case "MODE"
-      if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
-        FUNCTION.MODE = stateval;
-      else
-        error ('edit: expected "edit MODE sync|async"');
-      endif
-      return
-    case "EDITINPLACE"
-      if (ischar (stateval))
-        if (strcmpi (stateval, "true"))
-          stateval = true;
-        elseif (strcmpi (stateval, "false"))
-          stateval = false;
+      case "EDITOR"
+        FUNCTION.EDITOR = stateval;
+        return;
+      case "HOME"
+        if (! isempty (stateval) && stateval(1) == "~")
+          stateval = [ default_home, stateval(2:end) ];
+        endif
+        FUNCTION.HOME = stateval;
+        return;
+      case "AUTHOR"
+        FUNCTION.AUTHOR = stateval;
+        return;
+      case "EMAIL"
+        FUNCTION.EMAIL = stateval;
+        return;
+      case "LICENSE"
+        FUNCTION.LICENSE = stateval;
+        return;
+      case "MODE"
+        if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
+          FUNCTION.MODE = stateval;
         else
-          stateval = eval (stateval);
+          error ('edit: expected "edit MODE sync|async"');
+        endif
+        return;
+      case "EDITINPLACE"
+        if (ischar (stateval))
+          if (strcmpi (stateval, "true"))
+            stateval = true;
+          elseif (strcmpi (stateval, "false"))
+            stateval = false;
+          else
+            stateval = eval (stateval);
+          endif
         endif
-      endif
-      FUNCTION.EDITINPLACE = stateval;
-      return
-    case "GET"
-      if (isfield (FUNCTION, toupper (stateval)))
-        ret = FUNCTION.(toupper (stateval));
-      else
-        ret = FUNCTION;
-      endif
-      return
-    otherwise
-      ## If none of the states match, assume both inputs are
-      ## actually both file names to be opened
-      editfilelist = varargin;
+        FUNCTION.EDITINPLACE = stateval;
+        return;
+      case "GET"
+        if (isfield (FUNCTION, toupper (stateval)))
+          ret = FUNCTION.(toupper (stateval));
+        else
+          ret = FUNCTION;
+        endif
+        return;
+      otherwise
+        ## If none of the states match, assume both inputs are
+        ## actually both file names to be opened
+        editfilelist = varargin;
     endswitch
   elseif (nargin > 2)
-    if (iscellstr(varargin))
+    if (iscellstr (varargin))
       editfilelist = varargin;
     else
-      error('edit: if supplying more than one input all inputs must be strings containing fiel names to open.');
+      error ("edit: if supplying more than one input all inputs must be strings containing field names to open.");
     endif
   endif
 
   ## Start the editor without a file if no file is given.
-  if (nargin < 1)
+  if (nargin == 0)
     if (exist (FUNCTION.HOME, "dir") == 7)
       curr_dir = pwd ();
       unwind_protect
         chdir (FUNCTION.HOME);
         do_edit (FUNCTION.EDITOR, "", FUNCTION.MODE);
       unwind_protect_cleanup
         chdir (curr_dir);
       end_unwind_protect
     else
       do_edit (FUNCTION.EDITOR, "", FUNCTION.MODE);
     endif
     return;
   endif
 
-  if (numel(editfilelist) > 1)
+  if (numel (editfilelist) > 1)
 
     ## Call edit on each of the files in the list if there are more than 1
-    for i = 1:numel(editfilelist)
-      edit(editfilelist{i});
+    for i = 1:numel (editfilelist)
+      edit (editfilelist{i});
     endfor
 
   else
   
     ## Only one file name was supplied, get it from the cell array
     file = editfilelist{1};
 
     ## Check whether the user is trying to edit a builtin or compiled function.
@@ -291,34 +293,32 @@ function ret = edit (varargin)
     ## The code below includes a portion that serves as a place-holder for
     ## the changes suggested above.
 
     ## Create list of explicit and implicit file names.
     filelist = {file};
     ## If file has no extension, add file.m and file.cc to the list.
     idx = rindex (file, ".");
     if (idx == 0)
-      ## Create the list of files to look for
-      filelist = {file};
       if (isempty (regexp (file, '\.m$')))
         ## No ".m" at the end of the file, add to the list.
-        filelist{end+1} = cat (2, file, ".m");
+        filelist{end+1} = [file ".m"];
       endif
       if (isempty (regexp (file, '\.cc$')))
         ## No ".cc" at the end of the file, add to the list.
-        filelist{end+1} = cat (2, file, ".cc");
+        filelist{end+1} = [file ".cc"];
       endif
     endif
 
     ## If the file includes a path, it may be an overloaded function.
     if (! strcmp (file, "@") && index (file, filesep))
       ## No "@" at the beginning of the file, add to the list.
       numfiles = numel (filelist);
       for n = 1:numfiles
-        filelist{n+numfiles} = cat (2, "@", filelist{n});
+        filelist{n+numfiles} = ["@" filelist{n}];
       endfor
     endif
 
     ## Search the entire path for the 1st instance of a file in the list.
     fileandpath = "";
     for n = 1:numel (filelist)
       filetoedit = file_in_path (path, filelist{n});
       if (! isempty (filetoedit))
@@ -330,22 +330,22 @@ function ret = edit (varargin)
 
     if (! isempty (fileandpath))
       ## If the file exists, then edit it.
       if (FUNCTION.EDITINPLACE)
         ## Edit in place even if it is protected.
         do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
         return;
       else
-        ## If the file is modifiable in place then edit it, otherwise make
-        ## a copy in HOME and then edit it.
+        ## If the file is modifiable in place then edit it,
+        ## otherwise make a copy in HOME and then edit it.
         fid = fopen (fileandpath, "r+t");
         if (fid < 0)
           from = fileandpath;
-          fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
+          fileandpath = [FUNCTION.HOME, from(rindex(from, filesep):end)];
           [status, msg] = copyfile (from, fileandpath, 1);
           if (status == 0)
             error (msg);
           endif
         else
           fclose (fid);
         endif
         do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
@@ -354,226 +354,220 @@ function ret = edit (varargin)
     endif
 
     ## If editing a new file that is neither a m-file or an oct-file,
     ## just edit it.
     fileandpath = file;
     idx = rindex (file, ".");
     name = file(1:idx-1);
     ext = file(idx+1:end);
-    switch (ext)
-      case {"cc", "m"}
-        0;
-      otherwise
-        do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
-        return;
-    endswitch
+    if (! any (strcmp (ext, {"cc", "m"})))
+      ## Some unknown file.  Just open it up.
+      do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
+      return;
+    endif
 
-    ## The file doesn't exist in path so create it, put in the function
-    ## template and edit it.
+    ## The file doesn't exist in path so
+    ## create it, put in the function template, and edit it.
 
     ## Guess the email name if it was not given.
     if (isempty (FUNCTION.EMAIL))
       host = getenv ("HOSTNAME");
       if (isempty (host) && ispc ())
         host = getenv ("COMPUTERNAME");
       endif
       if (isempty (host))
-        [status, host] = system ("uname -n");
+        [~, host] = system ("uname -n");
         ## trim newline from end of hostname
         if (! isempty (host))
           host = host(1:end-1);
         endif
       endif
       if (isempty (host))
         FUNCTION.EMAIL = " ";
       else
-        FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
+        FUNCTION.EMAIL = ["<" default_user(0) "@" host ">"];
       endif
     endif
 
     ## Fill in the revision string.
     now = localtime (time);
-    revs = cstrcat ("Created: ", strftime ("%Y-%m-%d", now));
+    revs = ["Created: " strftime("%Y-%m-%d",now)];
 
     ## Fill in the copyright string.
-    copyright = cstrcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
+    copyright = [strftime("Copyright (C) %Y ",now) FUNCTION.AUTHOR];
 
     ## Fill in the author tag field.
-    author = cstrcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
+    author = ["Author: " FUNCTION.AUTHOR " " FUNCTION.EMAIL];
 
     ## Fill in the header.
     uclicense = toupper (FUNCTION.LICENSE);
     switch (uclicense)
       case "GPL"
         head = cstrcat (copyright, "\n\n", "\
-  This program is free software; you can redistribute it and/or modify\n\
-  it under the terms of the GNU General Public License as published by\n\
-  the Free Software Foundation; either version 3 of the License, or\n\
-  (at your option) any later version.\n\
-  \n\
-  This program is distributed in the hope that it will be useful,\n\
-  but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
-  GNU General Public License for more details.\n\
-  \n\
-  You should have received a copy of the GNU General Public License\n\
-  along with Octave; see the file COPYING.  If not, see\n\
-  <http://www.gnu.org/licenses/>.\
-  ");
-        tail = cstrcat (author, "\n", revs);
+This program is free software; you can redistribute it and/or modify\n\
+it under the terms of the GNU General Public License as published by\n\
+the Free Software Foundation; either version 3 of the License, or\n\
+(at your option) any later version.\n\
+\n\
+This program is distributed in the hope that it will be useful,\n\
+but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
+GNU General Public License for more details.\n\
+\n\
+You should have received a copy of the GNU General Public License\n\
+along with Octave; see the file COPYING.  If not, see\n\
+<http://www.gnu.org/licenses/>.\
+");
+        tail = [author, "\n", revs];
 
       case "BSD"
         head = cstrcat (copyright, "\n\n", "\
-  This program is free software; redistribution and use in source and\n\
-  binary forms, with or without modification, are permitted provided that\n\
-  the following conditions are met:\n\
-  \n\
-     1.Redistributions of source code must retain the above copyright\n\
-       notice, this list of conditions and the following disclaimer.\n\
-     2.Redistributions in binary form must reproduce the above copyright\n\
-       notice, this list of conditions and the following disclaimer in the\n\
-       documentation and/or other materials provided with the distribution.\n\
-  \n\
-  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n\
-  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
-  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n\
-  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
-  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
-  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
-  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
-  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
-  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
-  SUCH DAMAGE.\
-  ");
-        tail = cstrcat (author, "\n", revs);
+This program is free software; redistribution and use in source and\n\
+binary forms, with or without modification, are permitted provided that\n\
+the following conditions are met:\n\
+\n\
+   1.Redistributions of source code must retain the above copyright\n\
+     notice, this list of conditions and the following disclaimer.\n\
+   2.Redistributions in binary form must reproduce the above copyright\n\
+     notice, this list of conditions and the following disclaimer in the\n\
+     documentation and/or other materials provided with the distribution.\n\
+\n\
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n\
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n\
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
+SUCH DAMAGE.\
+");
+        tail = [author, "\n", revs];
 
       case "PD"
         head = "";
-        tail = cstrcat (author, "\n", revs, "\n\n",
-                       "This program is granted to the public domain.");
+        tail = [author, "\n", revs, "\n\n", ...
+                "This program is granted to the public domain."];
 
       otherwise
         head = "";
-        tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
-                       author, "\n", revs);
+        tail = [copyright, "\n\n", FUNCTION.LICENSE, "\n", author, "\n", revs];
     endswitch
 
     ## Generate the function template.
     exists = exist (name);
     switch (ext)
       case {"cc", "C", "cpp"}
         if (isempty (head))
-          comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
+          comment = ["/*\n\n", tail, "\n\n*/\n\n"];
         else
-          comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
+          comment = ["/*\n\n", head, "\n\n", tail, "\n\n*/\n\n"];
         endif
         ## If we are shadowing an m-file, paste the code for the m-file.
         if (any (exists == [2, 103]))
-          code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
+          code = ['\ ', strrep(type(name){1}, "\n", "\n// ")];
         else
           code = " ";
         endif
-        body = cstrcat ("#include <octave/oct.h>\n\n",
-                       "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
-                       name, "\\n\\\n\")\n{\n",
-                       "  octave_value_list retval;\n",
-                       "  int nargin = args.length ();\n\n",
-                       code, "\n  return retval;\n}\n");
+        body = ["#include <octave/oct.h>\n\n",               ...
+                "DEFUN_DLD(" name ", args, nargout, \"\\\n", ...
+                name, "\\n\\\n\")\n{\n",                     ...
+                "  octave_value_list retval;\n",             ...
+                "  int nargin = args.length ();\n\n",        ...
+                code, "\n  return retval;\n}\n"];
 
-        text = cstrcat (comment, body);
+        text = [comment, body];
       case "m"
-        ## If we are editing a function defined on the fly, paste the
-        ## code.
+        ## If we are editing a function defined on the fly, paste the code.
         if (any (exists == [2, 103]))
           body = type (name){1};
         else
-          body = cstrcat ("function [ret] = ", name, " ()\n\nendfunction\n");
+          body = ["function [retval] = " name " ()\n\nendfunction\n"];
         endif
         if (isempty (head))
-          comment = cstrcat ("## -*- texinfo -*- \n## @deftypefn {Function File}", 
-                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
-                             "## @seealso{}\n## @end deftypefn\n\n",
-                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+          comment = ["## -*- texinfo -*- \n## @deftypefn {Function File} " ...
+                     "{@var{retval} =} " name " (@var{x}, @var{y})\n##\n"  ...
+                     "## @seealso{}\n## @end deftypefn\n\n"                ...
+                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
         else
-          comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
-                             "## -*- texinfo -*- \n## @deftypefn {Function File}", 
-                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
-                             "## @seealso{}\n## @end deftypefn\n\n",
-                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+          comment = ["## " strrep(head,"\n","\n## ") "\n\n"                ...
+                     "## -*- texinfo -*- \n## @deftypefn {Function File} " ...
+                     "{@var{retval} =} " name " (@var{x} @var{y})\n##\n"   ...
+                     "## @seealso{}\n## @end deftypefn\n\n"                ...
+                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
         endif
-        text = cstrcat (comment, body);
+        text = [comment, body];
     endswitch
 
     ## Write the initial file (if there is anything to write)
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
       error ("edit: could not create %s", fileandpath);
     endif
     fputs (fid, text);
     fclose (fid);
 
     do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
             
   endif
 
 endfunction
 
-function ret = default_home ()
+function retval = default_home ()
 
-  ret = getenv ("HOME");
-  if (isempty (ret))
-    ret = glob ("~");
-    if (! isempty (ret))
-      ret = ret{1};
+  retval = getenv ("HOME");
+  if (isempty (retval))
+    retval = glob ("~");
+    if (! isempty (retval))
+      retval = retval{1};
     else
-      ret = "";
+      retval = "";
     endif
   endif
 
 endfunction
 
 ## Return the name associated with the current user ID.
 ##
 ## If LONG_FORM is 1, return the full name.  This will be the
 ## default author.  Otherwise return the login name.
 ## login@host will be the default email address.
 
-function ret = default_user (long_form)
+function retval = default_user (long_form)
 
   ent = getpwuid (getuid);
   if (! isstruct (ent))
-    ret = getenv ("USER");
-    if (isempty (ret))
-      ret = getenv ("USERNAME");
+    retval = getenv ("USER");
+    if (isempty (retval))
+      retval = getenv ("USERNAME");
     endif
   elseif (long_form)
-    ret = ent.gecos;
-    pos = strfind (ret, ",");
+    retval = ent.gecos;
+    pos = strfind (retval, ",");
     if (! isempty (pos))
-      ret = ret(1:pos-1);
+      retval = retval(1:pos-1);
     endif
   else
-    ret = ent.name;
+    retval = ent.name;
   endif
 
 endfunction
 
 function do_edit (editor, file, mode)
 
-  ## Give the hook function a chance.  If that fails, fall back
-  ## on running an editor with the system function.
+  ## Give the hook function a chance.
+  ## If that fails, fall back on running an editor with the system function.
 
   status = __octave_link_edit_file__ (file);
 
   if (! status)
-    system (sprintf (undo_string_escapes (editor),
-                     cstrcat ("\"", file, "\"")),
-            [], mode);
+    system (sprintf (undo_string_escapes (editor), ['"' file '"']), [], mode);
   endif
 
 endfunction
 
 
 %!test
 %! s.editor = edit ("get", "editor");
 %! s.home = edit ("get", "home");
diff --git a/scripts/miscellaneous/error_ids.m b/scripts/miscellaneous/error_ids.m
--- a/scripts/miscellaneous/error_ids.m
+++ b/scripts/miscellaneous/error_ids.m
@@ -39,17 +39,19 @@
 ## @item Octave:bad-alloc
 ## Indicates that memory couldn't be allocated.
 ##
 ## @item Octave:undefined-function
 ## Indicates a call to a function that is not defined.  The function may
 ## exist but Octave is unable to find it in the search path.
 ##
 ## @end table
+##
 
 
 function error_ids ()
   help ("error_ids");
 endfunction
 
 
 ## Remove from test statistics.  No real tests possible
 %!assert (1)
+
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -85,17 +85,17 @@ function f = fact ()
        "Richard Stallman wrote the HAL9000 OS.";
        "Richard Stallman's laser pointer is a lightsaber.";
        "Richard Stallman never steps down; he shifts the universe up.";
        "Richard Stallman doesn't maintain code; he stares at it until it fixes itself out of reverence.";
        "Richard Stallman doesn't use an editor; he sets the fundamental constants of the universe so that a magnetic platter with his code on it evolves itself.";
        "Richard Stallman doesnt code; he dares the computer to not do his bidding.";
        "Global warming is caused by Richard Stallman's rage towards non-free software.";
        "Rather than being birthed like a normal child, Richard Stallman instead instantiated himself polymorphically. Shortly thereafter he grew a beard.";
-       "Richard Stallman discovered extra-terrestrial life but killed them because they used non-free software.";
+       "Richard Stallman discovered extra-terrestrial life but killed them because they distributed non-free software.";
        "Richard Stallman doesn't evaluate expressions; expressions evaluate to Richard Stallman.";
        "Richard Stallman can see Russia from his house.";
        "Richard Stallman proved P=NP, twice!";
        "Richard Stallman knows of an unfixed bug in TeX.";
        "Richard Stallman can write a context-free grammar for C.";
        "Richard Stallman can determine whether an arbitrary program will terminate.";
        "Richard Stallman's computer has only two buttons. One is for guests.";
        "Richard Stallman does not actually write programs. He comes up with a length and digit index in pi.";
@@ -232,16 +232,34 @@ function f = fact ()
        "Richard Stallman pipes the Emacs binaries to /dev/dsp before he goes to sleep.";
        "When Richard Stallman counted his fingers as a kid, he always started with 0.";
        "When Richard Stallman's computer gets a virus, he simply applies a GPL license to it which converts the whole botnet to Linux. I mean, GNU/Linux.";
        "Richard Stallman's beard trimmings can cure cancer. Too bad he never shaves.";
        "Richard Stallman's doesn't kill a process; he just dares it to stay running.";
        "Richard Stallman exists because he compiled himself into being.";
        "Richard Stallman's first words were in binary. When they couldn't understand him, he wrote a parser.";
        "Richard Stallman doesn't need any codecs, he just opens a multimedia file with Emacs, and reads the bytes of the file as plain text. He then performs all the necessary decoding in his mind. But he refuses to decode files encrypted with DRM, although his mind is able to.";
+       "Richard Stallman was right. Sadly.";
+       "Richard Stallman can wiretap the NSA.";
+       "This is how Richard Stallman created Emacs: http://stallman.org/photos/rms-working/img_0631.jpg";
+       "Join Richard Stallman now and share the software, you'll be a free hacker, you'll be free!";
+       "Richard Stallman has not agreed to the terms and conditions and privacy policy because only he can actually read all of it.";
+       "Richard Stallman knows how of a backdoor to AES, but he respects your freedom and privacy too much to actually use it.";
+       "Richard Stallman will never get tired of being mocked for the foot cheese incident.";
+       "You like to release non-free software around Richard Stallman? I too like to live dangerously...";
+       "Yeah, if could just go ahead and make all software free for Richard Stallman, that'd be great, thanks.";
+       "Richard Stallman knows exactly what you mean when you talk about the cloud. But do you?";
+       "Richard Stallman satisfies Greenspun's Tenth Rule of programming, since his DNA also contains a complete implementation of all of Common Lisp.";
+       "Richard Stallman can violate the GPL. In a vulgar display of power, he once did so with the Emacs source code, but he undid the violation before most people noticed.";
+       "Good guy Richard Stallman does not try to shake you down for money. He will just kindly ask you to comply with the GPL.";
+       "Richard Stallman is in fact also a little sad that Steve Jobs is gone because it has diminished the size of the loyal opposition.";
+       "Richard Stallman can release LLVM and clang under the GPL.";
+       "No, really, Richard Stallman has a katana.";
+       "Every day Richard Stallman finds at least fifteen things in the world to rage about. You can read his findings here: http://stallman.org/archives/polnotes.html"
+       "Some of these Richard Stallman facts are completely true. Seriously.";
        };
 
   w = wisdom{randi([1, numel(wisdom)])};
   if (nargout > 0)
     f = w;
   else
     w = wordwrap (w);
     printf ("%s", w);
@@ -252,17 +270,18 @@ function out = wordwrap (w)
   cols = terminal_size ()(2);
   wc = ostrsplit (w, " ");
   out = "\n";
   i = 1;
   numwords = numel (wc);
   while (i <= numwords);
     line = wc{i};
     while (i < numwords
-           && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+           && length (newline = [line " " wc{i+1}]) < cols)
       line = newline;
       i++;
     endwhile
-    out = cstrcat (out, line, "\n");
+    out = [out, line, "\n"];
     i++;
   endwhile
-  out = cstrcat (out, "\n");
+  out = [out, "\n"];
 endfunction
+
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -34,29 +34,29 @@
 ## True if @var{file} is a system file (Windows).
 ##
 ## @item hidden
 ## True if @var{file} is a hidden file (Windows).
 ##
 ## @item directory
 ## True if @var{file} is a directory.
 ##
-## @item UserRead
+## @item  UserRead
 ## @itemx GroupRead
 ## @itemx OtherRead
 ## True if the user (group; other users) has read permission for
 ## @var{file}.
 ##
-## @item UserWrite
+## @item  UserWrite
 ## @itemx GroupWrite
 ## @itemx OtherWrite
 ## True if the user (group; other users) has write permission for
 ## @var{file}.
 ##
-## @item UserExecute
+## @item  UserExecute
 ## @itemx GroupExecute
 ## @itemx OtherExecute
 ## True if the user (group; other users) has execute permission for
 ## @var{file}.
 ## @end table
 ##
 ## If an attribute does not apply (i.e., archive on a Unix system) then
 ## the field is set to NaN.
@@ -138,8 +138,9 @@ function [status, msg, msgid] = fileattr
         msg = r;
       endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -20,48 +20,48 @@
 ## @deftypefn {Function File} {[@var{dir}, @var{name}, @var{ext}, @var{ver}] =} fileparts (@var{filename})
 ## Return the directory, name, extension, and version components of
 ## @var{filename}.
 ## @seealso{fullfile}
 ## @end deftypefn
 
 function [directory, name, extension, version] = fileparts (filename)
 
-  if (nargin == 1)
-    if (ischar (filename))
-      ds = strchr (filename, filesep ("all"), 1, "last");
-      if (isempty (ds))
-        ds = 0;
-      endif
-      es = rindex (filename, ".");
-      ## These can be the same if they are both 0 (no dir or ext).
-      if (es <= ds)
-        es = length (filename)+1;
-      endif
-      if (ds == 0)
-        directory = "";
-      elseif (ds == 1)
-        directory = filename(1);
-      else
-        directory = filename(1:ds-1);
-      endif
-      name = filename(ds+1:es-1);
-      if (es > 0 && es <= length (filename))
-        extension = filename(es:end);
-      else
-        extension = "";
-      endif
-      version = "";
-    else
-      error ("fileparts: expecting FILENAME argument to be a string");
-    endif
-  else
+  if (nargin != 1)
     print_usage ();
   endif
 
+  if (! ischar (filename) || rows (filename) > 1)
+    error ("fileparts: FILENAME must be a single string");
+  endif
+
+  ds = strchr (filename, filesep ("all"), 1, "last");
+  if (isempty (ds))
+    ds = 0;
+  endif
+  es = rindex (filename, ".");
+  ## These can be the same if they are both 0 (no dir or ext).
+  if (es <= ds)
+    es = length (filename)+1;
+  endif
+  if (ds == 0)
+    directory = "";
+  elseif (ds == 1)
+    directory = filename(1);
+  else
+    directory = filename(1:ds-1);
+  endif
+  name = filename(ds+1:es-1);
+  if (es > 0 && es <= length (filename))
+    extension = filename(es:end);
+  else
+    extension = "";
+  endif
+  version = "";
+
 endfunction
 
 
 %!test
 %! [d, n, e] = fileparts ("file");
 %! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ""));
 
 %!test
@@ -91,8 +91,14 @@ endfunction
 %!test
 %! [d, n, e] = fileparts ("/.ext");
 %! assert (strcmp (d, "/") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
 
 %!test
 %! [d, n, e] = fileparts (".ext");
 %! assert (strcmp (d, "") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
 
+%% Test input validation
+%!error fileparts ()
+%!error fileparts (1,2)
+%!error <FILENAME must be a single string> fileparts (1)
+%!error <FILENAME must be a single string> fileparts (["a"; "b"])
+
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -35,36 +35,36 @@ function filename = fullfile (varargin)
       endif
       for i = 2:nargs
         tmp = varargin{i};
         if (i < nargs && strcmp (tmp(end), filesep))
           tmp(end) = "";
         elseif (i == nargs && strcmp (tmp, filesep))
           tmp = "";
         endif
-        filename = cstrcat (filename, filesep, tmp);
+        filename = [filename filesep tmp];
       endfor
     elseif (nargs == 1)
       filename = varargin{1};
     else
       filename = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!shared fs, fsx, xfs, fsxfs, xfsy
 %! fs = filesep ();
-%! fsx = cstrcat (fs, "x");
-%! xfs = cstrcat ("x", fs);
-%! fsxfs = cstrcat (fs, "x", fs);
-%! xfsy = cstrcat ("x", fs, "y");
+%! fsx = [fs "x"];
+%! xfs = ["x" fs];
+%! fsxfs = [fs "x" fs];
+%! xfsy = ["x" fs "y"];
 %!assert (fullfile (""), "")
 %!assert (fullfile (fs), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile (fs, ""), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile ("x"), "x")
 %!assert (fullfile ("", "x"), "x")
 %!assert (fullfile ("x", ""), "x")
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -18,16 +18,18 @@
 ## @deftypefn  {Function File} {@var{value} =} getappdata (@var{h}, @var{name})
 ## @deftypefnx {Function File} {@var{appdata} =} getappdata (@var{h})
 ## 
 ## Return the @var{value} for named application data for the object(s) with
 ## handle(s) @var{h}.
 ## 
 ## @code{getappdata(@var{h})} returns a structure, @var{appdata}, whose fields
 ## correspond to the appdata properties.
+##
+## @seealso{setappdata, guidata, get, set, getpref, setpref}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function val = getappdata (h, name)
 
   if (all (ishandle (h)) && nargin == 2 && ischar (name))
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -36,8 +36,9 @@ function varargout = gunzip (gzfile, dir
   if (nargout > 0)
     varargout = cell (1, nargout);
     [varargout{:}] = unpack (gzfile, dir, mfilename ());
   else
     unpack (gzfile, dir, mfilename ());
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
-## Each file is compressed separately and a new file with a ".gz" extension
-## is created.  The original files are not modified.  Existing compressed
-## files are silently overwritten.  If @var{outdir} is defined the compressed
-## files are placed in this directory.
+## Each file is compressed separately and a new file with a @file{".gz"}
+## extension is created.  The original files are not modified.  Existing
+## compressed files are silently overwritten.  If @var{outdir} is defined the
+## compressed files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin != 1 && nargin != 2) || (nargout > 1)
     print_usage ();
   endif
 
@@ -37,17 +37,17 @@ function entries = gzip (varargin)
   else
     entries = __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   endif
 
 endfunction
 
 
 %!xtest
-%! # test gzip together with gunzip
+%! ## test gzip together with gunzip
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
 %!   dirname  = tmpnam;
 %!   mkdir (dirname);
 %!   entry = gzip (filename, dirname);
 %!   [path, basename, extension] = fileparts (filename);
diff --git a/scripts/miscellaneous/isdeployed.m b/scripts/miscellaneous/isdeployed.m
--- a/scripts/miscellaneous/isdeployed.m
+++ b/scripts/miscellaneous/isdeployed.m
@@ -25,8 +25,9 @@
 ## @end deftypefn
 
 function retval = isdeployed ()
   retval = false;
 endfunction
 
 
 %!assert (isdeployed (), false)
+
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -31,8 +31,9 @@ function retval = ismac ()
   endif
 
 endfunction
 
 
 %!assert (islogical (ismac ()))
 
 %!error ismac (1)
+
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -41,21 +41,21 @@
 ## insensitive and only the first 27 characters are checked.
 ##
 ## @code{license ("test", @var{feature}, @var{toggle})}
 ##
 ## Enable or disable license testing for @var{feature}, depending on
 ## @var{toggle}, which may be one of:
 ##
 ## @table @asis
-## @item "enable"
+## @item @qcode{"enable"}
 ## Future tests for the specified license of @var{feature} are conducted
 ## as usual.
 ##
-## @item "disable"
+## @item @qcode{"disable"}
 ## Future tests for the specified license of @var{feature} return 0.
 ## @end table
 ##
 ## @code{@var{retval} = license ("checkout", @var{feature})}
 ##
 ## Check out a license for @var{feature}, returning 1 on success and 0
 ## on failure.
 ##
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -27,17 +27,17 @@
 ##      @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
 ##      @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m
 ## @end group
 ## @end example
 ##
 ## The @code{dir} and @code{ls} commands are implemented by calling your
 ## system's directory listing command, so the available options may vary
 ## from system to system.
-## @seealso{dir, stat, readdir, glob, filesep, ls_command}
+## @seealso{dir, readdir, glob, what, stat, filesep, ls_command}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = ls (varargin)
 
   global __ls_command__;
 
diff --git a/scripts/miscellaneous/mex.m b/scripts/miscellaneous/mex.m
--- a/scripts/miscellaneous/mex.m
+++ b/scripts/miscellaneous/mex.m
@@ -12,18 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} mex [options] file @dots{}
+## @deftypefn {Command} {} mex [options] file @dots{}
 ## Compile source code written in C, C++, or Fortran, to a MEX file.
 ## This is equivalent to @code{mkoctfile --mex [options] file}.
 ## @seealso{mkoctfile}
 ## @end deftypefn
 
 function mex (varargin)
   args = {"--mex", varargin{:}};
   mkoctfile (args{:});
 endfunction
+
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -23,8 +23,9 @@
 ## @end deftypefn
 
 function retval = mexext ()
   retval = "mex";
 endfunction
 
 
 %!assert (mexext (), "mex")
+
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -41,17 +41,17 @@
 ## Add the definition DEF to the compiler call.
 ##
 ## @item -l LIB
 ## Add the library LIB to the link command.
 ##
 ## @item -L DIR
 ## Add the library directory DIR to the link command.
 ##
-## @item -M
+## @item  -M
 ## @itemx --depend
 ## Generate dependency files (.d) for C and C++ source files.
 ##
 ## @item -R DIR
 ## Add the run-time path to the link command.
 ##
 ## @item @nospell{-Wl,@dots{}}
 ## Pass flags though the linker like @nospell{"-Wl,-rpath=@dots{}"}.
@@ -62,65 +62,65 @@
 ## Pass flags though the compiler like @nospell{"-Wa,OPTION"}.
 ##
 ## @item -c
 ## Compile but do not link.
 ##
 ## @item -g
 ## Enable debugging options for compilers.
 ##
-## @item -o FILE
+## @item  -o FILE
 ## @itemx --output FILE
 ## Output file name.  Default extension is .oct
 ## (or .mex if @samp{--mex} is specified) unless linking
 ## a stand-alone executable.
 ##
-## @item -p VAR
+## @item  -p VAR
 ## @itemx --print VAR
 ## Print the configuration variable VAR@.  Recognized variables are:
 ##
 ## @example
 ##    ALL_CFLAGS                FFTW3F_LIBS
 ##    ALL_CXXFLAGS              FLIBS
 ##    ALL_FFLAGS                FPICFLAG
 ##    ALL_LDFLAGS               INCFLAGS
 ##    BLAS_LIBS                 LAPACK_LIBS
 ##    CC                        LDFLAGS
 ##    CFLAGS                    LD_CXX
 ##    CPICFLAG                  LD_STATIC_FLAG
 ##    CPPFLAGS                  LFLAGS
-##    CXX                       LIBOCTAVE       
-##    CXXFLAGS                  LIBOCTINTERP    
-##    CXXPICFLAG                LIBS            
-##    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS     
+##    CXX                       LIBOCTAVE
+##    CXXFLAGS                  LIBOCTINTERP
+##    CXXPICFLAG                LIBS
+##    DEPEND_EXTRA_SED_PATTERN  OCTAVE_LIBS
 ##    DEPEND_FLAGS              OCTAVE_LINK_DEPS
-##    DL_LD                     OCT_LINK_DEPS   
-##    DL_LDFLAGS                RDYNAMIC_FLAG   
-##    EXEEXT                    READLINE_LIBS   
-##    F77                       SED             
-##    F77_INTEGER_8_FLAG        XTRA_CFLAGS     
-##    FFLAGS                    XTRA_CXXFLAGS   
-##    FFTW3_LDFLAGS             
+##    DL_LD                     OCT_LINK_DEPS
+##    DL_LDFLAGS                RDYNAMIC_FLAG
+##    EXEEXT                    READLINE_LIBS
+##    F77                       SED
+##    F77_INTEGER_8_FLAG        XTRA_CFLAGS
+##    FFLAGS                    XTRA_CXXFLAGS
+##    FFTW3_LDFLAGS
 ##    FFTW3_LIBS
 ##    FFTW3F_LDFLAGS
 ##
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
 ## @item --mex
 ## Assume we are creating a MEX file.  Set the default output extension
 ## to ".mex".
 ##
-## @item -s
+## @item  -s
 ## @itemx --strip
 ## Strip the output file.
 ##
-## @item -v
+## @item  -v
 ## @itemx --verbose
 ## Echo commands as they are executed.
 ##
 ## @item file
 ## The file to compile or link.  Recognized file types are
 ##
 ## @example
 ## @group
@@ -141,29 +141,31 @@
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
-  cmd = cstrcat ("\"", shell_script, "\"");
+  if (! exist (shell_script, "file"))
+    __gripe_missing_component__ ("mkoctfile", "mkoctfile");
+  endif
+
+  cmd = ['"' shell_script '"'];
   for i = 1:nargin
-    cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
+    cmd = [cmd ' "' varargin{i} '"'];
   endfor
 
   [sys, out] = system (cmd);
 
   if (nargout > 0)
     [output, status] = deal (out, sys);
   else
     printf ("%s", out);
   endif
 
-  if (sys == 127)
-    warning ("unable to find mkoctfile in expected location: '%s'",
-             shell_script);
-
+  if (sys != 0)
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -13,16 +13,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/cast.m \
   miscellaneous/citation.m \
   miscellaneous/comma.m \
   miscellaneous/compare_versions.m \
   miscellaneous/computer.m \
   miscellaneous/copyfile.m \
   miscellaneous/debug.m \
   miscellaneous/delete.m \
+  miscellaneous/desktop.m \
   miscellaneous/dir.m \
   miscellaneous/dos.m \
   miscellaneous/dump_prefs.m \
   miscellaneous/edit.m \
   miscellaneous/error_ids.m \
 	miscellaneous/fact.m \
   miscellaneous/fileattrib.m \
   miscellaneous/fileparts.m \
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -12,117 +12,128 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} movefile (@var{f1}, @var{f2})
-## @deftypefnx {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} movefile (@var{f1}, @var{f2}, 'f')
-## Move the file @var{f1} to the new name @var{f2}.  The name @var{f1}
-## may contain globbing patterns.  If @var{f1} expands to multiple file
-## names, @var{f2} must be a directory.  If the force flag 'f' is given
-## then any existing files will be overwritten without prompting.
+## @deftypefn  {Function File} {} movefile (@var{f1})
+## @deftypefnx {Function File} {} movefile (@var{f1}, @var{f2})
+## @deftypefnx {Function File} {} movefile (@var{f1}, @var{f2}, 'f')
+## @deftypefnx {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} movefile (@dots{})
+## Move the file @var{f1} to the destination @var{f2}.
 ##
-## If successful, @var{status} is 1, with @var{msg} and @var{msgid} empty
-## character strings.  Otherwise, @var{status} is 0, @var{msg} contains a
-## system-dependent error message, and @var{msgid} contains a unique
-## message identifier.
-## @seealso{rename, copyfile}
+## The name @var{f1} may contain globbing patterns.  If @var{f1} expands to
+## multiple file names, @var{f2} must be a directory.  If no destination
+## @var{f2} is specified then the destination is the present working directory.
+## If @var{f2} is a file name then @var{f1} is renamed to @var{f2}.
+## When the force flag @qcode{'f'} is given any existing files will be
+## overwritten without prompting.
+##
+## If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty
+## character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a
+## system-dependent error message, and @var{msgid} contains a unique message
+## identifier.  Note that the status code is exactly opposite that of the
+## @code{system} command.
+## @seealso{rename, copyfile, unlink, delete, glob}
 ## @end deftypefn
 
 function [status, msg, msgid] = movefile (f1, f2, force)
 
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  endif
+
   max_cmd_line = 1024;
   status = true;
   msg = "";
   msgid = "";
 
-  ## FIXME -- maybe use the same method as in ls to allow users control
+  ## FIXME: maybe use the same method as in ls to allow users control
   ## over the command that is executed.
 
   if (ispc () && ! isunix ()
       && isempty (file_in_path (getenv ("PATH"), "mv.exe")))
     ## Windows.
     cmd = "cmd /C move";
     cmd_force_flag = "/Y";
   else
     cmd = "mv";
     cmd_force_flag = "-f";
   endif
 
-  if (nargin == 2 || nargin == 3)
-    ## Input type check.
-    if (! (ischar (f1) || iscellstr (f1)))
-      error ("movefile: first argument must be a character string or a cell array of character strings");
-    endif
-
-    if (! ischar (f2))
-      error ("movefile: second argument must be a character string");
-    endif
+  ## Input type check.
+  if (! (ischar (f1) || iscellstr (f1)))
+    error ("movefile: F1 must be a character string or a cell array of character strings");
+  endif
 
-    if (nargin == 3 && strcmp (force, "f"))
-      cmd = cstrcat (cmd, " ", cmd_force_flag);
-    endif
+  if (nargin == 1)
+    f2 = pwd ();
+  elseif (! ischar (f2))
+    error ("movefile: F2 must be a character string");
+  endif
 
-    ## If f1 isn't a cellstr convert it to one.
-    if (ischar (f1))
-      f1 = cellstr (f1);
-    endif
+  if (nargin == 3 && strcmp (force, "f"))
+    cmd = [cmd " " cmd_force_flag];
+  endif
 
-    ## If f1 has more than 1 element f2 must be a directory
-    isdir = (exist (f2, "dir") != 0);
-    if (length (f1) > 1 && ! isdir)
-      error ("movefile: when moving multiple files, second argument must be a directory");
-    endif
+  ## If f1 isn't a cellstr convert it to one.
+  if (ischar (f1))
+    f1 = cellstr (f1);
+  endif
 
-    ## Protect the file name(s).
-    f1 = glob (f1);
-    if (isempty (f1))
-      error ("movefile: no files to move");
-    endif
-    p1 = sprintf ("\"%s\" ", f1{:});
-    p2 = tilde_expand (f2);
+  ## If f1 has more than 1 element f2 must be a directory
+  isdir = (exist (f2, "dir") != 0);
+  if (length (f1) > 1 && ! isdir)
+    error ("movefile: when moving multiple files, F2 must be a directory");
+  endif
 
-    if (isdir && length (p1) > max_cmd_line)
-      l2 = length (p2) + length (cmd) + 6;
-      while (! isempty (f1))
-        p1 = sprintf ("\"%s\" ", f1{1});
+  ## Protect the file name(s).
+  f1 = glob (f1);
+  if (isempty (f1))
+    error ("movefile: no files to move");
+  endif
+  p1 = sprintf ('"%s" ', f1{:});
+  p2 = tilde_expand (f2);
+
+  if (isdir && length (p1) > max_cmd_line)
+    l2 = length (p2) + length (cmd) + 6;
+    while (! isempty (f1))
+      p1 = sprintf ('"%s" ', f1{1});
+      f1(1) = [];
+      while (! isempty (f1)
+             && (length (p1) + length (f1{1}) + l2 < max_cmd_line))
+        p1 = sprintf ('%s"%s" ', p1, f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length (p1) + length (f1{1}) + l2 <
-                                 max_cmd_line))
-          p1 = sprintf ("%s\"%s\" ", p1, f1{1});
-          f1(1) = [];
-        endwhile
+      endwhile
 
-        if (ispc () && ! isunix ()
-            && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
-          p1 = strrep (p1, "\\", "/");
-          p2 = strrep (p2, "\\", "/");
-        endif
-
-        ## Move the file(s).
-        [err, msg] = system (sprintf ("%s %s \"%s\"", cmd, p1, p2));
-        if (err < 0)
-          status = false;
-          msgid = "movefile";
-        endif
-      endwhile
-    else
       if (ispc () && ! isunix ()
           && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
-        p1 = strrep (p1, "\\", "/");
-        p2 = strrep (p2, "\\", "/");
+        p1 = strrep (p1, '\', '/');
+        p2 = strrep (p2, '\', '/');
       endif
 
       ## Move the file(s).
-      [err, msg] = system (sprintf ("%s %s \"%s\"", cmd, p1, p2));
-      if (err < 0)
+      [err, msg] = system (sprintf ('%s %s "%s"', cmd, p1, p2));
+      if (err != 0)
         status = false;
         msgid = "movefile";
       endif
-    endif
+    endwhile
   else
-    print_usage ();
+    if (ispc () && ! isunix ()
+        && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
+      p1 = strrep (p1, '\', '/');
+      p2 = strrep (p2, '\', '/');
+    endif
+
+    ## Move the file(s).
+    [err, msg] = system (sprintf ('%s %s "%s"', cmd, p1, p2));
+    if (err != 0)
+      status = false;
+      msgid = "movefile";
+    endif
   endif
+
 endfunction
+
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -27,8 +27,9 @@
 ## @end deftypefn
 
 function n = namelengthmax ()
   n = 63;
 endfunction
 
 
 %!assert (namelengthmax (), 63)
+
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -35,8 +35,9 @@ function news (package = "octave")
   endif
 
 endfunction
 
 
 %!error news (1, 2)
 %!error <news: PACKAGE must be a string> news (1)
 %!error <news: package .* is not installed> news ("__NOT_A_VALID_PKG_NAME__")
+
diff --git a/scripts/miscellaneous/pack.m b/scripts/miscellaneous/pack.m
--- a/scripts/miscellaneous/pack.m
+++ b/scripts/miscellaneous/pack.m
@@ -22,8 +22,9 @@
 ## compatibility, but does nothing in Octave.
 ## @end deftypefn
 
 ## Author: jwe
 
 function pack ()
 
 endfunction
+
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -35,18 +35,18 @@
 ## prop =
 ## @{
 ##   [1,1] = linewidth
 ##   [1,2] = 10
 ## @}
 ## @end group
 ## @end example
 ##
-## The parseparams function may be used to separate "regular"
-## arguments and additional arguments given as property/value pairs of
+## The parseparams function may be used to separate regular numeric
+## arguments from additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
 ## When called from an m-file function, the error is prefixed with the
 ## name of the caller function.
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -36,15 +36,16 @@ function [output, status] = perl (script
   if (ischar (scriptfile)
       && (   (nargin == 1 && ! isempty (scriptfile))
           || (nargin != 1 && iscellstr (varargin))))
     if (! strcmp (scriptfile(1:2), "-e"))
       ## Attempt to find file in loadpath.  No effect for absolute filenames.
       scriptfile = file_in_loadpath (scriptfile);
     endif
 
-    [status, output] = system (cstrcat ("perl ", scriptfile,
-                                        sprintf (" %s", varargin{:})));
+    [status, output] = system (["perl " scriptfile ...
+                                sprintf(" %s", varargin{:})]);
   else
     error ("perl: invalid arguments");
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -28,24 +28,16 @@
 ## is compressed separately and a new file with the extension @var{extension}
 ## is created and placed into the directory @var{outdir}. The original files
 ## are not touched. Existing compressed files are silently overwritten.
 ## This is an internal function. Do not use directly.
 
 function entries = __xzip__ (commandname, extension,
                              commandtemplate, files, outdir)
 
-  if (nargin != 4 && nargin != 5)
-    print_usage ();
-  endif
-
-  if (! ischar (extension) || length (extension) == 0)
-    error ("__xzip__: EXTENSION must be a string with finite length");
-  endif
-
   if (nargin == 5 && ! exist (outdir, "dir"))
     error ("__xzip__: OUTDIR output directory does not exist");
   endif
 
   if (ischar (files))
     files = cellstr (files);
   endif
   if (! iscellstr (files))
@@ -111,16 +103,17 @@ function [d, f] = myfileparts (files)
   [d, f, ext] = cellfun ("fileparts", files, "uniformoutput", false);
   f = cellfun (@(x, y) sprintf ("%s%s", x, y), f, ext,
                "uniformoutput", false);
   idx = cellfun ("isdir", files);
   d(idx) = "";
   f(idx) = files(idx);
 endfunction
 
+
 ## FIXME -- reinstate these tests if we invent a way to test private
 ## functions directly.
 ##
 ## %!error <extension has to be a string with finite length>
 ## %!  __xzip__ ("gzip", "", "gzip -r %s", "bla");
 ## %!error <no files to move>
 ## %!  __xzip__ ("gzip", ".gz", "gzip -r %s", tmpnam);
 ## %!error <command failed with exit status>
@@ -132,8 +125,9 @@ endfunction
 ## %!    dirname  = tmpnam;
 ## %!    mkdir (dirname);
 ## %!    entry = __xzip__ ("gzip", ".gz", "xxxzipxxx -r %s 2>/dev/null",
 ## %!                     filename, dirname);
 ## %!  unwind_protect_cleanup
 ## %!    delete (filename);
 ## %!    rmdir (dirname);
 ## %!  end_unwind_protect
+
diff --git a/scripts/miscellaneous/private/display_info_file.m b/scripts/miscellaneous/private/display_info_file.m
--- a/scripts/miscellaneous/private/display_info_file.m
+++ b/scripts/miscellaneous/private/display_info_file.m
@@ -16,20 +16,16 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## news() and citation() are very much alike. They both do the same thing, just
 ## for different files. This function does all the work.
 
 function display_info_file (func, package, file)
 
-  if (nargin != 3)
-    print_usage ();
-  endif
-
   if (! ischar (package))
     error ("%s: PACKAGE must be a string", func);
   endif
 
   if (strcmpi (package, "octave"))
     octetcdir = octave_config_info ("octetcdir");
     filepath  = fullfile (octetcdir, file);
   else
@@ -52,8 +48,9 @@ function display_info_file (func, packag
 
   fid = fopen (filepath, "r");
   while (ischar (line = fgets (fid)))
     puts (line);
   endwhile
   fclose (fid);
 
 endfunction
+
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -35,15 +35,16 @@ function [output, status] = python (scri
   if (ischar (scriptfile)
       && (   (nargin == 1 && ! isempty (scriptfile))
           || (nargin != 1 && iscellstr (varargin))))
     if (! strcmp (scriptfile(1:2), "-c"))
       ## Attempt to find file in loadpath.  No effect for absolute filenames.
       scriptfile = file_in_loadpath (scriptfile);
     endif
 
-    [status, output] = system (cstrcat ("python ", scriptfile,
-                                        sprintf (" %s", varargin{:})));
+    [status, output] = system (["python ", scriptfile, ...
+                                sprintf(" %s", varargin{:})]);
   else
     error ("python: invalid arguments");
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -40,16 +40,17 @@ function rmappdata (h, varargin)
         endif
       endfor
       set (h(nh), "__appdata__", appdata);
     endif
   endfor
 
 endfunction
 
+
 %!test
 %! setappdata (0, "hello", "world");
 %! rmappdata (0, "hello");
 %! assert (isappdata (0, "hello"), false);
 
 %!test
 %! setappdata (0, "data1", rand (3));
 %! setappdata (0, "data2", {"hello", "world"});
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -34,17 +34,17 @@ function run (script)
   endif
 
   [d, f, ext] = fileparts (script);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
         cd (d);
-        if (! exist (cstrcat (f, ext), "file"))
+        if (! exist ([f ext], "file"))
           error ("run: file SCRIPT must exist and be a valid Octave scriptfile");
         endif
         evalin ("caller", sprintf ("source (\"%s%s\");", f, ext),
                 "rethrow (lasterror ())");
       unwind_protect_cleanup
         cd (wd);
       end_unwind_protect
     else
@@ -54,8 +54,9 @@ function run (script)
     if (exist (script, "file"))
       evalin ("caller", sprintf ("source (\"%s\");", script),
               "rethrow (lasterror ())");
     else
       error ("run: %s not found", script);
     endif
   endif
 endfunction
+
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -14,16 +14,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} setappdata (@var{h}, @var{name}, @var{value})
 ## Set the named application data to @var{value} for the object(s) with
 ## handle(s) @var{h}.  If the application data with the specified name does
 ## not exist, it is created.
+## @seealso{getappdata, guidata, get, set, getpref, setpref}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function setappdata (h, varargin)
 
   if (! (all (ishandle (h)) && mod (numel (varargin), 2) == 0))
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -38,17 +38,17 @@
 ## @var{s}.("foo bar") = 42;
 ## @end example
 ##
 ## @noindent
 ## Note that ordinary structure syntax @code{@var{s}.foo bar = 42} cannot be
 ## used here, as the field name is not a valid Octave identifier.  Using
 ## arbitrary strings for field name is incompatible with @sc{matlab}, so
 ## this usage will warn if the @code{Octave:matlab-incompatible} warning
-## is set.  @xref{docXwarning_ids}.
+## is set.  @xref{XREFwarning_ids}.
 ##
 ## With the second calling form, set a field on a structure array,
 ## possibly nested, with successive nested indices @var{idx1},
 ## @var{idx2}, @dots{} and fields @var{field1}, @var{field2}, @dots{}
 ## The indices must be cells containing the desired index at this
 ## nesting depth.
 ##
 ## Thus consider instead,
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2012 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -25,17 +25,17 @@
 ## The optional argument @var{root} changes the relative path of @var{files}
 ## from the current directory.
 ##
 ## If an output argument is requested the entries in the archive are
 ## returned in a cell array.
 ## @seealso{untar, bzip2, gzip, zip}
 ## @end deftypefn
 
-## Author: Sren Hauberg <hauberg@gmail.com>
+## Author: Sren Hauberg <hauberg@gmail.com>
 
 function entries = tar (tarfile, files, root = ".")
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (ischar (files))
@@ -59,8 +59,9 @@ function entries = tar (tarfile, files, 
     if (output(end) == "\n")
       output(end) = [];
     endif
     entries = ostrsplit (output, "\n");
     entries = entries';
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -24,17 +24,17 @@
 function dirname = tempdir ()
 
   dirname = getenv ("TMPDIR");
   if (isempty (dirname))
     dirname = P_tmpdir;
   endif
 
   if (! strcmp (dirname(end), filesep))
-    dirname = cstrcat (dirname, filesep);
+    dirname = [dirname filesep];
   endif
 
   if (! isdir (dirname))
     warning ("tempdir: '%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/tempname.m b/scripts/miscellaneous/tempname.m
--- a/scripts/miscellaneous/tempname.m
+++ b/scripts/miscellaneous/tempname.m
@@ -28,8 +28,9 @@ function filename = tempname (varargin)
 
   filename = tmpnam (varargin{:});
 
 endfunction
 
 
 %% No tests needed for alias.
 %!assert (1)
+
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} unix ("@var{command}")
 ## @deftypefnx {Function File} {@var{status} =} unix ("@var{command}")
 ## @deftypefnx {Function File} {[@var{status}, @var{text}] =} unix ("@var{command}")
 ## @deftypefnx {Function File} {[@dots{}] =} unix ("@var{command}", "-echo")
 ## Execute a system command if running under a Unix-like operating
 ## system, otherwise do nothing.  Return the exit status of the program
 ## in @var{status} and any output from the command in @var{text}.
-## When called with no output argument, or the "-echo" argument is
+## When called with no output argument, or the @qcode{"-echo"} argument is
 ## given, then @var{text} is also sent to standard output.
 ## @seealso{dos, system, isunix, ispc}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = unix (command, echo_arg)
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -70,87 +70,91 @@ function filelist = unpack (file, dir = 
       error ("unpack: FILETYPE must be gunzip for a directory");
     endif
     ext = ".gz";
   else
     [pathstr, name, ext] = fileparts (file);
 
     ## Check to see if it's .tar.gz, .tar.Z, etc.
     if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
-      [tmppathstr, tmpname, tmpext] = fileparts (name);
+      [~, tmpname, tmpext] = fileparts (name);
       if (strcmpi (tmpext, ".tar"))
         name = tmpname;
-        ext = cstrcat (tmpext, ext);
+        ext = [tmpext ext];
       endif
     endif
 
     ## If the file is a URL, download it and then work with that file.
     if (! isempty (strfind (file, "://")))
       ## FIXME -- the above is not a perfect test for a URL
       urlfile = file;
       ## FIXME -- should we name the file that we download with the
       ## same file name as the URL requests?
-      tmpfile = cstrcat (tmpnam (), ext);
+      tmpfile = [tmpnam() ext];
       [file, success, msg] = urlwrite (urlfile, tmpfile);
       if (! success)
-        error ("unpack: could not get \"%s\": %s", urlfile, msg);
+        error ('unpack: could not get "%s": %s', urlfile, msg);
       endif
     endif
 
   endif
 
   ## canonicalize_file_name returns empty if the file isn't found, so
   ## use that to check for existence.
   cfile = canonicalize_file_name (file);
 
   if (isempty (cfile))
-    error ("unpack: file \"%s\" not found", file);
+    error ('unpack: file "%s" not found', file);
   else
     file = cfile;
   endif
 
   ## Instructions on what to do for any extension.
   ##
   ## The field names are the file extension without periods.
   ## The first cell is what is executed to unpack an archive verbosely.
   ## The second cell is what is executed to unpack an archive quietly.
-  ## The third cell is the function to execute on output to get the
-  ##   files list.
+  ## The third cell is the function to execute on output to get the files list.
   ## The fourth cell indicates if the files may need to be manually moved
-  ##   (i.e. tar and unzip decompress into the current directory while
-  ##   bzip2 and gzip decompress the file at its location).
+  ##   (i.e., tar and unzip decompress into the current directory while
+  ##    bzip2 and gzip decompress the file at its location).
   persistent commandlist;
   if (isempty (commandlist))
-    commandlist.gz = {"gzip -d -v -r \"%s\"", ...
-                      "gzip -d -r \"%s\"", ...
+    commandlist.gz = {'gzip -d -v -r "%s"', ...
+                      'gzip -d -r "%s"', ...
                       @__parse_gzip__, true};
     commandlist.z = commandlist.gz;
-    commandlist.bz2 = {"bzip2 -d -v \"%s\"", ...
-                       "bzip2 -d \"%s\"", ...
+    commandlist.bz2 = {'bzip2 -d -v "%s"', ...
+                       'bzip2 -d "%s"', ...
                        @__parse_bzip2__, true};
     commandlist.bz = commandlist.bz2;
-    commandlist.tar = {"tar xvf \"%s\"", ...
-                       "tar xf \"%s\"", ...
+    commandlist.tar = {'tar xvf "%s"', ...
+                       'tar xf "%s"', ...
                        @__parse_tar__, false};
-    commandlist.targz = {"gzip -d -c \"%s\" | tar xvf -", ...
-                         "gzip -d -c \"%s\" | tar xf -", ...
+    commandlist.targz = {'gzip -d -c "%s" | tar xvf -', ...
+                         'gzip -d -c "%s" | tar xf -', ...
                          @__parse_tar__, false};
     commandlist.tgz = commandlist.targz;
-    commandlist.tarbz2 = {"bzip2 -d -c \"%s\" | tar xvf -", ...
-                          "bzip2 -d -c \"%s\" | tar xf -", ...
+    commandlist.tarbz2 = {'bzip2 -d -c "%s" | tar xvf -', ...
+                          'bzip2 -d -c "%s" | tar xf -', ...
                           @__parse_tar__, false};
     commandlist.tarbz = commandlist.tarbz2;
     commandlist.tbz2 = commandlist.tarbz2;
     commandlist.tbz = commandlist.tarbz2;
-    commandlist.zip = {"unzip \"%s\"", ...
-                       "unzip -q \"%s\"", ...
+    commandlist.zip = {'unzip -n "%s"', ...
+                       'unzip -nq "%s"', ...
                        @__parse_zip__, false};
   endif
 
-  nodotext = ext(! ismember (ext, "."));
+  ## Unzip doesn't actually care about the extension
+  if (strcmp (filetype, "unzip"))
+    nodotext = "zip";
+  else
+    nodotext = ext(ext != '.');
+  endif
 
   origdir = pwd ();
 
   if (isfield (commandlist, nodotext))
     [commandv, commandq, parser, move] = deal (commandlist.(nodotext){:});
     cstartdir = canonicalize_file_name (origdir);
     cenddir = canonicalize_file_name (dir);
     needmove = move && ! strcmp (cstartdir, cenddir);
@@ -173,40 +177,39 @@ function filelist = unpack (file, dir = 
       error ("unpack: mkdir failed to create %s: %s", dir, msg);
     endif
   elseif (! S_ISDIR (s.mode))
     error ("unpack: %s: not a directory", dir);
   endif
 
   unwind_protect
     cd (dir);
-    [status, output] = system (sprintf (cstrcat (command, " 2>&1"), file));
+    [status, output] = system (sprintf ([command " 2>&1"], file));
   unwind_protect_cleanup
     cd (origdir);
   end_unwind_protect
 
   if (status)
     error ("unpack: unarchiving program exited with status: %d\n%s",
            status, output);
   endif
 
   if (nargout > 0 || needmove)
-    ## Trim the last cr if needed.
+    ## Trim the last CR if needed.
     ## FIXME -- will this need to change to a check for "\r\n" for windows?
-    if (output(length (output)) == "\n")
-      output(length (output)) = [];
+    if (output(end) == "\n")
+      output(end) = [];
     endif
     files = parser (ostrsplit (output, "\n"))';
 
     ## Move files if necessary
     if (needmove)
-      [st, msg, msgid] = movefile (files, dir);
+      [st, msg, ~] = movefile (files, dir);
       if (! st)
-        error ("unpack: unable to move files to \"%s\": %s",
-               dir, msg);
+        error ('unpack: unable to move files to "%s": %s', dir, msg);
       endif
 
       ## Fix the names for the files since they were moved.
       for i = 1:numel (files)
         files{i} = strrep (files{i}, cstartdir, cenddir);
       endfor
     endif
 
@@ -217,59 +220,32 @@ function filelist = unpack (file, dir = 
   endif
 
 endfunction
 
 function files = __parse_zip__ (output)
   ## Parse the output from zip and unzip.
 
   ## Skip first line which is Archive header
-  output(1) = [];
-  for i = 1:length (output)
-    files{i} = output{i}(14:length (output{i}));
-  endfor
+  files = char (output(2:end));
+  ## Trim constant width prefix and return cell array
+  files = cellstr (files(:,14:end))
 endfunction
 
 function output = __parse_tar__ (output)
-  ## This is a noop, but it makes things simpler for other cases.
+  ## This is a no-op, but it makes things simpler for other cases.
 endfunction
 
 function files = __parse_gzip__ (output)
   ## Parse the output from gzip and gunzip returning the files
   ## commpressed (or decompressed).
 
-  files = {};
-  ## The middle ": " should indicate a good place to start looking for
-  ## the filename.
-  for i = 1:length (output)
-    colons = strfind (output{i}, ":");
-    if (isempty (colons))
-      warning ("unpack:parsing",
-               "Unable to parse line (gzip missing colon):\n%s", output{i});
-    else
-      midcolon = colons(ceil (length (colons)/2));
-      thisstr = output{i}(midcolon+2:length (output{i}));
-      idx = index (thisstr, "with") + 5;
-      if (isempty (idx))
-        warning ("unpack:parsing",
-                 "Unable to parse line (gzip missing with):\n%s", output{i});
-      else
-        files{i} = thisstr(idx:length (thisstr));
-      endif
-    endif
-  endfor
+  files = regexprep (output, '^.+ with (.*)$', '$1');
 endfunction
 
 function files = __parse_bzip2__ (output)
   ## Parse the output from bzip2 and bunzip2 returning the files
   ## commpressed (or decompressed).
 
-  files = {};
-  for i = 1:length (output)
-    ## the -5 is to remove the ".bz2:"
-    endoffilename = rindex (output{i}, ": ") - 5;
-    if (isempty (endoffilename))
-      warning ("unpack:parsing", "Unable to parse line:\n%s", output{i});
-    else
-      files{i} = output{i}(3:endoffilename);
-    endif
-  endfor
+  ## Strip leading blanks and .bz2 extension from file name
+  files = regexprep (output, '^\s+(.*)\.bz2: .*', '$1');
 endfunction
+
diff --git a/scripts/miscellaneous/untar.m b/scripts/miscellaneous/untar.m
--- a/scripts/miscellaneous/untar.m
+++ b/scripts/miscellaneous/untar.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2012 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,25 +19,26 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} untar (@var{tarfile})
 ## @deftypefnx {Function File} {} untar (@var{tarfile}, @var{dir})
 ## Unpack the TAR archive @var{tarfile} to the directory @var{dir}.
 ## If @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{tar, unpack, bunzip2, gunzip, unzip}
 ## @end deftypefn
 
-## Author: Sren Hauberg <hauberg@gmail.com>
+## Author: Sren Hauberg <hauberg@gmail.com>
 ## Adapted-By: jwe, Bill Denney
 
 function varargout = untar (tarfile, dir = ".")
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargout > 0)
     varargout = cell (1, nargout);
     [varargout{:}] = unpack (tarfile, dir, mfilename ());
   else
     unpack (tarfile, dir, mfilename ());
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/unzip.m b/scripts/miscellaneous/unzip.m
--- a/scripts/miscellaneous/unzip.m
+++ b/scripts/miscellaneous/unzip.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2012 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -19,25 +19,26 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} unzip (@var{zipfile})
 ## @deftypefnx {Function File} {} unzip (@var{zipfile}, @var{dir})
 ## Unpack the ZIP archive @var{zipfile} to the directory @var{dir}.
 ## If @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{zip, unpack, bunzip2, gunzip, untar}
 ## @end deftypefn
 
-## Author: Sren Hauberg <hauberg@gmail.com>
+## Author: Sren Hauberg <hauberg@gmail.com>
 ## Adapted-By: jwe, Bill Denney
 
 function varargout = unzip (zipfile, dir = ".")
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargout > 0)
     varargout = cell (1, nargout);
     [varargout{:}] = unpack (zipfile, dir, mfilename ());
   else
     unpack (zipfile, dir, mfilename ());
   endif
 
 endfunction
+
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -172,17 +172,17 @@
 ## @item Octave:logical-conversion
 ## By default, the @code{Octave:logical-conversion} warning is enabled.
 ##
 ## @item Octave:matlab-incompatible
 ## Print warnings for Octave language features that may cause
 ## compatibility problems with @sc{matlab}.
 ## By default, the @code{Octave:matlab-incompatible} warning is disabled.
 ## The --traditional or --braindead startup options for Octave may also
-## be of use, @xref{Command Line Options}.
+## be of use, @pxref{Command Line Options}.
 ##
 ## @item Octave:md5sum-file-in-path
 ## By default, the @code{Octave:md5sum-file-in-path} warning is enabled.
 ##
 ## @item Octave:missing-glyph
 ## By default, the @code{Octave:missing-glyph} warning is enabled.
 ##
 ## @item Octave:missing-semicolon
@@ -328,16 +328,18 @@
 ## By default, the @code{Octave:undefined-return-values} warning is enabled.
 ##
 ## @item Octave:variable-switch-label
 ## If the @code{Octave:variable-switch-label} warning is enabled, Octave
 ## will print a warning if a switch label is not a constant or constant
 ## expression.
 ## By default, the @code{Octave:variable-switch-label} warning is disabled.
 ## @end table
+##
+
 
 function warning_ids ()
   help ("warning_ids");
 endfunction
 
 
 ## Remove from test statistics.  No real tests possible
 %!assert (1)
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -58,23 +58,23 @@ function ret = what (d)
     ## Ignore . and ..
     if (strcmp (n, ".") || strcmp (n, ".."))
       continue;
     else
       ## Ignore mdl and p files
       [dummy, f, e] = fileparts (n);
       if (strcmp (e, ".m"))
         w.m{end+1} = n;
-      elseif (strcmp (e, mexext ()))
-        w.mex{end+1} = n;
       elseif (strcmp (e, ".oct"))
         w.oct{end+1} = n;
+      elseif (strcmp (e, mexext ()))
+        w.mex{end+1} = n;
       elseif (strcmp (e, ".mat"))
         w.mat{end+1} = n;
-      elseif(strcmp (n(1), "@"))
+      elseif (strcmp (n(1), "@"))
         w.classes{end+1} = n;
       endif
     endif
   endfor
 
   if (nargout == 0)
     __display_filenames__ ("M-files in directory", w.path, w.m);
     __display_filenames__ ("\nMEX-files in directory", w.path, w.mex);
@@ -103,8 +103,9 @@ function __display_filenames__ (msg, p, 
       args  = f(i:nrows:end);
       if (length (args) < ncols)
         args(end + 1 : ncols) = {""};
       endif
       printf (fmt, args{:});
     endfor
   endif
 endfunction
+
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -61,8 +61,9 @@ function entries = zip (zipfile, files, 
     endif
     if (entries(end) == "\n")
       entries(end) = [];
     endif
     entries = ostrsplit (entries, "\n");
   endif
 
 endfunction
+
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
--- a/scripts/mkdoc.pl
+++ b/scripts/mkdoc.pl
@@ -47,17 +47,17 @@ MFILE: foreach $m_fname (@ARGV)
   if ($2)
     { $fcn = "$2$3/$4"; }
   else
     { $fcn = $4; }
 
   @help_txt = gethelp ($fcn, $full_fname);
   next MFILE if ($help_txt[0] eq "");
 
-  print "$fcn\n";
+  print "\x{1d}$fcn\n";
   print "\@c $fcn scripts/$m_fname\n";
 
   foreach $_ (@help_txt)
   {
     s/^\s+\@/\@/ unless $in_example;
     s/^\s+\@group/\@group/;
     s/^\s+\@end\s+group/\@end group/;
     $in_example = (/\s*\@example\b/ .. /\s*\@end\s+example\b/);
diff --git a/scripts/mkinstalldirs b/scripts/mkinstalldirs
deleted file mode 100755
--- a/scripts/mkinstalldirs
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/bin/sh
-# mkinstalldirs --- make directory hierarchy
-# Author: Noah Friedman <friedman@gnu.org>
-# Created: 1993-05-16
-# Last modified: Wed Jan 25 09:35:21 1995
-# Public domain
-
-errstatus=0
-
-dirmode=0755
-
-for file in ${1+"$@"} ; do 
-   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
-   shift
-
-   pathcomp=
-   for d in ${1+"$@"} ; do
-     pathcomp="$pathcomp$d"
-     case "$pathcomp" in
-       -* ) pathcomp=./$pathcomp ;;
-     esac
-
-     if test ! -d "$pathcomp"; then
-        echo "mkdir $pathcomp" 1>&2
-        mkdir "$pathcomp" || errstatus=$?
-        echo "chmod $dirmode $pathcomp" 1>&2
-        chmod $dirmode "$pathcomp" || errstatus=$?
-     fi
-
-     pathcomp="$pathcomp/"
-   done
-done
-
-exit $errstatus
-
-# mkinstalldirs ends here
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -44,17 +44,17 @@ function names = __all_opts__ (varargin)
     recursive = true;
     names = saved_names;
     for i = 1:nargin
       try
         opts = optimset (varargin{i});
         fn = fieldnames (opts).';
         names = [names, fn];
       catch
-        # throw the error as a warning.
+        ## throw the error as a warning.
         warning (lasterr ());
       end_try_catch
     endfor
     names = unique (names);
     [lnames, idx] = unique (tolower (names));
     if (length (lnames) < length (names))
       ## This is bad.
       error ("__all_opts__: duplicate options with inconsistent case");
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -20,18 +20,19 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fminbnd (@var{fun}, @var{a}, @var{b}, @var{options})
 ## Find a minimum point of a univariate function.
 ##
 ## @var{fun} should be a function handle or name.  @var{a}, @var{b} specify a
 ## starting interval.  @var{options} is a structure specifying additional
 ## options.  Currently, @code{fminbnd} recognizes these options:
-## "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a
-## description of these options, see @ref{docXoptimset,,optimset}.
+## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+## @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.  For a description of these
+## options, see @ref{XREFoptimset,,optimset}.
 ##
 ## On exit, the function returns @var{x}, the approximate minimum point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ## The algorithm converged to a solution.
@@ -205,17 +206,17 @@ function [x, fval, info, output] = fminb
       endif
     endif
   endwhile
 
   ## Fix the first step procedure.
   iter(1).procedure = "initial";
 
   ## Handle the "Display" option
-  switch displ
+  switch (displ)
     case "iter"
       print_formatted_table (iter);
       print_exit_msg (info, struct("TolX", tolx, "fx", fval));
     case "notify"
       if (info == 0)
         print_exit_msg (info, struct("fx",fval));
       endif
     case "final"
@@ -254,26 +255,26 @@ function print_formatted_table (table)
            num2str (row.fx,"%.6f"), row.procedure);
   endfor
   printf ("\n");
 endfunction
 
 ## Print either a success termination message or bad news
 function print_exit_msg (info, opt=struct())
   printf ("");
-  switch info
+  switch (info)
     case 1
       printf ("Optimization terminated:\n");
       printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
     case 0
       printf ("Exiting: Maximum number of iterations has been exceeded\n");
       printf ("         - increase MaxIter option.\n");
       printf ("         Current function value: %.6f\n", opt.fx);
     case -1
-      "FIXME"; ## FIXME: what's the message MATLAB prints for this case?
+      "FIXME"; # FIXME: what's the message MATLAB prints for this case?
     otherwise
       error ("internal error - fminbnd() is bug, sorry!");
   endswitch
   printf ("\n");
 endfunction
 
 
 %!shared opt0
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -25,18 +25,19 @@
 ## Find a value of @var{x} which minimizes the function @var{fun}.
 ## The search begins at the point @var{x0} and iterates using the
 ## Nelder & Mead Simplex algorithm (a derivative-free method).  This algorithm
 ## is better-suited to functions which have discontinuities or for which
 ## a gradient-based search such as @code{fminunc} fails.
 ##
 ## Options for the search are provided in the parameter @var{options} using 
 ## the function @code{optimset}.  Currently, @code{fminsearch} accepts the
-## options: "TolX", "MaxFunEvals", "MaxIter", "Display".  For a description of
-## these options, see @code{optimset}.
+## options: @qcode{"TolX"}, @qcode{"MaxFunEvals"}, @qcode{"MaxIter"},
+## @qcode{"Display"}.  For a description of these options, see
+## @code{optimset}.
 ##
 ## On exit, the function returns @var{x}, the minimum point,
 ## and @var{fval}, the function value thereof.
 ##
 ## Example usages:
 ##
 ## @example
 ## @group
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -28,27 +28,27 @@
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
 ## and return the objective function value, optionally with gradient.
 ## In other words, this function attempts to determine a vector @var{x} such
 ## that @code{@var{fcn} (@var{x})} is a local minimum.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fminunc} recognizes these options:
-## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
-## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"},
-## @code{"GradObj"}, @code{"FinDiffType"},
-## @code{"TypicalX"}, @code{"AutoScaling"}.
+## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
+## @qcode{"GradObj"}, @qcode{"FinDiffType"},
+## @qcode{"TypicalX"}, @qcode{"AutoScaling"}.
 ##
-## If @code{"GradObj"} is @code{"on"}, it specifies that @var{fcn},
+## If @qcode{"GradObj"} is @qcode{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
-## of right-hand sides at the requested point.  @code{"TolX"} specifies
+## of right-hand sides at the requested point.  @qcode{"TolX"} specifies
 ## the termination tolerance in the unknown variables, while
-## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
-## for both @code{"TolX"} and @code{"TolFun"}.
+## @qcode{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
+## for both @qcode{"TolX"} and @qcode{"TolFun"}.
 ##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
 ## evaluated at @var{x}, and @var{info} may be one of the following values:
 ##
 ## @table @asis
 ## @item 1
@@ -422,8 +422,9 @@ function x = __doglegm__ (r, g, d, delta
     else
       alpha = delta / xn;
       snm = 0;
     endif
     ## Form the appropriate convex combination.
     x = alpha * x + ((1-alpha) * min (snm, delta)) * s;
   endif
 endfunction
+
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -26,41 +26,40 @@
 ## and return a vector of left-hand sides of the equations.  Right-hand sides
 ## are defined to be zeros.
 ## In other words, this function attempts to determine a vector @var{x} such
 ## that @code{@var{fcn} (@var{x})} gives (approximately) all zeros.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fsolve} recognizes these options:
-## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
-## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"},
-## @code{"Jacobian"}, @code{"Updating"}, @code{"ComplexEqn"}
-## @code{"TypicalX"}, @code{"AutoScaling"} and @code{"FinDiffType"}.
+## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
+## @qcode{"Jacobian"}, @qcode{"Updating"}, @qcode{"ComplexEqn"}
+## @qcode{"TypicalX"}, @qcode{"AutoScaling"} and @qcode{"FinDiffType"}.
 ##
-## If @code{"Jacobian"} is @code{"on"}, it specifies that @var{fcn},
+## If @qcode{"Jacobian"} is @qcode{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
-## of right-hand sides at the requested point.  @code{"TolX"} specifies
+## of right-hand sides at the requested point.  @qcode{"TolX"} specifies
 ## the termination tolerance in the unknown variables, while
-## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
-## for both @code{"TolX"} and @code{"TolFun"}.
+## @qcode{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
+## for both @qcode{"TolX"} and @qcode{"TolFun"}.
 ##
-## If @code{"AutoScaling"} is on, the variables will be automatically scaled
+## If @qcode{"AutoScaling"} is on, the variables will be automatically scaled
 ## according to the column norms of the (estimated) Jacobian.  As a result,
 ## TolF becomes scaling-independent.  By default, this option is off, because
 ## it may sometimes deliver unexpected (though mathematically correct) results.
 ##
-## If @code{"Updating"} is "on", the function will attempt to use Broyden
-## updates to update the Jacobian, in order to reduce the amount of Jacobian
-## calculations.
-## If your user function always calculates the Jacobian (regardless of number
-## of output arguments), this option provides no advantage and should be set to
-## false.
+## If @qcode{"Updating"} is @qcode{"on"}, the function will attempt to use
+## @nospell{Broyden} updates to update the Jacobian, in order to reduce the
+## amount of Jacobian calculations.  If your user function always calculates the
+## Jacobian (regardless of number of output arguments), this option provides
+## no advantage and should be set to false.
 ##
-## @code{"ComplexEqn"} is @code{"on"}, @code{fsolve} will attempt to solve
+## @qcode{"ComplexEqn"} is @qcode{"on"}, @code{fsolve} will attempt to solve
 ## complex equations in complex variables, assuming that the equations possess a
 ## complex derivative (i.e., are holomorphic).  If this is not what you want,
 ## should unpack the real and imaginary parts of the system to get a real
 ## system.
 ##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
@@ -129,17 +128,17 @@
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
-    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, \
+    x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, ...
     "Jacobian", "off", "TolX", 1e-7, "TolFun", 1e-7,
     "OutputFcn", [], "Updating", "on", "FunValCheck", "off",
     "ComplexEqn", "off", "FinDiffType", "central",
     "TypicalX", [], "AutoScaling", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3 || ! ismatrix (x0))
@@ -457,16 +456,17 @@ endfunction
 
 function [fx, jx] = make_fcn_jac (x, fcn, fjac)
   fx = fcn (x);
   if (nargout == 2)
     jx = fjac (x);
   endif
 endfunction
 
+
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
 %!  retval(1) = sin (x) + y^2 + log (z) - 7;
 %!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -35,19 +35,19 @@
 ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
 ## @end example
 ##
 ## If @var{x0} is a single scalar then several nearby and distant
 ## values are probed in an attempt to obtain a valid bracketing.  If this
 ## is not successful, the function fails.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fzero}
-## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
-## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}.
-## For a description of these options, see @ref{docXoptimset,,optimset}.
+## recognizes these options: @qcode{"FunValCheck"}, @qcode{"OutputFcn"},
+## @qcode{"TolX"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.
+## For a description of these options, see @ref{XREFoptimset,,optimset}.
 ##
 ## On exit, the function returns @var{x}, the approximate zero point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ##  The algorithm converged to a solution.
@@ -191,80 +191,80 @@ function [x, fval, info, output] = fzero
     u = b; fu = fb;
   endif
 
   d = e = u;
   fd = fe = fu;
   mba = mu*(b - a);
   while (niter < maxiter && nfev < maxfev)
     switch (itype)
-    case 1
-      ## The initial test.
-      if (b - a <= 2*(2 * abs (u) * eps + tolx))
-        x = u; fval = fu;
-        info = 1;
-        break;
-      endif
-      if (abs (fa) <= 1e3*abs (fb) && abs (fb) <= 1e3*abs (fa))
-        ## Secant step.
-        c = u - (a - b) / (fa - fb) * fu;
-      else
+      case 1
+        ## The initial test.
+        if (b - a <= 2*(2 * abs (u) * eps + tolx))
+          x = u; fval = fu;
+          info = 1;
+          break;
+        endif
+        if (abs (fa) <= 1e3*abs (fb) && abs (fb) <= 1e3*abs (fa))
+          ## Secant step.
+          c = u - (a - b) / (fa - fb) * fu;
+        else
+          ## Bisection step.
+          c = 0.5*(a + b);
+        endif
+        d = u; fd = fu;
+        itype = 5;
+      case {2, 3}
+        l = length (unique ([fa, fb, fd, fe]));
+        if (l == 4)
+          ## Inverse cubic interpolation.
+          q11 = (d - e) * fd / (fe - fd);
+          q21 = (b - d) * fb / (fd - fb);
+          q31 = (a - b) * fa / (fb - fa);
+          d21 = (b - d) * fd / (fd - fb);
+          d31 = (a - b) * fb / (fb - fa);
+          q22 = (d21 - q11) * fb / (fe - fb);
+          q32 = (d31 - q21) * fa / (fd - fa);
+          d32 = (d31 - q21) * fd / (fd - fa);
+          q33 = (d32 - q22) * fa / (fe - fa);
+          c = a + q31 + q32 + q33;
+        endif
+        if (l < 4 || sign (c - a) * sign (c - b) > 0)
+          ## Quadratic interpolation + newton.
+          a0 = fa;
+          a1 = (fb - fa)/(b - a);
+          a2 = ((fd - fb)/(d - b) - a1) / (d - a);
+          ## Modification 1: this is simpler and does not seem to be worse.
+          c = a - a0/a1;
+          if (a2 != 0)
+            c = a - a0/a1;
+            for i = 1:itype
+              pc = a0 + (a1 + a2*(c - b))*(c - a);
+              pdc = a1 + a2*(2*c - a - b);
+              if (pdc == 0)
+                c = a - a0/a1;
+                break;
+              endif
+              c -= pc/pdc;
+            endfor
+          endif
+        endif
+        itype += 1;
+      case 4
+        ## Double secant step.
+        c = u - 2*(b - a)/(fb - fa)*fu;
+        ## Bisect if too far.
+        if (abs (c - u) > 0.5*(b - a))
+          c = 0.5 * (b + a);
+        endif
+        itype = 5;
+      case 5
         ## Bisection step.
-        c = 0.5*(a + b);
-      endif
-      d = u; fd = fu;
-      itype = 5;
-    case {2, 3}
-      l = length (unique ([fa, fb, fd, fe]));
-      if (l == 4)
-        ## Inverse cubic interpolation.
-        q11 = (d - e) * fd / (fe - fd);
-        q21 = (b - d) * fb / (fd - fb);
-        q31 = (a - b) * fa / (fb - fa);
-        d21 = (b - d) * fd / (fd - fb);
-        d31 = (a - b) * fb / (fb - fa);
-        q22 = (d21 - q11) * fb / (fe - fb);
-        q32 = (d31 - q21) * fa / (fd - fa);
-        d32 = (d31 - q21) * fd / (fd - fa);
-        q33 = (d32 - q22) * fa / (fe - fa);
-        c = a + q31 + q32 + q33;
-      endif
-      if (l < 4 || sign (c - a) * sign (c - b) > 0)
-        ## Quadratic interpolation + newton.
-        a0 = fa;
-        a1 = (fb - fa)/(b - a);
-        a2 = ((fd - fb)/(d - b) - a1) / (d - a);
-        ## Modification 1: this is simpler and does not seem to be worse.
-        c = a - a0/a1;
-        if (a2 != 0)
-          c = a - a0/a1;
-          for i = 1:itype
-            pc = a0 + (a1 + a2*(c - b))*(c - a);
-            pdc = a1 + a2*(2*c - a - b);
-            if (pdc == 0)
-              c = a - a0/a1;
-              break;
-            endif
-            c -= pc/pdc;
-          endfor
-        endif
-      endif
-      itype += 1;
-    case 4
-      ## Double secant step.
-      c = u - 2*(b - a)/(fb - fa)*fu;
-      ## Bisect if too far.
-      if (abs (c - u) > 0.5*(b - a))
         c = 0.5 * (b + a);
-      endif
-      itype = 5;
-    case 5
-      ## Bisection step.
-      c = 0.5 * (b + a);
-      itype = 2;
+        itype = 2;
     endswitch
 
     ## Don't let c come too close to a or b.
     delta = 2*0.7*(2 * abs (u) * eps + tolx);
     if ((b - a) <= 2*delta)
       c = (a + b)/2;
     else
       c = max (a + delta, min (b - delta, c));
@@ -352,13 +352,14 @@ function fx = guarded_eval (fun, x)
   fx = fx(1);
   if (! isreal (fx))
     error ("fzero:notreal", "fzero: non-real value encountered");
   elseif (isnan (fx))
     error ("fzero:isnan", "fzero: NaN value encountered");
   endif
 endfunction
 
+
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fzero (@cos, [0, 3], opt0), pi/2, 10*eps)
 %!assert (fzero (@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
 
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2005-2012 Nicolo' Giorgetti
+## Copyright (C) 2013 Sbastien Villemot <sebastien@debian.org>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpk (@var{c}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
+## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{errnum}, @var{extra}] =} glpk (@var{c}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
 ## Solve a linear program using the GNU @sc{glpk} library.  Given three
 ## arguments, @code{glpk} solves the following standard LP:
 ## @tex
 ## $$
 ##   \min_x C^T x
 ## $$
 ## @end tex
 ## @ifnottex
@@ -103,359 +104,359 @@
 ## infinite.
 ##
 ## @item ctype
 ## An array of characters containing the sense of each constraint in the
 ## constraint matrix.  Each element of the array may be one of the
 ## following values
 ##
 ## @table @asis
-## @item "F"
+## @item @qcode{"F"}
 ## A free (unbounded) constraint (the constraint is ignored).
 ##
-## @item "U"
+## @item @qcode{"U"}
 ## An inequality constraint with an upper bound (@code{A(i,:)*x <= b(i)}).
 ##
-## @item "S"
+## @item @qcode{"S"}
 ## An equality constraint (@code{A(i,:)*x = b(i)}).
 ##
-## @item "L"
+## @item @qcode{"L"}
 ## An inequality with a lower bound (@code{A(i,:)*x >= b(i)}).
 ##
-## @item "D"
+## @item @qcode{"D"}
 ## An inequality constraint with both upper and lower bounds
 ## (@code{A(i,:)*x >= -b(i)} @emph{and} (@code{A(i,:)*x <= b(i)}).
 ## @end table
 ##
 ## @item vartype
 ## A column array containing the types of the variables.
 ##
 ## @table @asis
-## @item "C"
+## @item @qcode{"C"}
 ## A continuous variable.
 ##
-## @item "I"
+## @item @qcode{"I"}
 ## An integer variable.
 ## @end table
 ##
 ## @item sense
 ## If @var{sense} is 1, the problem is a minimization.  If @var{sense} is
 ## -1, the problem is a maximization.  The default value is 1.
 ##
 ## @item param
 ## A structure containing the following parameters used to define the
 ## behavior of solver.  Missing elements in the structure take on default
 ## values, so you only need to set the elements that you wish to change
 ## from the default.
 ##
 ## Integer parameters:
 ##
 ## @table @code
-## @item msglev (@w{@code{LPX_K_MSGLEV}}, default: 1)
+## @item msglev (default: 1)
 ## Level of messages output by solver routines:
 ##
 ## @table @asis
-## @item 0
+## @item 0 (@w{@code{GLP_MSG_OFF}})
 ## No output.
 ##
-## @item 1
-## Error messages only.
+## @item 1 (@w{@code{GLP_MSG_ERR}})
+## Error and warning messages only.
 ##
-## @item 2
+## @item 2 (@w{@code{GLP_MSG_ON}})
 ## Normal output.
 ##
-## @item 3
+## @item 3 (@w{@code{GLP_MSG_ALL}})
 ## Full output (includes informational messages).
 ## @end table
 ##
-## @item scale (@w{@code{LPX_K_SCALE}}, default: 1)
-## Scaling option:
+## @item scale (default: 16)
+## Scaling option.  The values can be combined with the bitwise OR operator and
+## may be the following:
 ##
 ## @table @asis
-## @item 0
-## No scaling.
+## @item 1 (@w{@code{GLP_SF_GM}})
+## Geometric mean scaling.
 ##
-## @item 1
+## @item 16 (@w{@code{GLP_SF_EQ}})
 ## Equilibration scaling.
 ##
-## @item 2
-## Geometric mean scaling, then equilibration scaling.
+## @item 32 (@w{@code{GLP_SF_2N}})
+## Round scale factors to power of two.
+##
+## @item 64 (@w{@code{GLP_SF_SKIP}})
+## Skip if problem is well scaled.
 ## @end table
 ##
-## @item dual    (@w{@code{LPX_K_DUAL}}, default: 0)
-## Dual simplex option:
+## Alternatively, a value of 128 (@w{@env{GLP_SF_AUTO}}) may be also
+## specified, in which case the routine chooses the scaling options
+## automatically.
+##
+## @item dual (default: 1)
+## Simplex method option:
 ##
 ## @table @asis
-## @item 0
-## Do not use the dual simplex.
+## @item 1 (@w{@code{GLP_PRIMAL}})
+## Use two-phase primal simplex.
 ##
-## @item 1
-## If initial basic solution is dual feasible, use the dual simplex.
+## @item 2 (@w{@code{GLP_DUALP}})
+## Use two-phase dual simplex, and if it fails, switch to the primal simplex.
+##
+## @item 3 (@w{@code{GLP_DUAL}})
+## Use two-phase dual simplex.
 ## @end table
 ##
-## @item price   (@w{@code{LPX_K_PRICE}}, default: 1)
+## @item price (default: 34)
 ## Pricing option (for both primal and dual simplex):
 ##
 ## @table @asis
-## @item 0
+## @item 17 (@w{@code{GLP_PT_STD}})
 ## Textbook pricing.
 ##
-## @item 1
+## @item 34 (@w{@code{GLP_PT_PSE}})
 ## Steepest edge pricing.
 ## @end table
 ##
-## @item round   (@w{@code{LPX_K_ROUND}}, default: 0)
-## Solution rounding option:
-##
-## @table @asis
-## @item 0
-## Report all primal and dual values "as is".
+## @item itlim (default: intmax)
+## Simplex iterations limit.  It is decreased by one each time when one simplex
+## iteration has been performed, and reaching zero value signals the solver to
+## stop the search.
 ##
-## @item 1
-## Replace tiny primal and dual values by exact zero.
-## @end table
-##
-## @item itlim   (@w{@code{LPX_K_ITLIM}}, default: -1)
-## Simplex iterations limit.  If this value is positive, it is decreased by
-## one each time when one simplex iteration has been performed, and
-## reaching zero value signals the solver to stop the search.  Negative
-## value means no iterations limit.
-##
-## @item itcnt (@w{@code{LPX_K_OUTFRQ}}, default: 200)
+## @item outfrq (default: 200)
 ## Output frequency, in iterations.  This parameter specifies how
 ## frequently the solver sends information about the solution to the
 ## standard output.
 ##
-## @item branch (@w{@code{LPX_K_BRANCH}}, default: 2)
-## Branching heuristic option (for MIP only):
+## @item branch (default: 4)
+## Branching technique option (for MIP only):
 ##
 ## @table @asis
-## @item 0
-## Branch on the first variable.
+## @item 1 (@w{@code{GLP_BR_FFV}})
+## First fractional variable.
+##
+## @item 2 (@w{@code{GLP_BR_LFV}})
+## Last fractional variable.
 ##
-## @item 1
-## Branch on the last variable.
+## @item 3 (@w{@code{GLP_BR_MFV}})
+## Most fractional variable.
 ##
-## @item 2
-## Branch using a heuristic by Driebeck and Tomlin.
+## @item 4 (@w{@code{GLP_BR_DTH}})
+## Heuristic by Driebeck and Tomlin.
+##
+## @item 5 (@w{@code{GLP_BR_PCH}})
+## Hybrid @nospell{pseudocost} heuristic.
 ## @end table
 ##
-## @item btrack (@w{@code{LPX_K_BTRACK}}, default: 2)
-## Backtracking heuristic option (for MIP only):
+## @item btrack (default: 4)
+## Backtracking technique option (for MIP only):
 ##
 ## @table @asis
-## @item 0
+## @item 1 (@w{@code{GLP_BT_DFS}})
 ## Depth first search.
 ##
-## @item 1
+## @item 2 (@w{@code{GLP_BT_BFS}})
 ## Breadth first search.
 ##
-## @item 2
-## Backtrack using the best projection heuristic.
+## @item 3 (@w{@code{GLP_BT_BLB}})
+## Best local bound.
+##
+## @item 4 (@w{@code{GLP_BT_BPH}})
+## Best projection heuristic.
 ## @end table
 ##
-## @item presol (@w{@code{LPX_K_PRESOL}}, default: 1)
-## If this flag is set, the routine lpx_simplex solves the problem using
-## the built-in LP presolver.  Otherwise the LP presolver is not used.
+## @item presol (default: 1)
+## If this flag is set, the simplex solver uses the built-in LP presolver.
+## Otherwise the LP presolver is not used.
 ##
 ## @item lpsolver (default: 1)
 ## Select which solver to use.  If the problem is a MIP problem this flag
 ## will be ignored.
 ##
 ## @table @asis
 ## @item 1
 ## Revised simplex method.
 ##
 ## @item 2
 ## Interior point method.
 ## @end table
 ##
+## @item rtest (default: 34)
+## Ratio test technique:
+##
+## @table @asis
+## @item 17 (@w{@code{GLP_RT_STD}})
+## Standard ("textbook").
+##
+## @item 34 (@w{@code{GLP_RT_HAR}})
+## Harris' two-pass ratio test.
+## @end table
+##
+## @item tmlim (default: intmax)
+## Searching time limit, in milliseconds.
+##
+## @item outdly (default: 0)
+## Output delay, in seconds.  This parameter specifies how long the solver
+## should delay sending information about the solution to the standard
+## output.
+##
 ## @item save (default: 0)
 ## If this parameter is nonzero, save a copy of the problem in
 ## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
 ## way to change the name of the output file.
 ## @end table
 ##
 ## Real parameters:
 ##
 ## @table @code
-## @item relax (@w{@code{LPX_K_RELAX}}, default: 0.07)
-## Relaxation parameter used in the ratio test.  If it is zero, the textbook
-## ratio test is used.  If it is non-zero (should be positive), Harris'
-## two-pass ratio test is used.  In the latter case on the first pass of the
-## ratio test basic variables (in the case of primal simplex) or reduced
-## costs of non-basic variables (in the case of dual simplex) are allowed
-## to slightly violate their bounds, but not more than
-## @code{relax*tolbnd} or @code{relax*toldj (thus, @code{relax} is a
-## percentage of @code{tolbnd} or @code{toldj}}.
-##
-## @item tolbnd (@w{@code{LPX_K_TOLBND}}, default: 10e-7)
+## @item tolbnd (default: 1e-7)
 ## Relative tolerance used to check if the current basic solution is primal
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ##
-## @item toldj (@w{@code{LPX_K_TOLDJ}}, default: 10e-7)
+## @item toldj (default: 1e-7)
 ## Absolute tolerance used to check if the current basic solution is dual
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
 ##
-## @item tolpiv (@w{@code{LPX_K_TOLPIV}}, default: 10e-9)
+## @item tolpiv (default: 1e-10)
 ## Relative tolerance used to choose eligible pivotal elements of the
 ## simplex table.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
 ##
-## @item objll (@w{@code{LPX_K_OBJLL}}, default: -DBL_MAX)
-## Lower limit of the objective function.  If on the phase II the objective
+## @item objll (default: -DBL_MAX)
+## Lower limit of the objective function.  If the objective
 ## function reaches this limit and continues decreasing, the solver stops
 ## the search.  This parameter is used in the dual simplex method only.
 ##
-## @item objul (@w{@code{LPX_K_OBJUL}}, default: +DBL_MAX)
-## Upper limit of the objective function.  If on the phase II the objective
+## @item objul (default: +DBL_MAX)
+## Upper limit of the objective function.  If the objective
 ## function reaches this limit and continues increasing, the solver stops
 ## the search.  This parameter is used in the dual simplex only.
 ##
-## @item tmlim (@w{@code{LPX_K_TMLIM}}, default: -1.0)
-## Searching time limit, in seconds.  If this value is positive, it is
-## decreased each time when one simplex iteration has been performed by the
-## amount of time spent for the iteration, and reaching zero value signals
-## the solver to stop the search.  Negative value means no time limit.
-##
-## @item outdly (@w{@code{LPX_K_OUTDLY}}, default: 0.0)
-## Output delay, in seconds.  This parameter specifies how long the solver
-## should delay sending information about the solution to the standard
-## output.  Non-positive value means no delay.
-##
-## @item tolint (@w{@code{LPX_K_TOLINT}}, default: 10e-5)
+## @item tolint (default: 1e-5)
 ## Relative tolerance used to check if the current basic solution is integer
 ## feasible.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
 ##
-## @item tolobj (@w{@code{LPX_K_TOLOBJ}}, default: 10e-7)
+## @item tolobj (default: 1e-7)
 ## Relative tolerance used to check if the value of the objective function
 ## is not better than in the best known integer feasible solution.  It is
 ## not recommended that you change this parameter unless you have a
 ## detailed understanding of its purpose.
 ## @end table
 ## @end table
 ##
 ## Output values:
 ##
 ## @table @var
 ## @item xopt
 ## The optimizer (the value of the decision variables at the optimum).
 ##
 ## @item fopt
 ## The optimum value of the objective function.
 ##
-## @item status
-## Status of the optimization.
-##
-## Simplex Method:
-##
-## @table @asis
-## @item 180 (@w{@code{LPX_OPT}})
-## Solution is optimal.
-##
-## @item 181 (@w{@code{LPX_FEAS}})
-## Solution is feasible.
-##
-## @item 182 (@w{@code{LPX_INFEAS}})
-## Solution is infeasible.
-##
-## @item 183 (@w{@code{LPX_NOFEAS}})
-## Problem has no feasible solution.
-##
-## @item 184 (@w{@code{LPX_UNBND}})
-## Problem has no unbounded solution.
-##
-## @item 185 (@w{@code{LPX_UNDEF}})
-## Solution status is undefined.
-## @end table
-##
-## Interior Point Method:
-##
-## @table @asis
-## @item 150 (@w{@code{LPX_T_UNDEF}})
-## The interior point method is undefined.
-##
-## @item 151 (@w{@code{LPX_T_OPT}})
-## The interior point method is optimal.
-## @end table
-##
-## Mixed Integer Method:
+## @item errnum
+## Error code.
 ##
 ## @table @asis
-## @item 170 (@w{@code{LPX_I_UNDEF}})
-## The status is undefined.
+## @item 0
+## No error.
 ##
-## @item 171 (@w{@code{LPX_I_OPT}})
-## The solution is integer optimal.
+## @item 1 (@w{@code{GLP_EBADB}})
+## Invalid basis.
 ##
-## @item 172 (@w{@code{LPX_I_FEAS}})
-## Solution integer feasible but its optimality has not been proven
+## @item 2 (@w{@code{GLP_ESING}})
+## Singular matrix.
 ##
-## @item 173 (@w{@code{LPX_I_NOFEAS}})
-## No integer feasible solution.
-## @end table
+## @item 3 (@w{@code{GLP_ECOND}})
+## Ill-conditioned matrix.
 ##
-## @noindent
-## If an error occurs, @var{status} will contain one of the following
-## codes:
+## @item 4 (@w{@code{GLP_EBOUND}})
+## Invalid bounds.
 ##
-## @table @asis
-## @item 204 (@w{@code{LPX_E_FAULT}})
-## Unable to start the search.
+## @item 5 (@w{@code{GLP_EFAIL}})
+## Solver failed.
 ##
-## @item 205 (@w{@code{LPX_E_OBJLL}})
+## @item 6 (@w{@code{GLP_EOBJLL}})
 ## Objective function lower limit reached.
 ##
-## @item 206 (@w{@code{LPX_E_OBJUL}})
+## @item 7 (@w{@code{GLP_EOBJUL}})
 ## Objective function upper limit reached.
 ##
-## @item 207 (@w{@code{LPX_E_ITLIM}})
+## @item 8 (@w{@code{GLP_EITLIM}})
 ## Iterations limit exhausted.
 ##
-## @item 208 (@w{@code{LPX_E_TMLIM}})
+## @item 9 (@w{@code{GLP_ETMLIM}})
 ## Time limit exhausted.
 ##
-## @item 209 (@w{@code{LPX_E_NOFEAS}})
-## No feasible solution.
+## @item 10 (@w{@code{GLP_ENOPFS}})
+## No primal feasible solution.
+##
+## @item 11 (@w{@code{GLP_ENODFS}})
+## No dual feasible solution.
+##
+## @item 12 (@w{@code{GLP_EROOT}})
+## Root LP optimum not provided.
 ##
-## @item 210 (@w{@code{LPX_E_INSTAB}})
+## @item 13 (@w{@code{GLP_ESTOP}})
+## Search terminated by application.
+##
+## @item 14 (@w{@code{GLP_EMIPGAP}})
+## Relative MIP gap tolerance reached.
+##
+## @item 15 (@w{@code{GLP_ENOFEAS}})
+## No primal/dual feasible solution.
+##
+## @item 16 (@w{@code{GLP_ENOCVG}})
+## No convergence.
+##
+## @item 17 (@w{@code{GLP_EINSTAB}})
 ## Numerical instability.
 ##
-## @item 211 (@w{@code{LPX_E_SING}})
-## Problems with basis matrix.
-##
-## @item 212 (@w{@code{LPX_E_NOCONV}})
-## No convergence (interior).
+## @item 18 (@w{@code{GLP_EDATA}})
+## Invalid data.
 ##
-## @item 213 (@w{@code{LPX_E_NOPFS}})
-## No primal feasible solution (LP presolver).
-##
-## @item 214 (@w{@code{LPX_E_NODFS}})
-## No dual feasible solution (LP presolver).
+## @item 19 (@w{@code{GLP_ERANGE}})
+## Result out of range.
 ## @end table
 ##
 ## @item extra
 ## A data structure containing the following fields:
 ##
 ## @table @code
 ## @item lambda
 ## Dual variables.
 ##
 ## @item redcosts
 ## Reduced Costs.
 ##
 ## @item time
 ## Time (in seconds) used for solving LP/MIP problem.
 ##
-## @item mem
-## Memory (in bytes) used for solving LP/MIP problem (this is not
-## available if the version of @sc{glpk} is 4.15 or later).
+## @item status
+## Status of the optimization.
+##
+## @table @asis
+## @item 1 (@w{@code{GLP_UNDEF}})
+## Solution status is undefined.
+##
+## @item 2 (@w{@code{GLP_FEAS}})
+## Solution is feasible.
+##
+## @item 3 (@w{@code{GLP_INFEAS}})
+## Solution is infeasible.
+##
+## @item 4 (@w{@code{GLP_NOFEAS}})
+## Problem has no feasible solution.
+##
+## @item 5 (@w{@code{GLP_OPT}})
+## Solution is optimal.
+##
+## @item 6 (@w{@code{GLP_UNBND}})
+## Problem has no unbounded solution.
+## @end table
 ## @end table
 ## @end table
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## c = [10, 6, 4]';
@@ -476,17 +477,17 @@
 ##    glpk (c, A, b, lb, ub, ctype, vartype, s, param);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
 
-function [xopt, fmin, status, extra] = glpk (c, A, b, lb, ub, ctype, vartype, sense, param)
+function [xopt, fmin, errnum, extra] = glpk (c, A, b, lb, ub, ctype, vartype, sense, param)
 
   ## If there is no input output the version and syntax
   if (nargin < 3 || nargin > 9)
     print_usage ();
     return;
   endif
 
   if (all (size (c) > 1) || iscomplex (c) || ischar (c))
@@ -603,12 +604,13 @@ function [xopt, fmin, status, extra] = g
     if (! isstruct (param))
       error ("glpk: PARAM must be a structure");
       return;
     endif
   else
     param = struct ();
   endif
 
-  [xopt, fmin, status, extra] = ...
+  [xopt, fmin, errnum, extra] = ...
     __glpk__ (c, A, b, lb, ub, ctype, vartype, sense, param);
 
 endfunction
+
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -26,18 +26,18 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
 ## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
 ## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
 ## optional initial guess for @var{x}.
 ## Currently, @code{lsqnonneg}
-## recognizes these options: @code{"MaxIter"}, @code{"TolX"}.
-## For a description of these options, see @ref{docXoptimset,,optimset}.
+## recognizes these options: @qcode{"MaxIter"}, @qcode{"TolX"}.
+## For a description of these options, see @ref{XREFoptimset,,optimset}.
 ##
 ## Outputs:
 ##
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm (@var{c}*@var{x}-@var{d})^2
 ##
@@ -52,19 +52,19 @@
 ## that the algorithm converged.  (The algorithm is stable and will
 ## converge given enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
 ##
 ## @itemize @bullet
-## @item "algorithm": The algorithm used ("nnls")
+## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
 ##
-## @item "iterations": The number of iterations taken.
+## @item @qcode{"iterations"}: The number of iterations taken.
 ## @end itemize
 ##
 ## @item lambda
 ##
 ## Not implemented.
 ## @end itemize
 ## @seealso{optimset, pqpnonneg}
 ## @end deftypefn
@@ -74,17 +74,17 @@
 
 ## This is implemented from Lawson and Hanson's 1973 algorithm on page
 ## 161 of Solving Least Squares Problems.
 
 function [x, resnorm, residual, exitflag, output, lambda] = lsqnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
-    return
+    return;
   endif
 
   if (! (nargin >= 2 && nargin <= 4 && ismatrix (c) && ismatrix (d) && isstruct (options)))
     print_usage ();
   endif
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   m = rows (c);
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -28,17 +28,17 @@
 
 function retval = optimget (options, parname, default)
 
   if (nargin < 2 || nargin > 4 || ! isstruct (options) || ! ischar (parname))
     print_usage ();
   endif
 
   opts = __all_opts__ ();
-  idx = strncmpi (opts, parname, numel (parname));
+  idx = strncmpi (opts, parname, length (parname));
 
   nmatch = sum (idx);
 
   if (nmatch == 1)
     parname = opts{idx};
   elseif (nmatch == 0)
     warning ("unrecognized option: %s", parname);
   else
@@ -51,17 +51,19 @@ function retval = optimget (options, par
   elseif (nargin > 2)
     retval = default;
   else
     retval = [];
   endif
 
 endfunction
 
+
 %!error optimget ()
 
 %!shared opts
 %! opts = optimset ("tolx", 0.1, "maxit", 100);
 %!assert (optimget (opts, "TolX"), 0.1);
 %!assert (optimget (opts, "maxit"), 100);
 %!assert (optimget (opts, "MaxITer"), 100);
 %!warning (optimget (opts, "Max"));
 %!warning (optimget (opts, "foobar"));
+
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -30,50 +30,50 @@
 ## @item AutoScaling
 ##
 ## @item ComplexEqn
 ##
 ## @item Display
 ## Request verbose display of results from optimizations.  Values are:
 ##
 ## @table @asis
-## @item "off" [default]
+## @item @qcode{"off"} [default]
 ## No display.
 ##
-## @item "iter"
+## @item @qcode{"iter"}
 ## Display intermediate results for every loop iteration.
 ##
-## @item "final"
+## @item @qcode{"final"}
 ## Display the result of the final loop iteration.
 ##
-## @item "notify"
+## @item @qcode{"notify"}
 ## Display the result of the final loop iteration if the function has
 ## failed to converge.
 ## @end table
 ##
 ## @item FinDiffType
 ##
 ## @item FunValCheck
 ## When enabled, display an error if the objective function returns an invalid
-## value (a complex number, NaN, or Inf).  Must be set to "on" or "off"
-## [default].  Note: the functions @code{fzero} and @code{fminbnd} correctly
-## handle Inf values and only complex values or NaN will cause an error in this
-## case. 
+## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+## will cause an error in this case. 
 ##
 ## @item GradObj
-## When set to "on", the function to be minimized must return a second argument
-## which is the gradient, or first derivative, of the function at the point
-## @var{x}.  If set to "off" [default], the gradient is computed via finite
-## differences.
+## When set to @qcode{"on"}, the function to be minimized must return a
+## second argument which is the gradient, or first derivative, of the
+## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+## gradient is computed via finite differences.
 ##
 ## @item Jacobian
-## When set to "on", the function to be minimized must return a second argument
-## which is the Jacobian, or first derivative, of the function at the point
-## @var{x}.  If set to "off" [default], the Jacobian is computed via finite
-## differences.
+## When set to @qcode{"on"}, the function to be minimized must return a
+## second argument which is the Jacobian, or first derivative, of the
+## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+## Jacobian is computed via finite differences.
 ##
 ## @item MaxFunEvals
 ## Maximum number of function evaluations before optimization stops.
 ## Must be a positive integer.
 ##
 ## @item MaxIter
 ## Maximum number of algorithm iterations before optimization stops.
 ## Must be a positive integer.
@@ -167,8 +167,9 @@ endfunction
 
 
 %!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
 %!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
 %!warning (optimset ("Max", 10));
 %!warning (optimset ("foobar", 13));
 
 %!error (optimset ("%NOT_A_REAL_FUNCTION_NAME%"))
+
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -43,19 +43,19 @@
 ## that the algorithm converged.  (The algorithm is stable and will
 ## converge given enough iterations.)
 ##
 ## @item output
 ##
 ## A structure with two fields:
 ##
 ## @itemize @bullet
-## @item "algorithm": The algorithm used ("nnls")
+## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
 ##
-## @item "iterations": The number of iterations taken.
+## @item @qcode{"iterations"}: The number of iterations taken.
 ## @end itemize
 ##
 ## @item lambda
 ##
 ## Not implemented.
 ## @end itemize
 ## @seealso{optimset, lsqnonneg, qp}
 ## @end deftypefn
@@ -67,17 +67,17 @@
 ## implemented from Lawson and Hanson's 1973 algorithm on page
 ## 161 of Solving Least Squares Problems.
 ## It shares the convergence guarantees.
 
 function [x, minval, exitflag, output, lambda] = pqpnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
-    return
+    return;
   endif
 
   if (! (nargin >= 2 && nargin <= 4 && ismatrix (c) && ismatrix (d) && isstruct (options)))
     print_usage ();
   endif
 
   ## Lawson-Hanson Step 1 (LH1): initialize the variables.
   m = rows (c);
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -400,8 +400,9 @@ function [x, obj, INFO, lambda] = qp (x0
     INFO.solveiter = iter;
     INFO.info = info;
 
   else
     print_usage ();
   endif
 
 endfunction
+
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -181,65 +181,64 @@
 ##   -0.0052227
 ## @end example
 ##
 ## @seealso{qp}
 ## @end deftypefn
 
 function [x, obj, info, iter, nf, lambda] = sqp (x0, objf, cef, cif, lb, ub, maxiter, tolerance)
 
-  globals = struct (); # data and handles, needed and changed by
-                       # subfunctions
+  globals = struct (); # data and handles, needed and changed by subfunctions
 
   if (nargin < 2 || nargin > 8 || nargin == 5)
     print_usage ();
   endif
 
   if (!isvector (x0))
     error ("sqp: X0 must be a vector");
   endif
   if (rows (x0) == 1)
     x0 = x0';
   endif
 
   have_hess = 0;
   if (iscell (objf))
     switch (numel (objf))
-     case 1
-       obj_fun = objf{1};
-       obj_grd = @ (x) fd_obj_grd (x, obj_fun);
-     case 2
-       obj_fun = objf{1};
-       obj_grd = objf{2};
-     case 3
-       obj_fun = objf{1};
-       obj_grd = objf{2};
-       obj_hess = objf{3};
-       have_hess = 1;
-     otherwise
-      error ("sqp: invalid objective function specification");
+      case 1
+        obj_fun = objf{1};
+        obj_grd = @ (x) fd_obj_grd (x, obj_fun);
+      case 2
+        obj_fun = objf{1};
+        obj_grd = objf{2};
+      case 3
+        obj_fun = objf{1};
+        obj_grd = objf{2};
+        obj_hess = objf{3};
+        have_hess = 1;
+      otherwise
+        error ("sqp: invalid objective function specification");
     endswitch
   else
     obj_fun = objf;   # No cell array, only obj_fun set
     obj_grd = @ (x) fd_obj_grd (x, obj_fun);
   endif
 
   ce_fun = @empty_cf;
   ce_grd = @empty_jac;
   if (nargin > 2)
     if (iscell (cef))
       switch (numel (cef))
-       case 1
-         ce_fun = cef{1};
-         ce_grd = @ (x) fd_ce_jac (x, ce_fun);
-       case 2
-         ce_fun = cef{1};
-         ce_grd = cef{2};
-       otherwise
-         error ("sqp: invalid equality constraint function specification");
+        case 1
+          ce_fun = cef{1};
+          ce_grd = @ (x) fd_ce_jac (x, ce_fun);
+        case 2
+          ce_fun = cef{1};
+          ce_grd = cef{2};
+        otherwise
+          error ("sqp: invalid equality constraint function specification");
       endswitch
     elseif (! isempty (cef))
       ce_fun = cef;   # No cell array, only constraint equality function set
       ce_grd = @ (x) fd_ce_jac (x, ce_fun);
     endif
   endif
 
   ci_fun = @empty_cf;
@@ -256,24 +255,24 @@ function [x, obj, info, iter, nf, lambda
     elseif (! isempty (cif))
       globals.cifcn = cif;
     endif
 
     if (nargin < 5 || (nargin > 5 && isempty (lb) && isempty (ub)))
       ## constraint inequality function only without any bounds
       ci_grd = @ (x) fd_ci_jac (x, globals.cifcn);
       if (iscell (cif))
-        switch length (cif)
-         case {1}
-           ci_fun = cif{1};
-         case {2}
-           ci_fun = cif{1};
-           ci_grd = cif{2};
-        otherwise
-          error ("sqp: invalid inequality constraint function specification");
+        switch (length (cif))
+          case 1
+            ci_fun = cif{1};
+          case 2
+            ci_fun = cif{1};
+            ci_grd = cif{2};
+          otherwise
+           error ("sqp: invalid inequality constraint function specification");
         endswitch
       elseif (! isempty (cif))
         ci_fun = cif;   # No cell array, only constraint inequality function set
       endif
     else
       ## constraint inequality function with bounds present
       lb_idx = ub_idx = true (size (x0));
       ub_grad = - (lb_grad = eye (rows (x0)));
@@ -420,18 +419,18 @@ function [x, obj, info, iter, nf, lambda
         warning (id, "sqp: QP subproblem failed to converge in %d iterations",
                  INFO.solveiter);
       case 6
         warning (id, "sqp: QP subproblem is infeasible");
     endswitch
 
     ## Choose mu such that p is a descent direction for the chosen
     ## merit function phi.
-    [x_new, alpha, obj_new, globals] = \
-        linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, \
+    [x_new, alpha, obj_new, globals] = ...
+        linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, ...
                        obj, globals);
 
     ## Evaluate objective function, constraints, and gradients at x_new.
     c_new = feval (obj_grd, x_new);
 
     ce_new = feval (ce_fun, x_new);
     F_new = feval (ce_grd, x_new);
 
@@ -515,17 +514,17 @@ function [x, obj, info, iter, nf, lambda
     info = 103;
   endif
 
   nf = globals.nfun;
 
 endfunction
 
 
-function [merit, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, \
+function [merit, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, ...
                                          x, mu, globals)
 
   ce = feval (ce_fun, x);
   ci = feval (ci_fun, x);
 
   idx = ci < 0;
 
   con = [ce; ci(idx)];
@@ -540,18 +539,18 @@ function [merit, obj, globals] = phi_L1 
 
   if (! isempty (t))
     merit += t;
   endif
 
 endfunction
 
 
-function [x_new, alpha, obj, globals] = \
-      linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, \
+function [x_new, alpha, obj, globals] = ...
+      linesearch_L1 (x, p, obj_fun, obj_grd, ce_fun, ci_fun, lambda, ...
                      obj, globals)
 
   ## Choose parameters
   ##
   ## eta in the range (0, 0.5)
   ## tau in the range (0, 1)
 
   eta = 0.25;
@@ -565,31 +564,31 @@ function [x_new, alpha, obj, globals] = 
     mu = 1 / (norm (lambda, Inf) + delta_bar);
   endif
 
   alpha = 1;
 
   c = feval (obj_grd, x);
   ce = feval (ce_fun, x);
 
-  [phi_x_mu, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, x, \
+  [phi_x_mu, obj, globals] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, x, ...
                                      mu, globals);
 
   D_phi_x_mu = c' * p;
   d = feval (ci_fun, x);
   ## only those elements of d corresponding
   ## to violated constraints should be included.
   idx = d < 0;
   t = - norm ([ce; d(idx)], 1) / mu;
   if (! isempty (t))
     D_phi_x_mu += t;
   endif
 
   while (1)
-    [p1, obj, globals] = phi_L1 ([], obj_fun, ce_fun, ci_fun, \
+    [p1, obj, globals] = phi_L1 ([], obj_fun, ce_fun, ci_fun, ...
                                  x+alpha*p, mu, globals);
     p2 = phi_x_mu+eta*alpha*D_phi_x_mu;
     if (p1 > p2)
       ## Reset alpha = tau_alpha * alpha for some tau_alpha in the
       ## range (0, tau).
       tau_alpha = 0.9 * tau;  # ??
       alpha = tau_alpha * alpha;
     else
@@ -763,8 +762,9 @@ endfunction
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1), ones (2,2),[])
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[], ones (2,2))
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),1,-1)
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[], ones (2,2))
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],-1)
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],1.5)
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[], ones (2,2))
 %!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[],-1)
+
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -119,8 +119,9 @@ function specifiedpath = __extractpath__
     specifiedpath = strrep (regexprep (cstrcat (filelines(startline:endline){:}),
                                        " *path *\\('(.*)'\\); *", "$1"),
                             "''", "'");
   else
     specifiedpath = "";
   endif
 
 endfunction
+
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2005-2012 Sren Hauberg
+## Copyright (C) 2005-2012 Sren Hauberg
 ## Copyright (C) 2010 VZLU Prague, a.s.
 ## Copyright (C) 2012 Carlo de Falco
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
@@ -132,26 +132,27 @@
 ## If two output arguments are requested @code{pkg} splits the list of
 ## installed packages into those which were installed by the current user,
 ## and those which were installed by the system administrator.
 ##
 ## @example
 ## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
-## The option "-forge" lists packages available at the Octave-Forge repository.
-## This requires an internet connection and the cURL library.  For example:
+## The option @qcode{"-forge"} lists packages available at the Octave-Forge
+## repository.  This requires an internet connection and the cURL library. 
+## For example:
 ##
 ## @example
 ## oct_forge_pkgs = pkg ("list", "-forge")
 ## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
-## "-verbose" also list functions provided by the package.  For example,
+## @qcode{"-verbose"} also list functions provided by the package.  For example,
 ##
 ## @example
 ## pkg describe -verbose all
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## If one output is requested a cell of structure containing the
@@ -166,18 +167,19 @@
 ## If any of the requested packages is not installed, pkg returns an
 ## error, unless a second output is requested:
 ##
 ## @example
 ## [desc, flag] = pkg ("describe", "secs1d", "image")
 ## @end example
 ##
 ## @noindent
-## @var{flag} will take one of the values "Not installed", "Loaded" or
-## "Not loaded" for each of the named packages.
+## @var{flag} will take one of the values @qcode{"Not installed"},
+## @qcode{"Loaded"}, or
+## @qcode{"Not loaded"} for each of the named packages.
 ##
 ## @item prefix
 ## Set the installation prefix directory.  For example,
 ##
 ## @example
 ## pkg prefix ~/my_octave_packages
 ## @end example
 ##
@@ -549,8 +551,9 @@ function [local_packages, global_package
       else
         error ("no output arguments available");
       endif
 
     otherwise
       error ("you must specify a valid action for 'pkg'. See 'help pkg' for details");
   endswitch
 endfunction
+
diff --git a/scripts/pkg/private/build.m b/scripts/pkg/private/build.m
--- a/scripts/pkg/private/build.m
+++ b/scripts/pkg/private/build.m
@@ -56,8 +56,9 @@ function build (files, handle_deps, auto
     if (exist (installdir, "dir"))
       rmdir (installdir, "s");
     endif
     if (exist (buildlist, "file"))
       unlink (buildlist);
     endif
   end_unwind_protect
 endfunction
+
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -32,46 +32,54 @@ function configure_make (desc, packdir, 
     octave_config_program = fullfile (octave_bindir, sprintf ("octave-config-%s", ver));
     octave_binary = fullfile (octave_bindir, sprintf ("octave-%s", ver));
     cenv = {"MKOCTFILE"; mkoctfile_program;
             "OCTAVE_CONFIG"; octave_config_program;
             "OCTAVE"; octave_binary;
             "INSTALLDIR"; desc.dir};
     scenv = sprintf ("%s=\"%s\" ", cenv{:});
 
+    if (! exist (mkoctfile_program, "file"))
+      __gripe_missing_component__ ("pkg", "mkoctfile");
+    endif
+    if (! exist (octave_config_program, "file"))
+      __gripe_missing_component__ ("pkg", "octave-config");
+    endif
+    if (! exist (octave_binary, "file"))
+      __gripe_missing_component__ ("pkg", "octave");
+    endif
+
     ## Configure.
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
-        flags = cstrcat (flags, " CC=\"", mkoctfile ("-p", "CC"), "\"");
+        flags = [flags ' CC="' mkoctfile("-p", "CC") '"'];
       endif
       if (isempty (getenv ("CXX")))
-        flags = cstrcat (flags, " CXX=\"", mkoctfile ("-p", "CXX"), "\"");
+        flags = [flags ' CXX="' mkoctfile("-p", "CXX") '"'];
       endif
       if (isempty (getenv ("AR")))
-        flags = cstrcat (flags, " AR=\"", mkoctfile ("-p", "AR"), "\"");
+        flags = [flags ' AR="' mkoctfile("-p", "AR") '"'];
       endif
       if (isempty (getenv ("RANLIB")))
-        flags = cstrcat (flags, " RANLIB=\"", mkoctfile ("-p", "RANLIB"), "\"");
+        flags = [flags ' RANLIB="' mkoctfile("-p", "RANLIB") '"'];
       endif
-      [status, output] = shell (cstrcat ("cd '", src, "'; ", scenv,
-                                         "./configure --prefix=\"",
-                                         desc.dir, "\"", flags),
-                                verbose);
+      cmd = ["cd '" src "'; " ...
+             scenv "./configure --prefix=\"" desc.dir "\"" flags];
+      [status, output] = shell (cmd, verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
         error ("pkg: error running the configure script for %s.", desc.name);
       endif
     endif
 
     ## Make.
     if (exist (fullfile (src, "Makefile"), "file"))
-      [status, output] = shell (cstrcat (scenv, "make -C '", src, "'"),
-                                verbose);
+      [status, output] = shell ([scenv "make -C '" src "'"], verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
         error ("pkg: error running `make' for the %s package.", desc.name);
       endif
     endif
 
     ## Copy files to "inst" and "inst/arch" (this is instead of 'make
diff --git a/scripts/pkg/private/create_pkgadddel.m b/scripts/pkg/private/create_pkgadddel.m
--- a/scripts/pkg/private/create_pkgadddel.m
+++ b/scripts/pkg/private/create_pkgadddel.m
@@ -24,18 +24,18 @@
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
   ## If it is exists, most of the  PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
-  archdir = fullfile (getarchprefix (desc, global_install), cstrcat (desc.name,
-                      "-", desc.version), getarch ());
+  archdir = fullfile (getarchprefix (desc, global_install), 
+                      [desc.name "-" desc.version], getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
 
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -24,17 +24,16 @@
 
 function [pkg_desc_list, flag] = describe (pkgnames, verbose,
                                            local_list, global_list)
 
   ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
-
   describe_all = false;
   if (any (strcmp ("all", pkgnames)))
     describe_all = true;
     flag(1:num_packages) = {"Not Loaded"};
     num_pkgnames = num_packages;
   else
     num_pkgnames = length (pkgnames);
     flag(1:num_pkgnames) = {"Not installed"};
@@ -80,8 +79,9 @@ function [pkg_desc_list, flag] = describ
                                  pkg_desc_list{i}.version,
                                  pkg_desc_list{i}.provides,
                                  pkg_desc_list{i}.description,
                                  flag{i}, verbose);
     endfor
   endif
 
 endfunction
+
diff --git a/scripts/pkg/private/dirempty.m b/scripts/pkg/private/dirempty.m
--- a/scripts/pkg/private/dirempty.m
+++ b/scripts/pkg/private/dirempty.m
@@ -35,16 +35,17 @@ function emp = dirempty (nm, ign)
       for j = 1:length (ign)
         if (strcmp (l(i).name, ign{j}))
           found = true;
           break;
         endif
       endfor
       if (! found)
         emp = false;
-        return
+        return;
       endif
     endfor
     emp = true;
   else
     emp = true;
   endif
 endfunction
+
diff --git a/scripts/pkg/private/extract_pkg.m b/scripts/pkg/private/extract_pkg.m
--- a/scripts/pkg/private/extract_pkg.m
+++ b/scripts/pkg/private/extract_pkg.m
@@ -26,19 +26,19 @@ function pkg = extract_pkg (nm, pat)
   fid = fopen (nm, "rt");
   pkg = "";
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (ln > 0)
         t = regexp (ln, pat, "tokens");
         if (! isempty (t))
-          pkg = cstrcat (pkg, "\n", t{1}{1});
+          pkg = [pkg "\n" t{1}{1}];
         endif
       endif
     endwhile
     if (! isempty (pkg))
-      pkg = cstrcat (pkg, "\n");
+      pkg = [pkg "\n"];
     endif
     fclose (fid);
   endif
 endfunction
 
diff --git a/scripts/pkg/private/fix_depends.m b/scripts/pkg/private/fix_depends.m
--- a/scripts/pkg/private/fix_depends.m
+++ b/scripts/pkg/private/fix_depends.m
@@ -23,43 +23,45 @@
 ## @end deftypefn
 
 ## Make sure the depends field is of the right format.
 ## This function returns a cell of structures with the following fields:
 ##   package, version, operator
 function deps_cell = fix_depends (depends)
   deps = strtrim (ostrsplit (tolower (depends), ","));
   deps_cell = cell (1, length (deps));
+  dep_pat = ...
+  '\s*(?<name>\w+)+\s*(\(\s*(?<op>[<>=]+)\s*(?<ver>\d+\.\d+(\.\d+)*)\s*\))*\s*';
 
   ## For each dependency.
   for i = 1:length (deps)
     dep = deps{i};
-    lpar = find (dep == "(");
-    rpar = find (dep == ")");
-    ## Does the dependency specify a version
-    ## Example: package(>= version).
-    if (length (lpar) == 1 && length (rpar) == 1)
-      package = tolower (strtrim (dep(1:lpar-1)));
-      sub = dep(lpar(1)+1:rpar(1)-1);
-      parts = strsplit (sub, " ", true);
-      if (length (parts) != 2)
-        error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
-               dep);
+    [start, nm] = regexp (dep, dep_pat, 'start', 'names');
+    ## Is the dependency specified 
+    ## in the correct format?
+    if (! isempty (start))
+      package = tolower (strtrim (nm.name));
+      ## Does the dependency specify a version
+      ## Example: package(>= version).
+      if (! isempty (nm.ver))
+        operator = nm.op;
+        if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
+          error ("unsupported operator: %s", operator);
+        endif
+        version = fix_version (nm.ver);
+        ## If no version is specified for the dependency
+        ## we say that the version should be greater than
+        ## or equal to "0.0.0".
+      else
+        package = tolower (strtrim (dep));
+        operator = ">=";
+        version  = "0.0.0";
       endif
-      operator = parts{1};
-      if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
-        error ("unsupported operator: %s", operator);
-      endif
-      version  = fix_version (parts{2});
-
-  ## If no version is specified for the dependency
-  ## we say that the version should be greater than
-  ## or equal to "0.0.0".
-  else
-    package = tolower (strtrim (dep));
-    operator = ">=";
-    version  = "0.0.0";
-  endif
-  deps_cell{i} = struct ("package", package, "operator", operator,
-                         "version", version);
+      deps_cell{i} = struct ("package", package, 
+                             "operator", operator,
+                             "version", version);
+    else
+      error ("incorrect syntax for dependency '%s' in the DESCRIPTION file\n",
+             dep);
+    endif
   endfor
 endfunction
 
diff --git a/scripts/pkg/private/fix_version.m b/scripts/pkg/private/fix_version.m
--- a/scripts/pkg/private/fix_version.m
+++ b/scripts/pkg/private/fix_version.m
@@ -20,28 +20,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{out} =} fix_version (@var{v})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Make sure the version string v is a valid x.y.z version string
 ## Examples: "0.1" => "0.1.0", "monkey" => error(...).
 function out = fix_version (v)
-  dots = find (v == ".");
-  if (length (dots) == 1)
-    major = str2num (v(1:dots-1));
-    minor = str2num (v(dots+1:end));
-    if (length (major) != 0 && length (minor) != 0)
-      out = sprintf ("%d.%d.0", major, minor);
-      return;
+
+  if (regexp (v, '^\d+(\.\d+){1,2}$') == 1)
+    parts = ostrsplit (v, '.', true);
+    if (numel (parts) == 2)
+      out = strcat (v, ".0");
+    else
+      out = v;
     endif
-  elseif (length (dots) == 2)
-    major = str2num (v(1:dots(1)-1));
-    minor = str2num (v(dots(1)+1:dots(2)-1));
-    rev = str2num (v(dots(2)+1:end));
-    if (length (major) != 0 && length (minor) != 0 && length (rev) != 0)
-      out = sprintf ("%d.%d.%d", major, minor, rev);
-      return;
-    endif
+  else
+    error ("bad version string: %s", v);
   endif
-  error ("bad version string: %s", v);
+
 endfunction
 
diff --git a/scripts/pkg/private/get_description.m b/scripts/pkg/private/get_description.m
--- a/scripts/pkg/private/get_description.m
+++ b/scripts/pkg/private/get_description.m
@@ -33,17 +33,17 @@ function desc = get_description (filenam
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
       ## Comments, do nothing.
     elseif (isspace (line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
-        desc.(keyword) = cstrcat (desc.(keyword), " ", deblank (line));
+        desc.(keyword) = [desc.(keyword) " " deblank(line)];
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
       if (length (colon) == 0)
         disp ("skipping line");
       else
         colon = colon(1);
diff --git a/scripts/pkg/private/get_forge_download.m b/scripts/pkg/private/get_forge_download.m
--- a/scripts/pkg/private/get_forge_download.m
+++ b/scripts/pkg/private/get_forge_download.m
@@ -21,8 +21,9 @@
 ## @deftypefn {Function File} {[@var{url}, @var{local_file}] =} list_forge_packages ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [url, local_file] = get_forge_download (name)
   [ver, url] = get_forge_pkg (name);
   local_file = [name, "-", ver, ".tar.gz"];
 endfunction
+
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -21,19 +21,17 @@
 ## @deftypefn {Function File} {[@var{ver}, @var{url}] =} get_forge_pkg (@var{name})
 ## Try to discover the current version of an OctaveForge package from the web,
 ## using a working internet connection and the urlread function.
 ## If two output arguments are requested, also return an address from which
 ## to download the file.
 ## @end deftypefn
 
 function [ver, url] = get_forge_pkg (name)
-  if (nargin != 1)
-    print_usage ();
-  endif
+
   ## Verify that name is valid.
   if (! (ischar (name) && rows (name) == 1 && ndims (name) == 2))
     error ("get_forge_pkg: package NAME must be a string");
   elseif (! all (isalnum (name) | name == "-" | name == "." | name == "_"))
     error ("get_forge_pkg: invalid package name: %s", name);
   endif
 
   name = tolower (name);
@@ -46,19 +44,19 @@ function [ver, url] = get_forge_pkg (nam
     ## Good. Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
-        # Build download string.
+        ## Build download string.
         pkg_file = sprintf ("%s-%s.tar.gz", name, ver);
-        url = cstrcat ("http://packages.octave.org/download/", pkg_file);
+        url = ["http://packages.octave.org/download/" pkg_file];
         ## Verify that the package string exists on the page.
         if (isempty (strfind (html, pkg_file)))
           warning ("get_forge_pkg: download URL not verified");
         endif
       endif
     endif
   else
     ## Try get the list of all packages.
@@ -75,8 +73,9 @@ function [ver, url] = get_forge_pkg (nam
         error ("get_forge_pkg: package not found: ""%s"". Maybe you meant ""%s?""", name, t{i});
       endif
     else
       error ("get_forge_pkg: could not read URL, please verify internet connection");
     endif
   endif
 
 endfunction
+
diff --git a/scripts/pkg/private/get_unsatisfied_deps.m b/scripts/pkg/private/get_unsatisfied_deps.m
--- a/scripts/pkg/private/get_unsatisfied_deps.m
+++ b/scripts/pkg/private/get_unsatisfied_deps.m
@@ -47,8 +47,9 @@ function bad_deps = get_unsatisfied_deps
         endif
       endfor
       if (! ok)
         bad_deps{end+1} = dep;
       endif
     endif
   endfor
 endfunction
+
diff --git a/scripts/pkg/private/getarch.m b/scripts/pkg/private/getarch.m
--- a/scripts/pkg/private/getarch.m
+++ b/scripts/pkg/private/getarch.m
@@ -18,13 +18,13 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{arch} =} getarch ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function arch = getarch ()
-  persistent _arch = cstrcat (octave_config_info ("canonical_host_type"),
-                              "-", octave_config_info ("api_version"));
+  persistent _arch = [octave_config_info("canonical_host_type"), "-", ...
+                      octave_config_info("api_version")];
   arch = _arch;
 endfunction
 
diff --git a/scripts/pkg/private/getarchprefix.m b/scripts/pkg/private/getarchprefix.m
--- a/scripts/pkg/private/getarchprefix.m
+++ b/scripts/pkg/private/getarchprefix.m
@@ -20,14 +20,14 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{archprefix} =} getarchprefix (@var{desc}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function archprefix = getarchprefix (desc, global_install)
   if (global_install)
     archprefix = fullfile (octave_config_info ("libdir"), "octave",
-                           "packages", cstrcat (desc.name, "-", desc.version));
+                           "packages", [desc.name "-" desc.version]);
   else
     archprefix = desc.dir;
   endif
 endfunction
 
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -116,21 +116,20 @@ function install (files, handle_deps, au
         [dummy, nm] = fileparts (tgz);
         if ((length (nm) >= length (desc.name))
             && ! strcmp (desc.name, nm(1:length (desc.name))))
           error ("package name '%s' doesn't correspond to its filename '%s'",
                  desc.name, nm);
         endif
 
         ## Set default installation directory.
-        desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
+        desc.dir = fullfile (prefix, [desc.name "-" desc.version]);
 
         ## Set default architectire dependent installation directory.
-        desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-                                                         desc.version));
+        desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
 
         ## Save desc.
         descriptions{end+1} = desc;
 
         ## Are any of the new packages already installed?
         ## If so we'll remove the old version.
         for j = 1:length (packages)
           if (strcmp (packages{j}.name, desc.name))
@@ -167,19 +166,18 @@ function install (files, handle_deps, au
                                      descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
         ok = false;
         for i = 1:length (bad_deps)
           dep = bad_deps{i};
-          error_text = cstrcat (error_text, " ", desc.name, " needs ",
-                               dep.package, " ", dep.operator, " ",
-                               dep.version, "\n");
+          error_text = [error_text " " desc.name " needs " ...
+                        dep.package " " dep.operator " " dep.version "\n"];
         endfor
       endif
     endfor
 
     ## Did we find any unsatisfied dependencies?
     if (! ok)
       error ("the following dependencies were unsatisfied:\n  %s", error_text);
     endif
@@ -338,8 +336,9 @@ function install (files, handle_deps, au
   ## we are checking if desc exists too because it's possible to ge to this point
   ## without creating it such as giving an invalid filename for the package
   if (exist ("desc", "var") && exist (fullfile (desc.dir, "packinfo", "NEWS"), "file"))
     printf ("For information about changes from previous versions of the %s package, run 'news (\"%s\")'.\n",
             desc.name, desc.name);
   endif
 
 endfunction
+
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -135,20 +135,19 @@ function [out1, out2] = installed_packag
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
       first_filesep = strfind (cur_dir(first_char:end), filesep ());
       if (! isempty (first_filesep))
-        cur_dir = cstrcat ("...",
-                          cur_dir((first_char + first_filesep(1) - 1):end));
+        cur_dir = ["..." cur_dir((first_char + first_filesep(1) - 1):end)];
       else
-        cur_dir = cstrcat ("...", cur_dir(first_char:end));
+        cur_dir = ["..." cur_dir(first_char:end)];
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
       cur_loaded = "*";
     else
       cur_loaded = " ";
     endif
     printf (format, cur_name, cur_loaded, cur_version, cur_dir);
diff --git a/scripts/pkg/private/is_architecture_dependent.m b/scripts/pkg/private/is_architecture_dependent.m
--- a/scripts/pkg/private/is_architecture_dependent.m
+++ b/scripts/pkg/private/is_architecture_dependent.m
@@ -39,8 +39,9 @@ function dep = is_architecture_dependent
       if (! isglob && (length (nm) - pos(end) != length (ext) - 1))
         continue;
       endif
       dep = true;
       break;
     endif
   endfor
 endfunction
+
diff --git a/scripts/pkg/private/list_forge_packages.m b/scripts/pkg/private/list_forge_packages.m
--- a/scripts/pkg/private/list_forge_packages.m
+++ b/scripts/pkg/private/list_forge_packages.m
@@ -37,8 +37,9 @@ function list = list_forge_packages ()
         ver = get_forge_pkg (list{i});
       catch
         ver = "unknown";
       end_try_catch
       printf ("  %s %s\n", list{i}, ver);
     endfor
   endif
 endfunction
+
diff --git a/scripts/pkg/private/load_packages_and_dependencies.m b/scripts/pkg/private/load_packages_and_dependencies.m
--- a/scripts/pkg/private/load_packages_and_dependencies.m
+++ b/scripts/pkg/private/load_packages_and_dependencies.m
@@ -26,23 +26,23 @@ function load_packages_and_dependencies 
                                          global_install)
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
     dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
-      execpath = cstrcat (execpath, pathsep (), fullfile (dirs{end}, "bin"));
+      execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
     endif
     tmpdir = getarchdir (installed_pkgs_lst{i});
     if (exist (tmpdir, "dir"))
       dirs{end + 1} = tmpdir;
       if (exist (fullfile (dirs{end}, "bin"), "dir"))
-        execpath = cstrcat (execpath, pathsep (), fullfile (dirs{end}, "bin"));
+        execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
       endif
     endif
   endfor
 
   ## Load the packages.
   if (length (dirs) > 0)
     addpath (dirs{:});
   endif
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -30,32 +30,31 @@ function descriptions = rebuild (prefix,
     endif
     ## the two first entries of dirlist are "." and ".."
     dirlist([1,2]) = [];
   else
     old_descriptions = installed_packages (list, list);
     wd = pwd ();
     unwind_protect
       cd (prefix);
-      dirlist = glob (cellfun(@(x) cstrcat (x, '-*'), files, 'uniformoutput', 0));
+      dirlist = glob (strcat (files, '-*'));
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
       printf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
       desc.dir = fullfile (prefix, dirlist{k});
-      desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-                                  desc.version));
+      desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
       if (auto != 0)
         if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
           unlink (fullfile (desc.dir, "packinfo", ".autoload"));
         endif
         if (auto < 0)
           desc.autoload = 0;
         elseif (auto > 0)
           desc.autoload = 1;
@@ -93,8 +92,9 @@ function descriptions = rebuild (prefix,
         endif
       endfor
     endfor
     if (! isempty (dup))
       descriptions (dup) = [];
     endif
   endif
 endfunction
+
diff --git a/scripts/pkg/private/repackage.m b/scripts/pkg/private/repackage.m
--- a/scripts/pkg/private/repackage.m
+++ b/scripts/pkg/private/repackage.m
@@ -39,18 +39,18 @@ function repackage (builddir, buildlist)
       endif
       rmdir (fullfile (pack.name, "inst", "packinfo"));
       if (exist (fullfile (pack.name, "inst", "doc"), "dir"))
         movefile (fullfile (pack.name, "inst", "doc"), pack.name);
       endif
       if (exist (fullfile (pack.name, "inst", "bin"), "dir"))
         movefile (fullfile (pack.name, "inst", "bin"), pack.name);
       endif
-      archdir = fullfile (pack.archprefix, cstrcat (pack.name, "-",
-                          pack.version), getarch ());
+      archdir = fullfile (pack.archprefix, [pack.name "-" pack.version],
+                          getarch ());
       if (exist (archdir, "dir"))
         if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_ADD"));
         endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_DEL"));
         endif
         if (exist (fullfile (archdir, "PKG_ADD"), "file"))
@@ -66,17 +66,17 @@ function repackage (builddir, buildlist)
           movefile (fullfile (pack.name, "inst", "PKG_ADD"),
                     fullfile (pack.name, "PKG_ADD"));
         endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
           movefile (fullfile (pack.name, "inst", "PKG_DEL"),
                     fullfile (pack.name, "PKG_DEL"));
         endif
       endif
-      tfile = cstrcat (pack.name, "-", pack.version, ".tar");
+      tfile = [pack.name "-" pack.version ".tar"];
       tar (tfile, pack.name);
       try
         gzip (tfile);
         unlink (tfile);
       catch
         warning ("failed to compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
diff --git a/scripts/pkg/private/shell.m b/scripts/pkg/private/shell.m
--- a/scripts/pkg/private/shell.m
+++ b/scripts/pkg/private/shell.m
@@ -25,32 +25,33 @@
 ## contain the output of the execeuted command.
 
 function [status, output] = shell (cmd, verbose)
   persistent have_sh;
 
   cmd = strrep (cmd, "\\", "/");
   if (ispc () && ! isunix ())
     if (isempty (have_sh))
-      if (system ("sh.exe -c \"exit\""))
+      if (system ('sh.exe -c "exit"'))
         have_sh = false;
       else
         have_sh = true;
       endif
     endif
     if (have_sh)
-      cmd = cstrcat ("sh.exe -c \"", cmd, "\"");
+      cmd = ['sh.exe -c "' cmd '"'];
     else
       error ("pkg: unable to find the command shell.");
     endif
   endif
   ## if verbose, we want to display the output in real time. To do this, we
   ## must call system with 1 output argument. But then the variable `output'
   ## won't exist. So we initialize it empty. If an error does occur, and we
   ## are verbose we will return an empty string but it's all fine since
   ## the error message has already been displayed.
   output = "";
   if (verbose)
     [status] = system (cmd);
   else
     [status, output] = system (cmd);
   endif
 endfunction
+
diff --git a/scripts/pkg/private/uninstall.m b/scripts/pkg/private/uninstall.m
--- a/scripts/pkg/private/uninstall.m
+++ b/scripts/pkg/private/uninstall.m
@@ -76,19 +76,18 @@ function uninstall (pkgnames, handle_dep
     for i = 1:length (remaining_packages)
       desc = remaining_packages{i};
       bad_deps = get_unsatisfied_deps (desc, remaining_packages);
 
       ## Will the uninstallation break any dependencies?
       if (! isempty (bad_deps))
         for i = 1:length (bad_deps)
           dep = bad_deps{i};
-          error_text = cstrcat (error_text, " ", desc.name, " needs ",
-                               dep.package, " ", dep.operator, " ",
-                               dep.version, "\n");
+          error_text = [error_text " " desc.name " needs " ...
+                        dep.package " " dep.operator " " dep.version "\n"];
         endfor
       endif
     endfor
 
     if (! isempty (error_text))
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
@@ -140,8 +139,9 @@ function uninstall (pkgnames, handle_dep
       unlink (local_list);
     else
       local_packages = save_order (remaining_packages);
       save (local_list, "local_packages");
     endif
   endif
 
 endfunction
+
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -68,14 +68,13 @@ function unload_packages (files, handle_
   endfor
 
   ## Unload the packages.
   for i = 1:length (archdirs)
     d = archdirs{i};
     idx = strcmp (p, d);
     if (any (idx))
       rmpath (d);
-      ## FIXME: We should also check if we need to remove items from
-      ## EXEC_PATH.
+      ## FIXME: We should also check if we need to remove items from EXEC_PATH.
     endif
   endfor
 endfunction
 
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/appearance/__clabel__.m
rename from scripts/plot/private/__clabel__.m
rename to scripts/plot/appearance/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/appearance/__clabel__.m
@@ -17,99 +17,113 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} __clabel__ (@var{c}, @var{v}, @var{hparent}, @var{label_spacing}, @var{z}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
-  ## FIXME
-  ## Assume that the plot size is 4 by 3 inches.
+
+  hax = ancestor (hparent, "axes");
+  units = get (hax, "units");
+  set (hax, "units", "points");
+  axpos = get (hax, "position");
+  set (hax, "units", units);
   lims = axis ();
-  xspacing = 72 * 4 / abs (lims(1) - lims(2));
-  yspacing = 72 * 3 / abs (lims(3) - lims(4));
+  xspacing = axpos(3) / (lims(2) - lims (1));
+  yspacing = axpos(4) / (lims(4) - lims (3));
 
   if (isscalar (hparent) && ishandle (hparent)
       && strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
     xmin = min (x(:));
     xmax = max (x(:));
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
-    i1 = 1;
-    while (i1 < length (c))
-      clev = c(1,i1);
-      clen = c(2,i1);
-      p = c(:, i1+1:i1+clen);
+    xmin = xmax = ymin = ymax = NaN;
+    i = 1;
+    while (i < length (c))
+      clen = c(2,i);
+      data = c(:, i+(1:clen));
 
-      xmin = min (c(1,:));
-      xmax = max (c(1,:));
-      ymin = min (c(2,:));
-      ymax = max (c(2,:));
+      xmin = min ([xmin, data(1,:)]);
+      xmax = max ([xmax, data(1,:)]);
+      ymin = min ([ymin, data(2,:)]);
+      ymax = max ([ymax, data(2,:)]);
 
-      i1 += clen+1;
+      i += clen+1;
     endwhile
   endif
 
   ## Decode contourc output format and place labels.
-  i1 = 1;
   h = [];
-  while (i1 < length (c))
-    clev = c(1,i1);
-    clen = c(2,i1);
+  i = 1;
+  while (i < length (c))
+    clev = c(1,i);
+    clen = c(2,i);
 
-    if (!isempty (v) && ! any (find (clev == v)))
-      i1 += clen+1;
+    if (! isempty (v) && ! any (v == clev))
+      i += clen+1;
       continue;
     endif
 
-    p = c(:, i1+1:i1+clen) .* repmat ([xspacing; yspacing], 1, clen);
+    p = bsxfun (@times, c(:, i+(1:clen)), [xspacing; yspacing]);
     d = sqrt (sumsq (diff (p, 1, 2)));
     cumd = cumsum (d);
-    td = sum (d);
+    td = cumd(end);
     ntag = ceil (td / label_spacing);
 
-    if (all (c(:,i1+1) == c(:,i1+clen)))
-      Spacing = td / ntag;
-      pos = Spacing / 2 + [0:ntag-1] * Spacing;
+    if (all (c(:,i+1) == c(:,i+clen)))
+      ## Closed contour
+      ## FIXME: This spreads the tags uniformly around the contour which
+      ## looks nice, but it does not respect the label_spacing attribute.
+      ## Should we follow user input, which can result in two labels being
+      ## quite close to each other?
+      spacing = td / ntag;
+      pos = spacing/2 + spacing*[0:ntag-1];
     else
+      ## Open contour
       pos = zeros (1, ntag);
-      pos(1) = (td - label_spacing * (ntag - 1)) ./ 2;
-      pos(2:ntag) = pos(1) + [1:ntag-1] * label_spacing;
+      pos(1) = (td - label_spacing*(ntag - 1)) / 2;
+      pos(2:ntag) = pos(1) + label_spacing*[1:ntag-1];
     endif
 
-    j1 = 2;
-    tlabel = sprintf ("%g", clev);
-    for i = 1 : ntag
-      tagpos = pos(i);
+    tlabel = sprintf ("%.5g", clev);
+
+    for tagpos = pos
 
-      while (j1 < clen && cumd(j1) < tagpos)
-        j1++;
-      endwhile
-      tpos = sum (c(:,i1+j1-1:i1+j1), 2) ./ 2;
+      j = find (cumd > tagpos, 1);
+      if (isempty (j))
+        j = clen;
+      endif
+      tpos = sum (c(:,i+j-1:i+j), 2) / 2;
 
-      if (tpos(1) != xmin &&  tpos(1) != xmax
-          && tpos(2) != ymin &&  tpos(2) != ymax)
-        trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
-                                 diff (c(1,i1+j1-1:i1+j1)));
-
+      if (   tpos(1) != xmin && tpos(1) != xmax
+          && tpos(2) != ymin && tpos(2) != ymax)
+        trot = 180 / pi * atan2 (diff (c(2,i+j-1:i+j)),
+                                 diff (c(1,i+j-1:i+j)));
+        if (abs (trot) > 90)
+          trot += 180;
+        endif
         if (ischar (z))
           ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot,
-                     "parent", hparent, "horizontalalignment", "center",
-                     "userdata", clev, varargin{:});
-        elseif (!isempty (z))
+                     "horizontalalignment", "center", "userdata", clev,
+                     "parent", hparent, varargin{:});
+        elseif (! isempty (z))
           ht = text (tpos(1), tpos(2), z, tlabel, "rotation", trot,
-                     "parent", hparent, "horizontalalignment", "center",
-                     "userdata", clev, varargin{:});
+                     "horizontalalignment", "center", "userdata", clev,
+                     "parent", hparent, varargin{:});
         else
           ht = text (tpos(1), tpos(2), tlabel, "rotation", trot,
-                     "parent", hparent, "horizontalalignment", "center",
-                     "userdata", clev, varargin{:});
+                     "horizontalalignment", "center", "userdata", clev,
+                     "parent", hparent, varargin{:});
         endif
         h = [h; ht];
       endif
     endfor
-    i1 += clen+1;
+    i += clen+1;
   endwhile
+
 endfunction
+
diff --git a/scripts/plot/private/__getlegenddata__.m b/scripts/plot/appearance/__getlegenddata__.m
rename from scripts/plot/private/__getlegenddata__.m
rename to scripts/plot/appearance/__getlegenddata__.m
--- a/scripts/plot/private/__getlegenddata__.m
+++ b/scripts/plot/appearance/__getlegenddata__.m
@@ -17,42 +17,45 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{hplots}, @var{strings}]} = __getlegenddata__ (@var{h})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [hplots, text_strings] = __getlegenddata__ (hlegend)
+
   hplots = [];
   text_strings = {};
   ca = getfield (get (hlegend, "userdata"), "handle");
-  kids = [];
-  for i = 1:numel (ca)
-    kids = [kids; get(ca(i), "children")];
-  endfor
+  if (numel (ca) == 1)
+    kids = get (ca, "children");
+  else
+    kids = [get(kids, "children"){:}];
+  endif
 
   for i = numel (kids):-1:1
     typ = get (kids(i), "type");
-    if (strcmp (typ, "line") || strcmp (typ, "surface")
-        || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
-
+    if (any (strcmp (typ, {"line", "patch", "surface", "hggroup"})))
       if (strcmp (typ, "hggroup"))
         hgkids = get (kids(i), "children");
         for j = 1 : length (hgkids)
-          hgobj = get (hgkids (j));
-          if (isfield (hgobj, "displayname") && ! isempty (hgobj.displayname))
-            hplots = [hplots, hgkids(j)];
-            text_strings = {text_strings{:}, hgobj.displayname};
-            break;
-          endif
+          try
+            dname = get (hgkids(j), "DisplayName");
+            if (! isempty (dname))
+              hplots(end+1) = hgkids(j);
+              text_strings(end+1) = dname;
+              break;  # break from j-loop over hgkids
+            endif
+          end_try_catch
         endfor
       else
-        if (! isempty (get (kids (i), "displayname")))
-          hplots = [hplots, kids(i)];
-          text_strings = {text_strings{:}, get(kids (i), "displayname")};
+        dname = get (kids(i), "DisplayName");
+        if (! isempty (dname))
+          hplots(end+1) = kids(i);
+          text_strings(end+1) = dname;
         endif
       endif
-
     endif
   endfor
 
 endfunction
+
diff --git a/scripts/plot/axis.m b/scripts/plot/appearance/axis.m
rename from scripts/plot/axis.m
rename to scripts/plot/appearance/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -18,28 +18,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} axis ()
 ## @deftypefnx {Function File} {} axis ([@var{x}_lo @var{x}_hi])
 ## @deftypefnx {Function File} {} axis ([@var{x}_lo @var{x}_hi @var{y}_lo @var{y}_hi])
 ## @deftypefnx {Function File} {} axis ([@var{x}_lo @var{x}_hi @var{y}_lo @var{y}_hi @var{z}_lo @var{z}_hi])
 ## @deftypefnx {Function File} {} axis (@var{option})
 ## @deftypefnx {Function File} {} axis (@dots{}, @var{option})
-## @deftypefnx {Function File} {} axis (@var{h}, @dots{})
+## @deftypefnx {Function File} {} axis (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{limits} =} axis ()
-## Set axis limits for plots.
+## Set axis limits and appearance.
 ##
 ## The argument @var{limits} should be a 2-, 4-, or 6-element vector.  The
 ## first and second elements specify the lower and upper limits for the
 ## x-axis.  The third and fourth specify the limits for the y-axis, and the
 ## fifth and sixth specify the limits for the z-axis.
 ##
 ## Without any arguments, @code{axis} turns autoscaling on.
 ##
-## With one output argument, @code{x = axis} returns the current axes.
+## With one output argument, @code{@var{limits} = axis} returns the current
+## axis limits.
 ##
 ## The vector argument specifying limits is optional, and additional
 ## string arguments may be used to specify various axis properties.  For
 ## example,
 ##
 ## @example
 ## axis ([1, 2, 3, 4], "square");
 ## @end example
@@ -54,120 +55,126 @@
 ## @noindent
 ## turns tic marks on for all axes and tic mark labels on for the y-axis
 ## only.
 ##
 ## @noindent
 ## The following options control the aspect ratio of the axes.
 ##
 ## @table @asis
-## @item "square"
+## @item @qcode{"square"}
 ## Force a square aspect ratio.
 ##
-## @item "equal"
+## @item @qcode{"equal"}
 ## Force x distance to equal y-distance.
 ##
-## @item "normal"
-## Restore the balance.
+## @item @qcode{"normal"}
+## Restore default aspect ratio.
 ## @end table
 ##
 ## @noindent
 ## The following options control the way axis limits are interpreted.
 ##
 ## @table @asis
-## @item "auto"
+## @item @qcode{"auto"}
 ## Set the specified axes to have nice limits around the data
 ## or all if no axes are specified.
 ##
-## @item "manual"
+## @item @qcode{"manual"}
 ## Fix the current axes limits.
 ##
-## @item "tight"
+## @item @qcode{"tight"}
 ## Fix axes to the limits of the data.
-## @end table
 ##
-## @noindent
-## The option @code{"image"} is equivalent to @code{"tight"} and
-## @code{"equal"}.
+## @item @qcode{"image"}
+## Equivalent to @qcode{"tight"} and @qcode{"equal"}.
+## @end table
 ##
 ## @noindent
 ## The following options affect the appearance of tic marks.
 ##
 ## @table @asis
-## @item "on"
+## @item @qcode{"on"}
 ## Turn tic marks and labels on for all axes.
 ##
-## @item "off"
+## @item @qcode{"off"}
 ## Turn tic marks off for all axes.
 ##
-## @item "tic[xyz]"
+## @item @qcode{"tic[xyz]"}
 ## Turn tic marks on for all axes, or turn them on for the
 ## specified axes and off for the remainder.
 ##
-## @item "label[xyz]"
+## @item @qcode{"label[xyz]"}
 ## Turn tic labels on for all axes, or turn them on for the
 ## specified axes and off for the remainder.
 ##
-## @item "nolabel"
+## @item @qcode{"nolabel"}
 ## Turn tic labels off for all axes.
 ## @end table
 ##
 ## Note, if there are no tic marks for an axis, there can be no labels.
 ##
 ## @noindent
-## The following options affect the direction of increasing values on
-## the axes.
+## The following options affect the direction of increasing values on the axes.
 ##
 ## @table @asis
-## @item "ij"
+## @item @qcode{"ij"}
 ## Reverse y-axis, so lower values are nearer the top.
 ##
-## @item "xy"
+## @item @qcode{"xy"}
 ## Restore y-axis, so higher values are nearer the top.
 ## @end table
 ##
-## If an axes handle is passed as the first argument, then operate on
-## this axes rather than the current axes.
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axes rather than the current axes returned by @code{gca}.
+##
+## @seealso{xlim, ylim, zlim, daspect, pbaspect, box, grid}
 ## @end deftypefn
 
 ## Author: jwe
 
-function varargout = axis (varargin)
+function limits = axis (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("axis", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("axis", varargin{:});
-
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    varargout = cell (max (nargin == 0, nargout), 1);
-    if (isempty (varargout))
-      __axis__ (h, varargin{:});
+    if (isempty (hax))
+      hax = gca ();
+    endif
+    if (nargin == 0)
+      limits = __axis__ (hax, varargin{:});
     else
-      [varargout{:}] = __axis__ (h, varargin{:});
+      __axis__ (hax, varargin{:});
     endif
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
-function curr_axis = __axis__ (ca, ax, varargin)
+function limits = __axis__ (ca, ax, varargin)
 
   if (nargin == 1)
     if (nargout == 0)
       set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
     else
       xlim = get (ca, "xlim");
       ylim = get (ca, "ylim");
       view = get (ca, "view");
       if (view(2) == 90)
-        curr_axis = [xlim, ylim];
+        limits = [xlim, ylim];
       else
         zlim = get (ca, "zlim");
-        curr_axis = [xlim, ylim, zlim];
+        limits = [xlim, ylim, zlim];
       endif
     endif
 
   elseif (ischar (ax))
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
     if (strcmpi (ax, "ij"))
@@ -321,39 +328,57 @@ function lims = __get_tight_lims__ (ca, 
     data = get (kids, strcat (ax, "data"));
     scale = get (ca, strcat (ax, "scale"));
     if (! iscell (data))
       data = {data};
     endif
     if (strcmp (scale, "log"))
       tmp = data;
       data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
-      n = cellfun (@isempty, data);
+      n = cellfun ("isempty", data);
       data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
     data = cellfun (@(x) x(isfinite (x)), data, "uniformoutput", false);
     data = data(! cellfun ("isempty", data));
     if (! isempty (data))
-      lims_min = min (cellfun (@(x) min (x(:)), data(:)));
-      lims_max = max (cellfun (@(x) max (x(:)), data(:)));
-      lims = [lims_min, lims_max];
+      ## Change data from cell array of various sizes to a single column vector
+      data = cat (1, cellindexmat (data, ":"){:});
+      lims = [min(data), max(data)];
     else
       lims = [0, 1];
     endif
   endif
 
 endfunction
 
 function __do_tight_option__ (ca)
 
-  set (ca,
-       "xlim", __get_tight_lims__ (ca, "x"),
-       "ylim", __get_tight_lims__ (ca, "y"));
-  if (__calc_dimensions__ (ca) > 2)
-    set (ca, "zlim", __get_tight_lims__ (ca, "z"));
+  xlim = __get_tight_lims__ (ca, "x");
+  if (all (xlim == 0))
+    xlim = eps () * [-1 1];
+  elseif (diff (xlim == 0))
+    xlim = xlim .* (1 + eps () * [-1, 1]);
+  endif
+  ylim = __get_tight_lims__ (ca, "y");
+  if (all (ylim == 0))
+    ylim = eps () * [-1 1];
+  elseif (diff (ylim == 0))
+    ylim = ylim .* (1 + eps () * [-1, 1]);
+  endif
+  set (ca, "xlim", xlim, "ylim", ylim)
+  nd = __calc_dimensions__ (ca);
+  is3dview = (get (ca, "view")(2) != 90);
+  if (nd > 2 && is3dview)
+    zlim = __get_tight_lims__ (ca, "z");
+    if (all (zlim == 0))
+      zlim = eps () * [-1 1];
+    elseif (diff (zlim == 0))
+      zlim = zlim .* (1 + eps () * [-1, 1]);
+    endif
+    set (ca, "zlim", zlim);
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 0:0.01:2*pi;
@@ -466,32 +491,32 @@ endfunction
 %!
 %! subplot (324);
 %!  plot (t, x, ';sine [0:2pi];');
 %!  title ('axes at [0 3 0 1], then autox');
 %!  axis ([0,3,0,1]);
 %!  axis ('autox');
 %!
 %! subplot (325);
-%!  plot (t, x, ';sine [0:2p];');
+%!  plot (t, x, ';sine [0:2pi];');
 %!  title ('axes at [3 6 0 1], then autoy');
 %!  axis ([3,6,0,1]);
 %!  axis ('autoy');
 %!
 %! subplot (326);
 %!  plot (t, sin(t), t, -2*sin(t/2));
 %!  axis ('tight');
 %!  title ('tight');
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! plot (x, sin(x));
 %! axis image;
-%! title ('image');
+%! title ({'image', 'equivalent to "tight" & "equal"'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x,y,z] = peaks (50);
 %! x1 = max (x(:));
 %! pcolor (x-x1, y-x1/2, z);
 %! hold on;
@@ -513,60 +538,61 @@ endfunction
 %! loglog (1:20, '-s');
 %! axis tight;
 
 %!demo
 %! clf;
 %! x = -10:0.1:10;
 %! y = sin (x)./(1 + abs (x)) + 0.1*x - 0.4;
 %! plot (x, y);
-%! title ('no plot box');
 %! set (gca, 'xaxislocation', 'zero');
 %! set (gca, 'yaxislocation', 'zero');
 %! box off;
+%! title ({'no plot box', 'xaxislocation = zero, yaxislocation = zero'});
 
 %!demo
 %! clf;
 %! x = -10:0.1:10;
 %! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
 %! plot (x, y);
-%! title ('no plot box');
 %! set (gca, 'xaxislocation', 'zero');
 %! set (gca, 'yaxislocation', 'left');
 %! box off;
+%! title ({'no plot box', 'xaxislocation = zero, yaxislocation = left'});
 
 %!demo
 %! clf;
 %! x = -10:0.1:10;
 %! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
 %! plot (x, y);
 %! title ('no plot box');
 %! set (gca, 'xaxislocation', 'zero');
 %! set (gca, 'yaxislocation', 'right');
 %! box off;
+%! title ({'no plot box', 'xaxislocation = zero, yaxislocation = right'});
 
 %!demo
 %! clf;
 %! x = -10:0.1:10;
 %! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
 %! plot (x, y);
-%! title ('no plot box');
 %! set (gca, 'xaxislocation', 'bottom');
 %! set (gca, 'yaxislocation', 'zero');
 %! box off;
+%! title ({'no plot box', 'xaxislocation = bottom, yaxislocation = zero'});
 
 %!demo
 %! clf;
 %! x = -10:0.1:10;
 %! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
 %! plot (x, y);
-%! title ('no plot box');
 %! set (gca, 'xaxislocation', 'top');
 %! set (gca, 'yaxislocation', 'zero');
 %! box off;
+%! title ({'no plot box', 'xaxislocation = top, yaxislocation = zero'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (11:20, [21:24, NaN, -Inf, 27:30]);
 %!   hold all;
 %!   plot (11:20, 25.5 + rand (10));
 %!   axis tight;
@@ -581,8 +607,21 @@ endfunction
 %!   a = logspace (-5, 1, 10);
 %!   loglog (a, -a);
 %!   axis tight;
 %!   assert (axis (), [1e-5, 10, -10, -1e-5]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+## Test 'axis tight' with differently oriented, differently numbered data vecs
+## Bug #40036.
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   Z = peaks (linspace (-3, 3, 49), linspace (-2, 2, 29));
+%!   surf (Z);
+%!   axis tight;
+%!   assert (axis (), [1 49 1 29 min(Z(:)) max(Z(:))]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/box.m b/scripts/plot/appearance/box.m
rename from scripts/plot/box.m
rename to scripts/plot/appearance/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/appearance/box.m
@@ -12,37 +12,42 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} box
-## @deftypefnx {Function File} {} box ("on")
-## @deftypefnx {Function File} {} box ("off")
+## @deftypefn  {Command} {} box on
+## @deftypefnx {Command} {} box off
+## @deftypefnx {Command} {} box
 ## @deftypefnx {Function File} {} box (@var{hax}, @dots{})
-## Control the display of a border around the plot.
-## The argument may be either @code{"on"} or @code{"off"}.  If it is
+## Control display of the axis border.
+##
+## The argument may be either @qcode{"on"} or @qcode{"off"}.  If it is
 ## omitted, the current box state is toggled.
 ##
-## If the first argument is an axis handle, @var{hax}, operate on the
-## specified axis object.
-## @seealso{grid}
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+## @seealso{axis, grid}
 ## @end deftypefn
 
 ## Author: jwe
 
 function box (varargin)
 
-  [ax, varargin, nargs] = __plt_get_axis_arg__ ("box", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("box", varargin{:});
 
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (nargs == 0)
-    box_state = get (ax, "box");
+    box_state = get (hax, "box");
     if (strcmp (box_state, "on"))
       box_state = "off";
     else
       box_state = "on";
     endif
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
@@ -55,11 +60,12 @@ function box (varargin)
       endif
     else
       error ('box: argument must be "on" or "off"');
     endif
   else
     print_usage ();
   endif
 
-  set (ax, "box", box_state);
+  set (hax, "box", box_state);
 
 endfunction
+
diff --git a/scripts/plot/caxis.m b/scripts/plot/appearance/caxis.m
rename from scripts/plot/caxis.m
rename to scripts/plot/appearance/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/appearance/caxis.m
@@ -12,77 +12,86 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} caxis (@var{limits})
-## @deftypefnx {Function File} {} caxis (@var{h}, @dots{})
-## Set color axis limits for plots.
+## @deftypefn  {Function File} {} caxis ([cmin cmax])
+## @deftypefnx {Function File} {} caxis ("auto")
+## @deftypefnx {Function File} {} caxis ("manual")
+## @deftypefnx {Function File} {} caxis (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{limits} =} caxis ()
+## Query or set color axis limits for plots.
 ##
-## The argument @var{limits} should be a 2-element vector specifying the
+## The limits argument should be a 2-element vector specifying the
 ## lower and upper limits to assign to the first and last value in the
-## colormap.  Values outside this range are clamped to the first and last
+## colormap.  Data values outside this range are clamped to the first and last
 ## colormap entries.
 ##
-## If @var{limits} is "auto", then automatic colormap scaling is applied,
-## whereas if @var{limits} is "manual" the colormap scaling is set to manual.
+## If the @qcode{"auto"} option is given then automatic colormap limits are
+## applied.  The automatic algorithm sets @var{cmin} to the minimum data value
+## and @var{cmax} to the maximum data value.  If @qcode{"manual"} is specified
+## then the @qcode{"climmode"} property is set to @qcode{"manual"} and the
+## numeric values in the @qcode{"clim"} property are used for limits.
 ##
-## Called without any arguments to current color axis limits are returned.
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
 ##
-## If an axes handle is passed as the first argument, then operate on
-## this axes rather than the current axes.
+## Called without arguments the current color axis limits are returned.
+## @seealso{colormap}
 ## @end deftypefn
 
-function varargout = caxis (varargin)
+function limits = caxis (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("caxis", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("caxis", varargin{:});
-
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    varargout = cell (max (nargin == 0, nargout), 1);
-    if (isempty (varargout))
-      __caxis__ (h, varargin{:});
+    if (isempty (hax))
+      hax = gca ();
+    endif
+    if (nargin == 0)
+      limits = __caxis__ (hax);
     else
-      [varargout{:}] = __caxis__ (h, varargin{:});
+      __caxis__ (hax, varargin{:});
     endif
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
-function [cmin, cmax] = __caxis__ (ca, ax, varargin)
+function limits = __caxis__ (ca, ax, varargin)
 
   if (nargin == 1)
-    cmin = get (ca, "clim");
-    if (nargout > 1)
-      cmax = cmin(2);
-      cmin = cmin(1);
-    endif
+    limits = get (ca, "clim");
   elseif (ischar (ax))
     if (strcmpi (ax, "auto"))
       set (ca, "climmode", "auto");
     elseif (strcmpi (ax, "manual"))
       set (ca, "climmode", "manual");
     endif
   elseif (isvector (ax))
     len = length (ax);
-
     if (len != 2)
       error ("caxis: expecting vector with 2 elements");
     endif
 
     set (ca, "clim", [ax(1), ax(2)]);
   else
-    error ("caxis: expecting no args, a string or a 2 element vector");
+    error ("caxis: expecting no args, a string, or a 2 element vector");
   endif
 
+  ## FIXME: Why should it be possible to call __caxis__ recursively?
   if (nargin > 2)
     __caxis__ (ca, varargin{:})';
   endif
 
 endfunction
 
diff --git a/scripts/plot/clabel.m b/scripts/plot/appearance/clabel.m
rename from scripts/plot/clabel.m
rename to scripts/plot/appearance/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/appearance/clabel.m
@@ -16,130 +16,138 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} clabel (@var{c}, @var{h})
 ## @deftypefnx {Function File} {} clabel (@var{c}, @var{h}, @var{v})
 ## @deftypefnx {Function File} {} clabel (@var{c}, @var{h}, "manual")
 ## @deftypefnx {Function File} {} clabel (@var{c})
-## @deftypefnx {Function File} {} clabel (@var{c}, @var{h})
 ## @deftypefnx {Function File} {} clabel (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} clabel (@dots{})
-## Add labels to the contours of a contour plot.  The contour plot is specified
-## by the contour matrix @var{c} and optionally the contourgroup object @var{h}
-## that are returned by @code{contour}, @code{contourf} and @code{contour3}.
-## The contour labels are rotated and placed in the contour itself.
+## Add labels to the contours of a contour plot.
+##
+## The contour levels are specified by the contour matrix @var{c} which is
+## returned by @code{contour}, @code{contourc}, @code{contourf}, and
+## @code{contour3}.  Contour labels are rotated to match the local line 
+## orientation and centered on the line.  The position of labels along the
+## contour line is chosen randomly.
+##
+## If the argument @var{h} is a handle to a contour group object, then label
+## this plot rather than the one in the current axes returned by @code{gca}.
 ##
 ## By default, all contours are labeled.  However, the contours to label can be
-## specified by the vector @var{v}.  If the "manual" argument is given then
-## the contours to label can be selected with the mouse.
+## specified by the vector @var{v}.  If the @qcode{"manual"} argument is
+## given then the contours to label can be selected with the mouse.
 ##
 ## Additional property/value pairs that are valid properties of text objects
-## can be given and are passed to the underlying text objects.  Additionally,
-## the property "LabelSpacing" is available allowing the spacing between labels
-## on a contour (in points) to be specified.  The default is 144 points, or 2
-## inches.
+## can be given and are passed to the underlying text objects.  Moreover,
+## the contour group property @qcode{"LabelSpacing"} is available which
+## determines the spacing between labels on a contour to be specified.  The
+## default is 144 points, or 2 inches.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to
-## the text objects representing each label.  
-## The "userdata" property of the text objects contains the numerical value of
-## the contour label.
+## the text objects representing each label.
+## The @qcode{"userdata"} property of the text objects contains the numerical
+## value of the contour label.
 ##
 ## An example of the use of @code{clabel} is
 ##
 ## @example
 ## @group
 ## [c, h] = contour (peaks (), -4 : 6);
 ## clabel (c, h, -4:2:6, "fontsize", 12);
 ## @end group
 ## @end example
 ##
 ## @seealso{contour, contourf, contour3, meshc, surfc, text}
 ## @end deftypefn
 
-function retval = clabel (c, varargin)
-  label_spacing = 2 * 72;
+function h = clabel (c, varargin)
+
   have_hg = false;
   have_labelspacing = false;
+  label_spacing = 144;  # 2 inches in points
 
   if (nargin < 1)
     print_usage ();
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
     if (isscalar (arg) && ishandle (arg)
         && strcmp (get (arg, "type"), "hggroup"))
-      obj = get (arg);
-      if (! isfield (obj, "contourmatrix"))
-        error ("clabel: expecting the handle to be a contour group");
-      endif
+      try
+        get (arg, "contourmatrix");
+      catch
+        error ("clabel: H must be a handle to a contour group");
+      end_try_catch
+      have_hg = true;
       hg = arg;
-      have_hg = true;
       varargin(1) = [];
     else
       hparent = gca ();
     endif
   endif
 
   if (length (varargin) > 0 && isnumeric (varargin{1}))
     v = varargin{1}(:);
     varargin(1) = [];
   else
     v = [];
   endif
 
-  for i = 1 : length (varargin) - 1
-    arg = varargin{i};
-    if (strcmpi (arg, "labelspacing"))
-      label_spacing = varargin{i+1};
-      have_labelspacing = true;
-      varargin(i:i+1) = [];
-      break;
-    endif
-  endfor
+  idx = strcmpi (varargin(1:2:end), "manual");
+  if (any (idx))
+    error ('clabel: "manual" contour mode is not supported');
+  endif
 
-  for i = 1 : length (varargin)
-    arg = varargin{i};
-    if (strcmpi (arg, "manual"))
-      error ("clabel: manual contouring mode not supported");
-    endif
-  endfor
+  idx = find (strcmpi (varargin(1:2:end), "labelspacing"), 1);
+  if (! isempty (idx))
+    have_labelspacing = true;
+    label_spacing = varargin{2*idx};
+    varargin(2*idx+(-1:0)) = [];
+  endif    
 
   if (have_hg)
     if (! isempty (v))
       if (have_labelspacing)
         set (hg, "textlistmode", "manual", "textlist", v,
-             "labelspacing", label_spacing, "showtext", "on");
+                 "labelspacing", label_spacing, "showtext", "on");
       else
         set (hg, "textlistmode", "manual", "textlist", v, "showtext", "on");
       endif
     else
       if (have_labelspacing)
-        set (hg,"showtext", "on", "labelspacing", label_spacing);
+        set (hg, "showtext", "on", "labelspacing", label_spacing);
       else
-        set (hg,"showtext", "on");
+        set (hg, "showtext", "on");
       endif
     endif
-    retval = findobj (hg, "type", "text");
+    htmp = findobj (hg, "type", "text");
     if (! isempty (varargin))
-      set (retval, varargin {:});
+      set (htmp, varargin{:});
     endif
   else
-    retval =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
+    htmp =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
+  endif
+
+  if (nargout > 0)
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [c, h] = contour (peaks (), -4:6);
 %! clabel (c, h, -4:2:6, 'fontsize', 12);
+%! title ('clabel() labeling every other contour');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [c, h] = contourf (peaks (), -7:6);
 %! clabel (c, h, -6:2:6, 'fontsize', 12);
+%! title ('clabel() labeling every other contour');
 
diff --git a/scripts/plot/daspect.m b/scripts/plot/appearance/daspect.m
rename from scripts/plot/daspect.m
rename to scripts/plot/appearance/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/appearance/daspect.m
@@ -17,84 +17,86 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{data_aspect_ratio} =} daspect ()
 ## @deftypefnx {Function File} {} daspect (@var{data_aspect_ratio})
 ## @deftypefnx {Function File} {} daspect (@var{mode})
 ## @deftypefnx {Function File} {@var{data_aspect_ratio_mode} =} daspect ("mode")
 ## @deftypefnx {Function File} {} daspect (@var{hax}, @dots{})
-## Query or set the data aspect ratio of the current axes.  The aspect 
-## ratio is a normalized 3-element vector representing the span of the x, y,
-## and z-axis limits.
+## Query or set the data aspect ratio of the current axes.
+##
+## The aspect ratio is a normalized 3-element vector representing the span of
+## the x, y, and z-axis limits.
 ## 
 ## @code{(daspect (@var{mode}))}
 ##
 ## Set the data aspect ratio mode of the current axes.  @var{mode} is
-## either "auto" or "manual".
+## either @qcode{"auto"} or @qcode{"manual"}.
 ## 
-## @code{daspect ("mode")}
+## @code{daspect (@qcode{"mode"})}
 ##
 ## Return the data aspect ratio mode of the current axes.
 ## 
 ## @code{daspect (@var{hax}, @dots{})}
 ##
 ## Operate on the axes in handle @var{hax} instead of the current axes.
 ## 
 ## @seealso{axis, pbaspect, xlim, ylim, zlim}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-01-26
 
-function varargout = daspect (varargin)
+function daratio = daspect (varargin)
 
-  hax = gca ();
-
+  ## Grab axes handle if present
   if (nargin > 0)
-    if (isscalar (varargin{1}) && ishandle (varargin{1}))
+    if (isscalar (varargin{1}) && isaxes (varargin{1}))
       hax = varargin{1};
       varargin = varargin(2:end);
+    else
+      hax = gca ();
     endif
+  else
+    hax = gca ();
   endif
-  if (numel (varargin) > 0)
-    if (numel (varargin) == 1)
-      if (ischar (varargin{1})
-          && any (strcmpi (varargin{1}, {"mode", "manual", "auto"})))
-        switch (varargin{1})
-        case "mode"
-          if (nargout < 2)
-            varargout{1} = get (hax, "dataaspectratiomode");
-            return
-          else
-            error ("daspect: only one output is allowed");
-          endif
-        case "manual"
-          set (hax, "dataaspectratiomode", "manual");
-        case "auto"
-          set (hax, "dataaspectratiomode", "auto");
-        endswitch
-      elseif (isreal (varargin{1}) && numel (varargin{1}) == 2)
-        set (hax, "dataaspectratio", [varargin{1}, 1]);
-      elseif (isreal (varargin{1}) && numel (varargin{1}) == 3)
-        set (hax, "dataaspectratio", varargin{1});
-      else
-        error ("daspect: invalid input");
-      endif
-    elseif (numel (varargin) > 1)
-      error ("daspect: too many inputs");
-    endif
-  elseif (nargout == 0)
+
+  nargin = numel (varargin);
+  if (nargin > 1)
     print_usage ();
   endif
 
-  if (nargout == 1)
-    varargout{1} = get (hax, "dataaspectratio");
-  elseif (nargout > 1)
-    error ("daspect: only one output is allowed");
+  if (nargin == 0)
+    daratio = get (hax, "dataaspectratio");
+  else
+    arg = varargin{1};
+    if (isreal (arg))
+      if (numel (arg) == 2)
+        set (hax, "dataaspectratio", [arg, 1]);
+      elseif (numel (arg) == 3)
+        set (hax, "dataaspectratio", arg);
+      else
+        error ("daspect: DATA_ASPECT_RATIO must be a 2 or 3 element vector");
+      endif
+    elseif (ischar (arg))
+      arg = tolower (arg);
+      switch (arg)
+        case "auto"
+          set (hax, "dataaspectratiomode", "auto");
+        case "manual"
+          set (hax, "dataaspectratiomode", "manual");
+        case "mode"
+          daratio = get (hax, "dataaspectratiomode");
+        otherwise
+          error ("daspect: Invalid mode <%s>", arg);
+      endswitch
+    else
+      print_usage ();
+    endif
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.01:4;
@@ -132,8 +134,10 @@ endfunction
 %! clf;
 %! x = 0:0.01:4;
 %! plot (x,cos(x), x,sin(x));
 %! axis ([0 4 -1 1]);
 %! set (gca, 'activepositionproperty', 'position');
 %! daspect ([2 1 1]);
 %! title ('square plot-box with axis limits [0, 4, -1, 1]');
 
+## FIXME: need some input validation tests
+
diff --git a/scripts/plot/diffuse.m b/scripts/plot/appearance/diffuse.m
rename from scripts/plot/diffuse.m
rename to scripts/plot/appearance/diffuse.m
--- a/scripts/plot/diffuse.m
+++ b/scripts/plot/appearance/diffuse.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} diffuse (@var{sx}, @var{sy}, @var{sz}, @var{lv})
 ## Calculate diffuse reflection strength of a surface defined by the normal
 ## vector elements @var{sx}, @var{sy}, @var{sz}.
-## The light vector can be specified using parameter @var{lv}.  It can be
-## given as 2-element vector [azimuth, elevation] in degrees or as 3-element
-## vector [lx, ly, lz].
+##
+## The light source location vector @var{lv} can be given as 2-element vector
+## [azimuth, elevation] in degrees or as 3-element vector [lx, ly, lz].
 ## @seealso{specular, surfl}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = diffuse (sx, sy, sz, lv)
 
   if (nargin != 4)
@@ -51,8 +51,9 @@ function retval = diffuse (sx, sy, sz, l
     lv  /= norm (lv);
   endif
 
   ns = sqrt (sx.^2 + sy.^2 + sz.^2);
   retval = (sx * lv(1) + sy * lv(2) + sz * lv(3)) ./ ns;
   retval(retval < 0) = 0;
 
 endfunction
+
diff --git a/scripts/plot/grid.m b/scripts/plot/appearance/grid.m
rename from scripts/plot/grid.m
rename to scripts/plot/appearance/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/appearance/grid.m
@@ -12,93 +12,115 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} grid (@var{arg})
-## @deftypefnx {Function File} {} grid ("minor", @var{arg2})
+## @deftypefn  {Command} {} grid
+## @deftypefnx {Command} {} grid on
+## @deftypefnx {Command} {} grid off
+## @deftypefnx {Command} {} grid minor
+## @deftypefnx {Command} {} grid minor on
+## @deftypefnx {Command} {} grid minor off
 ## @deftypefnx {Function File} {} grid (@var{hax}, @dots{})
-## Force the display of a grid on the plot.
-## The argument may be either @code{"on"}, or @code{"off"}.
+## Control the display of plot grid lines.
+##
+## The function state input may be either @qcode{"on"} or @qcode{"off"}.
 ## If it is omitted, the current grid state is toggled.
 ##
-## If @var{arg} is @code{"minor"} then the minor grid is toggled.  When
-## using a minor grid a second argument @var{arg2} is allowed, which can
-## be either @code{"on"} or @code{"off"} to explicitly set the state of
-## the minor grid.
+## When the first argument is @qcode{"minor"} all subsequent commands
+## modify the minor grid rather than the major grid.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
 ##
-## If the first argument is an axis handle, @var{hax}, operate on the
-## specified axis object.
-## @seealso{plot}
+## To control the grid lines for an individual axis use the @code{set}
+## function.  For example:
+##
+## @example
+## set (gca, "ygrid", "on");
+## @end example
+## @seealso{axis, box}
 ## @end deftypefn
 
 ## Author: jwe
 
 function grid (varargin)
 
-  [ax, varargin, nargs] = __plt_get_axis_arg__ ("grid", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("grid", varargin{:});
 
-  grid_on = (strcmp (get (ax, "xgrid"), "on")
-             && strcmp (get (ax, "ygrid"), "on")
-             && strcmp (get (ax, "zgrid"), "on"));
-
-  minor_on = (strcmp (get (ax, "xminorgrid"), "on")
-              && strcmp (get (ax, "yminorgrid"), "on")
-              && strcmp (get (ax, "zminorgrid"), "on"));
-
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (nargs > 2)
     print_usage ();
-  elseif (nargs == 0)
+  endif
+
+  grid_on = (   strcmp (get (hax, "xgrid"), "on")
+             && strcmp (get (hax, "ygrid"), "on")
+             && strcmp (get (hax, "zgrid"), "on"));
+
+  minor_on = (   strcmp (get (hax, "xminorgrid"), "on")
+              && strcmp (get (hax, "yminorgrid"), "on")
+              && strcmp (get (hax, "zminorgrid"), "on"));
+
+  minor_auto = true;
+  if (nargs == 0)
     grid_on = ! grid_on;
   else
-    x = varargin{1};
-    if (ischar (x))
-      if (strcmpi (x, "off"))
-        grid_on = false;
-      elseif (strcmpi (x, "on"))
-        grid_on = true;
-      elseif (strcmpi (x, "minor"))
-        if (nargs == 2)
-          x2 = varargin{2};
-          if (strcmpi (x2, "on"))
-            minor_on = true;
-            grid_on = true;
-          elseif (strcmpi (x2, "off"))
-            minor_on = false;
-          else
-            print_usage ();
-          endif
+    arg1 = varargin{1};
+    if (! ischar (arg1))
+      error ("grid: argument 1 must be an axis handle or a string");
+    endif
+    if (strcmpi (arg1, "off"))
+      grid_on = false;
+    elseif (strcmpi (arg1, "on"))
+      grid_on = true;
+    elseif (strcmpi (arg1, "minor"))
+      minor_auto = false;
+      if (nargs == 2)
+        arg2 = varargin{2};
+        if (strcmpi (arg2, "on"))
+          minor_on = true;
+          grid_on = true;
+        elseif (strcmpi (arg2, "off"))
+          minor_on = false;
         else
-           minor_on = ! minor_on;
-           if (minor_on)
-             grid_on = true;
-           endif
+          print_usage ();
         endif
       else
-        print_usage ();
+        minor_on = ! minor_on;
+        if (minor_on)
+          grid_on = true;
+        endif
       endif
     else
-      error ("grid: argument must be a string");
+      print_usage ();
     endif
   endif
 
   if (grid_on)
-    set (ax, "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    set (hax, "xgrid", "on", "ygrid", "on", "zgrid", "on");
     if (minor_on)
-      set (ax, "xminorgrid", "on", "yminorgrid", "on", "zminorgrid", "on");
+      set (hax, "xminorgrid", "on", "yminorgrid", "on", "zminorgrid", "on");
+    elseif (minor_auto)
+      xmg = ifelse (strcmp (get (hax, "xscale"), "log"), "on", "off");
+      ymg = ifelse (strcmp (get (hax, "yscale"), "log"), "on", "off");
+      zmg = ifelse (strcmp (get (hax, "zscale"), "log"), "on", "off");
+      set (hax, "xminorgrid", xmg, "yminorgrid", ymg, "zminorgrid", zmg);
     else
-      set (ax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
+      set (hax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
     endif
   else
-    set (ax, "xgrid", "off", "ygrid", "off", "zgrid", "off");
-    set (ax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
+    set (hax, "xgrid", "off", "ygrid", "off", "zgrid", "off",
+              "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! subplot (2,2,1);
diff --git a/scripts/plot/gtext.m b/scripts/plot/appearance/gtext.m
rename from scripts/plot/gtext.m
rename to scripts/plot/appearance/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/appearance/gtext.m
@@ -15,28 +15,30 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} gtext (@var{s})
 ## @deftypefnx {Function File} {} gtext (@{@var{s1}, @var{s2}, @dots{}@})
 ## @deftypefnx {Function File} {} gtext (@{@var{s1}; @var{s2}; @dots{}@})
-## @deftypefnx {Function File} {} gtext (@dots{}, @var{prop}, @var{val})
+## @deftypefnx {Function File} {} gtext (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} gtext (@dots{})
-## Place text on the current figure using the mouse.  The text is defined
-## by the string @var{s}.  If @var{s} is a cell string organized as a row
-## vector then each string of the cell array is written to a separate line.
-## If @var{s} is organized as a column vector then one string element of the
-## cell array is placed for every mouse click.  Additional inputs besides a
-## string or cellstr are passed to the underlying text object as Property-value
-## pairs.
+## Place text on the current figure using the mouse.
+##
+## The text is defined by the string @var{s}.  If @var{s} is a cell string
+## organized as a row vector then each string of the cell array is written to a
+## separate line.  If @var{s} is organized as a column vector then one string
+## element of the cell array is placed for every mouse click.
+##
+## Optional property/value pairs are passed directly to the underlying text
+## objects.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
-## text object.
+## text object(s).
 ## @seealso{ginput, text}
 ## @end deftypefn
 
 function h = gtext (s, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
diff --git a/scripts/plot/hidden.m b/scripts/plot/appearance/hidden.m
rename from scripts/plot/hidden.m
rename to scripts/plot/appearance/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/appearance/hidden.m
@@ -12,66 +12,76 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} hidden (@var{mode})
-## @deftypefnx {Function File} {} hidden ()
-## Manipulation the mesh hidden line removal.  Called with no argument
-## the hidden line removal is toggled.  The argument @var{mode} can be either
-## "on" or "off" and the set of the hidden line removal is set accordingly.
-## @seealso{mesh, meshc, surf}
+## @deftypefn  {Command} {} hidden
+## @deftypefnx {Command} {} hidden "on"
+## @deftypefnx {Command} {} hidden "off"
+## @deftypefnx {Function File} {@var{mode} =} hidden (@dots{})
+## Control mesh hidden line removal.
+##
+## When called with no argument the hidden line removal state is toggled.
+## When called with one of the modes @qcode{"on"} or @qcode{"off"} the state
+## is set accordingly.
+##
+## The optional output argument @var{mode} is the current state.
+##
+## Hidden Line Removal determines what graphic objects behind a mesh plot
+## are visible.  The default is for the mesh to be opaque and lines behind
+## the mesh are not visible.  If hidden line removal is turned off then
+## objects behind the mesh can be seen through the faces (openings) of the
+## mesh, although the mesh grid lines are still opaque.
+##
+## @seealso{mesh, meshc, meshz, ezmesh, ezmeshc, trimesh, waterfall}
 ## @end deftypefn
 
-function retval = hidden (mode)
+function state = hidden (mode = "toggle")
 
-  if (nargin == 0)
-    mode = "swap";
-  elseif (nargin == 1);
-    if (ischar (mode))
-      mode = tolower (mode);
-      if (! strcmp (mode, "on") && ! strcmp (mode, "off"))
-        error ("hidden: MODE expected to be 'on' or 'off'");
-      endif
-    else
+  if (nargin > 2)
+    print_usage ();
+  elseif (nargin == 1)
+    if (! ischar (mode))
       error ("hidden: expecting MODE to be a string");
+    elseif (! any (strcmpi (mode, {"on", "off"})))
+      error ('hidden: MODE must be "on" or "off"');
     endif
-  else
-    print_usage ();
   endif
 
-  for h = get (gca (), "children");
-    htype = lower (get (h, "type"));
-    if (strcmp (htype, "surface"))
+  for h = (get (gca (), "children")).';
+    htype = get (h, "type");
+    htag = get (h, "tag");
+    if (strcmp (htype, "surface") || strcmp (htag, "trimesh"))
       fc = get (h, "facecolor");
       if ((! ischar (fc) && is_white (fc))
-          || (ischar (fc) && strcmpi (fc, "none")))
+          || (ischar (fc) && strcmp (fc, "none")))
         switch (mode)
-        case "on"
-          set (h, "facecolor", "w");
-        case "off"
-          set (h, "facecolor", "none");
-        case "swap"
-          if (ischar (fc))
+          case "on"
             set (h, "facecolor", "w");
-            mode = "on";
-          else
+          case "off"
             set (h, "facecolor", "none");
-            mode = "off";
-          endif
+          case "toggle"
+            if (ischar (fc))
+              set (h, "facecolor", "w");
+              mode = "on";
+            else
+              set (h, "facecolor", "none");
+              mode = "off";
+            endif
         endswitch
       endif
     endif
   endfor
 
   if (nargout > 0)
-    retval = mode;
+    state = mode;
   endif
 
 endfunction
 
 function retval = is_white (color)
   retval = all (color == 1);
 endfunction
+
diff --git a/scripts/plot/legend.m b/scripts/plot/appearance/legend.m
rename from scripts/plot/legend.m
rename to scripts/plot/appearance/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -23,91 +23,73 @@
 ## @deftypefnx {Function File} {} legend (@dots{}, "location", @var{pos})
 ## @deftypefnx {Function File} {} legend (@dots{}, "orientation", @var{orient})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend ("@var{option}")
 ## @deftypefnx {Function File} {[@var{hleg}, @var{hleg_obj}, @var{hplot}, @var{labels}] =} legend (@dots{})
 ##
-## Display a legend for the axes with handle @var{hax}, or the current axes,
-## using the specified strings as labels.  Legend entries may be specified
-## as individual character string arguments, a character array, or a cell
-## array of character strings.  If the handles, @var{hobjs}, are not specified
-## then the legend's strings will be associated with the axes' descendants.
-## @code{legend} works on line graphs, bar graphs, etc.
-## A plot must exist before legend is called.
+## Display a legend for the current axes using the specified strings as labels.
+##
+## Legend entries may be specified as individual character string arguments,
+## a character array, or a cell array of character strings.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.  If the handles,
+## @var{hobjs}, are not specified then the legend's strings will be associated
+## with the axes' descendants.  @code{legend} works on line graphs,
+## bar graphs, etc.  A plot must exist before legend is called.
 ##
 ## The optional parameter @var{pos} specifies the location of the legend
 ## as follows:
 ##
 ## @multitable @columnfractions 0.06 0.14 0.80
-##
-## @headitem @tab @var{pos} @tab
-##   location of the legend
-##
-## @item @tab north @tab
-##   center top
-##
-## @item @tab south @tab
-##   center bottom
-##
-## @item @tab east @tab
-##   right center
-##
-## @item @tab west @tab
-##   left center
-##
-## @item @tab northeast @tab
-##   right top (default)
-##
-## @item @tab northwest @tab
-##   left top
-##
-## @item @tab southeast @tab
-##   right bottom
-##
-## @item @tab southwest @tab
-##   left bottom
-##
+## @headitem @tab pos @tab location of the legend
+## @item @tab north @tab center top
+## @item @tab south @tab center bottom
+## @item @tab east @tab right center
+## @item @tab west @tab left center
+## @item @tab northeast @tab right top (default)
+## @item @tab northwest @tab left top
+## @item @tab southeast @tab right bottom
+## @item @tab southwest @tab left bottom
 ## @item
-##
-## @item @tab outside @tab
-##   can be appended to any location string
+## @item @tab outside @tab can be appended to any location string
 ## @end multitable
 ##
 ## The optional parameter @var{orient} determines if the key elements
 ## are placed vertically or horizontally.  The allowed values are
-## "vertical" (default) or "horizontal".
+## @qcode{"vertical"} (default) or @qcode{"horizontal"}.
 ##
 ## The following customizations are available using @var{option}:
 ##
 ## @table @asis
-## @item "show"
+## @item @qcode{"show"}
 ##   Show legend on the plot
 ##
-## @item "hide"
+## @item @qcode{"hide"}
 ##   Hide legend on the plot
 ##
-## @item "toggle"
-##   Toggles between "hide" and "show"
+## @item @qcode{"toggle"}
+##   Toggles between @qcode{"hide"} and @qcode{"show"}
 ##
-## @item "boxon"
-##   Show a box around legend
+## @item @qcode{"boxon"}
+##   Show a box around legend (default)
 ##
-## @item "boxoff"
+## @item @qcode{"boxoff"}
 ##   Hide the box around legend
 ##
-## @item "left"
+## @item @qcode{"right"}
+##   Place label text to the right of the keys (default)
+##
+## @item @qcode{"left"}
 ##   Place label text to the left of the keys
 ##
-## @item "right"
-##   Place label text to the right of the keys
-##
-## @item  "off"
+## @item @qcode{"off"}
 ##   Delete the legend object
 ## @end table
 ##
 ## The optional output values are
 ##
 ## @table @var
 ## @item hleg
 ##   The graphics handle of the legend object.
@@ -115,31 +97,39 @@
 ## @item hleg_obj
 ##   Graphics handles to the text and line objects which make up the legend.
 ##
 ## @item hplot
 ##   Graphics handles to the plot objects which were used in making the legend.
 ##
 ## @item labels
 ##   A cell array of strings of the labels in the legend.
-## @end table 
+## @end table
 ##
 ## The legend label text is either provided in the call to @code{legend} or
 ## is taken from the DisplayName property of graphics objects.  If no
 ## labels or DisplayNames are available, then the label text is simply
-## "data1", "data2", @dots{}, @nospell{"dataN"}.
+## @qcode{"data1"}, @qcode{"data2"}, @dots{}, @nospell{@qcode{"dataN"}}.
+##
+## Implementation Note: A legend is implemented as an additional axes object
+## of the current figure with the @qcode{"tag"} set to @qcode{"legend"}.
+## Properties of the legend object may be manipulated directly by using
+## @code{set}.
 ## @end deftypefn
 
-function [hlegend2, hobjects2, hplot2, text_strings2] = legend (varargin)
+function [hleg, hleg_obj, hplot, labels] = legend (varargin)
 
   if (nargin > 0
       && (! ishandle (varargin{1})
           || (strcmp (get (varargin{1}, "type"), "axes")
               && ! strcmp (get (varargin{1}, "tag"), "legend"))))
-    [ca, varargin, nargs] = __plt_get_axis_arg__ ("legend", varargin{:});
+    [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
+    if (isempty (ca))
+      ca = gca ();
+    endif
     fig = get (ca, "parent");
   else
     fig = get (0, "currentfigure");
     if (isempty (fig))
       fig = gcf ();
     endif
     ca = gca ();
   endif
@@ -238,20 +228,20 @@ function [hlegend2, hobjects2, hplot2, t
     otherwise
       error ("legend: unrecognized legend location");
   endswitch
 
   ## Find any existing legend object on figure
   hlegend = [];
   fkids = get (fig, "children");
   for i = 1 : numel (fkids)
-    if (ishandle (fkids(i)) && strcmp (get (fkids(i), "type"), "axes")
-        && (strcmp (get (fkids(i), "tag"), "legend")))
+    if (   strcmp (get (fkids(i), "type"), "axes")
+        && strcmp (get (fkids(i), "tag"), "legend"))
       udata = get (fkids(i), "userdata");
-      if (! isempty (intersect (udata.handle, ca)))
+      if (any (udata.handle == ca))
         hlegend = fkids(i);
         break;
       endif
     endif
   endfor
 
   if (nargs == 1)
     arg = varargin{1};
@@ -265,23 +255,23 @@ function [hlegend2, hobjects2, hplot2, t
           case "hide"
             show = "off";
             nargs--;
           case "show"
             if (! isempty (hlegend))
               show = "on";
             else
               show = "create";
-              textpos = "left";
+              textpos = "right";
             endif
             nargs--;
           case "toggle"
             if (isempty (hlegend))
               show = "create";
-              textpos = "left";
+              textpos = "right";
             elseif (strcmp (get (hlegend, "visible"), "off"))
               show = "on";
             else
               show = "off";
             endif
             nargs--;
           case "boxon"
             box = "on";
@@ -337,84 +327,80 @@ function [hlegend2, hobjects2, hplot2, t
   elseif (strcmp (box, "on"))
     if (! isempty (hlegend))
       set (hlegend, "box", "on", "visible", "on");
     endif
   elseif (strcmp (box, "off"))
     if (! isempty (hlegend))
       set (hlegend, "box", "off", "visible", "off");
     endif
-  elseif (! have_labels && !(strcmp (location, "default") &&
-                             strcmp (orientation, "default")))
+  elseif (! have_labels && ! (strcmp (location, "default") &&
+                              strcmp (orientation, "default")))
     ## Changing location or orientation of existing legend
     if (! isempty (hlegend))
-      hax = getfield (get (hlegend, "userdata"), "handle");
-      [hplots, text_strings] = __getlegenddata__ (hlegend);
-
       if (strcmp (location, "default"))
-        h = legend (hax, hplots, text_strings, "orientation", orientation);
+        set (hlegend, "orientation", orientation);
       elseif (strcmp (orientation, "default"))
         if (outside)
-          h = legend (hax, hplots, text_strings, "location",
-                      strcat (location, "outside"));
+          set (hlegend, "location", [location "outside"]);
         else
-          h = legend (hax, hplots, text_strings, "location", location);
+          set (hlegend, "location", location);
         endif
       else
         if (outside)
-          h = legend (hax, hplots, text_strings, "location",
-                      strcat (location, "outside"), "orientation", orientation);
+          set (hlegend, "location", [location "outside"],
+                        "orientation", orientation);
         else
-          h = legend (hax, hplots, text_strings, "location", location,
-                      "orientation", orientation);
+          set (hlegend, "location", location,
+                        "orientation", orientation);
         endif
       endif
     endif
   else
     ## Create new legend
     hobjects = [];
     hplots  = [];
     text_strings = {};
 
     if (have_labels)
       ## Check for valid data that can be labeled.
       have_data = false;
       have_dname = false;
       for k = 1 : nkids
         typ = get (kids(k), "type");
-        if (strcmp (typ, "line") || strcmp (typ, "surface")
-            || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
+        if (any (strcmp (typ, {"line", "patch", "surface", "hggroup"})))
           have_data = true;
           break;
         endif
       endfor
 
       if (! have_data)
         warning ("legend: plot data is empty; setting key labels has no effect");
       endif
     else
       ## No labels.  Search for DisplayName property.
       have_dname = false;
       for k = 1 : nkids
         hkid = kids(k);
         typ = get (hkid, "type");
-        if (strcmp (typ, "line") || strcmp (typ, "surface")
-            || strcmp (typ, "patch"))
+        if (any (strcmp (typ, {"line", "patch", "surface"})))
           if (! isempty (get (hkid, "displayname")))
             have_dname = true;
             break;
           endif
         elseif (strcmp (typ, "hggroup"))
           hgkids = get (hkid, "children");
           for j = 1 : length (hgkids)
-            hgobj = get (hgkids(j));
-            if (isfield (hgobj, "displayname") && ! isempty (hgobj.displayname))
-              have_dname = true;
-              break;  # break from j-loop over hgkids
-            endif
+            try
+              dname = get (hgkids(j), "DisplayName");
+              if (! isempty (dname))
+                have_dname = true;
+                break;  # break from j-loop over hgkids
+              endif
+            end_try_catch
           endfor
           if (have_dname)
             break;  # break from k loop over nkids
           endif
         endif  # elseif hggroup
       endfor   # for loop k = 1 : nkids
     endif      # else branch of if (have_labels)
 
@@ -426,40 +412,39 @@ function [hlegend2, hobjects2, hplot2, t
         have_labels = true;
         nargs = nkids;
       endif
       for i = 1 : nargs
         arg = varargin{i};
         if (ischar (arg))
           typ = get (kids(k), "type");
           while (k > 0
-                 && ! (strcmp (typ, "line") || strcmp (typ, "surface")
-                       || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+                 && ! any (strcmp (typ, {"line","patch","surface","hggroup"})))
             typ = get (kids(--k), "type");
           endwhile
           if (k > 0)
             if (strcmp (get (kids(k), "type"), "hggroup"))
               hgkids = get (kids(k), "children");
               for j = 1 : length (hgkids)
                 hgobj = get (hgkids(j));
                 if (isfield (hgobj, "displayname"))
                   if (have_labels)
                     set (hgkids(j), "displayname", arg);
                   endif
-                  hplots = [hplots, hgkids(j)];
-                  text_strings = {text_strings{:}, arg};
+                  hplots(end+1) = hgkids(j);
+                  text_strings(end+1) = arg;
                   break;
                 endif
               endfor
             else
               if (have_labels)
                 set (kids(k), "displayname", arg);
               endif
-              hplots = [hplots, kids(k)];
-              text_strings = {text_strings{:}, arg};
+              hplots(end+1) = kids(k);
+              text_strings(end+1) = arg;
             endif
 
             if (--k == 0)
               break;
             endif
           else
             break;  # k = 0, no further handles to process
           endif
@@ -471,40 +456,38 @@ function [hlegend2, hobjects2, hplot2, t
         warning ("legend: ignoring extra labels");
       endif
     else
       ## No labels specified but objects have DisplayName property set.
       k = nkids;
       while (k > 0)
         typ = get (kids(k), "type");
         while (k > 1
-               && ! (strcmp (typ, "line") || strcmp (typ, "surface")
-                     || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+               && ! any (strcmp (typ, {"line","patch","surface","hggroup"})))
           typ = get (kids(--k), "type");
         endwhile
-        if (! (strcmp (typ, "line") || strcmp (typ, "surface")
-               || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+        if (! any (strcmp (typ, {"line","patch","surface","hggroup"})))
           break;
         endif
         if (k > 0)
           if (strcmp (get (kids(k), "type"), "hggroup"))
             hgkids = get (kids(k), "children");
             for j = 1 : length (hgkids)
               hgobj = get (hgkids(j));
               if (isfield (hgobj, "displayname")
                   && ! isempty (hgobj.displayname))
-                hplots = [hplots, hgkids(j)];
-                text_strings = {text_strings{:}, hgobj.displayname};
+                hplots(end+1) = hgkids(j);
+                text_strings(end+1) = hgobj.displayname;
                 break;
               endif
             endfor
           else
             if (! isempty (get (kids(k), "displayname")))
-              hplots = [hplots, kids(k)];
-              text_strings = {text_strings{:}, get(kids(k), "displayname")};
+              hplots(end+1) = kids(k);
+              text_strings(end+1) = get (kids(k), "displayname");
             endif
           endif
           if (--k == 0)
             break;
           endif
         endif
       endwhile
     endif
@@ -535,97 +518,125 @@ function [hlegend2, hobjects2, hplot2, t
           endif
         endif
         if (strcmp (orientation, "default"))
           orientation = get (hlegend, "orientation");
         endif
         box = get (hlegend, "box");
       else
         if (strcmp (textpos, "default"))
-          textpos = "left";
+          textpos = "right";
         endif
         if (strcmp (location, "default"))
           location = "northeast";
         endif
         if (strcmp (orientation, "default"))
           orientation = "vertical";
         endif
         box = "on";
       endif
 
       ## Get axis size and fontsize in points.
       ## Rely on listener to handle coversion.
       units = get (ca(1), "units");
-      fontunits = get (ca(1), "fontunits");
       unwind_protect
         set (ca(1), "units", "points");
         set (ca(1), "fontunits", "points");
         if (isempty (hlegend) || ! isprop (hlegend, "unmodified_axes_position"))
           unmodified_axes_position = get (ca(1), "position");
           unmodified_axes_outerposition = get (ca(1), "outerposition");
         else
           unmodified_axes_position = get (hlegend, "unmodified_axes_position");
           unmodified_axes_outerposition = get (hlegend, ...
                                                "unmodified_axes_outerposition");
         endif
         ca_pos = unmodified_axes_position;
         ca_outpos = unmodified_axes_outerposition;
-        ca_fontsize = get (ca(1), "fontsize");
+        tightinset = get (ca(1), "tightinset");
+        for i = 2 : numel (ca)
+          tightinset = max (tightinset, get (ca(i), "tightinset"));
+        endfor
       unwind_protect_cleanup
         set (ca(1), "units", units);
-        set (ca(1), "fontunits", fontunits);
       end_unwind_protect
 
       ## Padding between legend entries horizontally and vertically
       xpad = 2;
       ypad = 2;
 
       linelength = 15;
 
       ## Create the axis first
-      ## FIXME hlegend should inherit properties from "ca"
       curaxes = get (fig, "currentaxes");
       unwind_protect
         ud = ancestor (hplots, "axes");
-        if (!isscalar (ud))
+        if (! isscalar (ud))
           ud = unique ([ud{:}]);
         endif
         if (isempty (hlegend))
           addprops = true;
           hlegend = axes ("tag", "legend", "userdata", struct ("handle", ud),
                           "box", box,
                           "xtick", [], "ytick", [],
-                          "xticklabel", "", "yticklabel", "", "zticklabel", "",
                           "xlim", [0, 1], "ylim", [0, 1],
                           "visible", ifelse (strcmp (box, "on"), "on", "off"),
                           "activepositionproperty", "position",
-                          "fontsize", ca_fontsize);
+                          "interpreter", "tex");
+          ## Inherit properties from current axis
+          ## "fontunits" shoud be first because it affects interpretation
+          ## of "fontsize" property
+          proplist = {"fontunits", "fontangle", "fontname", "fontsize", ...
+                      "fontweight"};
+          ca_props = get (ca(1), proplist); 
+          set (hlegend, proplist, ca_props);
         else
           addprops = false;
           axes (hlegend);
           delete (get (hlegend, "children"));
         endif
+        if (addprops)
+          addproperty ("edgecolor", hlegend, "color", [0, 0, 0]);
+          addproperty ("textcolor", hlegend, "color", [0, 0, 0]);
+          locations = {"north", "south", "east", "west", ...
+                       "{northeast}", "southeast", "northwest", "southwest", ...
+                       "northoutside", "southoutside", ...
+                       "eastoutside", "westoutside", ...
+                       "northeastoutside", "southeastoutside", ...
+                       "northwestoutside", "southwestoutside"};
+          addproperty ("location", hlegend, "radio", strjoin (locations, "|"));
+          addproperty ("orientation", hlegend, "radio",
+                       "{vertical}|horizontal");
+          addproperty ("string", hlegend, "any", text_strings);
+          addproperty ("textposition", hlegend, "radio", "left|{right}");
+        endif
+        ## Inherit visual properties from legend object
+        fontunits = get (hlegend, "fontunits");
+        fontangle = get (hlegend, "fontangle");
+        fontname = get (hlegend, "fontname");
         fontsize = get (hlegend, "fontsize");
+        fontweight = get (hlegend, "fontweight");
+        interpreter = get (hlegend, "interpreter");
+        textcolor = get (hlegend, "textcolor");
         ## Add text label to the axis first, checking their extents
         nentries = numel (hplots);
         texthandle = [];
         maxwidth = 0;
         maxheight = 0;
         for k = 1 : nentries
-          if (strcmp (textpos, "right"))
-            texthandle = [texthandle, text(0, 0, text_strings{k},
-                                           "horizontalalignment", "left",
-                                           "userdata", hplots(k),
-                                           "fontsize", fontsize)];
-          else
-            texthandle = [texthandle, text(0, 0, text_strings{k},
-                                           "horizontalalignment", "right",
-                                           "userdata", hplots(k),
-                                           "fontsize", fontsize)];
-          endif
+          halign = ifelse (strcmp (textpos, "right"), "left", "right");
+          texthandle(end+1) = text (0, 0, text_strings{k},
+                                    "color", textcolor,
+                                    "horizontalalignment", halign,
+                                    "interpreter", interpreter,
+                                    "fontunits", fontunits,
+                                    "fontangle", fontangle,
+                                    "fontname", fontname,
+                                    "fontsize", fontsize,
+                                    "fontweight", fontweight,
+                                    "userdata", hplots(k));
           units = get (texthandle(end), "units");
           unwind_protect
             set (texthandle(end), "units", "points");
             extents = get (texthandle(end), "extent");
             maxwidth = max (maxwidth, extents(3));
             maxheight = max (maxheight, extents(4));
           unwind_protect_cleanup
             set (texthandle(end), "units", units);
@@ -673,123 +684,133 @@ function [hlegend2, hobjects2, hplot2, t
 
         ## Place the legend in the desired location
         if (strcmp (orientation, "vertical"))
           lpos = [0, 0, num2 * xstep, num1 * ystep];
         else
           lpos = [0, 0, num1 * xstep, num2 * ystep];
         endif
 
-        if (strcmp (get (fig, "__graphics_toolkit__"), "gnuplot"))
+        gnuplot = strcmp (get (fig, "__graphics_toolkit__"), "gnuplot");
+        if (gnuplot)
           ## Gnuplot places the key (legend) at edge of the figure window.
           ## OpenGL places the legend box at edge of the unmodified axes
           ## position.
           if (isempty (strfind (location, "east")))
-            extra_offset = unmodified_axes_outerposition(1) ...
-                         + unmodified_axes_outerposition(3) ...
-                         - unmodified_axes_position(1) ...
-                         - unmodified_axes_position(3);
+            gnuplot_offset = unmodified_axes_outerposition(1) ...
+                           + unmodified_axes_outerposition(3) ...
+                           - unmodified_axes_position(1) ...
+                           - unmodified_axes_position(3);
           else
-            extra_offset = unmodified_axes_position(1) ...
-                         - unmodified_axes_outerposition(1);
+            gnuplot_offset = unmodified_axes_position(1) ...
+                           - unmodified_axes_outerposition(1);
           endif
-          ## FIXME - the "fontsize" is added to match the behavior of OpenGL.
+          ## FIXME: The "fontsize" is added to match the behavior of OpenGL.
           ## This implies that a change in fontsize should trigger a listener
           ## to update the legend.  The "2" was determined using a long legend
           ## key in the absence of any subplots.
-          extra_offset = extra_offset - 2 * fontsize;
+          gnuplot_offset = gnuplot_offset - 2 * fontsize;
         else
-          extra_offset = 0;
+          gnuplot_offset = 0;
         endif
 
+        ## For legend's outside the associated axes postion,
+        ## align their edge to the unmodified_axes_outerpostion,
+        ## and adjust the axes postion accordingly.
         switch (location)
           case "north"
             if (outside)
               lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
                       ca_outpos(2) + ca_outpos(4) - lpos(4) - ypad, lpos(3), ...
                       lpos(4)];
 
               new_pos = [ca_pos(1), ca_pos(2), ca_pos(3), ca_pos(4) - lpos(4)];
             else
               lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
                       ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
             endif
           case "south"
             if (outside)
               lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
                       ca_outpos(2) + ypad, lpos(3), lpos(4)];
-              new_pos = [ca_pos(1), ca_pos(2) + lpos(4), ca_pos(3), ...
+              new_pos = [ca_pos(1), lpos(2) + lpos(4) + 2 * ypad ...
+                      + tightinset(2), ca_pos(3), ...
                          ca_pos(4) - lpos(4)];
             else
               lpos = [ca_pos(1) + (ca_pos(3) - lpos(3)) / 2, ...
                       ca_pos(2) + ypad, lpos(3), lpos(4)];
             endif
           case "east"
             if (outside)
               lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
-              new_pos = [ca_pos(1), ca_pos(2), ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(3) = new_pos(3) + extra_offset;
+              new_pos = [ca_pos(1), ca_pos(2), ...
+                         lpos(1) - 2 * xpad - ca_pos(1) - tightinset(3), ...
+                         ca_pos(4)];
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
             endif
           case "west"
             if (outside)
               lpos = [ca_outpos(1) + ypad, ...
                       ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, ...
                       lpos(3), lpos(4)];
-              new_pos = [ca_pos(1) + lpos(3), ca_pos(2), ...
-                         ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(1) = new_pos(1) - extra_offset;
-              new_pos(3) = new_pos(3) + extra_offset;
+              new_pos = [lpos(1) + lpos(3) + 2 * xpad + tightinset(1), ...
+                         ca_pos(2), ca_pos(3) - lpos(3) - 2 * xpad, ca_pos(4)];
+              new_pos(1) = new_pos(1) - gnuplot_offset;
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) +  ypad, ...
                       ca_pos(2) + (ca_pos(4) - lpos(4)) / 2, lpos(3), lpos(4)];
             endif
           case "northeast"
             if (outside)
               lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + ca_pos(4) - lpos(4), lpos(3), lpos(4)];
-              new_pos = [ca_pos(1), ca_pos(2), ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(3) = new_pos(3) + extra_offset;
+              new_pos = [ca_pos(1), ca_pos(2), ...
+                         lpos(1) - 2 * xpad - tightinset(3) - ca_pos(1), ...
+                         ca_pos(4)];
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
             endif
           case "northwest"
             if (outside)
               lpos = [ca_outpos(1) + ypad , ca_pos(2) + ca_pos(4) - lpos(4), ...
                       lpos(3), lpos(4)];
-              new_pos = [ca_pos(1) + lpos(3), ca_pos(2), ...
-                         ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(1) = new_pos(1) - extra_offset;
-              new_pos(3) = new_pos(3) + extra_offset;
+              new_pos = [lpos(1) + lpos(3) + 2 * xpad + tightinset(1), ...
+              ca_pos(2), ca_pos(3) - lpos(3) - 2 * xpad, ca_pos(4)];
+              new_pos(1) = new_pos(1) - gnuplot_offset;
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) + ypad, ...
                       ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
             endif
           case "southeast"
             if (outside)
               lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3) - ypad, ...
                       ca_pos(2), lpos(3), lpos(4)];
               new_pos = [ca_pos(1), ca_pos(2), ...
-                         ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(3) = new_pos(3) + extra_offset;
+                         lpos(1) - 2 * xpad - ca_pos(1) - tightinset(3), ...
+                         ca_pos(4)];
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + ypad, lpos(3), lpos(4)];
             endif
           case "southwest"
             if (outside)
               lpos = [ca_outpos(1) + ypad, ca_pos(2), lpos(3), lpos(4)];
-              new_pos = [ca_pos(1) + lpos(3), ca_pos(2), ...
-                         ca_pos(3) - lpos(3), ca_pos(4)];
-              new_pos(1) = new_pos(1) - extra_offset;
-              new_pos(3) = new_pos(3) + extra_offset;
+              new_pos = [lpos(1) + lpos(3) + 2 * xpad + tightinset(1), ...
+              ca_pos(2), ca_pos(3) - lpos(3) - 2 * xpad, ca_pos(4)];
+              new_pos(1) = new_pos(1) - gnuplot_offset;
+              new_pos(3) = new_pos(3) + gnuplot_offset;
             else
               lpos = [ca_pos(1) + ypad, ca_pos(2) + ypad, lpos(3), lpos(4)];
             endif
         endswitch
 
         units = get (hlegend, "units");
         unwind_protect
           set (hlegend, "units", "points");
@@ -797,71 +818,95 @@ function [hlegend2, hobjects2, hplot2, t
         unwind_protect_cleanup
           set (hlegend, "units", units);
         end_unwind_protect
 
         ## Now write the line segments and place the text objects correctly
         xk = 0;
         yk = 0;
         for k = 1 : numel (hplots)
-          hobjects = [hobjects, texthandle(k)];
+          hobjects(end+1) = texthandle(k);
           switch (get (hplots(k), "type"))
-          case "line"
-            color = get (hplots(k), "color");
-            style = get (hplots(k), "linestyle");
-            if (! strcmp (style, "none"))
-              l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
-                         "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
-                         "color", color, "linestyle", style, "marker", "none",
-                         "userdata", hplots (k));
-              hobjects = [hobjects, l1];
-            endif
-            marker = get (hplots(k), "marker");
-            if (! strcmp (marker, "none"))
-              l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
-                         "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4),
-                         "color", color, "linestyle", "none", "marker", marker,
-                         "markeredgecolor", get (hplots (k), "markeredgecolor"),
-                         "markerfacecolor", get (hplots (k), "markerfacecolor"),
-                         "markersize", get (hplots (k), "markersize"),
-                         "userdata", hplots (k));
-              hobjects = [hobjects, l1];
-            endif
+
+            case "line"
+              color = get (hplots(k), "color");
+              style = get (hplots(k), "linestyle");
+              if (! strcmp (style, "none"))
+                l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
+                           "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
+                           "color", color, "linestyle", style,
+                           "marker", "none",
+                           "userdata", hplots(k));
+                hobjects(end+1) = l1;
+              endif
+              marker = get (hplots(k), "marker");
+              if (! strcmp (marker, "none"))
+                l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
+                           "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4),
+                           "color", color, "linestyle", "none",
+                           "marker", marker,
+                           "markeredgecolor",get (hplots(k), "markeredgecolor"),
+                           "markerfacecolor",get (hplots(k), "markerfacecolor"),
+                           "markersize", get (hplots(k), "markersize"),
+                           "userdata", hplots(k));
+                hobjects(end+1) = l1;
+              endif
 
-            addlistener (hplots(k), "color",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "linestyle",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "marker",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markeredgecolor",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markerfacecolor",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markersize",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "displayname",
-                         {@updateline, hlegend, linelength});
-          case "patch"
-            facecolor = get (hplots(k), "facecolor");
-            edgecolor = get (hplots(k), "edgecolor");
-            cdata = get (hplots(k), "cdata");
-            if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
-              p1 = patch ("xdata", ([0, linelength, linelength, 0] +
-                                   xoffset + xk * xstep) / lpos(3),
-                         "ydata", (lpos(4) - yoffset -
-                                   [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
-                         "facecolor", facecolor, "edgecolor", edgecolor,
-                         "cdata", cdata, "userdata", hplots(k));
-              hobjects = [hobjects, p1];
-            endif
-          case "surface"
+              if (addprops)
+                addlistener (hplots(k), "color",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "linestyle",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "marker",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "markeredgecolor",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "markerfacecolor",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "markersize",
+                             {@updateline, hlegend, linelength, false});
+                addlistener (hplots(k), "displayname",
+                             {@updateline, hlegend, linelength, true});
+              endif
+
+            case "patch"
+              facecolor = get (hplots(k), "facecolor");
+              edgecolor = get (hplots(k), "edgecolor");
+              cdata = get (hplots(k), "cdata");
+              if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
+                p1 = patch ("xdata", ([0, linelength, linelength, 0] +
+                                      xoffset + xk * xstep) / lpos(3),
+                            "ydata", (lpos(4) - yoffset -
+                                      [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
+                           "facecolor", facecolor, "edgecolor", edgecolor,
+                           "cdata", cdata, "userdata", hplots(k));
+                hobjects(end+1) = p1;
+              endif
+              ## FIXME: Probably need listeners, as for line objects
+
+            case "surface"
+              facecolor = get (hplots(k), "facecolor");
+              edgecolor = get (hplots(k), "edgecolor");
+              cdata = sum (get (ca(1), "clim")) / 2;
+              if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
+                p1 = patch ("xdata", ([0, linelength, linelength, 0] +
+                                      xoffset + xk * xstep) / lpos(3),
+                            "ydata", (lpos(4) - yoffset -
+                                      [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
+                           "facecolor", facecolor, "edgecolor", edgecolor,
+                           "cdata", cdata, "userdata", hplots(k));
+                hobjects(end+1) = p1;
+              endif
+              ## FIXME: Probably need listeners, as for line objects
+
           endswitch
-          set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
-                                            (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
+
+          set (texthandle(k), "position",
+                              [(txoffset + xk * xstep) / lpos(3), ...
+                               (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
             yk++;
             if (yk > num1)
               yk = 0;
               xk++;
             endif
           else
             xk++;
@@ -872,161 +917,184 @@ function [hlegend2, hobjects2, hplot2, t
           endif
         endfor
 
         ## Add an invisible text object to original axis
         ## that when it is destroyed will remove the legend
         props = {"parent", ca(1), "tag", "legend", ...
                  "handlevisibility", "off", "visible", "off", ...
                  "xliminclude", "off", "yliminclude", "off"};
-        t1 = findall (ca(1), props{3:4}, "type", "text");
+        t1 = findall (ca(1), "tag", "legend", "type", "text");
         if (isempty (t1))
           t1 = text (0, 0, "", props{:});
           set (t1, "deletefcn", {@deletelegend1, hlegend});
         endif
         if (isprop (hlegend, "unmodified_axes_position"))
-          set (hlegend, "unmodified_axes_position", unmodified_axes_position);
-          set (hlegend, "unmodified_axes_outerposition", 
-               unmodified_axes_outerposition);
+          set (hlegend, "unmodified_axes_position",
+                         unmodified_axes_position,
+                        "unmodified_axes_outerposition",
+                         unmodified_axes_outerposition);
         else
           addproperty ("unmodified_axes_position", hlegend,
                        "data", unmodified_axes_position);
           addproperty ("unmodified_axes_outerposition", hlegend,
                        "data", unmodified_axes_outerposition);
         endif
 
-        ## Resize the axis that the legend is attached to if the
-        ## legend is "outside" the plot and create a listener to
-        ## resize axis to original size if the legend is deleted,
-        ## hidden, or shown.
+        ## Resize the axis that the legend is attached to if the legend is
+        ## "outside" the plot and create a listener to resize axis to original
+        ## size if the legend is deleted, hidden, or shown.
         if (outside)
           for i = 1 : numel (ca)
             units = get (ca(i), "units");
             unwind_protect
               set (ca(i), "units", "points");
-              set (ca(i), "position", new_pos);
+              if (gnuplot && numel (ca) == 1)
+                ## Let Gnuplot handle the positioning of the keybox.
+                ## This violates strict Matlab compatibility, but reliably
+                ## renders an esthetic result.
+                set (ca(i), "position",  unmodified_axes_position);
+                set (ca(i), "activepositionproperty", "outerposition")
+              else
+                ## numel (ca) > 1 for axes overlays (like plotyy)
+                set (ca(i), "position", new_pos);
+              endif
             unwind_protect_cleanup
               set (ca(i), "units", units);
             end_unwind_protect
           endfor
 
           set (hlegend, "deletefcn", {@deletelegend2, ca, ...
                                       unmodified_axes_position, ...
-                                      unmodified_axes_outerposition, t1, hplots});
+                                      unmodified_axes_outerposition, ...
+                                      t1, hplots});
           addlistener (hlegend, "visible", {@hideshowlegend, ca, ...
-                                            unmodified_axes_position, new_pos});
+                                            unmodified_axes_position, ...
+                                            new_pos});
         else
           set (hlegend, "deletefcn", {@deletelegend2, ca, [], [], t1, hplots});
         endif
 
-        if (addprops)
-          addproperty ("edgecolor", hlegend, "color", [0, 0, 0]);
-          addproperty ("textcolor", hlegend, "color", [0, 0, 0]);
-          locations = {"north", "south", "east", "west", ...
-                       "northeast", "southeast", "northwest", "southwest", ...
-                       "northoutside", "southoutside", ...
-                       "eastoutside", "westoutside", ...
-                       "northeastoutside", "southeastoutside", ...
-                       "northwestoutside", "southwestoutside"};
-          addproperty ("location", hlegend, "radio", strjoin (locations, "|"));
-          addproperty ("orientation", hlegend, "radio",
-                       "{vertical}|horizontal");
-          addproperty ("string", hlegend, "any", text_strings);
-          addproperty ("textposition", hlegend, "radio", "{left}|right");
-        else
+        if (! addprops)
+          ## Remove listeners on existing legend temporarily to stop recursion.
+          dellistener (hlegend, "location");
+          dellistener (hlegend, "orientation");
+          dellistener (hlegend, "string");
+          dellistener (hlegend, "textposition");
+        endif
+
+        if (! addprops)
           set (hlegend, "string", text_strings);
         endif
 
         if (outside)
-          set (hlegend, "location", strcat (location, "outside"),
-               "orientation", orientation, "textposition", textpos);
+          set (hlegend, "location", [location "outside"],
+                        "orientation", orientation, "textposition", textpos);
         else
           set (hlegend, "location", location, "orientation", orientation,
-               "textposition", textpos);
+                        "textposition", textpos);
         endif
+
         if (addprops)
           addlistener (hlegend, "edgecolor", @updatelegendtext);
+          addlistener (hlegend, "fontangle", @updatelegendtext);
+          addlistener (hlegend, "fontname", @updatelegendtext);
+          addlistener (hlegend, "fontweight", @updatelegendtext);
           addlistener (hlegend, "textcolor", @updatelegendtext);
-          addlistener (hlegend, "fontsize", @updatelegendtext);
-          addlistener (hlegend, "interpreter", @updatelegendtext);
+          ## Properties which could change size of box, such as fontsize,
+          ## require legend to be redrawn.
+          addlistener (hlegend, "fontsize", @updatelegend);
+          addlistener (hlegend, "fontunits", @updatelegend);
+          addlistener (hlegend, "interpreter", @updatelegend);
+          addlistener (hlegend, "location", @updatelegend);
+          addlistener (hlegend, "orientation", @updatelegend);
+          addlistener (hlegend, "string", @updatelegend);
+          addlistener (hlegend, "textposition", @updatelegend);
+          ## FIXME: need to add listeners for tightinset and position
+          ##        addlistener (ca, "tightinset", @update????);
+          ##        addlistener (ca, "position", @update????);
+        else
+          ## Restore certain listeners
           addlistener (hlegend, "location", @updatelegend);
           addlistener (hlegend, "orientation", @updatelegend);
           addlistener (hlegend, "string", @updatelegend);
           addlistener (hlegend, "textposition", @updatelegend);
         endif
       unwind_protect_cleanup
         set (fig, "currentaxes", curaxes);
       end_unwind_protect
     endif
   endif
 
   if (nargout > 0)
-    hlegend2 = hlegend;
-    hobjects2 = hobjects;
-    hplot2 = hplots;
-    text_strings2 = text_strings;
+    hleg = hlegend;
+    hleg_obj = hobjects;
+    hplot = hplots;
+    labels = text_strings;
   endif
 
 endfunction
 
-function updatelegend (h, d)
+function updatelegend (h, ~)
   persistent recursive = false;
 
   if (! recursive)
     recursive = true;
     unwind_protect
       hax = getfield (get (h, "userdata"), "handle");
-      [hplots, text_strings] = __getlegenddata__ (h);
+      [hplots, ~] = __getlegenddata__ (h);
       position = get (h, "unmodified_axes_position");
       outerposition = get (h, "unmodified_axes_outerposition");
       units = get (hax, "units");
       set (hax, "units", "points");
-      switch get (hax, "activepositionproperty")
-      case "position"
-        set (hax, "outerposition", outerposition);
-        set (hax, "position", position);
-      case "outerposition"
-        set (hax, "position", position);
-        set (hax, "outerposition", outerposition);
+      switch (get (hax, "activepositionproperty"))
+        case "position"
+          set (hax, "outerposition", outerposition);
+          set (hax, "position", position);
+        case "outerposition"
+          set (hax, "position", position);
+          set (hax, "outerposition", outerposition);
       endswitch
       set (hax, "units", units);
       h = legend (hax, hplots, get (h, "string"));
     unwind_protect_cleanup
       recursive = false;
     end_unwind_protect
   endif
 
 endfunction
 
-function updatelegendtext (h, d)
-  hax = get (h, "userdata").handle;
+function updatelegendtext (h, ~)
   kids = get (h, "children");
-  text_kids = findobj (kids, "-property", "interpreter", "type", "text");
-  interpreter = get (h, "interpreter");
-  textcolor = get (h, "textcolor");
-  fontsize = get (h, "fontsize");
-  set (text_kids, "interpreter", interpreter,
-                  "fontsize", fontsize,
-                  "color", textcolor);
+  htext = [];
+  for i = 1:numel (kids)
+    if (strcmp (get (kids(i), "type"), "text"))
+      htext(end+1) = kids(i);
+    endif
+  endfor
+
+  tprops = {"fontangle", "fontname", "fontweight", "color"};
+  lprops = {"fontangle", "fontname", "fontweight", "textcolor"};
+  set (htext, tprops, get (h, lprops));
+
+  ec = get (h, "edgecolor");
+  set (h, "xcolor", ec, "ycolor", ec);
 endfunction
 
-function hideshowlegend (h, d, ca, pos1, pos2)
+function hideshowlegend (h, ~, ca, pos1, pos2)
   isvisible = strcmp (get (h, "visible"), "off");
   if (! isvisible)
     kids = get (h, "children");
-    for i = 1 : numel (kids)
-      if (! strcmp (get (kids(i), "visible"), "off"))
-        isvisible = true;
-        break;
-      endif
-    endfor
+    if (any (! strcmp (get (kids, "visible"), "off")))
+      isvisible = true;
+    endif
   endif
 
   for i = 1 : numel (ca)
-    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
+    if (isaxes (ca(i))
         && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       units = get (ca(i), "units");
       unwind_protect
         set (ca(i), "units", "points");
         if (isvisible)
           set (ca(i), "position", pos2);
         else
@@ -1034,143 +1102,108 @@ function hideshowlegend (h, d, ca, pos1,
         endif
       unwind_protect_cleanup
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
 endfunction
 
-function deletelegend1 (h, d, ca)
-  if (ishandle (ca) && strcmp (get (ca, "type"), "axes")
+function deletelegend1 (h, ~, ca)
+  if (isaxes (ca)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
       && strcmp (get (ca, "beingdeleted"), "off"))
     delete (ca);
   endif
 endfunction
 
-function deletelegend2 (h, d, ca, pos, outpos, t1, hplots)
+function deletelegend2 (h, ~, ca, pos, outpos, t1, hplots)
   for i = 1 : numel (ca)
-    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
+    if (isaxes (ca(i))
         && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
-      if (!isempty (pos) && !isempty(outpos))
+      if (! isempty (pos) && ! isempty (outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
         end_unwind_protect
       endif
     endif
   endfor
   set (t1, "deletefcn", "");
   delete (t1);
   for i = 1 : numel (hplots)
-    if (ishandle (hplots(i)) && strcmp (get (hplots (i), "type"), "line"))
+    if (ishandle (hplots(i)) && strcmp (get (hplots(i), "type"), "line"))
       dellistener (hplots(i), "color");
       dellistener (hplots(i), "linestyle");
       dellistener (hplots(i), "marker");
       dellistener (hplots(i), "markeredgecolor");
       dellistener (hplots(i), "markerfacecolor");
       dellistener (hplots(i), "markersize");
       dellistener (hplots(i), "displayname");
     endif
   endfor
 endfunction
 
-function updateline (h, d, hlegend, linelength)
-  lm = [];
-  ll = [];
-  kids = get (hlegend, "children");
-  for i = 1 : numel (kids)
-    if (get (kids(i), "userdata") == h
-        && strcmp (get (kids(i), "type"), "line"))
-      if (strcmp (get (kids (i), "marker"), "none"))
-        ll = kids(i);
-      else
-        lm = kids(i);
-      endif
-    endif
-  endfor
+function updateline (h, ~, hlegend, linelength, update_name)
 
-  linestyle = get (h, "linestyle");
-  marker = get (h, "marker");
-  displayname = get (h, "displayname");
-
-  if ((isempty (displayname)
-       || (strcmp (marker, "none") && strcmp (linestyle, "none")))
-       && (! isempty (lm) || isempty (ll)))
-    ## An element was removed from the legend. Need to recall the
-    ## legend function to recreate a new legend
+  if (update_name)
+    ## When string changes, have to rebuild legend completely
     [hplots, text_strings] = __getlegenddata__ (hlegend);
-    for i = 1 : numel (hplots)
-      if (hplots(i) == h)
-        hplots(i) = [];
-        text_strings(i) = [];
-        break;
+    legend (hplots, text_strings);
+  else
+    kids = get (hlegend, "children");
+    ll = lm = [];
+    for i = 1 : numel (kids)
+      if (get (kids(i), "userdata") == h
+          && strcmp (get (kids(i), "type"), "line"))
+        if (strcmp (get (kids(i), "marker"), "none"))
+          ll = kids(i);
+        else
+          lm = kids(i);
+        endif
       endif
     endfor
-    legend (hplots, text_strings);
-  elseif ((!isempty (displayname)
-           && (! strcmp (marker, "none") || ! strcmp (linestyle, "none")))
-          && isempty (lm) && isempty (ll))
-    ## An element was added to the legend.  Need to re-call the
-    ## legend function to recreate a new legend.
-    [hplots, text_strings] = __getlegenddata__ (hlegend);
-    hplots = [hplots, h];
-    text_strings = {text_strings{:}, displayname};
-    legend (hplots, text_strings);
-  else
+
+    [linestyle, marker, displayname] = ...
+      get (h, {"linestyle", "marker", "displayname"}){:};
+
     if (! isempty (ll))
-      ypos1 = get (ll,"ydata");
-      xpos1 = get (ll,"xdata");
+      [xpos1, ypos1] = get (ll, {"xdata", "ydata"}){:};
+      xpos2 = sum (xpos1) / 2;
       ypos2 = ypos1(1);
-      xpos2 = sum (xpos1) / 2;
       delete (ll);
       if (! isempty (lm))
         delete (lm);
       endif
     else
-      ypos2 = get (lm,"ydata");
-      xpos2 = get (lm,"xdata");
+      [xpos2, ypos2] = get (lm, {"xdata", "ydata"}){:};
+      xpos1 = xpos2 + [-0.5, 0.5] * linelength;
       ypos1 = [ypos2, ypos2];
-      xpos1 = xpos2 + [-0.5, 0.5] * linelength;
       delete (lm);
     endif
+
     if (! strcmp (linestyle, "none"))
       line ("xdata", xpos1, "ydata", ypos1, "color", get (h, "color"),
             "linestyle", get (h, "linestyle"), "marker", "none",
             "userdata", h, "parent", hlegend);
     endif
     if (! strcmp (marker, "none"))
       line ("xdata", xpos2, "ydata", ypos2, "color", get (h, "color"),
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", get (h, "markersize"), "linestyle", "none",
             "userdata", h, "parent", hlegend);
     endif
   endif
 endfunction
 
-%!test
-%! graphics_toolkit ("gnuplot");
-%! h = figure ("visible", "off", "__graphics_toolkit__", "gnuplot");
-%! unwind_protect
-%!   position = get (h, "position");
-%!   plot (rand (3))
-%!   legend ()
-%!   filename = sprintf ("%s.eps", tmpnam ());
-%!   print (filename)
-%!   unlink (filename);
-%!   assert (get (h, "position"), position)
-%! unwind_protect_cleanup
-%!   close (h)
-%! end_unwind_protect
 
 %!demo
 %! clf;
 %! plot (rand (2));
 %! title ('legend called with cellstr and string inputs for labels');
 %! h = legend ({'foo'}, 'bar');
 %! legend location northeastoutside
 %! set (h, 'fontsize', 20);
@@ -1212,28 +1245,28 @@ endfunction
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
 %! title ('Legend with box off');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend boxoff
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
-%! title ('Legend with text to the right of key');
+%! title ('Legend with text to the left of key');
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
-%! legend right
+%! legend left
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
-%! title ({'Use properties to place legend text to the right of key', ...
+%! title ({'Use properties to place legend text to the left of key', ...
 %!         'Legend text color is magenta'});
 %! h = legend ({'I am blue', 'I am green'}, 'location', 'east');
-%! legend ('left');
-%! set (h, 'textposition', 'right');
+%! legend ('right');
+%! set (h, 'textposition', 'left');
 %! set (h, 'textcolor', [1 0 1]);
 
 %!demo
 %! clf;
 %! plot (1:10, 1:10, 1:10, fliplr (1:10));
 %! title ('Legend is hidden')
 %! legend ({'I am blue', 'I am green'}, 'location', 'east');
 %! legend hide
@@ -1249,16 +1282,18 @@ endfunction
 %! legend show
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! plot (x, x, ';\alpha;',  ...
 %!       x, 2*x, ';\beta=2\alpha;',  ...
 %!       x, 3*x, ';\gamma=3\alpha;');
+%! h = legend ();
+%! set (h, 'interpreter', 'tex');
 %! title ('Labels with interpreted Greek text');
 
 %!demo
 %! clf;
 %! plot (rand (2));
 %! title ('Labels with TeX interpreter turned off');
 %! h = legend ('Hello_World', 'foo^bar');
 %! set (h, 'interpreter', 'none');
@@ -1308,25 +1343,25 @@ endfunction
 %! title ('Labels are applied in order of object creation');
 %! legend ('linear', 'quadratic');
 
 %!demo
 %! clf;
 %! rand_2x3_data1 = [0.341447, 0.171220, 0.284370; 0.039773, 0.731725, 0.779382];
 %! bar (rand_2x3_data1);
 %! ylim ([0 1.0]);
-%! title ('legend() works for bar graphs (hgobjects)');
+%! title ('legend() works for bar graphs (hggroups)');
 %! legend ({'1st Bar', '2nd Bar', '3rd Bar'});
 
 %!demo
 %! clf;
 %! rand_2x3_data2 = [0.44804, 0.84368, 0.23012; 0.72311, 0.58335, 0.90531];
 %! bar (rand_2x3_data2);
 %! ylim ([0 1.2]);
-%! title ('legend() works for bar graphs (hgobjects)');
+%! title ('legend() works for bar graphs (hggroups)');
 %! legend ('1st Bar', '2nd Bar', '3rd Bar');
 %! legend right;
 
 %!demo
 %! clf;
 %! x = 0:0.1:7;
 %! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
 %! title ('Only the sin() objects have keylabels');
@@ -1410,38 +1445,151 @@ endfunction
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
 %! title ('plotyy legend test #3: Blue and Green labels');
 %! legend ('Blue', 'Green', 'location', 'south');
 
 %!demo % bug 36408
 %! clf;
 %! option = 'right';
 %! subplot (3,1,1);
-%! plot (rand (1,4));
-%! title ('Subplots should adjust to the legend placed outside');
-%! legend ({'1'}, 'location', 'northeastoutside');
-%! legend (option);
+%!  plot (rand (1,4));
+%!  xlabel xlabel;
+%!  ylabel ylabel;
+%!  title ('Subplots should adjust to the legend placed outside');
+%!  legend ({'1'}, 'location', 'northeastoutside');
+%!  legend (option);
+%! subplot (3,1,2);
+%!  plot (rand (1,4));
+%!  xlabel xlabel;
+%!  ylabel ylabel;
+%!  legend ({'1234567890'}, 'location', 'eastoutside');
+%!  legend (option);
+%! subplot (3,1,3);
+%!  plot (rand (1,4));
+%!  xlabel xlabel;
+%!  ylabel ylabel;
+%!  legend ({'12345678901234567890'}, 'location', 'southeastoutside');
+%!  legend (option);
+
+%!demo % bug 36408
+%! clf;
+%! option = 'right';
+%! subplot (3,1,1);
+%!  plot (rand (1,4));
+%!  title ('Subplots should adjust to the legend placed outside');
+%!  legend ({'1'}, 'location', 'northwestoutside');
+%!  legend (option);
 %! subplot (3,1,2);
-%! plot (rand (1,4));
-%! legend ({'1234567890'}, 'location', 'eastoutside');
-%! legend (option);
+%!  plot (rand (1,4));
+%!  legend ({'1234567890'}, 'location', 'westoutside');
+%!  legend (option);
 %! subplot (3,1,3);
-%! plot (rand (1,4));
-%! legend ({'12345678901234567890'}, 'location', 'southeastoutside');
-%! legend (option);
+%!  plot (rand (1,4));
+%!  legend ({'12345678901234567890'}, 'location', 'southwestoutside');
+%!  legend (option);
+
+%!demo % bug 36408
+%! clf;
+%! option = 'right';
+%! subplot (3,1,1);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  title ('Subplots should adjust to the legend placed outside');
+%!  legend ({'1'}, 'location', 'northeastoutside');
+%!  legend (option);
+%! subplot (3,1,2);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'1234567890'}, 'location', 'eastoutside');
+%!  legend (option);
+%! subplot (3,1,3);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'12345678901234567890'}, 'location', 'southeastoutside');
+%!  legend (option);
 
 %!demo % bug 36408
 %! clf;
 %! option = 'right';
-%! subplot (3,1,1)
-%! plot (rand (1,4));
-%! title ('Subplots should adjust to the legend placed outside');
-%! legend ({'1'}, 'location', 'northwestoutside');
-%! legend (option);
+%! subplot (3,1,1);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  title ('Subplots should adjust to the legend placed outside');
+%!  legend ({'1'}, 'location', 'northwestoutside');
+%!  legend (option);
+%! subplot (3,1,2);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'1234567890'}, 'location', 'westoutside');
+%!  legend (option);
+%! subplot (3,1,3);
+%!  plot (rand (1,4));
+%!  set (gca (), 'yaxislocation', 'right');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'12345678901234567890'}, 'location', 'southwestoutside');
+%!  legend (option);
+
+%!demo % bug 36408;
+%! clf;
+%! option = 'right';
+%! subplot (3,1,1);
+%!  plot (rand (1,4));
+%!  set (gca (), 'xaxislocation', 'top');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  title ('Subplots should adjust to the legend placed outside');
+%!  legend ({'1'}, 'location', 'northwestoutside');
+%!  legend (option);
 %! subplot (3,1,2);
-%! plot (rand (1,4));
-%! legend ({'1234567890'}, 'location', 'westoutside');
-%! legend (option);
+%!  plot (rand (1,4));
+%!  set (gca (), 'xaxislocation', 'top');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'1234567890'}, 'location', 'westoutside');
+%!  legend (option);
 %! subplot (3,1,3);
-%! plot (rand (1,4));
-%! legend ({'12345678901234567890'}, 'location', 'southwestoutside');
-%! legend (option);
+%!  plot (rand (1,4));
+%!  set (gca (), 'xaxislocation', 'top');
+%!  xlabel ('xlabel');
+%!  ylabel ('ylabel');
+%!  legend ({'12345678901234567890'}, 'location', 'southwestoutside');
+%!  legend (option);
+
+%!demo % bug 39697
+%! clf;
+%! plot (1:10);
+%! legend ('Legend Text');
+%! title ({'Multi-line', 'titles', 'are a', 'problem'});
 
+%!demo
+%! clf;
+%! colormap (cool (64));
+%! surf (peaks ());
+%! legend ('peaks()')
+%! title ('legend() works for surface objects too');
+
+%!test
+%! toolkit = graphics_toolkit ("gnuplot");
+%! h = figure ("visible", "off");
+%! unwind_protect
+%!   position = get (h, "position");
+%!   plot (rand (3));
+%!   legend ();
+%!   filename = sprintf ("%s.eps", tmpnam ());
+%!   print (filename);
+%!   unlink (filename);
+%!   assert (get (h, "position"), position);
+%! unwind_protect_cleanup
+%!   close (h);
+%!   graphics_toolkit (toolkit);
+%! end_unwind_protect
+
diff --git a/scripts/plot/appearance/module.mk b/scripts/plot/appearance/module.mk
new file mode 100644
--- /dev/null
+++ b/scripts/plot/appearance/module.mk
@@ -0,0 +1,41 @@
+FCN_FILE_DIRS += plot/appearance
+
+plot_appearance_PRIVATE_FCN_FILES = \
+  plot/appearance/private/__axis_limits__.m \
+  plot/appearance/private/__axis_label__.m
+
+plot_appearance_FCN_FILES = \
+  plot/appearance/__clabel__.m \
+  plot/appearance/__getlegenddata__.m \
+  plot/appearance/axis.m \
+  plot/appearance/box.m \
+  plot/appearance/caxis.m \
+  plot/appearance/clabel.m \
+  plot/appearance/daspect.m \
+  plot/appearance/diffuse.m \
+  plot/appearance/grid.m \
+  plot/appearance/gtext.m \
+  plot/appearance/hidden.m \
+  plot/appearance/legend.m \
+  plot/appearance/orient.m \
+  plot/appearance/pbaspect.m \
+  plot/appearance/shading.m \
+  plot/appearance/specular.m \
+  plot/appearance/text.m \
+  plot/appearance/title.m \
+  plot/appearance/view.m \
+  plot/appearance/whitebg.m \
+  plot/appearance/xlabel.m \
+  plot/appearance/xlim.m \
+  plot/appearance/ylabel.m \
+  plot/appearance/ylim.m \
+  plot/appearance/zlabel.m \
+  plot/appearance/zlim.m \
+  $(plot_appearance_PRIVATE_FCN_FILES)
+
+FCN_FILES += $(plot_appearance_FCN_FILES)
+
+PKG_ADD_FILES += plot/appearance/PKG_ADD
+
+DIRSTAMP_FILES += plot/appearance/$(octave_dirstamp)
+
diff --git a/scripts/plot/orient.m b/scripts/plot/appearance/orient.m
rename from scripts/plot/orient.m
rename to scripts/plot/appearance/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/appearance/orient.m
@@ -12,25 +12,33 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} orient (@var{orientation})
-## Set the default print orientation.  Valid values for
-## @var{orientation} include @code{"landscape"}, @code{"portrait"},
-## and @code{"tall"}.
+## @deftypefn  {Function File} {} orient (@var{orientation})
+## @deftypefnx {Function File} {} orient (@var{hfig}, @var{orientation})
+## @deftypefnx {Function File} {@var{orientation} =} orient ()
+## @deftypefnx {Function File} {@var{orientation} =} orient (@var{hfig})
+## Query or set the default print orientation.
+##
+## Valid values for @var{orientation} are @qcode{"landscape"},
+## @qcode{"portrait"}, and @qcode{"tall"}.
 ##
-## The @code{"tall"} option sets the orientation to portait and fills
-## the page with the plot, while leaving a 0.25in border.
+## The @qcode{"tall"} option sets the orientation to portrait and fills
+## the page with the plot, while leaving a 0.25 inch border.
 ##
-## If called with no arguments, return the default print orientation.
+## When called with no arguments, return the default print orientation.
+##
+## If the first argument @var{hfig} is a figure handle, then operate on this
+## figure rather than the current figure returned by @code{gcf}.
+## @seealso{print, saveas}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Adapted-By: jwe
 
 function retval = orient (varargin)
 
   nargs = nargin;
@@ -44,18 +52,18 @@ function retval = orient (varargin)
   endif
 
   if (nargs == 0)
     retval = get (cf, "paperorientation");
   elseif (nargin == 1)
     orientation = varargin{1};
     if (strcmpi (orientation, "landscape") || strcmpi (orientation, "portrait"))
       if (! strcmpi (get (cf, "paperorientation"), orientation))
-        ## FIXME - with the proper listeners in place there won't be a need to set
-        ##         the papersize and paperpostion here.
+        ## FIXME: with the proper listeners in place there won't be a need to
+        ##        set the papersize and paperpostion here.
         papersize = get (cf, "papersize");
         paperposition = get (cf, "paperposition");
         set (cf, "paperorientation", orientation);
         set (cf, "papersize", papersize([2, 1]));
         set (cf, "paperposition", paperposition([2, 1, 4, 3]));
       endif
     elseif (strcmpi (varargin{1}, 'tall'))
       orient ("portrait");
@@ -70,42 +78,49 @@ function retval = orient (varargin)
 
 endfunction
 
 
 %!shared papersize, paperposition, tallpaperposition, hfig
 %! papersize = [8.5, 11];
 %! paperposition = [0.25, 2.5, 8, 6];
 %! tallpaperposition = [0.25, 0.25, (papersize-0.5)];
-%! hfig = figure ();
-%! set (hfig, "visible", "off");
+%! hfig = figure ("visible", "off");
 %! set (hfig, "paperorientation", "portrait");
 %! set (hfig, "papersize", papersize);
 %! set (hfig, "paperposition", paperposition);
+
 %!test
 %! orient portrait;
 %! assert (orient, "portrait")   # default
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), paperposition);
+
 %!test
 %! orient landscape;
 %! assert (orient,"landscape")   # change to landscape
 %! assert (get (hfig, "papersize"), papersize([2, 1]));
 %! assert (get (hfig, "paperposition"), paperposition([2, 1, 4, 3]));
+
 %!test
 %! orient portrait   # change back to portrait
 %! assert (orient, "portrait");
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), paperposition);
+
 %!test
 %! orient landscape;
 %! orient tall;
 %! assert (orient, "portrait");
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), tallpaperposition);
+
 %!fail ("orient ('nobody')", "unknown ORIENTATION")
+
 %!test
 %! orient portrait   # errors don't change the state
 %! assert (orient, "portrait");
 %! assert (get (hfig, "papersize"), papersize);
 %! assert (get (hfig, "paperposition"), tallpaperposition);
+
+%!test
 %! close (hfig);
 
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/appearance/pbaspect.m
rename from scripts/plot/pbaspect.m
rename to scripts/plot/appearance/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/appearance/pbaspect.m
@@ -18,84 +18,86 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{plot_box_aspect_ratio} =} pbaspect ( )
 ## @deftypefnx {Function File} {} pbaspect (@var{plot_box_aspect_ratio})
 ## @deftypefnx {Function File} {} pbaspect (@var{mode})
 ## @deftypefnx {Function File} {@var{plot_box_aspect_ratio_mode} =} pbaspect ("mode")
 ## @deftypefnx {Function File} {} pbaspect (@var{hax}, @dots{})
 ##
-## Query or set the plot box aspect ratio of the current axes.  The aspect
-## ratio is a normalized 3-element vector representing the rendered lengths of
-## the x, y, and z axes.
+## Query or set the plot box aspect ratio of the current axes.
+##
+## The aspect ratio is a normalized 3-element vector representing the rendered
+## lengths of the x, y, and z axes.
 ##
 ## @code{pbaspect(@var{mode})}
 ##
 ## Set the plot box aspect ratio mode of the current axes.  @var{mode} is
-## either "auto" or "manual".
+## either @qcode{"auto"} or @qcode{"manual"}.
 ##
 ## @code{pbaspect ("mode")}
 ##
 ## Return the plot box aspect ratio mode of the current axes.
 ##
 ## @code{pbaspect (@var{hax}, @dots{})}
 ##
 ## Operate on the axes in handle @var{hax} instead of the current axes.
 ##
 ## @seealso{axis, daspect, xlim, ylim, zlim}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-01-26
 
-function varargout = pbaspect (varargin)
+function pbratio = pbaspect (varargin)
 
-  hax = gca ();
-
+  ## Grab axes handle if present
   if (nargin > 0)
-    if (isscalar (varargin{1}) && ishandle (varargin{1}))
+    if (isscalar (varargin{1}) && isaxes (varargin{1}))
       hax = varargin{1};
       varargin = varargin(2:end);
+    else
+      hax = gca ();
     endif
+  else
+    hax = gca ();
   endif
-  if (numel (varargin) > 0)
-    if (numel (varargin) == 1)
-      if (ischar (varargin{1})
-          && any (strcmpi (varargin{1}, {"mode", "manual", "auto"})))
-        switch (varargin{1})
-        case "mode"
-          if (nargout < 2)
-            varargout{1} = get (hax, "plotboxaspectratiomode");
-            return
-          else
-            error ("pbaspect: only one output is allowed");
-          endif
-        case "manual"
-          set (hax, "plotboxaspectratiomode", "manual");
-        case "auto"
-          set (hax, "plotboxaspectratiomode", "auto");
-        endswitch
-      elseif (isreal (varargin{1}) && numel (varargin{1}) == 2)
-        set (hax, "plotboxaspectratio", [varargin{1}, 1]);
-      elseif (isreal (varargin{1}) && numel (varargin{1}) == 3)
-        set (hax, "plotboxaspectratio", varargin{1});
-      else
-        error ("pbaspect: invalid input");
-      endif
-    elseif (numel (varargin) > 1)
-      error ("pbaspect: too many inputs");
-    endif
-  elseif (nargout == 0)
+
+  nargin = numel (varargin);
+  if (nargin > 1)
     print_usage ();
   endif
 
-  if (nargout == 1)
-    varargout{1} = get (hax, "plotboxaspectratio");
-  elseif (nargout > 1)
-    error ("pbaspect: only one output is allowed");
+  if (nargin == 0)
+    pbratio = get (hax, "plotboxaspectratio");
+  else
+    arg = varargin{1};
+    if (isreal (arg))
+      if (numel (arg) == 2)
+        set (hax, "plotboxaspectratio", [arg, 1]);
+      elseif (numel (arg) == 3)
+        set (hax, "plotboxaspectratio", arg);
+      else
+        error ("pbaspect: PLOT_BOX_ASPECT_RATIO must be a 2 or 3 element vector");
+      endif
+    elseif (ischar (arg))
+      arg = tolower (arg);
+      switch (arg)
+        case "auto"
+          set (hax, "plotboxaspectratiomode", "auto");
+        case "manual"
+          set (hax, "plotboxaspectratiomode", "manual");
+        case "mode"
+          pbratio = get (hax, "plotboxaspectratiomode");
+        otherwise
+          error ("pbaspect: Invalid mode <%s>", arg);
+      endswitch
+    else
+      print_usage ();
+    endif
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.01:4;
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/appearance/private/__axis_label__.m
rename from scripts/plot/private/__axis_label__.m
rename to scripts/plot/appearance/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/appearance/private/__axis_label__.m
@@ -18,25 +18,26 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __axis_label__ (@var{caller}, @var{h}, @var{txt}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = __axis_label__ (ah, caller, txt, varargin)
+function retval = __axis_label__ (hax, caller, txt, varargin)
 
-  h = get (ah, caller);
+  h = get (hax, caller);
 
-  set (h, "fontangle", get (ah, "fontangle"),
-       "fontname", get (ah, "fontname"),
-       "fontsize", get (ah, "fontsize"),
-       "fontunits", get (ah, "fontunits"),
-       "fontweight", get (ah, "fontweight"),
-       "string", txt,
-       varargin{:});
+  set (h, "fontangle", get (hax, "fontangle"),
+          "fontname", get (hax, "fontname"),
+          "fontunits", get (hax, "fontunits"),   # must precede fontsize
+          "fontsize", get (hax, "fontsize"),
+          "fontweight", get (hax, "fontweight"),
+          "string", txt,
+          varargin{:});
 
   if (nargout > 0)
     retval = h;
   endif
 
 endfunction
+
diff --git a/scripts/plot/private/__axes_limits__.m b/scripts/plot/appearance/private/__axis_limits__.m
rename from scripts/plot/private/__axes_limits__.m
rename to scripts/plot/appearance/private/__axis_limits__.m
--- a/scripts/plot/private/__axes_limits__.m
+++ b/scripts/plot/appearance/private/__axis_limits__.m
@@ -12,45 +12,47 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} __axes_limits__ (@var{fcn}, @dots{})
+## @deftypefn {Function File} {} __axis_limits__ (@var{fcn}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function retval = __axes_limits__ (fcn, varargin)
+function retval = __axis_limits__ (fcn, varargin)
 
-  retval = [];
+  [hax, varargin, nargin] = __plt_get_axis_arg__ (fcn, varargin{:});
 
-  fcnmode = sprintf ("%smode", fcn);
-
-  [h, varargin, nargin] = __plt_get_axis_arg__ (fcn, varargin{:});
+  if (isempty (hax))
+    hax = gca ();
+  endif
 
   if (nargin == 0)
-    retval = get (h, fcn);
+    retval = get (hax, fcn);
   else
+    retval = [];
+    fcnmode = [fcn "mode"];
     arg = varargin{1};
-
     if (ischar (arg))
       if (strcmpi (arg, "mode"))
-        retval = get (h, fcnmode);
-      elseif (strcmpi (arg, "auto") ||  strcmpi (arg, "manual"))
-        set (h, fcnmode, arg);
+        retval = get (hax, fcnmode);
+      elseif (any (strcmpi (arg, {"auto", "manual"})))
+        set (hax, fcnmode, arg);
       endif
     else
       if (!isnumeric (arg) && any (size (arg(:)) != [2, 1]))
-        error ("%s: argument must be a 2 element vector", fcn);
+        error ("%s: LIMITS must be a 2-element vector", fcn);
       else
         if (arg(1) >= arg(2))
           error ("%s: axis limits must be increasing", fcn);
         else
-          set (h, fcn, arg(:));
+          set (hax, fcn, arg(:));
         endif
       endif
     endif
   endif
 
 endfunction
+
diff --git a/scripts/plot/shading.m b/scripts/plot/appearance/shading.m
rename from scripts/plot/shading.m
rename to scripts/plot/appearance/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/appearance/shading.m
@@ -13,68 +13,92 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} shading (@var{type})
-## @deftypefnx {Function File} {} shading (@var{ax}, @dots{})
-## Set the shading of surface or patch graphic objects.  Valid arguments
-## for @var{type} are
+## @deftypefnx {Function File} {} shading (@var{hax}, @var{type})
+## Set the shading of patch or surface graphic objects.
+##
+## Valid arguments for @var{type} are
 ##
 ## @table @asis
-## @item "flat"
+## @item @qcode{"flat"}
 ## Single colored patches with invisible edges.
 ##
-## @item "faceted"
+## @item @qcode{"faceted"}
 ## Single colored patches with visible edges.
 ##
-## @item "interp"
+## @item @qcode{"interp"}
 ## Color between patch vertices are interpolated and the patch edges are
 ## invisible.
 ## @end table
 ##
-## If @var{ax} is given the shading is applied to axis @var{ax} instead
-## of the current axis.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+## @seealso{fill, mesh, patch, pcolor, surf, surface, hidden}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function shading (varargin)
 
-  [ax, varargin] = __plt_get_axis_arg__ ("shading", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("shading", varargin{:});
 
-  if (nargin != 1 && nargin != 2)
+  if (nargin != 1)
     print_usage ();
   endif
 
   mode = varargin{1};
 
-  h1 = findobj (ax, "type", "patch");
-  h2 = findobj (ax, "type", "surface");
-
-  obj = [h1(:); h2(:)];
+  if (isempty (hax))
+    hax = gca ();
+  endif
 
-  for n = 1:numel (obj)
-    h = obj(n);
-    if (strcmpi (mode, "flat"))
-      set (h, "facecolor", "flat");
-      set (h, "edgecolor", "none");
-    elseif (strcmpi (mode, "interp"))
-      set (h, "facecolor", "interp");
-      set (h, "edgecolor", "none");
-    elseif (strcmpi (mode, "faceted"))
-      set (h, "facecolor", "flat");
-      set (h, "edgecolor", [0 0 0]);
-    else
-      error ("shading: unknown argument");
-    endif
-  endfor
+  ## Find all patch and surface objects that are descendants of hax
+  ## and  which are not part of a contour plot hggroup.
+  hlist = [];
+  kids = get (hax, "children");
+  while (! isempty (kids))
+    types = get (kids, "type");
+    hlist = [hlist; kids(strcmp(types, "patch"))];
+    hlist = [hlist; kids(strcmp(types, "surface"))];
+    parents = kids(strcmp (types, "axes"));
+    hglist = kids(strcmp (types, "hggroup"));
+    for i = 1 : numel (hglist)
+      props = get (hglist(i));
+      if (! isfield (props, "levelstep"))
+        parents(end+1) = hglist(i); 
+      endif
+    endfor
+    kids = get (parents, "children");
+  endwhile
+
+  ## FIXME: This is the old, simple code.
+  ##        Unfortunately, it also shades contour plots which is not desirable.
+  ##hp = findobj (hax, "type", "patch");
+  ##hs = findobj (hax, "type", "surface");
+  ##hlist = [hp(:); hs(:)];
+
+  switch (lower (mode))
+    case "flat"
+      set (hlist, "facecolor", "flat");
+      set (hlist, "edgecolor", "none");
+    case "interp"
+      set (hlist, "facecolor", "interp");
+      set (hlist, "edgecolor", "none");
+    case "faceted"
+      set (hlist, "facecolor", "flat");
+      set (hlist, "edgecolor", [0 0 0]);
+    otherwise
+      error ('shading: Invalid MODE "%s"', mode);
+  endswitch
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! sombrero ();
diff --git a/scripts/plot/specular.m b/scripts/plot/appearance/specular.m
rename from scripts/plot/specular.m
rename to scripts/plot/appearance/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/appearance/specular.m
@@ -16,23 +16,24 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv})
 ## @deftypefnx {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv}, @var{se})
 ## Calculate specular reflection strength of a surface defined by the normal
 ## vector elements @var{sx}, @var{sy}, @var{sz} using Phong's approximation.
-## The light and view vectors can be specified using parameter @var{lv} and
-## @var{vv} respectively.
-## Both can be given as 2-element vectors [azimuth, elevation] in degrees or as
-## 3-element
-## vector [x, y, z].  An optional 6th argument describes the specular exponent
-## (spread) @var{se}.
-## @seealso{surfl, diffuse}
+##
+## The light source location and viewer location vectors can be specified using
+## parameter @var{lv} and @var{vv} respectively.  The location vectors can
+## given as 2-element vectors [azimuth, elevation] in degrees or as 3-element
+## vectors [x, y, z].
+##
+## An optional sixth argument describes the specular exponent (spread) @var{se}.
+## @seealso{diffuse, surfl}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = specular (sx, sy, sz, lv, vv, se)
 
   if (nargin < 5 || nargin > 6)
     print_usage ();
@@ -85,8 +86,9 @@ function retval = specular (sx, sy, sz, 
   ## Set zero if light is on the other side.
   retval(l_dot_n < 0) = 0;
 
   ## Allow postive values only.
   retval(retval < 0) = 0;
   retval = retval .^ se;
 
 endfunction
+
diff --git a/scripts/plot/text.m b/scripts/plot/appearance/text.m
rename from scripts/plot/text.m
rename to scripts/plot/appearance/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/appearance/text.m
@@ -12,27 +12,33 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} text (@var{x}, @var{y}, @var{label})
-## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label})
-## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{label}, @var{p1}, @var{v1}, @dots{})
-## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{label}, @var{p1}, @var{v1}, @dots{})
+## @deftypefn  {Function File} {} text (@var{x}, @var{y}, @var{string})
+## @deftypefnx {Function File} {} text (@var{x}, @var{y}, @var{z}, @var{string})
+## @deftypefnx {Function File} {} text (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} text (@dots{})
-## Create a text object with text @var{label} at position @var{x},
-## @var{y}, @var{z} on the current axes.  Property-value pairs following
-## @var{label} may be used to specify the appearance of the text.
+## Create a text object with text @var{string} at position @var{x}, @var{y},
+## (@var{z}) on the current axes.
+##
+## Multiple locations can be specified if @var{x}, @var{y}, (@var{z}) are
+## vectors.  Multiple strings can be specified with a character matrix or
+## a cell array of strings.
 ##
-## The optional return value @var{h} is a graphics handle to the created text
-## object.
+## Optional property/value pairs may be used to control the appearance of the
+## text.
+##
+## The optional return value @var{h} is a vector of graphics handles to the
+## created text objects.
+## @seealso{gtext, title, xlabel, ylabel, zlabel}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## Note: The following code is rigged for Matlab compatibility and is
 ##       full of hidden assumptions.  Be very wary when modifying.
 
 function h = text (varargin)
@@ -47,99 +53,114 @@ function h = text (varargin)
     if (nargin > 3 && isnumeric (varargin{3}))
       z = varargin{3};
       offset = 4;
     else
       z = zeros (size (x));
       offset = 3;
     endif
 
-    label = varargin{offset};
+    string = varargin{offset};
     varargin(1:offset) = [];
 
     nx = numel (x);
     ny = numel (y);
     nz = numel (z);
-    if (ischar (label))
+    if (ischar (string))
 
       do_keyword_repl = true;
-      nt = rows (label);
+      nt = rows (string);
       if (nx == 1 && nt == 1)
         ## Single text object with one line
-        label = {label};
+        string = {string};
       elseif (nx == 1 && nt > 1)
         ## Single text object with multiple lines
         ## FIXME: "default" or "factory" as first row
         ##        should be escaped to "\default" or "\factory"
         ##        Other rows do not require escaping.
         do_keyword_repl = false;
-        label = {label};
+        string = {string};
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
-        label = cellstr (label);
+        string = cellstr (string);
       else 
         ## Mutiple text objects with same string
-        label = repmat ({label}, [nx, 1]);
+        string = repmat ({string}, [nx, 1]);
         nt = nx;
       endif
 
       ## Escape special keywords
       if (do_keyword_repl)
-        label = regexprep (label, '^(default|factory)$', '\\$1');
+        string = regexprep (string, '^(default|factory)$', '\\$1');
       endif
 
-    elseif (iscell (label))
+    elseif (iscell (string))
 
-      nt = numel (label);
+      nt = numel (string);
       if (nx == 1)      
         ## Single text object with one or more lines
-        label = {label};
+        string = {string};
         nt = 1;
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
       else
         ## Mutiple text objects with same string
-        label = repmat ({label}, [nx, 1]);
+        string = repmat ({string}, [nx, 1]);
         nt = nx;
       endif
 
     else
 
-      error ("text: LABEL must be a character string or cell array of character strings");
+      error ("text: STRING must be a character string or cell array of character strings");
 
     endif
   else  # Only PROP/VALUE pairs
     x = y = z = 0;
     nx = ny = nz = 1;
-    label = {""};
+    string = {""};
     nt = 1;
   endif
 
   ## Any remaining inputs must occur as PROPERTY/VALUE pairs
   if (rem (numel (varargin), 2) != 0)
     print_usage ();
   endif
 
-  if (nx == ny && nx == nz && (nt == nx || nt == 1 || nx == 1))
+  ## Get axis argument which may be in a 'parent' PROP/VAL pair
+  [hax, varargin] = __plt_get_axis_arg__ ("text", varargin{:});
+
+  if (isempty (hax))
+    hax = gca ();
+  endif
+
+  ## Position argument may alse be in PROP/VAL pair
+  idx = find (strcmpi (varargin, "position"), 1);
+  if (idx)
+    pos = varargin{idx+1};
+    varargin(idx:idx+1) = [];
+  else
     pos = [x(:), y(:), z(:)];
-    ca = gca ();
+  endif
+
+  if (nx == ny && nx == nz && (nt == nx || nt == 1 || nx == 1))
     htmp = zeros (nt, 1);
     if (nx == 1)
-      htmp = __go_text__ (ca, "string", label{1},
-                          varargin{:},
-                          "position", pos);
+      htmp = __go_text__ (hax, "string", string{1},
+                               ## varargin first, in case "Units" set for pos.
+                               varargin{:},
+                               "position", pos);
     elseif (nx == nt)
       for n = 1:nt
-        htmp(n) = __go_text__ (ca, "string", label{n},
-                               varargin{:},
-                               "position", pos(n,:));
+        htmp(n) = __go_text__ (hax, "string", string{n},
+                                    varargin{:},
+                                    "position", pos(n,:));
       endfor
       __request_drawnow__ ();
     else
-      error ("text: dimension mismatch for coordinates and LABEL");
+      error ("text: dimension mismatch for coordinates and STRING");
     endif
   elseif (nt == nx || nt == 1 || nx == 1)
     error ("text: dimension mismatch for coordinates");
   else
     error ("text: dimension mismatch between coordinates and strings");
   endif
 
   if (nargout > 0)
diff --git a/scripts/plot/title.m b/scripts/plot/appearance/title.m
rename from scripts/plot/title.m
rename to scripts/plot/appearance/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/appearance/title.m
@@ -13,71 +13,100 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} title (@var{string})
-## @deftypefnx {Function File} {} title (@var{string}, @var{p1}, @var{v1}, @dots{})
-## @deftypefnx {Function File} {} title (@var{h}, @dots{})
+## @deftypefnx {Function File} {} title (@var{string}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} title (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} title (@dots{})
-## Create a title object for a plot.
+## Specify the string used as a title for the current axis.
+##
+## An optional list of @var{property}/@var{value} pairs can be used to change
+## the appearance of the created title text object.
 ##
-## The optional return value @var{h} is a graphics handle to the created object.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
+## @seealso{xlabel, ylabel, zlabel, text}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = title (varargin)
+function h = title (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("title", varargin{:});
-
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  tmp = __axis_label__ (h, "title", varargin{:});
+  htmp = __axis_label__ (hax, "title", varargin{:});
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! ax = axes ();
-%! xl = get (ax, 'title');
-%! title ('Testing title');
-%! assert (get (xl, 'string'), 'Testing title');
+%! h = get (ax, 'title');
+%! title ('Test Title Text');
+
+%!demo
+%! clf;
+%! ax = axes ();
+%! h = get (ax, 'title');
+%! title ({'Multi-line'; 'Title'; 'Text'});
 
 %!demo
 %! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xl = get (gca, 'title');
-%! title ('Testing title');
-%! assert (get (xl, 'string'), 'Testing title');
+%! h = get (gca, 'title');
+%! title ('Test FontSize Property', 'fontsize', 16);
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ax = axes ();
-%!   xl = get (ax, "title");
-%!   title ("Testing title");
-%!   assert (get (xl, "string"), "Testing title");
+%!   h = get (ax, "title");
+%!   title ("Test Title Text");
+%!   assert (get (h, "string"), "Test Title Text");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   ax = axes ();
+%!   h = get (ax, "title");
+%!   title ({'Multi-line'; 'Title'; 'Text'});
+%!   assert (get (h, "string"), {'Multi-line'; 'Title'; 'Text'});
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
-%!   xl = get (gca, "title");
-%!   title ("Testing title");
-%!   assert (get (xl, "string"), "Testing title");
+%!   h = get (gca, "title");
+%!   title ("Test FontSize Property", "fontsize", 16);
+%!   assert (get (h, "string"), "Test FontSize Property");
+%!   assert (get (h, "fontsize"), 16);
+
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/view.m b/scripts/plot/appearance/view.m
rename from scripts/plot/view.m
rename to scripts/plot/appearance/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/appearance/view.m
@@ -12,90 +12,91 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{azimuth}, @var{elevation}] =} view ()
-## @deftypefnx {Function File} {} view (@var{azimuth}, @var{elevation})
+## @deftypefn  {Function File} {} view (@var{azimuth}, @var{elevation})
 ## @deftypefnx {Function File} {} view ([@var{azimuth} @var{elevation}])
 ## @deftypefnx {Function File} {} view ([@var{x} @var{y} @var{z}])
 ## @deftypefnx {Function File} {} view (2)
 ## @deftypefnx {Function File} {} view (3)
-## @deftypefnx {Function File} {} view (@var{ax}, @dots{})
-## Query or set the viewpoint for the current axes.  The parameters
-## @var{azimuth} and @var{elevation} can be given as two arguments or as
-## 2-element vector.
-## The viewpoint can also be given with Cartesian coordinates @var{x},
-## @var{y}, and @var{z}.
-## The call @code{view (2)} sets the viewpoint to @var{azimuth} = 0
-## and @var{elevation} = 90, which is the default for 2-D graphs.
-## The call @code{view (3)} sets the viewpoint to @var{azimuth} = -37.5
-## and @var{elevation} = 30, which is the default for 3-D graphs.
-## If @var{ax} is given, the viewpoint is set for this axes, otherwise
-## it is set for the current axes.
+## @deftypefnx {Function File} {} view (@var{hax}, @dots{})
+## @deftypefnx {Function File} {[@var{azimuth}, @var{elevation}] =} view ()
+## Query or set the viewpoint for the current axes.
+##
+## The parameters @var{azimuth} and @var{elevation} can be given as two
+## arguments or as 2-element vector.  The viewpoint can also be specified with
+## Cartesian coordinates @var{x}, @var{y}, and @var{z}.
+##
+## The call @code{view (2)} sets the viewpoint to @w{@var{azimuth} = 0}
+## and @w{@var{elevation} = 90}, which is the default for 2-D graphs.
+##
+## The call @code{view (3)} sets the viewpoint to @w{@var{azimuth} = -37.5}
+## and @w{@var{elevation} = 30}, which is the default for 3-D graphs.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+##
+## If no inputs are given, return the current @var{azimuth} and @var{elevation}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function [azimuth, elevation] = view (varargin)
 
-  if (nargin < 4)
-    if (nargin == 0)
-      args = {get(gca (), "view")};
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("view", varargin{:});
+  if (isempty (hax))
+    hax = gca ();
+  endif
+
+  if (nargin > 3)
+    print_usage ();
+  endif
+
+  if (nargin == 0)
+    x = get (hax, "view");
+    az = x(1);
+    el = x(2);
+  elseif (length (varargin) == 1)
+    x = varargin{1};
+    if (length (x) == 2)
+      az = x(1);
+      el = x(2);
+    elseif (length (x) == 3)
+      [az, el] = cart2sph (x(1), x(2), x(3));
+      az *= 180/pi;
+      az += 90;
+      el *= 180/pi;
+    elseif (x == 2)
+      az = 0;
+      el = 90;
+    elseif (x == 3)
+      az = -37.5;
+      el = 30;
     else
-      ax = varargin{1};
-      if (ishandle (ax) && strcmp (get (ax, "type"), "axes"))
-        args = varargin(2:end);
-      else
-        ax = gca;
-        args = varargin;
-      endif
+      print_usage ();
     endif
-    if (length (args) == 1)
-      x = args{1};
-      if (length (x) == 2)
-        az = x(1);
-        el = x(2);
-      elseif (length (x) == 3)
-        [az, el] = cart2sph (x(1), x(2), x(3));
-        az *= 180/pi;
-        az += 90;
-        el *= 180/pi;
-      elseif (x == 2)
-        az = 0;
-        el = 90;
-      elseif (x == 3)
-        az = -37.5;
-        el = 30;
-      else
-        print_usage ();
-      endif
-    elseif (length (args) == 2)
-      az = args{1};
-      el = args{2};
-    endif
+  elseif (length (varargin) == 2)
+    az = varargin{1};
+    el = varargin{2};
+  endif
 
-    if (nargin > 0)
-      set (ax, "view", [az, el]);
-    endif
-
+  if (nargin > 0)
+    set (hax, "view", [az, el]);
+  else
     if (nargout == 1)
-      error ("view: T = view () not implemented");
-    endif
-
-    if (nargout == 2)
+      azimuth = [az, el];
+    elseif (nargout == 2)
       azimuth = az;
       elevation = el;
     endif
-  else
-    print_usage ();
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
diff --git a/scripts/plot/whitebg.m b/scripts/plot/appearance/whitebg.m
rename from scripts/plot/whitebg.m
rename to scripts/plot/appearance/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -15,30 +15,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} whitebg ()
 ## @deftypefnx {Function File} {} whitebg (@var{color})
 ## @deftypefnx {Function File} {} whitebg ("none")
-## @deftypefnx {Function File} {} whitebg (@var{fig})
-## @deftypefnx {Function File} {} whitebg (@var{fig}, @var{color})
-## @deftypefnx {Function File} {} whitebg (@var{fig}, "none")
-## Invert the colors in the current color scheme.  The root properties are
-## also inverted such that all subsequent plot use the new color scheme.
+## @deftypefnx {Function File} {} whitebg (@var{hfig}, @dots{})
+## Invert the colors in the current color scheme.
 ##
-## If defined, @var{fig} is the handle to the figure to be inverted.  In
-## this case only the specified figure has its color properties changed.
+## The root properties are also inverted such that all subsequent plot use the
+## new color scheme.
 ##
 ## If the optional argument @var{color} is present then the background color
 ## is set to @var{color} rather than inverted.  @var{color} may be a string
 ## representing one of the eight known colors or an RGB triplet.  The special
-## string argument "none" restores the plot to the default colors.
-## @seealso{reset}
+## string argument @qcode{"none"} restores the plot to the default colors.
+##
+## If the first argument @var{hfig} is a figure handle, then operate on
+## this figure rather than the current figure returned by @code{gcf}.  The
+## root properties will not be changed.
+## @seealso{reset, get, set}
 ## @end deftypefn
 
 function whitebg (varargin)
   h = 0;
   color = NaN;
 
   if (nargin > 0 && nargin < 3)
     if (ishandle (varargin{1}))
diff --git a/scripts/plot/xlabel.m b/scripts/plot/appearance/xlabel.m
rename from scripts/plot/xlabel.m
rename to scripts/plot/appearance/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/appearance/xlabel.m
@@ -13,51 +13,61 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} xlabel (@var{string})
-## @deftypefnx {Function File} {} xlabel (@var{h}, @var{string})
+## @deftypefnx {Function File} {} xlabel (@var{string}, @var{property}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} xlabel (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} xlabel (@dots{})
-## @deftypefnx {Function File} {} ylabel (@dots{})
-## @deftypefnx {Function File} {} zlabel (@dots{})
-## Specify x-, y-, or z-axis labels for the current axis.  If @var{h} is
-## specified then label the axis defined by @var{h}.
+## Specify the string used to label the x-axis of the current axis.
+##
+## An optional list of @var{property}/@var{value} pairs can be used to change
+## the properties of the created text label.
 ##
-## The optional return value @var{h} is a graphics handle to the created object.
-## @seealso{title, text}
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
+## @seealso{ylabel, zlabel, datetick, title, text}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = xlabel (varargin)
+function h = xlabel (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("xlabel", varargin{:});
-
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  tmp = __axis_label__ (h, "xlabel", varargin{:},
-                        "color", get (h, "xcolor"));
+  htmp = __axis_label__ (hax, "xlabel", varargin{1},
+                         "color", get (hax, "xcolor"), varargin{2:end});
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   x = xlabel ("xlabel_string");
+%!   x = xlabel ("xlabel_string", "color", "r");
 %!   assert (get (gca, "xlabel"), x);
 %!   assert (get (x, "type"), "text");
 %!   assert (get (x, "visible"), "on");
 %!   assert (get (x, "string"), "xlabel_string");
+%!   assert (get (x, "color"), [1 0 0]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/xlim.m b/scripts/plot/appearance/xlim.m
rename from scripts/plot/xlim.m
rename to scripts/plot/appearance/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/appearance/xlim.m
@@ -12,42 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @c List other forms of function in documentation index
-## @findex ylim
-## @findex zlim
+## @deftypefn  {Function File} {@var{xlimits} =} xlim ()
+## @deftypefnx {Function File} {@var{xmode} =} xlim ("mode")
+## @deftypefnx {Function File} {} xlim ([@var{x_lo} @var{x_hi}])
+## @deftypefnx {Function File} {} xlim ("auto")
+## @deftypefnx {Function File} {} xlim ("manual")
+## @deftypefnx {Function File} {} xlim (@var{hax}, @dots{})
+## Query or set the limits of the x-axis for the current plot.
 ##
-## @deftypefn  {Function File} {@var{xl} =} xlim ()
-## @deftypefnx {Function File} {} xlim (@var{xl})
-## @deftypefnx {Function File} {@var{m} =} xlim ("mode")
-## @deftypefnx {Function File} {} xlim (@var{m})
-## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
-## Get or set the limits of the x-axis of the current plot.  Called without
-## arguments @code{xlim} returns the x-axis limits of the current plot.
-## If passed a two element vector @var{xl}, the limits of the x-axis are set
-## to this value.
+## Called without arguments @code{xlim} returns the x-axis limits of the
+## current plot.  With the input query @qcode{"mode"}, return the current
+## x-limit calculation mode which is either @qcode{"auto"} or @qcode{"manual"}.
+##
+## If passed a 2-element vector [@var{x_lo} @var{x_hi}], the limits of the
+## x-axis are set to these values and the mode is set to @qcode{"manual"}.
 ##
-## The current mode for calculation of the x-axis can be returned with a
-## call @code{xlim ("mode")}, and can be either "auto" or "manual".  The
-## current plotting mode can be set by passing either "auto" or "manual"
-## as the argument.
+## The current plotting mode can be changed by using either @qcode{"auto"}
+## or @qcode{"manual"} as the argument.
 ##
-## If passed a handle as the first argument, then operate on this handle
-## rather than the current axes handle.
-## @seealso{ylim, zlim, set, get, gca}
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+## @seealso{ylim, zlim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
-  ret = __axes_limits__ ("xlim", varargin{:});
+  ret = __axis_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
 
 %!demo
diff --git a/scripts/plot/ylabel.m b/scripts/plot/appearance/ylabel.m
rename from scripts/plot/ylabel.m
rename to scripts/plot/appearance/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/appearance/ylabel.m
@@ -13,45 +13,63 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ylabel (@var{string})
-## @deftypefnx {Function File} {} ylabel (@var{h}, @var{string})
+## @deftypefnx {Function File} {} ylabel (@var{string}, @var{property}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} ylabel (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ylabel (@dots{})
-## @seealso{xlabel}
+## Specify the string used to label the y-axis of the current axis.
+##
+## If @var{hax} is specified then label the axis defined by @var{hax}.
+##
+## An optional list of @var{property}/@var{value} pairs can be used to change
+## the properties of the created text label.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
+## @seealso{xlabel, zlabel, datetick, title, text}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = ylabel (varargin)
+function h = ylabel (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("ylabel", varargin{:});
-
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  tmp = __axis_label__ (h, "ylabel", varargin{:},
-                        "color", get (h, "ycolor"));
+  htmp = __axis_label__ (hax, "ylabel", varargin{1},
+                         "color", get (hax, "ycolor"), varargin{2:end});
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   y = ylabel ("ylabel_string");
+%!   y = ylabel ("ylabel_string", "color", "r");
 %!   assert (get (gca, "ylabel"), y);
 %!   assert (get (y, "type"), "text");
 %!   assert (get (y, "visible"), "on");
 %!   assert (get (y, "string"), "ylabel_string");
+%!   assert (get (y, "color"), [1 0 0]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/ylim.m b/scripts/plot/appearance/ylim.m
rename from scripts/plot/ylim.m
rename to scripts/plot/appearance/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/appearance/ylim.m
@@ -12,38 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{yl} =} ylim ()
-## @deftypefnx {Function File} {} ylim (@var{yl})
-## @deftypefnx {Function File} {@var{m} =} ylim ("mode")
-## @deftypefnx {Function File} {} ylim (@var{m})
-## @deftypefnx {Function File} {} ylim (@var{h}, @dots{})
-## Get or set the limits of the y-axis of the current plot.  Called without
-## arguments @code{ylim} returns the y-axis limits of the current plot.
-## If passed a two element vector @var{yl}, the limits of the y-axis are set
-## to this value.
+## @deftypefn  {Function File} {@var{ylimits} =} ylim ()
+## @deftypefnx {Function File} {@var{xmode} =} ylim ("mode")
+## @deftypefnx {Function File} {} ylim ([@var{y_lo} @var{y_hi}])
+## @deftypefnx {Function File} {} ylim ("auto")
+## @deftypefnx {Function File} {} ylim ("manual")
+## @deftypefnx {Function File} {} ylim (@var{hax}, @dots{})
+## Query or set the limits of the y-axis for the current plot.
 ##
-## The current mode for calculation of the y-axis can be returned with a
-## call @code{ylim ("mode")}, and can be either "auto" or "manual".  The
-## current plotting mode can be set by passing either "auto" or "manual"
-## as the argument.
+## Called without arguments @code{ylim} returns the y-axis limits of the
+## current plot.  With the input query @qcode{"mode"}, return the current
+## y-limit calculation mode which is either @qcode{"auto"} or @qcode{"manual"}.
+##
+## If passed a 2-element vector [@var{y_lo} @var{y_hi}], the limits of the
+## y-axis are set to these values and the mode is set to @qcode{"manual"}.
 ##
-## If passed a handle as the first argument, then operate on this handle
-## rather than the current axes handle.
-## @seealso{xlim, zlim, set, get, gca}
+## The current plotting mode can be changed by using either @qcode{"auto"}
+## or @qcode{"manual"} as the argument.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+## @seealso{xlim, zlim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
-  ret = __axes_limits__ ("ylim", varargin{:});
+  ret = __axis_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
 
 %!demo
diff --git a/scripts/plot/zlabel.m b/scripts/plot/appearance/zlabel.m
rename from scripts/plot/zlabel.m
rename to scripts/plot/appearance/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/appearance/zlabel.m
@@ -13,58 +13,72 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} zlabel (@var{string})
-## @deftypefnx {Function File} {} zlabel (@var{h}, @var{string})
+## @deftypefnx {Function File} {} zlabel (@var{string}, @var{property}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} zlabel (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} zlabel (@dots{})
-## @seealso{xlabel}
+## Specify the string used to label the z-axis of the current axis.
+##
+## An optional list of @var{property}/@var{value} pairs can be used to change
+## the properties of the created text label.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created text
+## object.
+## @seealso{xlabel, ylabel, datetick, title, text}
 ## @end deftypefn
-
 ## Author: jwe
 
-function retval = zlabel (varargin)
+function h = zlabel (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("zlabel", varargin{:});
-
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
   if (rem (nargin, 2) != 1)
     print_usage ();
   endif
 
-  tmp = __axis_label__ (h, "zlabel", varargin{:},
-                        "color", get (h, "zcolor"));
+  htmp = __axis_label__ (hax, "zlabel", varargin{1},
+                         "color", get (hax, "zcolor"), varargin{2:end});
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   z = zlabel ("zlabel_string");
+%!   z = zlabel ("zlabel_string", "color", "r");
 %!   assert (get (gca, "zlabel"), z);
 %!   assert (get (z, "type"), "text");
 %!   assert (get (z, "visible"), "off");
 %!   assert (get (z, "string"), "zlabel_string");
+%!   assert (get (z, "color"), [1 0 0]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! plot3 (0, 0, 0);
 %! unwind_protect
 %!   z = zlabel ("zlabel_string");
 %!   assert (get (gca, "zlabel"), z);
 %!   assert (get (z, "type"), "text");
-%!   assert (get (z, "visible"), "off");
 %!   assert (get (z, "string"), "zlabel_string");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/zlim.m b/scripts/plot/appearance/zlim.m
rename from scripts/plot/zlim.m
rename to scripts/plot/appearance/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/appearance/zlim.m
@@ -12,38 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{zl} =} zlim ()
-## @deftypefnx {Function File} {} zlim (@var{zl})
-## @deftypefnx {Function File} {@var{m} =} zlim ("mode")
-## @deftypefnx {Function File} {} zlim (@var{m})
-## @deftypefnx {Function File} {} zlim (@var{h}, @dots{})
-## Get or set the limits of the z-axis of the current plot.  Called without
-## arguments @code{zlim} returns the z-axis limits of the current plot.
-## If passed a two element vector @var{zl}, the limits of the z-axis are set
-## to this value.
+## @deftypefn  {Function File} {@var{zlimits} =} zlim ()
+## @deftypefnx {Function File} {@var{xmode} =} zlim ("mode")
+## @deftypefnx {Function File} {} zlim ([@var{z_lo} @var{z_hi}])
+## @deftypefnx {Function File} {} zlim ("auto")
+## @deftypefnx {Function File} {} zlim ("manual")
+## @deftypefnx {Function File} {} zlim (@var{hax}, @dots{})
+## Query or set the limits of the z-axis for the current plot.
 ##
-## The current mode for calculation of the z-axis can be returned with a
-## call @code{zlim ("mode")}, and can be either "auto" or "manual".  The
-## current plotting mode can be set by passing either "auto" or "manual"
-## as the argument.
+## Called without arguments @code{zlim} returns the z-axis limits of the
+## current plot.  With the input query @qcode{"mode"}, return the current
+## z-limit calculation mode which is either @qcode{"auto"} or @qcode{"manual"}.
+##
+## If passed a 2-element vector [@var{z_lo} @var{z_hi}], the limits of the
+## x-axis are set to these values and the mode is set to @qcode{"manual"}.
 ##
-## If passed a handle as the first argument, then operate on this handle
-## rather than the current axes handle.
-## @seealso{xlim, ylim, set, get, gca}
+## The current plotting mode can be changed by using either @qcode{"auto"}
+## or @qcode{"manual"} as the argument.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+## @seealso{xlim, ylim, axis, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
-  ret = __axes_limits__ ("zlim", varargin{:});
+  ret = __axis_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
 
 %!demo
diff --git a/scripts/plot/area.m b/scripts/plot/draw/area.m
rename from scripts/plot/area.m
rename to scripts/plot/draw/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/draw/area.m
@@ -17,167 +17,186 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} area (@var{y})
 ## @deftypefnx {Function File} {} area (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} area (@dots{}, @var{lvl})
 ## @deftypefnx {Function File} {} area (@dots{}, @var{prop}, @var{val}, @dots{})
-## @deftypefnx {Function File} {} area (@var{h}, @dots{})
+## @deftypefnx {Function File} {} area (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} area (@dots{})
-## Area plot of the columns of @var{y}.  This shows the
-## contributions of each column value to the row sum.  It is functionally
-## similar to @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the
-## area under the curve is shaded.
+## Area plot of the columns of @var{y}.
+##
+## This plot shows the contributions of each column value to the row sum.  It
+## is functionally similar to @code{plot (@var{x}, cumsum (@var{y}, 2))},
+## except that the area under the curve is shaded.
 ##
-## If the @var{x} argument is omitted it defaults to 
-## @code{1 : rows (@var{y})}.  A value @var{lvl} can be defined that determines
-## where the base level of the shading under the curve should be defined.  The
-## default level is 0.
+## If the @var{x} argument is omitted it defaults to @code{1:rows (@var{y})}.
+## A value @var{lvl} can be defined that determines where the base level of
+## the shading under the curve should be defined.  The default level is 0.
 ##
-## Additional arguments to the @code{area} function are passed directly to
-## @code{patch}.  
+## Additional property/value pairs are passed directly to the underlying patch
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
-## object representing the area patch objects.  The "BaseValue" property
+## object comprising the area patch objects.  The @qcode{"BaseValue"} property
 ## of the hggroup can be used to adjust the level where shading begins.
 ##
 ## Example: Verify identity sin^2 + cos^2 = 1
 ##
 ## @example
 ## @group
 ## t = linspace (0, 2*pi, 100)';
 ## y = [sin(t).^2, cos(t).^2)];
 ## area (t, y);
-## legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
+## legend ("sin^2", "cos^2", "location", "NorthEastOutside");
 ## @end group
 ## @end example
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
 
   if (nargin == 0)
     print_usage ();
   endif
 
-  idx = 1;
   x = y = [];
   bv = 0;
-  args = {};
-  ## Check for (X) or (X,Y) arguments and possible base value.
-  if (nargin >= idx && ismatrix (varargin{idx}))
-    y = varargin{idx};
-    idx++;
-    if (nargin >= idx)
-      if (isscalar (varargin{idx}))
-        bv = varargin{idx};
-        idx++;
-      elseif (ismatrix (varargin{idx}))
-        x = y;
-        y = varargin{idx};
-        idx++;
-        if (nargin >= idx && isscalar (varargin{idx}))
-          bv = varargin{idx};
-          idx++;
-        endif
+
+  num_numeric = find (cellfun ("isclass", varargin, "char"), 1) - 1;
+  if (isempty (num_numeric))
+    num_numeric = nargin;     
+  endif
+
+  switch (num_numeric)
+    case 1
+      y = varargin{1};
+    case 2
+      if (isscalar (varargin{2})) 
+        y = varargin{1};
+        bv = varargin{2};
+      else
+        x = varargin{1};
+        y = varargin{2};
       endif
-    endif
-  else
-    print_usage ();
+    case 3
+      x = varargin{1};
+      y = varargin{2};
+      bv = varargin{3};
+    otherwise
+      print_usage ();
+  endswitch
+
+  if (! isreal (x) || ! isreal (y))
+    error ("area: X and Y must be real vectors or matrices");
   endif
-  ## Check for additional args.
-  if (nargin >= idx)
-    args = {varargin{idx:end}};
+  if (! isreal (bv) || ! isscalar (bv))
+    error ("area: LVL must be a real scalar");
   endif
-  newplot ();
+
   if (isvector (y))
     y = y(:);
   endif
   if (isempty (x))
     x = repmat ([1:rows(y)]', 1, columns (y));
   elseif (isvector (x))
-    x = repmat (x(:),  1, columns (y));
+    x = repmat (x(:), 1, columns (y));
   endif
 
-  oldax = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (ax);
-    tmp = __area__ (ax, x, y, bv, args{:});
+    hax = newplot (hax);
+    htmp = __area__ (hax, x, y, bv, varargin{num_numeric+1:end});
   unwind_protect_cleanup
-    axes (oldax);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 function retval = __area__ (ax, x, y, bv, varargin)
 
   y0 = bv * ones (1, rows (y));
   y0 = zeros (1, rows (y));
   retval = [];
   for i = 1: columns (y);
+
+    lc = __next_line_color__ ();
+
+    ## Must occur after __next_line_color__ in order to work correctly.
     hg = hggroup ();
     retval = [retval; hg];
     args = __add_datasource__ ("area", hg, {"x", "y"}, varargin{:});
 
-    x1 = x(:, 1).';
-    y1 = y (:, i).';
+    x1 = x(:, 1)';
+    y1 = y(:, i)';
     addproperty ("xdata", hg, "data", x1);
     addproperty ("ydata", hg, "data", y1);
 
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
 
     if (i == 1)
       h = patch (ax, [x1(1), x1, fliplr(x1)], [bv, y1, bv*ones(1, length(y1))],
-                 __next_line_color__ (), "parent", hg);
+                     lc, "parent", hg);
     else
       y1 = y0 + y1;
       h = patch (ax, [x1(1), x1, fliplr(x1)], [y0(1), y1, fliplr(y0)],
-                 __next_line_color__ (), "parent", hg);
+                     lc, "parent", hg);
     endif
 
     y0 = y1;
 
     addproperty ("basevalue", hg, "data", bv);
     addlistener (hg, "basevalue", @move_baseline);
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
-    addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
+    addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
     addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
-    addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
+    addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
 
     addlistener (hg, "edgecolor", @update_props);
-    addlistener (hg, "linewidth", @update_props);
+    addlistener (hg, "facecolor", @update_props);
     addlistener (hg, "linestyle", @update_props);
-    addlistener (hg, "facecolor", @update_props);
+    addlistener (hg, "linewidth", @update_props);
 
     addproperty ("areagroup", hg, "data");
     set (retval, "areagroup", retval);
 
+    ## Matlab property, although Octave does not implement it.
+    addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
     if (! isempty (args))
       set (hg, args{:});
     endif
   endfor
 
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
   set (kids, "edgecolor", get (h, "edgecolor"),
-             "linewidth", get (h, "linewidth"),
+             "facecolor", get (h, "facecolor"),
              "linestyle", get (h, "linestyle"),
-             "facecolor", get (h, "facecolor"));
+             "linewidth", get (h, "linewidth"));
 endfunction
 
 function move_baseline (h, d)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
@@ -217,28 +236,48 @@ function update_data (h, d)
     endif
 
     y0 = y1;
   endfor
 endfunction
 
 
 %!demo
-%! # Verify identity sin^2 + cos^2 = 1
+%! ## Verify identity sin^2 + cos^2 = 1
 %! clf;
 %! t = linspace (0, 2*pi, 100)';
 %! y = [sin(t).^2, cos(t).^2];
 %! area (t, y);
+%! axis tight
 %! legend ('sin^2', 'cos^2', 'location', 'NorthEastOutside');  
+%! title ('area() plot');
 
 %!demo
-%! # Show effects of setting BaseValue
+%! ## Show effects of setting BaseValue
 %! clf;
 %! x = [-2:0.1:2]';
 %! y = x.^2 - 1;
 %! subplot (1, 2, 1)
 %! area (x, y);
 %! title ({'Parabola y = x^2 -1';'BaseValue = 0'});
 %! subplot (1, 2, 2)
 %! h = area (x, y);
 %! set (h, 'basevalue', -1);
 %! title ({'Parabola y = x^2 -1';'BaseValue = -1'});
 
+%!demo
+%! clf;
+%! x = 0:10;
+%! y = rand (size (x));
+%! h = area (x, y);
+%! set (h, 'ydata', sort (get (h, 'ydata')))
+%! title ('area() plot of sorted data');
+
+%% Test input validation
+%!error area ()
+%!error area (1,2,3,4)
+%!error <X and Y must be real vectors or matrices> area ({1})
+%!error <X and Y must be real vectors or matrices> area (1+i)
+%!error <X and Y must be real vectors or matrices> area (1:2, {1, 2})
+%!error <X and Y must be real vectors or matrices> area (1:2, [1 1+i])
+%!error <LVL must be a real scalar> area (1, i)
+%!error <LVL must be a real scalar> area (1, 2, ones (2,2))
+
diff --git a/scripts/plot/bar.m b/scripts/plot/draw/bar.m
rename from scripts/plot/bar.m
rename to scripts/plot/draw/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/draw/bar.m
@@ -12,99 +12,129 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} bar (@var{x}, @var{y})
-## @deftypefnx {Function File} {} bar (@var{y})
-## @deftypefnx {Function File} {} bar (@var{x}, @var{y}, @var{w})
-## @deftypefnx {Function File} {} bar (@var{x}, @var{y}, @var{w}, @var{style})
-## @deftypefnx {Function File} {} bar (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} bar (@dots{}, @var{prop}, @var{val})
-## Produce a bar graph from two vectors of x-y data.
+## @deftypefn  {Function File} {} bar (@var{y})
+## @deftypefnx {Function File} {} bar (@var{x}, @var{y})
+## @deftypefnx {Function File} {} bar (@dots{}, @var{w})
+## @deftypefnx {Function File} {} bar (@dots{}, @var{style})
+## @deftypefnx {Function File} {} bar (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} bar (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} bar (@dots{}, @var{prop}, @var{val}, @dots{})
+## Produce a bar graph from two vectors of X-Y data.
 ##
-## If only one argument is given, @var{y}, it is taken as a vector of y-values
-## and the x coordinates are taken to be the indices of the elements.
+## If only one argument is given, @var{y}, it is taken as a vector of Y values
+## and the X coordinates are the range @code{1:numel (@var{y})}.
 ##
-## The default width of 0.8 for the bars can be changed using @var{w}.
+## The optional input @var{w} controls the width of the bars.  A value of
+## 1.0 will cause each bar to exactly touch any adjacent bars.
+## The default width is 0.8.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
-## argument, which can take the values @code{"grouped"} (the default),
-## or @code{"stacked"}.
+## argument which can take the following values:
 ##
-## Passing the optional input handle @var{h} will draw the resulting plot
-## in the specified handle.
+## @table @asis
+## @item @qcode{"grouped"} (default) 
+## Side-by-side bars with a gap between bars and centered over the X-coordinate.
+## 
+## @item  @qcode{"stacked"}
+## Bars are stacked so that each X value has a single bar composed of
+## multiple segments.
+##
+## @item @qcode{"hist"}
+## Side-by-side bars with no gap between bars and centered over the
+## X-coordinate.
 ##
-## The optional return value @var{h} is a handle to the created "bar series"
-## object with one handle per column of the variable @var{y}.  This
-## series allows common elements of the group of bar series objects to
-## be changed in a single bar series and the same properties are changed
-## in the other "bar series".  For example,
+## @item @qcode{"histc"}
+## Side-by-side bars with no gap between bars and left-aligned to the
+## X-coordinate.
+## @end table
+##
+## Optional property/value pairs are passed directly to the underlying patch
+## objects.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a vector of handles to the created
+## "bar series" hggroups with one handle per column of the variable @var{y}.
+## This series makes it possible to change a common element in one bar series
+## object and have the change reflected in the other "bar series".
+## For example,
 ##
 ## @example
 ## @group
 ## h = bar (rand (5, 10));
 ## set (h(1), "basevalue", 0.5);
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## changes the position on the base of all of the bar series.
 ##
-## The bar graph's appearance may be modified by specifying property/value
-## pairs.  The following example modifies the face and edge colors.
+## The following example modifies the face and edge colors using
+## property/value pairs.
 ##
 ## @example
-## bar (randn (1, 100), "facecolor", "r", "edgecolor", "b")
+## bar (randn (1, 100), "facecolor", "r", "edgecolor", "b");
 ## @end example
 ##
 ## @noindent
 ## The color of the bars is taken from the figure's colormap, such that
 ##
 ## @example
 ## @group
 ## bar (rand (10, 3));
 ## colormap (summer (64));
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## will change the colors used for the bars.  The color of bars can also be set
-## manually using the "facecolor" property as shown below.
+## manually using the @qcode{"facecolor"} property as shown below.
 ##
 ## @example
 ## @group
 ## h = bar (rand (10, 3));
 ## set (h(1), "facecolor", "r")
 ## set (h(2), "facecolor", "g")
 ## set (h(3), "facecolor", "b")
 ## @end group
 ## @end example
 ##
-## @seealso{barh, plot}
+## @seealso{barh, hist, pie, plot, patch}
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = bar (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (true, "bar", varargin{:});
 endfunction
 
 
 %!demo
 %! clf;
-%! y = rand (10, 1);
-%! bar (y);
+%! y = rand (11, 1);
+%! h = bar (y);
+%! set (h, 'ydata', sort (rand (11, 1)));
+%! title ('bar() graph');
 
 %!demo
 %! clf;
 %! h = bar (rand (5, 3));
-%! set (h(1), 'facecolor', 'r')
-%! set (h(2), 'facecolor', 'g')
-%! set (h(3), 'facecolor', 'b')
+%! set (h(1), 'facecolor', 'r');
+%! set (h(2), 'facecolor', 'g');
+%! set (h(3), 'facecolor', 'b');
+%! title ('bar() graph w/multiple bars');
 
+%!demo
+%! clf;
+%! h = bar (rand (5, 3), 'stacked');
+%! title ('bar() graph with stacked style');
+
diff --git a/scripts/plot/barh.m b/scripts/plot/draw/barh.m
rename from scripts/plot/barh.m
rename to scripts/plot/draw/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/draw/barh.m
@@ -12,60 +12,80 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} barh (@var{x}, @var{y})
-## @deftypefnx {Function File} {} barh (@var{y})
-## @deftypefnx {Function File} {} barh (@var{x}, @var{y}, @var{w})
-## @deftypefnx {Function File} {} barh (@var{x}, @var{y}, @var{w}, @var{style})
-## @deftypefnx {Function File} {} barh (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} barh (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} barh (@dots{})
-## Produce a horizontal bar graph from two vectors of x-y data.
+## @deftypefn  {Function File} {} barh (@var{y})
+## @deftypefnx {Function File} {} barh (@var{x}, @var{y})
+## @deftypefnx {Function File} {} barh (@dots{}, @var{w})
+## @deftypefnx {Function File} {} barh (@dots{}, @var{style})
+## @deftypefnx {Function File} {} barh (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} barh (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} barh (@dots{}, @var{prop}, @var{val}, @dots{})
+## Produce a horizontal bar graph from two vectors of X-Y data.
 ##
-## If only one argument is given, it is taken as a vector of y-values
-## and the x coordinates are taken to be the indices of the elements.
+## If only one argument is given, it is taken as a vector of Y values
+## and the X coordinates are the range @code{1:numel (@var{y})}.
 ##
-## The default width of 0.8 for the bars can be changed using @var{w}.
+## The optional input @var{w} controls the width of the bars.  A value of
+## 1.0 will cause each bar to exactly touch any adjacent bars.
+## The default width is 0.8.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
-## argument, which can take the values @code{"grouped"} (the default),
-## or @code{"stacked"}.
+## argument which can take the following values:
 ##
-## Passing the optional input handle @var{h} will draw the resulting plot
-## in the specified handle.
+## @table @asis
+## @item @qcode{"grouped"} (default) 
+## Side-by-side bars with a gap between bars and centered over the Y-coordinate.
 ## 
-## Properties of the patch graphics object can be changed using
-## @var{prop}, @var{val} pairs.
+## @item  @qcode{"stacked"}
+## Bars are stacked so that each Y value has a single bar composed of
+## multiple segments.
+##
+## @item @qcode{"hist"}
+## Side-by-side bars with no gap between bars and centered over the
+## Y-coordinate.
 ##
+## @item @qcode{"histc"}
+## Side-by-side bars with no gap between bars and left-aligned to the
+## Y-coordinate.
+## @end table
+##
+## Optional property/value pairs are passed directly to the underlying patch
+## objects.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+## 
 ## The optional return value @var{h} is a graphics handle to the created
-## bar series object.  See @code{bar} for a description of the use of the
-## bar series.
-## @seealso{bar, plot}
+## bar series hggroup.  For a description of the use of the
+## bar series, @pxref{XREFbar,,bar}.
+## @seealso{bar, hist, pie, plot, patch}
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = barh (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (false, "barh", varargin{:});
 endfunction
 
 
 %!demo
 %! clf;
 %! x = rand (10, 1);
 %! barh (x);
+%! title ('barh() graph')
 
 %!demo
 %! clf;
 %! h = barh (rand (5, 3));
 %! set (h(1), 'facecolor', 'r')
 %! set (h(2), 'facecolor', 'g')
 %! set (h(3), 'facecolor', 'b')
+%! title ('barh() graph w/multiple bars')
 
diff --git a/scripts/plot/colorbar.m b/scripts/plot/draw/colorbar.m
rename from scripts/plot/colorbar.m
rename to scripts/plot/draw/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -12,266 +12,386 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} colorbar (@var{s})
-## @deftypefnx {Function File} {} colorbar ("peer", @var{h}, @dots{})
-## Add a colorbar to the current axes.  Valid values for @var{s} are
+## @deftypefn  {Command} {} colorbar
+## @deftypefnx {Function File} {} colorbar (@var{loc})
+## @deftypefnx {Function File} {} colorbar (@var{delete_option})
+## @deftypefnx {Function File} {} colorbar (@var{hcb}, @dots{})
+## @deftypefnx {Function File} {} colorbar (@var{hax}, @dots{})
+## @deftypefnx {Function File} {} colorbar (@dots{}, "peer", @var{hax}, @dots{})
+## @deftypefnx {Function File} {} colorbar (@dots{}, "location", @var{loc}, @dots{})
+## @deftypefnx {Function File} {} colorbar (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} colorbar (@dots{})
+## Add a colorbar to the current axes.
+##
+## A colorbar displays the current colormap along with numerical rulings
+## so that the color scale can be interpreted.
+##
+## The optional input @var{loc} determines the location of the colorbar.
+## Valid values for @var{loc} are
 ##
 ## @table @asis
-## @item "EastOutside"
+## @item @qcode{"EastOutside"}
 ## Place the colorbar outside the plot to the right.  This is the default.
 ##
-## @item "East"
+## @item @qcode{"East"}
 ## Place the colorbar inside the plot to the right.
 ##
-## @item "WestOutside"
+## @item @qcode{"WestOutside"}
 ## Place the colorbar outside the plot to the left.
 ##
-## @item "West"
+## @item @qcode{"West"}
 ## Place the colorbar inside the plot to the left.
 ##
-## @item "NorthOutside"
+## @item @qcode{"NorthOutside"}
 ## Place the colorbar above the plot.
 ##
-## @item "North"
+## @item @qcode{"North"}
 ## Place the colorbar at the top of the plot.
 ##
-## @item "SouthOutside"
+## @item @qcode{"SouthOutside"}
 ## Place the colorbar under the plot.
 ##
-## @item "South"
+## @item @qcode{"South"}
 ## Place the colorbar at the bottom of the plot.
-##
-## @item "Off", "None"
-## Remove any existing colorbar from the plot.
 ## @end table
 ##
-## If the argument "peer" is given, then the following argument is treated
-## as the axes handle on which to add the colorbar.
+## To remove a colorbar from a plot use any one of the following keywords for
+## the @var{delete_option}: @qcode{"delete"}, @qcode{"hide"}, @qcode{"off"}.
+## 
+## If the argument @qcode{"peer"} is given, then the following argument is
+## treated as the axes handle in which to add the colorbar.  Alternatively,
+## If the first argument @var{hax} is an axes handle, then the colorbar is
+## added to this axis, rather than the current axes returned by @code{gca}.
+##
+## If the first argument @var{hcb} is a handle to a colorbar object, then
+## operate on this colorbar directly.
+##
+## Additional property/value pairs are passed directly to the underlying axes
+## object.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## colorbar object.
+##
+## Implementation Note: A colorbar is created as an additional axes to the
+## current figure with the @qcode{"tag"} property set to @qcode{"colorbar"}. 
+## The created axes object has the extra property @qcode{"location"} which
+## controls the positioning of the colorbar.
+## @seealso{colormap}
 ## @end deftypefn
 
 function h = colorbar (varargin)
-  ax = [];
-  loc = "eastoutside";
+
+  [hcb, varargin, nargin] = __plt_get_axis_arg__ ("colorbar", varargin{:});
+
+  if (hcb && ! strcmp (get (hcb, "tag"), "colorbar"))
+    ax = hcb;
+    hcb = [];
+  else
+    ax = [];
+  endif
+  loc = "";
   args = {};
   deleting = false;
 
   i = 1;
   while (i <= nargin)
-    arg = varargin {i++};
+    arg = varargin{i++};
     if (ischar (arg))
-      if (strcmpi (arg, "peer"))
-        if (i > nargin)
-          error ("colorbar: missing axes handle after \"peer\"");
-        else
-          ax = varargin{i++};
-          if (!isscalar (ax) || ! ishandle (ax)
-              || ! strcmp (get (ax, "type"), "axes"))
-            error ("colorbar: expecting an axes handle following \"peer\"");
+      switch (tolower (arg))
+        case "peer"
+          if (i > nargin)
+            error ('colorbar: missing axes handle after "peer"');
+          else
+            ax = varargin{i++};
+            if (! isscalar (ax) && ! isaxes (ax))
+              error ('colorbar: expecting an axes handle following "peer"');
+            endif
           endif
-        endif
-      elseif (strcmpi (arg, "north") || strcmpi (arg, "south")
-              || strcmpi (arg, "east") || strcmpi (arg, "west")
-              || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
-              || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
-        loc = tolower (arg);
-      elseif (strcmpi (arg, "location") && i <= nargin)
-        loc = tolower (varargin{i++});
-      elseif (strcmpi (arg, "off") || strcmpi (arg, "none"))
-        deleting = true;
-      else
-        args{end+1} = arg;
-      endif
+        case {"north", "south", "east", "west",
+              "northoutside", "southoutside", "eastoutside", "westoutside"}
+          loc = tolower (arg);
+        case "location"
+          if (i > nargin)
+            error ('colorbar: missing value after "location"');
+          else
+            loc = tolower (varargin{i++});
+          endif
+        case {"delete", "hide", "off", "none"}
+          deleting = true;
+        otherwise
+          args{end+1} = arg;
+      endswitch
     else
       args{end+1} = arg;
     endif
   endwhile
 
+  ## Handle changes to existing colorbar
+  if (! isempty (hcb))
+    if (deleting)
+      delete (hcb);
+      if (nargout > 0)
+        h = hcb;
+      endif
+      return;
+    else
+      ## FIXME: No listener on location property so have to re-create
+      ##        colorbar whenever an option changes.
+      ##        re-instate this code if listener is developed.
+      # if (! isempty (loc))
+      #   set (hcb, "location", loc);
+      # endif
+      # if (! isempty (args))
+      #   set (hcb, args{:});
+      # endif
+      ax = get (get (hcb, "parent"), "currrentaxes");      
+    endif
+  endif
+    
+  if (isempty (loc))
+    loc = "eastoutside";
+  endif
   if (isempty (ax))
     ax = gca ();
   endif
 
   showhiddenhandles = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "on");
     cax = findobj (get (ax, "parent"), "tag", "colorbar", "type", "axes", "axes", ax);
     if (! isempty (cax))
       delete (cax);
     endif
   unwind_protect_cleanup
     set (0, "showhiddenhandles", showhiddenhandles);
   end_unwind_protect
 
   if (! deleting)
-    ## FIXME - Matlab does not require the "position" property to be active.
-    ##         Is there a way to determine the plotbox position for the
-    ##         gnuplot graphics toolkit with the outerposition is active?
+    ## FIXME: Matlab does not require the "position" property to be active.
+    ##        Is there a way to determine the plotbox position for the
+    ##        gnuplot graphics toolkit with the outerposition is active?
     set (ax, "activepositionproperty", "position");
     obj = get (ax);
-    obj.__my_handle__ = ax;
+    obj.__cbar_hax__ = ax;
     position = obj.position;
-    clen = rows (get (get (ax, "parent"), "colormap"));
+    ## FIXME: Should this be ancestor to accommodate hggroups?
+    hpar = get (ax, "parent");  
+    clen = rows (get (hpar, "colormap"));
     cext = get (ax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
     set (ax, "position", pos);
 
-    cax = __go_axes__ (get (ax, "parent"), "tag", "colorbar",
-                       "handlevisibility", "on",
-                       "activepositionproperty", "position",
-                       "position", cpos);
+    cax = __go_axes__ (hpar, "tag", "colorbar",
+                             "handlevisibility", "on",
+                             "activepositionproperty", "position",
+                             "position", cpos);
     addproperty ("location", cax, "radio",
                  "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
                  loc);
     addproperty ("axes", cax, "handle", ax);
 
     if (vertical)
       hi = image (cax, [0,1], [cmin, cmax], [1 : clen]');
       if (mirror)
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-             "ylim", cext, "ylimmode", "manual",
-             "yaxislocation", "right", args{:});
+                  "ylim", cext, "ylimmode", "manual",
+                  "yaxislocation", "right", args{:});
       else
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-             "ylim", cext, "ylimmode", "manual",
-             "yaxislocation", "left", args{:});
+                  "ylim", cext, "ylimmode", "manual",
+                  "yaxislocation", "left", args{:});
       endif
     else
       hi = image (cax, [cmin, cmax], [0,1], [1 : clen]);
       if (mirror)
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-             "xlim", cext, "xlimmode", "manual",
-             "xaxislocation", "top", args{:});
+                  "xlim", cext, "xlimmode", "manual",
+                  "xaxislocation", "top", args{:});
       else
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-             "xlim", cext, "xlimmode", "manual",
-             "xaxislocation", "bottom", args{:});
+                  "xlim", cext, "xlimmode", "manual",
+                  "xaxislocation", "bottom", args{:});
       endif
     endif
 
-    ctext = text (0, 0, "", "tag", "colorbar","visible", "off",
-                  "handlevisibility", "off", "xliminclude", "off",
-                  "yliminclude", "off", "zliminclude", "off",
+    ## Dummy object placed in axis to delete colorbar when axis is deleted.
+    ctext = text (0, 0, "", "tag", "colorbar",
+                  "visible", "off", "handlevisibility", "off",
+                  "xliminclude", "off", "yliminclude", "off",
+                  "zliminclude", "off",
                   "deletefcn", {@deletecolorbar, cax, obj});
 
     set (cax, "deletefcn", {@resetaxis, ax, obj});
 
+    addlistener (hpar, "colormap", {@update_colorbar_cmap, hi, vertical, clen});
     addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical});
+    addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj});
+    addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj});
-    addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj});
-    addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj});
     addlistener (ax, "position", {@update_colorbar_axis, cax, obj});
 
   endif
 
   if (nargout > 0)
     h = cax;
   endif
+
 endfunction
 
 function deletecolorbar (h, d, hc, orig_props)
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
-  if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
-      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
+  if (isaxes (hc)
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
     if (!isempty (ancestor (h, "axes"))
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
-      set (ancestor (h, "axes"), "position", orig_props.position, ...
-                            "outerposition", orig_props.outerposition, ...
-                    "activepositionproperty", orig_props.activepositionproperty);
+      ax = ancestor (h, "axes");
+      units = get (ax, "units");
+      set (ax, "units", orig_props.units);
+      set (ancestor (h, "axes"), "position", orig_props.position,
+                            "outerposition", orig_props.outerposition,
+                   "activepositionproperty", orig_props.activepositionproperty);
+      set (ax, "units", units);
     endif
   endif
 endfunction
 
 function resetaxis (cax, d, ax, orig_props)
-  if (ishandle (ax) && strcmp (get (ax, "type"), "axes"))
+  if (isaxes (ax))
+    ## FIXME: Probably don't want to delete everyone's listeners on colormap.
+    dellistener (get (ax, "parent"), "colormap");
+    dellistener (ax, "clim");
+    dellistener (ax, "dataaspectratio");
+    dellistener (ax, "dataaspectratiomode");
+    dellistener (ax, "plotboxaspectratio");
+    dellistener (ax, "plotboxaspectratiomode");
     dellistener (ax, "position");
+
     units = get (ax, "units");
     set (ax, "units", orig_props.units);
-    set (ax, "position", orig_props.position, ...
-             "outerposition", orig_props.outerposition, ...
+    set (ax, "position", orig_props.position,
+             "outerposition", orig_props.outerposition,
              "activepositionproperty", orig_props.activepositionproperty);
     set (ax, "units", units);
   endif
 endfunction
 
-function update_colorbar_clim (h, d, hi, vert)
-  if (ishandle (h) && strcmp (get (h, "type"), "image")
-      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
-    clen = rows (get (get (h, "parent"), "colormap"));
-    cext = get (h, "clim");
+function update_colorbar_clim (hax, d, hi, vert)
+  if (isaxes (hax)
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
+    clen = rows (get (get (hax, "parent"), "colormap"));
+    cext = get (hax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
+    hiax = get (hi, "parent");
     if (vert)
       set (hi, "ydata", [cmin, cmax]);
-      set (get (hi, "parent"), "ylim", cext);
+      set (hiax, "ylim", cext);
     else
       set (hi, "xdata", [cmin, cmax]);
-      set (get (hi, "parent"), "xlim", cext);
+      set (hiax, "xlim", cext);
+    endif
+
+    ## FIXME: Setting xlim or ylim from within a listener callback
+    ##        causes the axis to change size rather than change limits.
+    ##        Workaround it by jiggling the position property which forces
+    ##        a redraw of the axis object.
+    ##
+    ## Debug Example:
+    ## Uncomment the line below.
+    ##   keyboard;
+    ## Now run the the following code.
+    ##   clf; colorbar (); contour (peaks ())
+    ## Once the keyboard command has been hit in the debugger try
+    ##   set (hiax, "ylim", [0 0.5]) 
+    pos = get (hiax, "position");
+    pos(1) += eps;
+    set (hiax, "position", pos);
+    pos(1) -= eps;
+    set (hiax, "position", pos);
+  endif
+endfunction
+
+function update_colorbar_cmap (hf, d, hi, vert, init_sz)
+  persistent sz = init_sz;
+
+  if (ishandle (hf) && strcmp (get (hf, "type"), "figure")
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
+    clen = rows (get (hf, "colormap"));
+    if (clen != sz)
+      if (vert)
+        set (hi, "cdata", [1:clen]');
+      else
+        set (hi, "cdata", [1:clen]);
+      endif
+      sz = clen;
+      ## Also update limits on axis or there will be white gaps
+      update_colorbar_clim (get (hi, "parent"), d, hi, vert);
     endif
   endif
 endfunction
 
 function update_colorbar_axis (h, d, cax, orig_props)
-
-  if (ishandle (cax) && strcmp (get (cax, "type"), "axes")
+  if (isaxes (cax)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
-    obj.__my_handle__ = h;
+    obj.__cbar_hax__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
     if (vertical)
       if (mirror)
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-             "yaxislocation", "right", "position", cpos);
+                  "yaxislocation", "right", "position", cpos);
       else
         set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-             "yaxislocation", "left", "position", cpos);
+                  "yaxislocation", "left", "position", cpos);
       endif
     else
       if (mirror)
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-             "xaxislocation", "top", "position", cpos);
+                  "xaxislocation", "top", "position", cpos);
       else
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-             "xaxislocation", "bottom", "position", cpos);
+                  "xaxislocation", "bottom", "position", cpos);
       endif
     endif
 
   endif
 endfunction
 
 function [pos, cpos, vertical, mirr] = __position_colorbox__ (cbox, obj, cf)
 
   ## This will always represent the position prior to adding the colorbar.
   pos = obj.position;
   sz = pos(3:4);
 
-  if (strcmpi (obj.plotboxaspectratiomode, "manual")
-      || strcmpi (obj.dataaspectratiomode, "manual"))
+  if (strcmp (obj.plotboxaspectratiomode, "manual")
+      || strcmp (obj.dataaspectratiomode, "manual"))
     if (isempty (strfind (cbox, "outside")))
       scale = 1.0;
     else
       scale = 0.8;
     endif
     if (isempty (strfind (cbox, "east")) && isempty (strfind (cbox, "west")))
       scale = [1, scale];
     else
@@ -335,18 +455,18 @@ function [pos, cpos, vertical, mirr] = _
       origin = pos(1:2) + [0.05, 0.05] .* sz + off;
       sz = sz .* [0.06, 1.0] .* 0.9;
       mirr = true;
       vertical = true;
   endswitch
 
   cpos = [origin, sz];
 
-  if (strcmpi (obj.plotboxaspectratiomode, "manual")
-      || strcmpi (obj.dataaspectratiomode, "manual"))
+  if (strcmp (obj.plotboxaspectratiomode, "manual")
+      || strcmp (obj.dataaspectratiomode, "manual"))
     obj.position = pos;
     actual_pos = __actual_axis_position__ (obj);
     if (strfind (cbox, "outside"))
       scale = 1.0;
     else
       scale = 0.9;
     endif
     if (sz(1) > sz(2))
@@ -366,16 +486,17 @@ endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
 %! colorbar ();
+%! title ('colorbar() example');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
 %! colorbar ('westoutside');
 
diff --git a/scripts/plot/comet.m b/scripts/plot/draw/comet.m
rename from scripts/plot/comet.m
rename to scripts/plot/draw/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/draw/comet.m
@@ -24,27 +24,27 @@
 ## Produce a simple comet style animation along the trajectory provided by
 ## the input coordinate vectors (@var{x}, @var{y}).  If @var{x} is not
 ## specified it defaults to the indices of @var{y}.
 ##
 ## The speed of the comet may be controlled by @var{p}, which represents the
 ## time each point is displayed before moving to the next one.  The default for
 ## @var{p} is 0.1 seconds.
 ##
-## If @var{hax} is specified the animation is produced in that axis rather than
-## the current axis.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ## @seealso{comet3}
 ## @end deftypefn
 
 ## Author: Ben Abbott bpabbott@mac.com
 ## Created: 2008-09-21
 
 function comet (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("comet", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("comet", varargin{:});
 
   if (nargin == 0)
     print_usage ();
   elseif (nargin == 1)
     y = varargin{1};
     x = 1:numel (y);
     p = 0.1;
   elseif (nargin == 2)
@@ -52,38 +52,53 @@ function comet (varargin)
     y = varargin{2};
     p = 0.1;
   elseif (nargin == 3)
     x = varargin{1};
     y = varargin{2};
     p = varargin{3};
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    theaxis = [min(x), max(x), min(y), max(y)];
+    hax = newplot (hax);
+    limits = [min(x), max(x), min(y), max(y)];
     num = numel (y);
     dn = round (num/10);
-    for n = 1:(num+dn);
+
+    hl = plot (x(1), y(1), "color", "r", "marker", "none",
+               x(1), y(1), "color", "g", "marker", "none",
+               x(1), y(1), "color", "b", "marker", "o");
+    axis (limits);  # set manual limits to speed up plotting
+
+    for n = 2:(num+dn);
       m = n - dn;
       m = max ([m, 1]);
       k = min ([n, num]);
-      h = plot (x(1:m), y(1:m), "r", x(m:k), y(m:k), "g", x(k), y(k), "ob");
-      axis (theaxis);
+      set (hl(1), "xdata", x(1:m), "ydata", y(1:m));
+      set (hl(2), "xdata", x(m:k), "ydata", y(m:k));
+      set (hl(3), "xdata", x(k),   "ydata", y(k));
       drawnow ();
       pause (p);
     endfor
+
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
+%! title ('comet() animation');
+%! hold on;
 %! t = 0:.1:2*pi;
 %! x = cos (2*t) .* (cos (t).^2);
 %! y = sin (2*t) .* (sin (t).^2);
-%! comet (x, y);
+%! comet (x, y, 0.05);
+%! hold off;
 
diff --git a/scripts/plot/comet3.m b/scripts/plot/draw/comet3.m
rename from scripts/plot/comet3.m
rename to scripts/plot/draw/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/draw/comet3.m
@@ -24,27 +24,27 @@
 ## Produce a simple comet style animation along the trajectory provided by
 ## the input coordinate vectors (@var{x}, @var{y}, @var{z}).  If only @var{z}
 ## is specified then @var{x}, @var{y} default to the indices of @var{z}.
 ##
 ## The speed of the comet may be controlled by @var{p}, which represents the
 ## time each point is displayed before moving to the next one.  The default for
 ## @var{p} is 0.1 seconds.
 ##
-## If @var{hax} is specified the animation is produced in that axis rather than
-## the current axis.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ## @seealso{comet}
 ## @end deftypefn
 
 ## Author: jwe
 ## Created: 2010-12-17
 
 function comet3 (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("comet3", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("comet3", varargin{:});
 
   if (nargin == 0 || nargin == 2 || nargin > 4)
     print_usage ();
   elseif (nargin == 1)
     z = varargin{1};
     x = y = 1:numel (z);
     p = 0.1;
   elseif (nargin == 3)
@@ -54,37 +54,50 @@ function comet3 (varargin)
     p = 0.1;
   elseif (nargin == 4)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     p = varargin{4};
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    theaxis = [min(x), max(x), min(y), max(y), min(z), max(z)];
+    hax = newplot (hax);
+    limits = [min(x), max(x), min(y), max(y), min(z), max(z)];
     num = numel (y);
     dn = round (num/10);
-    for n = 1:(num+dn);
+
+    hl = plot3 (x(1), y(1), z(1), "color", "r", "marker", "none",
+                x(1), y(1), z(1), "color", "g", "marker", "none",
+                x(1), y(1), z(1), "color", "b", "marker", "o");
+    axis (limits);  # set manual limits to speed up plotting
+
+    for n = 2:(num+dn);
       m = n - dn;
       m = max ([m, 1]);
       k = min ([n, num]);
-      h = plot3 (x(1:m), y(1:m), z(1:m), "r", x(m:k), y(m:k), z(m:k), "g",
-                 x(k), y(k), z(k), "ob");
-      axis (theaxis);
+      set (hl(1), "xdata", x(1:m), "ydata", y(1:m), "zdata", z(1:m));
+      set (hl(2), "xdata", x(m:k), "ydata", y(m:k), "zdata", z(m:k));
+      set (hl(3), "xdata", x(k)  , "ydata", y(k)  , "zdata", z(k));
       drawnow ();
       pause (p);
     endfor
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
+%! title ('comet3() animation');
+%! view (3); hold on;
 %! t = 0:pi/20:5*pi;
-%! comet3 (cos (t), sin (t), t, 0.01);
+%! comet3 (cos (t), sin (t), t, 0.05);
+%! hold off;
 
diff --git a/scripts/plot/compass.m b/scripts/plot/draw/compass.m
rename from scripts/plot/compass.m
rename to scripts/plot/draw/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/draw/compass.m
@@ -15,106 +15,123 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} compass (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} compass (@var{z})
 ## @deftypefnx {Function File} {} compass (@dots{}, @var{style})
-## @deftypefnx {Function File} {} compass (@var{h}, @dots{})
+## @deftypefnx {Function File} {} compass (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} compass (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
-## from the origin of a polar plot.  If a single complex argument @var{z} is
-## given, then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag
-## (@var{z})}.
+## from the origin of a polar plot.
+##
+## The arrow representing each vector has one end at the origin and the tip at
+## [@var{u}(i), @var{v}(i)].  If a single complex argument @var{z} is given,
+## then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
+## of the same format as the @code{plot} command.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
 ## compass (eig (a));
 ## @end group
 ## @end example
 ##
-## @seealso{polar, quiver, feather, plot}
+## @seealso{polar, feather, quiver, rose, plot}
 ## @end deftypefn
 
-function retval = compass (varargin)
+function h = compass (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("compass", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("compass", varargin{:});
 
-  arrowsize = 0.25;
+  if (nargin == 0 || nargin > 3)
+    print_usage ();
+  endif
 
-  if (nargin == 0)
-    print_usage ();
-  elseif (nargin == 1 || (nargin == 2 && ! isnumeric (varargin{2})))
-    ioff = 2;
+  if (nargin == 1 || (nargin == 2 && ! isnumeric (varargin{2})))
     z = varargin{1}(:).';
     u = real (z);
     v = imag (z);
-  elseif (nargin > 1 && isnumeric (varargin{2}))
-    ioff = 3;
+    have_line_spec = (nargin == 2);
+  elseif (nargin >= 2 && isnumeric (varargin{2}))
     u = varargin{1}(:).';
     v = varargin{2}(:).';
+    have_line_spec = (nargin == 3);
+  else
+    print_usage ();
   endif
 
-  line_spec = "b-";
-  have_line_spec = false;
-  while (ioff <= nargin)
-    arg = varargin{ioff++};
-    if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
-      [linespec, valid] = __pltopt__ ("compass", arg, false);
+  arrowsize = 0.20;
+  line_spec = "-b";
+
+  if (have_line_spec)
+    arg = varargin{end};
+    if (ischar (arg) || iscellstr (arg))
+      [~, valid] = __pltopt__ ("compass", arg, false);
       if (valid)
         line_spec = arg;
-        have_line_spec = true;
-        break;
       else
-        error ("compass: invalid linespec");
+        error ("compass: invalid linestyle STYLE");
       endif
     else
-      error ("compass: unrecognized argument");
+      error ("compass: invalid linestyle STYLE");
     endif
-  endwhile
+  endif
 
-  ## Matlab draws compass plots, with the arrow head as one continous
-  ## line, and each arrow separately. This is completely different than
-  ## quiver and quite ugly.
+  ## Matlab draws compass plots with the arrow head as one continous line,
+  ## and each arrow separately.  This is completely different from quiver
+  ## and quite ugly.
   n = length (u);
   xend = u;
   xtmp = u .* (1 - arrowsize);
   yend = v;
   ytmp = v .* (1 - arrowsize);
-  x = [zeros(1, n); xend; xtmp  - v * arrowsize / 3; xend; ...
+  x = [zeros(1, n); xend; xtmp - v * arrowsize / 3; xend; ...
        xtmp + v * arrowsize / 3];
-  y = [zeros(1, n); yend; ytmp  + u * arrowsize / 3; yend; ...
+  y = [zeros(1, n); yend; ytmp + u * arrowsize / 3; yend; ...
        ytmp - u * arrowsize / 3];
   [r, p] = cart2pol (x, y);
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    hlist = polar (h, r, p, line_spec);
+    hax = newplot (hax);
+    hlist = polar (r, p, line_spec);
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = hlist;
+    h = hlist;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! randn_9x1_data = [-2.555884; 0.394974; -0.191871; -1.147024; 1.355425; -0.437335; -0.014370; -0.941312; 1.240300];
 %! randn_1x9_data = [1.42934, -1.10821, -1.70404, 0.63357, -0.68337, -1.19771, -0.96502, -1.12810, 0.22457];
 %! a = toeplitz ([1;randn_9x1_data], [1,randn_1x9_data]);
 %! compass (eig (a));
 
+%% Test input validation
+%!error compass ()
+%!error compass (1,2,3,4)
+%!error compass (1, "-r", 2)
+%!error <invalid linestyle STYLE> compass (1, "abc")
+%!error <invalid linestyle STYLE> compass (1, {1})
+
diff --git a/scripts/plot/contour.m b/scripts/plot/draw/contour.m
rename from scripts/plot/contour.m
rename to scripts/plot/draw/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/draw/contour.m
@@ -17,80 +17,124 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} contour (@var{z})
 ## @deftypefnx {Function File} {} contour (@var{z}, @var{vn})
 ## @deftypefnx {Function File} {} contour (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} contour (@var{x}, @var{y}, @var{z}, @var{vn})
 ## @deftypefnx {Function File} {} contour (@dots{}, @var{style})
-## @deftypefnx {Function File} {} contour (@var{h}, @dots{})
+## @deftypefnx {Function File} {} contour (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{c}, @var{h}] =} contour (@dots{})
+## Create a 2-D contour plot.
+##
 ## Plot level curves (contour lines) of the matrix @var{z}, using the
 ## contour matrix @var{c} computed by @code{contourc} from the same
-## arguments; see the latter for their interpretation.  The set of
-## contour levels, @var{c}, is only returned if requested.  For example:
+## arguments; see the latter for their interpretation.
+##
+## The appearance of contour lines can be defined with a line style @var{style}
+## in the same manner as @code{plot}.  Only line style and color are used;
+## Any markers defined by @var{style} are ignored.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional output @var{c} are the contour levels in @code{contourc} format.
+##
+## The optional return value @var{h} is a graphics handle to the hggroup
+## comprising the contour lines.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## x = 0:2;
 ## y = x;
 ## z = x' * y;
 ## contour (x, y, z, 2:3)
 ## @end group
 ## @end example
 ##
-## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
-## Any markers defined by @var{style} are ignored.
+## @seealso{ezcontour, contourc, contourf, contour3, clabel, meshc, surfc, caxis, colormap, plot}
 ##
-## The optional input and output argument @var{h} allows an axis handle to
-## be passed to @code{contour} and the handles to the contour objects to be
-## returned.
-## @seealso{contourc, contourf, contour3, patch, plot}
 ## @end deftypefn
 
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [c, h] = contour (varargin)
 
-  [xh, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (xh);
-    newplot ();
-    [ctmp, htmp] = __contour__ (xh, "none", varargin{:});
+    hax = newplot (hax);
+    
+    [ctmp, htmp] = __contour__ (hax, "none", varargin{:});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = peaks ();
 %! contour (x, y, z);
+%! title ({'contour() plot (isolines of constant Z)'; 'Z = peaks()'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
 %! Z = sin (2*theta) .* (1-r);
 %! contour (X, Y, abs (Z), 10);
+%! title ({'contour() plot'; 'polar fcn: Z = sin (2*theta) * (1-r)'});
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! x = linspace (-2, 2);
-%! [x, y] = meshgrid (x);
-%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2 + 1);
-%! contourf (x, y, z, [0.4, 0.4]);
-%! title ('The hole should be filled with the background color');
+%! z = peaks ();
+%! contour (z, [0 0]);
+%! title ({'contour() plot with single isoline at Z == 0'; 'Z = peaks()'});
 
+%!test
+%! hf = figure ("visible", "off");
+%! clf (hf);
+%! unwind_protect
+%!   [x, y, z] = peaks ();
+%!   [c, h] = contour (x, y, z);
+%!   levellist = -6:6;
+%!   set (h, "levellist", levellist);
+%!   assert (get (h, "levellist"), levellist)
+%!   assert (get (h, "levellistmode"), "manual")
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure ("visible", "off");
+%! clf (hf);
+%! unwind_protect
+%!   [x, y, z] = peaks ();
+%!   [c, h] = contour (x, y, z);
+%!   levelstep = 3;
+%!   set (h, "levelstep", levelstep);
+%!   assert (get (h, "levelstep"), levelstep)
+%!   assert (get (h, "levelstepmode"), "manual")
+%!   assert (get (h, "levellist"), -6:levelstep:6)
+%!   assert (get (h, "levellistmode"), "auto")
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/contour3.m b/scripts/plot/draw/contour3.m
rename from scripts/plot/contour3.m
rename to scripts/plot/draw/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/draw/contour3.m
@@ -17,72 +17,90 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} contour3 (@var{z})
 ## @deftypefnx {Function File} {} contour3 (@var{z}, @var{vn})
 ## @deftypefnx {Function File} {} contour3 (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} contour3 (@var{x}, @var{y}, @var{z}, @var{vn})
 ## @deftypefnx {Function File} {} contour3 (@dots{}, @var{style})
-## @deftypefnx {Function File} {} contour3 (@var{h}, @dots{})
+## @deftypefnx {Function File} {} contour3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{c}, @var{h}] =} contour3 (@dots{})
-## Plot level curves (contour lines) of the matrix @var{z}, using the
-## contour matrix @var{c} computed by @code{contourc} from the same
-## arguments; see the latter for their interpretation.  The contours are
-## plotted at the Z level corresponding to their contour.  The set of
-## contour levels, @var{c}, is only returned if requested.  For example:
+## Create a 3-D contour plot.
+##
+## @code{contour3} plots level curves (contour lines) of the matrix @var{z}
+## at a Z level corresponding to each contour.  This is in contrast to
+## @code{contour} which plots all of the contour lines at the same Z level
+## and produces a 2-D plot.
+##
+## The level curves are taken from the contour matrix @var{c} computed by
+## @code{contourc} for the same arguments; see the latter for their
+## interpretation.
+##
+## The appearance of contour lines can be defined with a line style @var{style}
+## in the same manner as @code{plot}.  Only line style and color are used;
+## Any markers defined by @var{style} are ignored.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional output @var{c} are the contour levels in @code{contourc} format.
+##
+## The optional return value @var{h} is a graphics handle to the hggroup
+## comprising the contour lines.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## contour3 (peaks (19));
+## colormap cool;
 ## hold on;
-## surface (peaks (19), "facecolor", "none", "EdgeColor", "black");
-## colormap hot;
+## surf (peaks (19), "facecolor", "none", "edgecolor", "black");
 ## @end group
 ## @end example
 ##
-## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
-## Any markers defined by @var{style} are ignored.
-##
-## The optional input and output argument @var{h} allows an axis handle to
-## be passed to @code{contour} and the handles to the contour objects to be
-## returned.
-## @seealso{contourc, contour, contourf, patch, plot}
+## @seealso{contour, contourc, contourf, clabel, meshc, surfc, caxis, colormap, plot}
 ## @end deftypefn
 
 function [c, h] = contour3 (varargin)
 
-  [xh, varargin, nargin] = __plt_get_axis_arg__ ("contour3", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("contour3", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (xh);
-    newplot ();
-    [ctmp, htmp] = __contour__ (xh, "auto", varargin{:});
+    hax = newplot (hax);
+    
+    [ctmp, htmp] = __contour__ (hax, "auto", varargin{:});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (! ishold ())
-    set (xh, "view", [-37.5, 30],
-         "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    set (hax, "view", [-37.5, 30], "box", "off",
+              "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! contour3 (peaks (19));
+%! colormap (cool (64));
+%! surf (peaks (19), 'facecolor', 'none', 'edgecolor', [0.85 0.85 0.85]);
 %! hold on;
-%! surface (peaks (19), 'facecolor', 'none', 'edgecolor', 'black');
-%! colormap (hot (64));
+%! contour3 (peaks (19));
+%! hold off;
 %! axis tight;
 %! zlim auto;
-%! box off;
-%! hold off;
+%! view (315, 17);
+%! title ({'contour3 of peaks() function', 'gray surf() shows peaks function'});
 
diff --git a/scripts/plot/contourc.m b/scripts/plot/draw/contourc.m
rename from scripts/plot/contourc.m
rename to scripts/plot/draw/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/draw/contourc.m
@@ -16,141 +16,156 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{c}, @var{lev}] =} contourc (@var{z})
 ## @deftypefnx {Function File} {[@var{c}, @var{lev}] =} contourc (@var{z}, @var{vn})
 ## @deftypefnx {Function File} {[@var{c}, @var{lev}] =} contourc (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {[@var{c}, @var{lev}] =} contourc (@var{x}, @var{y}, @var{z}, @var{vn})
-## Compute isolines (contour lines) of the matrix @var{z}.
-## Parameters @var{x}, @var{y}, and @var{vn} are optional.
+## Compute contour lines (isolines of constant Z value).
+##
+## The matrix @var{z} contains height values above the rectangular grid
+## determined by @var{x} and @var{y}.  If only a single input @var{z} is
+## provided then @var{x} is taken to be @code{1:rows (@var{z})} and @var{y} is
+## taken to be @code{1:columns (@var{z})}.
 ##
-## The return value @var{lev} is a vector of the contour levels.
+## The optional input @var{vn} is either a scalar denoting the number of
+## contour lines to compute or a vector containing the Z values where lines
+## will be computed.  When @var{vn} is a vector the number of contour lines
+## is @code{numel (@var{vn})}.  However, to compute a single contour line
+## at a given value use @code{@var{vn} = [val, val]}.  If @var{vn} is omitted
+## it defaults to 10.
+##
 ## The return value @var{c} is a 2x@var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
 ## @group
 ## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, ...
 ##      len1, y1, y2, @dots{}, lenn, y1, y2, @dots{}]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
 ##
-## If @var{x} and @var{y} are omitted they are taken as the row/column
-## indices of @var{z}.  @var{vn} is either a scalar denoting the number of
-## contour lines to compute or a vector containing the values of the lines.
-## If only one value is desired, set @code{@var{vn} = [val, val]};
-## If @var{vn} is omitted it defaults to 10.
+## The optional return value @var{lev} is a vector with the Z values of
+## of the contour levels.
 ##
-## For example:
+## Example:
 ##
 ## @example
 ## @group
 ## x = 0:2;
 ## y = x;
 ## z = x' * y;
 ## contourc (x, y, z, 2:3)
 ##    @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
 ##         2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
 ## @end group
 ## @end example
-## @seealso{contour, contourf, contour3}
+## @seealso{contour, contourf, contour3, clabel}
 ## @end deftypefn
 
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
-function [cout, lev] = contourc (varargin)
+function [c, lev] = contourc (varargin)
+
+  if (nargin < 1 || nargin > 4)
+    print_usage ();
+  endif
 
   if (nargin == 1)
-    vn = 10;
     z = varargin{1};
-    [nr, nc] = size (z);
-    x = 1:nc;
-    y = 1:nr;
+    x = 1:columns (z);
+    y = 1:rows (z);
+    vn = 10;
   elseif (nargin == 2)
+    z = varargin{1};
+    x = 1:columns (z);
+    y = 1:rows (z);
     vn = varargin{2};
-    z = varargin{1};
-    [nr, nc] = size (z);
-    x = 1:nc;
-    y = 1:nr;
   elseif (nargin == 3)
-    vn = 10;
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
+    vn = 10;
   elseif (nargin == 4)
-    vn = varargin{4};
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
-  else
-    print_usage ();
+    vn = varargin{4};
   endif
 
-  if (!ismatrix (z) || isvector (z) || isscalar (z))
-    error ("contourc: Z argument must be a matrix");
+  if (! ismatrix (z) || ! ismatrix (x) || ! ismatrix (y))
+    error ("contourc: X, Y, and Z must be matrices");
   endif
 
   if (isscalar (vn))
     vv = linspace (min (z(:)), max (z(:)), vn+2)(2:end-1);
   else
     vv = unique (sort (vn));
   endif
 
   if (isvector (x) && isvector (y))
-    c = __contourc__ (x(:)', y(:)', z, vv);
+    cdat = __contourc__ (x(:)', y(:)', z, vv);
+  elseif (! any (bsxfun (@minus, x, x(1,:))(:))
+          && ! any (bsxfun (@minus, y, y(:,1))(:)))
+    ## x,y are uniform grid (such as from meshgrid)
+    cdat = __contourc__ (x(1,:), y(:,1)', z, vv);
   else
-    ## Indexes x,y for the purpose of __contourc__.
-    ii = 1:columns (z);
-    jj = 1:rows (z);
+    ## Data is sampled over non-uniform mesh.
+    ## Algorithm calculates contours for uniform grid
+    ## and then interpolates values back to the non-uniform mesh.
 
-    ## Now call __contourc__ for the real work...
-    c = __contourc__ (ii, jj, z, vv);
+    ## Uniform grid for __contourc__.
+    [nr, nc] = size (z);
+    ii = 1:nc;
+    jj = 1:nr;
 
-    ## Map the contour lines from index space (i,j) back
-    ## to the original grid (x,y)
+    cdat = __contourc__ (ii, jj, z, vv);
+
+    ## Map the contour lines from index space (i,j)
+    ## back to the original grid (x,y)
     i = 1;
 
-    while (i < columns (c))
-      clen = c(2, i);
-      ind = i + [1 : clen];
+    while (i < columns (cdat))
+      clen = cdat(2, i);
+      idx = i + (1:clen);
 
-      ci = c(1, ind);
-      cj = c(2,ind);
+      ci = cdat(1, idx);
+      cj = cdat(2, idx);
 
-      ## due to rounding errors some elements of ci and cj
-      ## can fall out of the range of ii and jj and interp2 would
-      ## return NA for those values.
+      ## Due to rounding errors, some elements of ci and cj
+      ## can fall out of the range of ii and jj and
+      ## interp2 would return NA for those values.
       ## The permitted range is enforced here:
 
-      ci = max (ci, 1); ci = min (ci, columns (z));
-      cj = max (cj, 1); cj = min (cj, rows (z));
+      ci = max (ci, 1); ci = min (ci, nc);
+      cj = max (cj, 1); cj = min (cj, nr);
 
-      c(1, ind) = interp2 (ii, jj, x, ci, cj);
-      c(2, ind) = interp2 (ii, jj, y, ci, cj);
+      cdat(1, idx) = interp2 (ii, jj, x, ci, cj);
+      cdat(2, idx) = interp2 (ii, jj, y, ci, cj);
 
-      i = i + clen + 1;
+      i += clen + 1;
     endwhile
   endif
 
   if (nargout > 0)
-    cout = c;
+    c = cdat;
     lev = vv;
   endif
 
 endfunction
 
 
 %!test
 %! x = 0:2;
 %! y = x;
 %! z = x' * y;
-%! [c_actual, lev_actual]= contourc (x, y, z, 2:3);
-%! c_expected = [2, 1, 1, 2, 2, 3, 1.5, 2; 4, 2, 2, 1, 1, 2, 2, 1.5];
-%! lev_expected = [2 3];
-%! assert (c_actual, c_expected, eps);
-%! assert (lev_actual, lev_expected, eps);
+%! c_exp = [2, 1, 1, 2, 2, 3, 1.5, 2; 4, 2, 2, 1, 1, 2, 2, 1.5];
+%! lev_exp = [2 3];
+%! [c_obs, lev_obs] = contourc (x, y, z, 2:3);
+%! assert (c_obs, c_exp, eps);
+%! assert (lev_obs, lev_exp, eps);
 
diff --git a/scripts/plot/contourf.m b/scripts/plot/draw/contourf.m
rename from scripts/plot/contourf.m
rename to scripts/plot/draw/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/draw/contourf.m
@@ -13,90 +13,102 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} contourf (@var{x}, @var{y}, @var{z}, @var{lvl})
-## @deftypefnx {Function File} {} contourf (@var{x}, @var{y}, @var{z}, @var{n})
+## @deftypefn  {Function File} {} contourf (@var{z})
+## @deftypefnx {Function File} {} contourf (@var{z}, @var{vn})
 ## @deftypefnx {Function File} {} contourf (@var{x}, @var{y}, @var{z})
-## @deftypefnx {Function File} {} contourf (@var{z}, @var{n})
-## @deftypefnx {Function File} {} contourf (@var{z}, @var{lvl})
-## @deftypefnx {Function File} {} contourf (@var{z})
-## @deftypefnx {Function File} {} contourf (@dots{}, @var{prop}, @var{val})
+## @deftypefnx {Function File} {} contourf (@var{x}, @var{y}, @var{z}, @var{vn})
+## @deftypefnx {Function File} {} contourf (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} contourf (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{c}, @var{h}] =} contourf (@dots{})
-## Compute and plot filled contours of the matrix @var{z}.
-## Parameters @var{x}, @var{y} and @var{n} or @var{lvl} are optional.
+## Create a 2-D contour plot with filled intervals.
 ##
-## If @var{x} and @var{y} are omitted they are taken as the row/column
-## indices of @var{z}.  @var{n} is a scalar denoting the number of contour
-## lines to compute.  Alternatively @var{lvl} is a vector containing the
-## contour levels.  If only one value (e.g., lvl0) is desired, set
-## @var{lvl} to [lvl0, lvl0].  If both @var{n} or @var{lvl} are omitted
-## a default value of 10 contour levels is assumed.
+## Plot level curves (contour lines) of the matrix @var{z} and fill the region
+## between lines with colors from the current colormap.
+##
+## The level curves are taken from the contour matrix @var{c} computed by
+## @code{contourc} for the same arguments; see the latter for their
+## interpretation.
 ##
-## The appearance of the plot can be customized by passing
-## property/value pairs to the function. 
+## The appearance of contour lines can be defined with a line style @var{style}
+## in the same manner as @code{plot}.  Only line style and color are used;
+## Any markers defined by @var{style} are ignored.
 ##
-## If provided, the filled contours are added to the axes object
-## @var{hax} instead of the current axis.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## The return value @var{c} is a 2xn matrix containing the contour lines
-## as described in the documentation on the @code{contourc} function.
+## The optional output @var{c} are the contour levels in @code{contourc} format.
 ##
-## The return value @var{h} is handle-vector to the patch objects creating
-## the filled contours.
+## The optional return value @var{h} is a graphics handle to the hggroup
+## comprising the contour lines.
 ##
-## The following example plots filled contours of the @code{peaks}
-## function.
+## The following example plots filled contours of the @code{peaks} function.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (50);
 ## contourf (x, y, z, -7:9)
 ## @end group
 ## @end example
-## @seealso{contourc, contour, contour3, patch}
+## @seealso{ezcontourf, contour, contourc, contour3, clabel, meshc, surfc, caxis, colormap, plot}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [c, h] = contourf (varargin)
 
-  [xh, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (xh);
-    newplot ();
-    [ctmp, htmp] = __contour__ (xh, "none", "fill", "on",
-                                "linecolor", "black", varargin{:});
+    hax = newplot (hax);
+    
+    [ctmp, htmp] = __contour__ (hax, "none", "fill", "on",
+                                     "linecolor", "black", varargin{:});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = peaks (50);
 %! contourf (x, y, z, -7:9);
+%! title ({'contourf() plot (filled contour lines)'; 'Z = peaks()'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
 %! Z = sin (2*theta) .* (1-r);
 %! contourf (X, Y, abs (Z), 10);
+%! title ({'contourf() plot'; 'polar fcn: Z = sin (2*theta) * (1-r)'});
 
+%!demo
+%! clf;
+%! colormap ('default');
+%! x = linspace (-2, 2);
+%! [x, y] = meshgrid (x);
+%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2 + 1);
+%! contourf (x, y, z, [0.4, 0.4]);
+%! title ('Hole should be filled with the background color');
+
diff --git a/scripts/plot/cylinder.m b/scripts/plot/draw/cylinder.m
rename from scripts/plot/cylinder.m
rename to scripts/plot/draw/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/draw/cylinder.m
@@ -12,56 +12,59 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} cylinder
+## @deftypefn  {Command} {} cylinder
 ## @deftypefnx {Function File} {} cylinder (@var{r})
 ## @deftypefnx {Function File} {} cylinder (@var{r}, @var{n})
+## @deftypefnx {Function File} {} cylinder (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} cylinder (@dots{})
-## @deftypefnx {Function File} {} cylinder (@var{ax}, @dots{})
-## Generate three matrices in @code{meshgrid} format, such that
-## @code{surf (@var{x}, @var{y}, @var{z})} generates a unit cylinder.
-## The matrices are of size @code{@var{n}+1}-by-@code{@var{n}+1}.
-## @var{r} is a vector containing the radius along the z-axis.
-## If @var{n} or @var{r} are omitted then default values of 20 or [1 1]
-## are assumed.
+## Plot a 3-D unit cylinder.
+##
+## The optional input @var{r} is a vector specifying the radius along the
+## unit z-axis.  The default is [1 1] indicating radius 1 at @code{Z == 0}
+## and at @code{Z == 1}.
+##
+## The optional input @var{n} determines the number of faces around the
+## the circumference of the cylinder.  The default value is 20.
 ##
-## Called with no return arguments, @code{cylinder} calls directly
-## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle @var{ax}
-## is passed as the first argument, the surface is plotted to this set
-## of axes.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## Examples:
+## If outputs are requested @code{cylinder} returns three matrices in
+## @code{meshgrid} format, such that @code{surf (@var{x}, @var{y}, @var{z})}
+## generates a unit cylinder.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## [x, y, z] = cylinder (10:-1:0, 50);
 ## surf (x, y, z);
 ## title ("a cone");
 ## @end group
 ## @end example
-## @seealso{sphere}
+## @seealso{ellipsoid, rectangle, sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
-  [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder",
-                                            varargin{:});
+  [hax, args, nargs] = __plt_get_axis_arg__ ("cylinder", varargin{:});
 
   if (nargs == 0)
+    r = [1, 1];
     n = 20;
-    r = [1, 1];
   elseif (nargs == 1)
+    r = args{1};
     n = 20;
-    r = args{1};
   elseif (nargs == 2)
     r = args{1};
     n = args{2};
   else
     print_usage ();
   endif
 
   if (length (r) < 2)
@@ -75,21 +78,32 @@ function [xx, yy, zz] = cylinder (vararg
   r = r(idx);
   [x, y] = pol2cart (phi, r);
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
-    surf (ax, x, y, z);
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
+    unwind_protect
+      hax = newplot (hax);
+      surf (x, y, z);
+    unwind_protect_cleanup
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
+    end_unwind_protect
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [x, y, z] = cylinder (10:-1:0,50);
+%! [x, y, z] = cylinder (10:-1:0, 50);
 %! surf (x, y, z);
-%! title ('a cone');
+%! title ('cylinder() with linearly shrinking radius produces a cone');
 
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/draw/ellipsoid.m
rename from scripts/plot/ellipsoid.m
rename to scripts/plot/draw/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/draw/ellipsoid.m
@@ -12,32 +12,42 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{x}, @var{y}, @var{z}] =} ellipsoid (@var{xc}, @var{yc}, @var{zc}, @var{xr}, @var{yr}, @var{zr}, @var{n})
-## @deftypefnx {Function File} {} ellipsoid (@var{h}, @dots{})
-## Generate three matrices in @code{meshgrid} format that define an
-## ellipsoid.  Called with no return arguments, @code{ellipsoid} calls
-## directly @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle
-## is passed as the first argument, the surface is plotted to this
-## set of axes.
-## @seealso{sphere}
+## @deftypefn  {Function File} {} ellipsoid (@var{xc}, @var{yc}, @var{zc}, @var{xr}, @var{yr}, @var{zr}, @var{n})
+## @deftypefnx {Function File} {} ellipsoid (@dots{}, @var{n})
+## @deftypefnx {Function File} {} ellipsoid (@var{hax}, @dots{})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} ellipsoid (@dots{})
+## Plot a 3-D ellipsoid.
+##
+## The inputs @var{xc}, @var{yc}, @var{zc} specify the center of the ellipsoid.
+## The inputs @var{xr}, @var{yr}, @var{zr} specify the semi-major axis lengths.
+##
+## The optional input @var{n} determines the number of faces around the
+## the circumference of the cylinder.  The default value is 20.
+## 
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## If outputs are requested @code{ellipsoid} returns three matrices in
+## @code{meshgrid} format, such that @code{surf (@var{x}, @var{y}, @var{z})}
+## generates the ellipsoid.
+## @seealso{cylinder, rectangle, sphere}
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 function [xx, yy, zz] = ellipsoid (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "ellipsoid",
-                                                varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("ellipsoid", varargin{:});
 
   if (nargin != 6 && nargin != 7)
     print_usage ();
   endif
 
   xc = varargin{1};
   yc = varargin{2};
   zc = varargin{3};
@@ -59,18 +69,31 @@ function [xx, yy, zz] = ellipsoid (varar
   y = yr .* cos (phi) .* sin (theta) + yc;
   z = zr .* sin (phi) + zc;
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
-    surf (h, x, y, z);
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
+    unwind_protect
+      hax = newplot (hax);
+    
+      surf (x, y, z);
+    unwind_protect_cleanup
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
+    end_unwind_protect
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! ellipsoid (0, 0, 1, 2, 3, 4, 20);
+%! title ('ellipsoid()');
 
diff --git a/scripts/plot/errorbar.m b/scripts/plot/draw/errorbar.m
rename from scripts/plot/errorbar.m
rename to scripts/plot/draw/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/draw/errorbar.m
@@ -13,19 +13,22 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} errorbar (@var{args})
-## @deftypefnx {Function File} {@var{h} =} errorbar (@var{args})
-## This function produces two-dimensional plots with errorbars.  Many
-## different combinations of arguments are possible.  The simplest form is
+## @deftypefnx {Function File} {} errorbar (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} errorbar (@dots{})
+## Create a 2-D with errorbars.
+##
+## Many different combinations of arguments are possible.  The simplest
+## form is
 ##
 ## @example
 ## errorbar (@var{y}, @var{ey})
 ## @end example
 ##
 ## @noindent
 ## where the first argument is taken as the set of @var{y} coordinates
 ## and the second argument @var{ey} is taken as the errors of the
@@ -71,16 +74,22 @@
 ##
 ## @item #~
 ## Set boxerrorbars plot style.
 ##
 ## @item #~>
 ## Set boxxyerrorbars plot style.
 ## @end table
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a handle to the hggroup object
+## representing the data plot and errorbars.
+##
 ## Examples:
 ##
 ## @example
 ## errorbar (@var{x}, @var{y}, @var{ex}, ">")
 ## @end example
 ##
 ## @noindent
 ## produces an xerrorbar plot of @var{y} versus @var{x} with @var{x}
@@ -105,73 +114,107 @@
 ##           @var{ly}, @var{uy}, "~>")
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## produces an xyerrorbar plot of @var{y} versus @var{x} in which
 ## @var{x} errorbars are drawn from @var{x}-@var{lx} to @var{x}+@var{ux}
 ## and @var{y} errorbars from @var{y}-@var{ly} to @var{y}+@var{uy}.
-## @seealso{semilogxerr, semilogyerr, loglogerr}
+## @seealso{semilogxerr, semilogyerr, loglogerr, plot}
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = errorbar (varargin)
+function h = errorbar (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("errorbar", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("errorbar", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    tmp = __errcomm__ ("errorbar", h, varargin{:});
+    htmp = __errcomm__ ("errorbar", hax, varargin{:});
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
-    if (nargout > 0)
-      retval = tmp;
-    endif
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  if (nargout > 0)
+    h = htmp;
+  endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! rand_1x11_data1 = [0.82712, 0.50325, 0.35613, 0.77089, 0.20474, 0.69160, 0.30858, 0.88225, 0.35187, 0.14168, 0.54270];
 %! rand_1x11_data2 = [0.506375, 0.330106, 0.017982, 0.859270, 0.140641, 0.327839, 0.275886, 0.162453, 0.807592, 0.318509, 0.921112];
 %! errorbar (0:10, rand_1x11_data1, 0.25*rand_1x11_data2);
+%! title ('errorbar() with Y errorbars');
 
 %!demo
 %! clf;
 %! rand_1x11_data3 = [0.423650, 0.142331, 0.213195, 0.129301, 0.975891, 0.012872, 0.635327, 0.338829, 0.764997, 0.401798, 0.551850];
 %! rand_1x11_data4 = [0.682566, 0.456342, 0.132390, 0.341292, 0.108633, 0.601553, 0.040455, 0.146665, 0.309187, 0.586291, 0.540149];
 %! errorbar (0:10, rand_1x11_data3, rand_1x11_data4, '>');
+%! title ('errorbar() with X errorbars');
 
 %!demo
 %! clf;
 %! x = 0:0.5:2*pi;
-%! err = x/100;
+%! err = x/30;
 %! y1 = sin (x);
 %! y2 = cos (x);
-%! hg = errorbar (x, y1, err, '~', x, y2, err, '>');
+%! errorbar (x, y1, err, '~', x, y2, err, '>');
+%! legend ("Y errbar", "X errbar");
+%! title ('errorbar() with 2 datasets');
+
+
+%!demo
+%! clf;
+%! x = 0:0.5:2*pi;
+%! err = x/30;
+%! y1 = sin (x);
+%! y2 = cos (x);
+%! errorbar (x, y1, err, err, '#r', x, y2, err, err, '#~');
+%! legend ("X errbox", "Y errbox");
+%! title ('errorbar() with error boxes');
 
 %!demo
 %! clf;
 %! x = 0:0.5:2*pi;
-%! err = x/100;
+%! err = x/30;
 %! y1 = sin (x);
 %! y2 = cos (x);
-%! hg = errorbar (x, y1, err, err, '#r', x, y2, err, err, '#~');
+%! errorbar (x, y1, err, err, err, err, '~>', ...
+%!           x, y2, err, err, err, err, '#~>-*');
+%! legend ("X-Y errbars", "X-Y errboxes");
+%! title ('errorbar() with X-Y errorbars and error boxes');
+
+## Invisible figure used for tests
+%!shared hf, hax
+%! hf = figure ("visible", "off");
+%! hax = axes;
 
-%!demo
-%! clf;
-%! x = 0:0.5:2*pi;
-%! err = x/100;
-%! y1 = sin (x);
-%! y2 = cos (x);
-%! hg = errorbar (x, y1, err, err, err, err, '~>', ...
-%!                x, y2, err, err, err, err, '#~>-*');
+%!error errorbar ()
+%!error errorbar (1)
+%!error <data argument 1 must be numeric> errorbar (hax, {1}, 2)
+%!error <data argument 2 must be numeric> errorbar (hax, 1, {2})
+%!error <size of argument 2 does not match others> errorbar (hax, 1, 1:2)
+%!error <size of argument 3 does not match others> errorbar (hax, 1, 2, 3:4)
+%!error <too many arguments to plot> errorbar (1,2,3,4,5,6,7)
 
+%!error <2 column errorplot is only valid for xerr> errorbar (1,2, "~>")
+%!error <6 columns only valid for xyerr and boxxy> errorbar (1,2,3,4,5,6, "~")
+%!error <error plot requires 2, 3, 4, or 6 arguments> errorbar (1,2,3,4,5)
+
+## Close figure used for testing
+%!test
+%! close (hf);
+
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/draw/ezcontour.m
rename from scripts/plot/ezcontour.m
rename to scripts/plot/draw/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/draw/ezcontour.m
@@ -15,53 +15,58 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontour (@var{f})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezcontour (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezcontour (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontour (@dots{})
 ##
-## Plot the contour lines of a function.  @var{f} is a string, inline function
-## or function handle with two arguments defining the function.  By default the
-## plot is over the domain @code{-2*pi < @var{x} < 2*pi} and @code{-2*pi <
-## @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the contour lines of a function.
+## 
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
+## Example:
+##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezcontourf, ezsurfc, ezmeshc}
+## @seealso{contour, ezcontourf, ezplot, ezmeshc, ezsurfc}
 ## @end deftypefn
 
-function retval = ezcontour (varargin)
+function h = ezcontour (varargin)
 
-  [h, needusage] = __ezplot__ ("contour", varargin{:});
+  [htmp, needusage] = __ezplot__ ("contour", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/draw/ezcontourf.m
rename from scripts/plot/ezcontourf.m
rename to scripts/plot/draw/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/draw/ezcontourf.m
@@ -15,53 +15,58 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontourf (@var{f})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezcontourf (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezcontourf (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontourf (@dots{})
 ##
-## Plot the filled contour lines of a function.  @var{f} is a string, inline
-## function or function handle with two arguments defining the function.  By
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the filled contour lines of a function.
+## 
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
+## Example:
+##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezcontour, ezsurfc, ezmeshc}
+## @seealso{contourf, ezcontour, ezplot, ezmeshc, ezsurfc}
 ## @end deftypefn
 
-function retval = ezcontourf (varargin)
+function h = ezcontourf (varargin)
 
-  [h, needusage] = __ezplot__ ("contourf", varargin{:});
+  [htmp, needusage] = __ezplot__ ("contourf", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/draw/ezmesh.m
rename from scripts/plot/ezmesh.m
rename to scripts/plot/draw/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/draw/ezmesh.m
@@ -17,72 +17,77 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmesh (@var{f})
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, "circ")
-## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezmesh (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
-## Plot the mesh defined by a function.  @var{f} is a string, inline
-## function or function handle with two arguments defining the function.  By
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the mesh defined by a function.
 ##
-## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
-##
-## @var{n} is a scalar defining the number of points to use in each dimension.
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument "circ" is given, then the function is plotted over a disk
-## centered on the middle of the domain @var{dom}.
+## If @var{dom} is a two element vector, it represents the minimum and maximum
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
+##
+## @var{n} is a scalar defining the number of points to use in each dimension.
+##
+## If the argument @qcode{"circ"} is given, then the function is plotted over
+## a disk centered on the middle of the domain @var{dom}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created 
 ## surface object.
 ##
+## Example 1: 2-argument function
+##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## An example of a parametrically defined function is
+## Example 2: parametrically defined function
 ##
 ## @example
 ## @group
 ## fx = @@(s,t) cos (s) .* cos (t);
 ## fy = @@(s,t) sin (s) .* cos (t);
 ## fz = @@(s,t) sin (t);
 ## ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezmeshc, ezsurf, ezsurfc}
+## @seealso{mesh, ezmeshc, ezplot, ezsurf, ezsurfc, hidden}
 ## @end deftypefn
 
-function retval = ezmesh (varargin)
+function h = ezmesh (varargin)
 
-  [h, needusage] = __ezplot__ ("mesh", varargin{:});
+  [htmp, needusage] = __ezplot__ ("mesh", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/draw/ezmeshc.m
rename from scripts/plot/ezmeshc.m
rename to scripts/plot/draw/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/draw/ezmeshc.m
@@ -17,62 +17,67 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmeshc (@var{f})
 ## @deftypefnx {Function File} {} ezmeshc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, "circ")
-## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezmeshc (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
-## Plot the mesh and contour lines defined by a function.  @var{f} is a string,
-## inline function or function handle with two arguments defining the function.
-## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the mesh and contour lines defined by a function.
 ##
-## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
-##
-## @var{n} is a scalar defining the number of points to use in each dimension.
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument "circ" is given, then the function is plotted over a disk
-## centered on the middle of the domain @var{dom}.
+## If @var{dom} is a two element vector, it represents the minimum and maximum
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
+##
+## @var{n} is a scalar defining the number of points to use in each dimension.
+##
+## If the argument @qcode{"circ"} is given, then the function is plotted over
+## a disk centered on the middle of the domain @var{dom}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## handle for the created mesh plot and a second handle for the created contour
 ## plot.
 ##
+## Example: 2-argument function
+##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezsurfc, ezsurf, ezmesh}
+## @seealso{meshc, ezmesh, ezplot, ezsurf, ezsurfc, hidden}
 ## @end deftypefn
 
-function retval = ezmeshc (varargin)
+function h = ezmeshc (varargin)
 
-  [h, needusage] = __ezplot__ ("meshc", varargin{:});
+  [htmp, needusage] = __ezplot__ ("meshc", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/ezplot.m b/scripts/plot/draw/ezplot.m
rename from scripts/plot/ezplot.m
rename to scripts/plot/draw/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/draw/ezplot.m
@@ -13,83 +13,96 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot (@var{f})
+## @deftypefnx {Function File} {} ezplot (@var{f2v})
 ## @deftypefnx {Function File} {} ezplot (@var{fx}, @var{fy})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezplot (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezplot (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot (@dots{})
 ##
-## Plot the curve defined by @var{f} in two dimensions.  The function
-## @var{f} may be a string, inline function or function handle and can
-## have either one or two variables.  If @var{f} has one variable, then
+## Plot the 2-D curve defined by the function @var{f}.
+##
+## The function @var{f} may be a string, inline function, or function handle
+## and can have either one or two variables.  If @var{f} has one variable, then
 ## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
 ## with 500 points.
 ##
-## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
-## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
-## < 2*pi} with 60 by 60 in the mesh.  For example:
+## If @var{f2v} is a function of two variables then the implicit function
+## @code{@var{f}(@var{x},@var{y}) = 0} is calculated over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
+##
+## For example:
 ##
 ## @example
 ## ezplot (@@(@var{x}, @var{y}) @var{x}.^2 - @var{y}.^2 - 1)
 ## @end example
 ##
-## If two functions are passed as strings, inline functions or function
-## handles, then the parametric function
+## If two functions are passed as inputs then the parametric function
 ##
 ## @example
 ## @group
 ## @var{x} = @var{fx} (@var{t})
 ## @var{y} = @var{fy} (@var{t})
 ## @end group
 ## @end example
 ##
 ## @noindent
-## is plotted over the domain @code{-2*pi < @var{t} < 2*pi} with 500
-## points.
+## is plotted over the domain @code{-2*pi <= @var{t} <= 2*pi} with 500 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of @var{x}, @var{y} and @var{t}.  If it is a four element
-## vector, then the minimum and maximum values of @var{x} and @var{t}
-## are determined by the first two elements and the minimum and maximum
-## of @var{y} by the second pair of elements.
+## values of both @var{x} and @var{y}, or @var{t} for a parametric plot.  If
+## @var{dom} is a four element vector, then the minimum and maximum values are
+## @code{[xmin xmax ymin ymax]}.
 ##
 ## @var{n} is a scalar defining the number of points to use in plotting
 ## the function.
 ##
-## The optional return value @var{h} is a graphics handle to the created plot.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## @seealso{plot, ezplot3}
+## The optional return value @var{h} is a vector of graphics handles to
+## the created line objects.
+##
+## @seealso{plot, ezplot3, ezpolar, ezcontour, ezcontourf, ezmesh, ezmeshc, ezsurf, ezsurfc}
 ## @end deftypefn
 
-function retval = ezplot (varargin)
+function h = ezplot (varargin)
 
-  [h, needusage] = __ezplot__ ("plot", varargin{:});
+  [htmp, needusage] = __ezplot__ ("plot", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
+%! %% sinc function using function handle
+%! f = @(x) sin (pi*x) ./ (pi*x);
+%! ezplot (f);
+
+%!demo
+%! %% example of a function string and explicit limits
+%! clf;
+%! ezplot ('1/x', [-2 2]);
+
+%!demo
+%! %% parameterized function example over -2*pi <= t <= +2*pi
 %! clf;
 %! ezplot (@cos, @sin);
 
 %!demo
+%! %% implicit function of 2 variables
 %! clf;
-%! ezplot ('1/x');
+%! ezplot (inline ('x^2 - y^2 - 1'));
 
-%!demo
-%! clf;
-%! ezplot (inline ('x^2 - y^2 = 1'));
-
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/draw/ezplot3.m
rename from scripts/plot/ezplot3.m
rename to scripts/plot/draw/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/draw/ezplot3.m
@@ -15,56 +15,70 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot3 (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezplot3 (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezplot3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot3 (@dots{})
 ##
 ## Plot a parametrically defined curve in three dimensions.
-## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions
-## or function handles with one arguments defining the function.  By
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}
-## with 60 points.
+##
+## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions,
+## or function handles with one argument defining the function.  By
+## default the plot is over the domain @code{0 <= @var{t} <= 2*pi}
+## with 500 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of @var{t}.  @var{n} is a scalar defining the number of points to use.
+## values of @var{t}.
+##
+## @var{n} is a scalar defining the number of points to use in plotting the
+## function.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## @example
 ## @group
 ## fx = @@(t) cos (t);
 ## fy = @@(t) sin (t);
 ## fz = @@(t) t;
 ## ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 ## @end group
 ## @end example
 ##
-## @seealso{plot3, ezplot, ezsurf, ezmesh}
+## @seealso{plot3, ezplot, ezmesh, ezsurf}
 ## @end deftypefn
 
-function retval = ezplot3 (varargin)
+function h = ezplot3 (varargin)
 
-  [h, needusage] = __ezplot__ ("plot3", varargin{:});
+  [htmp, needusage] = __ezplot__ ("plot3", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! fx = @(t) cos (t);
 %! fy = @(t) sin (t);
 %! fz = @(t) t;
 %! ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 
+%!demo
+%! clf;
+%! fx = @(t) cos (t);
+%! fy = @(t) sin (t);
+%! fz = @(t) t;
+%! ezplot3 (fx, fy, fz, [0, 5*pi], 100, 'animate');
+
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/draw/ezpolar.m
rename from scripts/plot/ezpolar.m
rename to scripts/plot/draw/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/draw/ezpolar.m
@@ -18,50 +18,55 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezpolar (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
-## Plot a function in polar coordinates.  The function @var{f} is
-## a string, inline function, or function handle with a single argument.
-## The expected form of the function is
+## Plot a 2-D function in polar coordinates.
+## 
+## The function @var{f} is a string, inline function, or function handle with
+## a single argument.  The expected form of the function is
 ## @code{@var{rho} = @var{f}(@var{theta})}.
-## By default the plot is over the domain @code{0 < @var{theta} < 2*pi} with 60
-## points.
+## By default the plot is over the domain @code{0 <= @var{theta} <= 2*pi}
+## with 500 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## values of @var{theta}.  @var{n} is a scalar defining the number of points to
-## use.  If the optional input @var{hax} is given then the plot is placed into
-## the specified axes rather than the current axes.
+## values of @var{theta}.
+##
+## @var{n} is a scalar defining the number of points to use in plotting
+## the function.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
 ## Example:
 ##
 ## @example
-## ezpolar (@@(t) 1 + sin (t));
+## ezpolar (@@(t) sin (5/4 * t), [0, 8*pi]);
 ## @end example
 ##
-## @seealso{polar, ezplot, ezsurf, ezmesh}
+## @seealso{polar, ezplot}
 ## @end deftypefn
 
-function retval = ezpolar (varargin)
+function h = ezpolar (varargin)
 
-  [h, needusage] = __ezplot__ ("polar", varargin{:});
+  [htmp, needusage] = __ezplot__ ("polar", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! ezpolar (@(t) 1 + sin (t));
+%! ezpolar (@(t) sin (5/4 * t), [0, 8*pi]);
 
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/draw/ezsurf.m
rename from scripts/plot/ezsurf.m
rename to scripts/plot/draw/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/draw/ezsurf.m
@@ -17,72 +17,77 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurf (@var{f})
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, "circ")
-## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezsurf (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
-## Plot the surface defined by a function.  @var{f} is a string, inline
-## function or function handle with two arguments defining the function.  By
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the surface defined by a function.
 ##
-## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
-##
-## @var{n} is a scalar defining the number of points to use in each dimension.
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument "circ" is given, then the function is plotted over a disk
-## centered on the middle of the domain @var{dom}.
+## If @var{dom} is a two element vector, it represents the minimum and maximum
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
+##
+## @var{n} is a scalar defining the number of points to use in each dimension.
+##
+## If the argument @qcode{"circ"} is given, then the function is plotted over
+## a disk centered on the middle of the domain @var{dom}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
+## Example 1: 2-argument function
+##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## An example of a parametrically defined function is
+## Example 2: parametrically defined function
 ##
 ## @example
 ## @group
 ## fx = @@(s,t) cos (s) .* cos (t);
 ## fy = @@(s,t) sin (s) .* cos (t);
 ## fz = @@(s,t) sin (t);
 ## ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezmesh, ezsurfc, ezmeshc}
+## @seealso{surf, ezsurfc, ezplot, ezmesh, ezmeshc, shading}
 ## @end deftypefn
 
-function retval = ezsurf (varargin)
+function h = ezsurf (varargin)
 
-  [h, needusage] = __ezplot__ ("surf", varargin{:});
+  [htmp, needusage] = __ezplot__ ("surf", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
@@ -91,9 +96,21 @@ endfunction
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! fx = @(s,t) cos (s) .* cos (t);
 %! fy = @(s,t) sin (s) .* cos (t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
+%! axis equal;
 
+%!demo
+%! clf;
+%! colormap ('default');
+%! f = @(x,y) x.^2 + y.^2;
+%! subplot (1,2,1);
+%!  ezsurf (f, [-2,2]);
+%!  title ({'x^2 + y^2'; 'plotted over rectangular grid (default)'});
+%! subplot (1,2,2);
+%!  ezsurf (f, [-2,2], 'circ');
+%!  title ({'x^2 + y^2'; 'plotted over circular disk with "circ"'});
+
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/draw/ezsurfc.m
rename from scripts/plot/ezsurfc.m
rename to scripts/plot/draw/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/draw/ezsurfc.m
@@ -17,62 +17,67 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurfc (@var{f})
 ## @deftypefnx {Function File} {} ezsurfc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, "circ")
-## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezsurfc (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
-## Plot the surface and contour lines defined by a function.  @var{f} is a
-## string, inline function or function handle with two arguments defining the
-## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
-## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
+## Plot the surface and contour lines defined by a function.
 ##
-## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
-## then the minimum and maximum value of @var{x} and @var{y} are specify
-## separately.
-##
-## @var{n} is a scalar defining the number of points to use in each dimension.
+## @var{f} is a string, inline function, or function handle with two arguments
+## defining the function.  By default the plot is over the meshed domain
+## @code{-2*pi <= @var{x} | @var{y} <= 2*pi} with 60 points in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument "circ" is given, then the function is plotted over a disk
-## centered on the middle of the domain @var{dom}.
+## If @var{dom} is a two element vector, it represents the minimum and maximum
+## values of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
+## then the minimum and maximum values are @code{[xmin xmax ymin ymax]}.
+##
+## @var{n} is a scalar defining the number of points to use in each dimension.
+##
+## If the argument @qcode{"circ"} is given, then the function is plotted over
+## a disk centered on the middle of the domain @var{dom}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
-## for the created surface plot and a second handle for the created contour
-## plot.
+## handle for the created surface plot and a second handle for the created
+## contour plot.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
-## @seealso{ezplot, ezmeshc, ezsurf, ezmesh}
+## @seealso{surfc, ezsurf, ezplot, ezmesh, ezmeshc, shading}
 ## @end deftypefn
 
-function retval = ezsurfc (varargin)
+function h = ezsurfc (varargin)
 
-  [h, needusage] = __ezplot__ ("surfc", varargin{:});
+  [htmp, needusage] = __ezplot__ ("surfc", varargin{:});
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/feather.m b/scripts/plot/draw/feather.m
rename from scripts/plot/feather.m
rename to scripts/plot/draw/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/draw/feather.m
@@ -15,103 +15,122 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} feather (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} feather (@var{z})
 ## @deftypefnx {Function File} {} feather (@dots{}, @var{style})
-## @deftypefnx {Function File} {} feather (@var{h}, @dots{})
+## @deftypefnx {Function File} {} feather (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} feather (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
-## from equidistant points on the x-axis.  If a single complex argument
-## @var{z} is given, then @code{@var{u} = real (@var{z})} and
-## @code{@var{v} = imag (@var{z})}.
+## from equidistant points on the x-axis.
+##
+## If a single complex argument @var{z} is given, then
+## @code{@var{u} = real (@var{z})} and @code{@var{v} = imag (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
+## of the same format as the @code{plot} command.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing the drawn vectors.
 ##
 ## @example
 ## @group
 ## phi = [0 : 15 : 360] * pi/180;
 ## feather (sin (phi), cos (phi));
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, quiver, compass}
 ## @end deftypefn
 
-function retval = feather (varargin)
+function h = feather (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("feather", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("feather", varargin{:});
 
-  arrowsize = 0.25;
+  if (nargin == 0 || nargin > 3)
+    print_usage ();
+  endif
 
-  if (nargin == 0)
-    print_usage ();
-  elseif (nargin == 1 || (nargin == 2 && ! isnumeric (varargin{2})))
-    ioff = 2;
+  if (nargin == 1 || (nargin == 2 && ! isnumeric (varargin{2})))
     z = varargin{1}(:).';
     u = real (z);
     v = imag (z);
-  elseif (nargin > 1 && isnumeric (varargin{2}))
+    have_line_spec = (nargin == 2);
+  elseif (nargin >= 2 && isnumeric (varargin{2}))
     ioff = 3;
     u = varargin{1}(:).';
     v = varargin{2}(:).';
+    have_line_spec = (nargin == 3);
+  else
+    print_usage ();
   endif
 
-  line_spec = "b-";
-  have_line_spec = false;
-  while (ioff <= nargin)
-    arg = varargin{ioff++};
-    if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
-      [linespec, valid] = __pltopt__ ("feather", arg, false);
+  arrowsize = 0.20;
+  line_spec = "-b";
+
+  if (have_line_spec)
+    arg = varargin{end};
+    if (ischar (arg) || iscellstr (arg))
+      [~, valid] = __pltopt__ ("feather", arg, false);
       if (valid)
         line_spec = arg;
-        have_line_spec = false;
-        break;
       else
-        error ("feather: invalid linespec");
+        error ("feather: invalid linestyle STYLE");
       endif
     else
-      error ("feather: unrecognized argument");
+      error ("feather: invalid linestyle STYLE");
     endif
-  endwhile
+  endif
 
   ## Matlab draws feather plots, with the arrow head as one continous
-  ## line, and each arrow separately. This is completely different than
+  ## line, and each arrow separately. This is completely different from
   ## quiver and quite ugly.
   n = length (u);
   xend = [1 : n] + u;
   xtmp = [1 : n] + u .* (1 - arrowsize);
   yend = v;
   ytmp = v .* (1 - arrowsize);
-  x = [[1 : n]; xend; xtmp  - v * arrowsize; xend; ...
-       xtmp + v * arrowsize];
-  y = [zeros(1, n); yend; ytmp  + u * arrowsize / 3; yend; ...
+  x = [[1 : n]; xend; xtmp - v * arrowsize / 3; xend; ...
+       xtmp + v * arrowsize / 3];
+  y = [zeros(1, n); yend; ytmp + u * arrowsize / 3; yend; ...
        ytmp - u * arrowsize / 3];
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    hlist = plot (h, x, y, line_spec, [1, n], [0, 0], line_spec);
+    hax = newplot (hax);
+    hlist = plot (x, y, line_spec, [1, n], [0, 0], line_spec);
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = hlist;
+    h = hlist;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! phi = [0 : 15 : 360] * pi/180;
 %! feather (sin (phi), cos (phi));
+%! axis tight;
+%! title ('feather plot');
 
+%% Test input validation
+%!error feather ()
+%!error feather (1,2,3,4)
+%!error feather (1, "-r", 2)
+%!error <invalid linestyle STYLE> feather (1, "abc")
+%!error <invalid linestyle STYLE> feather (1, {1})
+
diff --git a/scripts/plot/fill.m b/scripts/plot/draw/fill.m
rename from scripts/plot/fill.m
rename to scripts/plot/draw/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/draw/fill.m
@@ -15,62 +15,102 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fill (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} fill (@var{x1}, @var{y1}, @var{c1}, @var{x2}, @var{y2}, @var{c2})
 ## @deftypefnx {Function File} {} fill (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} fill (@var{h}, @dots{})
+## @deftypefnx {Function File} {} fill (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} fill (@dots{})
-## Create one or more filled patch objects.
+## Create one or more filled 2-D polygons.
+##
+## The inputs @var{x} and @var{y} are the coordinates of the polygon vertices.
+## If the inputs are matrices then the rows represent different vertices and
+## each column produces a different polygon.  @code{fill} will close any open
+## polygons before plotting. 
+##
+## The input @var{c} determines the color of the polygon.  The simplest form
+## is a single color specification such as a @code{plot} format or an
+## RGB-triple.  In this case the polygon(s) will have one unique color.  If
+## @var{c} is a vector or matrix then the color data is first scaled using
+## @code{caxis} and then indexed into the current colormap.  A row vector will
+## color each polygon (a column from matrices @var{x} and @var{y}) with a
+## single computed color.  A matrix @var{c} of the same size as @var{x} and
+## @var{y} will compute the color of each vertex and then interpolate the face
+## color between the vertices.
+##
+## Multiple property/value pairs for the underlying patch object may be
+## specified, but they must appear in pairs.
 ##
-## The optional return value @var{h} is an array of graphics handles to
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a vector of graphics handles to
 ## the created patch objects.
-## @seealso{patch}
+##
+## Example: red square
+##
+## @example
+## @group
+## vertices = [0 0
+##             1 0
+##             1 1
+##             0 1];
+## fill (vertices(:,1), vertices(:,2), "r");
+## axis ([-0.5 1.5, -0.5 1.5])
+## axis equal
+## @end group
+## @end example
+##
+## @seealso{patch, caxis, colormap}
 ## @end deftypefn
 
-function retval = fill (varargin)
+function h = fill (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("fill", varargin{:});
 
-  htmp = [];
+  hlist = [];
   iargs = __find_patches__ (varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
+    hax = newplot (hax);
+    old_nxtplt = get (hax, "nextplot");
+    set (hax, "nextplot", "add");
 
-    nextplot = get (h, "nextplot");
     for i = 1 : length (iargs)
-      if (i > 1 && strncmp (nextplot, "replace", 7))
-        set (h, "nextplot", "add");
-      endif
       if (i == length (iargs))
         args = varargin(iargs(i):end);
       else
         args = varargin(iargs(i):iargs(i+1)-1);
       endif
-      newplot ();
-      [tmp, fail] = __patch__ (h, args{:});
+      [htmp, fail] = __patch__ (hax, args{:});
       if (fail)
         print_usage ();
       endif
-      htmp(end + 1, 1) = tmp;
+      hlist(end + 1, 1) = htmp;
     endfor
-    if (strncmp (nextplot, "replace", 7))
-      set (h, "nextplot", nextplot);
+
+    if (strcmp (old_nxtplt, "replace"))
+      set (hax, "nextplot", old_nxtplt);
     endif
+
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = htmp;
+    h = hlist;
   endif
 
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
diff --git a/scripts/plot/fplot.m b/scripts/plot/draw/fplot.m
rename from scripts/plot/fplot.m
rename to scripts/plot/draw/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/draw/fplot.m
@@ -13,128 +13,207 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fplot (@var{fn}, @var{limits})
-## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{tol})
-## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{n})
+## @deftypefnx {Function File} {} fplot (@dots{}, @var{tol})
+## @deftypefnx {Function File} {} fplot (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} fplot (@dots{}, @var{fmt})
-## Plot a function @var{fn} within defined limits.
-## @var{fn} is a function handle, inline function, or string
-## containing the name of the function to evaluate.
-## The limits of the plot are given by @var{limits} of the form
-## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
-## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
-## plot, and if @var{tol} is an integer it is assumed that it defines the
-## number points to use in the plot.  The @var{fmt} argument is passed
-## to the plot command.
+## @deftypefnx {Function File} {[@var{x}, @var{y}] =} fplot (@dots{})
+## Plot a function @var{fn} within the range defined by @var{limits}.
+##
+## @var{fn} is a function handle, inline function, or string containing the
+## name of the function to evaluate.
+##
+## The limits of the plot are of the form @w{@code{[@var{xlo}, @var{xhi}]}} or
+## @w{@code{[@var{xlo}, @var{xhi}, @var{ylo}, @var{yhi}]}}.
+##
+## The next three arguments are all optional and any number of them may be
+## given in any order.
+##
+## @var{tol} is the relative tolerance to use for the plot and defaults
+## to 2e-3 (.2%).
+##
+## @var{n} is the minimum number of points to use.  When @var{n} is specified,
+## the maximum stepsize will be @code{@var{xhi} - @var{xlo} / @var{n}}.  More
+## than @var{n} points may still be used in order to meet the relative
+## tolerance requirement.
+##
+## The @var{fmt} argument specifies the linestyle to be used by the plot
+## command.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## With no output arguments the results are immediately plotted.  With two
+## output arguments the 2-D plot data is returned.  The data can subsequently
+## be plotted manually with @code{plot (@var{x}, @var{y})}.
+##
+## Example:
 ##
 ## @example
 ## @group
-## fplot ("cos", [0, 2*pi])
+## fplot (@@cos, [0, 2*pi])
 ## fplot ("[cos(x), sin(x)]", [0, 2*pi])
 ## @end group
 ## @end example
-## @seealso{plot}
+##
+## Note: @code{fplot} works best with continuous functions.  Functions with
+## discontinuities are unlikely to plot well.  This restriction may be removed
+## in the future.
+## @seealso{ezplot, plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
-function fplot (fn, limits, n = 0.002, fmt = "")
+function [X, Y] = fplot (varargin)
 
-  if (nargin < 2 || nargin > 4)
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("fplot", varargin{:});
+
+  if (nargin < 2 || nargin > 5)
     print_usage ();
   endif
 
-  if (iscomplex (limits) || (numel (limits) != 2 && numel (limits) != 4))
-    error ("fplot: LIMITS must be a real vector with 2 or 4 elements");
-  endif
-
-  if (ischar (n))
-    fmt = n;
-    n = 0.002;
-  endif
+  fn = varargin{1};
+  limits = varargin{2};
+  varargin = varargin(3:end);
 
   if (strcmp (typeinfo (fn), "inline function"))
     fn = vectorize (fn);
     nam = formula (fn);
   elseif (isa (fn, "function_handle"))
     nam = func2str (fn);
   elseif (all (isalnum (fn)))
     nam = fn;
   elseif (ischar (fn))
     fn = vectorize (inline (fn));
     nam = formula (fn);
   else
     error ("fplot: FN must be a function handle, inline function, or string");
   endif
 
-  if (n != fix (n))
-    tol = n;
-    x0 = linspace (limits(1), limits(2), 5)';
+  if (iscomplex (limits) || (numel (limits) != 2 && numel (limits) != 4))
+    error ("fplot: LIMITS must be a real vector with 2 or 4 elements");
+  endif
+
+  n = 5;
+  tol = 2e-3;
+  fmt = "";
+  for i = 1:numel (varargin)
+    arg = varargin{i};
+    if (ischar (arg))
+      fmt = arg;
+    elseif (isnumeric (arg) && isscalar (arg) && arg > 0)
+      if (arg == fix (arg))
+        n = arg;
+      else
+        tol = arg;
+      endif
+    else
+      error ("fplot: bad input in position %d", i+2);
+    endif
+  endfor
+
+  if (n != 5) 
+    ## n was specified 
+    x0 = linspace (limits(1), limits(2), n/2 + 1)';
     y0 = feval (fn, x0);
-    err0 = Inf;
-    n = 8;
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
-   
-    if (! size_equal (x0, y0))
-      ## FN is a constant value function
-      y0 = repmat (y0, size (x0));
-      y = repmat (y, size (x));
-    endif
-
-    while (n < 2 .^ 20)
-      y00 = interp1 (x0, y0, x, "linear");
-      err = 0.5 * max (abs ((y00 - y) ./ (y00 + y))(:));
-      if (err == err0 || err < tol)
-        break;
-      endif
-      x0 = x;
-      y0 = y;
-      err0 = err;
-      n = 2 * (n - 1) + 1;
-      x = linspace (limits(1), limits(2), n)';
-      y = feval (fn, x);
-    endwhile
   else
+    x0 = linspace (limits(1), limits(2), 5)';
+    y0 = feval (fn, x0);
+    n = 8;
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
   endif
 
-  plot (x, y, fmt);
-
-  if (length (limits) > 2)
-    axis (limits);
+  if (rows (x0) != rows (y0))
+    ## FN is a constant value function
+    y0 = repmat (y0, size (x0));
+    y = repmat (y, size (x));
   endif
 
-  if (isvector (y))
-    legend (nam);
+  err0 = Inf;
+
+  ## FIXME: This algorithm should really use adaptive scaling as the 
+  ##        the numerical quadrature algorithms do so that extra points are
+  ##        used where they are needed and not spread evenly over the entire
+  ##        x-range.  Try any function with a discontinuity, such as
+  ##        fplot (@tan, [-2, 2]) or fplot ("1./x", [-3, 2]), to see the
+  ##        problems with the current solution.
+
+  while (n < 2^18)    # Something is wrong if we need more than 250K points
+    yi = interp1 (x0, y0, x, "linear");
+    ## relative error calculation using average of [yi,y] as reference
+    ## since neither estimate is known a priori to be better than the other.
+    err = 0.5 * max (abs ((yi - y) ./ (yi + y))(:));
+    if (err < tol || abs (err - err0) < tol/2)
+      ## Either relative tolerance has been met OR
+      ## algorithm has stopped making any reasonable progress per iteration.
+      break;
+    endif
+    x0 = x;
+    y0 = y;
+    err0 = err;
+    n = 2 * (n - 1) + 1;
+    x = linspace (limits(1), limits(2), n)';
+    y = feval (fn, x);
+  endwhile
+
+  if (nargout == 2)
+    X = x;
+    Y = y;
   else
-    for i = 1:columns (y)
-      nams{i} = sprintf ("%s(:,%i)", nam, i);
-    endfor
-    legend (nams{:});
+    if (isempty (hax))
+      hax = gca ();
+    endif
+    plot (hax, x, y, fmt);
+    axis (hax, limits);
+    if (isvector (y))
+      legend (hax, nam);
+    else
+      for i = 1:columns (y)
+        nams{i} = sprintf ("%s(:,%i)", nam, i);
+      endfor
+      legend (hax, nams{:});
+    endif
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! fplot ('cos', [0, 2*pi]);
+%! fplot (@cos, [0, 2*pi]);
+%! title ('fplot() single function');
 
 %!demo
 %! clf;
 %! fplot ('[cos(x), sin(x)]', [0, 2*pi]);
+%! title ('fplot() multiple functions');
+
+%!demo
+%! clf;
+%! %% sinc function
+%! fh = @(x) sin (pi*x) ./ (pi*x);
+%! fplot (fh, [-5, 5]);
+%! title ('fplot() sinc function');
+
+%!test
+%! [x, y] = fplot ("[cos(x), sin(x)]", [0, 2*pi]);
+%! assert (columns (y) == 2);
+%! assert (rows (x) == rows (y));
+%! assert (y, [cos(x), sin(x)], -2e-3);
 
 %% Test input validation
 %!error fplot (1)
-%!error fplot (1,2,3,4,5)
+%!error fplot (1,2,3,4,5,6)
+%!error <FN must be a function handle> fplot (1, [0 1])
 %!error <LIMITS must be a real vector> fplot (@cos, [i, 2*i])
 %!error <LIMITS must be a real vector with 2 or 4> fplot (@cos, [1])
 %!error <LIMITS must be a real vector with 2 or 4> fplot (@cos, [1 2 3])
-%!error <FN must be a function handle> fplot (1, [0 1])
+%!error <bad input in position 3> fplot (@cos,[-1,1], {1})
 
diff --git a/scripts/plot/hist.m b/scripts/plot/draw/hist.m
rename from scripts/plot/hist.m
rename to scripts/plot/draw/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/draw/hist.m
@@ -16,107 +16,115 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hist (@var{y})
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{x})
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{nbins})
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{x}, @var{norm})
+## @deftypefnx {Function File} {} hist (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} hist (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{nn}, @var{xx}] =} hist (@dots{})
-## @deftypefnx {Function File} {[@dots{}] =} hist (@dots{}, @var{prop}, @var{val})
-##
 ## Produce histogram counts or plots.
 ##
 ## With one vector input argument, @var{y}, plot a histogram of the values
 ## with 10 bins.  The range of the histogram bins is determined by the
 ## range of the data.  With one matrix input argument, @var{y}, plot a
 ## histogram where each bin contains a bar per input column.
 ##
 ## Given a second vector argument, @var{x}, use that as the centers of
 ## the bins, with the width of the bins determined from the adjacent
 ## values in the vector.
 ##
 ## If scalar, the second argument, @var{nbins}, defines the number of bins.
 ##
 ## If a third argument is provided, the histogram is normalized such that
 ## the sum of the bars is equal to @var{norm}.
 ##
-## Extreme values are lumped in the first and last bins.
-##
-## With two output arguments, produce the values @var{nn} and @var{xx} such
-## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
+## Extreme values are lumped into the first and last bins.
 ##
 ## The histogram's appearance may be modified by specifying property/value
-## pairs, @var{prop} and @var{val} pairs.  For example the face and edge
-## color may be modified.
+## pairs.  For example the face and edge color may be modified.
 ##
 ## @example
 ## @group
 ## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b");
 ## @end group
 ## @end example
 ##
 ## @noindent
-## The histograms colors also depend upon the colormap.
+## The histogram's colors also depend upon the current colormap.
 ##
 ## @example
 ## @group
 ## hist (rand (10, 3));
 ## colormap (summer ());
 ## @end group
 ## @end example
 ##
-## @seealso{bar}
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## With two output arguments, produce the values @var{nn} (numbers of elements)
+## and @var{xx} (bin centers) such that @code{bar (@var{xx}, @var{nn})} will
+## plot the histogram.
+##
+## @seealso{histc, bar, pie, rose}
 ## @end deftypefn
 
 ## Author: jwe
 
-function [nn, xx] = hist (y, varargin)
+function [nn, xx] = hist (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("hist", varargin{:});
 
   if (nargin < 1)
     print_usage ();
   endif
+  
+  y = varargin{1};
+  varargin = varargin(2:end);
 
   arg_is_vector = isvector (y);
 
-  if (rows (y) == 1)
+  if (arg_is_vector)
     y = y(:);
   endif
 
-  if (isreal (y))
-    max_val = max (y(:));
-    min_val = min (y(:));
-  else
-    error ("hist: first argument must be real valued");
+  if (! isreal (y))
+    error ("hist: Y must be real valued");
   endif
 
+  max_val = max (y(:));
+  min_val = min (y(:));
+
   iarg = 1;
   if (nargin == 1 || ischar (varargin{iarg}))
     n = 10;
     x = [0.5:n]'/n;
     x = x * (max_val - min_val) + ones (size (x)) * min_val;
   else
     ## nargin is either 2 or 3
     x = varargin{iarg++};
     if (isscalar (x))
       n = x;
       if (n <= 0)
-        error ("hist: number of bins must be positive");
+        error ("hist: number of bins NBINS must be positive");
       endif
       x = [0.5:n]'/n;
       x = x * (max_val - min_val) + ones (size (x)) * min_val;
     elseif (isreal (x))
       if (isvector (x))
         x = x(:);
       endif
-      tmp = sort (x);
-      if (any (tmp != x))
+      xsort = sort (x);
+      if (any (xsort != x))
         warning ("hist: bin values not sorted on input");
-        x = tmp;
+        x = xsort;
       endif
     else
       error ("hist: second argument must be a scalar or a vector");
     endif
   endif
 
   ## Avoid issues with integer types for x and y
   x = double (x);
@@ -142,33 +150,35 @@ function [nn, xx] = hist (y, varargin)
     chist = [(zeros (1, y_nc));
              (reshape (chist(idx > len), rows (cutoff), y_nc));
              (chist(end,:) - sum (isnan (y)))];
   endif
 
   freq = diff (chist);
 
   if (nargin > 2 && ! ischar (varargin{iarg}))
-    ## Normalise the histogram.
+    ## Normalize the histogram.
     norm = varargin{iarg++};
-    freq = freq / sum(! isnan (y)) * norm;
+    freq *= norm / sum (! isnan (y));
   endif
 
   if (nargout > 0)
-    if (arg_is_vector)
-      nn = freq';
+    if (arg_is_vector)  
+      ## Matlab compatibility requires a row vector return
+      nn = freq';  
       xx = x';
     else
       nn = freq;
       xx = x;
     endif
-  elseif (columns (freq) != 1)
-    bar (x, freq, 0.8, varargin{iarg:end});
   else
-    bar (x, freq, 1.0, varargin{iarg:end});
+    if (isempty (hax))
+      hax = gca ();
+    endif
+    bar (hax, x, freq, "hist", varargin{iarg:end});
   endif
 
 endfunction
 
 
 %!test
 %! [nn,xx] = hist ([1:4], 3);
 %! assert (xx, [1.5,2.5,3.5]);
diff --git a/scripts/plot/isocolors.m b/scripts/plot/draw/isocolors.m
rename from scripts/plot/isocolors.m
rename to scripts/plot/draw/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/draw/isocolors.m
@@ -88,17 +88,16 @@
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
 ## cdat = isocolors (x, y, z, r, g, b, v);
 ## set (p, "FaceVertexCData", cdat);
 ## isofinish (p);
 ## @end example
 ##
 ## @seealso{isosurface, isonormals}
-##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function varargout = isocolors (varargin)
   calc_rgb = false;
   switch (nargin)
     case 2
diff --git a/scripts/plot/isonormals.m b/scripts/plot/draw/isonormals.m
rename from scripts/plot/isonormals.m
rename to scripts/plot/draw/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/draw/isonormals.m
@@ -33,17 +33,17 @@
 ## @var{n} can be taken to manually set @var{VertexNormals} of a patch.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays with the same size than @var{val}
 ## then the volume data is taken at those given points.  Instead of the
 ## vertices data @var{v} a patch handle @var{p} can be passed to this
 ## function.
 ##
-## If given the string input argument "negate" as last input argument
+## If given the string input argument @qcode{"negate"} as last input argument
 ## then compute the reverse vector normals of an isosurface geometry.
 ##
 ## If no output argument is given then directly redraw the patch that is
 ## given by the patch handle @var{p}.
 ##
 ## For example:
 ## @c Set example in small font to prevent overfull line
 ##
diff --git a/scripts/plot/isosurface.m b/scripts/plot/draw/isosurface.m
rename from scripts/plot/isosurface.m
rename to scripts/plot/draw/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/draw/isosurface.m
@@ -33,19 +33,19 @@
 ## points @command{[x, y, z] = meshgrid (1:l, 1:m, 1:n)}.  The output
 ## argument @var{fv} can directly be taken as an input argument for the
 ## @command{patch} function.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays with the same size than @var{val}
 ## then the volume data is taken at those given points.
 ##
-## The string input argument "noshare" is only for compatibility and
+## The string input argument @qcode{"noshare"} is only for compatibility and
 ## has no effect.  If given the string input argument
-## "verbose" then print messages to the command line interface about the
+## @qcode{"verbose"} then print messages to the command line interface about the
 ## current progress.
 ##
 ## If called with the input argument @var{col} which is a
 ## three-dimensional array of the same size than @var{val} then take
 ## those values for the interpolation of coloring the isosurface
 ## geometry.  Add the field @var{FaceVertexCData} to the structure
 ## array @var{fv}.
 ##
@@ -145,42 +145,42 @@ function varargout = isosurface (varargi
     iso = varargin{2};
     if (nargin >= 3 && ismatrix (varargin{3}))
         colors = varargin{3};
         calc_colors = true;
     endif
   endif
   if (calc_colors)
     if (nargout == 2)
-      warning ( "Colors will be calculated, but you did not specify an output argument for it!" );
+      warning ("isosurface: colors will be calculated, but no output argument to receive it.");
     endif
     [fvc.faces, fvc.vertices, fvc.facevertexcdata] = __marching_cube__ (x, y, z, val, iso, colors);
   else
     [fvc.faces, fvc.vertices] = __marching_cube__ (x, y, z, val, iso);
   endif
 
   if (isempty (fvc.vertices) || isempty (fvc.faces))
-    warning ( "The resulting triangulation is empty" );
+    warning ("isosurface: triangulation is empty");
   endif
 
   switch (nargout)
     case 0
       ## plot the calculated surface
-      newplot ();
+      hax = newplot ();
       if (calc_colors)
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceVertexCData", fvc.facevertexcdata,
                     "FaceColor", "flat", "EdgeColor", "none");
       else
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
-        set (gca (), "view", [-37.5, 30],
-             "xgrid", "on", "ygrid", "on", "zgrid", "on");
+        set (hax, "view", [-37.5, 30],
+                  "xgrid", "on", "ygrid", "on", "zgrid", "on");
       endif
     case 1
       varargout = {fvc};
     case 2
       varargout = {fvc.faces, fvc.vertices};
     case 3
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
     otherwise
@@ -190,37 +190,42 @@ function varargout = isosurface (varargi
 endfunction
 
 
 %!demo
 %! clf;
 %! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
 %! v = x.^2 + y.^2 + z.^2;
 %! isosurface (x, y, z, v, 1);
+%! title ('isosurface of a sphere');
 
 %!shared x, y, z, val
 %! [x, y, z]  = meshgrid (0:1, 0:1, 0:1); # Points for single
 %! val        = [0, 0; 0, 0];             # cube and a 3-D
 %! val(:,:,2) = [0, 0; 1, 0];             # array of values
+
 %!test
 %! fv = isosurface (x, y, z, val, 0.3);
 %! assert (isfield (fv, "vertices"), true);
 %! assert (isfield (fv, "faces"), true);
 %! assert (size (fv.vertices), [3 3]);
 %! assert (size (fv.faces), [1 3]);
+
 %!test
 %! fvc = isosurface (x, y, z, val, .3, y);
 %! assert (isfield (fvc, "vertices"), true);
 %! assert (isfield (fvc, "faces"), true);
 %! assert (isfield (fvc, "facevertexcdata"), true);
 %! assert (size (fvc.vertices), [3 3]);
 %! assert (size (fvc.faces), [1 3]);
 %! assert (size (fvc.facevertexcdata), [3 1]);
+
 %!test
 %! [f, v] = isosurface (x, y, z, val, .3);
 %! assert (size (f), [1 3]);
 %! assert (size (v), [3 3]);
+
 %!test
 %! [f, v, c] = isosurface (x, y, z, val, .3, y);
 %! assert (size (f), [1 3]);
 %! assert (size (v), [3 3]);
 %! assert (size (c), [3 1]);
 
diff --git a/scripts/plot/line.m b/scripts/plot/draw/line.m
rename from scripts/plot/line.m
rename to scripts/plot/draw/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/draw/line.m
@@ -14,36 +14,52 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} line ()
 ## @deftypefnx {Function File} {} line (@var{x}, @var{y})
+## @deftypefnx {Function File} {} line (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} line (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} line (@var{x}, @var{y}, @var{z}, @var{property}, @var{value}, @dots{})
-## Create line object from @var{x} and @var{y} and insert in current
-## axes object.  Return a handle (or vector of handles) to the line
-## objects created.
+## @deftypefnx {Function File} {} line (@var{property}, @var{value}, @dots{})
+## @deftypefnx {Function File} {} line (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} line (@dots{})
+## Create line object from @var{x} and @var{y} (and possibly @var{z}) and
+## insert in the current axes.
 ##
-## Multiple property-value pairs may be specified for the line, but they
+## Multiple property-value pairs may be specified for the line object, but they
 ## must appear in pairs.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle (or vector of handles)
+## to the line objects created.
+##
+## @seealso{image, patch, rectangle, surface, text}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = line (varargin)
 
-  ## make a default line object, and make it the current axes for
-  ## the current figure.
-  tmp = __line__ (gca (), varargin{:});
+  ## Get axis argument which may be in a 'parent' PROP/VAL pair
+  [hax, varargin] = __plt_get_axis_arg__ ("line", varargin{:});
+
+  if (isempty (hax))
+    hax = gca ();
+  endif
+
+  htmp = __line__ (hax, varargin{:});
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf
 %! x = 0:0.3:10;
diff --git a/scripts/plot/loglog.m b/scripts/plot/draw/loglog.m
rename from scripts/plot/loglog.m
rename to scripts/plot/draw/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/draw/loglog.m
@@ -14,66 +14,76 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} loglog (@var{y})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y})
-## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
+## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{prop}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} loglog (@var{x}, @var{y}, @var{fmt})
-## @deftypefnx {Function File} {} loglog (@var{h}, @dots{})
+## @deftypefnx {Function File} {} loglog (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} loglog (@dots{})
-## Produce a two-dimensional plot using log scales for both axes.  See
-## the documentation of @code{plot} for a description of the arguments
+## Produce a 2-D plot using logarithmic scales for both axes.
+##
+## See the documentation of @code{plot} for a description of the arguments
 ## that @code{loglog} will accept.
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, semilogy}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = loglog (varargin)
+function h = loglog (varargin)
 
-  [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
 
   if (nargs < 1)
     print_usage ();
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "xscale", "log", "yscale", "log");
-    if (any( strcmp (get (gca, "nextplot"), {"new", "replace"})))
-      set (h, "xminortick", "on", "yminortick", "on");
+    set (hax, "xscale", "log", "yscale", "log");
+    if (! ishold (hax))
+      set (hax, "xminortick", "on", "yminortick", "on");
     endif
 
-    tmp = __plt__ ("loglog", h, varargin{:});
+    htmp = __plt__ ("loglog", hax, varargin{:});
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
 %! y = (t .* (1 + rand (size (t)))) .^ 2;
 %! loglog (x, y);
+%! title ({'loglog() plot', 'Both axes are logarithmic'});
 
 %!demo
 %! clf;
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
 %!
 %! subplot (1,2,1);
 %!  loglog (a, b);
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/draw/loglogerr.m
rename from scripts/plot/loglogerr.m
rename to scripts/plot/draw/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/draw/loglogerr.m
@@ -13,61 +13,75 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} loglogerr (@var{args})
-## @deftypefnx {Function File} {@var{h} =} loglogerr (@var{args})
-## Produce two-dimensional plots on double logarithm axis with
-## errorbars.  Many different combinations of arguments are possible.
-## The most common form is
+## @deftypefnx {Function File} {} loglogerr (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} loglogerr (@dots{})
+## Produce 2-D plots on a double logarithm axis with errorbars.
+##
+## Many different combinations of arguments are possible.  The most common
+## form is
 ##
 ## @example
 ## loglogerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a double logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See errorbar for available formats and
-## additional information.
+## format defined by @var{fmt}.  @xref{XREFerrorbar,,errorbar}, for available
+## formats and additional information.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ## @seealso{errorbar, semilogxerr, semilogyerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = loglogerr (varargin)
+function h = loglogerr (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("loglogerr", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("loglogerr", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "xscale", "log", "yscale", "log");
-
-    tmp = __errcomm__ ("loglogerr", h, varargin{:});
+    set (hax, "xscale", "log", "yscale", "log");
+    if (! ishold (hax))
+      set (hax, "xminortick", "on", "yminortick", "on");
+    endif
+    htmp = __errcomm__ ("loglogerr", hax, varargin{:});
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
 %! loglogerr (x, y, eyl, eyu, '#~x-');
 %! xlim (x([1, end]));
+%! title ({'loglogerr(): loglog() plot with errorbars', ...
+%!         'Both axes are logarithmic'});
 
diff --git a/scripts/plot/mesh.m b/scripts/plot/draw/mesh.m
rename from scripts/plot/mesh.m
rename to scripts/plot/draw/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/draw/mesh.m
@@ -15,73 +15,113 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} mesh (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} mesh (@var{z})
 ## @deftypefnx {Function File} {} mesh (@dots{}, @var{c})
+## @deftypefnx {Function File} {} mesh (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} mesh (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} mesh (@dots{})
-## Plot a mesh given matrices @var{x}, and @var{y} from @code{meshgrid} and
-## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
-## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
-## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
-## correspond to different @var{x} values and rows of @var{z} correspond
-## to different @var{y} values.
+## Plot a 3-D wireframe mesh.
+##
+## The wireframe mesh is plotted using rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
 ##
-## The color of the mesh is derived from the @code{colormap}
-## and the value of @var{z}.  Optionally the color of the mesh can be
-## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+## The color of the mesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally, the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
-## @seealso{colormap, contour, meshgrid, surf}
+##
+## @seealso{ezmesh, meshc, meshz, trimesh, contour, surf, surface, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = mesh (varargin)
 
-  newplot ();
-
-  tmp = surface (varargin{:});
-
-  ax = get (tmp, "parent");
-
-  set (tmp, "facecolor", "w");
-  set (tmp, "edgecolor", "flat");
-
-  if (! ishold ())
-    set (ax, "view", [-37.5, 30],
-         "xgrid", "on", "ygrid", "on", "zgrid", "on");
+  if (! all (cellfun ("isreal", varargin)))
+    error ("mesh: X, Y, Z, C arguments must be real");
   endif
 
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("mesh", varargin{:});
+
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+
+    htmp = surface (varargin{:});
+
+    set (htmp, "facecolor", "w");
+    set (htmp, "edgecolor", "flat");
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    endif
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
+
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! x = logspace (0,1,11);
 %! z = x'*x;
+%! mesh (x, x, z);
+%! xlabel 'X-axis';
+%! ylabel 'Y-axis';
+%! zlabel 'Z-axis';
+%! title ('mesh() with color proportional to height');
+
+%!demo
+%! clf;
+%! x = logspace (0,1,11);
+%! z = x'*x;
 %! mesh (x, x, z, z.^2);
-%! xlabel xlabel;
-%! ylabel ylabel;
+%! xlabel 'X-axis';
+%! ylabel 'Y-axis';
 %! zlabel 'linear scale';
+%! title ('mesh() with color proportional to Z^2');
 
 %!demo
 %! clf;
 %! x = logspace (0,1,11);
 %! z = x'*x;
 %! mesh (x, x, z, z.^2);
 %! set (gca, 'zscale', 'log');
-%! xlabel xlabel;
-%! ylabel ylabel;
+%! xlabel 'X-axis';
+%! ylabel 'Y-axis';
 %! zlabel 'log scale';
+%! title ({'mesh() with color proportional to Z^2', 'Z-axis is log scale'});
 %! if (strcmp (get (gcf, '__graphics_toolkit__'), 'gnuplot'))
-%!   title ({'Gnuplot: mesh color is wrong', 'This a Gnuplot bug'});
+%!   title ({'Gnuplot: mesh color is wrong', 'This is a Gnuplot bug'});
 %! endif
 
diff --git a/scripts/plot/meshc.m b/scripts/plot/draw/meshc.m
rename from scripts/plot/meshc.m
rename to scripts/plot/draw/meshc.m
--- a/scripts/plot/meshc.m
+++ b/scripts/plot/draw/meshc.m
@@ -12,50 +12,100 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} meshc (@var{x}, @var{y}, @var{z})
-## Plot a mesh and contour given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
-## columns of @var{z} correspond to different @var{x} values and rows of
-## @var{z} correspond to different @var{y} values.
-## @seealso{meshgrid, mesh, contour}
+## @deftypefn  {Function File} {} meshc (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} meshc (@var{z})
+## @deftypefnx {Function File} {} meshc (@dots{}, @var{c})
+## @deftypefnx {Function File} {} meshc (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} meshc (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} meshc (@dots{})
+## Plot a 3-D wireframe mesh with underlying contour lines.
+##
+## The wireframe mesh is plotted using rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
+## 
+## The color of the mesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a 2-element vector with a graphics
+## handle to the created surface object and to the created contour plot.
+##
+## @seealso{ezmeshc, mesh, meshz, contour, surfc, surface, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
 function h = meshc (varargin)
 
-  newplot ();
-
-  tmp = surface (varargin{:});
-
-  ax = get (tmp, "parent");
-
-  set (tmp, "facecolor", "w");
-  set (tmp, "edgecolor", "flat");
-  ## FIXME - gnuplot does not support a filled surface and a
-  ## non-filled contour. 3D filled patches are also not supported.
-  ## Thus, the facecolor will be transparent for the gnuplot
-  ## backend.
-
-  if (! ishold ())
-    set (ax, "view", [-37.5, 30],
-         "xgrid", "on", "ygrid", "on", "zgrid", "on");
+  if (! all (cellfun ("isreal", varargin)))
+    error ("meshc: X, Y, Z, C arguments must be real");
   endif
 
-  drawnow ();
-  zmin = get (ax, "zlim")(1);
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("meshc", varargin{:});
+
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+
+    htmp = surface (varargin{:});
 
-  [c, tmp2] = __contour__ (ax, zmin, varargin{:});
+    ## FIXME - gnuplot does not support a filled surface and a
+    ## non-filled contour.  3D filled patches are also not supported.
+    ## Thus, the facecolor will be transparent for the gnuplot backend.
+    set (htmp, "facecolor", "w");
+    set (htmp, "edgecolor", "flat");
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on",
+                "xlimmode", "manual", "ylimmode", "manual");
+    endif
 
-  tmp = [tmp; tmp2];
+    drawnow ();
+
+    zmin = get (hax, "zlim")(1);
+    [~, htmp2] = __contour__ (hax, zmin, varargin{:});
+
+    htmp = [htmp; htmp2];
+
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
+
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! [X, Y] = meshgrid (linspace (-3, 3, 40));
+%! Z = sqrt (abs (X .* Y)) ./ (1 + X.^2 + Y.^2);
+%! meshc (X, Y, Z);
+%! title ('meshc() combines mesh/contour plots');
+
diff --git a/scripts/plot/meshz.m b/scripts/plot/draw/meshz.m
rename from scripts/plot/meshz.m
rename to scripts/plot/draw/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/draw/meshz.m
@@ -12,77 +12,151 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} meshz (@var{x}, @var{y}, @var{z})
-## Plot a curtain mesh given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
-## columns of @var{z} correspond to different @var{x} values and rows of
-## @var{z} correspond to different @var{y} values.
-## @seealso{meshgrid, mesh, contour}
+## @deftypefn  {Function File} {} meshz (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} meshz (@var{z})
+## @deftypefnx {Function File} {} meshz (@dots{}, @var{c})
+## @deftypefnx {Function File} {} meshz (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} meshz (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} meshz (@dots{})
+## Plot a 3-D wireframe mesh with a surrounding curtain.
+##
+## The wireframe mesh is plotted using rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
+##
+## The color of the mesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
+##
+## @seealso{mesh, meshc, contour, surf, surface, waterfall, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
-function retval = meshz (varargin)
-
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("meshz", varargin{:});
+function h = meshz (varargin)
 
-  ioff = nargin + 1;
-  for i = 1:nargin
-    if (ischar (varargin{i}))
-      ioff = i;
-      break;
-    endif
-  endfor
-
-  ## Bundle C matrix back into varargin
-  if (ioff == 3 || ioff == 5)
-    ioff --;
+  if (! all (cellfun ("isreal", varargin)))
+    error ("meshz: X, Y, Z, C arguments must be real");
   endif
 
-  if (ioff == 2)
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("meshz", varargin{:});
+
+  ## Find where property/value pairs start
+  charidx = find (cellfun ("isclass", varargin, "char"), 1);
+
+  have_c = false;
+  if (isempty (charidx))
+    if (nargin == 2 || nargin == 4) 
+      have_c = true;
+      charidx = nargin;   # bundle C matrix back into varargin 
+    else
+      charidx = nargin + 1;
+    endif
+  endif
+
+  if (charidx == 2)
     z = varargin{1};
     [m, n] = size (z);
     x = 1:n;
     y = (1:m).';
   else
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
   endif
 
-
   if (isvector (x) && isvector (y))
     x = [x(1), x(:).', x(end)];
     y = [y(1); y(:); y(end)];
   else
-    x = [x(1, 1), x(1, :), x(1, end);
-         x(:, 1), x, x(:, end);
-         x(end, 1), x(end, :), x(end, end)];
-    y = [y(1, 1), y(1, :), y(1, end);
-         y(:, 1), y, y(:, end);
-         y(end, 1), y(end, :), y(end, end)];
+    x = [x(1,1), x(1,:), x(1,end);
+         x(:,1), x, x(:,end);
+         x(end,1), x(end,:), x(end,end)];
+    y = [y(1,1), y(1,:), y(1,end);
+         y(:,1), y, y(:,end);
+         y(end,1), y(end,:), y(end,end)];
   endif
 
   zref = min (z(isfinite (z)));
   z = [zref .* ones(1, columns(z) + 2);
        zref .* ones(rows(z), 1), z, zref .* ones(rows(z), 1);
-       zref.* ones(1, columns(z) + 2)];
+       zref .* ones(1, columns(z) + 2)];
 
-  oldh = gca ();
+  if (have_c)
+    c = varargin{charidx};
+    cref = min (c(isfinite (c)));
+    c = [cref .* ones(1, columns(c) + 2);
+         cref .* ones(rows(c), 1), c, cref .* ones(rows(c), 1);
+         cref .* ones(1, columns(c) + 2)];
+    varargin(charidx) = c;
+  endif
+    
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    tmp = mesh (x, y, z, varargin{ioff:end});
+    hax = newplot (hax);
+    htmp = mesh (x, y, z, varargin{charidx:end});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
+
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! Z = peaks ();
+%! meshz (Z);
+%! title ('meshz() plot of peaks() function');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! Z = peaks ();
+%! subplot (1,2,1)
+%!  mesh (Z);
+%!  daspect ([2.5, 2.5, 1]);
+%!  title ('mesh() plot');
+%! subplot (1,2,2)
+%!  meshz (Z);
+%!  daspect ([2.5, 2.5, 1]);
+%!  title ('meshz() plot');
+
+%!demo
+%! clf;
+%! colormap ('default');
+%! [X,Y,Z] = peaks ();
+%! [fx, fy] = gradient (Z); 
+%! C = sqrt (fx.^2 + fy.^2);
+%! meshz (X,Y,Z,C);
+%! title ('meshz() plot with color determined by gradient');
+
diff --git a/scripts/plot/draw/module.mk b/scripts/plot/draw/module.mk
new file mode 100644
--- /dev/null
+++ b/scripts/plot/draw/module.mk
@@ -0,0 +1,104 @@
+FCN_FILE_DIRS += plot/draw
+
+plot_draw_PRIVATE_FCN_FILES = \
+  plot/draw/private/__add_datasource__.m \
+  plot/draw/private/__bar__.m \
+  plot/draw/private/__contour__.m \
+  plot/draw/private/__errcomm__.m \
+  plot/draw/private/__errplot__.m \
+  plot/draw/private/__ezplot__.m \
+  plot/draw/private/__interp_cube__.m \
+  plot/draw/private/__line__.m \
+  plot/draw/private/__marching_cube__.m \
+  plot/draw/private/__patch__.m \
+  plot/draw/private/__pie__.m \
+  plot/draw/private/__plt__.m \
+  plot/draw/private/__quiver__.m \
+  plot/draw/private/__scatter__.m \
+  plot/draw/private/__stem__.m
+
+plot_draw_FCN_FILES = \
+  plot/draw/area.m \
+  plot/draw/barh.m \
+  plot/draw/bar.m \
+  plot/draw/colorbar.m \
+  plot/draw/comet3.m \
+  plot/draw/comet.m \
+  plot/draw/compass.m \
+  plot/draw/contour3.m \
+  plot/draw/contourc.m \
+  plot/draw/contourf.m \
+  plot/draw/contour.m \
+  plot/draw/cylinder.m \
+  plot/draw/ellipsoid.m \
+  plot/draw/errorbar.m \
+  plot/draw/ezcontourf.m \
+  plot/draw/ezcontour.m \
+  plot/draw/ezmeshc.m \
+  plot/draw/ezmesh.m \
+  plot/draw/ezplot3.m \
+  plot/draw/ezplot.m \
+  plot/draw/ezpolar.m \
+  plot/draw/ezsurfc.m \
+  plot/draw/ezsurf.m \
+  plot/draw/feather.m \
+  plot/draw/fill.m \
+  plot/draw/fplot.m \
+  plot/draw/hist.m \
+  plot/draw/isocolors.m \
+  plot/draw/isonormals.m \
+  plot/draw/isosurface.m \
+  plot/draw/line.m \
+  plot/draw/loglogerr.m \
+  plot/draw/loglog.m \
+  plot/draw/meshc.m \
+  plot/draw/mesh.m \
+  plot/draw/meshz.m \
+  plot/draw/pareto.m \
+  plot/draw/patch.m \
+  plot/draw/pcolor.m \
+  plot/draw/peaks.m \
+  plot/draw/pie3.m \
+  plot/draw/pie.m \
+  plot/draw/plot3.m \
+  plot/draw/plot.m \
+  plot/draw/plotmatrix.m \
+  plot/draw/plotyy.m \
+  plot/draw/polar.m \
+  plot/draw/quiver3.m \
+  plot/draw/quiver.m \
+  plot/draw/rectangle.m \
+  plot/draw/ribbon.m \
+  plot/draw/rose.m \
+  plot/draw/scatter3.m \
+  plot/draw/scatter.m \
+  plot/draw/semilogxerr.m \
+  plot/draw/semilogx.m \
+  plot/draw/semilogyerr.m \
+  plot/draw/semilogy.m \
+  plot/draw/shrinkfaces.m \
+  plot/draw/slice.m \
+  plot/draw/sombrero.m \
+  plot/draw/sphere.m \
+  plot/draw/stairs.m \
+  plot/draw/stem3.m \
+  plot/draw/stemleaf.m \
+  plot/draw/stem.m \
+  plot/draw/surface.m \
+  plot/draw/surfc.m \
+  plot/draw/surfl.m \
+  plot/draw/surf.m \
+  plot/draw/surfnorm.m \
+  plot/draw/tetramesh.m \
+  plot/draw/trimesh.m \
+  plot/draw/triplot.m \
+  plot/draw/trisurf.m \
+  plot/draw/waterfall.m \
+  $(plot_draw_PRIVATE_FCN_FILES)
+
+FCN_FILES += $(plot_draw_FCN_FILES)
+
+PKG_ADD_FILES += plot/draw/PKG_ADD
+
+DIRSTAMP_FILES += plot/draw/$(octave_dirstamp)
+
diff --git a/scripts/plot/pareto.m b/scripts/plot/draw/pareto.m
rename from scripts/plot/pareto.m
rename to scripts/plot/draw/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/draw/pareto.m
@@ -13,95 +13,104 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} pareto (@var{x})
-## @deftypefnx {Function File} {} pareto (@var{x}, @var{y})
-## @deftypefnx {Function File} {} pareto (@var{h}, @dots{})
+## @deftypefn  {Function File} {} pareto (@var{y})
+## @deftypefnx {Function File} {} pareto (@var{y}, @var{x})
+## @deftypefnx {Function File} {} pareto (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} pareto (@dots{})
-## Draw a Pareto chart, also called ABC chart.  A Pareto chart is a bar graph
-## used to arrange information in such a way that priorities for process
-## improvement can be established.  It organizes and displays information
-## to show the relative importance of data.  The chart is similar to the
-## histogram or bar chart, except that the bars are arranged in decreasing
-## order from left to right along the abscissa.
+## Draw a Pareto chart.
+##
+## A Pareto chart is a bar graph that arranges information in such a way
+## that priorities for process improvement can be established; It organizes
+## and displays information to show the relative importance of data.  The chart
+## is similar to the histogram or bar chart, except that the bars are arranged
+## in decreasing magnitude from left to right along the x-axis.
 ##
 ## The fundamental idea (Pareto principle) behind the use of Pareto
 ## diagrams is that the majority of an effect is due to a small subset of the
-## causes, so for quality improvement the first few (as presented on the
-## diagram) contributing causes to a problem usually account for the majority
-## of the result.  Thus, targeting these "major causes" for elimination
-## results in the most cost-effective improvement scheme.
+## causes.  For quality improvement, the first few contributing causes 
+## (leftmost bars as presented on the diagram) to a problem usually account for
+## the majority of the result.  Thus, targeting these "major causes" for
+## elimination results in the most cost-effective improvement scheme.
 ##
-## The data are passed as @var{x} and the abscissa as @var{y}.  If @var{y} is
-## absent, then the abscissa are assumed to be @code{1 : length (@var{x})}.
-## @var{y} can be a string array, a cell array of strings, or a numerical
+## Typically only the magnitude data @var{y} is present in which case
+## @var{x} is taken to be the range @code{1 : length (@var{y})}.  If @var{x}
+## is given it may be a string array, a cell array of strings, or a numerical
 ## vector.
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## handle for the created bar plot and a second handle for the created line
 ## plot.
 ##
 ## An example of the use of @code{pareto} is
 ##
 ## @example
 ## @group
 ## Cheese = @{"Cheddar", "Swiss", "Camembert", ...
 ##           "Munster", "Stilton", "Blue"@};
 ## Sold = [105, 30, 70, 10, 15, 20];
 ## pareto (Sold, Cheese);
 ## @end group
 ## @end example
-## @seealso{bar, barh, pie, plot}
+## @seealso{bar, barh, hist, pie, plot}
 ## @end deftypefn
 
 function h = pareto (varargin)
 
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("pareto", varargin{:});
+
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
-  x = varargin {1}(:).';
+  y = varargin{1}(:).';
   if (nargin == 2)
-    y = varargin {2}(:).';
-    if (! iscell (y))
-      if (ischar (y))
-        y = cellstr (y);
+    x = varargin{2}(:).';
+    if (! iscell (x))
+      if (ischar (x))
+        x = cellstr (x);
       else
-        y = cellfun ("num2str", num2cell (y), "uniformoutput", false);
+        x = cellstr (num2str (x(:)));
       endif
     endif
   else
-    y = cellfun ("int2str", num2cell (1 : numel (x)),
-                 "uniformoutput", false);
+    x = cellstr (int2str ([1:numel(y)]'));
   endif
 
-  [x, idx] = sort (x, "descend");
-  y = y (idx);
-  cdf = cumsum (x);
-  maxcdf = max (cdf);
-  cdf = cdf ./ maxcdf;
-  cdf95 = cdf - 0.95;
-  idx95 = find (sign (cdf95(1:end-1)) != sign (cdf95(2:end)))(1);
+  [y, idx] = sort (y, "descend");
+  x = x(idx);
+  cdf = cumsum (y);
+  maxcdf = cdf(end);
+  cdf ./= maxcdf;
+  idx95 = find (cdf < 0.95, 1, "last") + 1;
 
-  [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95),
-                              1 : length (cdf), 100 .* cdf,
-                              @bar, @plot);
+  if (isempty (hax))
+    [ax, hbar, hline] = plotyy (1 : idx95, y(1:idx95),
+                                1 : length (cdf), 100 * cdf,
+                                @bar, @plot);
+  else
+    [ax, hbar, hline] = plotyy (hax, 1 : idx95, y(1:idx95),
+                                     1 : length (cdf), 100 * cdf,
+                                     @bar, @plot);
+  endif
 
   axis (ax(1), [1 - 0.6, idx95 + 0.6, 0, maxcdf]);
   axis (ax(2), [1 - 0.6, idx95 + 0.6, 0, 100]);
   set (ax(2), "ytick", [0, 20, 40, 60, 80, 100],
-       "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
-  set (ax(1), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
-  set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
+              "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
+  set (ax(1:2), "xtick", 1:idx95, "xticklabel", x(1:idx95));
 
   if (nargout > 0)
     h = [hbar; hline];
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/patch.m b/scripts/plot/draw/patch.m
rename from scripts/plot/patch.m
rename to scripts/plot/draw/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/draw/patch.m
@@ -16,50 +16,85 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} patch ()
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{fv})
-## @deftypefnx {Function File} {} patch ("Faces", @var{f}, "Vertices", @var{v}, @dots{})
-## @deftypefnx {Function File} {} patch (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} patch (@var{h}, @dots{})
+## @deftypefnx {Function File} {} patch ("Faces", @var{faces}, "Vertices", @var{verts}, @dots{})
+## @deftypefnx {Function File} {} patch (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} patch (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} patch (@dots{})
-## Create patch object from @var{x} and @var{y} with color @var{c} and
-## insert in the current axes object.  Return handle to patch object.
+## Create patch object in the current axes with vertices at locations
+## (@var{x}, @var{y}) and of color @var{c}.
+##
+## If the vertices are matrices of size @nospell{MxN} then each polygon patch
+## has M vertices and a total of N polygons will be created.  If some polygons
+## do not have M vertices use NaN to represent "no vertex".  If the @var{z}
+## input is present then 3-D patches will be created.
+##
+## The color argument @var{c} can take many forms.  To create polygons
+## which all share a single color use a string value (e.g., @qcode{"r"} for
+## red), a scalar value which is scaled by @code{caxis} and indexed into the
+## current colormap, or a 3-element RGB vector with the precise TrueColor.
 ##
-## For a uniform colored patch, @var{c} can be given as an RGB vector,
-## scalar value referring to the current colormap, or string value (for
-## example, "r" or "red").
+## If @var{c} is a vector of length N then the ith polygon will have a color
+## determined by scaling entry @var{c}(i) according to @code{caxis} and then
+## indexing into the current colormap.  More complicated coloring situations
+## require directly manipulating patch property/value pairs.
 ##
-## If passed a structure @var{fv} contain the fields "vertices", "faces"
-## and optionally "facevertexcdata", create the patch based on these
-## properties.
+## Instead of specifying polygons by matrices @var{x} and @var{y}, it is
+## possible to present a unique list of vertices and then a list of polygon
+## faces created from those vertices.  In this case the
+## @qcode{"Vertices"} matrix will be an @nospell{Nx2} (2-D patch) or
+## @nospell{Nx3} (3-D path).  The @nospell{MxN} @qcode{"Faces"} matrix
+## describes M polygons having N vertices---each row describes a
+## single polygon and each column entry is an index into the
+## @qcode{"Vertices"} matrix to identify a vertex.  The patch object
+## can be created by directly passing the property/value pairs
+## @qcode{"Vertices"}/@var{verts}, @qcode{"Faces"}/@var{faces} as
+## inputs.
+##
+## A third input form is to create a structure @var{fv} with the fields
+## @qcode{"vertices"}, @qcode{"faces"}, and optionally
+## @qcode{"facevertexcdata"}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created patch
 ## object.
-## @seealso{fill}
+##
+## Implementation Note: Patches are highly configurable objects.  To truly
+## customize them requires setting patch properties directly.  Useful patch
+## properties are: @qcode{"cdata"}, @qcode{"edgecolor"},
+## @qcode{"facecolor"}, @qcode{"faces"}, @qcode{"facevertexcdata"}.
+## @seealso{fill, get, set}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = patch (varargin)
+function h = patch (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
-
-  [tmp, failed] = __patch__ (h, varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
+  
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
+  [htmp, failed] = __patch__ (hax, varargin{:});
 
   if (failed)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! %% Patches with same number of vertices
 %! clf;
@@ -184,17 +219,16 @@ endfunction
 %!  patch (x + 2, y, 17 * ones (size (x)), 'cdatamapping', 'direct');
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, 'facecolor', 'b');
-%! title ('Two blue triangles');
 %! set (p, 'cdatamapping', 'direct', 'facecolor', 'flat', 'cdata', [1 32]);
 %! title ('Direct mapping of colors: Light-Green UL and Blue LR triangles');
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
diff --git a/scripts/plot/pcolor.m b/scripts/plot/draw/pcolor.m
rename from scripts/plot/pcolor.m
rename to scripts/plot/draw/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/draw/pcolor.m
@@ -14,83 +14,106 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pcolor (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} pcolor (@var{c})
-## Produce a density plot for matrices @var{x} and @var{y} from
-## @code{meshgrid}, and a matrix @var{c} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh's vertices.  If @var{x} and @var{y} are
-## vectors, then a typical vertex is (@var{x}(j), @var{y}(i), @var{c}(i,j)). 
+## @deftypefnx {Function File} {} pcolor (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} pcolor (@dots{})
+## Produce a 2-D density plot.
+##
+## A @code{pcolor} plot draws rectangles with colors from the matrix @var{c}
+## over the two-dimensional region represented by the matrices @var{x} and
+## @var{y}.  @var{x} and @var{y} are the coordinates of the mesh's vertices
+## and are typically the output of @code{meshgrid}.  If @var{x} and @var{y} are
+## vectors, then a typical vertex is (@var{x}(j), @var{y}(i), @var{c}(i,j)).
 ## Thus, columns of @var{c} correspond to different @var{x} values and rows
 ## of @var{c} correspond to different @var{y} values.
 ##
-## The @code{colormap} is scaled to the extents of @var{c}.
-## Limits may be placed on the color axis by the command @code{caxis}, or by
-## setting the @code{clim} property of the parent axis.
+## The values in @var{c} are scaled to span the range of the current
+## colormap.  Limits may be placed on the color axis by the command
+## @code{caxis}, or by setting the @code{clim} property of the parent axis.
 ##
 ## The face color of each cell of the mesh is determined by interpolating
-## the values of @var{c} for the cell's vertices.  Contrast this with
+## the values of @var{c} for each of the cell's vertices; Contrast this with
 ## @code{imagesc} which renders one cell for each element of @var{c}.
 ##
 ## @code{shading} modifies an attribute determining the manner by which the
 ## face color of each cell is interpolated from the values of @var{c},
 ## and the visibility of the cells' edges.  By default the attribute is
-## "faceted", which renders a single color for each cell's face with the edge
-## visible.
+## @qcode{"faceted"}, which renders a single color for each cell's face with
+## the edge visible.
 ##
-## The optional return value @var{h} is a handle to the surface object.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## @seealso{caxis, contour, meshgrid, imagesc, shading}
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
+##
+## @seealso{caxis, shading, meshgrid, contour, imagesc}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
-function h = pcolor (x, y, c)
+function h = pcolor (varargin)
 
-  newplot ();
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("pcolor", varargin{:});
 
   if (nargin == 1)
-    c = x;
+    c = varargin{1};
     [nr, nc] = size (c);
+    [x, y] = meshgrid (1:nc, 1:nr);
     z = zeros (nr, nc);
-    [x, y] = meshgrid (1:nc, 1:nr);
   elseif (nargin == 3)
+    x = varargin{1};
+    y = varargin{2};
+    c = varargin{3};
     z = zeros (size (c));
   else
     print_usage ();
   endif
 
-  tmp = surface (x, y, z, c);
-
-  ax = get (tmp, "parent");
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+    htmp = surface (x, y, z, c);
 
-  set (tmp, "facecolor", "flat");
-  set (ax, "box", "on");
+    set (htmp, "facecolor", "flat");
+    if (! ishold ())
+      set (hax, "view", [0, 90], "box", "on");
+    endif
 
-  if (! ishold ())
-    set (ax, "view", [0, 90]);
-  endif
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = peaks ();
+%! Z = peaks ();
 %! pcolor (Z);
+%! title ('pcolor() of peaks with facet shading');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [X,Y,Z] = sombrero ();
 %! [Fx,Fy] = gradient (Z);
 %! pcolor (X,Y,Fx+Fy);
 %! shading interp;
+%! axis tight;
+%! title ('pcolor() of peaks with interp shading');
 
diff --git a/scripts/plot/peaks.m b/scripts/plot/draw/peaks.m
rename from scripts/plot/peaks.m
rename to scripts/plot/draw/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/draw/peaks.m
@@ -17,39 +17,47 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} peaks ()
 ## @deftypefnx {Function File} {} peaks (@var{n})
 ## @deftypefnx {Function File} {} peaks (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} peaks (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} peaks (@dots{})
-## Generate a function with lots of local maxima and minima.  The function
-## has the form
+## Plot a function with lots of local maxima and minima.
+##
+## The function has the form
 ##
 ## @tex
-## $f(x,y) = 3 (1 - x) ^ 2 e ^ {\left(-x^2 - (y+1)^2\right)} - 10 \left({x \over 5} - x^3 - y^5)\right) - {1 \over 3} e^{\left(-(x+1)^2 - y^2\right)}$
+## $$f(x,y) = 3 (1 - x) ^ 2 e ^ {\left(-x^2 - (y+1)^2\right)} - 10 \left({x \over 5} - x^3 - y^5)\right) - {1 \over 3} e^{\left(-(x+1)^2 - y^2\right)}$$
 ## @end tex
 ## @ifnottex
 ## @verbatim
 ## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
 ##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
 ##          - 1/3*exp(-(x+1)^2 - y^2)
 ## @end verbatim
 ## @end ifnottex
 ##
 ## Called without a return argument, @code{peaks} plots the surface of the
-## above function using @code{mesh}.  If @var{n} is a scalar, the @code{peaks}
-## returns the values of the above function on a @var{n}-by-@var{n} mesh over
-## the range @code{[-3,3]}.  The default value for @var{n} is 49.
+## above function using @code{surf}.
+## 
+## If @var{n} is a scalar, @code{peaks} plots the value of the above
+## function on an @var{n}-by-@var{n} mesh over the range [-3,3].  The
+## default value for @var{n} is 49.
 ##
-## If @var{n} is a vector, then it represents the @var{x} and @var{y} values
-## of the grid on which to calculate the above function.  The @var{x} and
-## @var{y} values can be specified separately.
-## @seealso{surf, mesh, meshgrid}
+## If @var{n} is a vector, then it represents the grid values over which
+## to calculate the function.  If @var{x} and @var{y} are specified then
+## the function value is calculated over the specified grid of vertices.
+##
+## When called with output arguments, return the data for the function
+## evaluated over the meshgrid.  This can subsequently be plotted with
+## @code{surf (@var{x}, @var{y}, @var{z})}.
+## 
+## @seealso{sombrero, meshgrid, mesh, surf}
 ## @end deftypefn
 
 ## Expression for the peaks function was taken from the following paper:
 ## http://www.control.hut.fi/Kurssit/AS-74.115/Material/GENALGgoga.pdf
 
 function [X_out, Y_out, Z_out] = peaks (x, y)
 
   if (nargin == 0)
@@ -79,8 +87,9 @@ function [X_out, Y_out, Z_out] = peaks (
     X_out = Z;
   else
     X_out = X;
     Y_out = Y;
     Z_out = Z;
   endif
 
 endfunction
+
diff --git a/scripts/plot/pie.m b/scripts/plot/draw/pie.m
rename from scripts/plot/pie.m
rename to scripts/plot/draw/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/draw/pie.m
@@ -13,75 +13,91 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie (@var{x})
-## @deftypefnx {Function File} {} pie (@var{x}, @var{explode})
+## @deftypefnx {Function File} {} pie (@dots{}, @var{explode})
 ## @deftypefnx {Function File} {} pie (@dots{}, @var{labels})
-## @deftypefnx {Function File} {} pie (@var{h}, @dots{});
+## @deftypefnx {Function File} {} pie (@var{hax}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
 ## Plot a 2-D pie chart.
 ##
 ## When called with a single vector argument, produce a pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
-## element @var{x}i represents of the total sum of @var{x}.
+## element @var{x}i represents of the total sum of @var{x}:
+## @code{pct = @var{x}(i) / sum (@var{x})}. 
 ##
-## The variable @var{explode} is a vector of the same length as @var{x} that,
-## if non-zero, "explodes" the slice from the pie chart.
+## The optional input @var{explode} is a vector of the same length as @var{x}
+## that, if non-zero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
+## 
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
 ## and text objects generating the plot.
 ##
-## @seealso{pie3, bar, stem}
+## Note: If @code{sum (@var{x}) @leq{} 1} then the elements of @var{x} are
+## interpreted as percentages directly and are not normalized by @code{sum (x)}.
+## Furthermore, if the sum is less than 1 then there will be a missing slice
+## in the pie plot to represent the missing, unspecified percentage.
+##
+## @seealso{pie3, bar, hist, rose}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
-function retval = pie (varargin)
+function h = pie (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("pie", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("pie", varargin{:});
 
   if (nargin < 1)
     print_usage ();
-  else
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __pie__ ("pie", h, varargin{:});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
   endif
 
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+    htmp = __pie__ ("pie", hax, varargin{:});
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
+
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! pie ([3, 2, 1], [0, 0, 1]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! title ('pie() with exploded wedge');
 
 %!demo
 %! clf;
 %! pie ([3, 2, 1], [0, 0, 1], {'Cheddar', 'Swiss', 'Camembert'});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
+%! title ('pie() with labels');
+
 
 %!demo
 %! clf;
 %! pie ([0.17, 0.34, 0.41], {'Cheddar', 'Swiss', 'Camembert'});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
-%! title ('missing slice');
+%! title ('pie() with missing slice');
 
diff --git a/scripts/plot/pie3.m b/scripts/plot/draw/pie3.m
rename from scripts/plot/pie3.m
rename to scripts/plot/draw/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/draw/pie3.m
@@ -14,75 +14,90 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie3 (@var{x})
-## @deftypefnx {Function File} {} pie3 (@var{x}, @var{explode})
+## @deftypefnx {Function File} {} pie3 (@dots{}, @var{explode})
 ## @deftypefnx {Function File} {} pie3 (@dots{}, @var{labels})
-## @deftypefnx {Function File} {} pie3 (@var{h}, @dots{});
+## @deftypefnx {Function File} {} pie3 (@var{hax}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie3 (@dots{});
 ## Plot a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
-## element @var{x}i represents of the total sum of @var{x}.
+## element @var{x}i represents of the total sum of @var{x}:
+## @code{pct = @var{x}(i) / sum (@var{x})}. 
 ##
-## The variable @var{explode} is a vector of the same length as @var{x} that,
-## if non-zero, "explodes" the slice from the pie chart.
+## The optional input @var{explode} is a vector of the same length as @var{x}
+## that, if non-zero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
 ##
-## The optional return value @var{h} is a list of graphics handles to the patch,
-## surface, and text objects generating the plot.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a list of graphics handles to the
+## patch, surface, and text objects generating the plot.
 ##
-## @seealso{pie, bar, stem}
+## Note: If @code{sum (@var{x}) @leq{} 1} then the elements of @var{x} are
+## interpreted as percentages directly and are not normalized by @code{sum (x)}.
+## Furthermore, if the sum is less than 1 then there will be a missing slice
+## in the pie plot to represent the missing, unspecified percentage.
+##
+## @seealso{pie, bar, hist, rose}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
-function retval = pie3 (varargin)
+function h = pie3 (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("pie", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("pie3", varargin{:});
 
   if (nargin < 1)
     print_usage ();
-  else
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __pie__ ("pie3", h, varargin{:});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
   endif
 
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+    htmp = __pie__ ("pie3", hax, varargin{:});
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
+
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
+%! title ('pie3() with exploded wedge');
 
 %!demo
 %! clf;
 %! pie3 ([3, 2, 1], [0, 0, 1], {'Cheddar', 'Swiss', 'Camembert'});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
+%! title ('pie3() with labels');
 
 %!demo
 %! clf;
 %! pie3 ([0.17, 0.34, 0.41], {'Cheddar', 'Swiss', 'Camembert'});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
-%! title ('missing slice');
+%! title ('pie3() with missing slice');
 
diff --git a/scripts/plot/plot.m b/scripts/plot/draw/plot.m
rename from scripts/plot/plot.m
rename to scripts/plot/draw/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/draw/plot.m
@@ -14,36 +14,33 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} plot (@var{y})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y})
-## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{fmt})
-## @deftypefnx {Function File} {} plot (@var{h}, @dots{})
+## @deftypefnx {Function File} {} plot (@dots{}, @var{property}, @var{value}, @dots{})
+## @deftypefnx {Function File} {} plot (@var{x1}, @var{y1}, @dots{}, @var{xn}, @var{yn})
+## @deftypefnx {Function File} {} plot (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} plot (@dots{})
-## Produce two-dimensional plots.
+## Produce 2-D plots.
 ##
 ## Many different combinations of arguments are possible.  The simplest
 ## form is
 ##
 ## @example
 ## plot (@var{y})
 ## @end example
 ##
 ## @noindent
 ## where the argument is taken as the set of @var{y} coordinates and the
-## @var{x} coordinates are taken to be the indices of the elements
-## starting with 1.
-##
-## To save a plot, in one of several image formats such as PostScript
-## or PNG, use the @code{print} command.
+## @var{x} coordinates are taken to be the range @code{1:numel (@var{y})}.
 ##
 ## If more than one argument is given, they are interpreted as
 ##
 ## @example
 ## plot (@var{y}, @var{property}, @var{value}, @dots{})
 ## @end example
 ##
 ## @noindent
@@ -66,159 +63,223 @@
 ##
 ## @itemize @bullet
 ## @item
 ## If a single data argument is supplied, it is taken as the set of @var{y}
 ## coordinates and the @var{x} coordinates are taken to be the indices of
 ## the elements, starting with 1.
 ##
 ## @item
-## If the @var{x} is a vector and @var{y} is a matrix, then
+## If @var{x} and @var{y} are scalars, a single point is plotted.
+##
+## @item
+## @code{squeeze()} is applied to arguments with more than two dimensions,
+## but no more than two singleton dimensions.
+## 
+## @item
+## If both arguments are vectors, the elements of @var{y} are plotted versus
+## the elements of @var{x}.
+##
+## @item
+## If @var{x} is a vector and @var{y} is a matrix, then
 ## the columns (or rows) of @var{y} are plotted versus @var{x}.
 ## (using whichever combination matches, with columns tried first.)
 ##
 ## @item
 ## If the @var{x} is a matrix and @var{y} is a vector,
 ## @var{y} is plotted versus the columns (or rows) of @var{x}.
 ## (using whichever combination matches, with columns tried first.)
 ##
 ## @item
-## If both arguments are vectors, the elements of @var{y} are plotted versus
-## the elements of @var{x}.
-##
-## @item
 ## If both arguments are matrices, the columns of @var{y} are plotted
 ## versus the columns of @var{x}.  In this case, both matrices must have
 ## the same number of rows and columns and no attempt is made to transpose
 ## the arguments to make the number of rows match.
-##
-## If both arguments are scalars, a single point is plotted.
 ## @end itemize
 ##
 ## Multiple property-value pairs may be specified, but they must appear
-## in pairs.  These arguments are applied to the lines drawn by
-## @code{plot}.
+## in pairs.  These arguments are applied to the line objects drawn by
+## @code{plot}.  Useful properties to modify are @qcode{"linestyle"},
+## @qcode{"linewidth"}, @qcode{"color"}, @qcode{"marker"},
+## @qcode{"markersize"}, @qcode{"markeredgecolor"}, @qcode{"markerfacecolor"}.
 ##
-## If the @var{fmt} argument is supplied, it is interpreted as
-## follows.  If @var{fmt} is missing, the default gnuplot line style
-## is assumed.
+## The @var{fmt} format argument can also be used to control the plot style.
+## The format is composed of three parts: linestyle, markerstyle, color. 
+## When a markerstyle is specified, but no linestyle, only the markers are
+## plotted.  Similarly, if a linestyle is specified, but no markerstyle, then
+## only lines are drawn.  If both are specified then lines and markers will
+## be plotted.  If no @var{fmt} and no @var{property}/@var{value} pairs are
+## given, then the default plot style is solid lines with no markers and the
+## color determined by the @qcode{"colororder"} property of the current axes.
 ##
-## @table @samp
-## @item -
-## Set lines plot style (default).
+## Format arguments:
+##
+## @table @asis
+## @item linestyle
 ##
-## @item .
-## Set dots plot style.
+## @multitable @columnfractions 0.06 0.94
+## @item @samp{-}  @tab Use solid lines (default).
+## @item @samp{--} @tab Use dashed lines.
+## @item @samp{:}  @tab Use dotted lines.
+## @item @samp{-.} @tab Use dash-dotted lines.
+## @end multitable
 ##
-## @item @var{n}
-## Interpreted as the plot color if @var{n} is an integer in the range 1 to
-## 6.
+## @item markerstyle
 ##
-## @item @var{nm}
-## If @var{nm} is a two digit integer and @var{m} is an integer in the
-## range 1 to 6, @var{m} is interpreted as the point style.  This is only
-## valid in combination with the @code{@@} or @code{-@@} specifiers.
-##
-## @item @var{c}
-## If @var{c} is one of @code{"k"} (black), @code{"r"} (red), @code{"g"}
-## (green), @code{"b"} (blue), @code{"m"} (magenta), @code{"c"} (cyan),
-## or @code{"w"} (white), it is interpreted as the line plot color.
+## @multitable @columnfractions 0.06 0.94
+## @item @samp{+} @tab crosshair
+## @item @samp{o} @tab circle
+## @item @samp{*} @tab star
+## @item @samp{.} @tab point
+## @item @samp{x} @tab cross
+## @item @samp{s} @tab square
+## @item @samp{d} @tab diamond
+## @item @samp{^} @tab upward-facing triangle
+## @item @samp{v} @tab downward-facing triangle
+## @item @samp{>} @tab right-facing triangle
+## @item @samp{<} @tab left-facing triangle
+## @item @samp{p} @tab pentagram
+## @item @samp{h} @tab hexagram
+## @end multitable
 ##
-## @item ";title;"
-## Here @code{"title"} is the label for the key.
+## @item color
 ##
-## @item +
-## @itemx *
-## @itemx o
-## @itemx x
-## @itemx ^
-## Used in combination with the points or linespoints styles, set the point
-## style.
+## @multitable @columnfractions 0.06 0.94
+## @item @samp{k} @tab blacK
+## @item @samp{r} @tab Red
+## @item @samp{g} @tab Green
+## @item @samp{b} @tab Blue
+## @item @samp{m} @tab Magenta
+## @item @samp{c} @tab Cyan
+## @item @samp{w} @tab White
+## @end multitable
 ##
-## @item @@
-## Select the next unused point style.
+## @item @qcode{";key;"}
+## Here @qcode{"key"} is the label to use for the plot legend.
 ## @end table
 ##
-## The @var{fmt} argument may also be used to assign key titles.
-## To do so, include the desired title between semi-colons after the
-## formatting sequence described above, e.g., "+3;Key Title;"
-## Note that the last semi-colon is required and will generate an error if
-## it is left out.
+## The @var{fmt} argument may also be used to assign legend keys.
+## To do so, include the desired label between semicolons after the
+## formatting sequence described above, e.g., @qcode{"+b;Key Title;"}.
+## Note that the last semicolon is required and Octave will generate
+## an error if it is left out.
 ##
 ## Here are some plot examples:
 ##
 ## @example
-## plot (x, y, "@@12", x, y2, x, y3, "4", x, y4, "+")
+## plot (x, y, "or", x, y2, x, y3, "m", x, y4, "+")
 ## @end example
 ##
-## This command will plot @code{y} with points of type 2 (displayed as
-## @samp{+}) and color 1 (red), @code{y2} with lines, @code{y3} with lines of
-## color 4 (magenta) and @code{y4} with points displayed as @samp{+}.
+## This command will plot @code{y} with red circles, @code{y2} with solid
+## lines, @code{y3} with solid magenta lines, and @code{y4} with points
+## displayed as @samp{+}.
 ##
 ## @example
-## plot (b, "*", "markersize", 3)
+## plot (b, "*", "markersize", 10)
 ## @end example
 ##
 ## This command will plot the data in the variable @code{b},
-## with points displayed as @samp{*} with a marker size of 3.
+## with points displayed as @samp{*} and a marker size of 10.
 ##
 ## @example
 ## @group
 ## t = 0:0.1:6.3;
-## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
+## plot (t, cos(t), "-;cos(t);", t, sin(t), "-b;sin(t);");
 ## @end group
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
-## in the key.
+## in the legend.
 ##
-## If the first argument is an axis handle, then plot into these axes,
-## rather than the current axis handle returned by @code{gca}.
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## The optional return value @var{h} is a graphics handle to the created plot.
+## The optional return value @var{h} is a vector of graphics handles to
+## the created line objects.
 ##
-## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
-## stairs, errorbar, xlabel, ylabel, title, print}
+## To save a plot, in one of several image formats such as PostScript
+## or PNG, use the @code{print} command.
+##
+## @seealso{axis, box, grid, hold, legend, title, xlabel, ylabel, xlim, ylim, ezplot, errorbar, fplot, line, plot3, polar, loglog, semilogx, semilogy, subplot}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = plot (varargin)
+function h = plot (varargin)
 
-  [h, varargin, nargs] = __plt_get_axis_arg__ ("plot", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("plot", varargin{:});
 
   if (nargs < 1)
     print_usage ();
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    tmp = __plt__ ("plot", h, varargin{:});
+    hax = newplot (hax);
+    htmp = __plt__ ("plot", hax, varargin{:});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! x = 1:5;  y = 1:5;
 %! plot (x,y,'g');
-%! title ('plot of green line at 45 degrees');
+%! title ('plot() of green line at 45 degrees');
 
 %!demo
 %! x = 1:5;  y = 1:5;
 %! plot (x,y,'g*');
-%! title ('plot of green stars along a line at 45 degrees');
+%! title ('plot() of green stars along a line at 45 degrees');
 
 %!demo
 %! x1 = 1:5;  y1 = 1:5;
 %! x2 = 5:9; y2 = 5:-1:1;
 %! plot (x1,y1,'bo-', x2,y2,'rs-');
 %! axis ('tight');
-%! title ('plot of blue circles ascending and red squares descending with connecting lines drawn'); 
+%! title ({'plot() of blue circles ascending and red squares descending';
+%!         'connecting lines drawn'}); 
+
+%!demo
+%! x = 0:10;
+%! plot (x, rand (numel (x), 3))
+%! axis ([0 10 0 1])
+%! title ({'Three random variables', 'x[1x11], y[11x3]'})
+
+%!demo
+%! x = 0:10;
+%! plot (x, rand (3, numel (x)))
+%! axis ([0 10 0 1])
+%! title ({'Three random variables', 'x[1x11], y[3x11]'})
 
+%!demo
+%! x = 0:10;
+%! plot (repmat (x, 2, 1), rand (2, numel (x)), '-s')
+%! axis ([0 10 0 1])
+%! title ({'Vertical lines with random height and lengths', ...
+%!         'x[2x11], y[2,11]'})
+
+%!demo
+%! x = 0:10;
+%! plot (repmat (x(:), 1, 2), rand (numel (x), 2))
+%! axis ([0 10 0 1])
+%! title ({'Two random variables', 'x[11x2], y[11x2]'})
+
+%!demo
+%! x = 0:10;
+%! shape = [1, 1, numel(x), 2];
+%! x = reshape (repmat (x(:), 1, 2), shape);
+%! y = rand (shape);
+%! plot (x, y)
+%! axis ([0 10 0 1])
+%! title ({'Two random variables', 'squeezed from 4-d arrays'})
+
diff --git a/scripts/plot/plot3.m b/scripts/plot/draw/plot3.m
rename from scripts/plot/plot3.m
rename to scripts/plot/draw/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/draw/plot3.m
@@ -12,46 +12,53 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} plot3 (@var{args})
-## Produce three-dimensional plots.  Many different combinations of
-## arguments are possible.  The simplest form is
+## @deftypefn  {Function File} {} plot3 (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} plot3 (@var{x}, @var{y}, @var{z}, @var{prop}, @var{value}, @dots{})
+## @deftypefnx {Function File} {} plot3 (@var{x}, @var{y}, @var{z}, @var{fmt})
+## @deftypefnx {Function File} {} plot3 (@var{x}, @var{cplx})
+## @deftypefnx {Function File} {} plot3 (@var{cplx})
+## @deftypefnx {Function File} {} plot3 (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} plot3 (@dots{})
+## Produce 3-D plots.
+##
+## Many different combinations of arguments are possible.  The simplest
+## form is
 ##
 ## @example
 ## plot3 (@var{x}, @var{y}, @var{z})
 ## @end example
 ##
 ## @noindent
 ## in which the arguments are taken to be the vertices of the points to
 ## be plotted in three dimensions.  If all arguments are vectors of the
 ## same length, then a single continuous line is drawn.  If all arguments
-## are matrices, then each column of the matrices is treated as a
-## separate line.  No attempt is made to transpose the arguments to make
-## the number of rows match.
+## are matrices, then each column of is treated as a separate line.  No attempt
+## is made to transpose the arguments to make the number of rows match.
 ##
 ## If only two arguments are given, as
 ##
 ## @example
-## plot3 (@var{x}, @var{c})
+## plot3 (@var{x}, @var{cplx})
 ## @end example
 ##
 ## @noindent
 ## the real and imaginary parts of the second argument are used
 ## as the @var{y} and @var{z} coordinates, respectively.
 ##
 ## If only one argument is given, as
 ##
 ## @example
-## plot3 (@var{c})
+## plot3 (@var{cplx})
 ## @end example
 ##
 ## @noindent
 ## the real and imaginary parts of the argument are used as the @var{y}
 ## and @var{z} values, and they are plotted versus their index.
 ##
 ## Arguments may also be given in groups of three as
 ##
@@ -65,283 +72,317 @@
 ##
 ## To plot multiple one- or two-argument groups, separate each group
 ## with an empty format string, as
 ##
 ## @example
 ## plot3 (@var{x1}, @var{c1}, "", @var{c2}, "", @dots{})
 ## @end example
 ##
-## An example of the use of @code{plot3} is
+## Multiple property-value pairs may be specified which will affect the line
+## objects drawn by @code{plot3}.  If the @var{fmt} argument is supplied it
+## will format the line objects in the same manner as @code{plot}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created plot.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## z = [0:0.05:5];
 ## plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
 ## plot3 (z, exp (2i*pi*z), ";complex sinusoid;");
 ## @end group
 ## @end example
-## @seealso{plot, xlabel, ylabel, zlabel, title, print}
+## @seealso{ezplot3, plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ##         (modified from __plt__.m)
 
 function retval = plot3 (varargin)
 
-  newplot ();
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("plot3", varargin{:});
+
+  if (nargs < 1)
+    print_usage ();
+  endif
+
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+
+    x_set = 0;
+    y_set = 0;
+    z_set = 0;
+    property_set = 0;
+    fmt_set = 0;
+    properties = {};
+    tlgnd = {};
+    hlgnd = [];
+    idx = 0;
+
+    ## Gather arguments, decode format, and plot lines.
+    arg = 0;
+    while (arg++ < nargs)
+      new = varargin{arg};
+      new_cell = varargin(arg);
+
+      if (property_set)
+        properties = [properties, new_cell];
+        property_set = 0;
+        continue;
+      endif
+
+      if (ischar (new))
+        if (! z_set)
+          if (! y_set)
+            if (! x_set)
+              error ("plot3: needs X, [ Y, [ Z ] ]");
+            else
+              y = real (x);
+              z = imag (x);
+              y_set = 1;
+              z_set = 1;
+              if (rows (x) > 1)
+                x = repmat ((1:rows (x))', 1, columns (x));
+              else
+                x = 1:columns (x);
+              endif
+            endif
+          else
+            z = imag (y);
+            y = real (y);
+            z_set = 1;
+          endif
+        endif
+
+        if (! fmt_set)
+          [options, valid] = __pltopt__ ("plot3", new, false);
+          if (! valid)
+            properties = [properties, new_cell];
+            property_set = 1;
+            continue;
+          else
+            fmt_set = 1;
+            while (arg < nargs && ischar (varargin{arg+1}))
+              if (nargs - arg < 2)
+                error ("plot3: properties must appear followed by a value");
+              endif
+              properties = [properties, varargin(arg+1:arg+2)];
+              arg += 2;
+            endwhile
+          endif
+        else
+          properties = [properties, new_cell];
+          property_set = 1;
+          continue;
+        endif
 
-  x_set = 0;
-  y_set = 0;
-  z_set = 0;
-  property_set = 0;
-  fmt_set = 0;
-  properties = {};
-  tlgnd = {};
-  hlgnd = [];
-  idx = 0;
+        if (isvector (x) && isvector (y))
+          if (isvector (z))
+            x = x(:);
+            y = y(:);
+            z = z(:);
+          elseif (length (x) == rows (z) && length (y) == columns (z))
+            [x, y] = meshgrid (x, y);
+          else
+            error ("plot3: [length(X), length(Y)] must match size (Z)");
+          endif
+        endif
+
+        if (! size_equal (x, y, z))
+          error ("plot3: X, Y, and Z must have the same shape");
+        elseif (ndims (x) > 2)
+          error ("plot3: X, Y, and Z must not have more than two dimensions");
+        endif
+
+        for i = 1 : columns (x)
+          linestyle = options.linestyle;
+          marker = options.marker;
+          if (isempty (marker) && isempty (linestyle))
+             [linestyle, marker] = __next_line_style__ ();
+          endif
+          color = options.color;
+          if (isempty (color))
+            color = __next_line_color__ ();
+          endif
+
+          htmp(++idx) = line (x(:, i), y(:, i), z(:, i),
+                              "color", color, "linestyle", linestyle,
+                              "marker", marker, properties{:});
+          key = options.key;
+          if (! isempty (key))
+            hlgnd = [hlgnd, htmp(idx)];
+            tlgnd = {tlgnd{:}, key};
+          endif
+        endfor
 
-  ## Gather arguments, decode format, and plot lines.
-  arg = 0;
-  while (arg++ < nargin)
-    new = varargin{arg};
-    new_cell = varargin(arg);
+        x_set = 0;
+        y_set = 0;
+        z_set = 0;
+        fmt_set = 0;
+        properties = {};
+      elseif (! x_set)
+        x = new;
+        x_set = 1;
+      elseif (! y_set)
+        y = new;
+        y_set = 1;
+      elseif (! z_set)
+        z = new;
+        z_set = 1;
+      else
+        if (isvector (x) && isvector (y))
+          if (isvector (z))
+            x = x(:);
+            y = y(:);
+            z = z(:);
+          elseif (length (x) == rows (z) && length (y) == columns (z))
+            [x, y] = meshgrid (x, y);
+          else
+            error ("plot3: [length(X), length(Y)] must match size (Z)");
+          endif
+        endif
+
+        if (! size_equal (x, y, z))
+          error ("plot3: X, Y, and Z must have the same shape");
+        elseif (ndims (x) > 2)
+          error ("plot3: X, Y, and Z must not have more than two dimensions");
+        endif
+
+        options = __default_plot_options__ ();
+        for i = 1 : columns (x)
+          linestyle = options.linestyle;
+          marker = options.marker;
+          if (isempty (marker) && isempty (linestyle))
+            [linestyle, marker] = __next_line_style__ ();
+          endif
+          color = options.color;
+          if (isempty (color))
+            color = __next_line_color__ ();
+          endif
+
+          htmp(++idx) = line (x(:, i), y(:, i), z(:, i),
+                              "color", color, "linestyle", linestyle,
+                              "marker", marker, properties{:});
+          key = options.key;
+          if (! isempty (key))
+            hlgnd = [hlgnd, htmp(idx)];
+            tlgnd = {tlgnd{:}, key};
+          endif
+        endfor
+
+        x = new;
+        y_set = 0;
+        z_set = 0;
+        fmt_set = 0;
+        properties = {};
+      endif
+
+    endwhile
 
     if (property_set)
-      properties = [properties, new_cell];
-      property_set = 0;
-      continue;
+      error ("plot3: properties must appear followed by a value");
     endif
 
-    if (ischar (new))
-      if (! z_set)
-        if (! y_set)
-          if (! x_set)
-            error ("plot3: needs x, [ y, [ z ] ]");
-          else
-            z = imag (x);
-            y = real (x);
-            y_set = 1;
-            z_set = 1;
-            if (rows (x) > 1)
-              x = repmat ((1:rows (x))', 1, columns (x));
-            else
-              x = 1:columns (x);
-            endif
-          endif
-        else
+    ## Handle last plot.
+
+    if (x_set)
+      if (y_set)
+        if (! z_set)
           z = imag (y);
           y = real (y);
           z_set = 1;
         endif
-      endif
-
-      if (! fmt_set)
-        [options, valid] = __pltopt__ ("plot3", new, false);
-        if (! valid)
-          properties = [properties, new_cell];
-          property_set = 1;
-          continue;
+      else
+        y = real (x);
+        z = imag (x);
+        y_set = 1;
+        z_set = 1;
+        if (rows (x) > 1)
+          x = repmat ((1:rows (x))', 1, columns (x));
         else
-          fmt_set = 1;
-          while (arg < nargin && ischar (varargin{arg+1}))
-            if (nargin - arg < 2)
-              error ("plot3: properties must appear followed by a value");
-            endif
-            properties = [properties, varargin(arg+1:arg+2)];
-            arg += 2;
-          endwhile
+          x = 1:columns (x);
         endif
-      else
-        properties = [properties, new_cell];
-        property_set = 1;
-        continue;
       endif
 
       if (isvector (x) && isvector (y))
         if (isvector (z))
           x = x(:);
           y = y(:);
           z = z(:);
         elseif (length (x) == rows (z) && length (y) == columns (z))
           [x, y] = meshgrid (x, y);
         else
-          error ("plot3: [length(x), length(y)] must match size (z)");
+          error ("plot3: [length(X), length(Y)] must match size (Z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
-        error ("plot3: x, y, and z must have the same shape");
+        error ("plot3: X, Y, and Z must have the same shape");
       elseif (ndims (x) > 2)
-        error ("plot3: x, y, and z must not have more than two dimensions");
+        error ("plot3: X, Y, and Z must not have more than two dimensions");
       endif
 
+      options = __default_plot_options__ ();
+
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
         if (isempty (marker) && isempty (linestyle))
-           [linestyle, marker] = __next_line_style__ ();
-        endif
-        color = options.color;
-        if (isempty (color))
-          color = __next_line_color__ ();
-        endif
-
-        tmp(++idx) = line (x(:, i), y(:, i), z(:, i),
-                           "color", color, "linestyle", linestyle,
-                           "marker", marker, properties{:});
-        key = options.key;
-        if (! isempty (key))
-          hlgnd = [hlgnd, tmp(idx)];
-          tlgnd = {tlgnd{:}, key};
-        endif
-      endfor
-
-      x_set = 0;
-      y_set = 0;
-      z_set = 0;
-      fmt_set = 0;
-      properties = {};
-    elseif (! x_set)
-      x = new;
-      x_set = 1;
-    elseif (! y_set)
-      y = new;
-      y_set = 1;
-    elseif (! z_set)
-      z = new;
-      z_set = 1;
-    else
-      if (isvector (x) && isvector (y))
-        if (isvector (z))
-          x = x(:);
-          y = y(:);
-          z = z(:);
-        elseif (length (x) == rows (z) && length (y) == columns (z))
-          [x, y] = meshgrid (x, y);
-        else
-          error ("plot3: [length(x), length(y)] must match size (z)");
-        endif
-      endif
-
-      if (! size_equal (x, y, z))
-        error ("plot3: x, y, and z must have the same shape");
-      elseif (ndims (x) > 2)
-        error ("plot3: x, y, and z must not have more than two dimensions");
-      endif
-
-      options =  __default_plot_options__ ();
-      for i = 1 : columns (x)
-        linestyle = options.linestyle;
-        marker = options.marker;
-        if (isempty (marker) && isempty (linestyle))
-           [linestyle, marker] = __next_line_style__ ();
+          [linestyle, marker] = __next_line_style__ ();
         endif
         color = options.color;
         if (isempty (color))
           color = __next_line_color__ ();
         endif
 
-        tmp(++idx) = line (x(:, i), y(:, i), z(:, i),
-                           "color", color, "linestyle", linestyle,
-                           "marker", marker, properties{:});
+        htmp(++idx) = line (x(:, i), y(:, i), z(:, i),
+                            "color", color, "linestyle", linestyle,
+                            "marker", marker, properties{:});
         key = options.key;
         if (! isempty (key))
-          hlgnd = [hlgnd, tmp(idx)];
+          hlgnd = [hlgnd, htmp(idx)];
           tlgnd = {tlgnd{:}, key};
         endif
       endfor
-
-      x = new;
-      y_set = 0;
-      z_set = 0;
-      fmt_set = 0;
-      properties = {};
     endif
 
-  endwhile
-
-  if (property_set)
-    error ("plot3: properties must appear followed by a value");
-  endif
-
-  ## Handle last plot.
-
-  if (x_set)
-    if (y_set)
-      if (! z_set)
-        z = imag (y);
-        y = real (y);
-        z_set = 1;
-      endif
-    else
-      z = imag (x);
-      y = real (x);
-      y_set = 1;
-      z_set = 1;
-      if (rows (x) > 1)
-        x = repmat ((1:rows (x))', 1, columns (x));
-      else
-        x = 1:columns (x);
-      endif
+    if (! isempty (hlgnd))
+      legend (hax, hlgnd, tlgnd);
     endif
 
-    if (isvector (x) && isvector (y))
-      if (isvector (z))
-        x = x(:);
-        y = y(:);
-        z = z(:);
-      elseif (length (x) == rows (z) && length (y) == columns (z))
-        [x, y] = meshgrid (x, y);
-      else
-        error ("plot3: [length(x), length(y)] must match size (z)");
-      endif
-    endif
-
-    if (! size_equal (x, y, z))
-      error ("plot3: x, y, and z must have the same shape");
-    elseif (ndims (x) > 2)
-      error ("plot3: x, y, and z must not have more than two dimensions");
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30]);
     endif
 
-    options =  __default_plot_options__ ();
-
-    for i = 1 : columns (x)
-      linestyle = options.linestyle;
-      marker = options.marker;
-      if (isempty (marker) && isempty (linestyle))
-        [linestyle, marker] = __next_line_style__ ();
-      endif
-      color = options.color;
-      if (isempty (color))
-        color = __next_line_color__ ();
-      endif
-
-      tmp(++idx) = line (x(:, i), y(:, i), z(:, i),
-                         "color", color, "linestyle", linestyle,
-                         "marker", marker, properties{:});
-      key = options.key;
-      if (! isempty (key))
-        hlgnd = [hlgnd, tmp(idx)];
-        tlgnd = {tlgnd{:}, key};
-      endif
-    endfor
-  endif
-
-  if (!isempty (hlgnd))
-    legend (gca (), hlgnd, tlgnd);
-  endif
-
-  set (gca (), "view", [-37.5, 30]);
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0 && idx > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! z = [0:0.05:5];
 %! plot3 (cos (2*pi*z), sin (2*pi*z), z, ';helix;');
+%! title ('plot3() of a helix');
+
+%!demo
+%! clf;
+%! z = [0:0.05:5];
 %! plot3 (z, exp (2i*pi*z), ';complex sinusoid;');
+%! title ('plot3() with complex input');
 
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/draw/plotmatrix.m
rename from scripts/plot/plotmatrix.m
rename to scripts/plot/draw/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/draw/plotmatrix.m
@@ -15,140 +15,148 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} plotmatrix (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} plotmatrix (@var{x})
 ## @deftypefnx {Function File} {} plotmatrix (@dots{}, @var{style})
-## @deftypefnx {Function File} {} plotmatrix (@var{h}, @dots{})
+## @deftypefnx {Function File} {} plotmatrix (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{h}, @var{ax}, @var{bigax}, @var{p}, @var{pax}] =} plotmatrix (@dots{})
-## Scatter plot of the columns of one matrix against another.  Given the
-## arguments @var{x} and @var{y}, that have a matching number of rows,
-## @code{plotmatrix} plots a set of axes corresponding to
+## Scatter plot of the columns of one matrix against another.
+##
+## Given the arguments @var{x} and @var{y}, that have a matching number of
+## rows, @code{plotmatrix} plots a set of axes corresponding to
 ##
 ## @example
 ## plot (@var{x}(:, i), @var{y}(:, j))
 ## @end example
 ##
 ## Given a single argument @var{x} this is equivalent to
 ##
 ## @example
 ## plotmatrix (@var{x}, @var{x})
 ## @end example
 ##
 ## @noindent
 ## except that the diagonal of the set of axes will be replaced with the
 ## histogram @code{hist (@var{x}(:, i))}.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
-## string defining a marker in the same manner as the @code{plot}
-## command.  If a leading axes handle @var{h} is passed to
-## @code{plotmatrix}, then this axis will be used for the plot.
+## string defining a marker in the same manner as the @code{plot} command.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} provides handles to the individual
 ## graphics objects in the scatter plots, whereas @var{ax} returns the
 ## handles to the scatter plot axis objects.  @var{bigax} is a hidden
 ## axis object that surrounds the other axes, such that the commands
 ## @code{xlabel}, @code{title}, etc., will be associated with this hidden
-## axis.  Finally @var{p} returns the graphics objects associated with
+## axis.  Finally, @var{p} returns the graphics objects associated with
 ## the histogram and @var{pax} the corresponding axes objects.
 ##
+## Example:
+##
 ## @example
 ## plotmatrix (randn (100, 3), "g+")
 ## @end example
 ##
-## @seealso{plot}
+## @seealso{scatter, plot}
 ## @end deftypefn
 
 function [h, ax, bigax, p, pax] = plotmatrix (varargin)
 
   [bigax2, varargin, nargin] = __plt_get_axis_arg__ ("plotmatrix", varargin{:});
 
   if (nargin > 3 || nargin < 1)
     print_usage ();
-  else
-    oldh = gca ();
-    unwind_protect
-      axes (bigax2);
-      newplot ();
-      [h2, ax2, p2, pax2, need_usage] = __plotmatrix__ (bigax2, varargin{:});
-      if (need_usage)
-        print_usage ();
-      endif
-      if (nargout > 0)
-        h = h2;
-        ax = ax2;
-        bigax = bigax2;
-        p = p2;
-        pax = pax2;
-      endif
-      axes (bigax2);
-      ctext = text (0, 0, "", "visible", "off",
-                    "handlevisibility", "off", "xliminclude", "off",
-                    "yliminclude", "off", "zliminclude", "off",
-                    "deletefcn", {@plotmatrixdelete, [ax2; pax2]});
-      set (bigax2, "visible", "off");
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
+  endif
+
+  oldfig = [];
+  if (! isempty (bigax2))
+    oldfig = get (0, "currentfigure");
   endif
+  unwind_protect
+    bigax2 = newplot (bigax2);
+
+    [h2, ax2, p2, pax2] = __plotmatrix__ (bigax2, varargin{:});
+
+    axes (bigax2);
+    ctext = text (0, 0, "", "visible", "off",
+                  "handlevisibility", "off", "xliminclude", "off",
+                  "yliminclude", "off", "zliminclude", "off",
+                  "deletefcn", {@plotmatrixdelete, [ax2; pax2]});
+    set (bigax2, "visible", "off");
+
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
+
+  if (nargout > 0)
+    h = h2;
+    ax = ax2;
+    bigax = bigax2;
+    p = p2;
+    pax = pax2;
+  endif
+
 endfunction
 
+
 %!demo
 %! clf;
 %! plotmatrix (randn (100, 3), 'g+');
 
+
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
-    if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
-        && strcmpi (get (hc, "beingdeleted"), "off"))
+    if (isaxes (hc) && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
       if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
         delete (hc);
       endif
     endif
   endfor
 endfunction
 
-function [h, ax, p, pax, need_usage] = __plotmatrix__ (bigax, varargin)
-  need_usage = false;
+function [h, ax, p, pax] = __plotmatrix__ (bigax, varargin)
   have_line_spec = false;
   have_hist = false;
   parent = get (bigax, "parent");
   for i = 1 : nargin - 1
     arg = varargin{i};
-    if (ischar (arg) || iscell (arg))
+    if (ischar (arg) || iscellstr (arg))
       [linespec, valid] = __pltopt__ ("plotmatrix", varargin{i}, false);
       if (valid)
         have_line_spec = true;
         linespec = varargin(i);
         varargin(i) = [];
         nargin = nargin - 1;
         break;
       else
-        need_usage = true;
-        returm;
+        print_usage ("plotmatrix");
       endif
     endif
   endfor
 
   if (nargin == 2)
     X = varargin{1};
     Y = X;
     have_hist = true;
   elseif (nargin == 3)
     X = varargin{1};
     Y = varargin{2};
   else
-    need_usage = true;
-    returm;
+    print_usage ("plotmatrix");
   endif
 
   if (rows (X) != rows (Y))
     error ("plotmatrix: dimension mismatch in the arguments");
   endif
 
   [dummy, m] = size (X);
   [dummy, n] = size (Y);
@@ -182,8 +190,9 @@ function [h, ax, p, pax, need_usage] = _
         else
           tmp = plot (X (:, i), Y (:, j), ".");
         endif
         h = [h ; tmp];
       endif
     endfor
   endfor
 endfunction
+
diff --git a/scripts/plot/plotyy.m b/scripts/plot/draw/plotyy.m
rename from scripts/plot/plotyy.m
rename to scripts/plot/draw/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -15,35 +15,38 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} plotyy (@var{x1}, @var{y1}, @var{x2}, @var{y2})
 ## @deftypefnx {Function File} {} plotyy (@dots{}, @var{fun})
 ## @deftypefnx {Function File} {} plotyy (@dots{}, @var{fun1}, @var{fun2})
-## @deftypefnx {Function File} {} plotyy (@var{h}, @dots{})
+## @deftypefnx {Function File} {} plotyy (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {[@var{ax}, @var{h1}, @var{h2}] =} plotyy (@dots{})
-## Plot two sets of data with independent y-axes.  The arguments @var{x1} and
-## @var{y1} define the arguments for the first plot and @var{x1} and @var{y2}
-## for the second.
+## Plot two sets of data with independent y-axes.
+##
+## The arguments @var{x1} and @var{y1} define the arguments for the first plot
+## and @var{x1} and @var{y2} for the second.
 ##
 ## By default the arguments are evaluated with
 ## @code{feval (@@plot, @var{x}, @var{y})}.  However the type of plot can be
 ## modified with the @var{fun} argument, in which case the plots are
 ## generated by @code{feval (@var{fun}, @var{x}, @var{y})}.  @var{fun} can be
-## a function handle, an inline function or a string of a function name.
+## a function handle, an inline function, or a string of a function name.
 ##
 ## The function to use for each of the plots can be independently defined
 ## with @var{fun1} and @var{fun2}.
 ##
-## If given, @var{h} defines the principal axis in which to plot the @var{x1}
-## and @var{y1} data.  The return value @var{ax} is a two element vector with
-## the axis handles of the two plots.  @var{h1} and @var{h2} are handles to
-## the objects generated by the plot commands.
+## If the first argument @var{hax} is an axes handle, then it defines
+## the principal axis in which to plot the @var{x1} and @var{y1} data.
+##
+## The return value @var{ax} is a vector with the axis handles of the two
+## y axes.  @var{h1} and @var{h2} are handles to the objects generated by the
+## plot commands.
 ##
 ## @example
 ## @group
 ## x = 0:0.1:2*pi;
 ## y1 = sin (x);
 ## y2 = exp (x - 1);
 ## ax = plotyy (x, y1, x - 1, y2, @@plot, @@semilogy);
 ## xlabel ("X");
@@ -107,17 +110,17 @@ function [Ax, H1, H2] = plotyy (varargin
   if (nargin < 4)
     print_usage ();
   endif
 
   unwind_protect
     [ax, h1, h2] = __plotyy__ (ax, varargin{:});
   unwind_protect_cleanup
     ## Only change back to the old axis if we didn't delete it
-    if (ishandle (oldh) && strcmp (get (oldh, "type"), "axes"))
+    if (isaxes (oldh))
       axes (oldh);
     endif
   end_unwind_protect
 
   if (nargout > 0)
     Ax = ax;
     H1 = h1;
     H2 = h2;
@@ -134,49 +137,51 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   if (nargin > 6)
     fun2 = varargin{2};
   else
     fun2 = fun1;
   endif
 
   xlim = [min([x1(:); x2(:)]), max([x1(:); x2(:)])];
 
-  if (ishandle (ax(1)) && strcmp (get (ax(1), "type"), "axes"))
+  if (isaxes (ax(1)))
     axes (ax(1));
   else
     ax(1) = axes ();
   endif
   newplot ();
   h1 = feval (fun1, x1, y1);
 
   set (ax(1), "ycolor", getcolor (h1(1)));
   set (ax(1), "xlim", xlim);
   set (ax(1), "color", "none");
 
   cf = gcf ();
   set (cf, "nextplot", "add");
 
-  if (ishandle (ax(2)) && strcmp (get (ax(2), "type"), "axes"))
+  if (isaxes (ax(2)))
     axes (ax(2));
   else
     ax(2) = axes ();
     set (ax(2), "nextplot", get (ax(1), "nextplot"));
   endif
   newplot ();
 
   colors = get (ax(1), "colororder");
   set (ax(2), "colororder", [colors(2:end,:); colors(1,:)]);
 
   if (strcmp (get (ax(1), "autopos_tag"), "subplot"))
     set (ax(2), "autopos_tag", "subplot");
   else
     set (ax, "activepositionproperty", "position");
   endif
 
-  h2 = feval (fun2, x2, y2);
+  ## Kluge, until __plt_get_axis_arg__ and newplot are reworked. 
+  set (ax(2), "nextplot", "replacechildren");
+  h2 = feval (fun2, ax(2), x2, y2);
   set (ax(2), "yaxislocation", "right");
   set (ax(2), "ycolor", getcolor (h2(1)));
 
   if (strcmp (get(ax(1), "activepositionproperty"), "position"))
     set (ax(2), "position", get (ax(1), "position"));
   else
     set (ax(2), "outerposition", get (ax(1), "outerposition"));
     set (ax(2), "looseinset", get (ax(1), "looseinset"));
@@ -279,17 +284,17 @@ endfunction
 %! [~, h3, h4] = plotyy (t+1, x, t+1, y);
 %! set ([h3, h4], 'linestyle', '--');
 %! xlabel (hax(1), 'xlabel');
 %! title (hax(2), 'title');
 %! ylabel (hax(1), 'Left axis is Blue');
 %! ylabel (hax(2), 'Right axis is Green');
 
 function deleteplotyy (h, d, ax2, t2)
-  if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
+  if (isaxes (ax2)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
 endfunction
 
 function update_nextplot (h, d, ax2)
diff --git a/scripts/plot/polar.m b/scripts/plot/draw/polar.m
rename from scripts/plot/polar.m
rename to scripts/plot/draw/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/draw/polar.m
@@ -14,217 +14,204 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polar (@var{theta}, @var{rho})
 ## @deftypefnx {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
-## @deftypefnx {Function File} {} polar (@var{h}, @dots{})
+## @deftypefnx {Function File} {} polar (@var{cplx})
+## @deftypefnx {Function File} {} polar (@var{cplx}, @var{fmt})
+## @deftypefnx {Function File} {} polar (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} polar (@dots{})
-## Create a two-dimensional plot from polar coordinates @var{theta} and
-## @var{rho}.
+## Create a 2-D plot from polar coordinates @var{theta} and @var{rho}.
+##
+## If a single complex input @var{cplx} is given then the real part is used
+## for @var{theta} and the imaginary part is used for @var{rho}.
 ##
-## The optional argument @var{fmt} specifies the line format.
+## The optional argument @var{fmt} specifies the line format in the same way
+## as @code{plot}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
-## @seealso{plot, rose, compass}
+## @seealso{rose, compass, plot}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = polar (varargin)
+function h = polar (varargin)
 
-  [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
 
   if (nargs < 1)
     print_usage ();
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
     if (nargs == 3)
       if (! ischar (varargin{3}))
-        error ("polar: third argument must be a string");
+        error ("polar: FMT argument must be a string");
       endif
-      tmp = __plr2__ (h, varargin{:});
-      maxr = max (varargin {2} (:));
+      htmp = __plr2__ (hax, varargin{:});
+      maxr = max (varargin{2}(:));
     elseif (nargs == 2)
       if (ischar (varargin{2}))
-        tmp = __plr1__ (h, varargin{:});
+        htmp = __plr1__ (hax, varargin{:});
         if (iscomplex (varargin{1}))
           maxr = max (imag (varargin{1})(:));
         else
           maxr = max (varargin{1}(:));
         endif
       else
         fmt = "";
-        tmp = __plr2__ (h, varargin{:}, fmt);
-        maxr = max (varargin {2} (:));
+        htmp = __plr2__ (hax, varargin{:}, fmt);
+        maxr = max (varargin{2}(:));
       endif
     elseif (nargs == 1)
       fmt = "";
-      tmp = __plr1__ (h, varargin{:}, fmt);
+      htmp = __plr1__ (hax, varargin{:}, fmt);
       if (iscomplex (varargin{1}))
         maxr = max (imag (varargin{1})(:));
       else
         maxr = max (varargin{1}(:));
       endif
     else
       print_usage ();
     endif
 
-    set (h, "xlim", [-maxr, maxr], "ylim", [-maxr, maxr],
-         "xaxislocation", "zero", "yaxislocation", "zero",
-         "plotboxaspectratio", [1, 1, 1]);
+    set (hax, "xlim", [-maxr, maxr], "ylim", [-maxr, maxr],
+              "xaxislocation", "zero", "yaxislocation", "zero",
+              "plotboxaspectratio", [1, 1, 1]);
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 function retval = __plr1__ (h, theta, fmt)
 
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  [nr, nc] = size (theta);
-  if (nr == 1)
-    theta = theta';
-    tmp = nr;
-    nr = nc;
-    nc = tmp;
-  endif
-  theta_i = imag (theta);
-  if (any (theta_i))
-    rho = theta_i;
+  theta = theta(:);
+  if (iscomplex (theta))
+    rho = imag (theta);
     theta = real (theta);
   else
     rho = theta;
-    theta = (1:nr)';
+    theta = (1:rows (rho))';
   endif
 
   retval = __plr2__ (h, theta, rho, fmt);
 
 endfunction
 
 function retval = __plr2__ (h, theta, rho, fmt)
 
-  if (nargin != 4)
-    print_usage ();
+  if (ndims (theta) > 2 || ndims (rho) > 2)
+    error ("polar: THETA and RHO must be 2-D objects");
   endif
-
-  if (any (imag (theta)))
-    theta = real (theta);
-  endif
-
-  if (any (imag (rho)))
-    rho = real (rho);
-  endif
+  theta = real (theta);
+  rho = real (rho);
 
   if (isscalar (theta))
     if (isscalar (rho))
       x = rho * cos (theta);
       y = rho * sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
     else
-      error ("__plr2__: invalid data for plotting");
+      error ("polar: Can't plot constant THETA with varying RHO");
     endif
   elseif (isvector (theta))
     if (isvector (rho))
       if (length (theta) != length (rho))
-        error ("__plr2__: vector lengths must match");
+        error ("polar: THETA and RHO vector lengths must match");
       endif
-      if (rows (rho) == 1)
-        rho = rho';
-      endif
-      if (rows (theta) == 1)
-        theta = theta';
-      endif
+      rho = rho(:);
+      theta = theta(:);
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
     elseif (ismatrix (rho))
-      [t_nr, t_nc] = size (theta);
-      if (t_nr == 1)
-        theta = theta';
-        tmp = t_nr;
-        t_nr = t_nc;
-        t_nc = tmp;
-      endif
+      theta = theta(:);
+      t_nr = rows (theta);
       [r_nr, r_nc] = size (rho);
       if (t_nr != r_nr)
         rho = rho';
-        tmp = r_nr;
         r_nr = r_nc;
-        r_nc = tmp;
       endif
       if (t_nr != r_nr)
-        error ("__plr2__: vector and matrix sizes must match");
+        error ("polar: THETA vector and RHO matrix sizes must match");
       endif
       x = diag (cos (theta)) * rho;
       y = diag (sin (theta)) * rho;
       retval = __plt__ ("polar", h, x, y, fmt);
     else
-      error ("__plr2__: invalid data for plotting");
+      error ("polar: invalid data for plotting");
     endif
   elseif (ismatrix (theta))
     if (isvector (rho))
-      [r_nr, r_nc] = size (rho);
-      if (r_nr == 1)
-        rho = rho';
-        tmp = r_nr;
-        r_nr = r_nc;
-        r_nc = tmp;
-      endif
+      rho = rho(:);
+      r_nr = rows (rho);
       [t_nr, t_nc] = size (theta);
       if (r_nr != t_nr)
         theta = theta';
-        tmp = t_nr;
         t_nr = t_nc;
-        t_nc = tmp;
       endif
       if (r_nr != t_nr)
-        error ("__plr2__: vector and matrix sizes must match");
+        error ("polar: THETA matrix and RHO vector sizes must match");
       endif
       diag_r = diag (rho);
       x = diag_r * cos (theta);
       y = diag_r * sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
     elseif (ismatrix (rho))
       if (! size_equal (rho, theta))
-        error ("__plr2__: matrix dimensions must match");
+        error ("polar: THETA and RHO matrix dimensions must match");
       endif
       x = rho .* cos (theta);
       y = rho .* sin (theta);
       retval = __plt__ ("polar", h, x, y, fmt);
     else
-      error ("__plr2__: invalid data for plotting");
+      error ("polar: invalid data for plotting");
     endif
   else
-    error ("__plr2__: invalid data for plotting");
+    error ("polar: invalid data for plotting");
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! theta = linspace (0,2*pi,1000);
 %! rho = sin (7*theta);
 %! polar (theta, rho);
+%! title ('polar() plot');
 
 %!demo
 %! clf;
-%! theta = linspace (0,10*pi,1000);
+%! theta = linspace (0,2*pi,1000);
+%! cplx = theta + i*sin (7*theta);
+%! polar (cplx, 'g');
+%! title ('polar() plot of complex data');
+
+%!demo
+%! clf;
+%! theta = linspace (0,8*pi,1000);
 %! rho = sin (5/4*theta);
 %! polar (theta, rho);
+%! title ('polar() plot');
 
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/draw/private/__add_datasource__.m
rename from scripts/plot/private/__add_datasource__.m
rename to scripts/plot/draw/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/draw/private/__add_datasource__.m
@@ -18,20 +18,16 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{newargs} =} __add_datasource__ (@var{fcn}, @var{h}, @var{data}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function newargs = __add_datasource__ (fcn, h, data, varargin)
 
-  if (nargin < 3)
-    error ("__add_datasource__: a minimum of 3 inputs are required");
-  endif
-
   if (ischar (data))
     data = {data};
   endif
 
   for i = 1 : numel (data)
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
   endfor
 
@@ -48,8 +44,9 @@ function newargs = __add_datasource__ (f
       else
         error ("%s: expecting data source to be a string", fcn);
       endif
     else
       newargs{end + 1} = arg;
     endif
   endwhile
 endfunction
+
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/draw/private/__bar__.m
rename from scripts/plot/private/__bar__.m
rename to scripts/plot/draw/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/draw/private/__bar__.m
@@ -20,28 +20,25 @@
 ## @deftypefn {Function File} {} __bar__ (@var{vertical}, @var{func}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = __bar__ (vertical, func, varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ((nargout > 1), func, varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ (func, varargin{:});
 
   ## Slightly smaller than 0.8 to avoid clipping issue in gnuplot 4.0
   width = 0.8 - 10 * eps;
   group = true;
-  bv = 0;
+  histc = NA;
+  bv = 0;  # BaseValue
 
-  if (nargin < 3)
-    print_usage ();
-  endif
-
-  if (nargin > 3 && isnumeric (varargin{2}))
+  if (nargin > 1 && isnumeric (varargin{2}))
     x = varargin{1};
     if (isvector (x))
       x = x(:);
     endif
     y = varargin{2};
     if (isvector (y))
       y = y(:);
     endif
@@ -49,186 +46,235 @@ function varargout = __bar__ (vertical, 
       y = varargin{1};
       if (isvector (y))
         y = y(:);
       endif
       x = [1:rows(y)]';
       idx = 2;
     else
       if (! isvector (x))
-        error ("%s: x must be a vector", func);
+        error ("%s: X must be a vector", func);
       endif
       idx = 3;
     endif
   else
     y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
     x = [1:rows(y)]';
     idx = 2;
   endif
 
   newargs = {};
   have_line_spec = false;
-  while (idx <= nargin - 2)
+  while (idx <= nargin)
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
       idx++;
+    elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "histc"))
+      group = true;
+      histc = true; 
+      idx++;
+    elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "hist"))
+      group = true;
+      histc = false;
+      idx++;
     else
-      if ((ischar (varargin{idx}) || iscell (varargin{idx}))
+      if ((ischar (varargin{idx}) || iscellstr (varargin{idx}))
           && ! have_line_spec)
         [linespec, valid] = __pltopt__ (func, varargin{idx}, false);
         if (valid)
           have_line_spec = true;
           ## FIXME: strange parse error requires semicolon to be spaced
           ##        away from closing ']' on next line.
           newargs = [{"facecolor", linespec.color}, newargs] ;
           idx++;
           continue;
         endif
       endif
       if (isscalar (varargin{idx}))
         width = varargin{idx++};
-      elseif (idx == nargin - 2)
-        newargs = [newargs,varargin(idx++)];
+      elseif (idx == nargin)
+        newargs = [newargs, varargin(idx++)];
       elseif (ischar (varargin{idx})
               && strcmpi (varargin{idx}, "basevalue")
               && isscalar (varargin{idx+1}))
         bv = varargin{idx+1};
         idx += 2;
       else
-        newargs = [newargs,varargin(idx:idx+1)];
+        newargs = [newargs, varargin(idx:idx+1)];
         idx += 2;
       endif
     endif
   endwhile
 
-  xlen = rows (x);
-  ylen = rows (y);
-
-  if (xlen != ylen)
-    error ("%s: length of x and y must be equal", func);
+  ngrp = rows (x);
+  if (ngrp != rows (y))
+    error ("%s: length of X and Y must be equal", func);
   endif
   if (any (x(2:end) < x(1:end-1)))
-    error ("%s: x vector values must be in ascending order", func);
+    error ("%s: X vector values must be in ascending order", func);
   endif
 
-  ycols = columns (y);
+  nbars = columns (y);
+
+  ## Column width is 1 for 'hist*' styles.  Otherwise, same as group width.
+  if (nbars == 1)
+    cwidth = 1;
+    gwidth = width;
+  elseif (islogical (histc))
+    cwidth = 1;
+    gwidth = width^2;
+  else
+    cwidth = gwidth = width;
+  endif
+
+  ## Complicated algorithm sizes bars with unitless parameter width.
+  ## If width is 1.0, adjacent bars in a group are touching.
+  ## Otherwise, bar size is cwidth and the remaining space is split evenly on
+  ## either side of the bar.  For the default 0.8, spacing is [0.1 0.8 0.1].
+  ## Groups of bars are spaced by gwidth.  If gwidth is 1.0 then adjacent
+  ## groups will just touch.
   if (numel (x) > 1)
     cutoff = min (diff (double (x))) / 2;
   else
     cutoff = 1;
   endif
   if (group)
-    delta_p = delta_m = repmat (cutoff * width / ycols, size (x));
+    gdelta = cutoff * gwidth / nbars; 
+    cdelta = repmat ((1 - ((1 - cwidth) / 2)) * gdelta, size (x));
   else
-    delta_p = delta_m = repmat (cutoff * width, size (x));
+    cdelta = repmat (cutoff * gwidth, size (x));
   endif
-  x1 = (x - delta_m)(:)';
-  x2 = (x + delta_p)(:)';
-  xb = repmat ([x1; x1; x2; x2](:), 1, ycols);
+  x1 = (x - cdelta)(:)';
+  x2 = (x + cdelta)(:)';
+  xb = repmat ([x1; x1; x2; x2](:), 1, nbars);
 
   if (group)
-    offset = ((delta_p + delta_m) * [-(ycols - 1) / 2 : (ycols - 1) / 2]);
-    xb(1:4:4*ylen,:) += offset;
-    xb(2:4:4*ylen,:) += offset;
-    xb(3:4:4*ylen,:) += offset;
-    xb(4:4:4*ylen,:) += offset;
+    if (islogical (histc) && histc)
+      offset = 2*cdelta * [0:(nbars-1)] + cdelta(1);  # not centered
+    else
+      offset = 2*cdelta * [-(nbars - 1) / 2 : (nbars - 1) / 2];
+    endif
+
+    xb(1:4:4*ngrp,:) += offset + (1-cwidth) / 2 * (2 * gdelta);
+    xb(2:4:4*ngrp,:) += offset + (1-cwidth) / 2 * (2 * gdelta);
+    xb(3:4:4*ngrp,:) += offset - (1-cwidth) / 2 * (2 * gdelta);
+    xb(4:4:4*ngrp,:) += offset - (1-cwidth) / 2 * (2 * gdelta);
+
     y0 = zeros (size (y)) + bv;
     y1 = y;
   else
     y1 = cumsum (y,2);
-    y0 = [zeros(ylen,1)+bv, y1(:,1:end-1)];
+    y0 = [zeros(ngrp,1)+bv, y1(:,1:end-1)];
   endif
 
-  yb = zeros (4*ylen, ycols);
-  yb(1:4:4*ylen,:) = y0;
-  yb(2:4:4*ylen,:) = y1;
-  yb(3:4:4*ylen,:) = y1;
-  yb(4:4:4*ylen,:) = y0;
+  yb = zeros (4*ngrp, nbars);
+  yb(1:4:4*ngrp,:) = y0;
+  yb(2:4:4*ngrp,:) = y1;
+  yb(3:4:4*ngrp,:) = y1;
+  yb(4:4:4*ngrp,:) = y0;
 
-  xb = reshape (xb, [4, numel(xb) / 4 / ycols, ycols]);
-  yb = reshape (yb, [4, numel(yb) / 4 / ycols, ycols]);
+  xb = reshape (xb, [4, ngrp, nbars]);
+  yb = reshape (yb, [4, ngrp, nbars]);
 
   if (nargout < 2)
-    oldh = gca ();
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
     unwind_protect
-      axes (h);
-      newplot ();
+      hax = newplot (hax);
+
+      htmp = bars (hax, vertical, x, y, xb, yb, gwidth, group,
+                   have_line_spec, bv, newargs{:});
 
-      tmp = bars (h, vertical, x, y, xb, yb, width, group,
-                  have_line_spec, bv, newargs{:});
-      if (nargout == 1)
-        varargout{1} = tmp;
+      if (! ishold (hax))
+        if (all (x(:,1) == fix (x(:,1))))
+          if (vertical)
+            set (hax, "xtick", x(:,1));
+          else
+            set (hax, "ytick", x(:,1));
+          endif
+        endif
+        ## Hack prevents color and xlim setting changes when basevalue changes.
+        if (vertical)
+          set (hax, "clim", [0 1], "xlimmode", "manual");
+        else
+          set (hax, "clim", [0 1], "ylimmode", "manual");
+        endif
       endif
     unwind_protect_cleanup
-      axes (oldh);
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
     end_unwind_protect
+    if (nargout == 1)
+      varargout{1} = htmp;
+    endif
   else
     if (vertical)
       varargout{1} = xb;
       varargout{2} = yb;
     else
       varargout{1} = yb;
       varargout{2} = xb;
     endif
   endif
 
 endfunction
 
-function tmp = bars (ax, vertical, x, y, xb, yb, width, group, have_color_spec, base_value, varargin)
+function hglist = bars (hax, vertical, x, y, xb, yb, width, group, have_color_spec, base_value, varargin)
 
-  ycols = columns (y);
-  clim = get (ax, "clim");
-  tmp = [];
+  nbars = columns (y);
+  clim = get (hax, "clim");
+  hglist = [];
 
-  for i = 1:ycols
+  for i = 1:nbars
     hg = hggroup ();
-    tmp = [tmp; hg];
+    hglist = [hglist; hg];
     args = __add_datasource__ ("bar", hg, {"x", "y"}, varargin{:});
 
     if (vertical)
       if (! have_color_spec)
-        if (ycols == 1)
+        if (nbars == 1)
           lev = clim(1);
         else
-          lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
+          lev = (i - 1) * (clim(2) - clim(1)) / (nbars - 1) - clim(1);
         endif
-        h = patch (xb(:,:,i), yb(:,:,i), "FaceColor", "flat",
-                   "cdata", lev, "parent", hg);
+        h = patch (hax, xb(:,:,i), yb(:,:,i),
+                        "FaceColor", "flat", "cdata", lev, "parent", hg);
       else
-        h = patch (xb(:,:,i), yb(:,:,i), "parent", hg);
+        h = patch (hax, xb(:,:,i), yb(:,:,i), "parent", hg);
       endif
     else
       if (! have_color_spec)
-        if (ycols == 1)
+        if (nbars == 1)
           lev = clim(1);
         else
-          lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
+          lev = (i - 1) * (clim(2) - clim(1)) / (nbars - 1) - clim(1);
         endif
-        h = patch (yb(:,:,i), xb(:,:,i), "FaceColor", "flat",
-                   "cdata", lev, "parent", hg);
+        h = patch (hax, yb(:,:,i), xb(:,:,i),
+                        "FaceColor", "flat", "cdata", lev, "parent", hg);
       else
-        h = patch (yb(:,:,i), xb(:,:,i), "parent", hg);
+        h = patch (hax, yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
     endif
 
     if (i == 1)
-      x_axis_range = get (ax, "xlim");
-      h_baseline = line (x_axis_range, [base_value, base_value],
-                         "color", [0, 0, 0]);
-      set (h_baseline, "handlevisibility", "off");
-      set (h_baseline, "xliminclude", "off");
-      addlistener (ax, "xlim", @update_xlim);
-      addlistener (h_baseline, "ydata", @update_baseline);
-      addlistener (h_baseline, "visible", @update_baseline);
+      ## Add baseline object the first time through loop
+      x_axis_range = get (hax, "xlim");
+      h_baseline = line (hax, x_axis_range, [base_value, base_value],
+                             "color", [0, 0, 0]);
+      set (h_baseline, "handlevisibility", "off", "xliminclude", "off");
+      set (h_baseline, "parent", get (hg, "parent"));
     endif
 
     ## Setup the hggroup and listeners
     addproperty ("showbaseline", hg, "radio", "{on}|off");
     addproperty ("basevalue", hg, "data", base_value);
     addproperty ("baseline", hg, "data", h_baseline);
 
     addlistener (hg, "showbaseline", {@show_baseline, "showbl"});
@@ -247,192 +293,187 @@ function tmp = bars (ax, vertical, x, y,
       addproperty ("horizontal", hg, "radio", "{on}|off", "on");
     endif
 
     addlistener (hg, "barwidth", @update_group);
     addlistener (hg, "barlayout", @update_group);
     addlistener (hg, "horizontal", @update_group);
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
-    addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
+    addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
     addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
-    addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
+    addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
 
     addlistener (hg, "edgecolor", @update_props);
-    addlistener (hg, "linewidth", @update_props);
+    addlistener (hg, "facecolor", @update_props);
     addlistener (hg, "linestyle", @update_props);
-    addlistener (hg, "facecolor", @update_props);
+    addlistener (hg, "linewidth", @update_props);
 
     if (isvector (x))
       addproperty ("xdata", hg, "data", x);
     else
       addproperty ("xdata", hg, "data", x(:, i));
     endif
     addproperty ("ydata", hg, "data", y(:, i));
 
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
 
     addproperty ("bargroup", hg, "data");
-    set (tmp, "bargroup", tmp);
+    set (hglist, "bargroup", hglist);
+
+    ## Matlab property, although Octave does not implement it.
+    addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
     if (! isempty (args))
       set (hg, args{:});
     endif
-    if (i == 1)
-      set (h_baseline, "parent", get (hg, "parent"));
-    endif
   endfor
 
-  update_xlim (ax, []);
+  update_xlim (hax, []);
+  ## Add listeners outside of for loop to prevent constant updating during
+  ## creation of plot when patch objects are added.
+  addlistener (hax, "xlim", @update_xlim);
+  addlistener (h_baseline, "ydata", @update_baseline);
+  addlistener (h_baseline, "visible", @update_baseline);
+
 endfunction
 
-function update_xlim (h, d)
+function update_xlim (h, ~)
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
-    obj = get (kids (i));
+    obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
         set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
 endfunction
 
-function update_baseline (h, d)
+function update_baseline (h, ~)
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
+  ## Search axis for a bargroup that contains this baseline handle
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
-    obj = get (kids (i));
+    obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline")
         && obj.baseline == h)
-      ## Only alter if changed to avoid recursion of the listener functions
-      if (! strcmpi (get (kids(i), "showbaseline"), visible))
-        set (kids (i), "showbaseline", visible);
-      endif
-      if (! strcmpi (get (kids(i), "basevalue"), visible))
-        set (kids (i), "basevalue", ydata);
-      endif
+      set (obj.bargroup, "showbaseline", visible, "basevalue", ydata);
+      break;
     endif
   endfor
 endfunction
 
-function show_baseline (h, d, prop = "")
+function show_baseline (h, ~, prop = "")
   persistent recursion = false;
   
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       if (strcmp (prop, "showbl"))
         showbaseline = get (h, "showbaseline");
-        for hh = hlist(:)'
-          if (hh != h)
-            set (hh, "showbaseline", showbaseline);
-          endif
-        endfor
+        hlist = hlist(hlist != h);  # remove current handle being updated
+        set (hlist, "showbaseline", showbaseline);
       elseif (strcmp (prop, "visib"))
         showbaseline = "on";
         if (all (strcmp (get (hlist, "visible"), "off")))
           showbaseline = "off";
         endif
       endif
       set (get (h, "baseline"), "visible", showbaseline);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
-function move_baseline (h, d)
-  b0 = get (h, "basevalue");
-  bl = get (h, "baseline");
+function move_baseline (h, ~)
+  persistent recursion = false;
 
-  if (get (bl, "ydata") != [b0, b0])
-    set (bl, "ydata", [b0, b0]);
-  endif
+  ## Don't allow recursion
+  if (! recursion)
+    recursion = true;
+    unwind_protect
+      b0 = get (h, "basevalue");
+      bl = get (h, "baseline");
+      set (bl, "ydata", [b0, b0]);
 
-  if (strcmpi (get (h, "barlayout"), "grouped"))
-    update_data (h, d);
+      if (strcmp (get (h, "barlayout"), "grouped"))
+        update_data (h);
+      endif
+    unwind_protect_cleanup
+      recursion = false;
+    end_unwind_protect
   endif
 endfunction
 
-function update_props (h, d)
+function update_props (h, ~)
   kids = get (h, "children");
-  set (kids, "edgecolor", get (h, "edgecolor"),
-       "linewidth", get (h, "linewidth"),
-       "linestyle", get (h, "linestyle"),
-       "facecolor", get (h, "facecolor"));
+  set (kids, {"edgecolor", "linewidth", "linestyle", "facecolor"},
+       get (h, {"edgecolor", "linewidth", "linestyle", "facecolor"}));
 endfunction
 
-function update_data (h, d)
+function update_data (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       x = get (h, "xdata");
-      if (!isvector (x))
+      if (! isvector (x))
         x = x(:);
       endif
-      y = [];
-      for hh = hlist(:)'
-        ytmp = get (hh, "ydata");
-        y = [y ytmp(:)];
-      endfor
+      ydat = get (hlist, "ydata");
+      if (iscell (ydat))
+        y = cell2mat (ydat.');
+      else
+        y = ydat;
+      endif
 
       [xb, yb] = bar (x, y, get (h, "barwidth"), get (h, "barlayout"),
                       "basevalue", get (h, "basevalue"));
-      ny = columns (y);
-      vert = strcmpi (get (h, "horizontal"), "off");
 
-      for i = 1:ny
+      vertical = strcmp (get (h, "horizontal"), "off");
+      for i = 1:columns (y)
         hp = get (hlist(i), "children");
-        if (vert)
+        if (vertical)
           set (hp, "xdata", xb(:,:,i), "ydata", yb(:,:,i));
         else
           set (hp, "xdata", yb(:,:,i), "ydata", xb(:,:,i));
         endif
       endfor
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
-function update_group (h, d)
+function update_group (h, ~)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       barwidth = get (h, "barwidth");
       barlayout = get (h, "barlayout");
       horizontal = get (h, "horizontal");
 
-      ## To prevent recursion, only change if modified
-      for hh = hlist(:)'
-        if (hh != h)
-          if (get (hh, "barwidth") != barwidth)
-            set (hh, "barwidth", barwidth);
-          endif
-          if (! strcmpi (get (hh, "barlayout"), barlayout))
-            set (hh, "barlayout", barlayout);
-          endif
-          if (! strcmpi (get (hh, "horizontal"), horizontal))
-            set (hh, "horizontal", horizontal);
-          endif
-        endif
-      endfor
-      update_data (h, d);
+      hlist = hlist(hlist != h);  # remove current handle being updated
+      set (hlist, "barwidth", barwidth, "barlayout", barlayout,
+                  "horizontal", horizontal);
+      update_data (h);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
+
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/draw/private/__contour__.m
rename from scripts/plot/private/__contour__.m
rename to scripts/plot/draw/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/draw/private/__contour__.m
@@ -21,94 +21,84 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [c, hg] = __contour__ (varargin)
   ax = varargin{1};
   zlevel = varargin{2};
   filled = "off";
 
+  linespec.color = "auto";
   linespec.linestyle = "-";
-  linespec.color = "auto";
-  edgecolor = "flat";
-  for i = 3 : nargin
-    arg = varargin {i};
-    if ((ischar (arg) || iscell (arg)))
-      [linespec, valid] = __pltopt__ ("__contour__", arg, false);
-      if (isempty (linespec.color))
-        linespec.color = "auto";
-      endif
-      if (isempty (linespec.linestyle))
-        linespec.linestyle = "-";
-      endif
+  for i = 3:2:nargin
+    arg = varargin{i};
+    if (ischar (arg) || iscellstr (arg))
+      [lspec, valid] = __pltopt__ ("__contour__", arg, false);
       if (valid)
         have_line_spec = true;
         varargin(i) = [];
+        linespec = lspec;
+        if (isempty (linespec.color))
+          linespec.color = "auto";
+        endif
+        if (isempty (linespec.linestyle))
+          linespec.linestyle = "-";
+        endif
         break;
       endif
     endif
   endfor
 
   opts = {};
   i = 3;
   while (i < length (varargin))
-    if (ischar (varargin {i}))
+    if (ischar (varargin{i}))
       if (strcmpi (varargin{i}, "fill"))
-        filled = varargin {i + 1};
+        filled = varargin{i+1};
         varargin(i:i+1) = [];
       elseif (strcmpi (varargin{i}, "linecolor"))
-        linespec.color = varargin {i + 1};
-        edgecolor = linespec.color;
-        if (ischar (edgecolor) && strcmpi (edgecolor, "auto"))
-          edgecolor = "flat";
-        endif
-        varargin(i:i+1) = [];
-      elseif (strcmpi (varargin{i}, "edgecolor"))
-        linespec.color = varargin {i + 1};
-        edgecolor = linespec.color;
-        if (ischar (edgecolor) && strcmpi (edgecolor, "flat"))
-          linespec.color = "auto";
-        endif
+        linespec.color = varargin{i+1};
         varargin(i:i+1) = [];
       else
-        opts{end+1} = varargin{i};
-        varargin(i) = [];
-        opts{end+1} = varargin{i};
-        varargin(i) = [];
+        opts(end+(1:2)) = varargin(i:i+1);
+        varargin(i:i+1) = [];
       endif
     else
       i++;
     endif
   endwhile
 
   if (length (varargin) < 5)
     z1 = varargin{3};
     x1 = 1 : columns (z1);
     y1 = 1 : rows (z1);
   else
     x1 = varargin{3};
     y1 = varargin{4};
     z1 = varargin{5};
   endif
-  if (!ismatrix (z1) || isvector (z1) || isscalar (z1))
-    error ("__contour__: z argument must be a matrix");
+  if (! ismatrix (z1) || ! ismatrix (x1) || ! ismatrix (y1))
+    error ("__contour__: X, Y, and Z must be matrices");
   endif
   if (length (varargin) == 4 || length (varargin) == 6)
-    vn = varargin {end};
+    vn = varargin{end};
     vnauto = false;
   else
+    vn = 10;
     vnauto = true;
-    vn = 10;
   endif
 
   if (isscalar (vn))
-    lvl = linspace (min (z1(!isinf (z1))), max (z1(!isinf (z1))),
-                    vn + 2)(1:end-1);
+    ## FIXME: The levels should be determined similarly to {x,y,z}ticks
+    ##        so that they aren't set at extremely odd values.
+    lvl = linspace (min (z1(!isinf (z1))), max (z1(!isinf (z1))), vn + 2);
+    ## Strip off max outlier, min must stay for contourf hole algorithm.
+    lvl = lvl(1:end-1);
   else
-    lvl = vn;
+    lvl = sort (vn);
   endif
 
   if (strcmpi (filled, "on"))
     if (isvector (x1) || isvector (y1))
       [x1, y1] = meshgrid (x1, y1);
     endif
     [nr, nc] = size (z1);
     x0 = prepad (x1, nc+1, 2 * x1(1, 1) - x1(1, 2), 2);
@@ -134,34 +124,27 @@ function [c, hg] = __contour__ (varargin
 
   addlistener (hg, "xdata", @update_data);
   addlistener (hg, "ydata", @update_data);
   addlistener (hg, "zdata", @update_data);
   addlistener (hg, "contourmatrix", @update_data);
 
   addproperty ("fill", hg, "radio", "on|{off}", filled);
 
-  ## The properties zlevel and zlevelmode don't exist in matlab, but
-  ## allow the use of contourgroups with the contour3, meshc and surfc
-  ## functions.
+  ## The properties zlevel and zlevelmode don't exist in matlab, but allow the
+  ## use of contourgroups with the contour3, meshc, and surfc functions.
   if (isnumeric (zlevel))
     addproperty ("zlevelmode", hg, "radio", "{none}|auto|manual", "manual");
     addproperty ("zlevel", hg, "data", zlevel);
   else
     addproperty ("zlevelmode", hg, "radio", "{none}|auto|manual", zlevel);
-    if (ischar (zlevel) && strcmpi (zlevel, "manual"))
-      z = varargin{3};
-      z = 2 * (min (z(:)) - max (z(:)));
-      addproperty ("zlevel", hg, "data", z);
-    else
-      addproperty ("zlevel", hg, "data", 0.);
-    endif
+    addproperty ("zlevel", hg, "data", 0.);
   endif
 
-  lvlstep = sum (abs (diff (lvl))) / (length (lvl) - 1);
+  lvlstep = sum (diff (lvl)) / (length (lvl) - 1);
 
   addproperty ("levellist", hg, "data", lev);
   addproperty ("levelstep", hg, "double", lvlstep);
   if (vnauto)
     addproperty ("levellistmode", hg, "radio", "{auto}|manual", "auto");
     addproperty ("levelstepmode", hg, "radio", "{auto}|manual", "auto");
   elseif (isscalar (vn))
     addproperty ("levellistmode", hg, "radio", "{auto}|manual", "auto");
@@ -177,111 +160,113 @@ function [c, hg] = __contour__ (varargin
   addproperty ("textstep", hg, "double", lvlstep);
   addproperty ("textstepmode", hg, "radio", "{auto}|manual", "auto");
   addproperty ("showtext", hg, "radio", "on|{off}", "off");
 
   addproperty ("linecolor", hg, "color", linespec.color, "{auto}|none");
   addproperty ("linestyle", hg, "linelinestyle", linespec.linestyle);
   addproperty ("linewidth", hg, "linelinewidth", 0.5);
 
-  ## FIXME It would be good to hide this property which is just an undocumented
-  ## alias for linecolor
-  addproperty ("edgecolor", hg, "color", edgecolor, "{flat}|none");
+  ## Matlab property, although Octave does not implement it.
+  addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
 
-  addlistener (hg, "fill", @update_data);
+  addlistener (hg, "fill", {@update_data, "fill"});
 
   addlistener (hg, "zlevelmode", @update_zlevel);
   addlistener (hg, "zlevel", @update_zlevel);
 
-  addlistener (hg, "levellist", @update_data);
-  addlistener (hg, "levelstep", @update_data);
+  addlistener (hg, "levellist", {@update_data, "levellist"});
+  addlistener (hg, "levelstep", {@update_data, "levelstep"});
   addlistener (hg, "levellistmode", @update_data);
   addlistener (hg, "levelstepmode", @update_data);
 
   addlistener (hg, "labelspacing", @update_text);
-  addlistener (hg, "textlist", @update_text);
+  addlistener (hg, "textlist", {@update_text, "textlist"});
   addlistener (hg, "textlistmode", @update_text);
-  addlistener (hg, "textstep", @update_text);
+  addlistener (hg, "textstep", {@update_text, "textstep"});
   addlistener (hg, "textstepmode", @update_text);
   addlistener (hg, "showtext", @update_text);
 
   addlistener (hg, "linecolor", @update_line);
   addlistener (hg, "linestyle", @update_line);
   addlistener (hg, "linewidth", @update_line);
 
-  addlistener (hg, "edgecolor", @update_edgecolor);
+  ## Set axis before adding patches so that each new patch does not trigger
+  ## new axis calculation.  No need if mode is already "manual".
+  if (all (strcmp (get (gca (), {"xlimmode", "ylimmode"}), "auto")))
+    axis ([min(x1(:)) max(x1(:)) min(y1(:)) max(y1(:))]);
+  endif
 
   add_patch_children (hg);
 
-  axis ("tight");
-
-  if (!isempty (opts))
+  if (! isempty (opts))
     set (hg, opts{:});
   endif
+
 endfunction
 
 function add_patch_children (hg)
   c = get (hg, "contourmatrix");
   lev = get (hg, "levellist");
   fill = get (hg, "fill");
   zlev = get (hg, "zlevel");
   zmode = get (hg, "zlevelmode");
   lc = get (hg, "linecolor");
   lw = get (hg, "linewidth");
   ls = get (hg, "linestyle");
   filled = get (hg, "fill");
   ca = gca ();
 
-  if (strcmpi (lc, "auto"))
+  ## Turn off automatic updating of clim while adding patches
+  climmode = get (ca, "climmode");
+  set (ca, "climmode", "manual"); 
+
+  if (strcmp (lc, "auto"))
     lc = "flat";
   endif
 
-  if (strcmpi (filled, "on"))
+  if (strcmp (filled, "on"))
 
     lvl_eps = get_lvl_eps (lev);
 
     ## Decode contourc output format.
-    i1 = 1;
+    i = 1;
     ncont = 0;
-    cont_lev = [];
-    cont_area = [];
-    while (i1 < columns (c))
+    while (i < columns (c))
       ncont++;
-      cont_lev(ncont) = c(1, i1);
-      cont_len(ncont) = c(2, i1);
-      cont_idx(ncont) = i1+1;
-      ii = i1+1:i1+cont_len(ncont);
+      cont_lev(ncont) = c(1, i);
+      cont_len(ncont) = c(2, i);
+      cont_idx(ncont) = i+1;
+      ii = i + (1:cont_len(ncont));
       cont_area(ncont) = polyarea (c(1, ii), c(2, ii));
-      i1 += c(2, i1) + 1;
+      i += cont_len(ncont) + 1;
     endwhile
 
     ## Handle for each level the case where we have (a) hole(s) in a patch.
     ## Those are to be filled with the color of level below or with the
     ## background colour.
     for k = 1:numel (lev)
       lvl_idx = find (abs (cont_lev - lev(k)) < lvl_eps);
       len = numel (lvl_idx);
       if (len > 1)
-        ## mark = logical (zeros (size (lvl_idx)));
         mark = false (size (lvl_idx));
         a = 1;
         while (a < len)
           ## take 1st patch
-          b = a + 1;
           pa_idx = lvl_idx(a);
           ## get pointer to contour start, and contour length
           curr_ct_idx = cont_idx(pa_idx);
           curr_ct_len = cont_len(pa_idx);
           ## get contour
           curr_ct = c(:, curr_ct_idx:curr_ct_idx+curr_ct_len-1);
           b_vec = (a+1):len;
           next_ct_pt_vec = c(:, cont_idx(lvl_idx(b_vec)));
           in = inpolygon (next_ct_pt_vec(1,:), next_ct_pt_vec(2,:),
                           curr_ct(1, :), curr_ct(2, :));
-          mark(b_vec(in)) = !mark(b_vec(in));
+          mark(b_vec(in)) = ! mark(b_vec(in));
           a++;
         endwhile
         if (numel (mark) > 0)
           ## All marked contours describe a hole in a larger contour of
           ## the same level and must be filled with colour of level below.
           ma_idx = lvl_idx(mark);
           if (k > 1)
             ## Find color of level below.
@@ -305,159 +290,173 @@ function add_patch_children (hg)
       ## delete double entries
       del_idx = max_idx(1:end-1);
       cont_area(del_idx) = cont_lev(del_idx) = [];
       cont_len(del_idx) = cont_idx(del_idx) = [];
     endif
 
     ## Now we have everything together and can start plotting the patches
     ## beginning with largest area.
-    [tmp, svec] = sort (cont_area);
+    [~, svec] = sort (cont_area);
     len = ncont - numel (del_idx);
     h = [];
-    for n = len:(-1):1
+    for n = len:-1:1
       idx = svec(n);
       ctmp = c(:, cont_idx(idx):cont_idx(idx) + cont_len(idx) - 1);
       if (all (ctmp(:,1) == ctmp(:,end)))
-        ctmp(:, end) = [];
-      else
-        ## Special case unclosed contours
+        ## patch() doesn't need/want closed contour.  It will do it itself.
+        ctmp(:,end) = [];
       endif
-      if (isnan (cont_lev (idx)))
+      if (isnan (cont_lev(idx)))
         fc = get (ca, "color");
         if (strcmp (fc, "none"))
           fc = get (ancestor (ca, "figure"), "color");
         endif
       else
         fc = "flat";
       endif
       h = [h; __go_patch__(ca, "xdata", ctmp(1, :)(:), "ydata", ctmp(2, :)(:),
                            "vertices", ctmp.', "faces", 1:(cont_len(idx)-1),
-                           "facevertexcdata", cont_lev(idx),
-                           "facecolor", fc, "cdata", cont_lev(idx),
-                           "edgecolor", lc, "linestyle", ls,
-                           "linewidth", lw, "parent", hg)];
+                           "facevertexcdata", cont_lev(idx), "facecolor", fc,
+                           "cdata", cont_lev(idx), "edgecolor", lc,
+                           "linestyle", ls, "linewidth", lw,
+                           "parent", hg)];
     endfor
 
     if (min (lev) == max (lev))
       set (ca, "clim", [min(lev)-1, max(lev)+1], "layer", "top");
     else
       set (ca, "clim", [min(lev), max(lev)], "layer", "top");
     endif
   else
     ## Decode contourc output format.
-    i1 = 1;
     h = [];
-    while (i1 < length (c))
-      clev = c(1,i1);
-      clen = c(2,i1);
+    i = 1;
+    while (i < length (c))
+      clev = c(1,i);
+      clen = c(2,i);
 
-      if (all (c(:,i1+1) == c(:,i1+clen)))
-        p = c(:, i1+1:i1+clen-1).';
+      if (all (c(:,i+1) == c(:,i+clen)))
+        p = c(:, i+1:i+clen-1).';
       else
-        p = [c(:, i1+1:i1+clen), NaN(2, 1)].';
+        p = [c(:, i+1:i+clen), NaN(2, 1)].';
       endif
 
       switch (zmode)
         case "none"
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
-                               "zdata", [], "facecolor", "none",
-                               "vertices", p, "faces", 1:rows(p),
-                               "facevertexcdata", clev,
-                               "edgecolor", lc, "linestyle", ls,
-                               "linewidth", lw,
-                               "cdata", clev, "parent", hg)];
+                               "zdata", [],
+                               "vertices", p, "faces", 1:rows (p),
+                               "facevertexcdata", clev, "facecolor", "none",
+                               "cdata", clev, "edgecolor", lc,
+                               "linestyle", ls, "linewidth", lw,
+                               "parent", hg)];
         case "auto"
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
-                               "zdata", clev * ones(rows(p),1),
+                               "zdata", clev * ones (rows (p),1),
                                "vertices", [p, clev * ones(rows(p),1)],
                                "faces", 1:rows(p),
-                               "facevertexcdata", clev,
-                               "facecolor", "none", "edgecolor", lc,
+                               "facevertexcdata", clev, "facecolor", "none",
+                               "cdata", clev, "edgecolor", lc,
                                "linestyle", ls, "linewidth", lw,
-                               "cdata", clev, "parent", hg)];
+                               "parent", hg)];
         otherwise
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
-                               "zdata", zlev * ones (rows(p), 1),
+                               "zdata", zlev * ones (rows (p), 1),
                                "vertices", [p, zlev * ones(rows(p),1)],
-                               "faces", 1:rows(p),
-                               "facevertexcdata", clev,
-                               "facecolor", "none", "edgecolor", lc,
+                               "faces", 1:rows (p),
+                               "facevertexcdata", clev, "facecolor", "none",
+                               "cdata", clev, "edgecolor", lc,
                                "linestyle", ls, "linewidth", lw,
-                               "cdata", clev, "parent", hg)];
+                               "parent", hg)];
       endswitch
-      i1 += clen + 1;
+      i += clen + 1;
     endwhile
   endif
 
+  set (ca, "climmode", climmode);
+
 endfunction
 
-function update_zlevel (h, d)
+function update_zlevel (h, ~)
   z = get (h, "zlevel");
   zmode = get (h, "zlevelmode");
   kids = get (h, "children");
 
   switch (zmode)
     case "none"
       set (kids, "zdata", []);
     case "auto"
       for i = 1 : length (kids)
-        set (kids(i), "zdata", get (kids (i), "cdata") .*
-             ones (size (get (kids (i), "xdata"))));
+        set (kids(i), "zdata", get (kids(i), "cdata") .*
+             ones (size (get (kids(i), "xdata"))));
       endfor
     otherwise
       for i = 1 : length (kids)
-        set (kids(i), "zdata", z .* ones (size (get (kids (i), "xdata"))));
+        set (kids(i), "zdata", z .* ones (size (get (kids(i), "xdata"))));
       endfor
   endswitch
 endfunction
 
-function update_edgecolor (h, d)
-  ec = get (h, "edgecolor");
+function update_line (h, ~)
   lc = get (h, "linecolor");
-  if (ischar (ec) && strcmpi (ec, "flat"))
-    if (! strcmpi (lc, "auto"))
-      set (h, "linecolor", "auto");
-    endif
-  elseif (! isequal (ec, lc))
-    set (h, "linecolor", ec);
-  endif
-endfunction
-
-function update_line (h, d)
-  lc = get (h, "linecolor");
-  ec = get (h, "edgecolor");
-  if (strcmpi (lc, "auto"))
+  if (strcmp (lc, "auto"))
     lc = "flat";
   endif
-  if (! isequal (ec, lc))
-    set (h, "edgecolor", lc);
-  endif
   set (findobj (h, "type", "patch"), "edgecolor", lc,
        "linewidth", get (h, "linewidth"), "linestyle", get (h, "linestyle"));
 endfunction
 
-function update_data (h, d)
+function update_data (h, ~, prop = "")
   persistent recursive = false;
 
-  if (!recursive)
+  if (! recursive)
     recursive = true;
 
     delete (get (h, "children"));
 
-    if (strcmpi (get (h, "levellistmode"), "manual"))
+    switch (prop)
+      case "levellist"
+        set (h, "levellistmode", "manual")
+      case "levelstep"
+        set (h, "levelstepmode", "manual")
+      case "fill"
+        ## Switching from filled ('k' linespec) to unfilled, reset linecolor
+        if (strcmp (get (h, "fill"), "off"))
+          set (h, "linecolor", "auto");
+        else
+          set (h, "linecolor", "black");
+        endif
+    endswitch
+
+    if (strcmp (get (h, "levellistmode"), "manual")
+        && ! strcmp (prop, "levelstep"))
       lvl = get (h, "levellist");
-    elseif (strcmpi (get (h, "levelstepmode"), "manual"))
+    elseif (strcmp (get (h, "levelstepmode"), "manual"))
       z = get (h, "zdata");
-      lvl = ceil ((max(z(:)) - min (z(:)) ./ get (h, "levelstep")));
+      lvs = get (h, "levelstep");
+      lvl(1) = ceil (min (z(:)) / lvs) * lvs;
+      lvl(2) = floor (max (z(:)) / lvs) * lvs;
+      if (lvl(1) >= lvl(2))
+        lvl = median (z(:));
+      else
+        lvl = lvl(1) : lvs : lvl(2);
+      endif
+      set (h, "levellist", lvl);
+      set (h, "levellistmode", "auto");
     else
-      lvl = 10;
+      z = get (h, "zdata");
+      ## FIXME: The levels should be determined similarly to {x,y,z}ticks
+      ##        so that they aren't set at extremely odd values.
+      lvl = linspace (min (z(!isinf (z))), max (z(!isinf (z))), 10 + 2);
+      ## Strip off max outlier, min must stay for contourf hole algorithm.
+      lvl = lvl(1:end-1);
     endif
 
-    if (strcmpi (get (h, "fill"), "on"))
+    if (strcmp (get (h, "fill"), "on"))
       X = get (h, "xdata");
       Y = get (h, "ydata");
       Z = get (h, "zdata");
       if (isvector (X) || isvector (Y))
         [X, Y] = meshgrid (X, Y);
       endif
       [nr, nc] = size (Z);
       X0 = prepad (X, nc+1, 2 * X(1, 1) - X(1, 2), 2);
@@ -470,59 +469,65 @@ function update_data (h, d)
       Z0(2:nr+1, 2:nc+1) = Z;
       [c, lev] = contourc (X0, Y0, Z0, lvl);
     else
       [c, lev] = contourc (get (h, "xdata"), get (h, "ydata"),
                            get (h, "zdata"), lvl);
     endif
     set (h, "contourmatrix", c);
 
-    if (strcmpi (get (h, "levellistmode"), "manual"))
+    if (strcmp (get (h, "levellistmode"), "manual"))
       ## Do nothing
-    elseif (strcmpi (get (h, "levelstepmode"), "manual"))
+    elseif (strcmp (get (h, "levelstepmode"), "manual"))
       set (h, "levellist", lev);
     else
       set (h, "levellist", lev);
-      z = get (h, "zdata");
-      lvlstep = (max (z(:)) - min (z(:))) / 10;
+      lvlstep = sum (diff (lvl)) / (length (lvl) - 1);
       set (h, "levelstep", lvlstep);
     endif
 
     add_patch_children (h);
-    update_text (h, d);
+    update_text (h);
+    recursive = false;
   endif
 
-  recursive = false;
 endfunction
 
-function update_text (h, d)
+function update_text (h, ~, prop = "")
   persistent recursive = false;
 
-  if (!recursive)
+  if (! recursive)
     recursive = true;
 
     delete (findobj (h, "type", "text"));
 
-    if (strcmpi (get (h, "textlistmode"), "manual"))
+    switch (prop)
+      case "textlist"
+        set (h, "textlistmode", "manual")
+      case "textstep"
+        set (h, "textstepmode", "manual")
+    endswitch
+
+    if (strcmp (get (h, "textlistmode"), "manual"))
       lvl = get (h, "textlist");
-    elseif (strcmpi (get (h, "textstepmode"), "manual"))
+    elseif (strcmp (get (h, "textstepmode"), "manual"))
       lev = get (h, "levellist");
 
       lvl_eps = get_lvl_eps (lev);
 
       stp = get (h, "textstep");
       t = [0, floor(cumsum(diff (lev)) / (abs(stp) - lvl_eps))];
       lvl = lev([true, t(1:end-1) != t(2:end)]);
       set (h, "textlist", lvl);
     else
       lvl = get (h, "levellist");
       set (h, "textlist", lvl, "textstep", get (h, "levelstep"));
     endif
 
-    if (strcmpi (get (h, "showtext"), "on"))
+    if (strcmp (get (h, "showtext"), "on"))
       switch (get (h, "zlevelmode"))
         case "manual"
           __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), get (h, "zlevel"));
         case "auto"
           __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), "auto");
         otherwise
@@ -531,22 +536,23 @@ function update_text (h, d)
       endswitch
     endif
 
     recursive = false;
   endif
 endfunction
 
 function lvl_eps = get_lvl_eps (lev)
-  ## FIXME -- is this the right thing to do for this tolerance?  Should
+  ## FIXME: is this the right thing to do for this tolerance?  Should
   ## it be an absolute or relative tolerance, or switch from one to the
   ## other depending on the value of lev?
   if (isscalar (lev))
     lvl_eps = abs (lev) * sqrt (eps) + sqrt (eps);
   else
     tmp = min (abs (diff (lev)));
     if (tmp < 10*eps)
       lvl_eps = sqrt (eps);
     else
       lvl_eps = tmp / 1000.0;
     endif
   endif
 endfunction
+
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/draw/private/__errcomm__.m
rename from scripts/plot/private/__errcomm__.m
rename to scripts/plot/draw/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/draw/private/__errcomm__.m
@@ -12,67 +12,68 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} __errcomm__ (@var{caller}, @var{p}, @dots{})
+## @deftypefn {Function File} {} __errcomm__ (@var{caller}, @var{hax}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Created: 20.02.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = __errcomm__ (caller, p, varargin)
+function retval = __errcomm__ (caller, hax, varargin)
 
   if (nargin < 4)
-    print_usage ();
+    print_usage (caller);
   endif
 
-  nargs = length (varargin);
   retval = [];
+  data = cell (6,1);
+  nargs = numel (varargin);
   k = 1;
-  data = cell (6,1);
   while (k <= nargs)
-    a = varargin{k++};
-    if (isvector (a))
-      a = a(:);
-    elseif (ismatrix (a))
-      ;
-    else
-      usage ("%s (...)", caller);
+    arg = varargin{k++};
+    if (! ismatrix (arg))
+      error ("%s: data argument %d must be numeric", caller, k-1);
     endif
-    sz = size (a);
+    if (isvector (arg))
+      arg = arg(:);
+    endif
+    sz = size (arg);
     ndata = 1;
-    data{ndata} = a;
+    data{ndata} = arg;
     while (k <= nargs)
-      a = varargin{k++};
-      if (ischar (a) || iscellstr (a))
-        retval = [retval; __errplot__(a, p, data{1:ndata})];
+      arg = varargin{k++};
+      if (ischar (arg) || iscellstr (arg))
+        retval(end+1,1) = __errplot__(arg, hax, data{1:ndata});
         break;
-      elseif (isvector (a))
-        a = a(:);
-      elseif (ismatrix (a))
-        ;
-      else
-        error ("wrong argument types");
+      endif
+      if (! ismatrix (arg))
+        error ("%s: data argument %d must be numeric", caller, k-1);
+      endif
+      if (isvector (arg))
+        arg = arg(:);
       endif
-      if (size (a) != sz)
-        error ("argument sizes do not match");
+      if (any (size (arg) != sz))
+        error ("%s: size of argument %d does not match others", caller, k-1);
       endif
-      data{++ndata} = a;
+      data{++ndata} = arg;
       if (ndata > 6)
-        error ("too many arguments to a plot");
+        error ("%s: too many arguments to plot", caller);
       endif
     endwhile
   endwhile
 
-  if (! (ischar (a) || iscellstr (a)))
-    retval = [retval; __errplot__("~", p, data{1:ndata})];
+  ## No format code found, use yerrorbar
+  if (! (ischar (arg) || iscellstr (arg)))
+    retval = [retval; __errplot__("~", hax, data{1:ndata})];
   endif
 
   drawnow ();
 
 endfunction
+
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/draw/private/__errplot__.m
rename from scripts/plot/private/__errplot__.m
rename to scripts/plot/draw/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/draw/private/__errplot__.m
@@ -12,172 +12,177 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{h} =} __errplot__ (@var{fstr}, @var{p}, @dots{})
+## @deftypefn {Function File} {@var{h} =} __errplot__ (@var{fstr}, @var{hax}, @dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function h = __errplot__ (fstr, p, varargin)
-
-  if (nargin < 4 || nargin > 8) # at least two data arguments needed
-    print_usage ();
-  endif
+function h = __errplot__ (fstr, hax, varargin)
 
-  [fmt, valid] = __pltopt__ ("__errplot__", fstr);
-
-  [len, nplots] = size (varargin{1});
-  h = [];
-
-  for i = 1:nplots
-    ## Set the plot type based on linestyle.
+  fmt = __pltopt__ ("__errplot__", fstr);
 
-    if (strcmp (fmt.errorstyle, "~"))
+  ## Set the plot type based on linestyle.
+  switch (fmt.errorstyle) 
+    case "~"
       ifmt = "yerr";
-    elseif (strcmp (fmt.errorstyle, ">"))
+    case ">"
       ifmt = "xerr";
-    elseif (strcmp (fmt.errorstyle, "~>"))
+    case "~>"
       ifmt = "xyerr";
-    elseif (strcmp (fmt.errorstyle, "#"))
+    case "#"
       ifmt = "box";
-    elseif (strcmp (fmt.errorstyle, "#~"))
+    case "#~"
       ifmt = "boxy";
-    elseif (strcmp (fmt.errorstyle, "#~>"))
+    case "#~>"
       ifmt = "boxxy";
+    otherwise
+      ifmt = "yerr";
+  endswitch
+
+  h = [];
+  nplots = columns (varargin{1});
+  for i = 1:nplots
+
+    if (isempty (fmt.color))
+      lc = __next_line_color__ ();
     else
-      ifmt = "yerr";
+      lc = fmt.color ();
+    endif
+    if (isempty (fmt.marker) && isempty (fmt.linestyle))
+      [ls, mk] = __next_line_style__ ();
+    else
+      ls = fmt.linestyle;
+      mk = fmt.marker;
     endif
 
-    hg = hggroup ("parent", p);
+    ## Must occur after __next_line_color__ in order to work correctly.
+    hg = hggroup ("parent", hax);
     h = [h; hg];
     args = __add_datasource__ ("__errplot__", hg,
                                {"x", "y", "l", "u", "xl", "xu"});
 
-    if (isempty (fmt.color))
-      fmt.color = __next_line_color__ ();
-    endif
-    if (isempty (fmt.marker) && isempty (fmt.linestyle))
-      [fmt.linestyle, fmt.marker] = __next_line_style__ ();
-    endif
-    hl = [(__line__ (hg, "linestyle", fmt.linestyle, "marker", fmt.marker,
-                   "color", fmt.color)),
-          (__line__ (hg, "linestyle", "-", "marker", "none",
-                   "color", fmt.color))];
+    hl = [(__line__ (hg, "color", lc, "linestyle", ls, "marker", mk)),
+          (__line__ (hg, "color", lc, "linestyle", "-", "marker", "none"))];
 
     switch (numel (varargin))
       case 2
         ydata = varargin{1}(:,i);
         xdata = 1:numel (ydata);
-        if (strcmp (ifmt, "xerr") || strcmp (ifmt, "box"))
+        if (strcmp (ifmt, "yerr") || strcmp (ifmt, "boxy"))
+          ldata  = varargin{2}(:,i);
+          udata  = ldata;
+          xldata = [];
+          xudata = [];
+        elseif (strcmp (ifmt, "xerr") || strcmp (ifmt, "box"))
           xldata = varargin{2}(:,i);
           xudata = ldata;
-          ldata = [];
-          udata = [];
-        elseif (strcmp (ifmt, "yerr") || strcmp (ifmt, "boxy"))
-          ldata = varargin{2}(:,i);
-          udata = ldata;
-          xldata = [];
-          xudata = [];
+          ldata  = [];
+          udata  = [];
         else
           error ("errorbar: 2 column errorplot is only valid for xerr or yerr");
         endif
       case 3
-        if (strcmp (ifmt, "boxxy") || strcmp (ifmt, "xyerr"))
-          ydata = varargin{1}(:,i);
-          xdata = 1:numel (ydata);
+        if (strcmp (ifmt, "yerr") || strcmp (ifmt, "boxy"))
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
+          ldata  = varargin{3}(:,i);
+          udata  = ldata;
+          xldata = [];
+          xudata = [];
+        elseif (strcmp (ifmt, "xyerr") || strcmp (ifmt, "boxxy"))
+          ydata  = varargin{1}(:,i);
+          xdata  = 1:numel (ydata);
           xldata = varargin{2}(:,i);
           xudata = xldata;
-          ldata = varargin{3}(:,i);
-          udata = ldata;
-        elseif (strcmp (ifmt, "xerr") || strcmp (ifmt, "box"))
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
-          xldata = varargin{3}(:,i);
-          xudata = xldata;
-          ldata = [];
-          udata = [];
-        else # yerr or boxy
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
-          ldata = varargin{3}(:,i);
-          udata = ldata;
-          xldata = [];
-          xudata = [];
-        endif
-      case 4
-        if (strcmp (ifmt, "boxxy") || strcmp (ifmt, "xyerr"))
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
+          ldata  = varargin{3}(:,i);
+          udata  = ldata;
+        else  # xerr or box
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
           xldata = varargin{3}(:,i);
           xudata = xldata;
-          ldata = varargin{4}(:,i);
-          udata = ldata;
-        elseif (strcmp (ifmt, "xerr") || strcmp (ifmt, "box"))
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
+          ldata  = [];
+          udata  = [];
+        endif
+      case 4
+        if (strcmp (ifmt, "yerr") || strcmp (ifmt, "boxy"))
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
+          ldata  = varargin{3}(:,i);
+          udata  = varargin{4}(:,i);
+          xldata = [];
+          xudata = [];
+        elseif (strcmp (ifmt, "xyerr") || strcmp (ifmt, "boxxy"))
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
+          xldata = varargin{3}(:,i);
+          xudata = xldata;
+          ldata  = varargin{4}(:,i);
+          udata  = ldata;
+        else  # xerr or box
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
           xldata = varargin{3}(:,i);
           xudata = varargin{4}(:,i);
-          ldata = [];
-          udata = [];
-        else # yerr or boxy
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
-          ldata = varargin{3}(:,i);
-          udata = varargin{4}(:,i);
-          xldata = [];
-          xudata = [];
+          ldata  = [];
+          udata  = [];
         endif
-      case 6 # boxxy, xyerr
-        if (strcmp (ifmt, "boxxy") || strcmp (ifmt, "xyerr"))
-          xdata = varargin{1}(:,i);
-          ydata = varargin{2}(:,i);
+      case 6  # xyerr, boxxy
+        if (strcmp (ifmt, "xyerr") || strcmp (ifmt, "boxxy"))
+          xdata  = varargin{1}(:,i);
+          ydata  = varargin{2}(:,i);
           xldata = varargin{3}(:,i);
           xudata = varargin{4}(:,i);
-          ldata = varargin{5}(:,i);
-          udata = varargin{6}(:,i);
+          ldata  = varargin{5}(:,i);
+          udata  = varargin{6}(:,i);
         else
-          error ("errorbar: error plot with 6 columns only valid for boxxy and xyerr");
+          error ("errorbar: error plot with 6 columns only valid for xyerr and boxxy");
         endif
       otherwise
         error ("errorbar: error plot requires 2, 3, 4, or 6 arguments");
     endswitch
 
     addproperty ("xdata", hg, "data", xdata(:));
     addproperty ("ydata", hg, "data", ydata(:));
     addproperty ("ldata", hg, "data", ldata(:));
     addproperty ("udata", hg, "data", udata(:));
     addproperty ("xldata", hg, "data", xldata(:));
     addproperty ("xudata", hg, "data", xudata(:));
     addproperty ("format", hg, "string", ifmt);
 
     addproperty ("color", hg, "linecolor", get (hl(1), "color"));
+    addproperty ("linestyle", hg, "linelinestyle", get (hl(1), "linestyle"));
     addproperty ("linewidth", hg, "linelinewidth", get (hl(1), "linewidth"));
-    addproperty ("linestyle", hg, "linelinestyle", get (hl(1), "linestyle"));
     addproperty ("marker", hg, "linemarker", get (hl(1), "marker"));
+    addproperty ("markeredgecolor", hg, "linemarkerfacecolor",
+                 get (hl(1), "markeredgecolor"));
     addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
                  get (hl(1), "markerfacecolor"));
-    addproperty ("markeredgecolor", hg, "linemarkerfacecolor",
-                 get (hl(1), "markeredgecolor"));
     addproperty ("markersize", hg, "linemarkersize",
                  get (hl(1), "markersize"));
 
+    ## Matlab property, although Octave does not implement it.
+    addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
     fcn = {@update_props, hl};
     addlistener (hg, "color", fcn);
+    addlistener (hg, "linestyle", fcn);
     addlistener (hg, "linewidth", fcn);
-    addlistener (hg, "linestyle", fcn);
     addlistener (hg, "marker", fcn);
+    addlistener (hg, "markeredgecolor", fcn);
     addlistener (hg, "markerfacecolor", fcn);
     addlistener (hg, "markersize", fcn);
 
     fcn = {@update_data, hl};
     addlistener (hg, "xdata", fcn);
     addlistener (hg, "ydata", fcn);
     addlistener (hg, "ldata", fcn);
     addlistener (hg, "udata", fcn);
@@ -193,18 +198,18 @@ function h = __errplot__ (fstr, p, varar
 
   endfor
 
   ## Process legend key
   if (! isempty (fmt.key))    
     hlegend = [];
     fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
-      if (ishandle (fkids(i)) && strcmp (get (fkids(i), "type"), "axes")
-          && (strcmp (get (fkids(i), "tag"), "legend")))
+      if (   strcmp (get (fkids(i), "type"), "axes")
+          && strcmp (get (fkids(i), "tag"), "legend"))
         udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
       endif
     endfor
 
@@ -227,31 +232,39 @@ function [xdata, ydata] = errorbar_data 
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
     dx = 0.01 * (max (xdata(:)) - min (xdata(:)));
     xlo = xdata - dx;
     xhi = xdata + dx;
   else
     n = xdata > 0;
-    rx = exp (0.01 * (max (log (xdata(n))) - min (log (xdata(n)))));
+    if (! any (n))
+      n = xdata < 0;
+    endif
+    logdata = log (abs (xdata(n)));
+    rx = exp (0.01 * (max (logdata) - min (logdata)));
     xlo = xdata/rx;
     xhi = xdata*rx;
   endif
   if (strcmp (yscale, "linear"))
     dy = 0.01 * (max (ydata(:)) - min (ydata(:)));
     ylo = ydata - dy;
     yhi = ydata + dy;
   else
     n = ydata > 0;
-    ry = exp (0.01 * (max (log (ydata(n))) - min (log (ydata(n)))));
+    if (! any (n))
+      n = ydata < 0;
+    endif
+    logdata = log (abs (ydata(n)));
+    ry = exp (0.01 * (max (logdata) - min (logdata)));
     ylo = ydata/ry;
     yhi = ydata*ry;
   endif
-  nans = NaN + xdata(:);
+  nans = NaN + xdata(:);  # fast way to do NaN (size (xdata(:)))
   if (strcmp (ifmt, "yerr"))
     xdata = [xdata, xdata, nans, ...
              xlo, xhi, nans, ...
              xlo, xhi, nans];
     ydata = [ydata-ldata, ydata+udata, nans, ...
              ydata+udata, ydata+udata, nans, ...
              ydata-ldata, ydata-ldata, nans];
   elseif (strcmp (ifmt, "xerr"))
@@ -278,51 +291,51 @@ function [xdata, ydata] = errorbar_data 
              ydata-ldata, nans];
   elseif (strcmp (ifmt, "xyerr"))
     [x1, y1] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "xerr", xscale, yscale);
     [x2, y2] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "yerr", xscale, yscale);
     xdata = [x1; x2];
     ydata = [y1; y2];
-    return
+    return;
   else
-    error ("errorbar: valid error bar types are xerr, yerr, boxxy, and xyerr");
+    error ("errorbar: valid error bar types are xerr, yerr, xyerr, box, boxy, boxxy");
   endif
 
   xdata = xdata.'(:);
   ydata = ydata.'(:);
 
 endfunction
 
-function update_props (hg, dummy, hl)
+function update_props (hg, ~, hl)
   set (hl, "color", get (hg, "color"),
-           "linewidth", get (hg, "linewidth"));,
+           "linewidth", get (hg, "linewidth"));
   set (hl(1), "linestyle", get (hg, "linestyle"),
               "marker", get (hg, "marker"),
-              "markersize", get (hg, "markersize"),
+              "markeredgecolor", get (hg, "markeredgecolor"),
               "markerfacecolor", get (hg, "markerfacecolor"),
-              "markeredgecolor", get (hg, "markeredgecolor"));
+              "markersize", get (hg, "markersize"));
 endfunction
 
-function update_data (hg, dummy, hl)
+function update_data (hg, ~, hl)
 
   if (strcmp (get (hg, "type"), "axes"))
     hax = hg;
     hg = ancestor (hl(1), "hggroup");
   else
     hax = ancestor (hg, "axes");
   endif
   xscale = get (hax, "xscale");
   yscale = get (hax, "yscale");
 
-  xdata = get (hg, "xdata");
-  ydata = get (hg, "ydata");
-  ldata = get (hg, "ldata");
-  udata = get (hg, "udata");
+  xdata  = get (hg, "xdata");
+  ydata  = get (hg, "ydata");
+  ldata  = get (hg, "ldata");
+  udata  = get (hg, "udata");
   xldata = get (hg, "xldata");
   xudata = get (hg, "xudata");
   ifmt = get (hg, "format");
 
   set (hl(1), "xdata", xdata);
   set (hl(1), "ydata", ydata);
 
   [errorbar_xdata, errorbar_ydata] = ...
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/draw/private/__ezplot__.m
rename from scripts/plot/private/__ezplot__.m
rename to scripts/plot/draw/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/draw/private/__ezplot__.m
@@ -12,231 +12,247 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{h}, @var{needusage}] =} __ezplot__ (@var{pfunc}, @var{varargin})
+## @deftypefn {Function File} {[@var{h}, @var{needusage}] =} __ezplot__ (@var{pltfunc}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function [h, needusage] = __ezplot__ (pfunc, varargin)
+## Overview: This function is the back-end for the 9 ez* plot functions.
+##           As such, most of the function is actually dedicated to sorting
+##           out the inputs and verifying that the particular ez* function
+##           called was called correctly.  The actual plotting occurs near
+##           the end in an unwind_protect block. 
 
-  func = cstrcat ("ez", pfunc);
-  if (strncmp (pfunc, "contour", 7))
-    iscontour = true;
-  else
-    iscontour = false;
-  endif
-  if (strcmp (pfunc, "plot"))
-    isplot = true;
-    isplot3 = false;
-    ispolar = false;
-    nargs = 1;
-  elseif (strcmp (pfunc, "plot3"))
-    isplot = false;
-    isplot3 = true;
-    ispolar = false;
-    nargs = 1;
-  elseif (strcmp (pfunc, "polar"))
-    isplot = false;
-    isplot3 = false;
-    ispolar = true;
-    nargs = 1;
-  else
-    isplot = false;
-    isplot3 = false;
-    ispolar = false;
-    nargs = 2;
-  endif
+function [h, needusage] = __ezplot__ (pltfunc, varargin)
+
+  ezfunc = ["ez" pltfunc];
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ (func, varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ (ezfunc, varargin{:});
 
+  ## Define outputs early in case of shorting out of function with return;
+  h = [];
   needusage = false;
   if (nargin < 1)
     needusage = true;
     return;
   endif
 
+  iscontour = strncmp (pltfunc, "contour", 7);
+
+  ## Defaults for ezplot
+  isplot  = true;
+  isplot3 = false;
+  ispolar = false;
+  nargs = 1;
+  switch (pltfunc)
+    case "plot"
+      ## defaults already set
+
+    case "plot3"
+      isplot  = false;
+      isplot3 = true;
+  
+    case "polar"
+      isplot  = false;
+      ispolar = true;
+    
+    otherwise
+      ## contour, mesh, surf plots
+      isplot  = false;
+      nargs = 2;
+
+  endswitch
+
   parametric = false;
-  fun = varargin {1};
+  fun = varargin{1};
   if (ischar (fun))
     if (exist (fun, "file") || exist (fun, "builtin"))
-      fun = vectorize (inline (cstrcat (fun, "(t)")));
+      fun = inline ([fun "(t)"]);
     else
       fun = vectorize (inline (fun));
     endif
-    if (isplot && length (argnames (fun)) == 2)
+    argids = argnames (fun);
+    if (isplot && length (argids) == 2)
       nargs = 2;
-    elseif (length (argnames (fun)) != nargs)
-      error ("%s: excepting a function of %d arguments", func, nargs);
+    elseif (numel (argids) != nargs)
+      error ("%s: expecting a function of %d arguments", ezfunc, nargs);
     endif
     fstr = formula (fun);
     if (isplot)
-      xarg = (argnames (fun)){1};
+      xarg = argids{1};
       if (nargs == 2)
-        yarg = (argnames (fun)){2};
+        yarg = argids{2};
       else
         yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
-      xarg = (argnames (fun)){1};
-      yarg = (argnames (fun)){2};
+      xarg = argids{1};
+      yarg = argids{2};
     endif
   elseif (strcmp (typeinfo (fun), "inline function"))
-    if (isplot && length (argnames (fun)) == 2)
+    argids = argnames (fun);
+    if (isplot && length (argids) == 2)
       nargs = 2;
-    elseif (length (argnames (fun)) != nargs)
-      error ("%s: excepting a function of %d arguments", func, nargs);
+    elseif (numel (argids) != nargs)
+      error ("%s: expecting a function of %d arguments", ezfunc, nargs);
     endif
     fun = vectorize (fun);
     fstr = formula (fun);
     if (isplot)
-      xarg = (argnames (fun)){1};
+      xarg = argids{1};
       if (nargs == 2)
-        yarg = (argnames (fun)){2};
+        yarg = argids{2};
       else
         yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (isplot || ispolar)
       xarg = "";
       yarg = "";
     else
-      xarg = (argnames (fun))(1);
-      yarg = (argnames (fun))(2);
+      xarg = argids{1};
+      yarg = argids{2};
     endif
   elseif (isa (fun, "function_handle"))
     fstr = func2str (fun);
-    if (! isempty (strfind (fstr, ')')))
-      args = regexp (substr (fstr, 3, strfind (fstr, ')')(1) - 3),
-                     '(\w+)', 'tokens');
-    fstr = substr (fstr, strfind (fstr, ')')(1) + 1);
+    idx = index (fstr, ')');
+    if (idx != 0)
+      args = regexp (fstr(3:(idx-1)), '\w+', 'match');
+      fstr = fstr(idx+2:end);  # remove '@(x) ' from string name
     else
-      args = {{"x"}};
+      args = {"x"};
     endif
     if (isplot && length (args) == 2)
       nargs = 2;
-    elseif (length (args) != nargs)
-      error ("%s: excepting a function of %d arguments", func, nargs);
+    elseif (numel (args) != nargs)
+      error ("%s: expecting a function of %d arguments", ezfunc, nargs);
     endif
     if (isplot)
-      xarg = args{1}{1};
+      xarg = args{1};
       if (nargs == 2)
-        yarg = args{2}{1};
+        yarg = args{2};
       else
         yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
-      xarg = args{1}{1};
-      yarg = args{2}{1};
+      xarg = args{1};
+      yarg = args{2};
     endif
   else
-    error ("%s: expecting string, inline function or function handle", func);
+    error ("%s: expecting string, inline function, or function handle", ezfunc);
   endif
 
   if (nargin > 2 || (nargin == 2 && isplot))
     funx = fun;
     fstrx = fstr;
-    funy = varargin {2};
+    funy = varargin{2};
     if (ischar (funy) && ! strcmp (funy, "circ") && ! strcmp (funy, "animate"))
       parametric = true;
       if (exist (funy, "file") || exist (funy, "builtin"))
-        funy = vectorize (inline (cstrcat (funy, "(t)")));
+        funy = inline ([funy "(t)"]);
       else
         funy = vectorize (inline (funy));
       endif
-      if (length (argnames (funy)) != nargs)
-        error ("%s: excepting a function of %d arguments", func, nargs);
+      if (numel (argnames (funy)) != nargs)
+        error ("%s: expecting a function of %d arguments", ezfunc, nargs);
       endif
       fstry = formula (funy);
     elseif (strcmp (typeinfo (funy), "inline function"))
       parametric = true;
-      if (length (argnames (funy)) != nargs)
-        error ("%s: excepting a function of %d arguments", func, nargs);
+      if (numel (argnames (funy)) != nargs)
+        error ("%s: expecting a function of %d arguments", ezfunc, nargs);
       endif
       funy = vectorize (funy);
       fstry = formula (funy);
     elseif (isa (funy, "function_handle"))
       parametric = true;
       fstry = func2str (funy);
-      if (! isempty (strfind (fstry, ')')))
-        args = regexp (substr (fstry, 3, strfind (fstry, ')')(1) - 3),
-                       '(\w+)', 'tokens');
-        fstry = substr (fstry, strfind (fstry, ')')(1) + 1);
+      idx = index (fstry, ')');
+      if (idx != 0)
+        args = regexp (fstry(3:(idx-1)), '\w+', 'match');
+        fstry = fstry(idx+2:end);  # remove '@(x) ' from string name
       else
-        args = {{"y"}};
+        args = {"y"};
       endif
-      if (length (args) != nargs)
-        error ("%s: excepting a function of %d arguments", func, nargs);
+      if (numel (args) != nargs)
+        error ("%s: expecting a function of %d arguments", ezfunc, nargs);
       endif
     endif
 
-    if (parametric && isplot)
-      xarg = "x";
-      yarg = "y";
+    if (! parametric && isplot3)
+      needusage = true;  # Can't call non-parametric ezplot3
+      return;
+    elseif (parametric && isplot)
       if (nargs == 2)
-        error ("%s: can not define a parametric function in this manner");
+        error ("%s: can not define a parametric function in this manner", ezfunc);
+      else
+        xarg = "x";
+        yarg = "y";
       endif
-    endif
-
-    if (!isplot && parametric)
-      funz = varargin {3};
+    elseif (parametric)
+      funz = varargin{3};
       if (ischar (funz) && ! strcmp (funz, "circ")
           && ! strcmp (funz, "animate"))
         if (exist (funz, "file") || exist (funz, "builtin"))
-          funz = vectorize (inline (cstrcat (funz, "(t)")));
+          funz = inline ([funz "(t)"]);
         else
           funz = vectorize (inline (funz));
         endif
-        if (length (argnames (funz)) != nargs)
-          error ("%s: excepting a function of %d arguments", func, nargs);
+        if (numel (argnames (funz)) > nargs)
+          error ("%s: expecting a function of %d arguments", ezfunc, nargs);
         endif
         fstrz = formula (funz);
       elseif (strcmp (typeinfo (funz), "inline function"))
-        if (length (argnames (funz)) != nargs)
-          error ("%s: excepting a function of %d arguments", func, nargs);
+        if (numel (argnames (funz)) != nargs)
+          error ("%s: expecting a function of %d arguments", ezfunc, nargs);
         endif
         funz = vectorize (funz);
         fstrz = formula (funz);
       elseif (isa (funz, "function_handle"))
         fstrz = func2str (funz);
-        args = regexp (substr (fstrz, 3, strfind (fstrz, ')')(1) - 3),
-                       '(\w+)', 'tokens');
-        if (length (args) != nargs)
-          error ("%s: excepting a function of %d arguments", func, nargs);
+        idx = index (fstrz, ')');
+        if (idx != 0)
+          args = regexp (fstrz(3:(idx-1)), '\w+', 'match');
+          fstrz = fstrz(idx+2:end);  # remove '@(x) ' from string name
+        else
+          args = {"z"};
         endif
-        fstrz = substr (fstrz, strfind (fstrz, ')')(1) + 1);
+        if (numel (args) != nargs)
+          error ("%s: expecting a function of %d arguments", ezfunc, nargs);
+        endif
       else
-        error ("%s: parametric plots expect 3 functions", func);
+        error ("%s: parametric plots expect 3 functions", ezfunc);
       endif
     endif
   endif
 
-  if (isplot && nargs != 2)
-    n = 500;
+  if ((isplot && nargs != 2) || isplot3 || ispolar)
+    n = 500;   # default for point-style functions like plot
   else
-    n = 60;
+    n = 60;    # default for meshgrid style functions like contour, surf
   endif
   domain = [];
   circ = false;
   animate = false;
   if (parametric)
     if (isplot)
       iarg = 3;
     else
@@ -249,197 +265,301 @@ function [h, needusage] = __ezplot__ (pf
     arg = varargin{iarg++};
     if (ischar (arg) && strcmp (arg, "circ"))
       circ = true;
     elseif (ischar (arg) && strcmp (arg, "animate"))
       animate = true;
     elseif (isscalar (arg))
       n = arg;
     elseif (numel (arg) == 2)
-      domain = [arg(:).' arg(:).'];
+      domain = [arg(1) arg(2) arg(1) arg(2)];
     elseif (numel (arg) == 4)
       domain = arg(:).';
     else
-      error ("%s: expecting scalar, 2 or 4 element vector", func);
+      error ("%s: expecting scalar, 2-, or 4-element vector", ezfunc);
     endif
   endwhile
 
+  if (circ && (iscontour || isplot3 || isplot))
+    needusage = true;
+    return;
+  elseif (circ && parametric)
+    error ("%s: can not have both circular domain and parametric function",
+           ezfunc);
+  endif
+
+  if (animate && ! isplot3)
+    error ("%s: animate option only valid for ezplot3", ezfunc);
+  endif
+
+  if (parametric)
+    ## Make the label strings pretty by removing extra spaces between base
+    ## and exponent, the '.' in vectorized code, and the '*' for multiply.
+    fstrx = regexprep (regexprep (regexprep (fstrx,
+           '\s*\.?(?:\^|\*\*)\s*','^'), '\.([/+-])', '$1'), '\s*\.?\*\s*', ' ');
+    fstry = regexprep (regexprep (regexprep (fstry,
+           '\s*\.?(?:\^|\*\*)\s*','^'), '\.([/+-])', '$1'), '\s*\.?\*\s*', ' ');
+    if (isplot)
+      fstr = ["x = " fstrx ", y = " fstry];
+    else
+      fstrz = regexprep (regexprep (regexprep (fstrz,
+           '\s*\.?(?:\^|\*\*)\s*','^'), '\.([/+-])', '$1'), '\s*\.?\*\s*', ' ');
+      fstr = ["x = " fstrx ",y = " fstry ", z = " fstrz];
+    endif
+  else
+    fstr = regexprep (regexprep (regexprep (fstr,
+           '\s*\.?(?:\^|\*\*)\s*','^'), '\.([/+-])', '$1'), '\s*\.?\*\s*', ' ');
+    if (isplot && nargs == 2)
+      fstr = [fstr " = 0"];  # make title string of implicit function
+    endif
+  endif
+
   if (isempty (domain))
+    auto_domain = true;
     if (isplot3 || ispolar)
       domain = [0, 2*pi, 0, 2*pi];
     else
       domain = [-2*pi, 2*pi, -2*pi, 2*pi];
     endif
-  endif
-
-  if (circ)
-    if (iscontour || isplot3 || isplot)
-      needusage = true;
-      return;
-    endif
-    if (parametric)
-      error ("%s: can not have both circular domain and parametric function",
-             func);
-    endif
-    cent = [domain(1) + domain(2), domain(3) + domain(4)] / 2;
-    funx = @(r,t) r .* cos (t) + cent (1);
-    funy = @(r,t) r .* sin (t) + cent (2);
-    domain = [0, sqrt((domain(2) - cent(1))^2 + (domain(4) - cent(2))^2), ...
-              -pi, pi];
-    funz = fun;
-    parametric = true;
-  endif
-
-  if (animate)
-    if (!isplot3)
-      error ("%s: animated graphs only valid with plot3", func);
-    endif
-    error ("%s: animated graphs not implemented", func);
-  endif
-
-  if (isplot3 || ispolar || (isplot && nargs == 1))
-    X = linspace (domain (1), domain (2), n);
-  elseif (isplot && numel (domain) == 2)
-    x = linspace (domain (1), domain (2), n);
-    [X, Y] = meshgrid (x, x);
   else
-    x = linspace (domain (1), domain (2), n);
-    y = linspace (domain (3), domain (4), n);
-    [X, Y] = meshgrid (x, y);
+    auto_domain = false;
   endif
 
-  if (parametric)
-    if (isplot)
-      XX = feval (funx, X);
-      Z = feval (funy, X);
-      X = XX;
-    elseif (isplot3)
-      Z = feval (funz, X);
-      XX = feval (funx, X);
-      YY = feval (funy, X);
-      X = XX;
-      Y = YY;
-    else
-      Z = feval (funz, X, Y);
-      XX = feval (funx, X, Y);
-      YY = feval (funy, X, Y);
-      X = XX;
-      Y = YY;
+  auto_domain_done = false;
+  do
+    domain_ok = true;
 
-      ## Eliminate the singularities
-      X = __eliminate_sing__ (X);
-      Y = __eliminate_sing__ (Y);
-      Z = __eliminate_sing__ (Z);
-    endif
-
-    fstrx = regexprep (regexprep (regexprep (fstrx,'\s*\.?\^\s*','^'),
-                      '\./', '/'), '\.?\*', '');
-    fstry = regexprep (regexprep (regexprep (fstry,'\s*\.?\^\s*','^'),
-                      '\./', '/'), '\.?\*', '');
-    if (isplot)
-      fstr = cstrcat ("x = ",fstrx,", y = ",fstry);
-    else
-      fstrz = regexprep (regexprep (regexprep (fstrz,'\s*\.?\^\s*','^'),
-                                    '\./', '/'), '\.?\*', '');
-      fstr = cstrcat ("x = ",fstrx,",y = ",fstry,", z = ",fstrz);
-    endif
-  else
-    if (isplot3)
-      needusage = true;
-      return;
+    if ((isplot && nargs == 1) || isplot3 || ispolar)
+      X = linspace (domain(1), domain(2), n);
+    elseif (isplot && numel (domain) == 2)
+      x = linspace (domain(1), domain(2), n);
+      [X, Y] = meshgrid (x, x);
+    elseif (circ)
+      ## To plot on circular domain develop grid in polar coordinates
+      ## and then switch these to Cartesian coordinates.
+      cent = [domain(1) + domain(2), domain(3) + domain(4)] / 2;
+      rmax = sqrt ((domain(2) - cent(1))^2 + (domain(4) - cent(2))^2);
+      r = linspace (0, rmax, n);
+      t = linspace (0, 2*pi, n);
+      [T, R] = meshgrid (t, r);
+      X = R .* cos (T) + cent(1);
+      Y = R .* sin (T) + cent(2);
+      domain = [-rmax+cent(1), +rmax+cent(1), -rmax+cent(2), +rmax+cent(2)];
+    else  # contour, mesh, surf plots
+      x = linspace (domain(1), domain(2), n);
+      y = linspace (domain(3), domain(4), n);
+      [X, Y] = meshgrid (x, y);
     endif
 
-    fstr = regexprep (regexprep (regexprep (fstr,'\s*\.?\^\s*','^'), '\./', '/'),
-                      '\.?\*', '');
-    if (isplot && nargs == 2)
-      if (strcmp (typeinfo (fun), "inline function")
-          && !isempty (strfind (formula (fun) , "=")))
-        fun = inline (cstrcat (strrep (formula (fun), "=", "- ("), ")"));
+    if (parametric)
+      if (isplot)
+        XX = feval (funx, X);
+        Z = feval (funy, X);
+        X = XX;
+      elseif (isplot3)
+        Z = feval (funz, X);
+        XX = feval (funx, X);
+        YY = feval (funy, X);
+        X = XX;
+        Y = YY;
       else
-        fstr = cstrcat (fstr, " = 0");
-      endif
-
-      Z = feval (fun, X, Y);
-
-      ## Matlab returns line objects for this case and so can't call
-      ## contour directly as it returns patch objects to allow colormaps
-      ## to work with contours. Therefore recreate the lines from the
-      ## output for contourc, and store in cell arrays.
-      [c, lev] = contourc (X, Y, Z, [0, 0]);
+        Z = feval (funz, X, Y);
+        XX = feval (funx, X, Y);
+        YY = feval (funy, X, Y);
+        X = XX;
+        Y = YY;
 
-      i1 = 1;
-      XX = {};
-      YY = {};
-      while (i1 < length (c))
-        clev = c(1,i1);
-        clen = c(2,i1);
-        XX = [XX, {c(1, i1+1:i1+clen)}];
-        YY = [YY, {c(2, i1+1:i1+clen)}];
-        i1 += clen+1;
-      endwhile
-    else
-      if (ispolar)
-        Z = feval (fun, X);
-      elseif (isplot)
-        Z = real (feval (fun, X));
-
-        ## Eliminate the singularities. This seems to be what matlab
-        ## does, but can't be sure.
-        XX = sort (Z (isfinite (Z)));
-        if (length (X) > 4)
-          d = XX(fix (7 * length (XX) / 8)) - XX(fix (length (XX) / 8));
-          yrange = [max(XX(1) - d/8, XX(fix (length (XX) / 8)) - d), ...
-                    min(XX(end) + d/8, XX(fix (7 * length (XX) / 8)) + d)];
-        else
-          yrange = [XX(1), XX(end)];
-        endif
-
-        idx = 2 : length (Z);
-        idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
-                 ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange (2) / 2)));
-        if (any (idx))
-          Z(idx) = NaN;
-        endif
-      else
+        ## Eliminate the singularities
+        X = __eliminate_sing__ (X);
+        Y = __eliminate_sing__ (Y);
+        Z = __eliminate_sing__ (Z);
+      endif
+    else  ## non-parametric plots
+      if (isplot && nargs == 2)
         Z = feval (fun, X, Y);
 
-        ## Eliminate the singularities
-        Z = __eliminate_sing__ (Z);
+        ## Matlab returns line objects for this case and so can't call
+        ## contour directly as it returns patch objects to allow colormaps
+        ## to work with contours.  Therefore recreate the lines from the
+        ## output for contourc, and store in cell arrays.
+        [c, ~] = contourc (X, Y, Z, [0, 0]);
+
+        i = 1;
+        XX = YY = {};
+        while (i < length (c))
+          clev = c(1,i);
+          clen = c(2,i);
+          XX = [XX, {c(1, i+1:i+clen)}];
+          YY = [YY, {c(2, i+1:i+clen)}];
+          i += clen+1;
+        endwhile
+      else
+        if (ispolar)
+          Z = feval (fun, X);
+          ## FIXME: Why aren't singularities eliminated for polar plots?
+        elseif (isplot)
+          Z = feval (fun, X);
+          ## Eliminate the singularities
+          Z = __eliminate_sing__ (Z);
+          domain = find_valid_domain (X, [], Z);
+        elseif (iscontour)
+          Z = feval (fun, X, Y);
+          Z = __eliminate_sing__ (Z);
+        else  #  mesh, surf plots
+          Z = feval (fun, X, Y);
+          Z = __eliminate_sing__ (Z);
+          if (circ)
+            ## Use domain calculated at the start.
+            ## The X, Y grids are non-monotonic after conversion from polar
+            ## coordinates and find_valid_domain fails.
+
+          elseif (auto_domain && ! auto_domain_done)
+            valid_domain = find_valid_domain (X, Y, Z);
+            domain_ok = isequal (domain, valid_domain);
+            domain = valid_domain;
+            auto_domain_done = true;  # ensures only 1 round of do loop done
+          else
+            if (! auto_domain_done)
+              domain = find_valid_domain (X, Y, Z);
+            endif
+          endif
+        endif
       endif
     endif
-  endif
+  until (domain_ok)
 
-  oldax = gca ();
+  ## Now, actually call the correct plot function with valid data and domain.
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (ax);
+    hax = newplot (hax);
     if (iscontour)
-      [clev, h] = feval (pfunc, X, Y, Z);
+      [~, h] = feval (pltfunc, hax, X, Y, Z);
     elseif (isplot && nargs == 2)
-      h = [];
-      hold_state = get (ax, "nextplot");
+      h = zeros (length (XX), 1);
+      hold_state = get (hax, "nextplot");
       for i = 1 : length (XX)
-        h = [h; plot(XX{i}, YY{i})];
+        h(i) = plot(hax, XX{i}, YY{i});
         if (i == 1)
-          set (ax, "nextplot", "add");
+          set (hax, "nextplot", "add");
         endif
       endfor
-      set (ax, "nextplot", hold_state);
-    elseif (ispolar || isplot)
-      h = feval (pfunc, X, Z);
-      if (isplot && !parametric)
-        axis ([X(1), X(end), yrange]);
+      set (hax, "nextplot", hold_state);
+      axis (hax, domain);
+    elseif (isplot || ispolar)
+      h = feval (pltfunc, hax, X, Z);
+      if (isplot && ! parametric)
+        axis (hax, domain);
+      endif
+    elseif (isplot3)
+      if (animate)
+        ## draw animation, then replace with true plot3
+        comet3 (hax, X, Y, Z, .05);
       endif
-    else
-      h = feval (pfunc, X, Y, Z);
+      h = feval (pltfunc, hax, X, Y, Z);
+      set (hax, "box", "off");
+      grid (hax, "on");
+      zlabel (hax, "z");
+    else  # mesh and surf plots
+      h = feval (pltfunc, hax, X, Y, Z);
+      ## FIXME: surf, mesh should really do a better job of setting zlim
+      if (! parametric)
+        axis (hax, domain);
+      endif
     endif
-    xlabel (xarg);
-    ylabel (yarg);
-    title (fstr);
+    xlabel (hax, xarg);
+    ylabel (hax, yarg);
+    title (hax, fstr);
   unwind_protect_cleanup
-    axes (oldax);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
+## Eliminate bad data (complex values, infinities, singularities)
 function x = __eliminate_sing__ (x)
-  x (isinf (x)) = NaN;
-  x (abs (del2 (x)) > 0.2 * (max (x(:)) - min (x(:)))) = NaN;
+  if (iscomplex (x))
+    x(imag (x) != 0) = NaN;
+  endif
+  x(isinf (x)) = NaN;
+  ## High rates of curvature are treated as singularities
+  threshold = 0.2 * (max (x(:)) - min (x(:)));
+  x(abs (del2 (x)) > threshold) = NaN;
 endfunction
+
+## Find: 1) range of function where there are not NaN values,
+##       2) function is changing (not just flat surface)
+function domain = find_valid_domain (X, Y, Z);
+
+  if (isvector (Z))
+    ## 2-D data for isplot
+    domain = [X(1) X(end)];
+
+    ## Guess a range which includes the "mass" of the data by using a 
+    ## median-based approach.  The center 3/4 of the data is used to
+    ## determine the range of the data.
+    ## This seems to be vaguely what Matlab does, but can't be sure.
+    XX = sort (Z(isfinite (Z)));
+    if (length (X) > 4)
+      irlo = XX(fix (1/8 * length (XX)));
+      irhi = XX(fix (7/8 * length (XX)));
+      d = irhi - irlo;
+      domain(3) = max (XX(1) - d/8, irlo - d);
+      domain(4) = min (XX(end) + d/8, irhi + d);
+    else
+      domain(3:4) = [XX(1), XX(end)];
+    endif
+
+    #{
+    ## FIXME: Old algorithm for removing singularities
+    ## Deprecated in 3.8.  Can be removed if no problems appear in ezplot.
+    idx = 2 : length (Z);
+    idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
+                ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange(2) / 2)));
+    Z(idx) = NaN;
+    #}
+
+  else
+    ## 3-D data such as mesh, surf
+    Zfinite = ! isnan (Z); 
+    Zrows = any (Zfinite, 2); 
+    rmin = find (Zrows, 1, "first"); 
+    rmax = find (Zrows, 1, "last"); 
+    Zcols = any (Zfinite, 1); 
+    cmin = find (Zcols, 1, "first"); 
+    cmax = find (Zcols, 1, "last"); 
+
+    ## Handle nasty case of all NaNs 
+    if (isempty (rmin))
+      rmin = 1, rmax = rows (Z);
+    endif
+    if (isempty (cmin))
+      cmin = 1, cmax = columns (Z);
+    endif
+
+    if (   ! any (isnan (Z([rmin, rmax],:)(:)))
+        && ! any (isnan (Z(:, [cmin, cmax])(:))))
+      ## Exclude surfaces along borders which are flat (gradient =~ 0).
+      ## Technically, this calculation might be better done with actual
+      ## deltaX, deltaY values.  But, data is usually meshgridded
+      ## (constant spacing) so working with deltaROW#, deltaCOL# is fine.
+      [Zx, Zy] = gradient (Z(rmin:rmax, cmin:cmax));
+      Zgrad = sqrt (Zx.^2 + Zy.^2);
+      slope = ((max (Z(:)) - min (Z(:)))
+                / sqrt ((rmax - rmin)^2 + (cmax - cmin)^2));
+      slope /= 125;  # threshold for discarding points.
+      Zrows = any (Zgrad > slope, 2); 
+      rmin += find (Zrows, 1, "first") - 1; 
+      rmax += find (Zrows, 1, "last") - rows (Zrows); 
+      Zcols = any (Zgrad > slope, 1); 
+      cmin += find (Zcols, 1, "first") - 1; 
+      cmax += find (Zcols, 1, "last") - columns (Zcols); 
+    endif
+
+    domain = [X(1,cmin) X(1,cmax) Y(rmin,1) Y(rmax,1)];
+  endif
+  
+endfunction
+
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/draw/private/__interp_cube__.m
rename from scripts/plot/private/__interp_cube__.m
rename to scripts/plot/draw/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/draw/private/__interp_cube__.m
@@ -19,45 +19,43 @@
 ## Author: Martin Helm <martin@mhelm.de>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{vxyz}, @var{idx}, @var{frac}] =} __interp_cube__ (@var{x}, @var{y}, @var{z}, @var{val}, @var{v})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [Vxyz, idx, frac] = __interp_cube__ (x, y, z, val, v, req = "values" )
-  if (ismatrix (x) && ndims (x) == 3 && ismatrix (y) && ndims (y) == 3 ...
+  if (ismatrix (x) && ndims (x) == 3 && ismatrix (y) && ndims (y) == 3
        && ismatrix (z) && ndims (z) == 3 && size_equal (x, y, z, val))
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
-  elseif (isvector (x) && isvector (y) && isvector (z) )
+  elseif (isvector (x) && isvector (y) && isvector (z))
     x = x(:);
     y = y(:);
     z = z(:);
   else
     error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
   if (columns (v) != 3)
-    error ( "v has to be N*3 matrix");
+    error ( "V has to be Nx3 matrix");
   endif
-  if (!ischar (req))
-   error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
-  endif
+  ##if (!ischar (req))
+  ## error ('__interp_cube__: Invalid request parameter use "values", "normals" or "normals8"');
+  ##endif
   if (isempty (v))
     Vxyz = idx = frac = [];
-    return
+    return;
   endif
 
   switch (req)
-    case "values"
-      [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v);
     case "normals"
       [idx, frac] = cube_idx (x, y, z, v);
 
       dx = x(2:end) - x(1:end-1);
       dy = y(2:end) - y(1:end-1);
       dz = z(2:end) - z(1:end-1);
       dx = 0.5 .* [dx;dx(end)](idx(:,2));
       dy = 0.5 .* [dy;dy(end)](idx(:,1));
@@ -91,18 +89,20 @@ function [Vxyz, idx, frac] = __interp_cu
       dx = x(2:end) - x(1:end-1);
       dy = y(2:end) - y(1:end-1);
       dz = z(2:end) - z(1:end-1);
       dx = [dx;dx(end)](idx(:,2));
       dy = [dy;dy(end)](idx(:,1));
       dz = [dz;dz(end)](idx(:,3));
       [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v);
       Vxyz = [Dx./dx, Dy./dy, Dz./dz];
+    case "values"
+      [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v);
    otherwise
-     error ("__interp_cube__: Invalid request type '%s', use 'values', 'normals' or 'normals8'", req);
+     error ('__interp_cube__: Invalid request type "%s", use "values", "normals" or "normals8"', req);
   endswitch
 endfunction
 
 function [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v)
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
@@ -177,8 +177,9 @@ function [idx, frac] = cube_idx (x, y, z
       ./ (x(idx(:, 2)+1) - x(idx(:, 2)));
   idx(:, 1) = lookup (y(2:end-1), v(:, 2)) + 1;
   frac(:, 1) = (v(:, 2) - y(idx(:, 1))) ...
       ./ (y(idx(:, 1)+1) - y(idx(:, 1)));
   idx(:, 3) = lookup (z(2:end-1), v(:, 3)) + 1;
   frac(:, 3) = (v(:, 3) - z(idx(:, 3))) ...
       ./ (z(idx(:, 3)+1) - z(idx(:, 3)));
 endfunction
+
diff --git a/scripts/plot/private/__line__.m b/scripts/plot/draw/private/__line__.m
rename from scripts/plot/private/__line__.m
rename to scripts/plot/draw/private/__line__.m
--- a/scripts/plot/private/__line__.m
+++ b/scripts/plot/draw/private/__line__.m
@@ -24,20 +24,16 @@
 ## __line__ (p, x, y, z)
 ## Create line object from x, y, and z with parent p.
 ## Return handle to line object.
 
 ## Author: jwe
 
 function h = __line__ (p, varargin)
 
-  if (nargin < 1)
-    print_usage ();
-  endif
-
   nvargs = numel (varargin);
 
   if (nvargs > 1 && ! ischar (varargin{1}) && ! ischar (varargin{2}))
     if (nvargs > 2 && ! ischar (varargin{3}))
       num_data_args = 3;
     else
       num_data_args = 2;
     endif
@@ -112,21 +108,21 @@ function h = __line__ (p, varargin)
   mask = reshape ([false(1,3); ismat], [1, 6]);
 
   for i = 1:nlines
     tmp = data(ismat);
     if (! size_equal (tmp)
         || (nvecpts != 0 && any (nvecpts != cellfun ("size", tmp, 1))))
       error ("line: data size_mismatch");
     endif
-
     data_args(mask) = cellfun (@(x) x(:,i), data(ismat),
                                "uniformoutput", false);
 
     handles(i) = __go_line__ (p, data_args{:}, other_args{:});
 
   endfor
 
   if (nargout > 0)
     h = handles;
   endif
 
 endfunction
+
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/draw/private/__marching_cube__.m
rename from scripts/plot/private/__marching_cube__.m
rename to scripts/plot/draw/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/draw/private/__marching_cube__.m
@@ -61,17 +61,17 @@
 ## @end example
 ##
 ## Instead of the @command{trimesh} function the @command{patch}
 ## function can be used to visualize the geometry.  For example:
 ##
 ## @example
 ## @group
 ## figure (); view (-38, 20);
-## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, \
+## pa = patch ("Faces", t, "Vertices", p, "FaceVertexCData", p, ...
 ##             "FaceColor", "interp", "EdgeColor", "none");
 ##
 ## ## Revert normals
 ## set (pa, "VertexNormals", -get (pa, "VertexNormals"));
 ##
 ## ## Set lightning (available with the JHandles package)
 ## # set (pa, "FaceLighting", "gouraud");
 ## # light ( "Position", [1 1 5]);
@@ -144,17 +144,17 @@ function [T, p, col] = __marching_cube__
     idx = c(vertex_idx{ii, :}) > iso;
     cc(idx) = bitset (cc(idx), ii);
   endfor
 
   cedge = edge_table(cc+1); # assign the info about intersected edges
   id =  find (cedge); # select only voxels which are intersected
   if (isempty (id))
     T = p = col = [];
-    return
+    return;
   endif
 
   ## phase II: calculate the list of intersection points
   xyz_off = [1, 1, 1; 2, 1, 1; 2, 2, 1; 1, 2, 1; 1, 1, 2;  2, 1, 2; 2, 2, 2; 1, 2, 2];
   edges = [1 2; 2 3; 3 4; 4 1; 5 6; 6 7; 7 8; 8 5; 1 5; 2 6; 3 7; 4 8];
   offset = sub2ind (size (c), xyz_off(:, 1), xyz_off(:, 2), xyz_off(:, 3)) -1;
   pp = zeros (length (id), lindex, 12);
   ccedge = [vec(cedge(id)), id];
@@ -523,8 +523,9 @@ function [edge_table, tri_table] = init_
   9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1;
   1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ] + 1;
 endfunction
+
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/draw/private/__patch__.m
rename from scripts/plot/private/__patch__.m
rename to scripts/plot/draw/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/draw/private/__patch__.m
@@ -143,17 +143,17 @@ function [h, failed] = __patch__ (p, var
             args{8} = "flat";
             args{9} = "cdata";
             args{10} = c;
           elseif (rows (c) == rows (x) && columns (c) == columns (x))
             ## Per-vertex color
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
-            agrs{10} = c;
+            args{10} = c;
           else
             error ("patch: color value not valid");
           endif
         else
           ## Color Vectors
           if (isempty (c))
             args{7} = "facecolor";
             args{8} = "interp";
@@ -205,23 +205,24 @@ function [h, failed] = __patch__ (p, var
 
     addlistener (h, "faces", @update_fvc);
     addlistener (h, "vertices", @update_fvc);
     addlistener (h, "facevertexcdata", @update_fvc);
   endif
 endfunction
 
 function args = delfields (args, flds)
-  idx = cellfun (@(x) any (strcmpi (x, flds)), args);
+  idx = cellfun ("isclass", args, "char");
+  idx(idx) = ismember (args(idx), flds);
   if (rows (idx) == 1)
-    idx = idx | [false, idx(1:end-1)];
+    idx |= [false, idx(1:end-1)];
   else
-    idx = idx | [false; idx(1:end-1)];
+    idx |= [false; idx(1:end-1)];
   endif
-  args (idx) = [];
+  args(idx) = [];
 endfunction
 
 function args = setdata (args)
   args = delfields (args, {"xdata", "ydata", "zdata", "cdata"});
   ## Remove the readonly fields as well
   args = delfields (args, {"type", "uicontextmenu"});
   nargs = length (args);
   idx = find (strcmpi (args, "faces"), 1, "last") + 1;
@@ -361,8 +362,9 @@ function update_handle (h, isfv)
     if (isfv)
       set (h, setdata ([fieldnames(f), struct2cell(f)].'(:)){:});
     else
       set (h, setvertexdata ([fieldnames(f), struct2cell(f)].'(:)){:});
     endif
     recursive = false;
   endif
 endfunction
+
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/draw/private/__pie__.m
rename from scripts/plot/private/__pie__.m
rename to scripts/plot/draw/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/draw/private/__pie__.m
@@ -109,51 +109,51 @@ function hlist = __pie__ (caller, vararg
     yt = 1.2 * cosd (xn2);
 
     if (len == 1)
       set (h, "clim", [1, 2]);
     else
       set (h, "clim", [1, len]);
     endif
 
-    if (strncmp (caller, "pie3", 4))
+    if (strcmp (caller, "pie3"))
       ln = length (xn);
       zlvl = 0.35;
       sx = repmat (xoff + [0, -sind(xn), 0], [2, 1]);
       sy = repmat (yoff + [0, cosd(xn), 0], [2, 1]);
       sz = [zeros(1, ln + 2); zlvl * ones(1, ln + 2)];
       sc = i * ones (size (sz));
 
       hlist = [hlist;
         patch(xoff + [0, -sind(xn)], yoff + [0, cosd(xn)], zeros (1, ln + 1), i);
         surface(sx, sy, sz, sc);
         patch(xoff + [0, -sind(xn)], yoff + [0, cosd(xn)], zlvl * ones (1, ln + 1), i);
         text(xt, yt, zlvl, labels{i})];
 
-    elseif (strncmp (caller, "pie", 3))
+    elseif (strcmp (caller, "pie"))
       if (xt > 0)
         align = "left";
       else
         align = "right";
       endif
 
       hlist = [hlist; patch(xoff + [0, -sind(xn)], yoff + [0, cosd(xn)], i);
                text(xt, yt, labels{i}, "horizontalalignment", align)];
 
     else
       error ("__pie__: unknown caller '%s'", caller);
     endif
   endfor
 
   addlistener (gca, "view", {@update_text_pos, hlist});
 
-  if (strncmp (caller, "pie3", 4))
+  if (strcmp (caller, "pie3"))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
-  elseif (strncmp (caller, "pie", 3))
+  elseif (strcmp (caller, "pie"))
     axis ([-1.5, 1.5, -1.5, 1.5], "square", "off");
   endif
 endfunction
 
 function update_text_pos (all_handles)
   ## Text objects in the foreground should be at the base level.
   ## Text objects in the background should be at the top level.
   ## Text objects on the right side should be aligned to the right
@@ -193,8 +193,9 @@ function update_text_pos (all_handles)
       if (lr_mask(i))
         set (tobj(i), "horizontalalignment", "right");
       else
         set (tobj(i), "horizontalalignment", "left");
       endif
     endfor
   endif
 endfunction
+
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/draw/private/__plt__.m
rename from scripts/plot/private/__plt__.m
rename to scripts/plot/draw/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/draw/private/__plt__.m
@@ -20,35 +20,36 @@
 ## @deftypefn {Function File} {} __plt__ (@var{caller}, @var{h}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = __plt__ (caller, h, varargin)
 
+  persistent warned_callers = {};
   nargs = nargin - 2;
 
   if (nargs > 0)
 
     k = 1;
 
     x_set = false;
     y_set = false;
     property_set = false;
     properties = {};
 
     hlegend = [];
     fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
-      if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
-          && (strcmp (get (fkids (i), "tag"), "legend")))
-        udata = get (fkids (i), "userdata");
+      if (   strcmp (get (fkids(i), "type"), "axes")
+          && strcmp (get (fkids(i), "tag"), "legend"))
+        udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
-          hlegend = fkids (i);
+          hlegend = fkids(i);
           break;
         endif
       endif
     endfor
 
     setlgnd = false;
     if (isempty (hlegend))
       hlgnd = [];
@@ -67,16 +68,29 @@ function retval = __plt__ (caller, h, va
         ## Force the last plot when input variables run out.
         next_cell = {};
         next_arg = {""};
       else
         next_cell = varargin(k);
         next_arg = varargin{k++};
       endif
 
+      if (isnumeric (next_arg) && ndims (next_arg) > 2
+          && any (size (next_arg) == 1))
+        next_arg = squeeze (next_arg);
+        if (! any (strcmp (caller, warned_callers)) && ndims (next_arg) < 3)
+          warning (["%s: N-d inputs have been squeezed to less than " ...
+                    "three dimensions"], caller)
+          warned_callers(end+1) = caller;
+        endif
+      endif
+      if (isnumeric (next_arg) && ndims (next_arg) > 2)
+        error ("%s: plot arrays must have less than 2 dimensions", caller)
+      endif
+
       nargs--;
 
       if (ischar (next_arg) || iscellstr (next_arg))
         if (x_set)
           [options, valid] = __pltopt__ (caller, next_arg, false);
           if (! valid)
             if (nargs == 0)
               error ("%s: properties must appear followed by a value", caller);
@@ -142,31 +156,27 @@ endfunction
 
 function [hlgnd, tlgnd, setlgnd] = __plt_key__ (h, options, hlgnd, tlgnd, setlgnd)
   n = numel (h);
   if (numel (options) == 1)
     options = repmat (options(:), n, 1);
   endif
 
   for i = 1 : n
-    key = options.key;
+    key = options(i).key;
     if (! isempty (key))
       hlgnd = [hlgnd(:); h(i)];
       tlgnd = {tlgnd{:}, key};
       setlgnd = true;
     endif
   endfor
 endfunction
 
 function retval = __plt1__ (h, x1, options, properties = {})
 
-  if (nargin < 2 || nargin > 4)
-    print_usage ();
-  endif
-
   if (nargin < 3 || isempty (options))
     options = __default_plot_options__ ();
   endif
 
   if (! isstruct (options))
     error ("__plt1__: options must be a struct array");
   endif
 
@@ -190,20 +200,16 @@ function retval = __plt1__ (h, x1, optio
   endif
 
   retval = __plt2__ (h, x1, x2, options, properties);
 
 endfunction
 
 function retval = __plt2__ (h, x1, x2, options, properties = {})
 
-  if (nargin < 3 || nargin > 5)
-    print_usage ();
-  endif
-
   if (nargin < 4 || isempty (options))
     options = __default_plot_options__ ();
   endif
 
   if (! isstruct (options))
     error ("__plt2__: options must be a struct array");
   endif
 
@@ -484,13 +490,13 @@ function retval = __plt2vv__ (h, x, y, o
     [linestyle, marker] = __next_line_style__ ();
   endif
   color = options.color;
   if (isempty (color))
     color = __next_line_color__ ();
   endif
 
   retval = line (x, y, "color", color,
-            "linestyle", linestyle,
-            "marker", marker, properties{:});
+                 "linestyle", linestyle,
+                 "marker", marker, properties{:});
 
 endfunction
 
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/draw/private/__quiver__.m
rename from scripts/plot/private/__quiver__.m
rename to scripts/plot/draw/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/draw/private/__quiver__.m
@@ -76,24 +76,24 @@ function hg = __quiver__ (varargin)
     endif
   endif
 
   have_filled = false;
   have_line_spec = false;
   args = {};
   while (ioff <= nargin)
     arg = varargin{ioff++};
-    if (ischar (arg) && strncmpi (arg, "filled", 6))
+    if (ischar (arg) && strcmpi (arg, "filled"))
       have_filled = true;
-    elseif ((ischar (arg) || iscell (arg))
+    elseif ((ischar (arg) || iscellstr (arg))
             && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("quiver", arg, false);
       if (valid)
         have_line_spec = true;
-        if (strncmp (linespec.linestyle, "none", 4))
+        if (strcmp (linespec.linestyle, "none"))
           linespec.linestyle = "-";
         endif
       else
         args {end + 1} = arg;
         if (ioff <= nargin)
           args {end + 1} = varargin{ioff++};
         endif
       endif
@@ -223,17 +223,17 @@ function hg = __quiver__ (varargin)
       xarrw1 = xtmp + (y - yend) * arrowsize / 3;
       xarrw2 = xtmp - (y - yend) * arrowsize / 3;
       yarrw1 = ytmp - (x - xend) * arrowsize / 3;
       yarrw2 = ytmp + (x - xend) * arrowsize / 3;
     endif
 
     if (have_line_spec)
       if (isfield (linespec, "marker")
-          && ! strncmp (linespec.marker, "none", 4))
+          && ! strcmp (linespec.marker, "none"))
         if (is3d)
           h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                       [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
                       [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
                       "linestyle", "none", "parent", hg);
         else
           h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
@@ -261,17 +261,17 @@ function hg = __quiver__ (varargin)
     else
       h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                  [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
                  "parent", hg);
     endif
 
     if (! have_line_spec
         || (isfield (linespec, "marker")
-            && strncmp (linespec.marker, "none", 4)))
+            && strcmp (linespec.marker, "none")))
       if (is3d)
         h3 = plot3 (x, y, z, "linestyle", "none", "marker", "none",
                     "parent", hg);
       else
         h3 = plot (x, y, "linestyle", "none", "marker", "none", "parent", hg);
       endif
     else
       if (is3d)
@@ -279,17 +279,17 @@ function hg = __quiver__ (varargin)
                     "parent", hg);
       else
 
         h3 = plot (x, y, "linestyle", "none", "marker", linespec.marker,
                    "parent", hg);
       endif
     endif
     if (have_filled)
-      ## FIXME gnuplot doesn't respect the markerfacecolor field
+      ## FIXME: gnuplot doesn't respect the markerfacecolor field
       set (h3, "markerfacecolor", get (h1, "color"));
     endif
 
     ## Set up the hggroup properties and listeners
     if (autoscale)
       addproperty ("autoscale", hg, "radio", "{on}|off", "on");
       addproperty ("autoscalefactor", hg, "data", autoscale);
     else
@@ -315,16 +315,19 @@ function hg = __quiver__ (varargin)
 
     addlistener (hg, "color", @update_props);
     addlistener (hg, "linewidth", @update_props);
     addlistener (hg, "linestyle", @update_props);
     addlistener (hg, "marker", @update_props);
     addlistener (hg, "markerfacecolor", @update_props);
     addlistener (hg, "markersize", @update_props);
 
+    ## Matlab property, although Octave does not implement it.
+    addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
     if (! isempty (args))
       set (hg, args{:});
     endif
   unwind_protect_cleanup
     set (h, "nextplot", hstate);
   end_unwind_protect
 
 endfunction
@@ -437,8 +440,9 @@ function update_props (h, d)
   else
     set (kids (2), "visible", "off");
   endif
   set (kids(1), "color", get (h, "color"),
        "marker", get (h, "marker"),
        "markerfacecolor", get (h, "markerfacecolor"),
        "markersize", get (h, "markersize"));
 endfunction
+
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/draw/private/__scatter__.m
rename from scripts/plot/private/__scatter__.m
rename to scripts/plot/draw/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/draw/private/__scatter__.m
@@ -18,116 +18,123 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{hg} =} __scatter__ (@dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function hg = __scatter__ (varargin)
 
-  h = varargin{1};
-  nd = varargin{2};
+  hax = varargin{1};  # We don't do anything with this.  Could remove it.
+  nd  = varargin{2};
   fcn = varargin{3};
-  x = varargin{4}(:);
-  y = varargin{5}(:);
-  istart = 6;
+  x   = varargin{4}(:);
+  y   = varargin{5}(:);
 
-  if (nd == 3)
+  if (nd == 2)
+    istart = 6;
+  else
     z = varargin{6}(:);
-    idx = isnan (x) | isnan (y) | isnan (z);
-    x (idx) = [];
-    y (idx) = [];
-    z (idx) = [];
     istart = 7;
-  else
-    idx = isnan (x) | isnan (y);
-    x (idx) = [];
-    y (idx) = [];
-    z = zeros (length (x), 0);
   endif
 
-  firstnonnumeric = Inf;
-  for i = istart:nargin
-    if (! isnumeric (varargin{i}))
-      firstnonnumeric = i;
-      break;
-    endif
-  endfor
-
   if (istart <= nargin)
-    s = varargin{istart};
+    s = varargin{istart}(:);
     if (isempty (s) || ischar (s))
       s = 6;
     endif
     if (! ischar (varargin{istart}))
       istart++;
     endif
   else
     s = 6;
   endif
 
+  ## Remove NaNs
+  idx = isnan (x) | isnan (y) | isnan (s);
+  if (nd == 3)
+    idx |= isnan (z);
+    z(idx) = [];
+  endif
+  x(idx) = [];
+  y(idx) = [];
+  if (nd == 2)
+    z = zeros (length (x), 0);
+  endif
+  if (numel (s) > 1)
+    s(idx) = [];
+  endif
+
+  firstnonnumeric = find (! cellfun ("isnumeric", varargin(istart:nargin)), 1);
+  if (isempty (firstnonnumeric))
+    firstnonnumeric = Inf;
+  else
+    firstnonnumeric += istart - 1;
+  endif
+
   if (istart <= nargin && firstnonnumeric > istart)
     c = varargin{istart};
-    if (isvector (c))
-      if (columns (c) != 3)
-        c = c(:);
-      endif
+    if (isvector (c) && columns (c) != 3)
+      c = c(:);
     endif
   elseif (firstnonnumeric == istart && ischar (varargin{istart})
-          && ! strcmpi (varargin{istart}, "filled"))
+          && ! (   strcmpi (varargin{istart}, "filled")
+                || strcmpi (varargin{istart}, "fill")))
     c = varargin{istart};
     firstnonnumeric++;
   else
     c = [];
   endif
 
   newargs = {};
   filled = false;
   have_marker = false;
   marker = "o";
   iarg = firstnonnumeric;
   while (iarg <= nargin)
     arg = varargin{iarg++};
-    if (ischar (arg) && strncmpi (arg, "filled", 6))
+    if (ischar (arg) && (strcmpi (arg, "filled") || strcmpi (arg, "fill")))
       filled = true;
-    elseif ((ischar (arg) || iscell (arg)) && ! have_marker)
+    elseif ((ischar (arg) || iscellstr (arg)) && ! have_marker)
       [linespec, valid] = __pltopt__ (fcn, arg, false);
       if (valid)
         have_marker = true;
         marker = linespec.marker;
-        if (strncmp (marker, "none", 4))
+        if (strcmp (marker, "none"))
           marker = "o";
         elseif (isempty (marker))
           have_marker = false;
-          [dummy, marker] = __next_line_style__ ();
+          [~, marker] = __next_line_style__ ();
         endif
       else
         error ("%s: invalid linespec", fcn);
       endif
     else
       newargs{end+1} = arg;
       if (iarg <= nargin)
         newargs{end+1} = varargin{iarg++};
       endif
     endif
   endwhile
 
   if (isempty (c))
     c = __next_line_color__ ();
   endif
 
+  ## Must occur after __next_line_color__ in order to work correctly.
   hg = hggroup ();
   newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"},
-                             newargs{:});
+                                newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
   addproperty ("zdata", hg, "data", z);
   if (ischar (c))
-    addproperty ("cdata", hg, "data", __color_str_rgb__ (c));
+    ## For single explicit color, cdata is unused
+    addproperty ("cdata", hg, "data", []);
   else
     addproperty ("cdata", hg, "data", c);
   endif
   addproperty ("sizedata", hg, "data", s);
   addlistener (hg, "xdata", @update_data);
   addlistener (hg, "ydata", @update_data);
   addlistener (hg, "zdata", @update_data);
   addlistener (hg, "cdata", @update_data);
@@ -141,82 +148,81 @@ function hg = __scatter__ (varargin)
 
     if (numel (s) == 1)
       s = repmat (s, numel (x), 1);
     endif
 
     if (one_explicit_color)
       for i = 1 : numel (x)
         if (filled)
-          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
-                            "facecolor", "none", "edgecolor", "none",
-                            "marker", marker,  "markersize", s(i),
-                            "markeredgecolor", c, "markerfacecolor", c,
-                            "linestyle", "none");
+          __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                        "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                        "facecolor", "none", "edgecolor", "none",
+                        "marker", marker,  "markersize", s(i),
+                        "markeredgecolor", c, "markerfacecolor", c,
+                        "linestyle", "none");
         else
-          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
-                            "facecolor", "none", "edgecolor", "none",
-                            "marker", marker,  "markersize", s(i),
-                            "markeredgecolor", c, "markerfacecolor", "none",
-                            "linestyle", "none");
+          __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                        "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                        "facecolor", "none", "edgecolor", "none",
+                        "marker", marker,  "markersize", s(i),
+                        "markeredgecolor", c, "markerfacecolor", "none",
+                        "linestyle", "none");
         endif
       endfor
     else
       if (rows (c) == 1)
-        c = ones (rows (x), 1) * c;
+        c = repmat (c, rows (x), 1);
       endif
       for i = 1 : numel (x)
         if (filled)
-          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
-                            "facecolor", "none", "edgecolor", "none",
-                            "marker", marker, "markersize", s(i),
-                            "markeredgecolor", "none",
-                            "markerfacecolor", "flat",
-                            "cdata", c(i,:), "facevertexcdata", c(i,:),
-                            "linestyle", "none");
+          __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                        "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                        "facecolor", "none", "edgecolor", "none",
+                        "marker", marker, "markersize", s(i),
+                        "markeredgecolor", "none",
+                        "markerfacecolor", "flat",
+                        "cdata", c(i,:), "facevertexcdata", c(i,:),
+                        "linestyle", "none");
         else
-          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
-                            "facecolor", "none", "edgecolor", "none",
-                            "marker", marker, "markersize", s(i),
-                            "markeredgecolor", "flat",
-                            "markerfacecolor", "none",
-                            "cdata", c(i,:), "facevertexcdata", c(i,:),
-                            "linestyle", "none");
-
+          __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                        "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                        "facecolor", "none", "edgecolor", "none",
+                        "marker", marker, "markersize", s(i),
+                        "markeredgecolor", "flat",
+                        "markerfacecolor", "none",
+                        "cdata", c(i,:), "facevertexcdata", c(i,:),
+                        "linestyle", "none");
         endif
       endfor
     endif
 
   else
 
     ## For larger numbers of points, we split the points by common color.
 
     vert = [x, y, z];
     if (one_explicit_color)
-      h = render_size_color (hg, vert, s, c, marker, filled, true);
+      render_size_color (hg, vert, s, c, marker, filled, true);
     else
       if (rows (c) == 1)
-        c = ones (rows (x), 1) * c;
+        c = repmat (c, rows (x), 1);
       endif
-      ## We want to group points by colour. So first get all the unique colours
+      ## We want to group points by color.  So first get all the unique colors
       [cc, ~, c_to_cc] = unique (c, "rows");
 
-      for i = 1:rows (cc)
-        ## Now for each possible unique colour, get the logical index of
-        ## points that correspond to that colour
+      for i = 1 : rows (cc)
+        ## Now for each possible unique color, get the logical index of
+        ## points that correspond to that color
         idx = (i == c_to_cc);
         if (isscalar (s))
-          h = render_size_color (hg, vert(idx, :), s, c(idx,:),
+          render_size_color (hg, vert(idx, :), s, c(idx,:),
                                  marker, filled, true);
         else
-          h = render_size_color (hg, vert(idx, :), s(idx), c(idx,:),
+          render_size_color (hg, vert(idx, :), s(idx), c(idx,:),
                                  marker, filled, true);
         endif
       endfor
 
     endif
   endif
 
   if (! ischar (c) && rows (c) > 1)
@@ -248,131 +254,121 @@ function hg = __scatter__ (varargin)
       addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "flat");
     endif
   endif
   addlistener (hg, "linewidth", @update_props);
   addlistener (hg, "marker", @update_props);
   addlistener (hg, "markerfacecolor", @update_props);
   addlistener (hg, "markeredgecolor", @update_props);
 
+  ## Matlab property, although Octave does not implement it.
+  addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
   if (! isempty (newargs))
     set (hg, newargs{:});
   endif
 
 endfunction
 
-function h = render_size_color (hg, vert, s, c, marker, filled, isflat)
+function render_size_color (hg, vert, s, c, marker, filled, isflat)
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
     toolkit = get (ancestor (hg, "figure"), "__graphics_toolkit__");
     ## Does gnuplot only support triangles with different vertex colors ?
-    ## TODO - Verify gnuplot can only support one color. If RGB triplets
-    ##        can be assigned to each vertex, then fix __go_draw_axe__.m
+    ## TODO: Verify gnuplot can only support one color.  If RGB triplets
+    ##       can be assigned to each vertex, then fix __go_draw_axes__.m
     gnuplot_hack = (numel (x) > 1 && columns (c) == 3
                     && strcmp (toolkit, "gnuplot"));
     if (ischar (c) || ! isflat || gnuplot_hack)
       if (filled)
-        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+        __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", "none",
                           "markerfacecolor", c(1,:),
                           "markersize", s, "linestyle", "none");
       else
-        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+        __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", c(1,:),
                           "markerfacecolor", "none",
                           "markersize", s, "linestyle", "none");
       endif
     else
       if (filled)
-        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+        __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "none",
                           "markerfacecolor", "flat",
                           "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       else
-        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+        __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "flat",
                           "markerfacecolor", "none",
                           "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       endif
     endif
   else
-    ## FIXME: round the size to one decimal place. It's not quite right, though.
+    ## Round size to one decimal place.
     [ss, ~, s_to_ss] = unique (ceil (s*10) / 10);
     for i = 1:rows (ss)
       idx = (i == s_to_ss);
-      h = render_size_color (hg, vert(idx,:), ss(i), c,
+      render_size_color (hg, vert(idx,:), ss(i), c,
                              marker, filled, isflat);
     endfor
   endif
 endfunction
 
 function update_props (h, d)
   lw = get (h, "linewidth");
-  m = get (h, "marker");
+  m  = get (h, "marker");
   fc = get (h, "markerfacecolor");
   ec = get (h, "markeredgecolor");
   kids = get (h, "children");
 
-  for i = 1 : numel (kids)
-    set (kids (i), "linewidth", lw, "marker", m, "markerfacecolor", fc,
-         "edgecolor", ec);
-  endfor
+  set (kids, "linewidth", lw, "marker", m,
+             "markerfacecolor", fc, "markeredgecolor", ec);
 endfunction
 
 function update_data (h, d)
-  x1 = get (h, "xdata");
-  y1 = get (h, "ydata");
-  z1 = get (h, "zdata");
-  c1 = get (h, "cdata");
-  if (!ischar (c1) && rows (c1) == 1)
-    c1 = repmat (c1, numel (x1), 1);
+  x = get (h, "xdata");
+  y = get (h, "ydata");
+  z = get (h, "zdata");
+  c = get (h, "cdata");
+  if (rows (c) == 1)
+    c = repmat (c, numel (x), 1);
   endif
-  size1 = get (h, "sizedata");
-  if (numel (size1) == 1)
-    size1 = repmat (size1, numel (x1), 1);
+  s = get (h, "sizedata");
+  if (numel (s) == 1)
+    s = repmat (s, numel (x), 1);
   endif
   hlist = get (h, "children");
-  if (ischar (c1))
-    if (isempty (z1))
-      for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", c1,
-             "markersize", size1(i));
-      endfor
-    else
-      for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
-             "markersize", size1(i));
-      endfor
-    endif
+
+  if (isempty (z))
+    for i = 1 : length (hlist)
+      set (hlist(i), "vertices", [x(i), y(i)],
+                     "cdata", reshape (c(i,:),[1, size(c)(2:end)]),
+                     "facevertexcdata", c(i,:),
+                     "markersize", s(i));
+    endfor
   else
-    if (isempty (z1))
-      for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata",
-             reshape (c1(i,:),[1, size(c1)(2:end)]),
-             "facevertexcdata", c1(i,:),
-             "markersize", size1(i));
-      endfor
-    else
-      for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata",
-             reshape (c1(i,:),[1, size(c1)(2:end)]),
-             "facevertexcdata", c1(i,:),
-             "markersize", size1(i));
-      endfor
-    endif
+    for i = 1 : length (hlist)
+      set (hlist(i), "vertices", [x(i), y(i), z(i)],
+                     "cdata", reshape (cd(i,:),[1, size(cd)(2:end)]),
+                     "facevertexcdata", cd(i,:),
+                     "markersize", s(i));
+    endfor
   endif
+
 endfunction
+
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
rename from scripts/plot/private/__stem__.m
rename to scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -27,52 +27,47 @@
 function h = __stem__ (have_z, varargin)
 
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ (caller, varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ (caller, varargin{:});
 
   [x, y, z, dofill, llc, ls, mmc, ms, varargin] = ...
-      check_stem_arg (have_z, varargin{:});
+                                           check_stem_arg (have_z, varargin{:});
 
-  oldax = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (ax);
-    hold_state = get (ax, "nextplot");
-    newplot ();
+    hax = newplot (hax);
+    hold_state = get (hax, "nextplot");
+    set (hax, "nextplot", "add");
+
     h = [];
-
     nx = rows (x);
-    for i = 1: columns (x)
+    for i = 1 : columns (x)
       if (have_z)
         xt = x(:)';
         xt = [xt; xt; NaN(1, nx)](:);
         yt = y(:)';
         yt = [yt; yt; NaN(1, nx)](:);
         zt = z(:)';
         zt = [zeros(1, nx); zt; NaN(1, nx)](:);
       else
         xt = x(:, i)';
         xt = [xt; xt; NaN(1, nx)](:);
         yt = y(:, i)';
         yt = [zeros(1, nx); yt; NaN(1, nx)](:);
       endif
 
-      hg  = hggroup ();
-      h = [h; hg];
-      args = __add_datasource__ (caller, hg, {"x", "y", "z"}, varargin{:});
-
-      if (i == 1)
-        set (ax, "nextplot", "add");
-      endif
-
       if (isempty (llc))
         lc = __next_line_color__ ();
       else
         lc = llc;
       endif
 
       if (isempty (mmc))
         mc = lc;
@@ -81,456 +76,329 @@ function h = __stem__ (have_z, varargin)
       endif
 
       if (dofill)
         fc = mc;
       else
         fc = "none";
       endif
 
+      ## Must occur after __next_line_color__ in order to work correctly.
+      hg = hggroup ();
+      h = [h; hg];
+      args = __add_datasource__ (caller, hg, {"x", "y", "z"}, varargin{:});
+
       if (have_z)
-        h_stems = plot3 (xt, yt, zt, "color", lc, "linestyle", ls,
-                         "parent", hg, x, y, z, "color", mc,
-                         "marker",  ms, "linestyle", "none",
-                         "markerfacecolor", fc, "parent", hg);
-
+        __line__ (hax, xt, yt, zt, "color", lc, "linestyle", ls, "parent", hg);
+        __line__ (hax, x, y, z, "color", mc, "linestyle", "none",
+                       "marker", ms, "markerfacecolor", fc, "parent", hg);
         h_baseline = [];
       else
-        h_stems = plot (xt, yt, "color", lc, "linestyle", ls,
-                        "parent", hg, x(:,i), y(:, i), "color", mc, "marker",
-                        ms, "linestyle", "none", "markerfacecolor",
-                        fc, "parent", hg);
-
-        x_axis_range = get (ax, "xlim");
-        h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
-        set (h_baseline, "handlevisibility", "off");
-        set (h_baseline, "xliminclude", "off");
-        addlistener (ax, "xlim", @update_xlim);
-        addlistener (h_baseline, "ydata", @update_baseline);
-        addlistener (h_baseline, "visible", @update_baseline);
+        __line__ (hax, xt, yt, "color", lc, "linestyle", ls, "parent", hg);
+        __line__ (hax, x(:,i), y(:, i), "color", mc, "linestyle", "none",
+                       "marker", ms, "markerfacecolor", fc, "parent", hg);
+        x_axis_range = get (hax, "xlim");
+        h_baseline = line (hax, x_axis_range, [0, 0], "color", [0, 0, 0]);
+        set (h_baseline, "handlevisibility", "off", "xliminclude", "off");
+        addlistener (hax, "xlim", @update_xlim);
+        addproperty ("basevalue", h_baseline, "data", 0);
+        addlistener (h_baseline, "basevalue", {@update_baseline, 0});
+        addlistener (h_baseline, "ydata", {@update_baseline, 1});
+        addlistener (h_baseline, "visible", {@update_baseline, 2});
       endif
 
       ## Setup the hggroup and listeners.
       addproperty ("showbaseline", hg, "radio", "{on}|off");
+      addproperty ("baseline", hg, "data", h_baseline);
       addproperty ("basevalue", hg, "data", 0);
-      addproperty ("baseline", hg, "data", h_baseline);
 
-      if (!have_z)
+      if (! have_z)
         addlistener (hg, "showbaseline", @show_baseline);
         addlistener (hg, "basevalue", @move_baseline);
       endif
 
       addproperty ("color", hg, "linecolor", lc);
+      addproperty ("linestyle", hg, "linelinestyle", ls);
       addproperty ("linewidth", hg, "linelinewidth", 0.5);
-      addproperty ("linestyle", hg, "linelinestyle", ls);
       addproperty ("marker", hg, "linemarker", ms);
+      addproperty ("markeredgecolor", hg, "linemarkerfacecolor", mc);
       addproperty ("markerfacecolor", hg, "linemarkerfacecolor", fc);
       addproperty ("markersize", hg, "linemarkersize", 6);
 
       addlistener (hg, "color", @update_props);
+      addlistener (hg, "linestyle", @update_props);
       addlistener (hg, "linewidth", @update_props);
-      addlistener (hg, "linestyle", @update_props);
       addlistener (hg, "marker", @update_props);
+      addlistener (hg, "markeredgecolor", @update_props);
       addlistener (hg, "markerfacecolor", @update_props);
       addlistener (hg, "markersize", @update_props);
 
       addproperty ("xdata", hg, "data", x(:, i));
       addproperty ("ydata", hg, "data", y(:, i));
       if (have_z)
         addproperty ("zdata", hg, "data", z(:, i));
       else
         addproperty ("zdata", hg, "data", []);
       endif
 
       addlistener (hg, "xdata", @update_data);
       addlistener (hg, "ydata", @update_data);
       addlistener (hg, "zdata", @update_data);
 
+      ## Matlab property, although Octave does not implement it.
+      addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
       if (! isempty (args))
         set (hg, args{:});
       endif
       if (i == 1 && ! isempty (h_baseline))
         set (h_baseline, "parent", get (hg, "parent"));
       endif
     endfor
 
+    if (! strcmp (hold_state, "add") && have_z)
+      set (hax, "view", [-37.5 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    endif
+    set (hax, "nextplot", hold_state);
+
   unwind_protect_cleanup
-    set (ax, "nextplot", hold_state);
-    axes (oldax);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
+
 endfunction
 
-function [x, y, z, dofill, lc, ls, mc, ms, newargs] = check_stem_arg (have_z, varargin)
-
-  ## FIXME -- there seems to be a lot of duplicated code in this
-  ## function.  It seems like it should be possible to simplify things
-  ## by combining some of the nearly identical code sections into
-  ## additional subfunctions.
+function [x, y, z, dofill, lc, ls, mc, ms, args] = check_stem_arg (have_z, varargin)
 
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
+  nargin = nargin - 1;  # account for have_z argument 
 
-  ## Remove prop/val pairs from data to consider.
-  i = 2;
-  newargs = {};
-  while (i < length (varargin))
-    if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i})
-                                  || strcmpi ("filled", varargin{i})))
-      newargs{end + 1} = varargin{i};
-      newargs{end + 1} = varargin{i + 1};
-      nargin = nargin - 2;
-      varargin(i:i+1) = [];
-    else
-      i++;
-    endif
-  endwhile
+  num_numeric = find (cellfun ("isclass", varargin, "char"), 1) - 1;
+  if (isempty (num_numeric))
+    num_numeric = nargin;     
+  endif
 
-  ## set specifiers to default values.
-  [lc, ls, mc, ms] = set_default_values ();
-  dofill = 0;
-  fill_2 = 0;
-  linespec_2 = 0;
-  z = [];
+  if (num_numeric < 1 || num_numeric > 3)
+    print_usage (caller);
+  endif
 
-  ## Check input arguments.
-  if (nargin == 2)
+  x = y = z = [];
+  if (num_numeric == 1)
     if (have_z)
       z = varargin{1};
-      x = 1:rows (z);
-      y = 1:columns (z);
     else
       y = varargin{1};
+    endif
+  elseif (num_numeric == 2)
+    if (have_z)
+      error ("stem3: must define X, Y, and Z");
+    else
+      x = varargin{1};
+      y = varargin{2};
+    endif
+  else  # nun_numeric == 3
+    if (have_z)
+      x = varargin{1};
+      y = varargin{2};
+      z = varargin{3};
+    else
+      error ("stem: can not define Z for 2-D stem plot");
+    endif
+  endif
+
+  ## Validate numeric data
+  if (have_z)
+    if (isempty (x))
+      [nr, nc] = size (z);
+      if (nr >= nc)
+        x = repmat ([1:nc], nr, 1);
+        y = repmat ([1:nr]', 1, nc);
+      else
+        x = repmat ([1:nc], nr, 1);
+        y = repmat ([1:nr]', 1, nc);
+      endif
+    endif
+    if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
+      error ("stem3: X, Y, and Z must be numeric");
+    endif
+  else
+    if (isempty (x))
       if (isvector (y))
         x = 1:length (y);
       elseif (ismatrix (y))
         x = 1:rows (y);
-      else
-        error ("stem: Y must be a matrix");
-      endif # in each case, x & y will be defined
-    endif
-  elseif (nargin == 3)
-    ## Several possibilities
-    ##
-    ## 1. the real y data
-    ## 2. 'filled'
-    ## 3. line spec
-    if (ischar (varargin{2}))
-      ## Only 2. or 3. possible.
-      if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
-        dofill = 1;
-      else
-        ## Parse the linespec.
-        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
-      endif
-      if (have_z)
-        z = varargin{1};
-        x = 1:rows (z);
-        y = 1:columns (z);
-      else
-        y = varargin{1};
-        if (isvector (y))
-          x = 1:length (y);
-        elseif (ismatrix (y))
-          x = 1:rows (y);
-        else
-          error ("stem: Y must be a matrix");
-        endif # in each case, x & y will be defined
-      endif
-    else
-      if (have_z)
-        error ("stem3: must define X, Y and Z");
-      else
-        ## Must be the real y data.
-        x = varargin{1};
-        y = varargin{2};
-        if (! (ismatrix (x) && ismatrix (y)))
-          error ("stem: X and Y must be matrices");
-        endif
       endif
     endif
-  elseif (nargin == 4)
-    ## Again, several possibilities:
-    ##
-    ## arg2 1. real y
-    ## arg2 2. 'filled' or linespec
-    ## arg3 1. real z
-    ## arg3 2. 'filled' or linespec
-    if (ischar (varargin{2}))
-      ## Only arg2 2. / arg3 1. & arg3 3. are possible.
-      if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
-        dofill = 1;
-        fill_2 = 1; # Be sure, no second "fill" is in the arguments.
-      else
-        ## Must be a linespec.
-        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
-        linespec_2 = 1;
-      endif
-      if (have_z)
-        z = varargin{1};
-        x = 1:rows (z);
-        y = 1:columns (z);
-      else
-        y = varargin{1};
-        if (isvector (y))
-          x = 1:length (y);
-        elseif (ismatrix (y))
-          x = 1:rows (y);
-        else
-          error ("stem: Y must be a matrix");
-        endif # in each case, x & y will be defined
-      endif
-    else
-      if (have_z)
-        x = varargin{1};
-        y = varargin{2};
-        z = varargin{3};
-        if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
-          error ("stem3: X, Y and Z must be matrices");
-        endif
-      else
-        ## must be the real y data.
-        x = varargin{1};
-        y = varargin{2};
-        if (! (ismatrix (x) && ismatrix (y)))
-          error ("stem: X and Y must be matrices");
-        endif
-      endif
-    endif # if ischar (varargin{2})
-    if (! have_z)
-      ## varargin{3} must be char.
-      ## Check for "fill.
-      if ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-          && fill_2)
-        error ("stem: duplicate fill argument");
-      elseif (strcmpi ("fill", varargin{3}) && linespec_2)
-        ## Must be "fill".
-        dofill = 1;
-        fill_2 = 1;
-      elseif ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-          && !linespec_2)
-        ## Must be "fill".
-        dofill = 1;
-        fill_2 = 1;
-      elseif (! linespec_2)
-        ## Must be linespec.
-        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
-        linespec_2 = 1;
-      endif
+    if (! (ismatrix (x) && ismatrix (y)))
+      error ("stem: X and Y must be numeric");
     endif
-  elseif (nargin == 5)
-    if (have_z)
-      x = varargin{1};
-      y = varargin{2};
-      z = varargin{3};
-      if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
-        error ("stem3: X, Y and Z must be matrices");
-      endif
-    else
-      x = varargin{1};
-      y = varargin{2};
-      if (! (ismatrix (x) && ismatrix (y)))
-        error ("stem: X and Y must be matrices");
-      endif
-    endif
-
-    if (! have_z)
-      if (strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-        dofill = 1;
-        fill_2 = 1; # Be sure, no second "fill" is in the arguments.
-      else
-        ## Must be a linespec.
-        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
-        linespec_2 = 1;
-      endif
-    endif
-
-    ## Check for "fill".
-    if ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
-        && fill_2)
-      error ("%s: duplicate fill argument", caller);
-    elseif ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
-        && linespec_2)
-      ## Must be "fill".
-      dofill = 1;
-      fill_2 = 1;
-    elseif (!strcmpi (varargin{4}, "fill") && !strcmpi (varargin{4}, "filled")
-        && !linespec_2)
-      ## Must be linespec.
-      [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
-      linespec_2 = 1;
-    endif
-  elseif (nargin == 6 && have_z)
-    x = varargin{1};
-    y = varargin{2};
-    z = varargin{3};
-    if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
-      error ("stem3: X, Y and Z must be matrices");
-    endif
-
-    if (strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
-      dofill = 1;
-      fill_2 = 1; # be sure, no second "fill" is in the arguments
-    else
-      ## Must be a linespec.
-      [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
-      linespec_2 = 1;
-    endif
-
-    ## check for "fill" ..
-    if ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
-        && fill_2)
-      error ("stem3: duplicate fill argument");
-    elseif ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
-        && linespec_2)
-      ## Must be "fill".
-      dofill = 1;
-      fill_2 = 1;
-    elseif (!strcmpi (varargin{5}, "fill") && !strcmpi (varargin{5}, "filled")
-            && !linespec_2)
-      ## Must be linespec.
-      [lc, ls, mc, ms] = stem_line_spec (caller, varargin{5});
-      linespec_2 = 1;
-    endif
-  else
-    error ("%s: incorrect number of arguments", caller);
   endif
 
   ## Check sizes of x, y and z.
   if (have_z)
-    if (!size_equal (x, y, z))
-      error ("stem3: inconsistent size of x, y and z");
-    else
-      x = x(:);
-      y = y(:);
-      z = z(:);
+    if (! size_equal (x, y, z))
+      error ("stem3: inconsistent sizes for X, Y, and Z");
     endif
+    x = x(:);
+    y = y(:);
+    z = z(:);
   else
     if (isvector (x))
       x = x(:);
       if (isvector (y))
         if (length (x) != length (y))
-          error ("stem: inconsistent size of x and y");
-        else
-          y = y(:);
+          error ("stem: inconsistent sizes for X and Y");
         endif
+        y = y(:);
       else
         if (length (x) == rows (y))
           x = repmat (x(:), 1, columns (y));
         else
-          error ("stem: inconsistent size of x and y");
+          error ("stem: inconsistent sizes for X and Y");
         endif
       endif
-    elseif (!size_equal (x, y))
-      error ("stem: inconsistent size of x and y");
+    elseif (! size_equal (x, y))
+      error ("stem: inconsistent sizes for X and Y");
     endif
   endif
 
+  dofill = false;
+  have_line_spec = false;
+  ## set specifiers to default values.
+  [lc, ls, mc, ms] = set_default_values ();
+
+  args = {};
+  ioff = num_numeric + 1;
+  while (ioff <= nargin)
+    arg = varargin{ioff++};
+    if (ischar (arg) && any (strcmpi (arg, {"fill", "filled"})))
+      dofill = true;
+    elseif ((ischar (arg) || iscellstr (arg)) && ! have_line_spec)
+      [linespec, valid] = __pltopt__ (caller, arg, false);
+      if (valid)
+        have_line_spec = true;
+        [lc, ls, mc, ms] = stem_line_spec (linespec);
+      else
+        args{end+1} = arg;
+        if (ioff <= nargin)
+          args{end+1} = varargin{ioff++};
+        else
+          error ('%s: No value specified for property "%s"', caller, arg);
+        endif
+      endif
+    else
+      args{end+1} = arg;
+      if (ioff <= nargin)
+        args{end+1} = varargin{ioff++};
+      else
+        error ('%s: No value specified for property "%s"', caller, arg);
+      endif
+    endif
+  endwhile
+
+endfunction
+
+function [lc, ls, mc, ms] = stem_line_spec (lspec)
+
+  [lc, ls, mc, ms] = set_default_values ();
+
+  if (! isempty (lspec.color))
+    lc = mc = lspec.color;
+  endif
+
+  if (! isempty (lspec.linestyle) && ! strcmp (lspec.linestyle, "none"))
+    ls = lspec.linestyle;
+  endif
+
+  if (! isempty (lspec.marker) && ! strcmp (lspec.marker, "none"))
+    ms = lspec.marker;
+  endif
+
 endfunction
 
-function [lc, ls, mc, ms] = stem_line_spec (caller, str)
-  if (! ischar (str))
-    error ("%s: expecting argument to be \"fill\" or a string of specifiers",
-           caller);
-  endif
-  [lc, ls, mc, ms] = set_default_values ();
-  ## Parse the line specifier string.
-  cur_props = __pltopt__ ("stem", str, false);
-  for i = 1:length (cur_props)
-    if (isfield (cur_props(i), "color") && ! isempty (cur_props(i).color)); # means line color
-      mc = lc = cur_props(i).color;
-    elseif (isfield (cur_props(i), "linestyle"))
-      ls = cur_props(i).linestyle;
-      if (isempty (ls))
-        ls = __next_line_style__ ();
-      endif
-    elseif (isfield (cur_props(i), "marker") && ! strcmpi (cur_props(i).marker, "none"))
-      ms = cur_props(i).marker;
-      if (isempty (ms))
-        [dummy, ms] = __next_line_style__ ();
-      endif
-    endif
-  endfor
-endfunction
-
 function [lc, ls, mc, ms] = set_default_values ()
-  ## set default values
   mc = [];
   lc = [];
   ls = "-";
   ms = "o";
 endfunction
 
-function update_xlim (h, d)
+function update_xlim (h, ~)
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
-    obj = get (kids (i));
+    obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
         set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
 endfunction
 
-function update_baseline (h, d)
+function update_baseline (h, ~, src)
   visible = get (h, "visible");
-  ydata = get (h, "ydata")(1);
+  if (src == 0)
+    basevalue = get (h, "basevalue");
+  else
+    basevalue = get (h, "ydata")(1);
+  endif
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
-    obj = get (kids (i));
+    obj = get (kids(i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline")
         && obj.baseline == h)
-      ## Only alter if changed to avoid recursion of the listener functions
-      if (! strcmpi (get (kids(i), "showbaseline"), visible))
-        set (kids (i), "showbaseline", visible);
+      ## Avoid lots of unnecessary listener updates
+      if (! strcmp (get (kids(i), "showbaseline"), visible))
+        set (kids(i), "showbaseline", visible);
       endif
-      if (! strcmpi (get (kids(i), "basevalue"), visible))
-        set (kids (i), "basevalue", ydata);
+      if (get (kids(i), "basevalue") != basevalue)
+        set (kids(i), "basevalue", basevalue);
       endif
     endif
   endfor
 endfunction
 
-function show_baseline (h, d)
+function show_baseline (h, ~)
   set (get (h, "baseline"), "visible", get (h, "showbaseline"));
 endfunction
 
-function move_baseline (h, d)
+function move_baseline (h, ~)
   b0 = get (h, "basevalue");
   bl = get (h, "baseline");
 
-  if (get (bl, "ydata") != [b0, b0])
-    set (bl, "ydata", [b0, b0]);
-  endif
+  set (bl, "ydata", [b0, b0]);
 
   kids = get (h, "children");
   yt = get (h, "ydata")(:)';
   ny = length (yt);
   yt = [b0 * ones(1, ny); yt; NaN(1, ny)](:);
   set (kids(2), "ydata", yt);
 endfunction
 
-function update_props (h, d)
+function update_props (h, ~)
   kids = get (h, "children");
   set (kids(2), "color", get (h, "color"),
-       "linewidth", get (h, "linewidth"),
-       "linestyle", get (h, "linestyle"));
-  set (kids(1), "color", get (h, "color"),
-       "marker", get (h, "marker"),
-       "markerfacecolor", get (h, "markerfacecolor"),
-       "markersize", get (h, "markersize"));
+                "linestyle", get (h, "linestyle"),
+                "linewidth", get (h, "linewidth"));
+  set (kids(1), "color", get (h, "markeredgecolor"),
+                "marker", get (h, "marker"),
+                "markerfacecolor", get (h, "markerfacecolor"),
+                "markersize", get (h, "markersize"));
 endfunction
 
-function update_data (h, d)
+function update_data (h, ~)
   x = get (h, "xdata");
   y = get (h, "ydata");
   z = get (h, "zdata");
 
   if (!isempty (z) && size_equal (x, y, z))
     sz = min ([size(x); size(y); size(z)]);
     x = x(1:sz(1),1:sz(2));
     y = y(1:sz(1),1:sz(2));
@@ -554,8 +422,9 @@ function update_data (h, d)
     yt = [bl * ones(1, nx); y; NaN(1, nx)](:);
     zt = [];
   endif
 
   kids = get (h, "children");
   set (kids(2), "xdata", xt, "ydata", yt, "zdata", zt);
   set (kids(1), "xdata", x, "ydata", y, "zdata", z);
 endfunction
+
diff --git a/scripts/plot/quiver.m b/scripts/plot/draw/quiver.m
rename from scripts/plot/quiver.m
rename to scripts/plot/draw/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/draw/quiver.m
@@ -17,71 +17,78 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@var{x}, @var{y}, @var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} quiver (@dots{}, "filled")
-## @deftypefnx {Function File} {} quiver (@var{h}, @dots{})
+## @deftypefnx {Function File} {} quiver (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver (@dots{})
 ##
-## Plot the @code{(@var{u}, @var{v})} components of a vector field in
-## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
+## Plot the (@var{u}, @var{v}) components of a vector field in
+## an (@var{x}, @var{y}) meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
-## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] =
-## size (@var{u})}.
+## @code{(1:@var{m}, 1:@var{n})} where
+## @code{[@var{m}, @var{n}] = size (@var{u})}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
+## of the same format as the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument "filled" is given then the
-## markers are drawn filled.
+## drawn rather than arrows.  If the argument @qcode{"filled"} is given then the
+## markers are filled.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y] = meshgrid (1:2:20);
 ## h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
 ## set (h, "maxheadsize", 0.33);
 ## @end group
 ## @end example
 ##
-## @seealso{quiver3, feather, plot}
+## @seealso{quiver3, compass, feather, plot}
 ## @end deftypefn
 
 function retval = quiver (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("quiver", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("quiver", varargin{:});
 
   if (nargin < 2)
     print_usage ();
   else
-    oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
     unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __quiver__ (h, 0, varargin{:});
+      hax = newplot (hax);
+      htmp = __quiver__ (hax, false, varargin{:});
     unwind_protect_cleanup
-      axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
     end_unwind_protect
   endif
 
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! [x,y] = meshgrid (1:2:20);
diff --git a/scripts/plot/quiver3.m b/scripts/plot/draw/quiver3.m
rename from scripts/plot/quiver3.m
rename to scripts/plot/draw/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/draw/quiver3.m
@@ -17,88 +17,99 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver3 (@var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@var{x}, @var{y}, @var{z}, @var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, "filled")
-## @deftypefnx {Function File} {} quiver3 (@var{h}, @dots{})
+## @deftypefnx {Function File} {} quiver3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
-## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in
-## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you
-## can specify @var{x}, @var{y} @var{z} as vectors.
+## Plot the (@var{u}, @var{v}, @var{w}) components of a vector field in
+## an (@var{x}, @var{y}, @var{z}) meshgrid.  If the grid is uniform, you
+## can specify @var{x}, @var{y}, and @var{z} as vectors.
 ##
-## If @var{x}, @var{y} and @var{z} are undefined they are assumed to be
+## If @var{x}, @var{y}, and @var{z} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n}, 1:@var{p})} where @code{[@var{m}, @var{n}] =
 ## size (@var{u})} and @code{@var{p} = max (size (@var{w}))}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
-##  the arrows of the field relative to the mesh spacing.  A value of 0
+## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
-## in a similar manner to the line styles used with the @code{plot} command.
+## of the same format as the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument "filled" is given then the
-## markers as filled.
+## drawn rather than arrows.  If the argument @qcode{"filled"} is given then the
+## markers are filled.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (25);
 ## surf (x, y, z);
 ## hold on;
 ## [u, v, w] = surfnorm (x, y, z / 10);
 ## h = quiver3 (x, y, z, u, v, w);
 ## set (h, "maxheadsize", 0.33);
 ## @end group
 ## @end example
 ##
-## @seealso{quiver, plot}
+## @seealso{quiver, compass, feather, plot}
 ## @end deftypefn
 
 function retval = quiver3 (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("quiver3", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("quiver3", varargin{:});
 
   if (nargin < 2)
     print_usage ();
   else
-    oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
     unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __quiver__ (h, 1, varargin{:});
+      hax = newplot (hax);
+      htmp = __quiver__ (hax, true, varargin{:});
+
+      if (! ishold (hax))
+        set (hax, "view", [-37.5, 30]);  # 3D view
+      endif
     unwind_protect_cleanup
-      axes (oldh);
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
     end_unwind_protect
   endif
 
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x,y] = meshgrid (-1:0.1:1);
 %! z = sin (2*pi * sqrt (x.^2 + y.^2));
 %! theta = 2*pi * sqrt (x.^2 + y.^2) + pi/2;
-%! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
+%! mesh (x, y, z);
 %! hold on;
-%! mesh (x, y, z);
+%! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold off;
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
diff --git a/scripts/plot/rectangle.m b/scripts/plot/draw/rectangle.m
rename from scripts/plot/rectangle.m
rename to scripts/plot/draw/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -17,53 +17,70 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rectangle ()
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Position", @var{pos})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "Curvature", @var{curv})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "EdgeColor", @var{ec})
 ## @deftypefnx {Function File} {} rectangle (@dots{}, "FaceColor", @var{fc})
+## @deftypefnx {Function File} {} rectangle (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} rectangle (@dots{})
 ##
-## Draw rectangular patch defined by @var{pos} and @var{curv}.  The variable
-## @code{@var{pos}(1:2)} defines the lower left-hand corner of the patch
-## and @code{@var{pos}(3:4)} defines its width and height.  By default, the
-## value of @var{pos} is @code{[0, 0, 1, 1]}.
+## Draw a rectangular patch defined by @var{pos} and @var{curv}.
+## 
+## The variable @code{@var{pos}(1:2)} defines the lower left-hand corner of
+## the patch and @code{@var{pos}(3:4)} defines its width and height.  By
+## default, the value of @var{pos} is @code{[0, 0, 1, 1]}.
 ##
 ## The variable @var{curv} defines the curvature of the sides of the rectangle
 ## and may be a scalar or two-element vector with values between 0 and 1.
 ## A value of 0 represents no curvature of the side, whereas a value of 1
 ## means that the side is entirely curved into the arc of a circle.
 ## If @var{curv} is a two-element vector, then the first element is the
 ## curvature along the x-axis of the patch and the second along y-axis.
 ##
 ## If @var{curv} is a scalar, it represents the curvature of the shorter of the
 ## two sides of the rectangle and the curvature of the other side is defined
 ## by
 ##
 ## @example
 ## min (pos (1:2)) / max (pos (1:2)) * curv
 ## @end example
 ##
-## Other properties are passed to the underlying patch command. 
+## Additional property/value pairs are passed to the underlying patch command. 
 ## 
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created
 ## rectangle object.
 ## @end deftypefn
-## @seealso{patch}
+## @seealso{patch, line, cylinder, ellipsoid, sphere}
 
 function h = rectangle (varargin)
 
   [hax, varargin] = __plt_get_axis_arg__ ("rectangle", varargin{:});
 
-  tmp =  __rectangle__ (hax, varargin{:});
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+
+    htmp = __rectangle__ (hax, varargin{:});
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 endfunction
 
 function hg = __rectangle__ (hax, varargin)
 
   iarg = 1;
   pos = [0, 0, 1, 1];
   curv2 = [0, 0];
@@ -193,30 +210,33 @@ function update_data (h, d)
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
   set (kids, "edgecolor", get (h, "edgecolor"),
-       "linewidth", get (h, "linewidth"),
-       "linestyle", get (h, "linestyle"),
-       "facecolor", get (h, "facecolor"));
+             "linewidth", get (h, "linewidth"),
+             "linestyle", get (h, "linestyle"),
+             "facecolor", get (h, "facecolor"));
 endfunction
 
 
 %!demo
 %! clf;
 %! axis equal;
 %! rectangle ('Position', [0.05, 0.05, 0.9, 0.9], 'Curvature', [0.5, 0.5]);
+%! title ('rectangle() with corners curved');
 
 %!demo
 %! clf;
 %! axis equal;
 %! rectangle ('Position', [0.05, 0.05, 0.9, 0.4], 'Curvature', 1.0);
+%! title ('rectangle() with sides as complete arcs');
 
 %!demo
 %! clf;
 %! axis equal;
 %! h = rectangle ('Position', [0.05, 0.05, 0.9, 0.4], 'Curvature', 1.0);
 %! set (h, 'FaceColor', [0, 1, 0]);
+%! title ('rectangle() with FaceColor = green');
 
diff --git a/scripts/plot/ribbon.m b/scripts/plot/draw/ribbon.m
rename from scripts/plot/ribbon.m
rename to scripts/plot/draw/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/draw/ribbon.m
@@ -12,85 +12,113 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} ribbon (@var{x}, @var{y}, @var{width})
-## @deftypefnx {Function File} {} ribbon (@var{y})
+## @deftypefn  {Function File} {} ribbon (@var{y})
+## @deftypefnx {Function File} {} ribbon (@var{x}, @var{y})
+## @deftypefnx {Function File} {} ribbon (@var{x}, @var{y}, @var{width})
+## @deftypefnx {Function File} {} ribbon (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ribbon (@dots{})
-## Plot a ribbon plot for the columns of @var{y} vs. @var{x}.  The
-## optional parameter @var{width} specifies the width of a single ribbon
+## Plot a ribbon plot for the columns of @var{y} vs. @var{x}.
+##
+## The optional parameter @var{width} specifies the width of a single ribbon
 ## (default is 0.75).  If @var{x} is omitted, a vector containing the
-## row numbers is assumed (1:rows (Y)).
+## row numbers is assumed (@code{1:rows (Y)}).
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to
 ## the surface objects representing each ribbon.
+## @seealso{surface, waterfall}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
-function h = ribbon (x, y, width = 0.75)
+function h = ribbon (varargin)
+
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("ribbon", varargin{:});
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 1)
-    y = x;
+    y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
     [nr, nc] = size (y);
     x = repmat ((1:nr)', 1, nc);
+    width = 0.75;
+  elseif (nargin == 2)
+    x = varargin{1};
+    y = varargin{2};
+    width = 0.75;
+  else
+    x = varargin{1};
+    y = varargin{2};
+    width = varargin{3};
   endif
 
   if (isvector (x) && isvector (y))
     if (length (x) != length (y))
       error ("ribbon: vectors X and Y must have the same length");
     else
       [x, y] = meshgrid (x, y);
     endif
   else
     if (! size_equal (x, y))
       error ("ribbon: matrices X and Y must have the same size");
     endif
   endif
 
-  newplot ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
 
-  [nr, nc] = size (y);
-  htmp = zeros (nc, 1);
+    [nr, nc] = size (y);
+    htmp = zeros (nc, 1);
 
-  for c = nc:-1:1
-    zz = [y(:,c), y(:,c)];
-    yy = x(:,c);
-    xx = [c - width / 2, c + width / 2];
-    [xx, yy] = meshgrid (xx, yy);
-    cc = repmat (c, size (zz));
-    htmp(c) = surface (xx, yy, zz, cc);
-  endfor
+    for c = nc:-1:1
+      zz = [y(:,c), y(:,c)];
+      yy = x(:,c);
+      xx = [c - width / 2, c + width / 2];
+      [xx, yy] = meshgrid (xx, yy);
+      cc = repmat (c, size (zz));
+      htmp(c) = surface (xx, yy, zz, cc);
+    endfor
 
-  if (! ishold ())
-    ax = get (htmp(1), "parent");
-    set (ax, "view", [-37.5, 30], "box", "off", 
-             "xgrid", "on", "ygrid", "on", "zgrid", "on");
-  endif
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30], "box", "off", 
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    endif
+
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = sombrero ();
-%! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
+%! title ('ribbon() plot of sombrero()');
 
 %!FIXME: Could have some input validation tests here
 
diff --git a/scripts/plot/rose.m b/scripts/plot/draw/rose.m
rename from scripts/plot/rose.m
rename to scripts/plot/draw/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/draw/rose.m
@@ -13,99 +13,109 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rose (@var{th})
-## @deftypefnx {Function File} {} rose (@var{th}, @var{r})
-## @deftypefnx {Function File} {} rose (@var{h}, @dots{})
+## @deftypefnx {Function File} {} rose (@var{th}, @var{nbins})
+## @deftypefnx {Function File} {} rose (@var{th}, @var{bins})
+## @deftypefnx {Function File} {} rose (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} rose (@dots{})
-## @deftypefnx {Function File} {[@var{r}, @var{th}] =} rose (@dots{})
+## @deftypefnx {Function File} {[@var{thout} @var{rout}] =} rose (@dots{})
+## Plot an angular histogram.
 ##
-## Plot an angular histogram.  With one vector argument, @var{th}, plot the
-## histogram with 20 angular bins.  If @var{th} is a matrix then each column
-## of @var{th} produces a separate histogram.
+## With one vector argument, @var{th}, plot the histogram with 20 angular bins.
+## If @var{th} is a matrix then each column of @var{th} produces a separate
+## histogram.
 ##
-## If @var{r} is given and is a scalar, then the histogram is produced with
-## @var{r} bins.  If @var{r} is a vector, then the center of each bin are
-## defined by the values of @var{r}.
+## If @var{nbins} is given and is a scalar, then the histogram is produced with
+## @var{nbin} bins.  If @var{bins} is a vector, then the center of each bin is
+## defined by the values of @var{bins} and the number of bins is
+## given by the number of elements in @var{bins}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a vector of graphics handles to the
 ## line objects representing each histogram.
 ##
 ## If two output arguments are requested then no plot is made and 
 ## the polar vectors necessary to plot the histogram are returned instead.
 ##
 ## @example
 ## @group
-## [r, th] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
-## polar (r, th);
+## [th, r] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
+## polar (th, r);
 ## @end group
 ## @end example
 ##
-## @seealso{polar, compass, hist}
+## @seealso{hist, polar}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose",
-                                                varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("rose", varargin{:});
 
   if (nargin < 1)
     print_usage ();
   endif
 
   ## Force theta to [0,2*pi] range
-  th = varargin {1};
-  th = atan2  (sin (th), cos (th)) + pi;
+  th = varargin{1};
+  th = atan2 (sin (th), cos (th)) + pi;
 
   if (nargin > 1)
-    x = varargin {2};
+    x = varargin{2};
     if (isscalar (x))
-      x = [0.5/x : 1/x : 1] * 2 * pi;
+      x = [0.5/x : 1/x : 1] * 2*pi;
     else
       ## Force theta to [0,2*pi] range
-      x = atan2  (sin (x), cos (x)) + pi;
+      x = atan2 (sin (x), cos (x)) + pi;
     endif
   else
-    x = [1/40 : 1/20 : 1] * 2 * pi;
+    x = [1/40 : 1/20 : 1] * 2*pi;
   endif
 
   [nn, xx] = hist (th, x);
   xx = xx(:).';
   if (isvector (nn))
-    nn = nn (:);
+    nn = nn(:);
   endif
   x1 = xx(1:end-1) + diff (xx, 1) / 2;
   x1 = [x1 ; x1; x1; x1](:);
   th = [0; 0; x1; 2*pi ; 2*pi];
   r = zeros (4 * rows (nn), columns (nn));
   r(2:4:end, :) = nn;
   r(3:4:end, :) = nn;
 
   if (nargout < 2)
-    oldh = gca ();
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
     unwind_protect
-      axes (h);
-      newplot ();
-      hlist = polar (h, th, r);
+      hax = newplot (hax);
+      htmp = polar (th, r);
     unwind_protect_cleanup
-      axes (oldh);
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
     end_unwind_protect
 
     if (nargout > 0)
-      thout = hlist;
+      thout = htmp;
     endif
   else
     thout = th;
     rout = r;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! rose ([2*randn(1e5, 1), pi + 2*randn(1e5, 1)]);
+%! title ('rose() angular histogram plot');
 
diff --git a/scripts/plot/scatter.m b/scripts/plot/draw/scatter.m
rename from scripts/plot/scatter.m
rename to scripts/plot/draw/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/draw/scatter.m
@@ -15,132 +15,151 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} scatter (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c})
-## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{style})
-## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{prop}, @var{val})
+## @deftypefnx {Function File} {} scatter (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} scatter (@dots{}, "filled")
-## @deftypefnx {Function File} {} scatter (@var{h}, @dots{})
+## @deftypefnx {Function File} {} scatter (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} scatter (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter (@dots{})
+## Draw a 2-D scatter plot.
 ##
-## Draw a scatter plot of the data.  A marker is plotted at each point
-## defined by the points in the vectors @var{x} and @var{y}.  The size of
-## the markers used is determined by the @var{s}, which can be a scalar or
-## a vector of the same length as @var{x} and @var{y}.  If @var{s} is not
-## given or is an empty matrix, then the default value of 8 points is used.
+## A marker is plotted at each point defined by the coordinates in the vectors
+## @var{x} and @var{y}.
+##
+## The size of the markers is determined by @var{s}, which can be a scalar
+## or a vector of the same length as @var{x} and @var{y}.  If @var{s}
+## is not given, or is an empty matrix, then a default value of 8 points is
+## used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
-## defining a fixed color; a 3-element vector giving the red, green,and blue
+## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
-## a scaled index into the current colormap; or an @var{n}-by-3 matrix defining
-## the colors of each of the markers individually.
+## a scaled index into the current colormap; or an @nospell{Nx3} matrix defining
+## the RGB color of each marker individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
-## If the argument @code{"filled"} is given then the markers as filled.  All
-## additional arguments are passed to the underlying patch command.
+## If no marker is specified it defaults to @qcode{"o"} or circles.
+## If the argument @qcode{"filled"} is given then the markers are filled.
+##
+## Additional property/value pairs are passed directly to the underlying
+## patch object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created patch
 ## object.
 ## 
 ## Example:
 ##
 ## @example
 ## @group
 ## x = randn (100, 1);
 ## y = randn (100, 1);
 ## scatter (x, y, [], sqrt (x.^2 + y.^2));
 ## @end group
 ## @end example
 ##
-## @seealso{plot, patch, scatter3}
+## @seealso{scatter3, patch, plot}
 ## @end deftypefn
 
 function retval = scatter (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("scatter", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("scatter", varargin{:});
 
   if (nargin < 2)
     print_usage ();
-  else
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __scatter__ (h, 2, "scatter", varargin{:});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
   endif
 
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+    
+    htmp = __scatter__ (hax, 2, "scatter", varargin{:});
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
+
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! scatter (x, y, 'r');
-%! title ('Scatter plot with red bubbles');
+%! title ('scatter() plot with red bubbles');
 
 %!demo
 %! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! c = x .* y;
 %! scatter (x, y, 20, c, 'filled');
-%! title ('Scatter with colors');
+%! title ('scatter() with colored filled bubbles');
 
 %!demo
 %! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! scatter (x, y, [], sqrt (x.^2 + y.^2));
-%! title ('Scatter plot with bubble color determined by distance from origin');
+%! title ({'scatter() plot'; ...
+%!         'bubble color determined by distance from origin'});
+
+%!demo
+%! clf;
+%! rand_10x1_data5 = [0.777753, 0.093848, 0.183162, 0.399499, 0.337997, 0.686724, 0.073906, 0.651808, 0.869273, 0.137949];
+%! rand_10x1_data6 = [0.37460, 0.25027, 0.19510, 0.51182, 0.54704, 0.56087, 0.24853, 0.75443, 0.42712, 0.44273];
+%! x = rand_10x1_data5;
+%! y = rand_10x1_data6;
+%! s = 10 - 10*log (x.^2 + y.^2);
+%! h = scatter (x, y, [], 'r', 's');
+%! title ({'scatter() plot'; ...
+%!         'marker is square, color is red'});
+
+%!demo
+%! clf;
+%! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726];
+%! rand_10x1_data4 = [0.020207, 0.527193, 0.443472, 0.061683, 0.370277, 0.947349, 0.249591, 0.666304, 0.134247, 0.920356];
+%! x = rand_10x1_data3;
+%! y = rand_10x1_data4;
+%! s = 10 - 10*log (x.^2 + y.^2);
+%! h = scatter (x, y, [], 'r', 's', 'filled');
+%! title ({'scatter() plot'; ...
+%!         'marker is square, marker is filled, color is red'});
 
 %!demo
 %! clf;
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
 %! y = rand_10x1_data2;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, s, s, 's', 'filled');
-%! title ({'Scatter plot with filled square markers', ...
+%! title ({'scatter() plot with filled square markers', ...
 %!         'size and color of markers determined by algorithm'});
 
 %!demo
 %! clf;
-%! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726];
-%! rand_10x1_data4 = [0.020207, 0.527193, 0.443472, 0.061683, 0.370277, 0.947349, 0.249591, 0.666304, 0.134247, 0.920356];
-%! x = rand_10x1_data3;
-%! y = rand_10x1_data4;
-%! s = 10 - 10*log (x.^2 + y.^2);
-%! h = scatter (x, y, [], 'r', 's', 'filled');
-
-%!demo
-%! clf;
-%! rand_10x1_data5 = [0.777753, 0.093848, 0.183162, 0.399499, 0.337997, 0.686724, 0.073906, 0.651808, 0.869273, 0.137949];
-%! rand_10x1_data6 = [0.37460, 0.25027, 0.19510, 0.51182, 0.54704, 0.56087, 0.24853, 0.75443, 0.42712, 0.44273];
-%! x = rand_10x1_data5;
-%! y = rand_10x1_data6;
-%! s = 10 - 10*log (x.^2 + y.^2);
-%! h = scatter (x, y, [], 'r', 's');
-
-%!demo
-%! clf;
 %! k = 1;
 %! for m = [1, 3]
 %!   for n = [101, 50, 1]
 %!     x = rand (n, 1);
 %!     y = rand (n, 1);
 %!     if (m > 1)
 %!       str = 'Three Colors';
 %!       idx = ceil (rand (n, 1) * 3);
diff --git a/scripts/plot/scatter3.m b/scripts/plot/draw/scatter3.m
rename from scripts/plot/scatter3.m
rename to scripts/plot/draw/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/draw/scatter3.m
@@ -12,99 +12,118 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s}, @var{c})
-## @deftypefnx {Function File} {} scatter3 (@dots{}, "filled")
+## @deftypefn  {Function File} {} scatter3 (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s})
+## @deftypefnx {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s}, @var{c})
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{style})
+## @deftypefnx {Function File} {} scatter3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} scatter3 (@var{h}, @dots{})
+## @deftypefnx {Function File} {} scatter3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter3 (@dots{})
+## Draw a 3-D scatter plot.
 ##
-## Plot a scatter plot of the data in 3D@.  A marker is plotted at each point
-## defined by the points in the vectors @var{x}, @var{y} and @var{z}.  The size
-## of the markers used is determined by @var{s}, which can be a scalar or
-## a vector of the same length of @var{x}, @var{y} and @var{z}.  If @var{s} is
-## not given or is an empty matrix, then the default value of 8 points is used.
+## A marker is plotted at each point defined by the coordinates in the vectors
+## @var{x}, @var{y}, and @var{z}.
+##
+## The size of the markers is determined by @var{s}, which can be a scalar
+## or a vector of the same length as @var{x}, @var{y}, and @var{z}.  If @var{s}
+## is not given, or is an empty matrix, then a default value of 8 points is
+## used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
 ## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
-## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
-## the colors of each of the markers individually.
+## a scaled index into the current colormap; or an @nospell{Nx3} matrix defining
+## the RGB color of each marker individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
-## If the argument "filled" is given then the markers as filled.  All
-## additional arguments are passed to the underlying patch command.
+## If no marker is specified it defaults to @qcode{"o"} or circles.
+## If the argument @qcode{"filled"} is given then the markers are filled.
+##
+## Additional property/value pairs are passed directly to the underlying
+## patch object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
 ## object representing the points.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
 ## scatter3 (x(:), y(:), z(:), [], z(:));
 ## @end group
 ## @end example
 ##
-## @seealso{plot, patch, scatter}
+## @seealso{scatter, patch, plot}
 ## @end deftypefn
 
 function retval = scatter3 (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("scatter3", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("scatter3", varargin{:});
 
   if (nargin < 2)
     print_usage ();
-  else
-    oldh = gca ();
-    unwind_protect
-      axes (h);
-      newplot ();
-      tmp = __scatter__ (h, 3, "scatter3", varargin{:});
-    unwind_protect_cleanup
-      axes (oldh);
-    end_unwind_protect
   endif
 
-  if (! ishold ())
-    set (h, "view", [-37.5, 30],
-         "xgrid", "on", "ygrid", "on", "zgrid", "on");
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
   endif
+  unwind_protect
+    hax = newplot (hax);
+    
+    htmp = __scatter__ (hax, 3, "scatter3", varargin{:});
+
+    if (! ishold (hax))
+      set (hax, "view", [-37.5, 30], "box", "off",
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    endif
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! [x, y, z] = peaks (20);
 %! scatter3 (x(:), y(:), z(:), [], z(:));
-%! %% Default scatter3 with constant size bubbles and color determined by Z
+%! title ({'Default scatter3() plot', ...
+%!         'constant size bubbles and color determined by Z'});
 
 %!demo
 %! clf;
 %! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 10, z(:), 's');
-%! %% scatter3 using a square marker of size 10 and color determined by Z
+%! title ({'scatter3() plot', ...
+%!         'marker is square, size is 10, color determined by Z'});
 
 %!demo
 %! clf;
 %! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 20*z(:), [], 's');
-%! %% scatter3 using a square marker whose size is determined by Z
+%! title ({'scatter3() plot', ...
+%!         'marker is square, size is determined by Z'});
 
 %!demo
 %! clf;
 %! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), 's');
-%! %% scatter3 using a square marker.
-%! %% Size and color of marker are determined by Z
+%! title ({'scatter3() plot', ...
+%!         'marker is square, size and color determined by Z'});
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/draw/semilogx.m
rename from scripts/plot/semilogx.m
rename to scripts/plot/draw/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/draw/semilogx.m
@@ -16,63 +16,73 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} semilogx (@var{y})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogx (@var{x}, @var{y}, @var{fmt})
-## @deftypefnx {Function File} {} semilogx (@var{h}, @dots{})
+## @deftypefnx {Function File} {} semilogx (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogx (@dots{})
-## Produce a two-dimensional plot using a logarithmic scale for the @var{x}
-## axis.  See the documentation of @code{plot} for a description of the
+## Produce a 2-D plot using a logarithmic scale for the x-axis.
+##
+## See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogx} will accept.
 ## 
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogy, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = semilogx (varargin)
+function h = semilogx (varargin)
 
-  [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
 
   if (nargs < 1)
     print_usage ();
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "xscale", "log");
-    if (any( strcmp (get (gca, "nextplot"), {"new", "replace"})))
-      set (h, "xminortick", "on");
+    set (hax, "xscale", "log");
+    if (! ishold (hax))
+      set (hax, "xminortick", "on");
     endif
 
-    tmp = __plt__ ("semilogx", h, varargin{:});
+    htmp = __plt__ ("semilogx", hax, varargin{:});
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
+%! title ({'semilogx() plot', 'X-axis is logarithmic'});
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
 %! subplot (1,2,1);
 %!  semilogx (x, y);
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/draw/semilogxerr.m
rename from scripts/plot/semilogxerr.m
rename to scripts/plot/draw/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/draw/semilogxerr.m
@@ -13,60 +13,77 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} semilogxerr (@var{args})
+## @deftypefnx {Function File} {} semilogxerr (@var{hax}, @var{args})
 ## @deftypefnx {Function File} {@var{h} =} semilogxerr (@var{args})
-## Produce two-dimensional plots using a logarithmic scale for the @var{x}
-## axis and errorbars at each data point.  Many different combinations of
-## arguments are possible.  The most common form is
+## Produce 2-D plots using a logarithmic scale for the x-axis and
+## errorbars at each data point.
+##
+## Many different combinations of arguments are possible.  The most common
+## form is
 ##
 ## @example
 ## semilogxerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See @code{errorbar} for available formats and
-## additional information.
-## @seealso{errorbar, loglogerr, semilogyerr}
+## format defined by @var{fmt}.  @xref{XREFerrorbar,,errorbar}, for available
+## formats and additional information.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## @seealso{errorbar, semilogyerr, loglogerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = semilogxerr (varargin)
+function h = semilogxerr (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("semilogxerr", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("semilogxerr", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "xscale", "log");
+    set (hax, "xscale", "log");
+    if (! ishold (hax))
+      set (hax, "xminortick", "on");
+    endif
 
-    tmp = __errcomm__ ("semilogxerr", h, varargin{:});
+    htmp = __errcomm__ ("semilogxerr", hax, varargin{:});
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
 %! semilogxerr (x, y, ey, '#~x-');
 %! xlim (x([1, end]));
+%! title ({'semilogxerr(): semilogx() plot with errorbars', ...
+%!         'X-axis is logarithmic'});
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/draw/semilogy.m
rename from scripts/plot/semilogy.m
rename to scripts/plot/draw/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/draw/semilogy.m
@@ -18,62 +18,71 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} semilogy (@var{y})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} semilogy (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} semilogy (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} semilogy (@dots{})
-## Produce a two-dimensional plot using a logarithmic scale for the @var{y}
-## axis.  See the documentation of @code{plot} for a description of the
+## Produce a 2-D plot using a logarithmic scale for the y-axis.
+##
+## See the documentation of @code{plot} for a description of the
 ## arguments that @code{semilogy} will accept.
 ##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ## @seealso{plot, semilogx, loglog}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = semilogy (varargin)
+function h = semilogy (varargin)
 
-  [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
 
   if (nargs < 1)
     print_usage ();
   endif
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "yscale", "log");
-    if (any (strcmp (get (gca, "nextplot"), {"new", "replace"})))
-      set (h, "yminortick", "on");
+    set (hax, "yscale", "log");
+    if (! ishold (hax))
+      set (hax, "yminortick", "on");
     endif
 
-    tmp = __plt__ ("semilogy", h, varargin{:});
-
-    if (nargout > 0)
-      retval = tmp;
-    endif
+    htmp = __plt__ ("semilogy", hax, varargin{:});
 
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
+%! title ({'semilogx() plot', 'Y-axis is logarithmic'});
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
 %! subplot (2,1,1);
 %!  semilogy (x, y);
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/draw/semilogyerr.m
rename from scripts/plot/semilogyerr.m
rename to scripts/plot/draw/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/draw/semilogyerr.m
@@ -13,61 +13,78 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} semilogyerr (@var{args})
+## @deftypefnx {Function File} {} semilogyerr (@var{hax}, @var{args})
 ## @deftypefnx {Function File} {@var{h} =} semilogyerr (@var{args})
-## Produce two-dimensional plots using a logarithmic scale for the @var{y}
-## axis and errorbars at each data point.  Many different combinations of
-## arguments are possible.  The most common form is
+## Produce 2-D plots using a logarithmic scale for the y-axis and
+## errorbars at each data point.
+##
+## Many different combinations of arguments are possible.  The most common
+## form is
 ##
 ## @example
 ## semilogyerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See @code{errorbar} for available formats and
-## additional information.
-## @seealso{errorbar, loglogerr, semilogxerr}
+## format defined by @var{fmt}.  @xref{XREFerrorbar,,errorbar}, for available
+## formats and additional information.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## @seealso{errorbar, semilogxerr, loglogerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
-function retval = semilogyerr (varargin)
+function h = semilogyerr (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("semilogyerr", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("semilogyerr", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
+    hax = newplot (hax);
 
-    set (h, "yscale", "log");
+    set (hax, "yscale", "log");
+    if (! ishold (hax))
+      set (hax, "yminortick", "on");
+    endif
 
-    tmp = __errcomm__ ("semilogyerr", h, varargin{:});
+    htmp = __errcomm__ ("semilogyerr", hax, varargin{:});
 
-    if (nargout > 0)
-      retval = tmp;
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  unwind_protect_cleanup
-    axes (oldh);
   end_unwind_protect
 
+  if (nargout > 0)
+    h = htmp;
+  endif
+
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0.25:0.25:10;
 %! y = wblpdf (x, 4, 2);
 %! eyu = rand (size (y));
 %! eyl = 1.0 - 1./(1+eyu);
 %! semilogyerr (x, y, eyl.*y, eyu.*y, '~-d');
 %! xlim ([0 10]);
+%! title ({'semilogyerr(): semilogy() plot with errorbars', ...
+%!         'Y-axis is logarithmic'});
 
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/draw/shrinkfaces.m
rename from scripts/plot/shrinkfaces.m
rename to scripts/plot/draw/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/draw/shrinkfaces.m
@@ -20,27 +20,27 @@
 ## @deftypefn  {Function File} {} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{fv}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{f}, @var{v}, @var{sf})
 ## @deftypefnx {Function File} {[@var{nf}, @var{nv}] =} shrinkfaces (@dots{})
 ##
 ## Reduce the faces area for a given patch, structure or explicit faces
 ## and points matrices by a scale factor @var{sf}.  The structure
-## @var{fv} must contain the fields 'faces' and 'vertices'.  If the
-## factor @var{sf} is omitted then a default of 0.3 is used.
+## @var{fv} must contain the fields @qcode{"faces"} and @qcode{"vertices"}. 
+## If the factor @var{sf} is omitted then a default of 0.3 is used.
 ##
 ## Given a patch handle as the first input argument and no output
 ## parameters, perform the shrinking of the patch faces in place and
 ## redraw the patch.
 ##
 ## If called with one output argument, return a structure with fields
-## 'faces', 'vertices', and 'facevertexcdata' containing the data after
-## shrinking which can then directly be used as an input argument for the
-## @command{patch} function.
+## @qcode{"faces"}, @qcode{"vertices"}, and @qcode{"facevertexcdata"}
+## containing the data after shrinking which can then directly be used as an
+## input argument for the @code{patch} function.
 ##
 ## Performing the shrinking on faces which are not convex can lead to
 ## undesired results.
 ##
 ## For example,
 ##
 ## @example
 ## @group
@@ -101,17 +101,17 @@ function [nf, nv] = shrinkfaces (varargi
   endif
   
   if (! isscalar (sf) || sf <= 0)
     error ("shrinkfaces: scale factor must be a positive scalar");
   endif
 
   n = columns (vertices);
   if (n < 2 || n > 3)
-    error ("shrinkfaces: only 2D and 3D patches are supported");
+    error ("shrinkfaces: only 2-D and 3-D patches are supported");
   endif
 
   m = columns (faces);
   if (m < 3)
     error ("shrinkfaces: faces must consist of at least 3 vertices");
   endif
 
   v = vertices(faces'(:), :);
diff --git a/scripts/plot/slice.m b/scripts/plot/draw/slice.m
rename from scripts/plot/slice.m
rename to scripts/plot/draw/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/draw/slice.m
@@ -16,95 +16,102 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} slice (@var{x}, @var{y}, @var{z}, @var{v}, @var{sx}, @var{sy}, @var{sz})
 ## @deftypefnx {Function File} {} slice (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {} slice (@var{v}, @var{sx}, @var{sy}, @var{sz})
 ## @deftypefnx {Function File} {} slice (@var{v}, @var{xi}, @var{yi}, @var{zi})
+## @deftypefnx {Function File} {} slice (@dots{}, @var{method})
+## @deftypefnx {Function File} {} slice (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{})
-## @deftypefnx {Function File} {@var{h} =} slice (@dots{}, @var{method})
-## Plot slices of 3-D data/scalar fields.  Each element of the 3-dimensional
-## array @var{v} represents a scalar value at a location given by the
-## parameters @var{x}, @var{y}, and @var{z}.  The parameters @var{x},
-## @var{x}, and @var{z} are either 3-dimensional arrays of the same size
-## as the array @var{v} in the "meshgrid" format or vectors.  The
-## parameters @var{xi}, etc. respect a similar format to @var{x}, etc.,
-## and they represent the points at which the array @var{vi} is
-## interpolated using interp3.  The vectors @var{sx}, @var{sy}, and
+## Plot slices of 3-D data/scalar fields.
+##
+## Each element of the 3-dimensional array @var{v} represents a scalar value at
+## a location given by the parameters @var{x}, @var{y}, and @var{z}.  The
+## parameters @var{x}, @var{x}, and @var{z} are either 3-dimensional arrays of
+## the same size as the array @var{v} in the @qcode{"meshgrid"} format or
+## vectors.  The parameters @var{xi}, etc. respect a similar format to
+## @var{x}, etc., and they represent the points at which the array @var{vi}
+## is interpolated using interp3.  The vectors @var{sx}, @var{sy}, and
 ## @var{sz} contain points of orthogonal slices of the respective axes.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1:size (@var{v}, 2)}, @code{y = 1:size (@var{v}, 1)} and
 ## @code{z = 1:size (@var{v}, 3)}.
 ##
-## @var{Method} is one of:
+## @var{method} is one of:
 ##
 ## @table @asis
-## @item "nearest"
+## @item @qcode{"nearest"}
 ## Return the nearest neighbor.
 ##
-## @item "linear"
+## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors.
 ##
-## @item "cubic"
+## @item @qcode{"cubic"}
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item "spline"
+## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is @code{"linear"}.
+## The default method is @qcode{"linear"}.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## [x, y, z] = meshgrid (linspace (-8, 8, 32));
 ## v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 ## slice (x, y, z, v, [], 0, []);
+##
 ## [xi, yi] = meshgrid (linspace (-7, 7));
 ## zi = xi + yi;
 ## slice (x, y, z, v, xi, yi, zi);
 ## @end group
 ## @end example
 ## @seealso{interp3, surface, pcolor}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function h = slice (varargin)
 
+  [hax, varargin, nargs] = __plt_get_axis_arg__ ("slice", varargin{:});
+
   method = "linear";
-  nargs = nargin;
 
   if (ischar (varargin{end}))
     method = varargin{end};
     nargs -= 1;
   endif
 
   if (nargs == 4)
     v = varargin{1};
     if (ndims (v) != 3)
-      error ("slice: expect 3-dimensional array of values");
+      error ("slice: V must be a 3-dimensional array of values");
     endif
     [nx, ny, nz] = size (v);
     [x, y, z] = meshgrid (1:nx, 1:ny, 1:nz);
     sx = varargin{2};
     sy = varargin{3};
     sz = varargin{4};
   elseif (nargs == 7)
     v = varargin{4};
     if (ndims (v) != 3)
-      error ("slice: expect 3-dimensional array of values");
+      error ("slice: V must be a 3-dimensional array of values");
     endif
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     if (isvector (x) && isvector (y) && isvector (z))
       [x, y, z] = meshgrid (x, y, z);
     elseif (ndims (x) == 3 && size_equal (x, y, z))
       ## Do nothing.
@@ -121,66 +128,77 @@ function h = slice (varargin)
   if (any ([isvector(sx), isvector(sy), isvector(sz)]))
     have_sval = true;
   elseif (ndims (sx) == 2 && size_equal (sx, sy, sz))
     have_sval = false;
   else
     error ("slice: dimensional mismatch for (XI, YI, ZI) or (SX, SY, SZ)");
   endif
 
-  newplot ();
-  ax = gca ();
-  sidx = 1;
-  maxv = max (v(:));
-  minv = min (v(:));
-  set (ax, "clim", [minv, maxv]);
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+
+    sidx = 1;
+    minv = min (v(:));
+    maxv = max (v(:));
+    set (hax, "clim", [minv, maxv]);
 
-  if (have_sval)
-    ns = length (sx) + length (sy) + length (sz);
-    hs = zeros (ns,1);
-    [ny, nx, nz] = size (v);
-    if (length (sz) > 0)
-      for i = 1:length (sz)
-        [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)),
-                                 squeeze (y(:,1,1)), sz(i));
-        vz = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
-        tmp(sidx++) = surface (xi, yi, sz(i) * ones (size (yi)), vz);
-      endfor
+    if (have_sval)
+      ns = length (sx) + length (sy) + length (sz);
+      hs = zeros (ns,1);
+      [ny, nx, nz] = size (v);
+      if (length (sz) > 0)
+        for i = 1:length (sz)
+          [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)),
+                                   squeeze (y(:,1,1)), sz(i));
+          vz = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
+          htmp(sidx++) = surface (xi, yi, sz(i) * ones (size (yi)), vz);
+        endfor
+      endif
+
+      if (length (sy) > 0)
+        for i = length (sy):-1:1
+          [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
+          vy = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
+          htmp(sidx++) = surface (squeeze (xi),
+                                  squeeze (sy(i) * ones (size (zi))),
+                                  squeeze (zi), vy);
+        endfor
+      endif
+
+      if (length (sx) > 0)
+        for i = length (sx):-1:1
+          [xi, yi, zi] = meshgrid (sx(i), squeeze (y(:,1,1)), squeeze (z(1,1,:)));
+          vx = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
+          htmp(sidx++) = surface (squeeze (sx(i) * ones (size (zi))),
+                                  squeeze (yi), squeeze(zi), vx);
+        endfor
+      endif
+    else
+      vi = interp3 (x, y, z, v, sx, sy, sz);
+      htmp = surface (sx, sy, sz, vi);
     endif
 
-    if (length (sy) > 0)
-      for i = length (sy):-1:1
-        [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
-        vy = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
-        tmp(sidx++) = surface (squeeze (xi),
-                               squeeze (sy(i) * ones (size (zi))),
-                               squeeze (zi), vy);
-      endfor
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30.0], "box", "off",
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
 
-    if (length (sx) > 0)
-      for i = length (sx):-1:1
-        [xi, yi, zi] = meshgrid (sx(i), squeeze (y(:,1,1)), squeeze (z(1,1,:)));
-        vx = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
-        tmp(sidx++) = surface (squeeze (sx(i) * ones (size (zi))),
-                               squeeze (yi), squeeze(zi), vx);
-      endfor
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
     endif
-  else
-    vi = interp3 (x, y, z, v, sx, sy, sz);
-    tmp = surface (sx, sy, sz, vi);
-  endif
-
-  if (! ishold ())
-    set (ax, "view", [-37.5, 30.0], "box", "off", "xgrid", "on",
-         "ygrid", "on", "zgrid", "on");
-  endif
+  end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
diff --git a/scripts/plot/sombrero.m b/scripts/plot/draw/sombrero.m
rename from scripts/plot/sombrero.m
rename to scripts/plot/draw/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/draw/sombrero.m
@@ -14,55 +14,73 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sombrero ()
 ## @deftypefnx {Function File} {} sombrero (@var{n})
-## Produce the familiar three-dimensional sombrero plot using @var{n}
-## grid lines.  If @var{n} is omitted, a value of 41 is assumed.
+## @deftypefnx {Function File} {@var{z} =} sombrero (@dots{})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} sombrero (@dots{})
+## Plot the familiar 3-D sombrero function.
 ##
 ## The function plotted is
+## @tex
+## $$z = { \rm{sin} (\sqrt {(x^2 + y^2)}) \over \sqrt {(x^2 + y^2)} }$$
+## @end tex
+## @ifnottex
 ##
 ## @example
 ## z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))
 ## @end example
-## @seealso{surf, meshgrid, mesh}
+##
+## @end ifnottex
+## Called without a return argument, @code{sombrero} plots the surface of the
+## above function over the meshgrid [-8,8] using @code{surf}.
+## 
+## If @var{n} is a scalar the plot is made with @var{n} grid lines.
+## The default value for @var{n} is 41.
+##
+## When called with output arguments, return the data for the function
+## evaluated over the meshgrid.  This can subsequently be plotted with
+## @code{surf (@var{x}, @var{y}, @var{z})}.
+##
+## @seealso{peaks, meshgrid, mesh, surf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [x, y, z] = sombrero (n = 41)
 
   if (nargin > 2)
     print_usage ();
   elseif (n <= 1)
     error ("sombrero: number of grid lines N must be greater than 1");
   endif
 
-  tx = linspace (-8, 8, n)';
-  ty = tx;
-  [xx, yy] = meshgrid (tx, ty);
-  r = sqrt (xx .^ 2 + yy .^ 2) + eps;
-  tz = sin (r) ./ r;
+  [xx, yy] = meshgrid (linspace (-8, 8, n));
+  r = sqrt (xx.^2 + yy.^2) + eps;  # eps prevents div/0 errors
+  zz = sin (r) ./ r;
+
   if (nargout == 0)
-    surf (tx, ty, tz);
-    box ("off");
+    surf (xx, yy, zz);
+  elseif (nargout == 1)
+    x = zz;
   else
-    x = tx;
-    y = ty;
-    z = tz;
+    x = xx;
+    y = yy;
+    z = zz;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! sombrero ();
+%! title ('sombrero() function');
 
 ## Test input validation
 %!error sombrero (1,2,3)
 %!error <N must be greater than 1> sombrero (1)
 
diff --git a/scripts/plot/sphere.m b/scripts/plot/draw/sphere.m
rename from scripts/plot/sphere.m
rename to scripts/plot/draw/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/draw/sphere.m
@@ -12,33 +12,49 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{x}, @var{y}, @var{z}] =} sphere (@var{n})
-## @deftypefnx {Function File} {} sphere (@var{h}, @dots{})
-## Generate three matrices in @code{meshgrid} format, such that
-## @code{surf (@var{x}, @var{y}, @var{z})} generates a unit sphere.
-## The matrices of @code{@var{n}+1}-by-@code{@var{n}+1}.  If @var{n} is
-## omitted then a default value of 20 is assumed.
+## @deftypefn  {Function File} {} sphere ()
+## @deftypefnx {Function File} {} sphere (@var{n})
+## @deftypefnx {Function File} {} sphere (@var{hax}, @dots{})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} sphere (@dots{})
+## Plot a 3-D unit sphere.
+##
+## The optional input @var{n} determines the number of faces around the
+## the circumference of the sphere.  The default value is 20.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
-## Called with no return arguments, @code{sphere} call directly
-## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle is passed
-## as the first argument, the surface is plotted to this set of axes.
-## @seealso{peaks}
+## If outputs are requested @code{sphere} returns three matrices in
+## @code{meshgrid} format such that @code{surf (@var{x}, @var{y}, @var{z})}
+## generates a unit sphere.
+##
+## Example:
+##
+## @example
+## @group
+## [x, y, z] = sphere (40);
+## surf (3*x, 3*y, 3*z);
+## axis equal;
+## title ("sphere of radius 3");
+## @end group
+## @end example
+## @seealso{cylinder, ellipsoid, rectangle}
 ## @end deftypefn
 
 function [xx, yy, zz] = sphere (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "sphere",
-                                                varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("sphere", varargin{:});
+
   if (nargin > 1)
     print_usage ();
   elseif (nargin == 1)
     n = varargin{1};
   else
     n = 20;
   endif
 
@@ -50,12 +66,25 @@ function [xx, yy, zz] = sphere (varargin
   y = cos (phi) .* sin (theta);
   z = sin (phi);
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
-    surf (h, x, y, z);
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
+    unwind_protect
+      hax = newplot (hax);
+    
+      surf (x, y, z);
+    unwind_protect_cleanup
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
+    end_unwind_protect
   endif
 
 endfunction
+
diff --git a/scripts/plot/stairs.m b/scripts/plot/draw/stairs.m
rename from scripts/plot/stairs.m
rename to scripts/plot/draw/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/draw/stairs.m
@@ -15,24 +15,34 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} stairs (@var{y})
 ## @deftypefnx {Function File} {} stairs (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} stairs (@dots{}, @var{style})
-## @deftypefnx {Function File} {} stairs (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} stairs (@var{h}, @dots{})
+## @deftypefnx {Function File} {} stairs (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} stairs (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} stairs (@dots{})
 ## @deftypefnx {Function File} {[@var{xstep}, @var{ystep}] =} stairs (@dots{})
-## Produce a stairstep plot.  The arguments may be vectors or matrices.
+## Produce a stairstep plot.
 ##
-## If only one argument is given, it is taken as a vector of y-values
-## and the x coordinates are taken to be the indices of the elements.
+## The arguments @var{x} and @var{y} may be vectors or matrices.
+## If only one argument is given, it is taken as a vector of Y values
+## and the X coordinates are taken to be the indices of the elements.
+## 
+## The style to use for the plot can be defined with a line style @var{style}
+## of the same format as the @code{plot} command.
+##
+## Multiple property/value pairs may be specified, but they must appear in
+## pairs.
+##
+## If the first argument @var{hax} is an axis handle, then plot into this axis,
+## rather than the current axis handle returned by @code{gca}.
 ##
 ## If one output argument is requested, return a graphics handle to the
 ## created plot.  If two output arguments are specified, the data are generated
 ## but not plotted.  For example,
 ##
 ## @example
 ## stairs (x, y);
 ## @end example
@@ -44,89 +54,89 @@
 ## @group
 ## [xs, ys] = stairs (x, y);
 ## plot (xs, ys);
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
-## @seealso{plot}
+## @seealso{bar, hist, plot, stem}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xs, ys] = stairs (varargin)
 
-  [ax, varargin, nargin] = __plt_get_axis_arg__ ("stairs", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("stairs", varargin{:});
 
   if (nargin < 1)
     print_usage ();
+  endif
+
+  if (nargout < 2)
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
+    unwind_protect
+      hax = newplot (hax);
+      [htmp, xxs, yys] = __stairs__ (true, varargin{:});
+    unwind_protect_cleanup
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
+    end_unwind_protect
+    if (nargout == 1)
+      xs = htmp;
+    endif
   else
-    if (nargout > 1)
-      [h, xs, ys] = __stairs__ (false, varargin{:});
-    else
-      oldax = gca ();
-      unwind_protect
-        axes (ax);
-        newplot ();
-        [h, xxs, yys] = __stairs__ (true, varargin{:});
-      unwind_protect_cleanup
-        axes (oldax);
-      end_unwind_protect
-    endif
-    if (nargout == 1)
-      xs = h;
-    endif
+    [~, xs, ys] = __stairs__ (false, varargin{:});
   endif
+
 endfunction
 
 function [h, xs, ys] = __stairs__ (doplot, varargin)
 
   if (nargin == 2 || ischar (varargin{2}))
-    y = varargin {1};
+    y = varargin{1};
     varargin(1) = [];
-    if (ismatrix (y))
-      if (isvector (y))
-        y = y(:);
-      endif
-      x = 1:rows (y);
+    if (! ismatrix (y) || ndims (y) > 2)
+      error ("stairs: Y must be a numeric 2-D vector or matrix");
     endif
+    if (isvector (y))
+      y = y(:);
+    endif
+    x = 1:rows (y);
   else
     x = varargin{1};
     y = varargin{2};
     varargin(1:2) = [];
-  endif
-
-  if (ndims (x) > 2 || ndims (y) > 2)
-    error ("stairs: expecting 2-d arguments");
+    if (! ismatrix (x) || ! ismatrix (y) || ndims (x) > 2 || ndims (y) > 2)
+      error ("stairs: X and Y must be numeric 2-D vectors or matrices");
+    endif
   endif
 
   vec_x = isvector (x);
-
   if (vec_x)
     x = x(:);
   endif
 
   if (isvector (y))
     y = y(:);
+  elseif (ismatrix (y) && vec_x)
+    x = repmat (x, [1, columns(y)]);
   endif
 
-  if (ismatrix (y))
-    [nr, nc] = size (y);
-    if (vec_x)
-      x = repmat (x, [1, nc]);
-    else
-      [x_nr, x_nc] = size (x);
-      if (x_nr != nr || x_nc != nc)
-        error ("stairs: argument size mismatch");
-      endif
-    endif
+  if (! size_equal (x, y))
+    error ("stairs: X and Y sizes must match");
   endif
 
+  [nr, nc] = size (y);
+
   len = 2*nr - 1;
 
   xs = ys = zeros (len, nc);
 
   xs(1,:) = x(1,:);
   ys(1,:) = y(1,:);
 
   xtmp = x(2:nr,:);
@@ -134,134 +144,112 @@ function [h, xs, ys] = __stairs__ (doplo
   xs(ridx,:) = xtmp;
   ys(ridx,:) = y(1:nr-1,:);
 
   ridx = 3:2:len;
   xs(ridx,:) = xtmp;
   ys(ridx,:) = y(2:nr,:);
 
   have_line_spec = false;
-  for i = 1 : length (varargin)
-    arg = varargin {i};
-    if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
+  for i = 1:2:numel (varargin)
+    arg = varargin{i};
+    if (ischar (arg) || iscellstr (arg))
       [linespec, valid] = __pltopt__ ("stairs", arg, false);
       if (valid)
         have_line_spec = true;
         varargin(i) = [];
         break;
       endif
     endif
   endfor
 
   if (doplot)
     h = [];
+    hold_state = get (gca (), "nextplot");
     unwind_protect
-      hold_state = get (gca (), "nextplot");
       for i = 1 : columns (y)
+
+        if (have_line_spec)
+          lc = linespec.color;
+          if (isempty (lc))
+            lc = __next_line_color__ ();
+          endif
+          ls = linespec.linestyle;
+          if (isempty (ls))
+            ls = "-";
+          endif
+          mk = linespec.marker;
+          if (isempty (mk))
+            mk = "none";
+          endif
+        else
+          lc = __next_line_color__ ();
+          ls = "-";
+          mk = "none";
+        endif
+
+        ## Must occur after __next_line_color__ in order to work correctly.
         hg = hggroup ();
         h = [h; hg];
         args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
 
         addproperty ("xdata", hg, "data", x(:,i).');
         addproperty ("ydata", hg, "data", y(:,i).');
 
         addlistener (hg, "xdata", @update_data);
         addlistener (hg, "ydata", @update_data);
 
-        if (have_line_spec)
-          tmp = line (xs(:,i).', ys(:,i).', "color", linespec.color,
-                      "parent", hg);
-        else
-          tmp = line (xs(:,i).', ys(:,i).', "color", __next_line_color__ (),
-                      "parent", hg);
-        endif
+        htmp = line (xs(:,i).', ys(:,i).', "color", lc, "linestyle", ls,
+                                           "marker", mk, "parent", hg);
+
+        addproperty ("color", hg, "linecolor", get (htmp, "color"));
+        addproperty ("linestyle", hg, "linelinestyle", get (htmp, "linestyle"));
+        addproperty ("linewidth", hg, "linelinewidth", get (htmp, "linewidth"));
 
-        addproperty ("color", hg, "linecolor", get (tmp, "color"));
-        addproperty ("linewidth", hg, "linelinewidth", get (tmp, "linewidth"));
-        addproperty ("linestyle", hg, "linelinestyle", get (tmp, "linestyle"));
-
-        addproperty ("marker", hg, "linemarker", get (tmp, "marker"));
+        addproperty ("marker", hg, "linemarker", get (htmp, "marker"));
+        addproperty ("markeredgecolor", hg, "linemarkeredgecolor",
+                     get (htmp, "markeredgecolor"));
         addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
-                     get (tmp, "markerfacecolor"));
-        addproperty ("markeredgecolor", hg, "linemarkeredgecolor",
-                     get (tmp, "markeredgecolor"));
+                     get (htmp, "markerfacecolor"));
         addproperty ("markersize", hg, "linemarkersize",
-                     get (tmp, "markersize"));
+                     get (htmp, "markersize"));
 
         addlistener (hg, "color", @update_props);
+        addlistener (hg, "linestyle", @update_props);
         addlistener (hg, "linewidth", @update_props);
-        addlistener (hg, "linestyle", @update_props);
         addlistener (hg, "marker", @update_props);
+        addlistener (hg, "markeredgecolor", @update_props);
         addlistener (hg, "markerfacecolor", @update_props);
-        addlistener (hg, "markeredgecolor", @update_props);
         addlistener (hg, "markersize", @update_props);
 
+        ## Matlab property, although Octave does not implement it.
+        addproperty ("hittestarea", hg, "radio", "on|{off}", "off");
+
         if (! isempty (args))
           set (hg, args{:});
         endif
       endfor
     unwind_protect_cleanup
       set (gca (), "nextplot", hold_state);
     end_unwind_protect
   else
     h = 0;
   endif
 
 endfunction
 
-
-%!demo
-%! clf;
-%! x = 1:10;
-%! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
-%! y = rand_1x10_data1;
-%! stairs (x, y);
-
-%!demo
-%! clf;
-%! x = 1:10;
-%! rand_1x10_data2 = [0.014, 0.460, 0.622, 0.394, 0.531, 0.378, 0.466, 0.788, 0.342, 0.893];
-%! y = rand_1x10_data2;
-%! [xs, ys] = stairs (x, y);
-%! plot (xs, ys);
-
-%!demo
-%! clf;
-%! stairs (1:9);
-
-%!demo
-%! clf;
-%! [xs, ys] = stairs (9:-1:1);
-%! plot (xs, ys);
-
-%!demo
-%! clf;
-%! N = 11;
-%! x = 0:(N-1);
-%! y = rand (1, N);
-%! hs = stairs (x(1), y(1));
-%! set (gca (), 'xlim', [1, N-1], 'ylim', [0, 1]);
-%! for k=2:N
-%!   set (hs, 'xdata', x(1:k), 'ydata', y(1:k));
-%!   drawnow ();
-%!   pause (0.2);
-%! end
-
-
-function update_props (h, d)
-  set (get (h, "children"), "color", get (h, "color"),
-       "linewidth", get (h, "linewidth"),
-       "linestyle", get (h, "linestyle"),
-       "marker", get (h, "marker"),
-       "markerfacecolor", get (h, "markerfacecolor"),
-       "markeredgecolor", get (h, "markeredgecolor"),
-       "markersize", get (h, "markersize"));
+function update_props (h, ~)
+  set (get (h, "children"),
+       {"color", "linestyle", "linewidth", "marker", ...
+        "markeredgecolor", "markerfacecolor", "markersize"},
+       get (h, {"color", "linestyle", "linewidth", "marker", ...
+                "markeredgecolor", "markerfacecolor", "markersize"}));
 endfunction
 
-function update_data (h, d)
+function update_data (h, ~)
   x = get (h, "xdata");
   y = get (h, "ydata");
 
   sz = min ([size(x); size(y)]);
   x = x(1:sz(1), 1:sz(2));
   y = y(1:sz(1), 1:sz(2));
 
   nr = length (x);
@@ -277,8 +265,68 @@ function update_data (h, d)
   ys(ridx) = y(1:nr-1);
 
   ridx = 3:2:len;
   xs(ridx) = xtmp;
   ys(ridx) = y(2:nr);
 
   set (get (h, "children"), "xdata", xs, "ydata", ys);
 endfunction
+
+
+%!demo
+%! clf;
+%! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
+%! y = rand_1x10_data1;
+%! stairs (y);
+%! title ('stairs() plot of y-data');
+
+%!demo
+%! clf;
+%! x = 1:10;
+%! rand_1x10_data2 = [0.014, 0.460, 0.622, 0.394, 0.531, 0.378, 0.466, 0.788, 0.342, 0.893];
+%! y = rand_1x10_data2;
+%! [xs, ys] = stairs (x, y);
+%! plot (xs, ys);
+%! title ('plot() of stairs() generated data');
+
+%!demo
+%! clf;
+%! stairs (1:9, '-o');
+%! title ('stairs() plot with linespec to modify marker');
+
+%!demo
+%! clf;
+%! stairs (9:-1:1, 'marker', 's', 'markersize', 10, 'markerfacecolor', 'm');
+%! title ('stairs() plot with prop/val pairs to modify appearance');
+
+%!demo
+%! clf;
+%! N = 11;
+%! x = 0:(N-1);
+%! y = rand (1, N);
+%! hs = stairs (x(1), y(1));
+%! axis ([1, N-1 0, 1]);
+%! title ('stairs plot data modified through handle');
+%! for k = 2:N
+%!   set (hs, 'xdata', x(1:k), 'ydata', y(1:k));
+%!   drawnow ();
+%!   pause (0.2);
+%! end
+
+## Invisible figure used for tests
+%!shared hf, hax
+%! hf = figure ("visible", "off");
+%! hax = axes;
+
+%!error stairs ()
+%!error <Y must be a numeric 2-D vector> stairs (hax, {1})
+%!error <Y must be a numeric 2-D vector> stairs (ones (2,2,2))
+%!error <X and Y must be numeric 2-D vector> stairs ({1}, 1)
+%!error <X and Y must be numeric 2-D vector> stairs (1, {1})
+%!error <X and Y must be numeric 2-D vector> stairs (ones (2,2,2), 1)
+%!error <X and Y must be numeric 2-D vector> stairs (1, ones (2,2,2))
+%!error <X and Y sizes must match> stairs (1:2, 1:3)
+
+## Close figure used for testing
+%!test
+%! close (hf);
+
diff --git a/scripts/plot/stem.m b/scripts/plot/draw/stem.m
rename from scripts/plot/stem.m
rename to scripts/plot/draw/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/draw/stem.m
@@ -14,132 +14,202 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} stem (@var{y})
 ## @deftypefnx {Function File} {} stem (@var{x}, @var{y})
-## @deftypefnx {Function File} {} stem (@var{x}, @var{y}, @var{linespec})
+## @deftypefnx {Function File} {} stem (@dots{}, @var{linespec})
 ## @deftypefnx {Function File} {} stem (@dots{}, "filled")
+## @deftypefnx {Function File} {} stem (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} stem (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} stem (@dots{})
-## Plot a stem graph from two vectors of x-y data.  If only one argument
-## is given, it is taken as the y-values and the x coordinates are taken
-## from the indices of the elements.
+## Plot a 2-D stem graph.
+##
+## If only one argument is given, it is taken as the y-values and the
+## x-coordinates are taken from the indices of the elements.
 ##
 ## If @var{y} is a matrix, then each column of the matrix is plotted as
 ## a separate stem graph.  In this case @var{x} can either be a vector,
 ## the same length as the number of rows in @var{y}, or it can be a
 ## matrix of the same size as @var{y}.
 ##
-## The default color is @code{"b"} (blue).  The default line style is
-## @code{"-"} and the default marker is @code{"o"}.  The line style can
+## The default color is @qcode{"b"} (blue), the default line style is
+## @qcode{"-"}, and the default marker is @qcode{"o"}.  The line style can
 ## be altered by the @code{linespec} argument in the same manner as the
-## @code{plot} command.  For example,
+## @code{plot} command.  If the @qcode{"filled"} argument is present the
+## markers at the top of the stems will be filled in.  For example,
 ##
 ## @example
 ## @group
 ## x = 1:10;
 ## y = 2*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ##
-## The optional return value @var{h} is a vector of "stem series" graphics
-## handles with one handle per column of the variable @var{y}.  The
-## handle regroups the elements of the stem graph together as the
-## children of the "stem series" handle, allowing them to be altered
-## together.  For example,
+## Optional property/value pairs may be specified to control the appearance
+## of the plot.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a handle to a @nospell{"stem series"}
+## hggroup.  The single hggroup handle has all of the graphical elements
+## comprising the plot as its children; This allows the properties of
+## multiple graphics objects to be changed by modifying just a single
+## property of the @nospell{"stem series"} hggroup.
+##
+## For example,
 ##
 ## @example
 ## @group
 ## x = [0:10]';
 ## y = [sin(x), cos(x)]
 ## h = stem (x, y);
 ## set (h(2), "color", "g");
 ## set (h(1), "basevalue", -1)
 ## @end group
 ## @end example
 ##
 ## @noindent
-## changes the color of the second "stem series" and moves the base line
-## of the first.
-## @seealso{bar, barh, plot}
+## changes the color of the second @nospell{"stem series"} and moves the base
+## line of the first.
+##
+## Stem Series Properties
+##
+## @table @asis
+## @item linestyle
+## The linestyle of the stem.  (Default: @qcode{"-"})
+##
+## @item linewidth
+## The width of the stem.  (Default: 0.5)
+##
+## @item color
+## The color of the stem, and if not separately specified, the marker.
+## (Default: @qcode{"b"} [blue])
+##
+## @item marker
+## The marker symbol to use at the top of each stem.  (Default: @qcode{"o"})
+##
+## @item markeredgecolor
+## The edge color of the marker.  (Default: @qcode{"color"} property)
+##
+## @item markerfacecolor
+## The color to use for @nospell{"filling"} the marker.  
+## (Default: @qcode{"none"} [unfilled])
+##
+## @item markersize
+## The size of the marker.  (Default: 6)
+##
+## @item baseline
+## The handle of the line object which implements the baseline.  Use @code{set}
+## with the returned handle to change graphic properties of the baseline.
+##
+## @item basevalue
+## The y-value where the baseline is drawn.  (Default: 0)
+## @end table
+## @seealso{stem3, bar, hist, plot, stairs}
 ## @end deftypefn
 
 ## Author: Michel D. Schmid <michaelschmid@users.sourceforge.net>
 ## Adapted-by: jwe
 
 function h = stem (varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  tmp = __stem__ (false, varargin{:});
+  htmp = __stem__ (false, varargin{:});
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! x = 1:10;
-%! stem (x);
+%! y = 1:10;
+%! stem (y);
+%! title ('stem plot of y-values only');
 
 %!demo
 %! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! stem (x, y);
+%! title ('stem plot of x and y-values');
 
 %!demo
 %! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, 'r');
+%! title ('stem plot with modified color');
 
 %!demo
 %! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, '-.k');
+%! title ('stem plot with modified line style and color');
 
 %!demo
 %! clf;
 %! x = 1:10;
 %! y = 2*x;
-%! h = stem (x, y, '-.k.');
+%! h = stem (x, y, '-.ks');
+%! title ('stem plot with modified line style, color, and marker');
 
 %!demo
 %! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, 'filled');
+%! title ('stem plot with "filled" markers');
+
+%!demo
+%! clf;
+%! x = 1:10;
+%! y = 2*x;
+%! h = stem (x, y, 'markerfacecolor', [1 0 1]);
+%! title ('stem plot modified with property/value pair');
 
 %!demo
 %! clf;
 %! x = (0 : 10)';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), 'color', 'g');
 %! set (h(1), 'basevalue', -1);
+%! title ('stem plots modified through hggroup handle');
 
 %!demo
 %! clf;
 %! N = 11;
 %! x = 0:(N-1);
 %! y = rand (1, N);
 %! hs = stem (x(1), y(1));
 %! set (gca (), 'xlim', [1, N-1], 'ylim', [0, 1]);
+%! title ('stem plot data modified through hggroup handle');
 %! for k=2:N
 %!   set (hs, 'xdata', x(1:k), 'ydata', y(1:k))
 %!   drawnow ();
 %!   pause (0.2);
 %! end
 
+%!error stem ()
+%!error <can not define Z for 2-D stem plot> stem (1,2,3)
+%!error <X and Y must be numeric> stem ({1})
+%!error <X and Y must be numeric> stem (1, {1})
+%!error <inconsistent sizes for X and Y> stem (1:2, 1:3)
+%!error <inconsistent sizes for X and Y> stem (1:2, ones (3,3))
+%!error <inconsistent sizes for X and Y> stem (ones (2,2), ones (3,3))
+%!error <No value specified for property "FOO"> stem (1, "FOO")
+
diff --git a/scripts/plot/stem3.m b/scripts/plot/draw/stem3.m
rename from scripts/plot/stem3.m
rename to scripts/plot/draw/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/draw/stem3.m
@@ -13,50 +13,80 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} stem3 (@var{x}, @var{y}, @var{z})
-## @deftypefnx {Function File} {} stem3 (@var{x}, @var{y}, @var{z}, @var{linespec})
+## @deftypefnx {Function File} {} stem3 (@dots{}, @var{linespec})
+## @deftypefnx {Function File} {} stem3 (@dots{}, "filled")
+## @deftypefnx {Function File} {} stem3 (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} stem3 (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} stem3 (@dots{})
-## Plot a three-dimensional stem graph and return the handles of the line
-## and marker objects used to draw the stems as "stem series" object.
-## The default color is @code{"r"} (red).  The default line style is
-## @code{"-"} and the default marker is @code{"o"}.
+## Plot a 3-D stem graph.
+##
+## Stems are drawn from the height @var{z} to the location in the x-y plane
+## determined by @var{x} and @var{y}.  The default color is @qcode{"b"} (blue),
+## the default line style is @qcode{"-"}, and the default marker is @qcode{"o"}.
+##
+## The line style can be altered by the @code{linespec} argument in the same
+## manner as the @code{plot} command.  If the @qcode{"filled"} argument is
+## present the markers at the top of the stems will be filled in.
 ##
-## For example,
+## Optional property/value pairs may be specified to control the appearance
+## of the plot.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a handle to the @nospell{"stem series"}
+## hggroup containing the line and marker objects used for the plot.
+## @xref{XREFstem,,stem}, for a description of the @nospell{"stem series"}
+## object.
+##
+## Example:
 ##
 ## @example
 ## @group
 ## theta = 0:0.2:6;
-## stem3 (cos (theta), sin (theta), theta)
+## stem3 (cos (theta), sin (theta), theta);
 ## @end group
 ## @end example
 ##
 ## @noindent
-## plots 31 stems with heights from 0 to 6 lying on a circle.  Color
-## definitions with RGB-triples are not valid!
-## @seealso{stem, bar, barh, plot}
+## plots 31 stems with heights from 0 to 6 lying on a circle.
+##
+## Implementation Note: Color definitions with RGB-triples are not valid.
+## @seealso{stem, bar, hist, plot}
 ## @end deftypefn
 
 function h = stem3 (varargin)
 
-  if (nargin < 1 || nargin > 4)
+  if (nargin < 1)
     print_usage ();
   endif
 
-  tmp = __stem__ (true, varargin{:});
+  htmp = __stem__ (true, varargin{:});
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! theta = 0:0.2:6;
 %! stem3 (cos (theta), sin (theta), theta);
+%! title ('stem3() plot');
 
+%!error stem3 ()
+%!error <must define X, Y, and Z> stem3 (1,2)
+%!error <X, Y, and Z must be numeric> stem3 ({1}, 1, 1)
+%!error <X, Y, and Z must be numeric> stem3 (1, {1}, 1)
+%!error <X, Y, and Z must be numeric> stem3 (1, 1, {1})
+%!error <inconsistent sizes for X, Y, and Z> stem3 (ones (2,2), 1, 1);
+%!error <inconsistent sizes for X, Y, and Z> stem3 (1, ones (2,2), 1);
+%!error <inconsistent sizes for X, Y, and Z> stem3 (1, 1, ones (2,2));
+%!error <No value specified for property "FOO"> stem3 (1, "FOO")
diff --git a/scripts/plot/stemleaf.m b/scripts/plot/draw/stemleaf.m
rename from scripts/plot/stemleaf.m
rename to scripts/plot/draw/stemleaf.m
--- a/scripts/plot/stemleaf.m
+++ b/scripts/plot/draw/stemleaf.m
@@ -190,17 +190,17 @@ function plotstr = stemleaf (x, caption,
   o_fence_l = hl - 2*step;      # outer fences: outside hinges + 2*step
   i_fence_h = hu + step;
   o_fence_h = hu + 2*step;
   n_out_l   = sum (x<i_fence_l) - sum (x<o_fence_l);
   n_out_h   = sum (x>i_fence_h) - sum (x>o_fence_h);
   n_far_l   = sum (x<o_fence_l);
   n_far_h   = sum (x>o_fence_h);
 
-  # display table similar to that on pg. 33
+  ## display table similar to that on pg. 33
   plot_out = sprintf ("       Data: %s", caption);
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("         Fenced Letter Display")];
   plot_out = [plot_out; sprintf(" ")];
   plot_out = [plot_out; sprintf("     #%3d|___________________", nx)];
   plot_out = [plot_out; sprintf("     M%3d|       %5d      |", mdidx, md)];
   plot_out = [plot_out; sprintf("     H%3d|%5d        %5d|   %d", hlidx, hl, hu, h_spread)];
   plot_out = [plot_out; sprintf("     1   |%5d        %5d|", xs(1), xs(nx))];
@@ -327,26 +327,26 @@ endfunction
 %!      34 133 45 120 30 127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20  ...
 %!      0];
 %! y = sort (x);
 %! stemleaf (y, 'Sorted leaves (large dataset)');
 
 %!demo
 %! %% Gaussian leaves:
 %! x = fix (30 * randn (300,1));
-%! stemleaf (x);
+%! stemleaf (x, 'Gaussian leaves');
 
 %!test
 %! ## test minus to plus
-%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127  \
-%!      36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 \
-%!      23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58  \
-%!      114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31  \
-%!      115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57\
-%!      122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 \
+%! x = [-22 12 -28 52  39 -2 12 10 11 11 42 38 44 18 44 37 113 124 37 48 127   ...
+%!      36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109  ...
+%!      23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58   ...
+%!      114 126 53 114 96 25 109 7 31 141 46 -13 71 43 117 116 27 7 68 40 31   ...
+%!      115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 105 57 ...
+%!      122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30  ...
 %!      127 31 116 146 21 23 30 10 20 21 30 0 100 110 1 20 0];
 %! x = sort (x);
 %! rexp = char (
 %! "       Data: test minus to plus"    ,
 %! " "                                  ,
 %! "         Fenced Letter Display"     ,
 %! " "                                  ,
 %! "     #138|___________________"      ,     
diff --git a/scripts/plot/surf.m b/scripts/plot/draw/surf.m
rename from scripts/plot/surf.m
rename to scripts/plot/draw/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/draw/surf.m
@@ -15,75 +15,104 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} surf (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} surf (@var{z})
 ## @deftypefnx {Function File} {} surf (@dots{}, @var{c})
+## @deftypefnx {Function File} {} surf (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} surf (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} surf (@dots{})
-## Plot a surface given matrices @var{x}, and @var{y} from @code{meshgrid} and
-## a matrix @var{z} corresponding to the @var{x} and @var{y} coordinates of
-## the mesh.  If @var{x} and @var{y} are vectors, then a typical vertex
-## is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z}
-## correspond to different @var{x} values and rows of @var{z} correspond
-## to different @var{y} values.
+## Plot a 3-D surface mesh.
+##
+## The surface mesh is plotted using shaded rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
 ##
-## The color of the surface is derived from the @code{colormap} and
-## the value of @var{z}.  Optionally the color of the surface can be
-## specified independent of @var{z}, by adding a fourth matrix, @var{c}.
+## The color of the surface is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally, the color of the surface can be specified independently of
+## @var{z} by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
-## @seealso{colormap, contour, meshgrid, mesh}
+##
+## Note: The exact appearance of the surface can be controlled with the
+## @code{shading} command or by using @code{set} to control surface object
+## properties.
+## @seealso{ezsurf, surfc, surfl, surfnorm, trisurf, contour, mesh, surface, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = surf (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("surf", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
   unwind_protect
-    axes (h);
-    newplot ();
-    tmp = surface (varargin{:});
+    hax = newplot (hax);
+    
+    htmp = surface (varargin{:});
 
-    if (! ishold ())
-      set (h, "view", [-37.5, 30],
-           "xgrid", "on", "ygrid", "on", "zgrid", "on");
+    if (! ishold (hax))
+      set (hax, "view", [-37.5, 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
+
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = tmp;
+    retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = peaks ();
+%! Z = peaks ();
 %! surf (Z);
+%! title ({'surf() plot of peaks() function'; 'color determined by height Z'});
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = sombrero ();
+%! Z = sombrero ();
 %! [Fx,Fy] = gradient (Z);
 %! surf (Z, Fx+Fy);
 %! shading interp;
+%! title ({'surf() plot of peaks() function'; ...
+%!         'facecolor is interpolated, color determined by gradient of Z'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [X,Y,Z] = sombrero ();
 %! [~,Fy] = gradient (Z);
 %! surf (X, Y, Z, Fy);
 %! shading interp;
+%! title ({'surf() plot of peaks() function'; ...
+%!         'facecolor is interpolated, color determined by Y-gradient of Z'});
 
diff --git a/scripts/plot/surface.m b/scripts/plot/draw/surface.m
rename from scripts/plot/surface.m
rename to scripts/plot/draw/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/draw/surface.m
@@ -16,78 +16,87 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} surface (@var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} surface (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} surface (@var{z}, @var{c})
 ## @deftypefnx {Function File} {} surface (@var{z})
-## @deftypefnx {Function File} {} surface (@dots{}, @var{prop}, @var{val})
-## @deftypefnx {Function File} {} surface (@var{h}, @dots{})
+## @deftypefnx {Function File} {} surface (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} surface (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} surface (@dots{})
-## Plot a surface graphic object given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the surface.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
-## columns of @var{z} correspond to different @var{x} values and rows of
-## @var{z} correspond to different @var{y} values.  If @var{x} and @var{y}
-## are missing, they are constructed from size of the matrix @var{z}.
+## Create a surface graphic object given matrices @var{x} and @var{y} from
+## @code{meshgrid} and a matrix of values @var{z} corresponding to the
+## @var{x} and @var{y} coordinates of the surface.
 ##
-## Any additional properties passed are assigned to the surface.
+## If @var{x} and @var{y} are vectors, then a typical vertex is
+## (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns of @var{z} correspond
+## to different @var{x} values and rows of @var{z} correspond to different
+## @var{y} values.  If only a single input @var{z} is given then @var{x} is
+## taken to be @code{1:rows (@var{z})} and @var{y} is
+## @code{1:columns (@var{z})}.
+##
+## Any property/value input pairs are assigned to the surface object.
 ## 
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = surface (varargin)
+function h = surface (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("surface", varargin{:});
 
-  oldh = gca ();
-  unwind_protect
-    axes (h);
-    [tmp, bad_usage] = __surface__ (h, varargin{:});
-  unwind_protect_cleanup
-    axes (oldh);
-  end_unwind_protect
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
+  [htmp, bad_usage] = __surface__ (hax, varargin{:});
 
   if (bad_usage)
     print_usage ();
   endif
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 function [h, bad_usage] = __surface__ (ax, varargin)
 
+  h = 0;
   bad_usage = false;
-  h = 0;
   firststring = nargin;
-  for i = 2 : nargin
-    if (ischar (varargin{i - 1}))
-      firststring = i - 1;
+  for i = 1 : (nargin - 1)
+    if (ischar (varargin{i}))
+      firststring = i;
       break;
     endif
   endfor
 
   if (firststring > 5)
     bad_usage = true;
+    return;
   elseif (firststring == 5)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     c = varargin{4};
 
+    if (iscomplex (x) || iscomplex (y) || iscomplex (z) || iscomplex (c))
+      error ("mesh: X, Y, Z, C arguments must be real");
+    endif
+
     [z_nr, z_nc] = size (z);
     [c_nr, c_nc, c_np] = size (c);
     if (! (z_nr == c_nr && z_nc == c_nc && (c_np == 1 || c_np == 3)))
       error ("surface: Z and C must have the same size");
     endif
 
     if (isvector (x) && isvector (y) && ismatrix (z))
       if (rows (z) == length (y) && columns (z) == length (x))
@@ -103,16 +112,21 @@ function [h, bad_usage] = __surface__ (a
     else
       error ("surface: X and Y must be vectors and Z must be a matrix");
     endif
   elseif (firststring == 4)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     c = z;
+
+    if (iscomplex (x) || iscomplex (y) || iscomplex (z))
+      error ("mesh: X, Y, Z arguments must be real");
+    endif
+
     if (isvector (x) && isvector (y) && ismatrix (z))
       if (rows (z) == length (y) && columns (z) == length (x))
         x = x(:)';
         y = y(:);
       else
         error ("surface: rows (Z) must be the same as length (Y) and columns (Z) must be the same as length (X)");
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
@@ -120,53 +134,62 @@ function [h, bad_usage] = __surface__ (a
         error ("surface: X, Y, and Z must have the same dimensions");
       endif
     else
       error ("surface: X and Y must be vectors and Z must be a matrix");
     endif
   elseif (firststring == 3)
     z = varargin{1};
     c = varargin{2};
+
+    if (iscomplex (z) || iscomplex (c))
+      error ("mesh: X, C arguments must be real");
+    endif
+
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: Z argument must be a matrix");
     endif
   elseif (firststring == 2)
     z = varargin{1};
     c = z;
+
+    if (iscomplex (z))
+      error ("mesh: Z argument must be real");
+    endif
+
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: Z argument must be a matrix");
     endif
   elseif (firststring == 1)
     x = 1:3;
-    y = (x).';
+    y = x';
     c = z = eye (3);
   else
     bad_usage = true;
+    return;
   endif
 
-  if (! bad_usage)
-    ## Make a default surface object.
-    other_args = {};
-    if (firststring < nargin)
-      other_args = varargin(firststring:end);
-    endif
-    h = __go_surface__ (ax, "xdata", x, "ydata", y, "zdata", z, "cdata", c,
-                        other_args{:});
+  if (firststring < nargin)
+    other_args = varargin(firststring:end);
+  else
+    other_args = {};  # make a default surface object.
+  endif
+  h = __go_surface__ (ax, "xdata", x, "ydata", y, "zdata", z, "cdata", c,
+                      other_args{:});
 
-    if (! ishold ())
-      set (ax, "view", [0, 90], "box", "off");
-    endif
+  if (! ishold ())
+    set (ax, "view", [0, 90], "box", "off");
   endif
 
 endfunction
 
 
 ## Functional tests for surface() are in surf.m, surfc.m, surfl.m, and pcolor.m
 %!test
 %! hf = figure ("visible", "off");
diff --git a/scripts/plot/surfc.m b/scripts/plot/draw/surfc.m
rename from scripts/plot/surfc.m
rename to scripts/plot/draw/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/draw/surfc.m
@@ -12,88 +12,131 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} surfc (@var{x}, @var{y}, @var{z})
-## Plot a surface and contour given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
-## columns of @var{z} correspond to different @var{x} values and rows of
-## @var{z} correspond to different @var{y} values.
-## @seealso{meshgrid, surf, contour}
+## @deftypefn  {Function File} {} surfc (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} surfc (@var{z})
+## @deftypefnx {Function File} {} surfc (@dots{}, @var{c})
+## @deftypefnx {Function File} {} surfc (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} surfc (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} surfc (@dots{})
+## Plot a 3-D surface mesh with underlying contour lines.
+##
+## The surface mesh is plotted using shaded rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
+##
+## The color of the surface is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally, the color of the surface can be specified independently of
+## @var{z} by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
+##
+## Note: The exact appearance of the surface can be controlled with the
+## @code{shading} command or by using @code{set} to control surface object
+## properties.
+## @seealso{ezsurfc, surf, surfl, surfnorm, trisurf, contour, mesh, surface, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
 function h = surfc (varargin)
 
-  newplot ();
-
-  tmp = surface (varargin{:});
-
-  ax = get (tmp, "parent");
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("surfc", varargin{:});
 
-  set (tmp, "facecolor", "flat");
-
-  if (! ishold ())
-    set (ax, "view", [-37.5, 30],
-         "xgrid", "on", "ygrid", "on", "zgrid", "on");
+  if (nargin < 1)
+    print_usage ();
   endif
 
-  drawnow ();
-  zmin = get (ax, "zlim")(1);
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
+    
+    htmp = surface (varargin{:});
 
-  # don't pass axis handle and/or string arguments to __contour__()
-  stop_idx = nargin;
-  for i = 2 : nargin
-    if (ischar (varargin{i}))
-      stop_idx = i - 1;
-      break;
+    set (htmp, "facecolor", "flat");
+    if (! ishold ())
+      set (hax, "view", [-37.5, 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on",
+                "xlimmode", "manual", "ylimmode", "manual");
     endif
-  endfor
+
+    drawnow ();
 
-  start_idx = 1;
-  if (ishandle (varargin{1}))
-    start_idx = 2;
-  endif
+    ## don't pass string arguments to __contour__()
+    stop_idx = find (cellfun ("isclass", varargin, "char"), 1);
+    if (isempty (stop_idx))
+      stop_idx = nargin;
+    else
+      stop_idx--;
+    endif
 
-  if (stop_idx - start_idx == 1 || stop_idx - start_idx == 3)
-    #don't pass a color matrix c to __contour__
-    stop_idx -= 1;
-  endif
+    if (stop_idx - 1 == 1 || stop_idx - 1 == 3)
+      ## Don't pass a color matrix c to __contour__
+      stop_idx -= 1;
+    endif
+
+    zmin = get (hax, "zlim")(1);
+    [~, htmp2] = __contour__ (hax, zmin, varargin{1:stop_idx});
 
-  [c, tmp2] = __contour__ (ax, zmin, varargin{start_idx:stop_idx});
+    htmp = [htmp; htmp2];
 
-  tmp = [tmp; tmp2];
+  unwind_protect_cleanup
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
+  end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = peaks ();
+%! Z = peaks ();
 %! surfc (Z);
+%! title ('surfc() combines surf/contour plots');
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = sombrero ();
+%! Z = sombrero ();
 %! [Fx,Fy] = gradient (Z);
 %! surfc (Z, Fx+Fy);
 %! shading interp;
+%! title ({'surfc() plot of sombrero() function'; ...
+%!         'facecolor is interpolated, color determined by gradient of Z'});
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [X,Y,Z] = sombrero ();
 %! [~,Fy] = gradient (Z);
 %! surfc (X,Y,Z,Fy);
 %! shading interp;
+%! title ({'surfc() plot of peaks() function'; ...
+%!         'facecolor is interpolated, color determined by Y-gradient of Z'});
 
diff --git a/scripts/plot/surfl.m b/scripts/plot/draw/surfl.m
rename from scripts/plot/surfl.m
rename to scripts/plot/draw/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/draw/surfl.m
@@ -12,176 +12,202 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} surfl (@var{x}, @var{y}, @var{z})
-## @deftypefnx {Function File} {} surfl (@var{z})
-## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z}, @var{L})
-## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z}, @var{L}, @var{P})
+## @deftypefn  {Function File} {} surfl (@var{z})
+## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} surfl (@dots{}, @var{lsrc})
+## @deftypefnx {Function File} {} surfl (@var{x}, @var{y}, @var{z}, @var{lsrc}, @var{P})
+## @deftypefnx {Function File} {} surfl (@dots{}, "cdata")
 ## @deftypefnx {Function File} {} surfl (@dots{}, "light")
-## Plot a lighted surface given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, then
-## a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, columns
-## of @var{z} correspond to different @var{x} values and rows of @var{z}
-## correspond to different @var{y} values.
+## @deftypefnx {Function File} {} surfl (@var{hax}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} surfl (@dots{})
+##
+## Plot a 3-D surface using shading based on various lighting models.
 ##
-## The light direction can be specified using @var{L}.  It can be given as a
-## 2-element vector [azimuth, elevation] in degrees or as a 3-element vector
-## [lx, ly, lz].  The default value is rotated 45 degrees counterclockwise
-## from the current view.
+## The surface mesh is plotted using shaded rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
 ##
-## The material properties of the surface can specified using a 4-element vector
-## @var{P} = [@var{AM} @var{D} @var{SP} @var{exp}] which defaults to
+## The default lighting mode @qcode{"cdata"}, changes the cdata property of the
+## surface object to give the impression of a lighted surface.
+## @strong{Warning:} The alternative mode @qcode{"light"} mode which creates a
+## light object to illuminate the surface is not implemented (yet).
+##
+## The light source location can be specified using @var{lsrc}.  It can be given
+## as a 2-element vector [azimuth, elevation] in degrees, or as a 3-element
+## vector [lx, ly, lz].  The default value is rotated 45 degrees
+## counterclockwise to the current view.
+##
+## The material properties of the surface can specified using a 4-element
+## vector @var{P} = [@var{AM} @var{D} @var{SP} @var{exp}] which defaults to
 ## @var{p} = [0.55 0.6 0.4 10].
 ##
 ## @table @asis
-## @item "AM" strength of ambient light
+## @item @qcode{"AM"} strength of ambient light
 ##
-## @item "D" strength of diffuse reflection
+## @item @qcode{"D"} strength of diffuse reflection
 ##
-## @item "SP" strength of specular reflection
+## @item @qcode{"SP"} strength of specular reflection
 ##
-## @item "EXP" specular exponent
+## @item @qcode{"EXP"} specular exponent
 ## @end table
 ##
-## The default lighting mode "cdata", changes the cdata property to give the
-## impression of a lighted surface.  Please note: the alternative "light"
-## mode, which creates a light object to illuminate the surface is not
-## implemented (yet).
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## surface object.
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## colormap (bone (64));
 ## surfl (peaks);
 ## shading interp;
 ## @end group
 ## @end example
-## @seealso{surf, diffuse, specular, surface}
+## @seealso{diffuse, specular, surf, shading, colormap, caxis}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
-function retval = surfl (varargin)
+function h = surfl (varargin)
 
-  [h, varargin] = __plt_get_axis_arg__ ("surfl", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("surfl", varargin{:});
 
-  oldh = gca ();
-  unwind_protect
-    axes (h);
-    newplot ();
+  if (nargin == 0)
+    print_usage ();
+  endif
 
-    ## Check for lighting type.
-    use_cdata = true;
-    if (ischar (varargin{end}))
-      lstr = tolower (varargin{end});
-      if (strncmp (lstr, "light", 5))
-        warning ("light method not supported (yet), using cdata method instead");
+  ## Check for lighting type.
+  use_cdata = true;
+  if (ischar (varargin{end}))
+    switch (tolower (varargin{end}))
+      case "light"
+        warning ("surfl: light method not supported (yet), using cdata method instead");
         ## This can be implemented when light objects are supported.
         use_cdata = false;
-      elseif (strncmp (lstr, "cdata", 5))
+      case "cdata"
         use_cdata = true;
-      else
+      otherwise
         error ("surfl: unknown lighting method");
-      endif
-      varargin(end) = [];
-    endif
+    endswitch
+    varargin(end) = [];
+  endif
 
-    ## Check for reflection properties argument.
-    ##
-    ## r = [ambient light strength,
-    ##      diffuse reflection strength,
-    ##      specular reflection strength,
-    ##      specular shine]
-    if (length (varargin{end}) == 4 && isnumeric (varargin{end}))
-      r = varargin{end};
+  ## Check for reflection properties argument.
+  ##
+  ## r = [ambient light strength,
+  ##      diffuse reflection strength,
+  ##      specular reflection strength,
+  ##      specular shine]
+  if (isnumeric (varargin{end}) && length (varargin{end}) == 4)
+    r = varargin{end};
+    varargin(end) = [];
+  else
+    ## Default values.
+    r = [0.55, 0.6, 0.4, 10];
+  endif
+
+  ## Check for light vector (lv) argument.
+  have_lv = false;
+  if (isnumeric (varargin{end}))
+    len = numel (varargin{end});
+    lastarg = varargin{end};
+    if (len == 3)
+      lv = lastarg;
       varargin(end) = [];
-    else
-      ## Default values.
-      r = [0.55, 0.6, 0.4, 10];
+      have_lv = true;
+    elseif (len == 2)
+      [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180, 
+                                         lastarg(2) * pi/180,
+                                         1.0);
+      varargin(end) = [];
+      have_lv = true;
     endif
+  endif
 
-    ## Check for light vector (lv) argument.
-    have_lv = false;
-    if (isnumeric (varargin{end}))
-      len = numel (varargin{end});
-      lastarg = varargin{end};
-      if (len == 3)
-        lv = lastarg;
-        varargin(end) = [];
-        have_lv = true;
-      elseif (len == 2)
-        [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180, lastarg(2) * pi/180, 1.0);
-        varargin(end) = [];
-        have_lv = true;
-      endif
-    endif
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  unwind_protect
+    hax = newplot (hax);
 
     htmp = surface (varargin{:});
-    if (! ishold ())
-      set (h, "view", [-37.5, 30],
-           "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
+    if (! ishold (hax))
+      set (hax, "view", [-37.5, 30],
+                "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
     endif
 
     ## Get view vector (vv).
-    a = axis;
-    [az, el] = view;
+    [az, el] = view ();
     vv = sph2cart ((az - 90) * pi/180.0, el * pi/180.0, 1.0);
 
-    if (!have_lv)
+    if (! have_lv)
       ## Calculate light vector (lv) from view vector.
-      Phi = 45.0 / 180.0 * pi;
-      R = [cos(Phi), -sin(Phi), 0;
-           sin(Phi),  cos(Phi), 0;
-           0,          0,         1];
+      phi = pi / 4;  # 45 degrees
+      R = [cos(phi), -sin(phi), 0;
+           sin(phi),  cos(phi), 0;
+           0,         0,        1];
       lv = (R * vv.').';
     endif
 
     vn = get (htmp, "vertexnormals");
-    dar = get (h, "plotboxaspectratio");
+    dar = get (hax, "plotboxaspectratio");
     vn(:,:,1) *= dar(1);
     vn(:,:,2) *= dar(2);
     vn(:,:,3) *= dar(3);
 
     ## Normalize vn.
-    vn = vn ./ repmat (sqrt (sumsq (vn, 3)), [1, 1, 3]);
+    vn ./= repmat (sqrt (sumsq (vn, 3)), [1, 1, 3]);
     [nr, nc] = size (get (htmp, "zdata"));
 
     ## Ambient, diffuse, and specular term.
-    cdata = (r(1) * ones (nr, nc)
+    cdata = (  r(1) * ones (nr, nc)
              + r(2) * diffuse  (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv)
              + r(3) * specular (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv, vv, r(4)));
+    cdata ./= sum (r(1:3));
 
-    set (htmp, "cdata", cdata ./ sum (r(1:3)));
+    set (htmp, "cdata", cdata);
 
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
   if (nargout > 0)
-    retval = htmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! [X,Y,Z] = sombrero ();
 %! colormap (copper (64));
 %! surfl (X,Y,Z);
 %! shading interp;
+%! title ('surfl() with defaults');
 
 %!demo
 %! clf;
 %! [X,Y,Z] = sombrero ();
 %! colormap (copper (64));
 %! [az, el] = view ();
 %! surfl (X,Y,Z, [az+225,el], [0.2 0.6 0.4 25]);
 %! shading interp;
+%! title ('surfl() with lighting vector and material properties');
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/draw/surfnorm.m
rename from scripts/plot/surfnorm.m
rename to scripts/plot/draw/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/draw/surfnorm.m
@@ -48,18 +48,17 @@
 ## @example
 ## surfnorm (peaks (25));
 ## @end example
 ## @seealso{surf, quiver3}
 ## @end deftypefn
 
 function [Nx, Ny, Nz] = surfnorm (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout != 0), "surfnorm",
-                                                varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("surfnorm", varargin{:});
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     z = varargin{1};
     [x, y] = meshgrid (1:rows (z), 1:columns (z));
@@ -110,33 +109,39 @@ function [Nx, Ny, Nz] = surfnorm (vararg
 
   ## Normalize the normal vectors
   len = sqrt (nx.^2 + ny.^2 + nz.^2);
   nx = nx ./ len;
   ny = ny ./ len;
   nz = nz ./ len;
 
   if (nargout == 0)
-    oldh = gca ();
+    oldfig = [];
+    if (! isempty (hax))
+      oldfig = get (0, "currentfigure");
+    endif
     unwind_protect
-      axes (h);
-      newplot ();
+      hax = newplot (hax);
+      
       surf (x, y, z, varargin{ioff:end});
-      old_hold_state = get (h, "nextplot");
+      old_hold_state = get (hax, "nextplot");
       unwind_protect
-        set (h, "nextplot", "add");
+        set (hax, "nextplot", "add");
         plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
                [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
                [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:),
                varargin{ioff:end});
       unwind_protect_cleanup
-        set (h, "nextplot", old_hold_state);
+        set (hax, "nextplot", old_hold_state);
       end_unwind_protect
+      
     unwind_protect_cleanup
-      axes (oldh);
+      if (! isempty (oldfig))
+        set (0, "currentfigure", oldfig);
+      endif
     end_unwind_protect
   else
     Nx = nx;
     Ny = ny;
     Nz = nz;
   endif
 
 endfunction
diff --git a/scripts/plot/tetramesh.m b/scripts/plot/draw/tetramesh.m
rename from scripts/plot/tetramesh.m
rename to scripts/plot/draw/tetramesh.m
--- a/scripts/plot/tetramesh.m
+++ b/scripts/plot/draw/tetramesh.m
@@ -16,95 +16,103 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} tetramesh (@var{T}, @var{X})
 ## @deftypefnx {Function File} {} tetramesh (@var{T}, @var{X}, @var{C})
 ## @deftypefnx {Function File} {} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} tetramesh (@dots{})
+## Display the tetrahedrons defined in the m-by-4 matrix @var{T} as 3-D patches.
 ##
-## Display the tetrahedrons defined in the m-by-4 matrix @var{T}
-## as 3-D patches.  @var{T} is typically the output of a Delaunay triangulation
+## @var{T} is typically the output of a Delaunay triangulation
 ## of a 3-D set of points.  Every row of @var{T} contains four indices into
 ## the n-by-3 matrix @var{X} of the vertices of a tetrahedron.  Every row in
 ## @var{X} represents one point in 3-D space. 
 ##
 ## The vector @var{C} specifies the color of each tetrahedron as an index
 ## into the current colormap.  The default value is 1:m where m is the number
 ## of tetrahedrons; the indices are scaled to map to the full range of the
 ## colormap.  If there are more tetrahedrons than colors in the colormap then
 ## the values in @var{C} are cyclically repeated.
 ## 
 ## Calling @code{tetramesh (@dots{}, "property", "value", @dots{})} passes all
 ## property/value pairs directly to the patch function as additional arguments.
 ##
 ## The optional return value @var{h} is a vector of patch handles where each
 ## handle represents one tetrahedron in the order given by @var{T}. 
-## A typical use case for @var{h} is to turn the respective patch "visible"
-## property "on" or "off".
+## A typical use case for @var{h} is to turn the respective patch
+## @qcode{"visible"} property @qcode{"on"} or @qcode{"off"}.
 ##
 ## Type @code{demo tetramesh} to see examples on using @code{tetramesh}.
-## @seealso{delaunay3, delaunayn, trimesh, patch}
+## @seealso{trimesh, delaunay3, delaunayn, patch}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function h = tetramesh (varargin)
 
   [reg, prop] = parseparams (varargin);
 
   if (length (reg) < 2 || length (reg) > 3)
     print_usage ();
   endif
 
   T = reg{1};
   X = reg{2};
 
   if (! ismatrix (T) || columns (T) != 4)
-    error ("tetramesh: T must be a n-by-4 matrix");
-  endif
-  if (! ismatrix (X) || columns (X) != 3)
-    error ("tetramesh: X must be a n-by-3 matrix");
+    error ("tetramesh: T must be an n-by-4 matrix");
+  elseif (! ismatrix (X) || columns (X) != 3)
+    error ("tetramesh: X must be an n-by-3 matrix");
   endif
 
   size_T = rows (T);
-  colmap = colormap ();
+  cmap = colormap ();
   
   if (length (reg) < 3)
-    size_colmap = rows (colmap);
-    C = mod ((1:size_T)' - 1, size_colmap) + 1;
-    if (size_T < size_colmap && size_T > 1) 
+    size_cmap = rows (cmap);
+    C = mod ((1:size_T)' - 1, size_cmap) + 1;
+    if (size_T < size_cmap && size_T > 1) 
       ## expand to the available range of colors
-      C = floor ((C - 1) * (size_colmap - 1) / (size_T - 1)) + 1;
+      C = floor ((C - 1) * (size_cmap - 1) / (size_T - 1)) + 1;
     endif
   else
     C = reg{3};
     if (! isvector (C) || size_T != length (C))
       error ("tetramesh: C must be a vector of the same length as T");
     endif
   endif
 
-  h = zeros (1, size_T);
+  hax = newplot ();
+
+  hvec = zeros (size_T, 1);
   if (strcmp (graphics_toolkit (), "gnuplot"))
-    ## tiny reduction of the tetrahedron size to help gnuplot by
+    ## Tiny reduction of the tetrahedron size to help gnuplot by
     ## avoiding identical faces with different colors
     for i = 1:size_T
       [th, p] = __shrink__ ([1 2 3 4], X(T(i, :), :), 1 - 1e-7);
       hvec(i) = patch ("Faces", th, "Vertices", p, 
-                       "FaceColor", colmap(C(i), :), prop{:});
+                       "FaceColor", cmap(C(i), :), "FaceAlpha", 0.9,
+                       prop{:});
     endfor
   else
+    ## FLTK does not support FaceAlpha.
     for i = 1:size_T
       th = [1 2 3; 2 3 4; 3 4 1; 4 1 2];
       hvec(i) = patch ("Faces", th, "Vertices", X(T(i, :), :), 
-                       "FaceColor", colmap(C(i), :), prop{:});
+                       "FaceColor", cmap(C(i), :), "FaceAlpha", 1.0,
+                       prop{:});
     endfor
   endif
 
+  if (! ishold ())
+    set (hax, "view", [-37.5, 30], "box", "off");
+  endif
+
   if (nargout > 0)
     h = hvec;
   endif
 
 endfunction
 
 ## shrink the tetrahedron relative to its center of gravity
 function [tri, p] = __shrink__ (T, X, sf)
@@ -124,25 +132,27 @@ endfunction
 %! z = [z(:); 0];
 %! tetra = delaunay3 (x, y, z);
 %! X = [x(:) y(:) z(:)];
 %! colormap (jet (64));
 %! h = tetramesh (tetra, X);
 %! set (h(1:2:end), 'Visible', 'off');
 %! axis equal;
 %! view (30, 20);
-%! title ('Using jet (64), every other tetrahedron invisible');
+%! title ({'tetramesh() plot', ...
+%!         'colormap = jet (64), every other tetrahedron invisible'});
 
 %!demo
 %! clf;
 %! d = [-1 1];
 %! [x,y,z] = meshgrid (d, d, d);
 %! x = [x(:); 0];
 %! y = [y(:); 0];
 %! z = [z(:); 0];
 %! tetra = delaunay3 (x, y, z);
 %! X = [x(:) y(:) z(:)];
 %! colormap (gray (256));
 %! tetramesh (tetra, X, 21:20:241, 'EdgeColor', 'w');
 %! axis equal;
 %! view (30, 20);
-%! title ('Using gray (256) and white edges');
+%! title ({'tetramesh() plot', ...
+%!         'colormap = gray (256) with white edges'});
 
diff --git a/scripts/plot/trimesh.m b/scripts/plot/draw/trimesh.m
rename from scripts/plot/trimesh.m
rename to scripts/plot/draw/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/draw/trimesh.m
@@ -12,58 +12,109 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
+## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z}, @var{c})
+## @deftypefnx {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} trimesh (@var{tri}, @var{x}, @var{y})
+## @deftypefnx {Function File} {} trimesh (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
-## Plot a triangular mesh in 3D@.  The variable @var{tri} is the triangular
-## meshing of the points @code{(@var{x}, @var{y})} which is returned
-## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.
+## Plot a 3-D triangular wireframe mesh.
+## 
+## In contrast to @code{mesh}, which plots a mesh using rectangles,
+## @code{trimesh} plots the mesh using triangles.
 ##
-## The optional return value @var{h} is a graphics handle to the created plot.
-## @seealso{triplot, trisurf, delaunay3}
+## @var{tri} is typically the output of a Delaunay triangulation over the
+## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
+## and contains three indices into [@var{x}, @var{y}] which are the
+## vertices of the triangles in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If no @var{z} input is given then
+## the triangles are plotted as a 2-D figure.
+## 
+## The color of the trimesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally, the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.  If @var{z} has N elements, then
+## @var{c} should be an Nx1 vector for colormap data or an Nx3 matrix for
+## RGB data.
+##
+## Any property/value pairs are passed directly to the underlying patch object.
+##
+## The optional return value @var{h} is a graphics handle to the created patch
+## object.
+## @seealso{mesh, tetramesh, triplot, trisurf, delaunay, patch, hidden}
 ## @end deftypefn
 
 function h = trimesh (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
 
   if (nargin == 3)
-    triplot (tri, x, y);
+    htmp = triplot (tri, x, y);
   elseif (ischar (z))
-    triplot (tri, x, y, z, varargin{:});
+    htmp = triplot (tri, x, y, z, varargin{:});
   else
-    newplot ();
-    handle = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
-                    "FaceColor", "none", "EdgeColor", __next_line_color__ (),
-                    varargin{:});
+    ## Process color argument
+    if (nargin > 4 && isnumeric (varargin{1}))
+      c = varargin{1};
+      varargin(1) = [];
+      if (isvector (c))
+        if (numel (c) != numel (z))
+          error ("trimesh: C must have 'numel (Z)' elements");
+        endif
+        c = c(:);
+      elseif (rows (c) != numel (z) || columns (c) != 3)
+        error ("trimesh: TrueColor C matrix must be 'numel (Z)' rows by 3 columns");
+      endif
+    else
+      c = z(:);
+    endif
+
+    hax = newplot ();
+
+    ## Tag object as "trimesh" so that hidden() can find it.
+    htmp = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
+                  "FaceVertexCdata", c, "EdgeColor", "flat", "FaceColor", "w",
+                  "Tag", "trimesh", varargin{:});
     if (! ishold ())
-      set (gca (), "view", [-37.5, 30],
-           "xgrid", "on", "ygrid", "on", "zgrid", "on");
+      set (hax, "view", [-37.5, 30], "box", "off",
+                "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
-    if (nargout > 0)
-      h = handle;
-    endif
+  endif
+
+  if (nargout > 0)
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
+%! colormap ('default');
 %! old_state = rand ('state');
 %! restore_state = onCleanup (@() rand ('state', old_state));
 %! rand ('state', 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trimesh (tri, x(:), y(:), z(:));
 
+%% Test input validation
+%!error trimesh ()
+%!error trimesh (1)
+%!error trimesh (1,2)
+%!error <C must have 'numel \(Z\)' elements> trimesh (1,2,3,4,[5 6])
+%!error <C must have 'numel \(Z\)' elements> trimesh (1,2,3,4,[5 6]')
+%!error <TrueColor C matrix must> trimesh ([1;1],[2;2],[3;3],[4;4],zeros(3,3))
+%!error <TrueColor C matrix must> trimesh ([1;1],[2;2],[3;3],[4;4],zeros(2,2))
+
diff --git a/scripts/plot/triplot.m b/scripts/plot/draw/triplot.m
rename from scripts/plot/triplot.m
rename to scripts/plot/draw/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/draw/triplot.m
@@ -15,22 +15,28 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} triplot (@var{tri}, @var{x}, @var{y})
 ## @deftypefnx {Function File} {} triplot (@var{tri}, @var{x}, @var{y}, @var{linespec})
 ## @deftypefnx {Function File} {@var{h} =} triplot (@dots{})
-## Plot a triangular mesh in 2D@.  The variable @var{tri} is the triangular
-## meshing of the points @code{(@var{x}, @var{y})} which is returned from
-## @code{delaunay}.  If given, @var{linespec} determines the properties
-## to use for the lines. 
+## Plot a 2-D triangular mesh.
+## 
+## @var{tri} is typically the output of a Delaunay triangulation over the
+## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
+## and contains three indices into [@var{x}, @var{y}] which are the
+## vertices of the triangles in the x-y plane.
 ##
-## The optional return value @var{h} is a graphics handle to the created plot.
+## The linestyle to use for the plot can be defined with the argument
+## @var{linespec} of the same format as the @code{plot} command.
+##
+## The optional return value @var{h} is a graphics handle to the created
+## patch object.
 ## @seealso{plot, trimesh, trisurf, delaunay}
 ## @end deftypefn
 
 function h = triplot (tri, x, y, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
diff --git a/scripts/plot/trisurf.m b/scripts/plot/draw/trisurf.m
rename from scripts/plot/trisurf.m
rename to scripts/plot/draw/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/draw/trisurf.m
@@ -12,89 +12,115 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
+## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z}, @var{c})
+## @deftypefnx {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
+## @deftypefnx {Function File} {} trisurf (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} trisurf (@dots{})
-## Plot a triangular surface in 3D@.  The variable @var{tri} is the triangular
-## meshing of the points @code{(@var{x}, @var{y})} which is returned
-## from @code{delaunay}.  The variable @var{z} is value at the point
-## @code{(@var{x}, @var{y})}.
+## Plot a 3-D triangular surface.
+## 
+## In contrast to @code{surf}, which plots a surface mesh using rectangles,
+## @code{trisurf} plots the mesh using triangles.
 ##
-## The optional return value @var{h} is a graphics handle to the created plot.
-## @seealso{triplot, trimesh, delaunay3}
+## @var{tri} is typically the output of a Delaunay triangulation over the
+## grid of @var{x}, @var{y}.  Every row of @var{tri} represents one triangle
+## and contains three indices into [@var{x}, @var{y}] which are the
+## vertices of the triangles in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.
+## 
+## The color of the trimesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally, the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.  If @var{z} has N elements, then
+## @var{c} should be an Nx1 vector for colormap data or an Nx3 matrix for
+## RGB data.
+##
+## Any property/value pairs are passed directly to the underlying patch object.
+##
+## The optional return value @var{h} is a graphics handle to the created patch
+## object.
+## @seealso{surf, triplot, trimesh, delaunay, patch, shading}
 ## @end deftypefn
 
 function h = trisurf (tri, x, y, z, varargin)
 
-  if (nargin < 3)
+  if (nargin < 4)
     print_usage ();
   endif
 
-  if (nargin == 3)
-    triplot (tri, x, y);
-  elseif (ischar (z))
-    triplot (tri, x, y, z, varargin{:});
-  else
-    if (nargin > 4 && isnumeric (varargin{1}))
-      c = varargin{1};
-      varargin(1) = [];
-    else
-      c = z;
-    endif
-    if (! any (strcmpi (varargin, "FaceColor")))
-      nfc = numel (varargin) + 1;
-      varargin(nfc+(0:1)) = {"FaceColor", "flat"};
-    else
-      nfc = find (any (strcmpi (varargin, "FaceColor")), 1);
+  if (nargin > 4 && isnumeric (varargin{1}))
+    c = varargin{1};
+    varargin(1) = [];
+    if (isvector (c))
+      if (numel (c) != numel (z))
+        error ("trisurf: C must have 'numel (Z)' elements");
+      endif
+      c = c(:);
+    elseif (rows (c) != numel (z) || columns (c) != 3)
+      error ("trisurf: TrueColor C matrix must be 'numel (Z)' rows by 3 columns");
     endif
-    if (! any (strcmpi (varargin, "EdgeColor"))
-        && strcmpi (varargin{nfc+1}, "interp"))
-      varargin(end+(1:2)) = {"EdgeColor", "none"};
-    endif
-    newplot ();
-    handle = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
-                    "FaceVertexCData", reshape (c, numel (c), 1),
-                    varargin{:});
-    if (nargout > 0)
-      h = handle;
-    endif
+  else
+    c = z(:);
+  endif
+  ## FIXME: Is all this extra input parsing necessary?
+  ##        Is it for Matlab compatibility?
+  if (! any (strcmpi (varargin, "FaceColor")))
+    nfc = numel (varargin) + 1;
+    varargin(nfc+(0:1)) = {"FaceColor", "flat"};
+  else
+    nfc = find (any (strcmpi (varargin, "FaceColor")), 1);
+  endif
+  if (! any (strcmpi (varargin, "EdgeColor"))
+      && strcmpi (varargin{nfc+1}, "interp"))
+    varargin(end+(1:2)) = {"EdgeColor", "none"};
+  endif
 
-    if (! ishold ())
-      set (gca (), "view", [-37.5, 30],
-           "xgrid", "on", "ygrid", "on", "zgrid", "on");
-    endif
+  hax = newplot ();
+
+  htmp = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
+                "FaceVertexCData", c, varargin{:});
+
+  if (! ishold ())
+    set (hax, "view", [-37.5, 30], "box", "off",
+              "xgrid", "on", "ygrid", "on", "zgrid", "on");
+  endif
+
+  if (nargout > 0)
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! N = 31;
 %! [x, y] = meshgrid (1:N);
-%! tri = delaunay (x, y);
+%! tri = delaunay (x(:), y(:));
 %! z = peaks (N);
 %! h = trisurf (tri, x, y, z, 'facecolor', 'interp');
 %! axis tight;
 %! zlim auto;
 %! title (sprintf ('facecolor = %s', get (h, 'facecolor')));
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! N = 31;
 %! [x, y] = meshgrid (1:N);
-%! tri = delaunay (x, y);
+%! tri = delaunay (x(:), y(:));
 %! z = peaks (N);
 %! h = trisurf (tri, x, y, z, 'facecolor', 'flat');
 %! axis tight;
 %! zlim auto;
 %! title (sprintf ('facecolor = %s', get (h, 'facecolor')));
 
 %!demo
 %! clf;
@@ -131,8 +157,18 @@ endfunction
 %! clf;
 %! colormap ('default');
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, 'facecolor', 'interp', 'edgecolor', 'k');
 
+%% Test input validation
+%!error trisurf ()
+%!error trisurf (1)
+%!error trisurf (1,2)
+%!error trisurf (1,2,3)
+%!error <C must have 'numel \(Z\)' elements> trisurf (1,2,3,4,[5 6])
+%!error <C must have 'numel \(Z\)' elements> trisurf (1,2,3,4,[5 6]')
+%!error <TrueColor C matrix must> trisurf ([1;1],[2;2],[3;3],[4;4],zeros(3,3))
+%!error <TrueColor C matrix must> trisurf ([1;1],[2;2],[3;3],[4;4],zeros(2,2))
+
diff --git a/scripts/plot/waterfall.m b/scripts/plot/draw/waterfall.m
rename from scripts/plot/waterfall.m
rename to scripts/plot/draw/waterfall.m
--- a/scripts/plot/waterfall.m
+++ b/scripts/plot/draw/waterfall.m
@@ -14,48 +14,86 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} waterfall (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} waterfall (@var{z})
+## @deftypefnx {Function File} {} waterfall (@dots{}, @var{c})
+## @deftypefnx {Function File} {} waterfall (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {} waterfall (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} waterfall (@dots{})
-## Plot a waterfall plot given matrices @var{x}, and @var{y} from
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
-## columns of @var{z} correspond to different @var{x} values and rows of
-## @var{z} correspond to different @var{y} values.
+## Plot a 3-D waterfall plot.
+##
+## A waterfall plot is similar to a @code{meshz} plot except only
+## mesh lines for the rows of @var{z} (x-values) are shown.
+##
+## The wireframe mesh is plotted using rectangles.  The vertices of the
+## rectangles [@var{x}, @var{y}] are typically the output of @code{meshgrid}.
+## over a 2-D rectangular region in the x-y plane.  @var{z} determines the
+## height above the plane of each vertex.  If only a single @var{z} matrix is
+## given, then it is plotted over the meshgrid
+## @code{@var{x} = 1:columns (@var{z}), @var{y} = 1:rows (@var{z})}.
+## Thus, columns of @var{z} correspond to different @var{x} values and rows
+## of @var{z} correspond to different @var{y} values.
+##
+## The color of the mesh is computed by linearly scaling the @var{z} values
+## to fit the range of the current colormap.  Use @code{caxis} and/or
+## change the colormap to control the appearance.
+##
+## Optionally the color of the mesh can be specified independently of @var{z}
+## by supplying a color matrix, @var{c}.
+##
+## Any property/value pairs are passed directly to the underlying surface
+## object.
+##
+## If the first argument @var{hax} is an axes handle, then plot into this axis,
+## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
-## @seealso{meshgrid, meshz, surf}
+##
+## @seealso{meshz, mesh, meshc, contour, surf, surface, ribbon, meshgrid, hidden, shading, colormap, caxis}
 ## @end deftypefn
 
 ## Author: Mike Miller <mtmiller@ieee.org>
 
 function h = waterfall (varargin)
 
-  tmp = meshz (varargin{:});
+  htmp = meshz (varargin{:});
 
-  set (tmp, "meshstyle", "row");
+  set (htmp, "meshstyle", "row");
 
   ## The gnuplot toolkit does nothing with the meshstyle property currently.
-  toolkit = get (ancestor (tmp, "figure"), "__graphics_toolkit__");
+  toolkit = get (ancestor (htmp, "figure"), "__graphics_toolkit__");
   if (strcmp (toolkit, "gnuplot"))
     warning ("waterfall: may not render correctly using toolkit '%s'", toolkit);
   endif
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! [~,~,Z] = peaks ();
+%! Z = peaks ();
 %! waterfall (Z);
+%! title ('waterfall() plot of peaks() function');
 
+%!demo
+%! clf;
+%! colormap ('default');
+%! Z = peaks ();
+%! subplot (1,2,1)
+%!  meshz (Z);
+%!  daspect ([2.5, 2.5, 1]);
+%!  title ('meshz() plot');
+%! subplot (1,2,2)
+%!  waterfall (Z);
+%!  daspect ([2.5, 2.5, 1]);
+%!  title ('waterfall() plot');
+
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -8,17 +8,16 @@ GEN_FCN_FILES += $(plot_GEN_FCN_FILES)
 plot_PRIVATE_FCN_FILES = \
   plot/private/__actual_axis_position__.m \
   plot/private/__add_datasource__.m \
   plot/private/__add_default_menu__.m \
   plot/private/__axes_limits__.m \
   plot/private/__axis_label__.m \
   plot/private/__bar__.m \
   plot/private/__clabel__.m \
-  plot/private/__color_str_rgb__.m \
   plot/private/__contour__.m \
   plot/private/__default_plot_options__.m \
   plot/private/__errcomm__.m \
   plot/private/__errplot__.m \
   plot/private/__ezplot__.m \
   plot/private/__file_filter__.m \
   plot/private/__fltk_file_filter__.m \
   plot/private/__fltk_ginput__.m \
@@ -113,16 +112,17 @@ plot_FCN_FILES = \
   plot/gtext.m \
   plot/guidata.m \
   plot/guihandles.m \
   plot/hdl2struct.m \
   plot/hggroup.m \
   plot/hidden.m \
   plot/hist.m \
   plot/hold.m \
+  plot/isaxes.m \
   plot/isfigure.m \
   plot/ishghandle.m \
   plot/ishold.m \
   plot/isocolors.m \
   plot/isonormals.m \
   plot/isosurface.m \
   plot/isprop.m \
   plot/legend.m \
diff --git a/scripts/plot/private/__color_str_rgb__.m b/scripts/plot/private/__color_str_rgb__.m
deleted file mode 100644
--- a/scripts/plot/private/__color_str_rgb__.m
+++ /dev/null
@@ -1,50 +0,0 @@
-## Copyright (C) 2010-2012 David Bateman
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{rgb} =} __color_str_rgb__ (@var{str})
-## Undocumented internal function.
-## @end deftypefn
-
-function rgb = __color_str_rgb__ (str)
-
-  if (ischar (str))
-    if (strncmpi (str, "black", 5))
-      rgb = [0, 0, 0];
-    elseif (strncmpi (str, "red", 3))
-      rgb = [1, 0, 0];
-    elseif (strncmpi (str, "green", 5))
-      rgb = [0, 1, 0];
-    elseif (strncmpi (str, "blue", 4))
-      rgb = [0, 0, 1];
-
-    elseif (strncmpi (str, "yellow", 6))
-      rgb = [1, 1, 0];
-    elseif (strncmpi (str, "magenta", 7))
-      rgb = [1, 0, 1];
-    elseif (strncmpi (str, "cyan", 4))
-      rgb = [0, 1, 1];
-    elseif (strncmpi (str, "white", 5))
-      rgb = [1, 1, 1];
-    else
-      rgb = [0, 0, 0];
-    endif
-  else
-    error ("__color_str_rgb__: expecting a string argument");
-  endif
-endfunction
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/util/__actual_axis_position__.m
rename from scripts/plot/private/__actual_axis_position__.m
rename to scripts/plot/util/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/util/__actual_axis_position__.m
@@ -25,17 +25,17 @@
 ## Author: Ben Abbott
 
 function pos = __actual_axis_position__ (h)
 
   if (ishandle (h))
     axis_obj = get (h);
   elseif (isstruct (h))
     axis_obj = h;
-    h = axis_obj.__my_handle__;
+    h = axis_obj.__cbar_hax__;
   endif
 
   ## Get figure size in pixels
   orig_fig_units = get (axis_obj.parent, "units");
   orig_fig_position = get (axis_obj.parent, "position");
   unwind_protect
     set (axis_obj.parent, "units", "pixels");
     fig_position = get (axis_obj.parent, "position");
@@ -55,18 +55,18 @@ function pos = __actual_axis_position__ 
 
   if (strcmp (axis_obj.plotboxaspectratiomode, "manual")
       || strcmp (axis_obj.dataaspectratiomode, "manual"))
     ## When using {rltb}margin, Gnuplot does not handle the specified
     ## aspect ratio properly, so handle it here.
     if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
       aspect_ratio_2d = axis_obj.plotboxaspectratio(1:2);
     else
-      ## FIXME -- this works for "axis square", but has not been
-      ##          thoroughly tested for other aspect ratios.
+      ## FIXME: This works for "axis square", but has not been
+      ##        thoroughly tested for other aspect ratios.
       aspect_ratio_2d = [max(axis_obj.plotboxaspectratio(1:2)), ...
                              axis_obj.plotboxaspectratio(3)/sqrt(2)];
     endif
     orig_aspect_ratio_2d = pos_in_pixels(3:4);
     rel_aspect_ratio_2d =  aspect_ratio_2d ./ orig_aspect_ratio_2d;
     rel_aspect_ratio_2d = rel_aspect_ratio_2d ./ max (rel_aspect_ratio_2d);
     if (rel_aspect_ratio_2d(1) < rel_aspect_ratio_2d(2));
       dx = (1.0 - rel_aspect_ratio_2d(1)) * pos_in_pixels(3);
diff --git a/scripts/plot/private/__default_plot_options__.m b/scripts/plot/util/__default_plot_options__.m
rename from scripts/plot/private/__default_plot_options__.m
rename to scripts/plot/util/__default_plot_options__.m
--- a/scripts/plot/private/__default_plot_options__.m
+++ b/scripts/plot/util/__default_plot_options__.m
@@ -27,8 +27,9 @@ function options = __default_plot_option
 
   options.key = "";
   options.color = [];
   options.linestyle = [];
   options.marker = [];
   options.errorstyle = [];
 
 endfunction
+
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
rename from scripts/plot/__gnuplot_drawnow__.m
rename to scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -204,33 +204,33 @@ function enhanced = gnuplot_set_term (pl
           endif
           switch (term)
             case terminals_with_size
               size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
             case "tikz"
               size_str = sprintf ("size %gin,%gin", gnuplot_size);
             case "dumb"
               new_stream = 1;
-              if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
+              if (!isempty (getenv ("COLUMNS")) && !isempty (getenv ("LINES")))
                 ## Let dumb use full text screen size (minus prompt lines).
                 n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
                 ## n = the number of times \n appears in PS1
-                size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
+                size_str = ["size " getenv("COLUMNS") "," getenv("LINES") n];
               else
                 ## Use the gnuplot default.
                 size_str = "";
               endif
             case {"aqua", "fig", "corel"}
               size_str = sprintf ("size %g %g", gnuplot_size);
             case "dxf"
               size_str = "";
             otherwise
               size_str = "";
           endswitch
-          if ((strncmpi (term, "x11", 3)
+          if ((strcmp (term, "x11")
                && __gnuplot_has_feature__ ("x11_figure_position"))
               || (strcmpi (term, "windows")
                   && __gnuplot_has_feature__ ("windows_figure_position")))
             ## X11/Windows allows the window to be positioned as well.
             units = get (0, "units");
             unwind_protect
               set (0, "units", "pixels");
               screen_size = get (0, "screensize")(3:4);
@@ -291,23 +291,23 @@ function enhanced = gnuplot_set_term (pl
         ## size_str comes after other options to permit specification of
         ## the canvas size for terminals cdr/corel.
         term_str = [term_str " " size_str];
       endif
     endif
     if (! __gnuplot_has_feature__ ("has_termoption_dashed"))
       ## If "set termoption dashed" isn't available add "dashed" option
       ## to the "set terminal ..." command, if it is supported.
-      if (any (strcmp (term, {"aqua", "cgm", "eepic", "emf", "epslatex", \
-                              "fig", "pcl5", "mp", "next", "openstep", "pdf", \
-                              "pdfcairo", "pngcairo", "postscript", \
+      if (any (strcmp (term, {"aqua", "cgm", "eepic", "emf", "epslatex", ...
+                              "fig", "pcl5", "mp", "next", "openstep", "pdf", ...
+                              "pdfcairo", "pngcairo", "postscript", ...
                               "pslatex", "pstext", "svg", "tgif", "x11"})))
         term_str = [term_str " dashed"];
       endif
-    end
+    endif
     if (any (strcmp (term, {"aqua", "wxt"})))
       term_str = [term_str, " ", "dashlength 1"];
     elseif (any (strcmp (term, {"epslatex", "postscript", "pslatex"})))
       term_str = [term_str, " ", "dashlength 2"];
     endif
 
     ## Work around the gnuplot feature of growing the x11 window and
     ## flickering window (x11, windows, & wxt) when the mouse and
diff --git a/scripts/plot/private/__next_line_color__.m b/scripts/plot/util/__next_line_color__.m
rename from scripts/plot/private/__next_line_color__.m
rename to scripts/plot/util/__next_line_color__.m
--- a/scripts/plot/private/__next_line_color__.m
+++ b/scripts/plot/util/__next_line_color__.m
@@ -1,8 +1,9 @@
+## Copyright (C) 2013 Carl Osterwisch
 ## Copyright (C) 2007-2012 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
@@ -18,37 +19,36 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{rgb} =} __next_line_color__ (@var{reset})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Return the next line color in the rotation.
 
+## Author: Carl Osterwisch
 ## Author: jwe
 
 function rgb = __next_line_color__ (reset)
 
-  persistent color_rotation;
-  persistent num_colors;
-  persistent color_index;
+  persistent reset_colors = true;
 
-  if (nargin < 2)
-    if (nargin == 1)
-      if (reset || isempty (color_rotation))
-        color_rotation = get (gca (), "colororder");
-        num_colors = rows (color_rotation);
-        color_index = 1;
-      endif
-    elseif (! isempty (color_rotation))
-      rgb = color_rotation(color_index,:);
-      if (++color_index > num_colors)
-        color_index = 1;
-        __next_line_style__ ("incr");
-      endif
+  if (nargin == 1)
+    ## Indicates whether the next call will increment or not
+    reset_colors = reset;
+  else
+    ## Find and return the next line color
+    ca = gca ();
+    colororder = get (ca, "colororder");
+    if (reset_colors)
+      color_index = 1;
+      reset_colors = false;
     else
-      error ("__next_line_color__: color_rotation not initialized");
+      ## Executed when "hold all" is active
+      n_kids = length (get (ca, "children"));
+      n_colors = rows (colororder);
+      color_index = mod (n_kids, n_colors) + 1;
     endif
-  else
-    print_usage ();
+    rgb = colororder(color_index,:);
   endif
 
 endfunction
+
diff --git a/scripts/plot/private/__next_line_style__.m b/scripts/plot/util/__next_line_style__.m
rename from scripts/plot/private/__next_line_style__.m
rename to scripts/plot/util/__next_line_style__.m
--- a/scripts/plot/private/__next_line_style__.m
+++ b/scripts/plot/util/__next_line_style__.m
@@ -21,41 +21,38 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Return the next line style in the rotation.
 
 
 function [linestyle, marker] = __next_line_style__ (reset)
 
-  persistent style_rotation;
-  persistent num_styles;
-  persistent style_index;
+  persistent reset_style = true;
 
-  if (nargin < 2)
-    if (nargin == 1)
-      if (ischar (reset) && strncmp (reset, "incr", 4))
-        if (isempty (style_rotation))
-          error ("__next_line_style__: style_rotation not initialized");
-        elseif (++style_index > num_styles)
-          style_index = 1;
-        endif
-      elseif (reset || isempty (style_rotation))
-        style_rotation = get (gca (), "linestyleorder");
-        if (ischar (style_rotation))
-          style_rotation = ostrsplit (style_rotation, "|");
-        endif
-        num_styles = length (style_rotation);
-        style_index = 1;
-      endif
-    elseif (! isempty (style_rotation))
-      options = __pltopt__ ("__next_line_style__",
-                            style_rotation (style_index));
-      linestyle = options.linestyle;
-      marker = options.marker;
+  if (nargin == 1)
+    ## Indicates whether the next call will increment or not
+    reset_style = reset;
+  else
+    ## Find and return the next line style
+    ca = gca ();
+    style_rotation = get (ca, "linestyleorder");
+    if (ischar (style_rotation))
+      style_rotation = strsplit (style_rotation, "|");
+    endif
+    nStyles = length (style_rotation);
+    if (reset_style || (nStyles < 2))
+      style_index = 1;
+      reset_style = false;
     else
-      error ("__next_line_style__: style_rotation not initialized");
+      ## Executed when "hold all" is active
+      nChildren = length (get (ca, "Children"));
+      nColors = rows (get (ca, "ColorOrder"));
+      style_index = mod (floor (nChildren/nColors), nStyles) + 1;
     endif
-  else
-    print_usage ();
+    options = __pltopt__ ("__next_line_style__",
+                          style_rotation(style_index));
+    linestyle = options.linestyle;
+    marker = options.marker;
   endif
 
 endfunction
+
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/util/__plt_get_axis_arg__.m
rename from scripts/plot/__plt_get_axis_arg__.m
rename to scripts/plot/util/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/util/__plt_get_axis_arg__.m
@@ -20,62 +20,46 @@
 ## @deftypefn {Function File} {[@var{h}, @var{varargin}, @var{narg}] =} __plt_get_axis_arg__ (@var{caller}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function [h, varargin, narg] = __plt_get_axis_arg__ (caller, varargin)
 
-  if (islogical (caller))
-    nogca = caller;
-    caller = varargin{1};
-    varargin(1) = [];
-  else
-    nogca = false;
-  endif
+  h = [];
+  parent = find (strcmpi (varargin, "parent"), 1);
+  
 
-  ## Figure handles are integers, but object handles are non-integer,
-  ## therefore ignore integer scalars.
-  if (nargin > 1 && length (varargin) > 0 && isnumeric (varargin{1})
-      && numel (varargin{1}) == 1 && ishandle (varargin{1}(1))
-      && varargin{1}(1) != 0 && ! isfigure (varargin{1}(1)))
-    tmp = varargin{1};
-    obj = get (tmp);
-    if ((strcmp (obj.type, "axes") && ! strcmp (obj.tag, "legend"))
-        || strcmp (obj.type, "hggroup"))
-      h = ancestor (tmp, "axes");
+  ## Look for a scalar which is a graphics handle but not the
+  ## Root Figure (0) or an ordinary figure (integer).
+  if (numel (varargin) > 0 && numel (varargin{1}) == 1
+      && ishandle (varargin{1}) && varargin{1} != 0 && ! isfigure (varargin{1}))
+    htmp = varargin{1};
+    if (! isaxes (htmp))
+      error ("%s: expecting first argument to be axes handle", caller);
+    endif
+    if (! strcmp (get (htmp, "tag"), "legend"))
+      h = htmp;
       varargin(1) = [];
-      if (isempty (varargin))
-        varargin = {};
+    endif
+  ## Look for "parent"/axis prop/value pair
+  elseif (numel (varargin) > 1 && ! isempty (parent))
+    if (parent < numel (varargin) && ishandle (varargin{parent+1}))
+      htmp = varargin{parent+1};
+      if (isaxes (htmp) && ! strcmp (get (htmp, "tag"), "legend"))
+        h = htmp;
+        varargin(parent:parent+1) = [];
+      else
+        ## 'parent' property for some other type like hggroup
+        h = ancestor (htmp, "axes");
       endif
     else
-      error ("%s: expecting first argument to be axes handle", caller);
-    endif
-  else
-    f = get (0, "currentfigure");
-    if (isempty (f))
-      h = [];
-    else
-      h = get (f, "currentaxes");
+      error ("%s: expecting parent value to be axes handle", caller);
     endif
-    if (isempty (h))
-      if (nogca)
-        h = NaN;
-      else
-        h = gca ();
-      endif
-    endif
-    if (nargin < 2)
-      varargin = {};
-    endif
-  endif
-
-  if (ishandle (h) && strcmp (get (h, "nextplot"), "new"))
-    h = axes ();
   endif
 
   narg = length (varargin);
 
 endfunction
 
 
 ## No test needed for internal helper function.
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/util/__pltopt__.m
rename from scripts/plot/private/__pltopt__.m
rename to scripts/plot/util/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/util/__pltopt__.m
@@ -84,73 +84,54 @@
 ## style.
 ## @end table
 ##
 ## The legend may be fixed to include the name of the variable
 ## plotted in some future version of Octave.
 
 ## Author: jwe
 
-function [options, valid] = __pltopt__ (caller, opt, err_on_invalid)
+function [options, valid] = __pltopt__ (caller, opt, err_on_invalid = true)
 
+  options = __default_plot_options__ ();
   valid = true;
-  options =  __default_plot_options__ ();
+
+  if (ischar (opt))
+    opt = cellstr (opt);
+  elseif (! iscellstr (opt))
+    error ("__pltopt__: argument must be a character string or cell array of character strings");
+  endif
 
-  if ((nargin == 2 || nargin == 3) && (nargout == 1 || nargout == 2))
-    if (nargin == 2)
-      err_on_invalid = true;
+  nel = numel (opt);
+
+  for i = nel:-1:1
+    [options(i), valid] = __pltopt1__ (caller, opt{i}, err_on_invalid);
+    if (! err_on_invalid && ! valid)
+      return;
     endif
-    if (ischar (opt))
-      nel = rows (opt);
-    elseif (iscellstr (opt))
-      nel = numel (opt);
-    else
-      error ("__pltopt__: expecting argument to be character string or cell array of character strings");
-    endif
-    if (ischar (opt))
-      opt = cellstr (opt);
-    endif
-    for i = nel:-1:1
-      [options(i), valid] = __pltopt1__ (caller, opt{i}, err_on_invalid);
-      if (! err_on_invalid && ! valid)
-        return;
-      endif
-    endfor
-  else
-    print_usage ();
-  endif
+  endfor
 
 endfunction
 
 ## Really decode plot option strings.
 
 ## Author: Rick Niles <niles@axp745.gsfc.nasa.gov>
 ## Adapted-By: jwe
 ## Maintainer: jwe
 
 function [options, valid] = __pltopt1__ (caller, opt, err_on_invalid)
 
   options = __default_plot_options__ ();
   valid = true;
 
-  more_opts = 1;
-
-  if (nargin != 2 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! ischar (opt))
-    return;
-  endif
-
   have_linestyle = false;
   have_marker = false;
 
   ## If called by __errplot__, extract the linestyle before proceeding.
-  if (strcmp (caller,"__errplot__"))
+  if (strcmp (caller, "__errplot__"))
     if (strncmp (opt, "#~>", 3))
       n = 3;
     elseif (strncmp (opt, "#~", 2) || strncmp (opt, "~>", 2))
       n = 2;
     elseif (strncmp (opt, "~", 1) || strncmp (opt, ">", 1)
             || strncmp (opt, "#", 1))
       n = 1;
     else
@@ -174,22 +155,34 @@ function [options, valid] = __pltopt1__ 
         have_linestyle = true;
         options.linestyle = topt;
       elseif (topt == "+" || topt == "o" || topt == "*"
               || topt == "." || topt == "x" || topt == "s"
               || topt == "d" || topt == "^" || topt == "v"
               || topt == ">" || topt == "<" || topt == "p"
               || topt == "h" || topt == "@")
         have_marker = true;
+        ## Check for long form marker styles
+        if (any (topt == "sdhp"))
+          if (strncmp (opt, "square", 6))
+            n = 6;
+          elseif (strncmp (opt, "diamond", 7))
+            n = 7;
+          elseif (strncmp (opt, "hexagram", 8))
+            n = 8;
+          elseif (strncmp (opt, "pentagram", 9))
+            n = 9;
+          endif
+        endif
         ## Backward compatibility.  Leave undocumented.
         if (topt == "@")
           topt = "+";
         endif
         options.marker = topt;
-### Numeric color specs for backward compatibility.  Leave undocumented.
+      ## Numeric color specs are for backward compatibility.  Don't document.
       elseif (topt == "k" || topt == "0")
         options.color = [0, 0, 0];
       elseif (topt == "r" || topt == "1")
         options.color = [1, 0, 0];
       elseif (topt == "g" || topt == "2")
         options.color = [0, 1, 0];
       elseif (topt == "b" || topt == "3")
         options.color = [0, 0, 1];
@@ -234,8 +227,9 @@ function [options, valid] = __pltopt1__ 
     options.linestyle = "none";
   endif
 
   if (have_linestyle && ! have_marker)
     options.marker = "none";
   endif
 
 endfunction
+
diff --git a/scripts/plot/allchild.m b/scripts/plot/util/allchild.m
rename from scripts/plot/allchild.m
rename to scripts/plot/util/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/util/allchild.m
@@ -15,43 +15,50 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} allchild (@var{handles})
 ## Find all children, including hidden children, of a graphics object.
 ##
-## This function is similar to @code{get (h, "children")}, but also
-## returns hidden objects.  If @var{handles} is a scalar,
-## @var{h} will be a vector.  Otherwise, @var{h} will be a cell matrix
-## of the same size as @var{handles} and each cell will contain a
+## This function is similar to @code{get (h, "children")}, but also returns
+## hidden objects (HandleVisibility = @qcode{"off"}).  If @var{handles} is a
+## scalar, @var{h} will be a vector.  Otherwise, @var{h} will be a cell
+## matrix of the same size as @var{handles} and each cell will contain a
 ## vector of handles.
-## @seealso{get, set, findall, findobj}
+## @seealso{findall, findobj, get, set}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function h = allchild (handles)
 
+  if (nargin != 1)
+    print_usage ();
+  endif
+
   shh = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "on");
     h = get (handles, "children");
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 
 %!testif HAVE_FLTK
-%! toolkit = graphics_toolkit ();
-%! graphics_toolkit ("fltk");
+%! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
-%!   assert (get (allchild (hf),"type"),{"axes"; "uimenu"; "uimenu"; "uimenu"});
+%!   kids = allchild (hf);
+%!   assert (get (kids, "type"), {"axes"; "uimenu"; "uimenu"; "uimenu"});
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
+%!error allchild ()
+%!error allchild (1, 2)
+
diff --git a/scripts/plot/ancestor.m b/scripts/plot/util/ancestor.m
rename from scripts/plot/ancestor.m
rename to scripts/plot/util/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/util/ancestor.m
@@ -19,70 +19,98 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{parent} =} ancestor (@var{h}, @var{type})
 ## @deftypefnx {Function File} {@var{parent} =} ancestor (@var{h}, @var{type}, "toplevel")
 ## Return the first ancestor of handle object @var{h} whose type matches
 ## @var{type}, where @var{type} is a character string.  If @var{type} is a
 ## cell array of strings, return the first parent whose type matches
 ## any of the given type strings.
 ##
-## If the handle object @var{h} is of type @var{type}, return @var{h}.
+## If the handle object @var{h} itself is of type @var{type}, return @var{h}.
 ##
-## If @code{"toplevel"} is given as a 3rd argument, return the highest
+## If @qcode{"toplevel"} is given as a third argument, return the highest
 ## parent in the object hierarchy that matches the condition, instead
 ## of the first (nearest) one.
-## @seealso{get, set}
+## @seealso{findobj, findall, allchild}
 ## @end deftypefn
 
 function p = ancestor (h, type, toplevel)
 
-  if (nargin == 2 || nargin == 3)
-    p = cell (numel (h), 1);
-    if (ischar (type))
-      type = { type };
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+  endif
+
+  if (ischar (type))
+    type = { type };
+  elseif (! iscellstr (type))
+    error ("ancestor: TYPE must be a string or cell array of strings");
+  endif
+
+  find_first = true;
+  if (nargin == 3)
+    if (ischar (toplevel) && strcmpi (toplevel, "toplevel"))
+      find_first = false;
+    else
+      error ('ancestor: third argument must be "toplevel"');
     endif
-    if (iscellstr (type))
-      look_first = true;
-      if (nargin == 3)
-        if (ischar (toplevel) && strcmpi (toplevel, "toplevel"))
-          look_first = false;
-        else
-          error ("ancestor: third argument must be \"toplevel\"");
+  endif
+
+  if (isempty (h))
+    p = [];
+  else
+    p = cell (numel (h), 1);
+    h = num2cell (h);
+    for nh = 1:numel (h)
+      while (true)
+        if (isempty (h{nh}) || ! ishandle (h{nh}))
+          break;
         endif
-      endif
-      h = num2cell (h);
-      for nh = 1:numel (h)
-        while (true)
-          if (isempty (h{nh}) || ! ishandle (h{nh}))
+        if (any (strcmpi (get (h{nh}, "type"), type)))
+          p{nh} = h{nh};
+          if (find_first)
             break;
           endif
-          if (any (strcmpi (get (h{nh}, "type"), type)))
-            p{nh} = h{nh};
-            if (look_first)
-              break;
-            endif
-          endif
-          h{nh} = get (h{nh}, "Parent");
-        endwhile
-      endfor
-      if (nh == 1)
-        p = p{1};
-      endif
-    else
-      error ("ancestor: second argument must be a string or cell array of strings");
+        endif
+        h{nh} = get (h{nh}, "parent");
+      endwhile
+    endfor
+    if (nh == 1)
+      p = p{1};
     endif
-  else
-    print_usage ();
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   l = line;
-%!   assert (ancestor (l, "axes"), gca);
-%!   assert (ancestor (l, "figure"), hf);
+%!   hl = line;
+%!   assert (ancestor (hl, "axes"), gca);
+%!   assert (ancestor (hl, "figure"), hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!    hg1 = hggroup ("parent", gca);
+%!    hg2 = hggroup ("parent", hg1);
+%!    hl = line ("parent", hg2);
+%!    assert (ancestor (hl, "line"), hl);
+%!    assert (ancestor (hl, "axes"), gca);
+%!    assert (ancestor (hl, "figure"), hf);
+%!    assert (ancestor (hl, "hggroup"), hg2);
+%!    assert (ancestor (hl, "hggroup", "toplevel"), hg1);
+%!    assert (ancestor (hl, {"hggroup", "axes"}), hg2);
+%!    assert (ancestor (hl, {"hggroup", "axes"}, "toplevel"), gca);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!assert (ancestor ([], "axes"), [])
+
+%!error ancestor ()
+%!error ancestor (1,2,3)
+%!error <TYPE must be a string> ancestor (1,2)
+%!error <third argument must be "toplevel"> ancestor (1, "axes", "foo")
+
diff --git a/scripts/plot/axes.m b/scripts/plot/util/axes.m
rename from scripts/plot/axes.m
rename to scripts/plot/util/axes.m
--- a/scripts/plot/axes.m
+++ b/scripts/plot/util/axes.m
@@ -14,49 +14,69 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} axes ()
 ## @deftypefnx {Function File} {} axes (@var{property}, @var{value}, @dots{})
-## @deftypefnx {Function File} {} axes (@var{h})
-## Create an axes object and return a handle to it.
+## @deftypefnx {Function File} {} axes (@var{hax})
+## @deftypefnx {Function File} {@var{h} =} axes (@dots{})
+## Create an axes object and return a handle to it, or set the current
+## axes to @var{hax}.
+##
+## Called without any arguments, or with @var{property}/@var{value} pairs,
+## construct a new axes.  For accepted properties and corresponding
+## values, @pxref{XREFset,,set}.
+##
+## Called with a single axes handle argument @var{hax}, the function makes
+## @var{hax} the current axis.  It also restacks the axes in the
+## corresponding figure so that @var{hax} is the first entry in the list
+## of children.  This causes @var{hax} to be displayed on top of any other
+## axes objects (Z-order stacking).
+## 
+## @seealso {gca, set, get}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = axes (varargin)
 
   if (nargin == 0 || nargin > 1)
     ## Create an axes object.
     idx = find (strcmpi (varargin(1:2:end), "parent"), 1, "first");
     if (! isempty (idx) && length (varargin) >= 2*idx)
       cf = varargin{2*idx};
       varargin([2*idx-1, 2*idx]) = [];
     else
       cf = gcf ();
     endif
-    tmp = __go_axes__ (cf, varargin{:});
-    if (__is_handle_visible__ (tmp))
-      set (ancestor (cf, "figure"), "currentaxes", tmp);
+    htmp = __go_axes__ (cf, varargin{:});
+    if (__is_handle_visible__ (htmp))
+      set (ancestor (cf, "figure"), "currentaxes", htmp);
     endif
   else
-    ## arg is axes handle.
-    tmp = varargin{1};
-    if (length (tmp) == 1 && ishandle (tmp)
-        && strcmp (get (tmp, "type"), "axes"))
-      if (__is_handle_visible__ (tmp))
-        parent = ancestor (tmp, "figure");
+    ## ARG is axes handle.
+    htmp = varargin{1};
+    if (isscalar (htmp) && isaxes (htmp))
+      if (__is_handle_visible__ (htmp))
+        parent = ancestor (htmp, "figure");
         set (0, "currentfigure", parent);
-        set (parent, "currentaxes", tmp);
+        set (parent, "currentaxes", htmp);
+
+        ## restack
+        ch = get (parent, "children")(:);
+        idx = (ch == htmp);
+        ch = [ch(idx); ch(!idx)];
+        set (parent, "children", ch);
       endif
     else
-      error ("axes: expecting argument to be a scalar axes handle");
+      error ("axes: H must be a scalar axes handle");
     endif
   endif
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
+
diff --git a/scripts/plot/cla.m b/scripts/plot/util/cla.m
rename from scripts/plot/cla.m
rename to scripts/plot/util/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/util/cla.m
@@ -12,93 +12,97 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} cla ()
-## @deftypefnx {Function File} {} cla ("reset")
+## @deftypefn  {Command} {} cla
+## @deftypefnx {Command} {} cla reset
 ## @deftypefnx {Function File} {} cla (@var{hax})
 ## @deftypefnx {Function File} {} cla (@var{hax}, "reset")
-## Delete the children of the current axes with visible handles.
-## If @var{hax} is specified and is an axes object handle, operate on it
-## instead of the current axes.  If the optional argument @code{"reset"}
-## is specified, also delete the children with hidden handles.
-## @seealso{clf}
+## Clear the current axes.
+##
+## @code{cla} operates by deleting child graphic objects with visible
+## handles (HandleVisibility = @qcode{"on"}).
+##
+## If the optional argument @qcode{"reset"} is specified, delete all child
+## objects including those with hidden handles and reset all axis properties
+## to their defaults.  However, the following properties are not reset:
+## Position, Units.
+##
+## If the first argument @var{hax} is an axes handle, then operate on
+## this axis rather than the current axes returned by @code{gca}.
+## @seealso{clf, delete, reset}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2008-10-03
 
 function cla (varargin)
 
   if (nargin > 2)
     print_usage ();
-  elseif (nargin > 1)
-    if (ishandle (varargin{1})
-        && strcmp (get (varargin{1}, "type"), "axes")
-        && ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
-      oldhax = gca;
-      hax = varargin{1};
-      do_reset = true;
-    else
-      print_usage ();
-    endif
+  elseif (nargin == 0)
+    hax = gca;
+    do_reset = false;
   elseif (nargin == 1)
-    if (ishandle (varargin{1})
-        && strcmp (get (varargin{1}, "type"), "axes"))
-      oldhax = gca;
+    if (isscalar (varargin{1}) && isaxes (varargin{1}))
       hax = varargin{1};
       do_reset = false;
     elseif (ischar (varargin{1}) && strcmpi (varargin{1}, "reset"))
       hax = gca;
-      oldhax = hax;
       do_reset = true;
     else
       print_usage ();
     endif
   else
-    hax = gca;
-    oldhax = hax;
-    do_reset = false;
-  endif
-
-  hc = get (hax, "children");
-
-  if (! do_reset && ! isempty (hc))
-    hc = findobj (hc, "flat", "visible", "on");
-    hc = setdiff (hc, hax);
+    if (isscalar (varargin{1}) && isaxes (varargin{1})
+        && ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
+      hax = varargin{1};
+      do_reset = true;
+    else
+      print_usage ();
+    endif
   endif
 
-  if (! isempty (hc))
-    ## Delete the children of the axis.
-    delete (hc);
+  if (! do_reset)
+    delete (get (hax, "children"));
+  else
+    __go_axes_init__ (hax, "replace");
+    __request_drawnow__ ();
   endif
 
-  ## FIXME: The defaults should be "reset()" below, but so far there is
-  ## no method to determine the defaults, much less return an object's
-  ## properties to their default values.  Instead make a close
-  ## approximation.
-
-  axes (hax);
-  axis ("auto");
-
-  ## Set the current axis back to where it was upon entry.
-  axes (oldhax);
-
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (1:10);
+%!   assert (! isempty (get (gca, "children")));
 %!   cla ();
-%!   kids = get (gca, "children");
-%!   cla ();
+%!   assert (isempty (get (gca, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
-%! assert (numel (kids), 0);
 
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   hax = gca;
+%!   plot (hax, 1:10);
+%!   set (hax, "interpreter", "tex");
+%!   cla (hax);
+%!   kids = get (hax, "children");
+%!   assert (numel (kids), 0);
+%!   assert (get (hax, "interpreter"), "tex");
+%!   plot (hax, 1:10);
+%!   cla (hax, "reset");
+%!   kids = get (hax, "children");
+%!   assert (numel (kids), 0);
+%!   assert (get (hax, "interpreter"), "none");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/clf.m b/scripts/plot/util/clf.m
rename from scripts/plot/clf.m
rename to scripts/plot/util/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/util/clf.m
@@ -12,94 +12,113 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} clf ()
-## @deftypefnx {Function File} {} clf ("reset")
+## @deftypefn  {Command} {} clf
+## @deftypefnx {Command} {} clf reset
 ## @deftypefnx {Function File} {} clf (@var{hfig})
 ## @deftypefnx {Function File} {} clf (@var{hfig}, "reset")
 ## @deftypefnx {Function File} {@var{h} =} clf (@dots{})
-## Clear the current figure window.  @code{clf} operates by deleting child
-## graphics objects with visible handles (@code{handlevisibility} = on).
-## If @var{hfig} is specified operate on it instead of the current figure.
-## If the optional argument @code{"reset"} is specified, all objects including
-## those with hidden handles are deleted.
+## Clear the current figure window.
+## 
+## @code{clf} operates by deleting child graphics objects with visible
+## handles (HandleVisibility = @qcode{"on"}).
+##
+## If the optional argument @qcode{"reset"} is specified, delete all child
+## objects including those with hidden handles and reset all figure
+## properties to their defaults.  However, the following properties are not
+## reset: Position, Units, PaperPosition, PaperUnits.
+##
+## If the first argument @var{hfig} is a figure handle, then operate on
+## this figure rather than the current figure returned by @code{gcf}.
 ## 
 ## The optional return value @var{h} is the graphics handle of the figure
 ## window that was cleared.
-## @seealso{cla, close, delete}
+## @seealso{cla, close, delete, reset}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = clf (varargin)
+function h = clf (varargin)
 
   if (nargin > 2)
     print_usage ();
-  elseif (nargin > 1)
-    if (isfigure (varargin{1}) && ischar (varargin{2})
-        && strcmpi (varargin{2}, "reset"))
-      oldfig = gcf;
+  elseif (nargin == 0)
+    hfig = gcf;
+    do_reset = false;
+  elseif (nargin == 1)
+    if (isscalar (varargin{1}) && isfigure (varargin{1}))
+      hfig = varargin{1};
+      do_reset = false;
+    elseif (ischar (varargin{1}) && strcmpi (varargin{1}, "reset"))
+      hfig = gcf;
+      do_reset = true;
+    else
+      print_usage ();
+    endif
+  else
+    if (isscalar (varargin{1}) && isfigure (varargin{1})
+        && ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
       hfig = varargin{1};
       do_reset = true;
     else
       print_usage ();
     endif
-  elseif (nargin == 1)
-    if (isfigure (varargin{1}))
-      oldfig = gcf;
-      hfig = varargin{1};
-      do_reset = false;
-    elseif (ischar (varargin{1}) && strcmpi (varargin{1}, "reset"))
-      hfig = gcf;
-      oldfig = hfig;
-      do_reset = true;
-    else
-      print_usage ();
-    endif
-  else
-    hfig = gcf;
-    oldfig = hfig;
-    do_reset = false;
   endif
 
   if (do_reset)
     ## Select all the children, including the one with hidden handles.
-    hc = allchild (hfig);
+    delete (allchild (hfig));
     reset (hfig);
   else
     ## Select only the chilren with visible handles.
-    hc = get (hfig, "children");
+    delete (get (hfig, "children"));
   endif
 
-  ## Delete the children.
-  delete (hc);
-
   if (nargout > 0)
-    retval = hfig;
+    h = hfig;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (! isempty (get (gcf, "children")));
+%!   clf;
+%!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   clf;
 %!   assert (isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+%!xtest
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   plot (1:10);
+%!   set (hf, "papertype", "tabloid");
+%!   clf (hf);
+%!   assert (isempty (get (gcf, "children")));
+%!   assert (get (hf, "papertype"), "tabloid");
+%!   plot (1:10);
+%!   clf (hf, "reset");
+%!   kids = get (hf, "children");
+%!   assert (isempty (get (gcf, "children")));
+%!   assert (get (hf, "papertype"), "usletter");
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/close.m b/scripts/plot/util/close.m
rename from scripts/plot/close.m
rename to scripts/plot/util/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/util/close.m
@@ -13,83 +13,97 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} close
-## @deftypefnx {Command} {} close (@var{n})
+## @deftypefnx {Command} {} close (@var{h})
 ## @deftypefnx {Command} {} close all
 ## @deftypefnx {Command} {} close all hidden
-## Close figure window(s) by calling the function specified by the
-## @code{"closerequestfcn"} property for each figure.  By default, the
-## function @code{closereq} is used.
-## @seealso{closereq}
+## Close figure window(s).
+##
+## When called with no arguments, close the current figure.  This is equivalent
+## to @code{close (gcf)}.  If the input @var{h} is a graphic handle, or vector
+## of graphics handles, then close each figure in @var{h}.
+##
+## If the argument @qcode{"all"} is given then all figures with visible handles
+## (HandleVisibility = @qcode{"on"}) are closed.
+##
+## If the argument @qcode{"all hidden"} is given then all figures, including
+## hidden ones, are closed.
+##
+## Implementation Note: @code{close} operates by calling the function specified
+## by the @qcode{"closerequestfcn"} property for each figure.  By default, the
+## function @code{closereq} is used.  It is possible that the function invoked
+## will delay or abort removing the figure.  To remove a figure without
+## executing any callback functions use @code{delete}.  When writing a callback
+## function to close a window do not use @code{close} to avoid recursion.
+##
+## @seealso{closereq, delete}
 ## @end deftypefn
 
 ## Author: jwe
 ## 2010-05-02   PBig    allow empty argument
 
 function retval = close (arg1, arg2)
 
   figs = [];
 
-  if (nargin == 0)
-    ## Close current figure.  Don't use gcf because that will open a new
-    ## plot window if one doesn't exist.
+  if (nargin > 2)
+    print_usage ();
+  elseif (nargin == 0)
+    ## Close current figure.
+    ## Can't use gcf because it opens a new plot window if one does not exist.
     figs = get (0, "currentfigure");
-    if (! isempty (figs) && figs == 0)
+    if (figs == 0)  # don't close root figure
       figs = [];
     endif
   elseif (nargin == 1)
     if (ischar (arg1) && strcmpi (arg1, "all"))
-      close_all_figures (false);
+      figs = (get (0, "children"))';
+      figs = figs(isfigure (figs));
     elseif (isfigure (arg1))
       figs = arg1;
     elseif (isempty (arg1))
       figs = [];
     else
-      error ("close: expecting argument to be \"all\" or a figure handle");
+      error ('close: first argument must be "all" or a figure handle');
     endif
-  elseif (nargin == 2
-          && ischar (arg1) && strcmpi (arg1, "all")
+  elseif (   ischar (arg1) && strcmpi (arg1, "all")
           && ischar (arg2) && strcmpi (arg2, "hidden"))
-    close_all_figures (true);
+    figs = (allchild (0))';
+    figs = figs(isfigure (figs));
   else
-    print_usage ();
+    error ('close: expecting argument to be "all hidden"');
   endif
 
   for h = figs
     __go_execute_callback__ (h, "closerequestfcn");
   endfor
 
   if (nargout > 0)
     retval = 1;
   endif
 
 endfunction
 
-function close_all_figures (close_hidden_figs)
-
-  while (! isempty (fig = get (0, "currentfigure")))
-    ## handlevisibility = get (fig, "handlevisibility")
-    ## if (close_hidden_figs || ! strcmpi (handlevisibility, "off"))
-    close (fig);
-    ## endif
-  endwhile
-
-endfunction
-
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   close (hf);
 %!   objs = findobj ("type", "figure");
-%!   assert (isempty (intersect (objs, hf)));
+%!   assert (! any (objs == hf));
 %! unwind_protect_cleanup
 %!   if (isfigure (hf))
 %!     close (hf);
 %!   endif
 %! end_unwind_protect
 
+%!error close (1,2,3)
+%!error <first argument must be "all" or a figure> close ({"all"})
+%!error <first argument must be "all" or a figure> close ("all_and_more")
+%!error <first argument must be "all" or a figure> close (-1)
+%!error <expecting argument to be "all hidden"> close "all" hid"
+
diff --git a/scripts/plot/closereq.m b/scripts/plot/util/closereq.m
rename from scripts/plot/closereq.m
rename to scripts/plot/util/closereq.m
--- a/scripts/plot/closereq.m
+++ b/scripts/plot/util/closereq.m
@@ -13,31 +13,34 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} closereq ()
-## Close the current figure and delete all graphics objects associated
-## with it.
+## Close the current figure and delete all graphics objects associated with it.
+##
+## By default, the @qcode{"closerequestfcn"} property of a new plot figure
+## points to this function.
 ## @seealso{close, delete}
 ## @end deftypefn
 
 ## Author: jwe
 
 function closereq ()
 
-  if (nargin == 0)
-    cf = gcbf ();
-    if (isempty (cf))
-      warning ("closereq: calling closereq from octave prompt is not supported, use 'close' instead");
-      cf = get (0, "currentfigure");
-    endif
-    if (! isempty (cf) && isfigure (cf))
-      delete (cf);
-    endif
-  else
+  if (nargin != 0)
     print_usage ();
   endif
 
+  cf = gcbf ();
+  if (isempty (cf))
+    warning ("closereq: calling closereq from octave prompt is not supported, use 'close' instead");
+    cf = get (0, "currentfigure");
+  endif
+  if (! isempty (cf) && isfigure (cf))
+    delete (cf);
+  endif
+
 endfunction
+
diff --git a/scripts/plot/colstyle.m b/scripts/plot/util/colstyle.m
rename from scripts/plot/colstyle.m
rename to scripts/plot/util/colstyle.m
diff --git a/scripts/plot/copyobj.m b/scripts/plot/util/copyobj.m
rename from scripts/plot/copyobj.m
rename to scripts/plot/util/copyobj.m
--- a/scripts/plot/copyobj.m
+++ b/scripts/plot/util/copyobj.m
@@ -12,21 +12,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{hnew} =} copyobj (@var{horig})
 ## @deftypefnx {Function File} {@var{hnew} =} copyobj (@var{horig}, @var{hparent})
-## Construct a copy of the object associated with handle @var{horig}
+## Construct a copy of the graphic object associated with handle @var{horig}
 ## and return a handle @var{hnew} to the new object.
+##
 ## If a parent handle @var{hparent} (root, figure, axes, or hggroup) is
-## specified, the copied object will be created as a child to @var{hparent}.
-## @seealso{findobj, get, set, struct2hdl, hdl2struct}
+## specified, the copied object will be created as a child of @var{hparent}.
+## @seealso{struct2hdl, hdl2struct, findobj}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-04-01
 
 function hnew = copyobj (horig, hparent = 0)
 
   partypes = {"root", "figure", "axes", "hggroup"};
@@ -78,63 +79,76 @@ endfunction
 %! dy = 2 * (.2 * x);
 %! y2 = (x - 3).^2;
 %! hg = errorbar (x, y, dy,'#~');
 %! set (hg, 'marker', '^', 'markerfacecolor', rand (1,3));
 %! plot (x, y2, 'ok-');
 %! legend ('errorbar', 'line');
 %! hnew = copyobj (hdl);
 
-%!demo
-%! ## FIXME: This demo fails occasionally for an obscure reason.
+%!#demo
+%! ## FIXME: This demo fails for an obscure reason.
 %! ## It appears that there is something wrong with Octave code for patches.
-%! hdl = figure (1234);
-%! clf;
-%! subplot (2,2,1);
-%! hold on;
-%! contourf (rand (10, 10));
-%! colorbar;
-%! subplot (2,2,2);
-%! quiver (rand (10, 10), rand (10, 10));
-%! subplot (2,2,3);
-%! colormap (jet (64));
-%! hold on;
-%! sombrero;
-%! colorbar ('peer', gca, 'NorthOutside');
-%! subplot (2,2,4);
-%! imagesc (rand (30, 30));
-%! text (15, 15, 'Rotated text', ...
-%!      'HorizontAlalignment', 'Center', 'Rotation', 30);
-%! hnew = copyobj (hdl);
+%! ## This demo must remain commented out until patch() has been reworked.
+%! unwind_protect
+%!   hdl = figure (1234);
+%!   clf;
+%!   subplot (2,2,1);
+%!   hold on;
+%!   contourf (rand (10, 10));
+%!   colorbar ();
+%!   subplot (2,2,2);
+%!   quiver (rand (10, 10), rand (10, 10));
+%!   subplot (2,2,3);
+%!   colormap (jet (64));
+%!   hold on;
+%!   sombrero ();
+%!   colorbar ('peer', gca, 'NorthOutside');
+%!   subplot (2,2,4);
+%!   imagesc (rand (30, 30));
+%!   text (15, 15, 'Rotated text', ...
+%!         'HorizontAlalignment', 'Center', 'Rotation', 30);
+%!   hnew = copyobj (hdl);
+%! unwind_protect_cleanup
+%!   close all;
+%! end_unwind_protect
 
 %!testif HAVE_MAGICK
-%! h1 = figure ();
-%! set (h1, "visible", "off");
-%! x = 0:0.1:2*pi;
-%! y1 = sin (x);
-%! y2 = exp (x - 1);
-%! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
-%! xlabel ("X");
-%! ylabel (ax(1), "Axis 1");
-%! ylabel (ax(2), "Axis 2");
-%! axes (ax(1));
-%! text (0.5, 0.5, "Left Axis", ...
-%!       "color", [0 0 1], "horizontalalignment", "center");
-%! axes (ax(2));
-%! text (4.5, 80, "Right Axis", ...
-%!       "color", [0 0.5 0], "horizontalalignment", "center");
-%! s1 = hdl2struct (h1);
-%! h2 = struct2hdl (s1);
-%! s2 = hdl2struct (h2);
-%! png1 = strcat (tmpnam (), ".png");
-%! png2 = strcat (tmpnam (), ".png");
+%! toolkit = graphics_toolkit ();
+%! graphics_toolkit ("gnuplot");
 %! unwind_protect
-%!   print (h1, png1);
-%!   [img1, map1, alpha1] = imread (png1);
-%!   print (h2, png2);
-%!   [img2, map2, alpha2] = imread (png2);
+%!   h1 = figure ("visible", "off");
+%!   x = 0:0.1:2*pi;
+%!   y1 = sin (x);
+%!   y2 = exp (x - 1);
+%!   ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
+%!   xlabel ("X");
+%!   ylabel (ax(1), "Axis 1");
+%!   ylabel (ax(2), "Axis 2");
+%!   axes (ax(1));
+%!   text (0.5, 0.5, "Left Axis", ...
+%!         "color", [0 0 1], "horizontalalignment", "center");
+%!   axes (ax(2));
+%!   text (4.5, 80, "Right Axis", ...
+%!         "color", [0 0.5 0], "horizontalalignment", "center");
+%!   s1 = hdl2struct (h1);
+%!   h2 = struct2hdl (s1);
+%!   s2 = hdl2struct (h2);
+%!   png1 = strcat (tmpnam (), ".png");
+%!   png2 = strcat (tmpnam (), ".png");
+%!   unwind_protect
+%!     print (h1, png1);
+%!     [img1, map1, alpha1] = imread (png1);
+%!     print (h2, png2);
+%!     [img2, map2, alpha2] = imread (png2);
+%!   unwind_protect_cleanup
+%!     unlink (png1);
+%!     unlink (png2);
+%!   end_unwind_protect
+%!   assert (img1, img2);
+%!   assert (map1, map2);
+%!   assert (alpha1, alpha2);
 %! unwind_protect_cleanup
-%!   unlink (png1);
-%!   unlink (png2);
+%!   close (h1);
+%!   close (h2);
+%!   graphics_toolkit (toolkit);
 %! end_unwind_protect
-%! assert (img1, img2);
-%! assert (map1, map2);
-%! assert (alpha1, alpha2);
+
diff --git a/scripts/plot/figure.m b/scripts/plot/util/figure.m
rename from scripts/plot/figure.m
rename to scripts/plot/util/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/util/figure.m
@@ -15,94 +15,113 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} figure
 ## @deftypefnx {Command} {} figure @var{n}
 ## @deftypefnx {Function File} {} figure (@var{n})
-## @deftypefnx {Function File} {} figure (@var{n}, "@var{property}", @var{value}, @dots{})
-## Set the current plot window to plot window @var{n}.  If no arguments are
-## specified, the next available window number is chosen.
+## @deftypefnx {Function File} {} figure (@dots{}, "@var{property}", @var{value}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} figure (@var{dots})
+## Create a new figure window for plotting.
+##
+## If no arguments are specified, a new figure with the next available number
+## is created.
 ##
-## Multiple property-value pairs may be specified for the figure, but they
-## must appear in pairs.
+## If called with an integer @var{n}, and no such numbered figure exists, then
+## a new figure with the specified number is created.  If the figure already
+## exists then it is made visible and becomes the current figure for plotting.
+## 
+## Multiple property-value pairs may be specified for the figure object, but
+## they must appear in pairs.
+##
+## The optional return value @var{h} is a graphics handle to the created figure
+## object.
+## @seealso{axes, gcf, clf, close}
 ## @end deftypefn
 
 ## Author: jwe, Bill Denney
 
 function h = figure (varargin)
 
   nargs = nargin;
 
-  f = NaN;
-
-  init_new_figure = false;
-  if (mod (nargs, 2) == 1)
-    tmp = varargin{1};
-    if (ischar (tmp))
-      tmp = str2double (tmp);
+  if (mod (nargs, 2) == 0)
+    f = NaN;
+    init_new_figure = true;
+  else
+    arg = varargin{1};
+    if (ischar (arg))
+      arg = str2double (arg);
     endif
-    if (isfigure (tmp))
-      f = tmp;
+    if (isfigure (arg))
+      f = arg;
+      init_new_figure = false;
       varargin(1) = [];
       nargs--;
-    elseif (isnumeric (tmp) && tmp > 0 && tmp == fix (tmp))
-      f = tmp;
+    elseif (isnumeric (arg) && isscalar (arg) && arg > 0 && arg == fix (arg))
+      f = arg;
       init_new_figure = true;
       varargin(1) = [];
       nargs--;
     else
-      error ("figure: expecting figure handle or figure number");
+      error ("figure: N must be figure handle or figure number");
     endif
   endif
 
+  if (rem (nargs, 2) == 1)
+    error ("figure: PROPERTY/VALUE arguments must be in pairs");
+  endif
+
   ## Check to see if we already have a figure on the screen.  If we do,
   ## then update it if it is different from the figure we are creating
   ## or switching to.
-  cf = get (0, "currentfigure");   # Can't use gcf () because it calls figure ()
+  cf = get (0, "currentfigure");   # Can't use gcf () because it calls figure()
   if (! isempty (cf) && cf != 0)
-    if (isnan (f) || cf != f)
+    if (init_new_figure || cf != f)
       drawnow ();
     endif
   endif
 
-  if (rem (nargs, 2) == 0)
-    if (isnan (f) || init_new_figure)
-      if (ismac () && strcmp (graphics_toolkit (), "fltk"))
-        ## FIXME - Hack for fltk-aqua to work around bug #31931
-        f = __go_figure__ (f);
-        drawnow ();
-        if (! isempty (varargin))
-          set (f, varargin{:});
-        endif
-      else
-        f = __go_figure__ (f, varargin{:});
+  if (init_new_figure)
+    if (ismac () && strcmp (graphics_toolkit (), "fltk"))
+      ## FIXME: Hack for fltk-aqua to work around bug #31931
+      f = __go_figure__ (f);
+      drawnow ();
+      if (! isempty (varargin))
+        set (f, varargin{:});
       endif
-    elseif (nargs > 0)
-      set (f, varargin{:});
+    else
+      f = __go_figure__ (f, varargin{:});
     endif
-    set (0, "currentfigure", f);
-  else
-    print_usage ();
+    __add_default_menu__ (f);
+  elseif (nargs > 0)
+    set (f, varargin{:});
   endif
 
-  if (strcmp (get (f, "__graphics_toolkit__"), "fltk"))
-    __add_default_menu__ (f);
+  set (0, "currentfigure", f);
+  ## When switching to figure N, make figure visible and on top of stack.
+  if (! init_new_figure)
+    set (f, "visible", "on");
   endif
 
   if (nargout > 0)
     h = f;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   assert (gcf, hf);
+%!   assert (hf, gcf);
 %!   assert (isfigure (hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
+%!error <N must be figure handle or figure number> figure ({1})
+%!error <N must be figure handle or figure number> figure ([1 2])
+%!error <N must be figure handle or figure number> figure (-1)
+%!error <N must be figure handle or figure number> figure (1.5)
+
diff --git a/scripts/plot/findall.m b/scripts/plot/util/findall.m
rename from scripts/plot/findall.m
rename to scripts/plot/util/findall.m
--- a/scripts/plot/findall.m
+++ b/scripts/plot/util/findall.m
@@ -13,25 +13,31 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findall ()
-## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value})
-## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} findall (@var{h}, "-depth", @var{d}, @dots{})
-## Find graphics object with specified property values including hidden handles.
+## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findall (@var{prop_name}, @var{prop_value}, "-@var{logical_op}", @var{prop_name}, @var{prop_value})
+## @deftypefnx {Function File} {@var{h} =} findall ("-property", @var{prop_name})
+## @deftypefnx {Function File} {@var{h} =} findall ("-regexp", @var{prop_name}, @var{pattern})
+## @deftypefnx {Function File} {@var{h} =} findall (@var{hlist}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findall (@var{hlist}, "flat", @dots{})
+## @deftypefnx {Function File} {@var{h} =} findall (@var{hlist}, "-depth", @var{d}, @dots{})
+## Find graphics object, including hidden ones, with specified property values.
 ##
-## This function performs the same function as @code{findobj}, but it
-## includes hidden objects in its search.  For full documentation, see
-## @code{findobj}.
-## @seealso{get, set, findobj, allchild}
+## The return value @var{h} is a list of handles to the found graphic objects.
+##
+## @code{findall} performs the same search as @code{findobj}, but it
+## includes hidden objects (HandleVisibility = @qcode{"off"}).  For full
+## documentation, @pxref{XREFfindobj,,findobj}.
+## @seealso{findobj, allchild, get, set}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function h = findall (varargin)
 
   unwind_protect
     shh = get (0, "showhiddenhandles");
@@ -40,21 +46,20 @@ function h = findall (varargin)
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 
 %!testif HAVE_FLTK
-%! toolkit = graphics_toolkit ();
-%! graphics_toolkit ("fltk");
+%! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = findall (hf);
-%!   all_handles(1:13,1) = {"uimenu"};
-%!   all_handles(14) = {"figure"};
+%!   all_handles(1) = {"figure"};
+%!   all_handles(2:14,1) = {"uimenu"};
 %!   assert (get (h, "type"), all_handles);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
diff --git a/scripts/plot/findfigs.m b/scripts/plot/util/findfigs.m
rename from scripts/plot/findfigs.m
rename to scripts/plot/util/findfigs.m
--- a/scripts/plot/findfigs.m
+++ b/scripts/plot/util/findfigs.m
@@ -24,58 +24,54 @@
 ## @seealso{allchild, figure, get, set}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 ## Modified by: Carn Draug <carandraug+dev@gmail.com>
 
 function findfigs ()
 
-  figh  = allchild (0);
+  hfigs = allchild (0);
   units = get (0, "units");
   unwind_protect
-    if (!strcmp (units, "pixels"))
-      set (0, "units", "pixels");
-    endif
+    set (0, "units", "pixels");
     screensize = get (0, "screensize");
   unwind_protect_cleanup
     set (0, "units", units);
   end_unwind_protect
 
   ## give the monitor a margin so that the figure must not just
   ## marginally be on the monitor.
   margin = 30;
   screensize(1:2) += margin;
   screensize(3:4) -= margin;
 
-  for i = 1:numel (figh)
-    if (strcmp (get (figh(i), "visible"), "on"))
+  hfigs = hfigs(strcmp (get (hfigs, "visible"), "on"));
+  for hf = hfigs'
+    units = get (hf, "units");
+    unwind_protect
+      set (hf, "units", "pixels");
+      pos = get (hf, "position");
+      ## Test if (in order):
+      ## The left side is outside the right side of the screen
+      ## The bottom is above the top of the screen
+      ## The right side is outside the left of the screen
+      ## the top is below the bottom of the screen
+      if (pos(1) > screensize(3)
+          || pos(2) > screensize(4)
+          || pos(1)+pos(3) < screensize(1)
+          || pos(2)+pos(4) < screensize(2))
 
-      units = get (figh(i), "units");
-      unwind_protect
-        if (!strcmp (units, "pixels"))
-          set (figh(i), "units", "pixels");
-        endif
-        pos = get (figh(i), "position");
-        ## Test if (in order):
-        ## The left side is outside the right side of the screen
-        ## The bottom is above the top of the screen
-        ## The right side is outside the left of the screen
-        ## the top is below the bottom of the screen
-        if (pos(1) > screensize(3)
-            || pos(2) > screensize(4)
-            || pos(1)+pos(3) < screensize(1)
-            || pos(2)+pos(4) < screensize(2))
+        ## the new position will be at the top left of the screen
+        ## (all moved figures will overlap).  The bottom left is chosen
+        ## instead of the top left because that allows for the unknown
+        ## amount of space for the menu bar and the title bar.
+        pos(1) = screensize(1);
+        pos(2) = screensize(2);
+        set (hf, "position", pos);
+      endif
+    unwind_protect_cleanup
+      set (hf, "units", units);
+    end_unwind_protect
+  endfor
 
-          ## the new position will be at the top left of the screen
-          ## (all moved figures will overlap).  The bottom left is chosen
-          ## instead of the top left because that allows for the unknown
-          ## amount of space for the menu bar and the title bar.
-          pos(1) = screensize(1);
-          pos(2) = screensize(2);
-          set (figh(i), "position", pos);
-        endif
-      unwind_protect_cleanup
-        set (figh(i), "units", units);
-      end_unwind_protect
-    endif
-  endfor
 endfunction
+
diff --git a/scripts/plot/findobj.m b/scripts/plot/util/findobj.m
rename from scripts/plot/findobj.m
rename to scripts/plot/util/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -13,56 +13,69 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} findobj ()
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{prop_name}, @var{prop_value}, "-@var{logical_op}", @var{prop_name}, @var{prop_value})
 ## @deftypefnx {Function File} {@var{h} =} findobj ("-property", @var{prop_name})
 ## @deftypefnx {Function File} {@var{h} =} findobj ("-regexp", @var{prop_name}, @var{pattern})
-## @deftypefnx {Function File} {@var{h} =} findobj ("flat", @dots{})
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
-## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, "-depth", @var{d}, @dots{})
-## Find graphics object with specified property values.  The simplest form is
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{hlist}, @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{hlist}, "flat", @dots{})
+## @deftypefnx {Function File} {@var{h} =} findobj (@var{hlist}, "-depth", @var{d}, @dots{})
+## Find graphics object with specified property values.
+##
+## The simplest form is
 ##
 ## @example
 ## findobj (@var{prop_name}, @var{prop_value})
 ## @end example
 ##
 ## @noindent
-## which returns all of the handles to the objects with the name
-## @var{prop_name} and the name @var{prop_value}.  The search can be limited
-## to a particular object or set of objects and their descendants by
-## passing a handle or set of handles @var{h} as the first argument to
-## @code{findobj}.
+## which returns the handles of all objects which have a property named
+## @var{prop_name} that has the value @var{prop_value}.  If multiple
+## property/value pairs are specified then only objects meeting all of the
+## conditions are returned.
 ##
-## The depth of hierarchy of objects to which to search to can be limited
-## with the "-depth" argument.  To limit the number depth of the hierarchy
-## to search to @var{d} generations of children, and example is
+## The search can be limited to a particular set of objects and their
+## descendants, by passing a handle or set of handles @var{hlist} as the first
+## argument.
+##
+## The depth of the object hierarchy to search can be limited with the
+## @qcode{"-depth"} argument.  An example of searching only three generations
+## of children is:
 ##
 ## @example
-## findobj (@var{h}, "-depth", @var{d}, @var{prop_name}, @var{prop_value})
+## findobj (@var{hlist}, "-depth", 3, @var{prop_name}, @var{prop_value})
 ## @end example
 ##
-## Specifying a depth @var{d} of 0, limits the search to the set of object
-## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the "-flat"
-## argument.
+## Specifying a depth @var{d} of 0, limits the search to the set of objects
+## passed in @var{hlist}.  A depth @var{d} of 0 is equivalent to the
+## @qcode{"flat"} argument.
 ##
 ## A specified logical operator may be applied to the pairs of @var{prop_name}
-## and @var{prop_value}.  The supported logical operators are "-and", "-or",
-## "-xor", "-not".
+## and @var{prop_value}.  The supported logical operators are:
+## @qcode{"-and"}, @qcode{"-or"},
+## @qcode{"-xor"}, @qcode{"-not"}.
+##
+## Objects may also be matched by comparing a regular expression to the
+## property values, where property values that match
+## @code{regexp (@var{prop_value}, @var{pattern})} are returned.
 ##
-## The objects may also be matched by comparing a regular expression to the
-## property values, where property values that match @code{regexp
-## (@var{prop_value}, @var{pattern})} are returned.  Finally, objects may be
-## matched by property name only, using the "-property" option.
-## @seealso{get, set}
+## Finally, objects may be matched by property name only by using the
+## @qcode{"-property"} option.
+##
+## Implementation Note: The search only includes objects with visible
+## handles (HandleVisibility = @qcode{"on"}).  @xref{XREFfindall,,findall}, to
+## search for all objects including hidden ones.
+## @seealso{findall, allchild, get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function h = findobj (varargin)
 
   depth = NaN;
   if (nargin == 0)
@@ -105,16 +118,17 @@ function h = findobj (varargin)
 
   regularexpression = [];
   property          = [];
   logicaloperator   = {};
   pname             = {};
   pvalue            = {};
   np = 1;
   na = 1;
+  operatorprecedence = {"-not", "-and", "-or", "-xor"};
 
   while (na <= numel (args))
     regularexpression(np) = 0;
     property(np) = 0;
     logicaloperator{np} = "and";
     if (ischar (args{na}))
       if (strcmpi (args{na}, "-regexp"))
         if (na + 2 <= numel (args))
@@ -143,123 +157,147 @@ function h = findobj (varargin)
         ## Parameter/value pairs.
         if (na + 1 <= numel (args))
           pname{np} = args{na};
           na = na + 1;
           pvalue{np} = args{na};
           na = na + 1;
           if (na <= numel (args))
             if (ischar (args{na}))
-              if (strcmpi (args{na}, "-and"))
-                logicaloperator{np} = "and";
-                na = na+1;
-              elseif (strcmpi (args{na}, "-or"))
-                logicaloperator{np} = "or";
-                na = na+1;
-              elseif (strcmpi (args{na}, "-xor"))
-                logicaloperator{np} = "xor";
-                na = na+1;
-              elseif (strcmpi (args{na}, "-not"))
-                logicaloperator{np} = "not";
+              if (any (strcmpi (args{na}, operatorprecedence)))
+                logicaloperator{np} = args{na}(2:end);
                 na = na+1;
               endif
             else
               error ("findobj: properties and options must be strings");
             endif
           else
             logicaloperator{np} = "and";
           endif
           np = np + 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       else
         ## This is sloppy ... but works like Matlab.
         if (strcmpi (args{na}, "-not"))
           h = [];
-          return
+          return;
         endif
         na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
-  if (~ isempty (logicaloperator))
+  if (! isempty (logicaloperator))
     logicaloperator = shift (logicaloperator, 1);
   endif
 
   ## Load all objects which qualify for being searched.
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
-      children = union (children, get (handles(n), "children"));
+      children = [children; get(handles(n), "children")];
     endfor
     handles = children;
-    h = union (h, children);
+    h = [h; children];
     idepth = idepth + 1;
   endwhile
 
-  keepers = ones (size (h));
   if (numpairs > 0)
+    match = true (numel (h), numpairs);
     for nh = 1 : numel (h)
-      p = get (h (nh));
+      p = get (h(nh));
       for np = 1 : numpairs
         fields = fieldnames (p);
         fieldindex = find (strcmpi (fields, pname{np}), 1);
         if (numel (fieldindex))
           pname{np} = fields{fieldindex};
           if (property(np))
-            match = 1;
+            match(nh,np) = true;
           else
             if (regularexpression(np))
-              match = regexp (p.(pname{np}), pvalue{np});
-              if (isempty (match))
-                match = 0;
+              foo = regexp (p.(pname{np}), pvalue{np}, "once");
+              if (isempty (foo))
+                match(nh,np) = false;
+              else
+                match(nh,np) = foo;
               endif
             elseif (numel (p.(pname{np})) == numel (pvalue{np}))
               if (ischar (pvalue{np}) && ischar (p.(pname{np})))
-                match = strcmpi (pvalue{np}, p.(pname{np}));
+                match(nh,np) = strcmpi (pvalue{np}, p.(pname{np}));
               elseif (isnumeric (pvalue{np} && isnumeric (p.(pname{np}))))
-                match = (pvalue{np} == p.(pname{np}));
+                match(nh,np) = (pvalue{np} == p.(pname{np}));
               else
-                match = isequal (pvalue{np}, p.(pname{np}));
+                match(nh,np) = isequal (pvalue{np}, p.(pname{np}));
               endif
             else
-              match = 0;
+              match(nh,np) = false;
             endif
-            match = all (match);
-          endif
-          if (strcmpi (logicaloperator{np}, "not"))
-            keepers(nh) = ! keepers(nh) & ! match;
-          else
-            keepers(nh) = feval (logicaloperator{np}, keepers(nh), match);
           endif
         else
-          keepers(nh) = 0;
+          match(nh,np) = false;
         endif
       endfor
     endfor
+
+    if (numpairs > 1)
+      for no = 1 : numel (operatorprecedence)
+        pairs = find (strcmp (logicaloperator(2:end), ...
+                              operatorprecedence{no}(2:end)));
+        for np = sort (pairs, "descend")
+          if (no == 1)
+            match(:,np+1) = ! match(:,np+1);
+            logicaloperator(np+1) = {"and"};
+          else
+            match(:,np) = feval (logicaloperator{np+1}, match(:,np), ...
+                                 match(:,np+1));
+            logicaloperator(np+1) = [];
+            match(:,np+1) = [];
+            numpairs = numpairs - 1;
+          endif
+          if (numpairs < 2)
+            break;
+          endif
+        endfor
+        if (numpairs < 2)
+          break;
+        endif
+      endfor
+    endif
+  else
+    match = true (numel (h), 1);
   endif
 
-  h = h (keepers != 0);
-  h = reshape (h, [numel(h), 1]);
+  h = h(match);
+  h = h(:);
 endfunction
 
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h = findobj (gca (), "-property", "foo");
+%!   assert (isempty (h));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = plot (1:10);
-%!   set (h, "tag", "foobar")
+%!   set (h, "tag", "foobar");
 %!   g = findobj (gcf (), "tag", "foobar", "type", "line", "color", [0 0 1]);
-%!   assert (g, h)
+%!   assert (g, h);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
@@ -270,32 +308,113 @@ endfunction
 %!   assert (isempty (findobj (hf, "type", "xyzxyz")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   subplot (2, 2, 1)
-%!   imagesc (rand (10))
-%!   subplot (2, 2, 2)
-%!   surf (peaks)
-%!   subplot (2, 2, 3)
-%!   contour (peaks)
-%!   subplot (2, 2, 4)
-%!   plot (peaks)
+%!   subplot (2,2,1);
+%!    imagesc (rand (10));
+%!   subplot (2,2,2);
+%!    surf (peaks);
+%!   subplot (2,2,3);
+%!    contour (peaks);
+%!   subplot (2,2,4);
+%!    plot (peaks);
 %!   h1 = findobj (gcf (), "-regexp", "Type", "image|surface|hggroup");
-%!   h2 = findobj (gcf (), "Type", "image", "-or", "Type", "surface", "-or", "Type", "hggroup");
+%!   h2 = findobj (gcf (), "Type", "image",
+%!                  "-or", "Type", "surface",
+%!                  "-or", "Type", "hggroup");
+%!   assert (h2, h1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
-%! assert (h2, h1)
+
+%!test
+%! toolkit = graphics_toolkit ("gnuplot");
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h1 = subplot (2,2,1);
+%!   h2 = subplot (2,2,2);
+%!   h3 = subplot (2,2,3, "userdata", struct ("foo", "bar"));
+%!   h4 = subplot (2,2,4);
+%!   h = findobj (hf, "userdata", struct ("foo", "bar"));
+%!   assert (h, h3);
+%! unwind_protect_cleanup
+%!   close (hf);
+%!   graphics_toolkit (toolkit);
+%! end_unwind_protect
+
+%!test
+%! toolkit = graphics_toolkit ("gnuplot");
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   h1 = subplot (2,2,1, "tag", "1");
+%!   h2 = subplot (2,2,2, "tag", "2");
+%!   h3 = subplot (2,2,3, "tag", "3");
+%!   h4 = subplot (2,2,4, "tag", "4");
+%!   h = findobj (hf, "type", "axes", "-not", "tag", "1");
+%!   assert (h, [h4; h3; h2])
+%! unwind_protect_cleanup
+%!   close (hf);
+%!   graphics_toolkit (toolkit);
+%! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
-%! h1 = subplot (2, 2, 1);
-%! h2 = subplot (2, 2, 2);
-%! h3 = subplot (2, 2, 3);
-%! h4 = subplot (2, 2, 4);
-%! userdata = struct ("foo", "bar");
-%! set (h3, "userdata", userdata);
-%! assert (findobj (hf, "userdata", userdata), h3)
+%! unwind_protect
+%!   h1 = subplot (2, 2, 1);
+%!   set (h1, "userdata", struct ("column", 1, "row", 1));
+%!   h2 = subplot (2, 2, 2);
+%!   set (h2, "userdata", struct ("column", 2, "row", 1));
+%!   h3 = subplot (2, 2, 3);
+%!   set (h3, "userdata", struct ("column", 1, "row", 2));
+%!   h4 = subplot (2, 2, 4);
+%!   set (h4, "userdata", struct ("column", 2, "row", 2));
+%!   h = findobj (hf, "type", "axes",
+%!                "-not", "userdata", struct ("column", 1, "row", 1));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+%! assert (h, [h4; h3; h2])
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   ha = axes ();
+%!   plot (1:10);
+%!   h = findobj (hf, "type", "figure",
+%!                "-or", "parent", hf,
+%!                "-and", "type", "axes");
+%! unwind_protect_cleanup
+%!   close (hf)
+%! end_unwind_protect
+%! assert (h, [hf; ha])
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   set (hf, "tag", "foo");
+%!   h1 = subplot (2,2,1, "tag", "foo");
+%!   h2 = subplot (2,2,2, "tag", "bar");
+%!   h3 = subplot (2,2,3, "tag", "foo");
+%!   h4 = subplot (2,2,4, "tag", "bar");
+%!   h = findobj (hf, "type", "axes", "-xor", "tag", "foo");
+%!   assert (h, [hf; h4; h2]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   hax1 = subplot (2,1,1);
+%!    hl1 = plot (rand (10,1));
+%!   hax2 = subplot (2,1,2);
+%!    hl2 = plot (rand (10,1));
+%!   hobj = findobj (hf);
+%!   assert (hobj, [hf; hax2; hax1; hl2; hl1]);
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/gca.m b/scripts/plot/util/gca.m
rename from scripts/plot/gca.m
rename to scripts/plot/util/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/util/gca.m
@@ -13,31 +13,44 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} gca ()
-## Return a handle to the current axis object.  If no axis object
-## exists, create one and return its handle.  The handle may then be
-## used to examine or set properties of the axes.  For example,
+## Return a handle to the current axis object.
+##
+## The current axis is the default target for graphics output.  In the case
+## of a figure with multiple axes, @code{gca} returns the last created axes
+## or the last axes that was clicked on with the mouse.
+##
+## If no current axes object exists, create one and return its handle.  The
+## handle may then be used to examine or set properties of the axes.  For
+## example,
 ##
 ## @example
 ## @group
 ## ax = gca ();
 ## set (ax, "position", [0.5, 0.5, 0.5, 0.5]);
 ## @end group
 ## @end example
 ##
 ## @noindent
-## creates an empty axes object, then changes its location and size in
-## the figure window.
-## @seealso{gcf, gco, get, set}
+## creates an empty axes object and then changes its location and size in the
+## figure window.
+##
+## Note: To find the current axis without creating a new axes object if it
+## does not exist, query the @qcode{"CurrentAxes"} property of a figure.
+##
+## @example
+## get (gcf, "currentaxes");
+## @end example
+## @seealso{gcf, gco, gcbf, gcbo, get, set}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = gca ()
 
   if (nargin == 0)
     h = get (gcf (), "currentaxes");
diff --git a/scripts/plot/gcbf.m b/scripts/plot/util/gcbf.m
rename from scripts/plot/gcbf.m
rename to scripts/plot/util/gcbf.m
--- a/scripts/plot/gcbf.m
+++ b/scripts/plot/util/gcbf.m
@@ -13,25 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{fig} =} gcbf ()
-## Return a handle to the figure containing the object whose callback
-## is currently executing.  If no callback is executing, this function
-## returns the empty matrix.  The handle returned by this function is
-## the same as the second output argument of @code{gcbo}.
+## Return a handle to the figure containing the object whose callback is
+## currently executing.
 ##
-##@seealso{gcbo, gcf, gca}
-##@end deftypefn
+## If no callback is executing, this function returns the empty matrix.  The
+## handle returned by this function is the same as the second output argument
+## of @code{gcbo}.
+##
+## @seealso{gcbo, gcf, gco, gca, get, set}
+## @end deftypefn
 
 function fig = gcbf ()
 
-  [dummy, fig] = gcbo ();
+  [~, fig] = gcbo ();
 
 endfunction
 
 
 %!assert (isempty (gcbf))
 
diff --git a/scripts/plot/gcbo.m b/scripts/plot/util/gcbo.m
rename from scripts/plot/gcbo.m
rename to scripts/plot/util/gcbo.m
--- a/scripts/plot/gcbo.m
+++ b/scripts/plot/util/gcbo.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} gcbo ()
 ## @deftypefnx {Function File} {[@var{h}, @var{fig}] =} gcbo ()
-## Return a handle to the object whose callback is currently
-## executing.  If no callback is executing, this function returns the
-## empty matrix.  This handle is obtained from the root object property
-## "CallbackObject".
+## Return a handle to the object whose callback is currently executing.
+## 
+## If no callback is executing, this function returns the empty matrix.  This
+## handle is obtained from the root object property @qcode{"CallbackObject"}.
 ##
 ## When called with a second output argument, return the handle of the figure
 ## containing the object whose callback is currently executing.  If no callback
 ## is executing the second output is also set to the empty matrix.
 ##
-##@seealso{gcbf, gco, gcf, gca}
-##@end deftypefn
+## @seealso{gcbf, gco, gca, gcf, get, set}
+## @end deftypefn
 
 function [h, fig] = gcbo ()
 
   h = get (0, "callbackobject");
   fig = [];
 
   if (! isempty (h) && nargout > 1)
     fig = ancestor (h, "figure");
diff --git a/scripts/plot/gcf.m b/scripts/plot/util/gcf.m
rename from scripts/plot/gcf.m
rename to scripts/plot/util/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/util/gcf.m
@@ -13,45 +13,59 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} gcf ()
-## Return the current figure handle.  If a figure does not exist, create
-## one and return its handle.  The handle may then be used to examine or
-## set properties of the figure.  For example,
+## Return a handle to the current figure.
+##
+## The current figure is the default target for graphics output.  If multiple
+## figures exist, @code{gcf} returns the last created figure or the last figure
+## that was clicked on with the mouse.
+##
+## If a current figure does not exist, create one and return its handle.  The
+## handle may then be used to examine or set properties of the figure.  For
+## example,
 ##
 ## @example
 ## @group
 ## fplot (@@sin, [-10, 10]);
 ## fig = gcf ();
-## set (fig, "visible", "off");
+## set (fig, "numbertitle", "off", "name", "sin plot")
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots a sine wave, finds the handle of the current figure, and then
-## makes that figure invisible.  Setting the visible property of the
-## figure to @code{"on"} will cause it to be displayed again.
-## @seealso{gca, gco, get, set}
+## renames the figure window to describe the contents.
+##
+## Note: To find the current figure without creating a new one if it does not
+## exist, query the @qcode{"CurrentFigure"} property of the root graphics
+## object.
+##
+## @example
+## get (0, "currentfigure");
+## @end example
+##
+## @seealso{gca, gco, gcbf, gcbo, get, set}
 ## @end deftypefn
 
 ## Author: jwe, Bill Denney
 
 function h = gcf ()
 
   if (nargin == 0)
     h = get (0, "currentfigure");
     if (isempty (h) || h == 0)
       ## We only have a root figure object, so create a new figure
       ## object and make it the current figure.
-      h = figure (1);
+      h = figure ();
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/gco.m b/scripts/plot/util/gco.m
rename from scripts/plot/gco.m
rename to scripts/plot/util/gco.m
--- a/scripts/plot/gco.m
+++ b/scripts/plot/util/gco.m
@@ -15,31 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} gco ()
 ## @deftypefnx {Function File} {@var{h} =} gco (@var{fig})
 ## Return a handle to the current object of the current figure, or a handle
-## to the current object of the figure with handle @var{fig}.  The current
-## object of a figure is the object that was last clicked on.  It is stored
-## in the CurrentObject property of the target figure.
+## to the current object of the figure with handle @var{fig}.
 ##
-## If the last mouse click didn't occur on any child object of the figure,
-## the current object is the figure itself.
+## The current object of a figure is the object that was last clicked on.  It
+## is stored in the @qcode{"CurrentObject"} property of the target figure.
+##
+## If the last mouse click did not occur on any child object of the figure,
+## then the current object is the figure itself.
 ##
 ## If no mouse click occurred in the target figure, this function returns an
 ## empty matrix.
 ##
-## Note that the value returned by this function is not necessarily the same
-## as the one returned by gcbo during callback execution.  An executing
-## callback can be interrupted by another callback and the current object
-## can be modified.
+## Programming Note: The value returned by this function is not necessarily the
+## same as the one returned by @code{gcbo} during callback execution.  An
+## executing callback can be interrupted by another callback and the current
+## object may be changed.
 ##
-##@seealso{gcbo, gcf, gca, get, set}
-##@end deftypefn
+## @seealso{gcbo, gca, gcf, gcbf, get, set}
+## @end deftypefn
 
 function h = gco ()
 
   h = get (get (0, "currentfigure"), "currentobject");
 
 endfunction
+
diff --git a/scripts/plot/ginput.m b/scripts/plot/util/ginput.m
rename from scripts/plot/ginput.m
rename to scripts/plot/util/ginput.m
--- a/scripts/plot/ginput.m
+++ b/scripts/plot/util/ginput.m
@@ -12,38 +12,48 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{x}, @var{y}, @var{buttons}] =} ginput (@var{n})
-## Return which mouse buttons were pressed and keys were hit on the current
-## figure.  If @var{n} is defined, then wait for @var{n} mouse clicks
-## before returning.  If @var{n} is not defined, then @code{ginput} will
-## loop until the return key @key{RET} is pressed.
+## @deftypefn  {Function File} {[@var{x}, @var{y}, @var{buttons}] =} ginput (@var{n})
+## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{buttons}] =} ginput ()
+## Return the position and type of mouse button clicks and/or key strokes
+## in the current figure window.
+##
+## If @var{n} is defined, then capture @var{n} events before returning.
+## When @var{n} is not defined @code{ginput} will loop until the return key
+## @key{RET} is pressed.
+##
+## The return values @var{x}, @var{y} are the coordinates where the mouse
+## was clicked in the units of the current axes.  The return value @var{button}
+## is 1, 2, or 3 for the left, middle, or right button.  If a key is pressed
+## the ASCII value is returned in @var{button}.
+## @seealso{gtext, waitforbuttonpress}
 ## @end deftypefn
 
 function varargout = ginput (n)
 
   if (nargin > 1)
     print_usage ();
   endif
 
   f = gcf ();
+  a = gca ();  # Create an axis, if necessary
   drawnow ();
-  toolkit = (get (f, "__graphics_toolkit__"));
+  toolkit = get (f, "__graphics_toolkit__");
 
   varargout = cell (1, nargout);
   if (nargin == 0)
-    [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f);
+    [varargout{:}] = feval (["__" toolkit "_ginput__"], f);
   else
-    [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f, n);
+    [varargout{:}] = feval (["__" toolkit "_ginput__"], f, n);
   endif
 
 endfunction
 
 
 ## Remove from test statistics.  No real tests possible.
 %!test
 %! assert (1);
diff --git a/scripts/plot/gnuplot_binary.in b/scripts/plot/util/gnuplot_binary.in
rename from scripts/plot/gnuplot_binary.in
rename to scripts/plot/util/gnuplot_binary.in
--- a/scripts/plot/gnuplot_binary.in
+++ b/scripts/plot/util/gnuplot_binary.in
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {[@var{prog}, @var{args}] =} gnuplot_binary ()
 ## @deftypefnx {Loadable Function} {[@var{old_prog}, @var{old_args}] =} gnuplot_binary (@var{new_prog}, @var{arg1}, @dots{})
 ## Query or set the name of the program invoked by the plot command
 ## when the graphics toolkit is set to "gnuplot".  Additional arguments to
 ## pass to the external plotting program may also be given.
-## The default value is @code{"gnuplot"} with no additional arguments.
+## The default value is @qcode{"gnuplot"} with no additional arguments.
 ## @xref{Installation}.
 ## @seealso{graphics_toolkit}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [prog, args] = gnuplot_binary (new_prog, varargin)
 
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/util/graphics_toolkit.m
rename from scripts/plot/graphics_toolkit.m
rename to scripts/plot/util/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/util/graphics_toolkit.m
@@ -16,33 +16,27 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
 ## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Return the default graphics toolkit.  The default graphics toolkit value
-## is assigned to new figures.
+## Query or set the default graphics toolkit which is assigned to new figures.
 ## 
-## @code{graphics_toolkit (@var{hlist})}
-## 
-## Return the graphics toolkits for the figures with handles @var{hlist}.
-## 
-## @code{graphics_toolkit (@var{name})}
+## With no inputs, return the current default graphics toolkit.  If the input
+## is a list of figure graphic handles, @var{hlist}, then return the name
+## of the graphics toolkit in use for each figure.
 ## 
-## Set the default graphics toolkit to @var{name}.  If the toolkit is not
-## already loaded, it is initialized by calling the function
-## @code{__init_@var{name}__}.
-## 
-## @code{graphics_toolkit (@var{hlist}, @var{name})}
-##
-## Set the graphics toolkit for the figures with handles @var{hlist} to
-## @var{name}.
+## When called with a single input @var{name} set the default graphics toolkit
+## to @var{name}.  If the toolkit is not already loaded, it is initialized by
+## calling the function @code{__init_@var{name}__}.  If the first input
+## is a list of figure handles, @var{hlist}, then the graphics toolkit is set
+## to @var{name} for these figures only.
 ## 
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
@@ -53,17 +47,17 @@ function retval = graphics_toolkit (name
   endif
 
   if (nargin == 0)
     return;
   elseif (nargin == 1)
     if (all (isfigure (name)))
       hlist = name;
       retval = get (hlist, "__graphics_toolkit__");
-      return
+      return;
     elseif (! ischar (name))
       error ("graphics_toolkit: invalid graphics toolkit NAME");
     endif
   elseif (nargin == 2)
     ## Swap input arguments
     [hlist, name] = deal (name, hlist);
     if (! all (isfigure (hlist)))
       error ("graphics_toolkit: invalid figure handle list HLIST");
@@ -85,28 +79,28 @@ function retval = graphics_toolkit (name
     set (hlist, "__graphics_toolkit__", name);
   endif
 
 endfunction
 
 
 %!testif HAVE_FLTK
 %! unwind_protect
-%!   hf = figure ("visible", "off"); 
+%!   hf = figure ("visible", "off");
 %!   toolkit = graphics_toolkit ();
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
-%!   graphics_toolkit (hf, "fltk"); 
+%!   graphics_toolkit (hf, "fltk");
 %!   assert (graphics_toolkit (hf), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
 %! old_toolkit = graphics_toolkit ();
-%! switch old_toolkit
+%! switch (old_toolkit)
 %!   case {"gnuplot"}
 %!     new_toolkit = "fltk";
 %!   otherwise
 %!     new_toolkit = "gnuplot";
 %! endswitch
 %! assert (graphics_toolkit (new_toolkit), old_toolkit);
 %! assert (graphics_toolkit (old_toolkit), new_toolkit);
 
diff --git a/scripts/plot/hdl2struct.m b/scripts/plot/util/hdl2struct.m
rename from scripts/plot/hdl2struct.m
rename to scripts/plot/util/hdl2struct.m
--- a/scripts/plot/hdl2struct.m
+++ b/scripts/plot/util/hdl2struct.m
@@ -13,19 +13,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} hdl2struct (@var{h})
 ## Return a structure, @var{s}, whose fields describe the properties
 ## of the object, and its children, associated with the handle, @var{h}.
-## The fields of the structure, @var{s}, are "type", "handle", "properties",
-## "children" and "special".
-## @seealso{findobj, get, set, struct2hdl}
+##
+## The fields of the structure @var{s} are @qcode{"type"}, @qcode{"handle"},
+## @qcode{"properties"}, @qcode{"children"}, and @qcode{"special"}.
+## @seealso{struct2hdl, findobj}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
 function s = hdl2struct (h)
 
   if (nargin != 1 || !ishandle (h))
@@ -141,17 +142,17 @@ function prpstr = getprops (h)
             "interruptible", "parent", "selected" ,...
             "selectionhighlight", "type", "__modified__", ...
             "uicontextmenu", "__graphics_toolkit__", "currentaxes", ...
             "currentcharacter", "currentobject","tightinset", ...
             "currentpoint", "extent"};
 
   nflds = length (fields);
   ii = 0;
-  while nflds
+  while (nflds)
     prop = fields{nflds};
     val = obj.(fields{nflds});
     ii++;
     if (! any (strcmp (prop, forbid)))
       prpstr.(prop) = val;
     endif
     nflds--;
   endwhile
@@ -163,8 +164,9 @@ function prpstr = getprops (h)
       prpstr.(hidden{ii}) = get (h, hidden{ii});
     endif
   endfor
 
 endfunction
 
 
 ## FIXME: need validation tests
+
diff --git a/scripts/plot/hggroup.m b/scripts/plot/util/hggroup.m
rename from scripts/plot/hggroup.m
rename to scripts/plot/util/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/util/hggroup.m
@@ -13,36 +13,52 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hggroup ()
-## @deftypefnx {Function File} {} hggroup (@var{h})
+## @deftypefnx {Function File} {} hggroup (@var{hax})
 ## @deftypefnx {Function File} {} hggroup (@dots{}, @var{property}, @var{value}, @dots{})
-## Create group object with parent @var{h}.  If no parent is specified,
-## the group is created in the current axes.  Return the handle of the
-## group object created.
+## @deftypefnx {Function File} {@var{h} =} hggroup (@dots{})
+## Create handle graphics group object with axes parent @var{hax}.
+##
+## If no parent is specified, the group is created in the current axes.
+##
+## Multiple property/value pairs may be specified for the hggroup, but they
+## must appear in pairs.
 ##
-## Multiple property-value pairs may be specified for the group, but they
-## must appear in pairs.
+## The optional return value @var{h} is a graphics handle to the created
+## hggroup object.
+##
+## Programming Note: An hggroup is a way to group base graphics objects such
+## as line objects or patch objects into a single unit which can react
+## appropriately.  For example, the individual lines of a contour plot are
+## collected into a single hggroup so that they can be made visible/invisible
+## with a single command, @code{set (hg_handle, "visible", "off")}.
+## 
+## @seealso{addproperty, addlistener}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function h = hggroup (varargin)
 
-  [ax, varargin] = __plt_get_axis_arg__ ("hggroup", varargin{:});
-
-  tmp = __go_hggroup__ (ax, varargin{:});
+  [hax, varargin] = __plt_get_axis_arg__ ("hggroup", varargin{:});
+  
+  if (isempty (hax))
+    hax = gca ();
+  endif
+  
+  htmp = __go_hggroup__ (hax, varargin{:});
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
diff --git a/scripts/plot/hold.m b/scripts/plot/util/hold.m
rename from scripts/plot/hold.m
rename to scripts/plot/util/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/util/hold.m
@@ -13,101 +13,123 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} hold
-## @deftypefnx {Command} {} hold @var{state}
+## @deftypefnx {Command} {} hold on
+## @deftypefnx {Command} {} hold off
+## @deftypefnx {Command} {} hold all
 ## @deftypefnx {Function File} {} hold (@var{hax}, @dots{})
-## Toggle or set the "hold" state of the plotting engine which determines
-## whether new graphic objects are added to the plot or replace the existing
-## objects.
+## Toggle or set the @qcode{"hold"} state of the plotting engine which
+## determines whether new graphic objects are added to the plot or replace
+## the existing objects.
 ##
 ## @table @code
 ## @item hold on
 ## Retain plot data and settings so that subsequent plot commands are displayed
 ## on a single graph.
 ##
 ## @item hold all
-## Retain plot line color, line style, data and settings so that subsequent
+## Retain plot line color, line style, data, and settings so that subsequent
 ## plot commands are displayed on a single graph with the next line color and
 ## style.
 ##
 ## @item hold off
-## Clear plot and restore default graphics settings before each new plot
-## command.  (default).
+## Restore default graphics settings which clear the graph and reset axis
+## properties before each new plot command.  (default).
 ##
 ## @item hold
 ## Toggle the current hold state.
 ## @end table
 ##
 ## When given the additional argument @var{hax}, the hold state is modified
-## only for the given axis handle.
+## for this axis rather than the current axes returned by @code{gca}.
 ##
 ## To query the current hold state use the @code{ishold} function.
-## @seealso{ishold, cla, newplot, clf}
+## @seealso{ishold, cla, clf, newplot}
 ## @end deftypefn
 
 function hold (varargin)
 
-  if (nargin > 0 && numel (varargin{1}) == 1 && ishandle (varargin{1})
-      && strcmp (get (varargin{1}, "type"), "axes"))
-    [ax, varargin, nargs] = __plt_get_axis_arg__ ("hold", varargin{:});
-    fig = get (ax, "parent");
+  if (nargin > 0 && isscalar (varargin{1}) && isaxes (varargin{1}))
+    hax = varargin{1};
+    varargin(1) = [];
+    nargs = numel (varargin);
+    ## FIXME: Should this be ancestor (hax, "parent")?
+    hfig = get (hax, "parent");
   elseif (nargin > 0 && numel (varargin{1}) > 1 && ishandle (varargin{1}))
     print_usage ();
   else
-    ax = gca ();
-    fig = gcf ();
+    hax = gca ();
+    hfig = gcf ();
     nargs = numel (varargin);
   endif
 
   hold_all = false;
   if (nargs == 0)
-    turn_hold_off = ishold (ax);
+    turn_hold_off = ishold (hax);
   elseif (nargs == 1)
-    state = varargin{1};
-    if (ischar (state))
-      if (strcmpi (state, "off"))
+    state = tolower (varargin{1});
+    switch (state)
+      case "off"
         turn_hold_off = true;
-      elseif (strcmpi (state, "all"))
+      case "all"
         turn_hold_off = false;
         hold_all = true;
-      elseif (strcmpi (state, "on"))
+      case "on"
         turn_hold_off = false;
-      else
+      otherwise
         error ("hold: invalid hold STATE");
-      endif
-    endif
+    endswitch
   else
     print_usage ();
   endif
 
   if (turn_hold_off)
-    set (ax, "nextplot", "replace");
+    set (hax, "nextplot", "replace");
   else
-    set (ax, "nextplot", "add");
-    set (fig, "nextplot", "add");
+    set (hax, "nextplot", "add");
+    set (hfig, "nextplot", "add");
   endif
-  set (ax, "__hold_all__", hold_all);
+  set (hax, "__hold_all__", hold_all);
 
 endfunction
 
 
 %!demo
 %! clf;
+%! t = linspace (0, 2*pi, 100);
+%! plot (t, sin (t));
+%! hold on;
+%! plot (t, cos (t));
+%! title ({'hold on', '2 plots shown on same graph'});
+%! hold off;
+
+%!demo
+%! clf;
+%! t = linspace (0, 2*pi, 100);
+%! plot (t, sin (t));
+%! hold all;
+%! plot (t, cos (t));
+%! title ({'hold all', '2 plots shown on same graph with linestyle also preserved'});
+%! hold off;
+
+%!demo
+%! clf;
 %! A = rand (100);
-%! [X, Y] = find (A > 0.9);
+%! [X, Y] = find (A > 0.95);
 %! imshow (A);
 %! hold on;
 %! plot (X, Y, 'o');
 %! hold off;
+%! title ('hold with image and plot');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! hold on;
 %! imagesc (1 ./ hilb (4));
 %! plot (1:4, '-s');
 %! hold off;
@@ -138,33 +160,33 @@ endfunction
 %! hold on;
 %! plot (x(:), y(:), '^');
 %! patch ([-1.0 1.0 1.0 -1.0 -1.0], [-1.0 -1.0 1.0 1.0 -1.0], 'red');
 %! xlim ([-2.0 2.0]);
 %! ylim ([-2.0 2.0]);
 %! colorbar ('SouthOutside');
 %! title ('Test script for some plot functions');
 
-##hold on
+## hold on test
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1], "black");
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 3);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-##hold off
+## hold off test
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1], "black");
diff --git a/scripts/plot/util/isaxes.m b/scripts/plot/util/isaxes.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/util/isaxes.m
@@ -0,0 +1,56 @@
+## Copyright (C) 2013 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} isaxes (@var{h})
+## Return true if @var{h} is an axes graphics handle and false otherwise.
+##
+## If @var{h} is a matrix then return a logical array which is true where
+## the elements of @var{h} are axes graphics handles and false where
+## they are not.
+## @seealso{isaxes, ishandle}
+## @end deftypefn
+
+## Author: jwe
+
+function retval = isaxes (h)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
+  hlist = ishandle (h);
+  if (any (hlist))
+    retval(hlist) = strcmp (get (h(hlist), "type"), "axes");
+  else
+    retval = hlist;
+  endif
+
+endfunction
+
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   hax = axes ();
+%!   assert (isaxes (hax));
+%!   assert (! isaxes (-hax));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
diff --git a/scripts/plot/isfigure.m b/scripts/plot/util/isfigure.m
rename from scripts/plot/isfigure.m
rename to scripts/plot/util/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/util/isfigure.m
@@ -13,29 +13,37 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isfigure (@var{h})
-## Return true if @var{h} is a graphics handle that contains a figure
-## object.
-## @seealso{ishandle}
+## Return true if @var{h} is a figure graphics handle and false otherwise.
+##
+## If @var{h} is a matrix then return a logical array which is true where
+## the elements of @var{h} are figure graphics handles and false where
+## they are not.
+## @seealso{isaxes, ishandle}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isfigure (h)
 
-  if (nargin == 1)
-    retval = (ishandle (h) && strcmp (get (h, "type"), "figure"));
+  if (nargin != 1)
+    print_usage ();
+  endif
+
+  hlist = ishandle (h);
+  if (any (hlist))
+    retval(hlist) = strcmp (get (h(hlist), "type"), "figure");
   else
-    print_usage ();
+    retval = hlist;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/util/ishghandle.m
rename from scripts/plot/ishghandle.m
rename to scripts/plot/util/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/util/ishghandle.m
@@ -13,19 +13,20 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ishghandle (@var{h})
-## Return true if @var{h} is a graphics handle and false otherwise.  This
-## function is equivalent to @code{ishandle} and is provided for compatibility
-## with @sc{matlab}.
+## Return true if @var{h} is a graphics handle and false otherwise.
+##
+## This function is equivalent to @code{ishandle} and is provided for
+## compatibility with @sc{matlab}.
 ## @seealso{ishandle}
 ## @end deftypefn
 
 function retval = ishghandle (h)
   ## This function is just included for compatibility as Octave has
   ## no simulink equivalent.
   retval = ishandle (h);
 endfunction
@@ -46,17 +47,17 @@ endfunction
 %!   assert (ishghandle (p));
 %!   assert (! ishghandle (-p));
 %!   s = surface;
 %!   assert (ishghandle (s));
 %!   assert (! ishghandle (-s));
 %!   t = text;
 %!   assert (ishghandle (t));
 %!   assert (! ishghandle (-t));
-%!   i = image;
+%!   i = image ([1]);
 %!   assert (ishghandle (i));
 %!   assert (! ishghandle (-i));
 %!   hg = hggroup;
 %!   assert (ishghandle (hg));
 %!   assert (! ishghandle (-hg));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/ishold.m b/scripts/plot/util/ishold.m
rename from scripts/plot/ishold.m
rename to scripts/plot/util/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/util/ishold.m
@@ -13,50 +13,53 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} ishold
-## @deftypefnx {Function File} {} ishold (@var{h})
+## @deftypefnx {Function File} {} ishold (@var{hax})
+## @deftypefnx {Function File} {} ishold (@var{hfig})
 ## Return true if the next plot will be added to the current plot, or
 ## false if the plot device will be cleared before drawing the next plot.
 ##
-## Optionally, operate on the graphics handle @var{h} rather than the current
-## plot.
-## @seealso{hold}
+## If the first argument is an axes handle @var{hax} or figure handle
+## @var{hfig} then operate on this plot rather than the current one.
+## @seealso{hold, newplot}
 ## @end deftypefn
 
 function retval = ishold (h)
 
+  if (nargin > 1)
+    print_usage ();
+  endif
+
   if (nargin == 0)
     fig = gcf ();
     ax = get (fig, "currentaxes");
-  elseif (nargin == 1)
+  else
     if (ishandle (h))
-      if (isfigure (h))
-        ax = get (h, "currentaxes");
+      if (strcmp (get (h, "type"), "figure"))
         fig = h;
-      elseif (strcmpi (get (h, "type"), "axes"))
+        ax = get (fig, "currentaxes");
+      elseif (strcmp (get (h, "type"), "axes"))
         ax = h;
-        fig = get (h, "parent");
+        fig = get (ax, "parent");
       else
-        error ("ishold: expecting argument to be axes or figure graphics handle");
+        error ("ishold: H must be an axes or figure graphics handle");
       endif
     else
-      error ("ishold: expecting argument to be axes or figure graphics handle");
+      error ("ishold: H must be an axes or figure graphics handle");
     endif
-  else
-    print_usage ();
   endif
 
-  retval = (strcmpi (get (fig, "nextplot"), "add")
-            && ! isempty (ax) && strcmpi (get (ax, "nextplot"), "add"));
+  retval = (strcmp (get (fig, "nextplot"), "add")
+            && ! isempty (ax) && strcmp (get (ax, "nextplot"), "add"));
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (! ishold);
diff --git a/scripts/plot/isprop.m b/scripts/plot/util/isprop.m
rename from scripts/plot/isprop.m
rename to scripts/plot/util/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -12,43 +12,50 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{res} =} isprop (@var{h}, @var{prop})
+## @deftypefn {Function File} {@var{res} =} isprop (@var{h}, "@var{prop}")
 ## Return true if @var{prop} is a property of the object with handle @var{h}.
+##
+## @var{h} may also be an array of handles in which case @var{res} will be a
+## logical array indicating whether each handle has the property @var{prop}.
 ## @seealso{get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
 function res = isprop (h, prop)
-  ## Check input
-  if (nargin < 1 || nargin > 2)
+
+  if (nargin != 2)
     print_usage ();
   endif
 
   if (! all (ishandle (h)))
-    error ("isprop: first input argument must be a handle");
+    error ("isprop: H must be a graphics handle or vector of handles");
   elseif (! ischar (prop))
-    error ("isprop: second input argument must be string");
+    error ("isprop: PROP name must be a string");
   endif
 
   res = false (size (h));
-  for n = 1:numel (res)
-    res(n) = true;
+  for i = 1:numel (res)
     try
-      v = get (h(n), prop);
-    catch
-      res(n) = false;
+      v = get (h(i), prop);
+      res(i) = true;
     end_try_catch
   endfor
 endfunction
 
 
 %!assert (isprop (0, "foobar"), false)
 %!assert (isprop (0, "screenpixelsperinch"), true)
 %!assert (isprop (zeros (2, 3), "visible"), true (2, 3))
 
+%!error isprop ()
+%!error isprop (1)
+%!error isprop (1,2,3)
+%!error <H must be a graphics handle> isprop ({1}, "visible")
+%!error <PROP name must be a string> isprop (0, {"visible"})
+
diff --git a/scripts/plot/linkprop.m b/scripts/plot/util/linkprop.m
rename from scripts/plot/linkprop.m
rename to scripts/plot/util/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/util/linkprop.m
@@ -12,23 +12,26 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{hlink} =} linkprop (@var{h}, @var{prop})
+## @deftypefn  {Function File} {@var{hlink} =} linkprop (@var{h}, @var{prop})
+## @deftypefnx {Function File} {@var{hlink} =} linkprop (@var{h}, @{@var{prop1}, @var{prop2}, @dots{}@})
 ## Link graphics object properties, such that a change in one is
-## propagated to the others.  The properties to link are given as a
-## string of cell string array by @var{prop} and the objects containing
-## these properties by the handle array @var{h}.
+## propagated to the others.
 ##
-## An example of the use of linkprop is
+## @var{prop} can be a string for a single property, or a cell array of strings
+## for multiple properties.  @var{h} is an array of graphics handles which
+## will have their properties linked.
+##
+## An example of the use of @code{linkprop} is
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
 ## subplot (1,2,1);
 ## h1 = plot (x, sin (x));
 ## subplot (1,2,2);
 ## h2 = plot (x, cos (x));
@@ -91,8 +94,9 @@ function delete_prop (h, d, hlist, prop)
       warn = true;
       break;
     endif
   endfor
   if (warn)
     warning ("linkprop: can not remove linked properties");
   endif
 endfunction
+
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/util/meshgrid.m
rename from scripts/plot/meshgrid.m
rename to scripts/plot/util/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/util/meshgrid.m
@@ -12,66 +12,89 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{xx}, @var{yy}, @var{zz}] =} meshgrid (@var{x}, @var{y}, @var{z})
-## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x}, @var{y})
+## @deftypefn  {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x}, @var{y})
+## @deftypefnx {Function File} {[@var{xx}, @var{yy}, @var{zz}] =} meshgrid (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x})
-## Given vectors of @var{x} and @var{y} and @var{z} coordinates, and
-## returning 3 arguments, return three-dimensional arrays corresponding
-## to the @var{x}, @var{y}, and @var{z} coordinates of a mesh.  When
-## returning only 2 arguments, return matrices corresponding to the
-## @var{x} and @var{y} coordinates of a mesh.  The rows of @var{xx} are
-## copies of @var{x}, and the columns of @var{yy} are copies of @var{y}.
-## If @var{y} is omitted, then it is assumed to be the same as @var{x},
-## and @var{z} is assumed the same as @var{y}.
-## @seealso{mesh, contour}
+## @deftypefnx {Function File} {[@var{xx}, @var{yy}, @var{zz}] =} meshgrid (@var{x})
+## Given vectors of @var{x} and @var{y} coordinates, return matrices @var{xx}
+## and @var{yy} corresponding to a full 2-D grid.
+##
+## The rows of @var{xx} are copies of @var{x}, and the columns of @var{yy} are
+## copies of @var{y}.  If @var{y} is omitted, then it is assumed to be the same
+## as @var{x}.
+##
+## If the optional @var{z} input is given, or @var{zz} is requested, then the
+## output will be a full 3-D grid.
+##
+## @code{meshgrid} is most frequently used to produce input for a 2-D or 3-D
+## function that will be plotted.  The following example creates a surface
+## plot of the ``sombrero'' function.
+##
+## @example
+## @group
+## f = @@(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
+## range = linspace (-8, 8, 41);
+## [@var{X}, @var{Y}] = meshgrid (range, range);  
+## Z = f (X, Y);
+## surf (X, Y, Z);
+## @end group
+## @end example
+##
+## Programming Note: @code{meshgrid} is restricted to 2-D or 3-D grid
+## generation.  The @code{ndgrid} function will generate 1-D through N-D
+## grids.  However, the functions are not completely equivalent.  If @var{x}
+## is a vector of length M and @var{y} is a vector of length N, then
+## @code{meshgrid} will produce an output grid which is NxM@.  @code{ndgrid}
+## will produce an output which is @nospell{MxN} (transpose) for the same
+## input.  Some core functions expect @code{meshgrid} input and others expect
+## @code{ndgrid} input.  Check the documentation for the function in question
+## to determine the proper input format.
+## @seealso{ndgrid, mesh, contour, surf}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xx, yy, zz] = meshgrid (x, y, z)
 
   if (nargin == 0 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin < 2)
     y = x;
   endif
 
-  ## Use repmat to ensure that the result values have the same type as
-  ## the arguments.
+  ## Use repmat to ensure that result values have the same type as the inputs
 
   if (nargout < 3)
-    if (isvector (x) && isvector (y))
-      xx = repmat (x(:).', length (y), 1);
-      yy = repmat (y(:), 1, length (x));
-    else
-      error ("meshgrid: arguments must be vectors");
+    if (! (isvector (x) && isvector (y)))
+      error ("meshgrid: X and Y must be vectors");
     endif
+    xx = repmat (x(:).', length (y), 1);
+    yy = repmat (y(:), 1, length (x));
   else
     if (nargin < 3)
       z = y;
     endif
-    if (isvector (x) && isvector (y) && isvector (z))
-       lenx = length (x);
-       leny = length (y);
-       lenz = length (z);
-       xx = repmat (repmat (x(:).', leny, 1), [1, 1, lenz]);
-       yy = repmat (repmat (y(:), 1, lenx), [1, 1, lenz]);
-       zz = reshape (repmat (z(:).', lenx*leny, 1)(:), leny, lenx, lenz);
-    else
-      error ("meshgrid: arguments must be vectors");
+    if (! (isvector (x) && isvector (y) && isvector (z)))
+      error ("meshgrid: X, Y, and Z must be vectors");
     endif
+    lenx = length (x);
+    leny = length (y);
+    lenz = length (z);
+    xx = repmat (repmat (x(:).', leny, 1), [1, 1, lenz]);
+    yy = repmat (repmat (y(:), 1, lenx), [1, 1, lenz]);
+    zz = reshape (repmat (z(:).', lenx*leny, 1)(:), leny, lenx, lenz);
   endif
 
 endfunction
 
 
 %!test
 %! x = 1:2;
 %! y = 1:3;
@@ -98,8 +121,15 @@ endfunction
 %! [XX1, YY1] = meshgrid (x, x);
 %! [XX2, YY2] = meshgrid (x);
 %! assert (size_equal (XX1, XX2, YY1, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 3]);
 %! assert (XX1, XX2);
 %! assert (YY1, YY2);
 
+%% Test input validation
+%!error meshgrid ()
+%!error meshgrid (1,2,3,4)
+%!error <X and Y must be vectors> meshgrid (ones (2,2), 1:3)
+%!error <X and Y must be vectors> meshgrid (1:3, ones (2,2))
+%!error <X, Y, and Z must be vectors> [X,Y,Z] = meshgrid (1:3, 1:3, ones (2,2))
+
diff --git a/scripts/plot/util/module.mk b/scripts/plot/util/module.mk
new file mode 100644
--- /dev/null
+++ b/scripts/plot/util/module.mk
@@ -0,0 +1,80 @@
+FCN_FILE_DIRS += plot
+
+plot_util_GEN_FCN_FILES = \
+  plot/util/gnuplot_binary.m
+
+GEN_FCN_FILES += $(plot_util_GEN_FCN_FILES)
+
+plot_util_PRIVATE_FCN_FILES = \
+  plot/util/private/__add_default_menu__.m \
+  plot/util/private/__fltk_ginput__.m \
+  plot/util/private/__fltk_print__.m \
+  plot/util/private/__ghostscript__.m \
+  plot/util/private/__gnuplot_get_var__.m \
+  plot/util/private/__gnuplot_ginput__.m \
+  plot/util/private/__gnuplot_has_feature__.m \
+  plot/util/private/__gnuplot_has_terminal__.m \
+  plot/util/private/__gnuplot_open_stream__.m \
+  plot/util/private/__gnuplot_print__.m \
+  plot/util/private/__gnuplot_version__.m \
+  plot/util/private/__go_draw_axes__.m \
+  plot/util/private/__go_draw_figure__.m \
+  plot/util/private/__print_parse_opts__.m \
+  plot/util/private/__tight_eps_bbox__.m
+
+plot_util_FCN_FILES = \
+  plot/util/__actual_axis_position__.m \
+  plot/util/allchild.m \
+  plot/util/ancestor.m \
+  plot/util/axes.m \
+  plot/util/cla.m \
+  plot/util/clf.m \
+  plot/util/close.m \
+  plot/util/closereq.m \
+  plot/util/colstyle.m \
+  plot/util/copyobj.m \
+  plot/util/__default_plot_options__.m \
+  plot/util/figure.m \
+  plot/util/findall.m \
+  plot/util/findfigs.m \
+  plot/util/findobj.m \
+  plot/util/gca.m \
+  plot/util/gcbf.m \
+  plot/util/gcbo.m \
+  plot/util/gcf.m \
+  plot/util/gco.m \
+  plot/util/ginput.m \
+  plot/util/__gnuplot_drawnow__.m \
+  plot/util/graphics_toolkit.m \
+  plot/util/hdl2struct.m \
+  plot/util/hggroup.m \
+  plot/util/hold.m \
+  plot/util/isaxes.m \
+  plot/util/isfigure.m \
+  plot/util/ishghandle.m \
+  plot/util/ishold.m \
+  plot/util/isprop.m \
+  plot/util/linkprop.m \
+  plot/util/meshgrid.m \
+  plot/util/ndgrid.m \
+  plot/util/newplot.m \
+  plot/util/__next_line_color__.m \
+  plot/util/__next_line_style__.m \
+  plot/util/__plt_get_axis_arg__.m \
+  plot/util/__pltopt__.m \
+  plot/util/printd.m \
+  plot/util/print.m \
+  plot/util/refreshdata.m \
+  plot/util/refresh.m \
+  plot/util/saveas.m \
+  plot/util/shg.m \
+  plot/util/struct2hdl.m \
+  plot/util/subplot.m \
+  $(plot_util_PRIVATE_FCN_FILES)
+
+FCN_FILES += $(plot_util_FCN_FILES)
+
+PKG_ADD_FILES += plot/util/PKG_ADD
+
+DIRSTAMP_FILES += plot/util/$(octave_dirstamp)
+
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/util/ndgrid.m
rename from scripts/plot/ndgrid.m
rename to scripts/plot/util/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/util/ndgrid.m
@@ -14,24 +14,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{y1}, @var{y2}, @dots{}, @var{y}n] =} ndgrid (@var{x1}, @var{x2}, @dots{}, @var{x}n)
 ## @deftypefnx {Function File} {[@var{y1}, @var{y2}, @dots{}, @var{y}n] =} ndgrid (@var{x})
-## Given n vectors @var{x1}, @dots{} @var{x}n, @code{ndgrid} returns
+## Given n vectors @var{x1}, @dots{}, @var{x}n, @code{ndgrid} returns
 ## n arrays of dimension n.  The elements of the i-th output argument
 ## contains the elements of the vector @var{x}i repeated over all
 ## dimensions different from the i-th dimension.  Calling ndgrid with
-## only one input argument @var{x} is equivalent of calling ndgrid with
+## only one input argument @var{x} is equivalent to calling ndgrid with
 ## all n input arguments equal to @var{x}:
 ##
 ## [@var{y1}, @var{y2}, @dots{}, @var{y}n] = ndgrid (@var{x}, @dots{}, @var{x})
+##
+## Programming Note: @code{ndgrid} is very similar to the function
+## @code{meshgrid} except that the first two dimensions are transposed in
+## comparison to @code{meshgrid}.  Some core functions expect @code{meshgrid}
+## input and others expect @code{ndgrid} input.  Check the documentation for
+## the function in question to determine the proper input format.
 ## @seealso{meshgrid}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth@marine.usf.edu>
 
 function varargout = ndgrid (varargin)
 
   if (nargin == 0)
diff --git a/scripts/plot/newplot.m b/scripts/plot/util/newplot.m
rename from scripts/plot/newplot.m
rename to scripts/plot/util/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/util/newplot.m
@@ -13,74 +13,182 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} newplot ()
-## @deftypefnx {Function File} {@var{h} =} newplot ()
-## Prepare graphics engine to produce a new plot.  This function is
-## called at the beginning of all high-level plotting functions.
-## It is not normally required in user programs.
+## @deftypefnx {Function File} {} newplot (@var{hfig})
+## @deftypefnx {Function File} {} newplot (@var{hax})
+## @deftypefnx {Function File} {@var{hax} =} newplot (@dots{})
+## Prepare graphics engine to produce a new plot.
+##
+## This function is called at the beginning of all high-level plotting
+## functions.  It is not normally required in user programs.  @code{newplot}
+## queries the @qcode{"NextPlot"} field of the current figure and axis to
+## determine what to do.
+##
+## @multitable @columnfractions .25 .75
+## @headitem Figure NextPlot @tab Action
+## @item @qcode{"new"} @tab Create a new figure and make it the current figure.
+##
+## @item @qcode{"add"} (default) @tab Add new graphic objects to the current figure.
+##
+## @item @qcode{"replacechildren"} @tab Delete child objects whose HandleVisibility is
+## set to @qcode{"on"}.  Set NextPlot property to @qcode{"add"}.  This
+## typically clears a figure, but leaves in place hidden objects such as
+## menubars.  This is equivalent to @code{clf}.
 ##
-## The optional return value @var{h} is a graphics handle to the created
-## axes (not figure).
+## @item @qcode{"replace"} @tab Delete all child objects of the figure and
+## reset all figure properties to their defaults.  However, the following
+## four properties are not reset: Position, Units, PaperPosition, PaperUnits.
+##  This is equivalent to @code{clf reset}.
+## @end multitable
+##
+## @multitable @columnfractions .25 .75
+## @headitem Axis NextPlot @tab Action
+## @item @qcode{"add"} @tab Add new graphic objects to the current axes.  This is
+## equivalent to @code{hold on}.
+##
+## @item @qcode{"replacechildren"} @tab Delete child objects whose HandleVisibility is
+## set to @qcode{"on"}, but leave axis properties unmodified.  This typically
+## clears a plot, but preserves special settings such as log scaling for
+## axes.  This is equivalent to @code{cla}.
+##
+## @item @qcode{"replace"} (default) @tab Delete all child objects of the
+## axis and reset all axis properties to their defaults.  However, the
+## following properties are not reset: Position, Units.  This is equivalent
+## to @code{cla reset}.
+## @end multitable
+##
+## If the optional input @var{hfig} or @var{hax} is given then prepare the
+## specified figure or axes rather than the current figure and axes.
+##
+## The optional return value @var{hax} is a graphics handle to the created
+## axes object (not figure).
+##
+## @strong{Caution:} Calling @code{newplot} may change the current figure and
+## current axis.
 ## @end deftypefn
 
-function h = newplot ()
+## FIXME: The Matlab function takes an optional list of file handles, hsave,
+##        which are not deleted when the figure and axes are prepared.
+##        I'm sure there is a good reason for that, but coding such
+##        compatibility is really tricky and doesn't serve much purpose since
+##        newplot is nearly exclusively used by Octave's internal plotting
+##        functions.  In Octave's case the argument is almost always null,
+##        or occasionally the axis handle to plot into.
+
+function hax = newplot (hsave = [])
+
+  if (nargin > 1)
+    print_usage ();
+  endif
 
-  if (nargin == 0)
+  cf = [];
+  ca = [];
+
+  if (! isempty (hsave))
+    ## Find the first valid axes 
+    ca = ancestor (hsave, "axes", "toplevel"); 
+    ca = ca(find (ca, 1));
+    ## Next, find the figure associated with any axis found
+    if (! isempty (ca))
+      cf = ancestor (ca, "figure", "toplevel");
+    else
+      cf = ancestor (hsave, "figure", "toplevel"); 
+      cf = cf(find (cf, 1));
+    endif
+  endif
+
+  if (isempty (cf))
+    ## get current figure, or create a new one if necessary
     cf = gcf ();
-    fnp = get (cf, "nextplot");
-    switch (fnp)
-      ## FIXME -- probably we should do more than validate the nextplot
-      ## property value...
-      case "new"
-      case "add"
-      case "replacechildren"
-        delete (get (cf, "children"));
-      case "replace"
-      otherwise
-        error ("newplot: unrecognized nextplot property for current figure");
-    endswitch
+  else
+    ## switch to figure provided without causing other updates
+    set (0, "currentfigure", cf);
+  endif
+
+  fnp = get (cf, "nextplot");
+  switch (fnp)
+    case "add"
+      ## Default case.  Doesn't require action.
+    case "new"
+      ## Ordinarily, create a new figure to hold plot.
+      ## But, if user has requested preparing a specific axis, then
+      ## use the existing figure to hold the requested axis.
+      if (isempty (ca))
+        cf = figure ();
+      endif
+    case "replacechildren"
+      kids = get (cf, "children");
+      if (! isempty (ca))
+        kids(kids == ca) = [];
+      endif
+      delete (kids);
+    case "replace"
+      kids = allchild (cf);
+      if (! isempty (ca))
+        kids(kids == ca) = [];
+      endif
+      delete (kids);
+      reset (cf);
+  endswitch
+  set (cf, "nextplot", "add");  # Matlab compatibility
+
+  if (isempty (ca))
     ca = gca ();
-    anp = get (ca, "nextplot");
-    if (strcmp (get (ca, "__hold_all__"), "off"))
-      __next_line_color__ (true);
-      __next_line_style__ (true);
-    else
-      __next_line_color__ (false);
-      __next_line_style__ (false);
-    endif
-    switch (anp)
-      case "new"
-      case "add"
-      case "replacechildren"
-        delete (get (ca, "children"));
-      case "replace"
-        __go_axes_init__ (ca, "replace");
-        __request_drawnow__ ();
-      otherwise
-        error ("newplot: unrecognized nextplot property for current axes");
-    endswitch
-    if (nargout > 0)
-      h = ca;
-    endif
+  else
+    set (cf, "currentaxes", ca);
+  endif
+
+  ## FIXME: Is this necessary anymore?
+  ##        It seems like a kluge that belongs somewhere else.
+  if (strcmp (get (ca, "__hold_all__"), "off"))
+    __next_line_color__ (true);
+    __next_line_style__ (true);
   else
-    print_usage ();
+    __next_line_color__ (false);
+    __next_line_style__ (false);
+  endif
+
+  anp = get (ca, "nextplot");
+  switch (anp)
+    case "add"
+      ## Default case.  Doesn't require action.
+    case "replacechildren"
+      delete (get (ca, "children"));
+    case "replace"
+      __go_axes_init__ (ca, "replace");
+      __request_drawnow__ ();
+      ## FIXME: The code above should perform the following:
+      ###########################
+      ## delete (allchild (ca));
+      ## reset (ca);
+      ###########################
+      ## Actually, __go_axes_init__ does both less and more.
+      ## It doesn't really remove all children since it re-instantiates
+      ## xlabel, ylabel, zlabel, and title text objects.
+      ## Also it preserves font properties like fontsize.
+      ## For the time being, in order to have axis labels and title work,
+      ## the above code is is required.
+  endswitch
+
+  if (nargout > 0)
+    hax = ca;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0, 1]);
-%!   ha = newplot ();
-%!   assert (ha, gca);
+%!   hax = newplot ();
+%!   assert (hax, gca);
 %!   assert (isempty (get (gca, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/print.m b/scripts/plot/util/print.m
rename from scripts/plot/print.m
rename to scripts/plot/util/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/util/print.m
@@ -16,27 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a plot, or save it to a file.  Both output formatted for 
-## printing (PDF and PostScript), and many bitmapped and vector
-## image formats are supported.
+## Print a plot, or save it to a file.
+##
+## Both output formatted for printing (PDF and PostScript), and many bitmapped
+## and vector image formats are supported.
 ##
 ## @var{filename} defines the name of the output file.  If the
 ## file name has no suffix, one is inferred from the specified
 ## device and appended to the file name.  If no filename is
 ## specified, the output is sent to the printer.
 ##
-## @var{h} specifies the figure handle.  If no handle is specified
-## the handle for the current figure is used.
+## @var{h} specifies the handle of the figure to print.  If no handle is
+## specified the current figure is used.
 ##
 ## For output to a printer, PostScript file, or PDF file,
 ## the paper size is specified by the figure's @code{papersize}
 ## property.  The location and size of the image on the page are
 ## specified by the figure's @code{paperposition} property.  The
 ## orientation of the page is specified by the figure's
 ## @code{paperorientation} property.
 ##
@@ -51,91 +52,91 @@
 ## default is the current figure.
 ##
 ## @item -P@var{printer}
 ##   Set the @var{printer} name to which the plot is sent if no
 ## @var{filename} is specified.
 ##
 ## @item -G@var{ghostscript_command}
 ##   Specify the command for calling Ghostscript.  For Unix and Windows
-## the defaults are 'gs' and 'gswin32c', respectively.
+## the defaults are @qcode{"gs"} and @qcode{"gswin32c"}, respectively.
 ##
-## @item -color
+## @item  -color
 ## @itemx -mono
-##   Monochrome or color output.
+##   Color or monochrome output.
 ##
-## @item -solid
+## @item  -solid
 ## @itemx -dashed
 ##   Force all lines to be solid or dashed, respectively.
 ##
-## @item -portrait
+## @item  -portrait
 ## @itemx -landscape
 ##   Specify the orientation of the plot for printed output.  For
 ## non-printed output the aspect ratio of the output corresponds to
-## the plot area defined by the "paperposition" property in the
-## orientation specified.  This options is equivalent to changing
-## the figure's "paperorientation" property.
+## the plot area defined by the @qcode{"paperposition"} property in the
+## orientation specified.  This option is equivalent to changing
+## the figure's @qcode{"paperorientation"} property.
 ##
-## @item -TextAlphaBits=@var{n}
+## @item  -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
 ## vector formats by using Ghostscript.
 ## For bitmap and printer output anti-aliasing is applied using
 ## Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
 ## The default number of bits for each is 4.
 ## Allowed values for @var{N} are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device},
 ## and is one of:
 ##
 ##   @table @code
-##   @item ps
+##   @item  ps
 ##   @itemx ps2
 ##   @itemx psc
 ##   @itemx psc2
-##     Postscript (level 1 and 2, mono and color).  The FLTK graphics
-## toolkit generates Postscript level 3.0.
+##     PostScript (level 1 and 2, mono and color).  The FLTK graphics
+## toolkit generates PostScript level 3.0.
 ##
-##   @item eps
+##   @item  eps
 ##   @itemx eps2
 ##   @itemx epsc
 ##   @itemx epsc2
-##     Encapsulated postscript (level 1 and 2, mono and color).  The FLTK
-## graphic toolkit generates Postscript level 3.0.
+##     Encapsulated PostScript (level 1 and 2, mono and color).  The FLTK
+## graphic toolkit generates PostScript level 3.0.
 ##
-##   @item tex
+##   @item  tex
 ##   @itemx epslatex
 ##   @itemx epslatexstandalone
 ##   @itemx pstex
 ##   @itemx pslatex
 ##   @itemx pdflatex
 ##     Generate a @LaTeX{} (or @TeX{}) file for labels and eps/ps/pdf
 ## for graphics.  The file produced by @code{epslatexstandalone} can be
 ## processed directly by @LaTeX{}.  The other formats are intended to
 ## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
 ## is the same as the @code{epslatex} device.  The @code{pdflatex} device
 ## is only available for the FLTK graphics toolkit.
 ##
 ##   @item tikz
 ##     Generate a @LaTeX{} file using PGF/TikZ@.  For the FLTK toolkit
 ## the result is PGF.
 ##
-##   @item ill
+##   @item  ill
 ##   @itemx aifm
 ##     Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)
 ##
-##   @item cdr
+##   @item  cdr
 ##   @itemx @nospell{corel}
 ##     CorelDraw
 ##
 ##   @item dxf
 ##     AutoCAD
 ##
-##   @item emf
+##   @item  emf
 ##   @itemx meta
 ##     Microsoft Enhanced Metafile
 ##
 ##   @item fig
 ##     XFig.  For the Gnuplot graphics toolkit, the additional options
 ## @option{-textspecial} or @option{-textnormal} can be used to control
 ## whether the special flag should be set for the text in
 ## the figure.  (default is @option{-textnormal})
@@ -144,17 +145,17 @@
 ##     HP plotter language
 ##
 ##   @item mf
 ##     Metafont
 ##
 ##   @item png
 ##     Portable network graphics
 ##
-##   @item jpg
+##   @item  jpg
 ##   @itemx jpeg
 ##     JPEG image
 ##
 ##   @item gif
 ##     GIF image (only available for the Gnuplot graphics toolkit)
 ##
 ##   @item pbm
 ##     PBMplus
@@ -162,17 +163,17 @@
 ##   @item svg
 ##     Scalable vector graphics
 ##
 ##   @item pdf
 ##     Portable document format
 ##   @end table
 ##
 ##   If the device is omitted, it is inferred from the file extension,
-## or if there is no filename it is sent to the printer as postscript.
+## or if there is no filename it is sent to the printer as PostScript.
 ##
 ## @item -d@var{ghostscript_device}
 ##   Additional devices are supported by Ghostscript.
 ## Some examples are;
 ##
 ##   @table @code
 ##   @item ljet2p
 ##     HP LaserJet @nospell{IIP}
@@ -194,34 +195,35 @@
 ##
 ##   @item ppm
 ##     Portable Pixel Map file format
 ##
 ##   @item pdfwrite
 ##     Produces pdf output from eps
 ##   @end table
 ##
-##   For a complete list, type @samp{system ("gs -h")} to see what formats
+##   For a complete list, type @code{system ("gs -h")} to see what formats
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
-## by the figure's "papersize" property.  When the output
+## by the figure's @qcode{"papersize"} property.  When the output
 ## is sent to a file the size is determined by the plot box defined by
-## the figure's "paperposition" property.
+## the figure's @qcode{"paperposition"} property.
 ##
 ## @item -append
-##   Append Postscript or PDF output to a pre-existing file of the same type.
+##   Append PostScript or PDF output to a pre-existing file of the same type.
 ##
 ## @item -r@var{NUM}
 ##   Resolution of bitmaps in pixels per inch.  For both metafiles and
 ## SVG the default is the screen resolution; for other formats it is 150 dpi.
-## To specify screen resolution, use "-r0".
+## To specify screen resolution, use @qcode{"-r0"}.
 ##
-## @item -tight
-##   Force a tight bounding box for eps files.
+## @item  -loose
+## @itemx -tight
+##   Force a tight or loose bounding box for eps files.  The default is loose.
 ##
 ## @item -@var{preview}
 ##   Add a preview to eps files.  Supported formats are:
 ##
 ##   @table @code
 ##   @item -interchange
 ##     Provide an interchange preview.
 ##
@@ -234,21 +236,21 @@
 ##   @item -tiff
 ##     Provide a tiff preview.
 ##   @end table
 ##
 ## @item -S@var{xsize},@var{ysize}
 ##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG, and SVG@.  For
 ## PS, EPS, PDF, and other vector formats the plot size is in points.
 ## This option is equivalent to changing the size of the plot box
-## associated with the "paperposition" property.  When using the command form
-## of the print function you must quote the @var{xsize},@var{ysize}
-## option.  For example, by writing @w{"-S640,480"}.
+## associated with the @qcode{"paperposition"} property.  When using the
+## command form of the print function you must quote the
+## @var{xsize},@var{ysize} option.  For example, by writing @w{"-S640,480"}.
 ##
-## @item -F@var{fontname}
+## @item  -F@var{fontname}
 ## @itemx -F@var{fontname}:@var{size}
 ## @itemx -F:@var{size}
 ##   Use @var{fontname} and/or @var{fontsize} for all text.
 ## @var{fontname} is ignored for some devices: dxf, fig, hpgl, etc.
 ## @end table
 ##
 ## The filename and options can be given in any order.
 ##
@@ -262,24 +264,23 @@
 ## print -dsvg figure1.svg
 ## @end group
 ## @end example
 ##
 ## Example: Print to an HP DeskJet 550C.
 ##
 ## @example
 ## @group
-## figure (1);
 ## clf ();
 ## surf (peaks);
 ## print -dcdj550
 ## @end group
 ## @end example
 ##
-## @seealso{figure, orient, saveas}
+## @seealso{saveas, orient, figure}
 ## @end deftypefn
 
 function print (varargin)
 
   opts = __print_parse_opts__ (varargin{:});
 
   opts.pstoedit_cmd = @pstoedit;
   opts.fig2dev_cmd = @fig2dev;
@@ -287,17 +288,17 @@ function print (varargin)
   opts.lpr_cmd = @lpr;
   opts.epstool_cmd = @epstool;
 
   if (! isfigure (opts.figure))
     error ("print: no figure to print");
   endif
 
   orig_figure = get (0, "currentfigure");
-  figure (opts.figure);
+  set (0, "currentfigure", opts.figure);
 
   if (opts.append_to_file)
     [~, ~, ext] = fileparts (opts.ghostscript.output);
     opts.ghostscript.prepend = strcat (tmpnam (), ext);
     copyfile (opts.ghostscript.output, opts.ghostscript.prepend);
   endif
 
   unwind_protect
@@ -405,20 +406,20 @@ function print (varargin)
           fontsize = fontsize * opts.scalefontsize;
         endif
         set (h(ishandle (h)), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphcis toolkit print script
     switch (get (opts.figure, "__graphics_toolkit__"))
-    case "gnuplot"
-      opts = __gnuplot_print__ (opts);
-    otherwise
-      opts = __fltk_print__ (opts);
+      case "gnuplot"
+        opts = __gnuplot_print__ (opts);
+      otherwise
+        opts = __fltk_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
       for n = numel (props):-1:1
         if (ishandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
@@ -431,17 +432,17 @@ function print (varargin)
       [status, output] = unlink (opts.unlink{n});
       if (status != 0)
         warning ("print.m: %s, '%s'", output, opts.unlink{n});
       endif
     endfor
   end_unwind_protect
 
   if (isfigure (orig_figure))
-    figure (orig_figure);
+    set (0, "currentfigure", orig_figure);
   endif
 
 endfunction
 
 function cmd = epstool (opts, filein, fileout)
   ## As epstool does not work with pipes, a subshell is used to
   ## permit piping. Since this solution does not work with the DOS
   ## command shell, the -tight and -preview options are disabled if
@@ -490,29 +491,29 @@ function cmd = epstool (opts, filein, fi
     warning ("print:previewandtight",
              "print.m: eps preview may not be combined with -tight");
   endif
   if (! isempty (opts.preview) || opts.tight_flag)
     if (! isempty (opts.epstool_binary))
       if (opts.tight_flag)
         cmd = "--copy --bbox";
       elseif (! isempty (opts.preview))
-        switch opts.preview
-        case "tiff"
-          cmd = sprintf ("--add-%s-preview --device tiffg3", opts.preview);
-        case {"tiff6u", "tiff6p", "metafile"}
-          cmd = sprintf ("--add-%s-preview --device bmpgray", opts.preview);
-        case {"tiff4", "interchange"}
-          cmd = sprintf ("--add-%s-preview", opts.preview);
-        case "pict"
-          cmd = sprintf ("--add-%s-preview --mac-single", opts.preview);
-        otherwise
-          error ("print:invalidpreview",
-                 "print.m: epstool cannot include preview for format '%s'",
-                 opts.preview);
+        switch (opts.preview)
+          case "tiff"
+            cmd = sprintf ("--add-%s-preview --device tiffg3", opts.preview);
+          case {"tiff6u", "tiff6p", "metafile"}
+            cmd = sprintf ("--add-%s-preview --device bmpgray", opts.preview);
+          case {"tiff4", "interchange"}
+            cmd = sprintf ("--add-%s-preview", opts.preview);
+          case "pict"
+            cmd = sprintf ("--add-%s-preview --mac-single", opts.preview);
+          otherwise
+            error ("print:invalidpreview",
+                   "print.m: epstool cannot include preview for format '%s'",
+                   opts.preview);
         endswitch
         if (! isempty (opts.ghostscript.resolution))
           cmd = sprintf ("%s --dpi %d", cmd, opts.ghostscript.resolution);
         endif
       else
         cmd = "";
       endif
       if (! isempty (cmd))
@@ -612,26 +613,26 @@ function cmd = fig2dev (opts, devopt)
 endfunction
 
 function latex_standalone (opts)
   n = find (opts.name == ".", 1, "last");
   if (! isempty (n))
     opts.name = opts.name(1:n-1);
   endif
   latexfile = strcat (opts.name, ".tex");
-  switch opts.devopt
-  case {"pdflatexstandalone"}
-    packages = "\\usepackage{graphicx,color}";
-    graphicsfile = strcat (opts.name, "-inc.pdf");
-  case {"pslatexstandalone"}
-    packages = "\\usepackage{epsfig,color}";
-    graphicsfile = strcat (opts.name, "-inc.ps");
-  otherwise
-    packages = "\\usepackage{epsfig,color}";
-    graphicsfile = strcat (opts.name, "-inc.eps");
+  switch (opts.devopt)
+    case {"pdflatexstandalone"}
+      packages = "\\usepackage{graphicx,color}";
+      graphicsfile = strcat (opts.name, "-inc.pdf");
+    case {"pslatexstandalone"}
+      packages = "\\usepackage{epsfig,color}";
+      graphicsfile = strcat (opts.name, "-inc.ps");
+    otherwise
+      packages = "\\usepackage{epsfig,color}";
+      graphicsfile = strcat (opts.name, "-inc.eps");
   endswitch
   papersize = sprintf ("\\usepackage[papersize={%.2fbp,%.2fbp},text={%.2fbp,%.2fbp}]{geometry}",
                        opts.canvas_size, opts.canvas_size);
   prepend = {"\\documentclass{minimal}";
              packages;
              papersize;
              "\\begin{document}";
              "\\centering"};
@@ -702,9 +703,8 @@ function cmd = pstoedit (opts, devopt)
   elseif (isempty (opts.pstoedit_binary))
     error ("print:nopstoedit", "print.m: 'pstoedit' not found in PATH");
   endif
   if (opts.debug)
     fprintf ("pstoedit command: '%s'\n", cmd);
   endif
 endfunction
 
-
diff --git a/scripts/plot/printd.m b/scripts/plot/util/printd.m
rename from scripts/plot/printd.m
rename to scripts/plot/util/printd.m
--- a/scripts/plot/printd.m
+++ b/scripts/plot/util/printd.m
@@ -46,36 +46,36 @@ function pr_out = printd (obj, filename)
   opt = substr (filename, sufix+1);
   [pf, tempf, mag] = mkstemp ("oct-XXXXXX", 1);  # Safe version of tmpnam()
   fprintf (pf, "%s", disp (obj));
   frewind (pf);
 
   ## It seems best to only use convert for image output.  Its ps and pdf
   ## are badly rendered.
   opt = lower (opt);
-  switch opt
-    case {"pdf"}
+  switch (opt)
+    case "pdf"
       enscr = sprintf (
                        "enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit",...
                        tempf, tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
-    case {"ps"}
+    case "ps"
       enscr = sprintf ("enscript --no-header -o %s %s ; exit", filename, tempf);
       system (enscr);
-    case {"eps"}
+    case "eps"
       enscr = sprintf (
                        "enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit",...
                        tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
-    case {"txt"}
+    case "txt"
       enscr = sprintf ("cp %s %s", tempf, filename);
       system (enscr);
-    case {"jpg" "jpeg"}
+    case {"jpg", "jpeg"}
       enscr = sprintf ("convert -trim txt:%s  jpg:%s", tempf, filename);
       system (enscr);
     otherwise
       fclose (pf);
       delete (tempf);
       error ("Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
 
   endswitch
diff --git a/scripts/plot/private/__add_default_menu__.m b/scripts/plot/util/private/__add_default_menu__.m
rename from scripts/plot/private/__add_default_menu__.m
rename to scripts/plot/util/private/__add_default_menu__.m
--- a/scripts/plot/private/__add_default_menu__.m
+++ b/scripts/plot/util/private/__add_default_menu__.m
@@ -14,58 +14,63 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __add_default_menu__ (@var{fig})
 ## Add default menu to figure.  All uimenu handles have
-## set their property "handlevisibility" to "off".
+## their @qcode{"HandleVisibility"} property set to @qcode{"off"}.
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function __add_default_menu__ (fig)
 
-  if (isfigure (fig))
-    obj = findall (fig, "label", "&File", "tag", "__default_menu__");
-    if (length (obj) == 0)
-      __f = uimenu (fig, "label", "&File", "handlevisibility", "off", "tag", "__default_menu__");
-        sa = uimenu (__f, "label", "Save &As", "handlevisibility", "off",
-                          "callback", @save_cb);
-        sv = uimenu (__f, "label", "&Save", "handlevisibility", "off",
-                          "callback", @save_cb);
-        cl = uimenu (__f, "label", "&Close", "handlevisibility", "off",
-                          "callback", "close(gcf)");
-
-      __e = uimenu (fig, "label", "&Edit", "handlevisibility", "off");
-        gr = uimenu (__e, "label", "&Grid", "handlevisibility", "off",
-                          "callback", @grid_cb);
-        as = uimenu (__e, "label", "Auto&scale", "handlevisibility", "off",
-                          "callback", @autoscale_cb);
-        gm = uimenu (__e, "label", "GUI &Mode", "handlevisibility", "off");
-          gm2 = uimenu (gm, "label", "Pan+Zoom", "handlevisibility", "off",
-                            "callback", @guimode_cb);
-          gm3 = uimenu (gm, "label", "Rotate+Zoom", "handlevisibility", "off",
-                            "callback", @guimode_cb);
-          gmn = uimenu (gm, "label", "None", "handlevisibility", "off",
-                            "callback", @guimode_cb);
-      __h = uimenu (fig, "label", "&Help", "handlevisibility", "off");
-        ab = uimenu (__h, "label", "A&bout", "handlevisibility", "off", "enable", "off");
-    endif
-  else
-    error ("expecting figure handle", "handlevisibility", "off");
+  ## Only FLTK toolkit currently provides menubar
+  if (! strcmp (get (fig, "__graphics_toolkit__"), "fltk"))
+    return;
   endif
 
-endfunction
+  obj = findall (fig, "-depth", 1, "tag", "__default_menu__", "label", "&File");
+  if (isempty (obj))
+    ## FIXME: uimenu() will cause menubar to be displayed, even though property
+    ##        menubar remains set at "none".  So, forcibly turn menubar status
+    ##        on and then off to force figure to hide menubar.
+    menubar_state = get (fig, "menubar");
+    set (fig, "menubar", "figure");
+
+    __f = uimenu (fig, "label", "&File", "handlevisibility", "off",
+                       "tag", "__default_menu__");
+      uimenu (__f, "label", "Save &As", "callback", @save_cb);
+      uimenu (__f, "label", "&Save", "callback", @save_cb);
+      uimenu (__f, "label", "&Close", "callback", "close (gcf)");
 
-function grid_cb (h, e)
-  grid;
-  drawnow; # should not be required
+    __e = uimenu (fig, "label", "&Edit", "handlevisibility", "off",
+                       "tag", "__default_menu__");
+      uimenu (__e, "label", "&Grid", "callback", @grid_cb);
+      uimenu (__e, "label", "Auto&scale", "callback", @autoscale_cb);
+      gm = uimenu (__e, "label", "GUI &Mode");
+        uimenu (gm, "label", "Pan+Zoom", "callback", @guimode_cb);
+        uimenu (gm, "label", "Rotate+Zoom", "callback", @guimode_cb);
+        uimenu (gm, "label", "None", "callback", @guimode_cb);
+
+    __h = uimenu (fig, "label", "&Help", "handlevisibility", "off",
+                       "tag", "__default_menu__");
+      uimenu (__h, "label", "A&bout", "enable", "off");
+
+    ## FIXME: This drawnow () must occur after at least one menu item has
+    ##        been defined to avoid sizing issues in new figures.
+    ##        This may lead to flicker.  The real fix must be in the C++ code. 
+    drawnow ();
+
+    set (fig, "menubar", menubar_state);
+  endif
+
 endfunction
 
 function save_cb (h, e)
   lbl = get (gcbo, "label");
   if (strcmp (lbl, "&Save"))
     fname = get (gcbo, "userdata");
     if (isempty (fname))
       __save_as__ (gcbo);
@@ -73,37 +78,42 @@ function save_cb (h, e)
       saveas (gcbo, fname);
     endif
   elseif (strcmp (lbl, "Save &As"))
     __save_as__ (gcbo);
   endif
 endfunction
 
 function __save_as__ (caller)
-
-  [filename, filedir] = uiputfile ({"*.pdf;*.ps;*.gif;*.png;*.jpg","Supported Graphic Formats"},
-                                  "Save Figure",
-                                  pwd);
+  [filename, filedir] = uiputfile ({"*.pdf;*.ps;*.gif;*.png;*.jpg",
+                                    "Supported Graphic Formats"},
+                                   "Save Figure",
+                                   pwd);
   if (filename != 0)
-    fname = strcat (filedir, filesep, filename);
-    obj = findall ("label", "&Save");
-    if (length (obj) > 0)
+    fname = [filedir filesep() filename];
+    obj = findall (gcbf, "label", "&Save");
+    if (! isempty (obj))
       set (obj(1), "userdata", fname);
     endif
     saveas (caller, fname);
   endif
 endfunction
 
+function grid_cb (h, e)
+  grid;
+endfunction
+
 function autoscale_cb (h, e)
   axis ("auto");
-  drawnow; #should not be required
 endfunction
 
 function guimode_cb (h, e)
   lbl = get (h, "label");
-  if (strncmp (lbl, "Pan+Zoom", 8))
-    gui_mode ("2D");
-  elseif (strncmp (lbl, "Rotate+Zoom", 11))
-    gui_mode ("3D");
-  elseif (strncmp (lbl, "None", 4))
-    gui_mode ("None");
-  endif
+  switch (lbl)
+    case "Pan+Zoom"
+      gui_mode ("2D");
+    case "Rotate+Zoom"
+      gui_mode ("3D");
+    case "None"
+      gui_mode ("None");
+  endswitch
 endfunction
+
diff --git a/scripts/plot/private/__fltk_ginput__.m b/scripts/plot/util/private/__fltk_ginput__.m
rename from scripts/plot/private/__fltk_ginput__.m
rename to scripts/plot/util/private/__fltk_ginput__.m
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/util/private/__fltk_print__.m
rename from scripts/plot/private/__fltk_print__.m
rename to scripts/plot/util/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/util/private/__fltk_print__.m
@@ -20,135 +20,135 @@
 ## @deftypefn {Function File} {} __fltk_print__ (@var{@dots{}})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function opts = __fltk_print__ (opts)
 
   dos_shell = (ispc () && ! isunix ());
 
-  figure (opts.figure);
+  set (0, "currentfigure", opts.figure);
   drawnow ("expose");
   __fltk_redraw__ ();
 
   if (! isempty (opts.fig2dev_binary))
     ## fig2dev is prefered for conversion to emf
     fig2dev_devices = {"pstex", "mf", "emf"};
   else
     fig2dev_devices = {"pstex", "mf"};
   endif
 
   gl2ps_device = {};
   pipeline = {};
   switch (lower (opts.devopt))
-  case {"eps", "eps2", "epsc", "epsc2"}
-    ## format GL2PS_EPS
-    gl2ps_device = {"eps"};
-    ## FIXME - use epstool to tighten bbox and provide preview.
-    pipeline = {opts.epstool_cmd(opts, "-", opts.name)};
-  case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
-        "pslatexstandalone", "pdflatexstandalone"}
-    ## format GL2PS_TEX
-    n = find (opts.devopt == "l", 1);
-    suffix = opts.devopt(1:n-1);
-    dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end), ...
-                {strcat(".", suffix), ".tex", "."})))
-      name = opts.name(1:dot-1);
-      if (dot < numel (opts.name)
-          && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
-        ## If user provides eps/ps/pdf suffix, use it.
-        suffix = opts.name(dot+1:end);
+    case {"eps", "eps2", "epsc", "epsc2"}
+      ## format GL2PS_EPS
+      gl2ps_device = {"eps"};
+      ## FIXME: use epstool to tighten bbox and provide preview.
+      pipeline = {opts.epstool_cmd(opts, "-", opts.name)};
+    case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
+          "pslatexstandalone", "pdflatexstandalone"}
+      ## format GL2PS_TEX
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      dot = find (opts.name == ".", 1, "last");
+      if ((! isempty (dot))
+          && any (strcmpi (opts.name(dot:end), ...
+                  {strcat(".", suffix), ".tex", "."})))
+        name = opts.name(1:dot-1);
+        if (dot < numel (opts.name)
+            && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
+          ## If user provides eps/ps/pdf suffix, use it.
+          suffix = opts.name(dot+1:end);
+        endif
+      else
+        error ("print:invalid-suffix", 
+               "invalid suffix '%s' for device '%s'.",
+               opts.name(dot:end), lower (opts.devopt));
       endif
-    else
-      error ("print:invalid-suffix", 
-             "invalid suffix '%s' for device '%s'.",
-             opts.name(dot:end), lower (opts.devopt));
-    endif
-    gl2ps_device = {sprintf("%snotxt", lower (suffix))};
-    gl2ps_device{2} = "tex";
-    if (dos_shell)
-      ## FIXME - this will only work on MinGW with the MSYS shell
-      pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
-      pipeline{2} = sprintf ("cat > %s.tex", name);
-    else
-      pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
-      pipeline{2} = sprintf ("cat > %s.tex", name);
-    endif
-  case "tikz"
-    ## format GL2PS_PGF
-    gl2ps_device = {"pgf"};
-    pipeline = {sprintf("cat > %s", opts.name)};
-  case "svg"
-    ## format GL2PS_SVG
-    gl2ps_device = {"svg"};
-    pipeline = {sprintf("cat > %s", opts.name)};
-  case fig2dev_devices
-    cmd_pstoedit = opts.pstoedit_cmd (opts, "fig");
-    cmd_fig2dev = opts.fig2dev_cmd (opts, opts.devopt);
-    if (strcmp (opts.devopt, "pstex"))
-      [~, ~, ext] = fileparts (opts.name);
-      if (any (strcmpi (ext, {".ps", ".tex", "."})))
-        opts.name = opts.name(1:end-numel(ext));
+      gl2ps_device = {sprintf("%snotxt", lower (suffix))};
+      gl2ps_device{2} = "tex";
+      if (dos_shell)
+        ## FIXME: this will only work on MinGW with the MSYS shell
+        pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
+        pipeline{2} = sprintf ("cat > %s.tex", name);
+      else
+        pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
+        pipeline{2} = sprintf ("cat > %s.tex", name);
       endif
-      opts.name = strcat (opts.name, ".ps");
-      cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
-      gl2ps_device = {"eps"};
-      pipeline = {cmd};
-      cmd_fig2dev = opts.fig2dev_cmd (opts, "pstex_t");
-      gl2ps_device{2} = "eps";
-      pipeline{2} = sprintf ("%s | %s > %s", cmd_pstoedit,
-                             cmd_fig2dev, strrep(opts.name, ".ps", ".tex"));
-    else
-      cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+    case "tikz"
+      ## format GL2PS_PGF
+      gl2ps_device = {"pgf"};
+      pipeline = {sprintf("cat > %s", opts.name)};
+    case "svg"
+      ## format GL2PS_SVG
+      gl2ps_device = {"svg"};
+      pipeline = {sprintf("cat > %s", opts.name)};
+    case fig2dev_devices
+      cmd_pstoedit = opts.pstoedit_cmd (opts, "fig");
+      cmd_fig2dev = opts.fig2dev_cmd (opts, opts.devopt);
+      if (strcmp (opts.devopt, "pstex"))
+        [~, ~, ext] = fileparts (opts.name);
+        if (any (strcmpi (ext, {".ps", ".tex", "."})))
+          opts.name = opts.name(1:end-numel(ext));
+        endif
+        opts.name = strcat (opts.name, ".ps");
+        cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+        cmd_fig2dev = opts.fig2dev_cmd (opts, "pstex_t");
+        gl2ps_device{2} = "eps";
+        pipeline{2} = sprintf ("%s | %s > %s", cmd_pstoedit,
+                               cmd_fig2dev, strrep(opts.name, ".ps", ".tex"));
+      else
+        cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+      endif
+    case "aifm"
+      cmd = opts.pstoedit_cmd (opts, "ps2ai");
       gl2ps_device = {"eps"};
-      pipeline = {cmd};
-    endif
-  case "aifm"
-    cmd = opts.pstoedit_cmd (opts, "ps2ai");
-    gl2ps_device = {"eps"};
-    pipeline = {sprintf("%s > %s", cmd, opts.name)};
-  case {"dxf", "emf", "fig", "hpgl"}
-    cmd = opts.pstoedit_cmd (opts);
-    gl2ps_device = {"eps"};
-    pipeline = {sprintf("%s > %s", cmd, opts.name)};
-  case {"corel", "gif"}
-    error ("print:unsupporteddevice",
-           "print.m: %s output is not available for the FLTK graphics toolkit",
-           upper (opts.devopt));
-  case opts.ghostscript.device
-    opts.ghostscript.source = "-";
-    opts.ghostscript.output = opts.name;
-    if (opts.send_to_printer)
-      opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
-      opts.ghostscript.output = "-";
-    endif
-    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
-    if (opts.send_to_printer || isempty (opts.name))
-      cmd_lpr = opts.lpr_cmd (opts);
-      cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
-    else
-      cmd = sprintf ("%s", cmd_gs);
-    endif
-    if (! isempty (cmd_cleanup))
+      pipeline = {sprintf("%s > %s", cmd, opts.name)};
+    case {"dxf", "emf", "fig", "hpgl"}
+      cmd = opts.pstoedit_cmd (opts);
       gl2ps_device = {"eps"};
-      if (dos_shell)
-        pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
-      else
-        pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+      pipeline = {sprintf("%s > %s", cmd, opts.name)};
+    case {"corel", "gif"}
+      error ("print:unsupporteddevice",
+             "print.m: %s output is not available for the FLTK graphics toolkit",
+             upper (opts.devopt));
+    case opts.ghostscript.device
+      opts.ghostscript.source = "-";
+      opts.ghostscript.output = opts.name;
+      if (opts.send_to_printer)
+        opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
+        opts.ghostscript.output = "-";
       endif
-    else
-      gl2ps_device = {"eps"};
-      pipeline = {cmd};
-    endif
-  otherwise
-    error (sprintf ("print:no%soutput", opts.devopt),
-           "print.m: %s output is not available for GL2PS output",
-           upper (opts.devopt));
+      [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
+      if (opts.send_to_printer || isempty (opts.name))
+        cmd_lpr = opts.lpr_cmd (opts);
+        cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
+      else
+        cmd = sprintf ("%s", cmd_gs);
+      endif
+      if (! isempty (cmd_cleanup))
+        gl2ps_device = {"eps"};
+        if (dos_shell)
+          pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
+        else
+          pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+        endif
+      else
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+      endif
+    otherwise
+      error (sprintf ("print:no%soutput", opts.devopt),
+             "print.m: %s output is not available for GL2PS output",
+             upper (opts.devopt));
   endswitch
 
   opts.pipeline = pipeline;
 
   ## Tell gl2ps to use different rendering options for 2D plots
   haxes = findall (opts.figure, "type", "axes");
   vw = get (haxes, "view");
   if (iscell (vw))
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/util/private/__ghostscript__.m
rename from scripts/plot/private/__ghostscript__.m
rename to scripts/plot/util/private/__ghostscript__.m
diff --git a/scripts/plot/private/__gnuplot_get_var__.m b/scripts/plot/util/private/__gnuplot_get_var__.m
rename from scripts/plot/private/__gnuplot_get_var__.m
rename to scripts/plot/util/private/__gnuplot_get_var__.m
--- a/scripts/plot/private/__gnuplot_get_var__.m
+++ b/scripts/plot/util/private/__gnuplot_get_var__.m
@@ -21,20 +21,16 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-02-07
 
 function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt = "")
 
-  if (nargin < 2)
-    print_usage ();
-  endif
-
   if (numel (h) == 1 && isfigure (h))
     if (isempty (get (gcf, "__plot_stream__")))
       ostream = __gnuplot_open_stream__ (2, h);
     else
       ostream = get (h, "__plot_stream__");
     endif
   else
     ostream = h;
@@ -51,17 +47,17 @@ function gp_var_value = __gnuplot_get_va
   else
     use_mkfifo = true;
     ostream = ostream(1);
   endif
 
   if (use_mkfifo)
     gpin_name = tmpnam ();
 
-    ## Mode: 6*8*8 ==  0600
+    ## Mode: 0600 == 6*8*8
     [err, msg] = mkfifo (gpin_name, 6*8*8);
 
     if (err)
       error ("__gnuplot_get_var__: Can not make FIFO (%s)", msg);
     endif
   endif
 
   gp_var_name = strtrim (gp_var_name);
diff --git a/scripts/plot/private/__gnuplot_ginput__.m b/scripts/plot/util/private/__gnuplot_ginput__.m
rename from scripts/plot/private/__gnuplot_ginput__.m
rename to scripts/plot/util/private/__gnuplot_ginput__.m
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/util/private/__gnuplot_has_feature__.m
rename from scripts/plot/private/__gnuplot_has_feature__.m
rename to scripts/plot/util/private/__gnuplot_has_feature__.m
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/util/private/__gnuplot_has_terminal__.m
rename from scripts/plot/private/__gnuplot_has_terminal__.m
rename to scripts/plot/util/private/__gnuplot_has_terminal__.m
diff --git a/scripts/plot/private/__gnuplot_open_stream__.m b/scripts/plot/util/private/__gnuplot_open_stream__.m
rename from scripts/plot/private/__gnuplot_open_stream__.m
rename to scripts/plot/util/private/__gnuplot_open_stream__.m
--- a/scripts/plot/private/__gnuplot_open_stream__.m
+++ b/scripts/plot/util/private/__gnuplot_open_stream__.m
@@ -38,8 +38,9 @@ function plot_stream = __gnuplot_open_st
     if (plot_stream < 0)
       error ("__gnuplot_open_stream__: failed to open connection to gnuplot");
     endif
   endif
   if (nargin > 1)
     set (h, "__plot_stream__", plot_stream);
   endif
 endfunction
+
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/util/private/__gnuplot_print__.m
rename from scripts/plot/private/__gnuplot_print__.m
rename to scripts/plot/util/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/util/private/__gnuplot_print__.m
@@ -44,113 +44,114 @@ function opts = __gnuplot_print__ (opts)
   endif
   ## The axes-label and tick-label spacing is determined by
   ## the font spec given in "set terminal ..."
   gp_opts = font_spec (opts);
 
   pipeline = "";
 
   switch (lower (opts.devopt))
-  case {"eps", "eps2", "epsc", "epsc2"}
-    if (any (strcmp (opts.devopt, {"eps", "epsc"})))
-      gp_opts = [gp_opts " level1"];
-    endif
-    if (opts.tight_flag || ! isempty (opts.preview))
-      tmp_file = strcat (tmpnam (), ".eps");
-      eps_drawnow (opts, tmp_file, gp_opts);
-      if (dos_shell)
-        cleanup = [" & del " strrep(tmp_file, '/', '\')];
+    case {"eps", "eps2", "epsc", "epsc2"}
+      if (any (strcmp (opts.devopt, {"eps", "epsc"})))
+        gp_opts = [gp_opts " level1"];
+      endif
+      if (opts.tight_flag || ! isempty (opts.preview))
+        tmp_file = strcat (tmpnam (), ".eps");
+        eps_drawnow (opts, tmp_file, gp_opts);
+        if (dos_shell)
+          cleanup = [" & del " strrep(tmp_file, '/', '\')];
+        else
+          cleanup = [" ; rm " tmp_file];
+        endif
+        pipeline = {sprintf("%s %s",
+                            opts.epstool_cmd (opts, tmp_file, opts.name),
+                            cleanup)};
       else
-        cleanup = [" ; rm " tmp_file];
+        eps_drawnow (opts, opts.name, gp_opts);
       endif
-      pipeline = {sprintf("%s %s",
-                          opts.epstool_cmd (opts, tmp_file, opts.name),
-                          cleanup)};
-    else
-      eps_drawnow (opts, opts.name, gp_opts);
-    endif
-  case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
-    dot = find (opts.name == ".", 1, "last");
-    n = find (opts.devopt == "l", 1);
-    suffix = opts.devopt(1:n-1);
-    if (! isempty (dot))
-      if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
-        name = opts.name(1:dot-1);
+    case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
+      dot = find (opts.name == ".", 1, "last");
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      if (! isempty (dot))
+        if (any (strcmpi (opts.name(dot:end), {["." suffix], ".tex", "."})))
+          name = opts.name(1:dot-1);
+        else
+          error ("print:invalid-suffix", 
+                 "invalid suffix '%s' for device '%s'.",
+                 opts.name(dot:end), lower (opts.devopt));
+        endif
+      endif
+      if (strfind (opts.devopt, "standalone"))
+        term = sprintf ("%s ",
+                        strrep (opts.devopt, "standalone", " standalone"));
       else
-        error ("print:invalid-suffix", 
-               "invalid suffix '%s' for device '%s'.",
-               opts.name(dot:end), lower (opts.devopt));
+        term = sprintf ("%s ", opts.devopt);
+      endif
+      if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
+        suffix = "tex";
+      else
+        ## Gnuplot 4.0 wants a ".eps" suffix.
+        suffix = "eps";
       endif
-    endif
-    if (strfind (opts.devopt, "standalone"))
-      term = sprintf ("%s ",
-                      strrep (opts.devopt, "standalone", " standalone"));
-    else
-      term = sprintf ("%s ", opts.devopt);
-    endif
-    if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
-      suffix = "tex";
-    else
-      ## Gnuplot 4.0 wants a ".eps" suffix.
-      suffix = "eps";
-    endif
-    local_drawnow ([term " " gp_opts],
-                   strcat (name, ".", suffix), opts);
-  case "tikz"
-    if (__gnuplot_has_terminal__ ("tikz"))
-      local_drawnow (["lua tikz " gp_opts], opts.name, opts);
-    else
-      error (sprintf ("print:no%soutput", opts.devopt),
-             "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ());
-    endif
-  case "svg"
-    local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
-  case {"aifm", "corel", "eepic", "emf", "fig"}
-    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-  case {"pdfcairo", "pngcairo"}
-    if (__gnuplot_has_terminal__ (opts.devopt))
+      local_drawnow ([term " " gp_opts],
+                     strcat (name, ".", suffix), opts);
+    case "tikz"
+      if (__gnuplot_has_terminal__ ("tikz"))
+        local_drawnow (["lua tikz " gp_opts], opts.name, opts);
+      else
+        error (sprintf ("print:no%soutput", opts.devopt),
+               "print.m: '%s' output is not available for gnuplot-%s",
+               upper (opts.devopt), __gnuplot_version__ ());
+      endif
+    case "svg"
+      local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
+    case {"aifm", "corel", "eepic", "emf", "fig"}
+      local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
+    case {"pdfcairo", "pngcairo"}
+      if (__gnuplot_has_terminal__ (opts.devopt))
+        local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
+      else
+        error (sprintf ("print:no%soutput", opts.devopt),
+               "print.m: '%s' output is not available for gnuplot-%s",
+               upper (opts.devopt), __gnuplot_version__ ());
+      endif
+    case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
       local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-    else
+    case opts.ghostscript.device
+      gp_opts = font_spec (opts, "devopt", "eps");
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      eps_drawnow (opts, opts.ghostscript.source, gp_opts);
+      [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
+      if (opts.send_to_printer || isempty (opts.name))
+        cmd_lpr = opts.lpr_cmd (opts);
+        cmd = [cmd_gs " | " cmd_lpr];
+      else
+        cmd = cmd_gs;
+      endif
+      if (dos_shell)
+        cmd = sprintf ("%s & del %s", cmd,
+                       strrep (opts.ghostscript.source, '/', '\'));
+      else
+        cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
+      endif
+      if (! isempty (cmd_cleanup))
+        if (dos_shell)
+          pipeline = {[cmd " & " cmd_cleanup]};
+        else
+          pipeline = {[cmd " ; " cmd_cleanup]};
+        endif
+      else
+        pipeline = {cmd};
+      endif
+    otherwise
       error (sprintf ("print:no%soutput", opts.devopt),
-             "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ());
-    endif
-  case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
-    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-  case opts.ghostscript.device
-    gp_opts = font_spec (opts, "devopt", "eps");
-    opts.ghostscript.output = opts.name;
-    opts.ghostscript.source = strcat (tmpnam (), ".eps");
-    eps_drawnow (opts, opts.ghostscript.source, gp_opts);
-    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
-    if (opts.send_to_printer || isempty (opts.name))
-      cmd_lpr = opts.lpr_cmd (opts);
-      cmd = [cmd_gs " | " cmd_lpr];
-    else
-      cmd = cmd_gs;
-    endif
-    if (dos_shell)
-      cmd = sprintf ("%s & del %s", cmd, strrep (opts.ghostscript.source, '/', '\'));
-    else
-      cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
-    endif
-    if (! isempty (cmd_cleanup))
-      if (dos_shell)
-        pipeline = {[cmd " & " cmd_cleanup]};
-      else
-        pipeline = {[cmd " ; " cmd_cleanup]};
-      endif
-    else
-      pipeline = {cmd};
-    endif
-  otherwise
-    error (sprintf ("print:no%soutput", opts.devopt),
-           "print.m: %s output is not available for the Gnuplot graphics toolkit",
-           upper (opts.devopt));
+             "print.m: %s output is not available for the Gnuplot graphics toolkit",
+             upper (opts.devopt));
   endswitch
 
 
   opts.pipeline = pipeline;
 
   for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n});
@@ -165,134 +166,134 @@ function opts = __gnuplot_print__ (opts)
     endif
   endfor
 
 endfunction
 
 function eps_drawnow (opts, epsfile, gp_opts)
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
-    fontsize_2x = cellfun (@(x) 2*x, fontsize, "uniformoutput", false);
+    fontsize_2x = cellfun (@times, {2}, fontsize, "uniformoutput", false);
     set (h, {"fontsize"}, fontsize_2x);
     local_drawnow (["postscript eps " gp_opts], epsfile, opts);
   unwind_protect_cleanup
     set (h, {"fontsize"}, fontsize);
   end_unwind_protect
 endfunction
 
 function local_drawnow (term, file, opts)
   if (opts.use_color < 0)
     mono = true;
   else
     mono = false;
   endif
-  figure (opts.figure);
+  set (0, "currentfigure", opts.figure);
   if (isempty (opts.debug_file) || ! opts.debug)
     drawnow (term, file, mono);
   else
     drawnow (term, file, mono, opts.debug_file);
   endif
 endfunction
 
 function f = font_spec (opts, varargin)
   for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
-  case "cgm"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case {"eps", "eps2", "epsc", "epsc2"}
-    ## Gnuplot renders fonts as half their specification, which
-    ## results in a tight spacing for the axes-labels and tick-labels.
-    ## Compensate for the half scale. This will produce the proper
-    ## spacing for the requested fontsize.
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", 2 * opts.fontsize);
-    endif
-  case "svg"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('fname "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ("%s fsize %d", f, fontsize);
-    endif
-  case "pdf"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("fsize %d", f, opts.fontsize);
-    endif
-  case {"pdfcairo", "pngcairo"}
-    if (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    endif
-  case {"epslatex", "epslatexstandalone"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "pslatex"
-    if (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case {"gif", "jpeg", "png"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ('font "%d"', opts.fontsize);
-    endif
-  case "emf"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('"%s" %d', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('"%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "canvas"
-    if (! isempty (opts.fontsize))
-      f = sprintf ("fsize %d", opts.fontsize);
-    endif
-  case {"aifm", "corel"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("%s %d", opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ("%s", opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "fig"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ("font %s", opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("fontsize %d", opts.fontsize);
-    endif
+    case "cgm"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case {"eps", "eps2", "epsc", "epsc2"}
+      ## Gnuplot renders fonts as half their specification, which
+      ## results in a tight spacing for the axes-labels and tick-labels.
+      ## Compensate for the half scale. This will produce the proper
+      ## spacing for the requested fontsize.
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", 2 * opts.fontsize);
+      endif
+    case "svg"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        fontsize = round (opts.fontsize * 0.75);
+        f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('fname "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        fontsize = round (opts.fontsize * 0.75);
+        f = sprintf ("%s fsize %d", f, fontsize);
+      endif
+    case "pdf"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("fsize %d", f, opts.fontsize);
+      endif
+    case {"pdfcairo", "pngcairo"}
+      if (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      endif
+    case {"epslatex", "epslatexstandalone"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "pslatex"
+      if (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case {"gif", "jpeg", "png"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ('font "%d"', opts.fontsize);
+      endif
+    case "emf"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('"%s" %d', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('"%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "canvas"
+      if (! isempty (opts.fontsize))
+        f = sprintf ("fsize %d", opts.fontsize);
+      endif
+    case {"aifm", "corel"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ("%s %d", opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ("%s", opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "fig"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ("font %s", opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("fontsize %d", opts.fontsize);
+      endif
   endswitch
 endfunction
 
 function [h, fontsize] = get_figure_text_objs (opts)
   h = findall (opts.figure, "-property", "fontsize");
   hp = get (h, "parent");
   if (iscell (hp))
     hp = cell2mat (hp);
@@ -301,14 +302,15 @@ function [h, fontsize] = get_figure_text
   ## legend axes.  These will be handled by the fontsize listener.
   is_legend_key_string = strcmp (get (hp, "tag"), "legend") ...
                        & isprop (hp, "string") ...
                        & isprop (hp, "location") ...
                        & strcmp (get (hp, "type"), "axes");
   h(is_legend_key_string) = [];
   fontsize = get (h, "fontsize");
   switch (numel (fontsize))
-  case 0
-    fontsize = {};
-  case 1
-    fontsize = {fontsize};
+    case 0
+      fontsize = {};
+    case 1
+      fontsize = {fontsize};
   endswitch
 endfunction
+
diff --git a/scripts/plot/private/__gnuplot_version__.m b/scripts/plot/util/private/__gnuplot_version__.m
rename from scripts/plot/private/__gnuplot_version__.m
rename to scripts/plot/util/private/__gnuplot_version__.m
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/util/private/__go_draw_axes__.m
rename from scripts/plot/private/__go_draw_axes__.m
rename to scripts/plot/util/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/util/private/__go_draw_axes__.m
@@ -21,1738 +21,1734 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function __go_draw_axes__ (h, plot_stream, enhanced, mono,
                            bg_is_set, fg_is_set, hlgnd)
 
-  if (nargin >= 4 && nargin <= 7)
+  showhiddenhandles = get (0, "showhiddenhandles");
+  unwind_protect
+    set (0, "showhiddenhandles", "on");
+    axis_obj = __get__ (h);
+  unwind_protect_cleanup
+    set (0, "showhiddenhandles", showhiddenhandles);
+  end_unwind_protect
+
+  parent_figure_obj = get (axis_obj.parent);
+  gnuplot_term = __gnuplot_get_var__ (axis_obj.parent, "GPVAL_TERM");
+
+  ## Set to false for plotyy axes.
+  ymirror = true;
+  if (isfield (axis_obj, "__plotyy_axes__"))
+    if (all (ishandle (axis_obj.__plotyy_axes__)))
+      ymirror = false;
+    else
+      h = axis_obj.__plotyy_axes__;
+      h = h(ishandle (h));
+      h = h(isprop (h, "__plotyy_axes__"));
+      rmappdata (h, "__plotyy_axes__");
+    endif
+  endif
+
+  nd = __calc_dimensions__ (h);
+
+  if (strcmp (axis_obj.dataaspectratiomode, "manual")
+      && strcmp (axis_obj.xlimmode, "manual")
+      && strcmp (axis_obj.ylimmode, "manual"))
+    ## All can't be "manual"
+    axis_obj.plotboxaspectratiomode = "auto";
+  endif
 
-    showhiddenhandles = get (0, "showhiddenhandles");
-    unwind_protect
-      set (0, "showhiddenhandles", "on");
-      axis_obj = __get__ (h);
-    unwind_protect_cleanup
-      set (0, "showhiddenhandles", showhiddenhandles);
-    end_unwind_protect
+  if (strcmp (axis_obj.dataaspectratiomode, "manual")
+      && strcmp (axis_obj.xlimmode, "manual")
+      && strcmp (axis_obj.ylimmode, "manual")
+      && (nd == 2 || all (mod (axis_obj.view, 90) == 0)))
+    ## FIXME - adjust plotboxaspectratio to respect other
+    fpos = get (axis_obj.parent, "position");
+    apos = axis_obj.position;
+  endif
+
+  pos = __actual_axis_position__ (h);
+
+  if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+    dr = axis_obj.dataaspectratio;
+    if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
+      dr = dr(1) / dr(2);
+    else
+      ## FIXME - need to properly implement 3D
+      dr = mean (dr(1:2)) / dr(3);
+    endif
+  else
+    dr = 1;
+  endif
+
+  if (strcmp (axis_obj.activepositionproperty, "position"))
+    if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
+      if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
+        x = [1, 1];
+      else
+        ## 3D plots need to be sized down to fit in the window.
+        x = 1.0 ./ sqrt ([2, 2.5]);
+      endif
+      fprintf (plot_stream, "set tmargin screen %.15g;\n",
+               pos(2)+pos(4)/2+x(2)*pos(4)/2);
+      fprintf (plot_stream, "set bmargin screen %.15g;\n",
+               pos(2)+pos(4)/2-x(2)*pos(4)/2);
+      fprintf (plot_stream, "set lmargin screen %.15g;\n",
+               pos(1)+pos(3)/2-x(1)*pos(3)/2);
+      fprintf (plot_stream, "set rmargin screen %.15g;\n",
+               pos(1)+pos(3)/2+x(1)*pos(3)/2);
+      sz_str = "";
+    else
+      fprintf (plot_stream, "set tmargin 0;\n");
+      fprintf (plot_stream, "set bmargin 0;\n");
+      fprintf (plot_stream, "set lmargin 0;\n");
+      fprintf (plot_stream, "set rmargin 0;\n");
 
-    parent_figure_obj = get (axis_obj.parent);
-    gnuplot_term = __gnuplot_get_var__ (axis_obj.parent, "GPVAL_TERM");
+      if (nd == 3 && all (axis_obj.view == [0, 90]))
+        ## FIXME -- Kludge to allow colorbar to be added to a pcolor() plot
+        pos(3:4) = pos(3:4) * 1.4;
+        pos(1:2) = pos(1:2) - pos(3:4) * 0.125;
+      endif
+
+      fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
+
+      if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+        sz_str = sprintf ("set size ratio %.15g", -dr);
+      else
+        sz_str = "set size noratio";
+      endif
+      sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
+    endif
+  else ## activepositionproperty == outerposition
+    fprintf (plot_stream, "unset tmargin;\n");
+    fprintf (plot_stream, "unset bmargin;\n");
+    fprintf (plot_stream, "unset lmargin;\n");
+    fprintf (plot_stream, "unset rmargin;\n");
+    fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2));
+    sz_str = "";
+    if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
+      sz_str = sprintf ("ratio %g", -dr);
+    else
+      sz_str = "noratio";
+    endif
+    sz_str = sprintf ("set size %s %g, %g;\n", sz_str, pos(3:4));
+  endif
+  if (! isempty (sz_str))
+    fputs (plot_stream, sz_str);
+  endif
 
-    ## Set to false for plotyy axes.
-    ymirror = true;
-    if (isfield (axis_obj, "__plotyy_axes__"))
-      if (all (ishandle (axis_obj.__plotyy_axes__)))
-        ymirror = false;
+  ## Reset all labels, axis-labels, tick-labels, and title
+  ## FIXME - We should have an function to initialize the axis.
+  ##         Presently, this is dispersed in this function.
+  fputs (plot_stream, "unset label;\n");
+  fputs (plot_stream, "unset xtics;\n");
+  fputs (plot_stream, "unset ytics;\n");
+  fputs (plot_stream, "unset ztics;\n");
+  fputs (plot_stream, "unset x2tics;\n");
+  fputs (plot_stream, "unset x2tics;\n");
+
+  if (! isempty (axis_obj.title))
+    t = get (axis_obj.title);
+    if (isempty (t.string))
+      fputs (plot_stream, "unset title;\n");
+    else
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      fprintf (plot_stream, "set title \"%s\" %s %s;\n",
+               undo_string_escapes (tt), fontspec,
+               __do_enhanced_option__ (enhanced, t));
+    endif
+  endif
+
+  if (! isempty (axis_obj.xlabel))
+    t = get (axis_obj.xlabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.xcolor, mono);
+    if (isempty (t.string))
+      fprintf (plot_stream, "unset xlabel;\n");
+      fprintf (plot_stream, "unset x2label;\n");
+    else
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      if (strcmpi (axis_obj.xaxislocation, "top"))
+        fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
       else
-        h = axis_obj.__plotyy_axes__;
-        h = h(ishandle (h));
-        h = h(isprop (h, "__plotyy_axes__"));
-        rmappdata (h, "__plotyy_axes__");
+        fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
+      endif
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+      if (strcmpi (axis_obj.xaxislocation, "top"))
+        fprintf (plot_stream, "unset xlabel;\n");
+      else
+        fprintf (plot_stream, "unset x2label;\n");
       endif
     endif
-
-    nd = __calc_dimensions__ (h);
-
-    if (strcmp (axis_obj.dataaspectratiomode, "manual")
-        && strcmp (axis_obj.xlimmode, "manual")
-        && strcmp (axis_obj.ylimmode, "manual"))
-      ## All can't be "manual"
-      axis_obj.plotboxaspectratiomode = "auto";
-    endif
-
-    if (strcmp (axis_obj.dataaspectratiomode, "manual")
-        && strcmp (axis_obj.xlimmode, "manual")
-        && strcmp (axis_obj.ylimmode, "manual")
-        && (nd == 2 || all (mod (axis_obj.view, 90) == 0)))
-      ## FIXME - adjust plotboxaspectratio to respect other
-      fpos = get (axis_obj.parent, "position");
-      apos = axis_obj.position;
-    endif
-
-    pos = __actual_axis_position__ (h);
+  endif
 
-    if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-      dr = axis_obj.dataaspectratio;
-      if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
-        dr = dr(1) / dr(2);
-      else
-        ## FIXME - need to properly implement 3D
-        dr = mean (dr(1:2)) / dr(3);
-      endif
+  if (! isempty (axis_obj.ylabel))
+    t = get (axis_obj.ylabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.ycolor, mono);
+    if (isempty (t.string))
+      fprintf (plot_stream, "unset ylabel;\n");
+      fprintf (plot_stream, "unset y2label;\n");
     else
-      dr = 1;
-    endif
-
-    if (strcmp (axis_obj.activepositionproperty, "position"))
-      if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
-        if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
-          x = [1, 1];
-        else
-          ## 3D plots need to be sized down to fit in the window.
-          x = 1.0 ./ sqrt ([2, 2.5]);
-        endif
-        fprintf (plot_stream, "set tmargin screen %.15g;\n",
-                 pos(2)+pos(4)/2+x(2)*pos(4)/2);
-        fprintf (plot_stream, "set bmargin screen %.15g;\n",
-                 pos(2)+pos(4)/2-x(2)*pos(4)/2);
-        fprintf (plot_stream, "set lmargin screen %.15g;\n",
-                 pos(1)+pos(3)/2-x(1)*pos(3)/2);
-        fprintf (plot_stream, "set rmargin screen %.15g;\n",
-                 pos(1)+pos(3)/2+x(1)*pos(3)/2);
-        sz_str = "";
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
       else
-        fprintf (plot_stream, "set tmargin 0;\n");
-        fprintf (plot_stream, "set bmargin 0;\n");
-        fprintf (plot_stream, "set lmargin 0;\n");
-        fprintf (plot_stream, "set rmargin 0;\n");
-
-        if (nd == 3 && all (axis_obj.view == [0, 90]))
-          ## FIXME -- Kludge to allow colorbar to be added to a pcolor() plot
-          pos(3:4) = pos(3:4) * 1.4;
-          pos(1:2) = pos(1:2) - pos(3:4) * 0.125;
-        endif
-
-        fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
-
-        if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-          sz_str = sprintf ("set size ratio %.15g", -dr);
-        else
-          sz_str = "set size noratio";
-        endif
-        sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
-      endif
-    else ## activepositionproperty == outerposition
-      fprintf (plot_stream, "unset tmargin;\n");
-      fprintf (plot_stream, "unset bmargin;\n");
-      fprintf (plot_stream, "unset lmargin;\n");
-      fprintf (plot_stream, "unset rmargin;\n");
-      fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2));
-      sz_str = "";
-      if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
-        sz_str = sprintf ("ratio %g", -dr);
-      else
-        sz_str = "noratio";
-      endif
-      sz_str = sprintf ("set size %s %g, %g;\n", sz_str, pos(3:4));
-    endif
-    if (! isempty (sz_str))
-      fputs (plot_stream, sz_str);
-    endif
-
-    ## Reset all labels, axis-labels, tick-labels, and title
-    ## FIXME - We should have an function to initialize the axis.
-    ##         Presently, this is dispersed in this function.
-    fputs (plot_stream, "unset label;\n");
-    fputs (plot_stream, "unset xtics;\n");
-    fputs (plot_stream, "unset ytics;\n");
-    fputs (plot_stream, "unset ztics;\n");
-    fputs (plot_stream, "unset x2tics;\n");
-    fputs (plot_stream, "unset x2tics;\n");
-
-    if (! isempty (axis_obj.title))
-      t = get (axis_obj.title);
-      if (isempty (t.string))
-        fputs (plot_stream, "unset title;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        fprintf (plot_stream, "set title \"%s\" %s %s;\n",
-                 undo_string_escapes (tt), fontspec,
+        fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
                  __do_enhanced_option__ (enhanced, t));
       endif
-    endif
-
-    if (! isempty (axis_obj.xlabel))
-      t = get (axis_obj.xlabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.xcolor, mono);
-      if (isempty (t.string))
-        fprintf (plot_stream, "unset xlabel;\n");
-        fprintf (plot_stream, "unset x2label;\n");
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "unset ylabel;\n");
       else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        if (strcmpi (axis_obj.xaxislocation, "top"))
-          fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        else
-          fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        endif
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-        if (strcmpi (axis_obj.xaxislocation, "top"))
-          fprintf (plot_stream, "unset xlabel;\n");
-        else
-          fprintf (plot_stream, "unset x2label;\n");
-        endif
+        fprintf (plot_stream, "unset y2label;\n");
       endif
     endif
+  endif
 
-    if (! isempty (axis_obj.ylabel))
-      t = get (axis_obj.ylabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.ycolor, mono);
-      if (isempty (t.string))
-        fprintf (plot_stream, "unset ylabel;\n");
-        fprintf (plot_stream, "unset y2label;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        else
-          fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
-                   undo_string_escapes (tt), colorspec, fontspec,
-                   __do_enhanced_option__ (enhanced, t));
-        endif
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "unset ylabel;\n");
-        else
-          fprintf (plot_stream, "unset y2label;\n");
-        endif
-      endif
-    endif
-
-    if (! isempty (axis_obj.zlabel))
-      t = get (axis_obj.zlabel);
-      angle = t.rotation;
-      colorspec = get_text_colorspec (axis_obj.zcolor, mono);
-      if (isempty (t.string))
-        fputs (plot_stream, "unset zlabel;\n");
-      else
-        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-        fontspec = create_fontspec (f, s, gnuplot_term);
-        fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
-                 undo_string_escapes (tt), colorspec, fontspec,
-                 __do_enhanced_option__ (enhanced, t));
-        fprintf (plot_stream, " rotate by %f;\n", angle);
-      endif
-    endif
-
-    if (strcmpi (axis_obj.xaxislocation, "top"))
-      xaxisloc = "x2";
-      xaxisloc_using = "x2";
+  if (! isempty (axis_obj.zlabel))
+    t = get (axis_obj.zlabel);
+    angle = t.rotation;
+    colorspec = get_text_colorspec (axis_obj.zcolor, mono);
+    if (isempty (t.string))
+      fputs (plot_stream, "unset zlabel;\n");
     else
-      xaxisloc = "x";
-      xaxisloc_using = "x1";
-      if (strcmpi (axis_obj.xaxislocation, "zero"))
-        fputs (plot_stream, "set xzeroaxis;\n");
-      endif
+      [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+      fontspec = create_fontspec (f, s, gnuplot_term);
+      fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
+               undo_string_escapes (tt), colorspec, fontspec,
+               __do_enhanced_option__ (enhanced, t));
+      fprintf (plot_stream, " rotate by %f;\n", angle);
+    endif
+  endif
+
+  if (strcmpi (axis_obj.xaxislocation, "top"))
+    xaxisloc = "x2";
+    xaxisloc_using = "x2";
+  else
+    xaxisloc = "x";
+    xaxisloc_using = "x1";
+    if (strcmpi (axis_obj.xaxislocation, "zero"))
+      fputs (plot_stream, "set xzeroaxis;\n");
     endif
-    if (strcmpi (axis_obj.yaxislocation, "right"))
-      yaxisloc = "y2";
-      yaxisloc_using = "y2";
-    else
-      yaxisloc = "y";
-      yaxisloc_using = "y1";
-      if (strcmpi (axis_obj.yaxislocation, "zero"))
-        fputs (plot_stream, "set yzeroaxis;\n");
-      endif
+  endif
+  if (strcmpi (axis_obj.yaxislocation, "right"))
+    yaxisloc = "y2";
+    yaxisloc_using = "y2";
+  else
+    yaxisloc = "y";
+    yaxisloc_using = "y1";
+    if (strcmpi (axis_obj.yaxislocation, "zero"))
+      fputs (plot_stream, "set yzeroaxis;\n");
     endif
+  endif
 
-    have_grid = false;
+  have_grid = false;
+
+  if (strcmpi (axis_obj.xgrid, "on"))
+    have_grid = true;
+    fprintf (plot_stream, "set grid %stics;\n", xaxisloc);
+  else
+    fprintf (plot_stream, "set grid no%stics;\n", xaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.xgrid, "on"))
-      have_grid = true;
-      fprintf (plot_stream, "set grid %stics;\n", xaxisloc);
-    else
-      fprintf (plot_stream, "set grid no%stics;\n", xaxisloc);
-    endif
+  if (strcmpi (axis_obj.ygrid, "on"))
+    have_grid = true;
+    fprintf (plot_stream, "set grid %stics;\n", yaxisloc);
+  else
+    fprintf (plot_stream, "set grid no%stics;\n", yaxisloc);
+  endif
+
+  if (strcmpi (axis_obj.zgrid, "on"))
+    have_grid = true;
+    fputs (plot_stream, "set grid ztics;\n");
+  else
+    fputs (plot_stream, "set grid noztics;\n");
+  endif
 
-    if (strcmpi (axis_obj.ygrid, "on"))
-      have_grid = true;
-      fprintf (plot_stream, "set grid %stics;\n", yaxisloc);
+  if (strcmpi (axis_obj.xminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.xscale, "log"))
+      m = 10;
     else
-      fprintf (plot_stream, "set grid no%stics;\n", yaxisloc);
+      m = 5;
     endif
+    fprintf (plot_stream, "set m%stics %d;\n", xaxisloc, m);
+    fprintf (plot_stream, "set grid m%stics;\n", xaxisloc);
+  else
+    fprintf (plot_stream, "set grid nom%stics;\n", xaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.zgrid, "on"))
-      have_grid = true;
-      fputs (plot_stream, "set grid ztics;\n");
+  if (strcmpi (axis_obj.yminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.yscale, "log"))
+      m = 10;
     else
-      fputs (plot_stream, "set grid noztics;\n");
+      m = 5;
     endif
+    fprintf (plot_stream, "set m%stics %d;\n", yaxisloc, m);
+    fprintf (plot_stream, "set grid m%stics;\n", yaxisloc);
+  else
+    fprintf (plot_stream, "set grid nom%stics;\n", yaxisloc);
+  endif
 
-    if (strcmpi (axis_obj.xminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.xscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set m%stics %d;\n", xaxisloc, m);
-      fprintf (plot_stream, "set grid m%stics;\n", xaxisloc);
+  if (strcmpi (axis_obj.zminorgrid, "on"))
+    have_grid = true;
+    if (strcmp (axis_obj.zscale, "log"))
+      m = 10;
     else
-      fprintf (plot_stream, "set grid nom%stics;\n", xaxisloc);
+      m = 5;
     endif
+    fprintf (plot_stream, "set mztics %d;\n", m);
+    fputs (plot_stream, "set grid mztics;\n");
+  else
+    fputs (plot_stream, "set grid nomztics;\n");
+  endif
+
+  ## The grid front/back/layerdefault option also controls the
+  ## appearance of tics, so it is used even if the grid is absent.
+  if (strcmpi (axis_obj.layer, "top"))
+    fputs (plot_stream, "set grid front;\n");
+    fputs (plot_stream, "set border front;\n");
+  else
+    fputs (plot_stream, "set grid layerdefault;\n");
+    ## FIXME -- the gnuplot help says that "layerdefault" should work
+    ## for set border too, but it fails for me with gnuplot 4.2.5.  So
+    ## use "back" instead.
+    fputs (plot_stream, "set border back;\n");
+  endif
+
+  fprintf (plot_stream, "set grid linewidth %f, linewidth %f;\n",
+           axis_obj.linewidth, axis_obj.linewidth);
 
-    if (strcmpi (axis_obj.yminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.yscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set m%stics %d;\n", yaxisloc, m);
-      fprintf (plot_stream, "set grid m%stics;\n", yaxisloc);
-    else
-      fprintf (plot_stream, "set grid nom%stics;\n", yaxisloc);
-    endif
+  if (! have_grid)
+    fputs (plot_stream, "unset grid;\n");
+  endif
+
+  xlogscale = strcmpi (axis_obj.xscale, "log");
+  ylogscale = strcmpi (axis_obj.yscale, "log");
+  zlogscale = strcmpi (axis_obj.zscale, "log");
 
-    if (strcmpi (axis_obj.zminorgrid, "on"))
-      have_grid = true;
-      if (strcmp (axis_obj.zscale, "log"))
-        m = 10;
-      else
-        m = 5;
-      endif
-      fprintf (plot_stream, "set mztics %d;\n", m);
-      fputs (plot_stream, "set grid mztics;\n");
-    else
-      fputs (plot_stream, "set grid nomztics;\n");
+  ## Detect logscale and negative lims
+  if (xlogscale && all (axis_obj.xlim < 0))
+    axis_obj.xsgn = -1;
+    if (strcmp (axis_obj.xdir, "reverse"))
+      axis_obj.xdir = "normal";
+    elseif (strcmp (axis_obj.xdir, "normal"))
+      axis_obj.xdir = "reverse";
     endif
+    axis_obj.xtick = -flip (axis_obj.xtick);
+    axis_obj.xticklabel = flip (axis_obj.xticklabel);
+    axis_obj.xlim = -flip (axis_obj.xlim);
+  else
+    axis_obj.xsgn = 1;
+  endif
+  if (ylogscale && all (axis_obj.ylim < 0))
+    axis_obj.ysgn = -1;
+    if (strcmp (axis_obj.ydir, "reverse"))
+      axis_obj.ydir = "normal";
+    elseif (strcmp (axis_obj.ydir, "normal"))
+      axis_obj.ydir = "reverse";
+    endif
+    axis_obj.ytick = -flip (axis_obj.ytick);
+    axis_obj.yticklabel = flip (axis_obj.yticklabel);
+    axis_obj.ylim = -flip (axis_obj.ylim);
+  else
+    axis_obj.ysgn = 1;
+  endif
+  if (zlogscale && all (axis_obj.zlim < 0))
+    axis_obj.zsgn = -1;
+    if (strcmp (axis_obj.zdir, "reverse"))
+      axis_obj.zdir = "normal";
+    elseif (strcmp (axis_obj.zdir, "normal"))
+      axis_obj.zdir = "reverse";
+    endif
+    axis_obj.ztick = -flip (axis_obj.ztick);
+    axis_obj.zticklabel = flip (axis_obj.zticklabel);
+    axis_obj.zlim = -flip (axis_obj.zlim);
+  else
+    axis_obj.zsgn = 1;
+  endif
 
-    ## The grid front/back/layerdefault option also controls the
-    ## appearance of tics, so it is used even if the grid is absent.
-    if (strcmpi (axis_obj.layer, "top"))
-      fputs (plot_stream, "set grid front;\n");
-      fputs (plot_stream, "set border front;\n");
-    else
-      fputs (plot_stream, "set grid layerdefault;\n");
-      ## FIXME -- the gnuplot help says that "layerdefault" should work
-      ## for set border too, but it fails for me with gnuplot 4.2.5.  So
-      ## use "back" instead.
-      fputs (plot_stream, "set border back;\n");
-    endif
+  xlim = axis_obj.xlim;
+  ylim = axis_obj.ylim;
+  zlim = axis_obj.zlim;
+  clim = axis_obj.clim;
 
-    fprintf (plot_stream, "set grid linewidth %f, linewidth %f;\n",
-             axis_obj.linewidth, axis_obj.linewidth);
-
-    if (! have_grid)
-      fputs (plot_stream, "unset grid;\n");
-    endif
-
-    xlogscale = strcmpi (axis_obj.xscale, "log");
-    ylogscale = strcmpi (axis_obj.yscale, "log");
-    zlogscale = strcmpi (axis_obj.zscale, "log");
+  do_tics (axis_obj, plot_stream, ymirror, mono, gnuplot_term);
 
-    ## Detect logscale and negative lims
-    if (xlogscale && all (axis_obj.xlim < 0))
-      axis_obj.xsgn = -1;
-      if (strcmp (axis_obj.xdir, "reverse"))
-        axis_obj.xdir = "normal";
-      elseif (strcmp (axis_obj.xdir, "normal"))
-        axis_obj.xdir = "reverse";
-      endif
-      axis_obj.xtick = -flip (axis_obj.xtick);
-      axis_obj.xticklabel = flip (axis_obj.xticklabel);
-      axis_obj.xlim = -flip (axis_obj.xlim);
-    else
-      axis_obj.xsgn = 1;
-    endif
-    if (ylogscale && all (axis_obj.ylim < 0))
-      axis_obj.ysgn = -1;
-      if (strcmp (axis_obj.ydir, "reverse"))
-        axis_obj.ydir = "normal";
-      elseif (strcmp (axis_obj.ydir, "normal"))
-        axis_obj.ydir = "reverse";
-      endif
-      axis_obj.ytick = -flip (axis_obj.ytick);
-      axis_obj.yticklabel = flip (axis_obj.yticklabel);
-      axis_obj.ylim = -flip (axis_obj.ylim);
-    else
-      axis_obj.ysgn = 1;
+  fputs (plot_stream, "unset logscale;\n");
+  if (xlogscale)
+    fprintf (plot_stream, "set logscale %s;\n", xaxisloc);
+  endif
+  if (ylogscale)
+    fprintf (plot_stream, "set logscale %s;\n", yaxisloc);
+  endif
+  if (zlogscale)
+    fputs (plot_stream, "set logscale z;\n");
+  endif
+
+  xautoscale = strcmpi (axis_obj.xlimmode, "auto");
+  yautoscale = strcmpi (axis_obj.ylimmode, "auto");
+  zautoscale = strcmpi (axis_obj.zlimmode, "auto");
+  cautoscale = strcmpi (axis_obj.climmode, "auto");
+  cdatadirect = false;
+  truecolor = false;
+
+  fputs (plot_stream, "set clip two;\n");
+
+  kids = axis_obj.children;
+  ## Remove the axis labels and title from the children, and
+  ## preserved the original order.
+  [jnk, k] = setdiff (kids, [axis_obj.xlabel; axis_obj.ylabel; ...
+                             axis_obj.zlabel; axis_obj.title]);
+  kids = kids (sort (k));
+
+  if (nd == 3)
+    fputs (plot_stream, "set parametric;\n");
+    fputs (plot_stream, "set style data lines;\n");
+    fputs (plot_stream, "set surface;\n");
+    fputs (plot_stream, "unset contour;\n");
+  endif
+
+  data_idx = 0;
+  data = cell ();
+  is_image_data = [];
+  hidden_removal = NaN;
+  view_map = false;
+
+  if (! cautoscale && clim(1) == clim(2))
+    clim(2)++;
+  endif
+  addedcmap = [];
+
+  ximg_data = {};
+  ximg_data_idx = 0;
+
+  while (! isempty (kids))
+
+    obj = get (kids(end));
+
+    if (isfield (obj, "xdata"))
+      obj.xdata = double (obj.xdata);
     endif
-    if (zlogscale && all (axis_obj.zlim < 0))
-      axis_obj.zsgn = -1;
-      if (strcmp (axis_obj.zdir, "reverse"))
-        axis_obj.zdir = "normal";
-      elseif (strcmp (axis_obj.zdir, "normal"))
-        axis_obj.zdir = "reverse";
-      endif
-      axis_obj.ztick = -flip (axis_obj.ztick);
-      axis_obj.zticklabel = flip (axis_obj.zticklabel);
-      axis_obj.zlim = -flip (axis_obj.zlim);
-    else
-      axis_obj.zsgn = 1;
+    if (isfield (obj, "ydata"))
+      obj.ydata = double (obj.ydata);
     endif
-
-    xlim = axis_obj.xlim;
-    ylim = axis_obj.ylim;
-    zlim = axis_obj.zlim;
-    clim = axis_obj.clim;
-
-    do_tics (axis_obj, plot_stream, ymirror, mono, gnuplot_term);
-
-    fputs (plot_stream, "unset logscale;\n");
-    if (xlogscale)
-      fprintf (plot_stream, "set logscale %s;\n", xaxisloc);
-    endif
-    if (ylogscale)
-      fprintf (plot_stream, "set logscale %s;\n", yaxisloc);
-    endif
-    if (zlogscale)
-      fputs (plot_stream, "set logscale z;\n");
+    if (isfield (obj, "zdata"))
+      obj.zdata = double (obj.zdata);
     endif
 
-    xautoscale = strcmpi (axis_obj.xlimmode, "auto");
-    yautoscale = strcmpi (axis_obj.ylimmode, "auto");
-    zautoscale = strcmpi (axis_obj.zlimmode, "auto");
-    cautoscale = strcmpi (axis_obj.climmode, "auto");
-    cdatadirect = false;
-    truecolor = false;
-
-    fputs (plot_stream, "set clip two;\n");
+    if (isfield (obj, "units"))
+      units = obj.units;
+      unwind_protect
+        set (kids(end), "units", "data");
+        obj = get (kids(end));
+      unwind_protect_cleanup
+        set (kids(end), "units", units);
+      end_unwind_protect
+    endif
+    kids = kids(1:(end-1));
 
-    kids = axis_obj.children;
-    ## Remove the axis labels and title from the children, and
-    ## preserved the original order.
-    [jnk, k] = setdiff (kids, [axis_obj.xlabel; axis_obj.ylabel; ...
-                               axis_obj.zlabel; axis_obj.title]);
-    kids = kids (sort (k));
+    if (strcmp (obj.visible, "off"))
+      continue;
+    endif
 
-    if (nd == 3)
-      fputs (plot_stream, "set parametric;\n");
-      fputs (plot_stream, "set style data lines;\n");
-      fputs (plot_stream, "set surface;\n");
-      fputs (plot_stream, "unset contour;\n");
+    if (xlogscale && isfield (obj, "xdata"))
+      obj.xdata = axis_obj.xsgn * obj.xdata;
+      obj.xdata(obj.xdata<=0) = NaN;
+    endif
+    if (ylogscale && isfield (obj, "ydata"))
+      obj.ydata = axis_obj.ysgn * obj.ydata;
+      obj.ydata(obj.ydata<=0) = NaN;
+    endif
+    if (zlogscale && isfield (obj, "zdata"))
+      obj.zdata = axis_obj.zsgn * obj.zdata;
+      obj.zdata(obj.zdata<=0) = NaN;
     endif
 
-    data_idx = 0;
-    data = cell ();
-    is_image_data = [];
-    hidden_removal = NaN;
-    view_map = false;
+    ## Check for facecolor interpolation for surfaces.
+    doing_interp_color = ...
+       isfield (obj, "facecolor") && strcmp (obj.facecolor, "interp");
 
-    if (! cautoscale && clim(1) == clim(2))
-      clim(2)++;
-    endif
-    addedcmap = [];
-
-    ximg_data = {};
-    ximg_data_idx = 0;
-
-    while (! isempty (kids))
-
-      obj = get (kids(end));
+    switch (obj.type)
+      case "image"
+        img_data = obj.cdata;
+        img_xdata = obj.xdata;
+        img_ydata = obj.ydata;
 
-      if (isfield (obj, "xdata"))
-        obj.xdata = double (obj.xdata);
-      end
-      if (isfield (obj, "ydata"))
-        obj.ydata = double (obj.ydata);
-      end
-      if (isfield (obj, "zdata"))
-        obj.zdata = double (obj.zdata);
-      end
+        if (ndims (img_data) == 3)
+          truecolor = true;
+        elseif (strcmpi (obj.cdatamapping, "direct"))
+          cdatadirect = true;
+        endif
+        data_idx++;
+        is_image_data(data_idx) = true;
+        parametric(data_idx) = false;
+        have_cdata(data_idx) = false;
+        have_3d_patch(data_idx) = false;
 
-      if (isfield (obj, "units"))
-        units = obj.units;
-        unwind_protect
-          set (kids(end), "units", "data");
-          obj = get (kids(end));
-        unwind_protect_cleanup
-          set (kids(end), "units", units);
-        end_unwind_protect
-      endif
-      kids = kids(1:(end-1));
-
-      if (strcmp (obj.visible, "off"))
-        continue;
-      endif
+        if (img_xdata(2) < img_xdata(1))
+          img_xdata = img_xdata(2:-1:1);
+          img_data = img_data(:,end:-1:1,:);
+        elseif (img_xdata(1) == img_xdata(2))
+          img_xdata = img_xdata(1) + [0, columns(img_data)-1];
+        endif
+        if (img_ydata(2) < img_ydata(1))
+          img_ydata = img_ydata(2:-1:1);
+          img_data = img_data(end:-1:1,:,:);
+        elseif (img_ydata(1) == img_ydata(2))
+          img_ydata = img_ydata(1) + [0, rows(img_data)-1];
+        endif
 
-      if (xlogscale && isfield (obj, "xdata"))
-        obj.xdata = axis_obj.xsgn * obj.xdata;
-        obj.xdata(obj.xdata<=0) = NaN;
-      endif
-      if (ylogscale && isfield (obj, "ydata"))
-        obj.ydata = axis_obj.ysgn * obj.ydata;
-        obj.ydata(obj.ydata<=0) = NaN;
-      endif
-      if (zlogscale && isfield (obj, "zdata"))
-        obj.zdata = axis_obj.zsgn * obj.zdata;
-        obj.zdata(obj.zdata<=0) = NaN;
-      endif
+        [y_dim, x_dim] = size (img_data(:,:,1));
+        if (x_dim > 1)
+          dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
+        else
+          x_dim = 2;
+          img_data = [img_data, img_data];
+          dx = abs (img_xdata(2)-img_xdata(1));
+        endif
+        if (y_dim > 1)
+          dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
+        else
+          y_dim = 2;
+          img_data = [img_data; img_data];
+          dy = abs (img_ydata(2)-img_ydata(1));
+        endif
 
-      ## Check for facecolor interpolation for surfaces.
-      doing_interp_color = ...
-         isfield (obj, "facecolor") && strncmp (obj.facecolor, "interp", 6);
+        x_origin = min (img_xdata);
+        y_origin = min (img_ydata);
 
-      switch (obj.type)
-        case "image"
-          img_data = obj.cdata;
-          img_xdata = obj.xdata;
-          img_ydata = obj.ydata;
+        if (ndims (img_data) == 3)
+          data{data_idx} = permute (img_data, [3, 1, 2])(:);
+          format = "1:2:3";
+          imagetype = "rgbimage";
+        else
+          data{data_idx} = img_data(:);
+          format = "1";
+          imagetype = "image";
+        endif
 
-          if (ndims (img_data) == 3)
-            truecolor = true;
-          elseif (strcmpi (obj.cdatamapping, "direct"))
-            cdatadirect = true;
-          endif
-          data_idx++;
-          is_image_data(data_idx) = true;
-          parametric(data_idx) = false;
-          have_cdata(data_idx) = false;
-          have_3d_patch(data_idx) = false;
+        titlespec{data_idx} = "title \"\"";
+        usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
+            x_dim, y_dim, x_origin, y_origin, dx, dy, format);
+        withclause{data_idx} = sprintf ("with %s;", imagetype);
 
-          if (img_xdata(2) < img_xdata(1))
-            img_xdata = img_xdata(2:-1:1);
-            img_data = img_data(:,end:-1:1,:);
-          elseif (img_xdata(1) == img_xdata(2))
-            img_xdata = img_xdata(1) + [0, columns(img_data)-1];
-          endif
-          if (img_ydata(2) < img_ydata(1))
-            img_ydata = img_ydata(2:-1:1);
-            img_data = img_data(end:-1:1,:,:);
-          elseif (img_ydata(1) == img_ydata(2))
-            img_ydata = img_ydata(1) + [0, rows(img_data)-1];
-          endif
-
-          [y_dim, x_dim] = size (img_data(:,:,1));
-          if (x_dim > 1)
-            dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
-          else
-            x_dim = 2;
-            img_data = [img_data, img_data];
-            dx = abs (img_xdata(2)-img_xdata(1));
-          endif
-          if (y_dim > 1)
-            dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
+      case "line"
+        if (strcmp (obj.linestyle, "none")
+            && (! isfield (obj, "marker")
+                || (isfield (obj, "marker")
+                    && strcmp (obj.marker, "none"))))
+          continue;
+        endif
+        data_idx++;
+        is_image_data(data_idx) = false;
+        parametric(data_idx) = true;
+        have_cdata(data_idx) = false;
+        have_3d_patch(data_idx) = false;
+        if (isempty (obj.displayname))
+          titlespec{data_idx} = "title \"\"";
+        else
+          tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+          titlespec{data_idx} = ['title "' tmp '"'];
+        endif
+        usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+        errbars = "";
+        if (nd == 3)
+          xdat = obj.xdata(:);
+          ydat = obj.ydata(:);
+          if (! isempty (obj.zdata))
+            zdat = obj.zdata(:);
           else
-            y_dim = 2;
-            img_data = [img_data; img_data];
-            dy = abs (img_ydata(2)-img_ydata(1));
-          endif
-
-          x_origin = min (img_xdata);
-          y_origin = min (img_ydata);
-
-          if (ndims (img_data) == 3)
-            data{data_idx} = permute (img_data, [3, 1, 2])(:);
-            format = "1:2:3";
-            imagetype = "rgbimage";
-          else
-            data{data_idx} = img_data(:);
-            format = "1";
-            imagetype = "image";
-          endif
-
-          titlespec{data_idx} = "title \"\"";
-          usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
-              x_dim, y_dim, x_origin, y_origin, dx, dy, format);
-          withclause{data_idx} = sprintf ("with %s;", imagetype);
-
-        case "line"
-          if (strncmp (obj.linestyle, "none", 4)
-              && (! isfield (obj, "marker")
-                  || (isfield (obj, "marker")
-                      && strncmp (obj.marker, "none", 4))))
-            continue;
-          endif
-          data_idx++;
-          is_image_data(data_idx) = false;
-          parametric(data_idx) = true;
-          have_cdata(data_idx) = false;
-          have_3d_patch(data_idx) = false;
-          if (isempty (obj.displayname))
-            titlespec{data_idx} = "title \"\"";
-          else
-            tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-            titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
+            zdat = zeros (size (xdat));
           endif
-          usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
-          errbars = "";
-          if (nd == 3)
-            xdat = obj.xdata(:);
-            ydat = obj.ydata(:);
-            if (! isempty (obj.zdata))
-              zdat = obj.zdata(:);
-            else
-              zdat = zeros (size (xdat));
-            endif
-            data{data_idx} = [xdat, ydat, zdat]';
-            usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
-            ## fputs (plot_stream, "set parametric;\n");
-          else
-            xdat = obj.xdata(:);
-            ydat = obj.ydata(:);
-            data{data_idx} = [xdat, ydat]';
-            usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
-                                            rows (xdat), xaxisloc_using, yaxisloc_using);
-          endif
+          data{data_idx} = [xdat, ydat, zdat]';
+          usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
+          ## fputs (plot_stream, "set parametric;\n");
+        else
+          xdat = obj.xdata(:);
+          ydat = obj.ydata(:);
+          data{data_idx} = [xdat, ydat]';
+          usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
+                                          rows (xdat), xaxisloc_using, yaxisloc_using);
+        endif
 
-          style = do_linestyle_command (obj, obj.color, data_idx, mono,
-                                        plot_stream, errbars);
+        style = do_linestyle_command (obj, obj.color, data_idx, mono,
+                                      plot_stream, errbars);
 
-          withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{1}, data_idx);
+        withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{1}, data_idx);
 
-          if (length (style) > 1)
-            data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1);
-            parametric(data_idx) = parametric(data_idx - 1);
-            have_cdata(data_idx) = have_cdata(data_idx - 1);
-            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-            titlespec{data_idx} = "title \"\"";
-            usingclause{data_idx} = usingclause{data_idx - 1};
-            data{data_idx} = data{data_idx - 1};
-            withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{2}, data_idx);
-          endif
-          if (length (style) > 2)
-            data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1);
-            parametric(data_idx) = parametric(data_idx - 1);
-            have_cdata(data_idx) = have_cdata(data_idx - 1);
-            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-            titlespec{data_idx} = "title \"\"";
-            usingclause{data_idx} = usingclause{data_idx - 1};
-            data{data_idx} = data{data_idx - 1};
-            withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                          style{3}, data_idx);
-          endif
+        if (length (style) > 1)
+          data_idx++;
+          is_image_data(data_idx) = is_image_data(data_idx - 1);
+          parametric(data_idx) = parametric(data_idx - 1);
+          have_cdata(data_idx) = have_cdata(data_idx - 1);
+          have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+          titlespec{data_idx} = "title \"\"";
+          usingclause{data_idx} = usingclause{data_idx - 1};
+          data{data_idx} = data{data_idx - 1};
+          withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{2}, data_idx);
+        endif
+        if (length (style) > 2)
+          data_idx++;
+          is_image_data(data_idx) = is_image_data(data_idx - 1);
+          parametric(data_idx) = parametric(data_idx - 1);
+          have_cdata(data_idx) = have_cdata(data_idx - 1);
+          have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+          titlespec{data_idx} = "title \"\"";
+          usingclause{data_idx} = usingclause{data_idx - 1};
+          data{data_idx} = data{data_idx - 1};
+          withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                        style{3}, data_idx);
+        endif
 
-       case "patch"
-         cmap = parent_figure_obj.colormap;
-         [nr, nc] = size (obj.xdata);
+     case "patch"
+       cmap = parent_figure_obj.colormap;
+       [nr, nc] = size (obj.xdata);
 
-         if (! isempty (obj.cdata))
-           cdat = obj.cdata;
-           if (strcmpi (obj.cdatamapping, "direct"))
-             cdatadirect = true;
+       if (! isempty (obj.cdata))
+         cdat = obj.cdata;
+         if (strcmpi (obj.cdatamapping, "direct"))
+           cdatadirect = true;
+         endif
+       else
+         cdat = [];
+       endif
+
+       data_3d_idx = NaN;
+       for i = 1:nc
+         xcol = obj.xdata(:,i);
+         ycol = obj.ydata(:,i);
+         if (nd == 3)
+           if (! isempty (obj.zdata))
+             zcol = obj.zdata(:,i);
+           else
+             zcol = zeros (size (xcol));
            endif
-         else
-           cdat = [];
          endif
 
-         data_3d_idx = NaN;
-         for i = 1:nc
-           xcol = obj.xdata(:,i);
-           ycol = obj.ydata(:,i);
-           if (nd == 3)
-             if (! isempty (obj.zdata))
-               zcol = obj.zdata(:,i);
-             else
-               zcol = zeros (size (xcol));
-             endif
-           endif
-
-           if (! isnan (xcol) && ! isnan (ycol))
-             ## Is the patch closed or not
-             if (strncmp (obj.facecolor, "none", 4))
-               hidden_removal = false;
-             else
+         if (! isnan (xcol) && ! isnan (ycol))
+           ## Is the patch closed or not
+           if (strcmp (obj.facecolor, "none"))
+             hidden_removal = false;
+           else
 
-               if (isnan (hidden_removal))
-                 hidden_removal = true;
-               endif
-               if (nd == 3)
-                 if (numel (xcol) > 3)
-                   error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3D filled triangular patches");
-                 else
-                   if (isnan (data_3d_idx))
-                     data_idx++;
-                     data_3d_idx = data_idx;
-                     is_image_data(data_idx) = false;
-                     parametric(data_idx) = false;
-                     have_cdata(data_idx) = true;
-                     have_3d_patch(data_idx) = true;
-                     withclause{data_3d_idx} = sprintf ("with pm3d");
-                     usingclause{data_3d_idx} =  "using 1:2:3:4";
-                     data{data_3d_idx} = [];
-                   endif
-                   local_idx = data_3d_idx;
-                   ccdat = NaN;
+             if (isnan (hidden_removal))
+               hidden_removal = true;
+             endif
+             if (nd == 3)
+               if (numel (xcol) > 3)
+                 error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3-D filled triangular patches");
+               else
+                 if (isnan (data_3d_idx))
+                   data_idx++;
+                   data_3d_idx = data_idx;
+                   is_image_data(data_idx) = false;
+                   parametric(data_idx) = false;
+                   have_cdata(data_idx) = true;
+                   have_3d_patch(data_idx) = true;
+                   withclause{data_3d_idx} = sprintf ("with pm3d");
+                   usingclause{data_3d_idx} =  "using 1:2:3:4";
+                   data{data_3d_idx} = [];
                  endif
-               else
-                 data_idx++;
-                 local_idx = data_idx;
-                 is_image_data(data_idx) = false;
-                 parametric(data_idx) = false;
-                 have_cdata(data_idx) = false;
-                 have_3d_patch(data_idx) = false;
-               endif
-
-               if (i > 1 || isempty (obj.displayname))
-                 titlespec{local_idx} = "title \"\"";
-               else
-                 tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-                 titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
+                 local_idx = data_3d_idx;
+                 ccdat = NaN;
                endif
-               if (isfield (obj, "facecolor"))
-                 if ((strncmp (obj.facecolor, "flat", 4)
-                     || strncmp (obj.facecolor, "interp", 6))
-                     && isfield (obj, "cdata"))
-                   if (ndims (obj.cdata) == 2
-                       && (columns (obj.cdata) == nc
-                           && (rows (obj.cdata) == 1
-                               || rows (obj.cdata) == 3)))
-                     ccol = cdat (:, i);
-                   elseif (ndims (obj.cdata) == 2
-                       && (rows (obj.cdata) == nc
-                           && (columns (obj.cdata) == 1
-                               || columns (obj.cdata) == 3)))
-                     ccol = cdat (i, :);
-                   elseif (ndims (obj.cdata) == 3)
-                     ccol = permute (cdat (:, i, :), [1, 3, 2]);
-                   else
-                     ccol = cdat;
-                   endif
-                   if (strncmp (obj.facecolor, "flat", 4))
-                     if (isequal (size (ccol), [1, 3]))
-                       ## RGB Triplet
-                       color = ccol;
-                     elseif (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol;
-                     else
-                       if (cdatadirect)
-                         r = round (ccol);
-                       else
-                         r = 1 + round ((rows (cmap) - 1)
-                                        * (ccol - clim(1))/(clim(2) - clim(1)));
-                       endif
-                       r = max (1, min (r, rows (cmap)));
-                       color = cmap(r, :);
-                     endif
-                   elseif (strncmp (obj.facecolor, "interp", 6))
-                     if (nd == 3 && numel (xcol) == 3)
-                       ccdat = ccol;
-                       if (! isvector (ccdat))
-                         tmp = rows (cmap) + rows (addedcmap) + ...
-                              [1 : rows(ccdat)];
-                         addedcmap = [addedcmap; ccdat];
-                         ccdat = tmp(:);
-                       else
-                         ccdat = ccdat(:);
-                       endif
-                     else
-                       if (sum (diff (ccol)))
-                         warning ("\"interp\" not supported, using 1st entry of cdata");
-                       endif
-                       if (cdatadirect)
-                         r = round (ccol);
-                       else
-                         r = 1 + round ((rows (cmap) - 1)
-                                        * (ccol - clim(1))/(clim(2) - clim(1)));
-                       endif
-                       r = max (1, min (r, rows (cmap)));
-                       color = cmap(r(1),:);
-                     endif
-                   endif
-                 elseif (isnumeric (obj.facecolor))
-                   color = obj.facecolor;
-                 else
-                   color = [0, 1, 0];
-                 endif
-               else
-                 color = [0, 1, 0];
-               endif
-
-               if (nd == 3 && numel (xcol) == 3)
-                 if (isnan (ccdat))
-                   ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
-                   addedcmap = [addedcmap; reshape(color, 1, 3)];
-                 endif
-                 data{data_3d_idx} = [data{data_3d_idx}, ...
-                                      [[xcol; xcol(end)], [ycol; ycol(end)], ...
-                                      [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
-               else
-                 if (mono)
-                   colorspec = "";
-                 elseif (__gnuplot_has_feature__ ("transparent_patches")
-                         && isscalar (obj.facealpha))
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\" fillstyle transparent solid %f",
-                                      round (255*color), obj.facealpha);
-                 else
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                        round (255*color));
-                 endif
-
-                 withclause{data_idx} = sprintf ("with filledcurve %s",
-                                               colorspec);
-                 data{data_idx} = [xcol, ycol]';
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
-                                                  numel (xcol));
-               endif
-             endif
-           endif
-
-           ## patch outline
-           if (!(strncmp (obj.edgecolor, "none", 4)
-                  && (strncmp (obj.marker, "none", 4)
-                      || (strncmp (obj.markeredgecolor, "none", 4)
-                          && strncmp (obj.markerfacecolor, "none", 4)))))
-
-             data_idx++;
-             is_image_data(data_idx) = false;
-             parametric(data_idx) = false;
-             have_cdata(data_idx) = false;
-             have_3d_patch(data_idx) = false;
-             titlespec{data_idx} = "title \"\"";
-             usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
-
-             if (isfield (obj, "markersize"))
-               mdat = obj.markersize / 3;
+             else
+               data_idx++;
+               local_idx = data_idx;
+               is_image_data(data_idx) = false;
+               parametric(data_idx) = false;
+               have_cdata(data_idx) = false;
+               have_3d_patch(data_idx) = false;
              endif
 
-             if (isfield (obj, "edgecolor"))
-               ## FIXME
-               ## This is the wrong thing to do as edgecolor, markeredgecolor
-               ## and markerfacecolor can have different values and we should
-               ## treat them seperately. However, the below allow the scatter
-               ## functions to work as expected, where only one of these values
-               ## is set
-               if (strncmp (obj.edgecolor, "none", 4))
-                 if (strncmp (obj.markeredgecolor, "none", 4))
-                   ec = obj.markerfacecolor;
-                 else
-                   ec = obj.markeredgecolor;
-                 endif
-               else
-                 ec = obj.edgecolor;
-               endif
-
-               if ((strncmp (ec, "flat", 4)
-                    || strncmp (ec, "interp", 6))
+             if (i > 1 || isempty (obj.displayname))
+               titlespec{local_idx} = "title \"\"";
+             else
+               tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+               titlespec{local_idx} = ['title "' tmp '"'];
+             endif
+             if (isfield (obj, "facecolor"))
+               if ((strcmp (obj.facecolor, "flat")
+                   || strcmp (obj.facecolor, "interp"))
                    && isfield (obj, "cdata"))
                  if (ndims (obj.cdata) == 2
                      && (columns (obj.cdata) == nc
                          && (rows (obj.cdata) == 1
                              || rows (obj.cdata) == 3)))
                    ccol = cdat (:, i);
                  elseif (ndims (obj.cdata) == 2
-                         && (rows (obj.cdata) == nc
-                             && (columns (obj.cdata) == 1
-                                 || columns (obj.cdata) == 3)))
+                     && (rows (obj.cdata) == nc
+                         && (columns (obj.cdata) == 1
+                             || columns (obj.cdata) == 3)))
                    ccol = cdat (i, :);
                  elseif (ndims (obj.cdata) == 3)
                    ccol = permute (cdat (:, i, :), [1, 3, 2]);
                  else
                    ccol = cdat;
                  endif
-                 if (strncmp (ec, "flat", 4))
-                   if (numel (ccol) == 3)
+                 if (strcmp (obj.facecolor, "flat"))
+                   if (isequal (size (ccol), [1, 3]))
+                     ## RGB Triplet
                      color = ccol;
+                   elseif (nd == 3 && numel (xcol) == 3)
+                     ccdat = ccol;
                    else
-                     if (isscalar (ccol))
-                       ccol = repmat (ccol, numel (xcol), 1);
+                     if (cdatadirect)
+                       r = round (ccol);
+                     else
+                       r = 1 + round ((rows (cmap) - 1)
+                                      * (ccol - clim(1))/(clim(2) - clim(1)));
                      endif
-                     color = "flat";
-                     have_cdata(data_idx) = true;
+                     r = max (1, min (r, rows (cmap)));
+                     color = cmap(r, :);
                    endif
-                 elseif (strncmp (ec, "interp", 6))
-                   if (numel (ccol) == 3)
-                     warning ("\"interp\" not supported, using 1st entry of cdata");
-                     color = ccol(1,:);
+                 elseif (strcmp (obj.facecolor, "interp"))
+                   if (nd == 3 && numel (xcol) == 3)
+                     ccdat = ccol;
+                     if (! isvector (ccdat))
+                       tmp = rows (cmap) + rows (addedcmap) + ...
+                            [1 : rows(ccdat)];
+                       addedcmap = [addedcmap; ccdat];
+                       ccdat = tmp(:);
+                     else
+                       ccdat = ccdat(:);
+                     endif
                    else
-                     if (isscalar (ccol))
-                       ccol = repmat (ccol, numel (xcol), 1);
+                     if (sum (diff (ccol)))
+                       warning ("\"interp\" not supported, using 1st entry of cdata");
                      endif
-                     color = "interp";
-                     have_cdata(data_idx) = true;
+                     if (cdatadirect)
+                       r = round (ccol);
+                     else
+                       r = 1 + round ((rows (cmap) - 1)
+                                      * (ccol - clim(1))/(clim(2) - clim(1)));
+                     endif
+                     r = max (1, min (r, rows (cmap)));
+                     color = cmap(r(1),:);
                    endif
                  endif
-               elseif (isnumeric (ec))
-                 color = ec;
+               elseif (isnumeric (obj.facecolor))
+                 color = obj.facecolor;
                else
-                 color = [0, 0, 0];
+                 color = [0, 1, 0];
                endif
              else
-               color = [0, 0, 0];
+               color = [0, 1, 0];
              endif
 
-             if (isfield (obj, "linestyle"))
-               switch (obj.linestyle)
-                 case "-"
-                   lt = "lt 1";
-                 case "--"
-                   lt = "lt 2";
-                 case ":"
-                   lt = "lt 3";
-                 case "-."
-                   lt = "lt 6";
-                 case "none"
-                   lt = "";
-                 otherwise
-                   lt = "";
-               endswitch
+             if (nd == 3 && numel (xcol) == 3)
+               if (isnan (ccdat))
+                 ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
+                 addedcmap = [addedcmap; reshape(color, 1, 3)];
+               endif
+               data{data_3d_idx} = [data{data_3d_idx}, ...
+                                    [[xcol; xcol(end)], [ycol; ycol(end)], ...
+                                    [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
              else
-               lt = "";
-             endif
-
-             if (isfield (obj, "linewidth"))
-               lw = sprintf ("linewidth %f", obj.linewidth);
-             else
-               lw  = "";
-             endif
-
-             [pt, pt2, obj] = gnuplot_pointtype (obj);
-             if (! isempty (pt))
-               pt = sprintf ("pointtype %s", pt);
-             endif
-             if (! isempty (pt2))
-               pt2 = sprintf ("pointtype %s", pt2);
-             endif
-
-             if (mono)
-               colorspec = "";
-             else
-               if (ischar (color))
-                 colorspec = "palette";
+               if (mono)
+                 colorspec = "";
+               elseif (__gnuplot_has_feature__ ("transparent_patches")
+                       && isscalar (obj.facealpha))
+                 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\" fillstyle transparent solid %f",
+                                    round (255*color), obj.facealpha);
                else
                  colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                       round (255*color));
                endif
+
+               withclause{data_idx} = sprintf ("with filledcurve %s",
+                                             colorspec);
+               data{data_idx} = [xcol, ycol]';
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
+                                                numel (xcol));
+             endif
+           endif
+         endif
+
+         ## patch outline
+         if (!(strcmp (obj.edgecolor, "none")
+                && (strcmp (obj.marker, "none")
+                    || (strcmp (obj.markeredgecolor, "none")
+                        && strcmp (obj.markerfacecolor, "none")))))
+
+           data_idx++;
+           is_image_data(data_idx) = false;
+           parametric(data_idx) = false;
+           have_cdata(data_idx) = false;
+           have_3d_patch(data_idx) = false;
+           titlespec{data_idx} = "title \"\"";
+           usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+
+           if (isfield (obj, "markersize"))
+             mdat = obj.markersize / 3;
+           endif
+
+           if (isfield (obj, "edgecolor"))
+             ## FIXME
+             ## This is the wrong thing to do as edgecolor, markeredgecolor
+             ## and markerfacecolor can have different values and we should
+             ## treat them seperately. However, the below allow the scatter
+             ## functions to work as expected, where only one of these values
+             ## is set
+             if (strcmp (obj.edgecolor, "none"))
+               if (strcmp (obj.markeredgecolor, "none"))
+                 ec = obj.markerfacecolor;
+               else
+                 ec = obj.markeredgecolor;
+               endif
+             else
+               ec = obj.edgecolor;
              endif
 
-             sidx = 1;
-             if (isempty (lt))
-               style = "";
+             if ((strcmp (ec, "flat")
+                  || strcmp (ec, "interp"))
+                 && isfield (obj, "cdata"))
+               if (ndims (obj.cdata) == 2
+                   && (columns (obj.cdata) == nc
+                       && (rows (obj.cdata) == 1
+                           || rows (obj.cdata) == 3)))
+                 ccol = cdat (:, i);
+               elseif (ndims (obj.cdata) == 2
+                       && (rows (obj.cdata) == nc
+                           && (columns (obj.cdata) == 1
+                               || columns (obj.cdata) == 3)))
+                 ccol = cdat (i, :);
+               elseif (ndims (obj.cdata) == 3)
+                 ccol = permute (cdat (:, i, :), [1, 3, 2]);
+               else
+                 ccol = cdat;
+               endif
+               if (strcmp (ec, "flat"))
+                 if (numel (ccol) == 3)
+                   color = ccol;
+                 else
+                   if (isscalar (ccol))
+                     ccol = repmat (ccol, numel (xcol), 1);
+                   endif
+                   color = "flat";
+                   have_cdata(data_idx) = true;
+                 endif
+               elseif (strcmp (ec, "interp"))
+                 if (numel (ccol) == 3)
+                   warning ("\"interp\" not supported, using 1st entry of cdata");
+                   color = ccol(1,:);
+                 else
+                   if (isscalar (ccol))
+                     ccol = repmat (ccol, numel (xcol), 1);
+                   endif
+                   color = "interp";
+                   have_cdata(data_idx) = true;
+                 endif
+               endif
+             elseif (isnumeric (ec))
+               color = ec;
              else
-               style = "lines";
+               color = [0, 0, 0];
              endif
-             tmpwith = {};
+           else
+             color = [0, 0, 0];
+           endif
+
+           if (isfield (obj, "linestyle"))
+             switch (obj.linestyle)
+               case "-"
+                 lt = "lt 1";
+               case "--"
+                 lt = "lt 2";
+               case ":"
+                 lt = "lt 3";
+               case "-."
+                 lt = "lt 6";
+               case "none"
+                 lt = "";
+               otherwise
+                 lt = "";
+             endswitch
+           else
+             lt = "";
+           endif
+
+           if (isfield (obj, "linewidth"))
+             lw = sprintf ("linewidth %f", obj.linewidth);
+           else
+             lw  = "";
+           endif
 
-             facesame = true;
-             if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
-                 && !strncmp (obj.markerfacecolor, "none", 4))
-               if (strncmp (obj.markerfacecolor, "auto", 4)
-                   || ! isnumeric (obj.markerfacecolor)
-                   || (isnumeric (obj.markerfacecolor)
-                       && isequal (color, obj.markerfacecolor)))
+           [pt, pt2, obj] = gnuplot_pointtype (obj);
+           if (! isempty (pt))
+             pt = sprintf ("pointtype %s", pt);
+           endif
+           if (! isempty (pt2))
+             pt2 = sprintf ("pointtype %s", pt2);
+           endif
+
+           if (mono)
+             colorspec = "";
+           else
+             if (ischar (color))
+               colorspec = "palette";
+             else
+               colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                    round (255*color));
+             endif
+           endif
+
+           sidx = 1;
+           if (isempty (lt))
+             style = "";
+           else
+             style = "lines";
+           endif
+           tmpwith = {};
+
+           facesame = true;
+           if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
+               && !strcmp (obj.markerfacecolor, "none"))
+             if (strcmp (obj.markerfacecolor, "auto")
+                 || ! isnumeric (obj.markerfacecolor)
+                 || (isnumeric (obj.markerfacecolor)
+                     && isequal (color, obj.markerfacecolor)))
+               style = strcat (style, "points");
+               if (isfield (obj, "markersize"))
+                 if (length (mdat) == nc)
+                   m = mdat(i);
+                 else
+                   m = mdat;
+                 endif
+                 ps = sprintf ("pointsize %f", m / 3);
+               else
+                 ps = "";
+               endif
+
+               tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                        style, lw, pt2, lt, ps,
+                                        colorspec);
+             else
+               facesame = false;
+               if (! isempty (style))
+                 tmpwith{sidx} = sprintf ("with %s %s %s %s",
+                                          style, lw, lt,
+                                          colorspec);
+                 sidx ++;
+               endif
+               if (isnumeric (obj.markerfacecolor) && ! mono)
+                 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                      round (255*obj.markerfacecolor));
+               endif
+               style = "points";
+               if (isfield (obj, "markersize"))
+                 if (length (mdat) == nc)
+                   m = mdat(i);
+                 else
+                   m = mdat;
+                 endif
+                 ps = sprintf ("pointsize %f", m / 3);
+               else
+                 ps = "";
+               endif
+               tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                        style, lw, pt2, lt, ps,
+                                        colorspec);
+             endif
+           endif
+
+           if (isfield (obj, "markeredgecolor")
+               && !strcmp (obj.markeredgecolor, "none"))
+             if (facesame && !isempty (pt)
+                 && (strcmp (obj.markeredgecolor, "auto")
+                     || ! isnumeric (obj.markeredgecolor)
+                     || (isnumeric (obj.markeredgecolor)
+                         && isequal (color, obj.markeredgecolor))))
+               if (sidx == 1 && ((length (style) == 5
+                        && strncmp (style, "lines", 5))
+                       || isempty (style)))
                  style = strcat (style, "points");
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
                    ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
-
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps,
+                                          style, lw, pt, lt, ps,
                                           colorspec);
-               else
-                 facesame = false;
-                 if (! isempty (style))
+               endif
+             else
+               if (!isempty (style))
+                 if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
                    tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                             style, lw, lt,
                                             colorspec);
-                   sidx ++;
                  endif
-                 if (isnumeric (obj.markerfacecolor) && ! mono)
-                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                        round (255*obj.markerfacecolor));
+                 sidx ++;
+               endif
+
+               if (!isempty (pt))
+                 if (! mono)
+                   if (strcmp (obj.markeredgecolor, "auto"))
+                     colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                          round (255*color));
+                   elseif (isnumeric (obj.markeredgecolor) && ! mono)
+                     colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                          round (255*obj.markeredgecolor));
+                   endif
                  endif
                  style = "points";
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
                    ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps,
+                                          style, lw, pt, lt, ps,
                                           colorspec);
                endif
              endif
-
-             if (isfield (obj, "markeredgecolor")
-                 && !strncmp (obj.markeredgecolor, "none", 4))
-               if (facesame && !isempty (pt)
-                   && (strncmp (obj.markeredgecolor, "auto", 4)
-                       || ! isnumeric (obj.markeredgecolor)
-                       || (isnumeric (obj.markeredgecolor)
-                           && isequal (color, obj.markeredgecolor))))
-                 if (sidx == 1 && ((length (style) == 5
-                          && strncmp (style, "lines", 5))
-                         || isempty (style)))
-                   style = strcat (style, "points");
-                   if (isfield (obj, "markersize"))
-                     if (length (mdat) == nc)
-                       m = mdat(i);
-                     else
-                       m = mdat;
-                     endif
-                     ps = sprintf ("pointsize %f", m / 3);
-                   else
-                     ps = "";
-                   endif
-                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps,
-                                            colorspec);
-                 endif
-               else
-                 if (!isempty (style))
-                   if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
-                     tmpwith{sidx} = sprintf ("with %s %s %s %s",
-                                              style, lw, lt,
-                                              colorspec);
-                   endif
-                   sidx ++;
-                 endif
-
-                 if (!isempty (pt))
-                   if (! mono)
-                     if (strncmp (obj.markeredgecolor, "auto", 4))
-                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                            round (255*color));
-                     elseif (isnumeric (obj.markeredgecolor) && ! mono)
-                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-                                            round (255*obj.markeredgecolor));
-                     endif
-                   endif
-                   style = "points";
-                   if (isfield (obj, "markersize"))
-                     if (length (mdat) == nc)
-                       m = mdat(i);
-                     else
-                       m = mdat;
-                     endif
-                     ps = sprintf ("pointsize %f", m / 3);
-                   else
-                     ps = "";
-                   endif
-                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps,
-                                            colorspec);
-                 endif
-               endif
-             endif
+           endif
 
-             if (isempty (tmpwith))
-               withclause{data_idx} = sprintf ("with %s %s %s %s %s",
-                                               style, lw, pt, lt,
-                                               colorspec);
-             else
-               withclause{data_idx} = tmpwith{1};
-             endif
-             if (nd == 3)
-               if (ischar (color))
-                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [zcol; zcol(1)], [ccol; ccol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, zcol, ccol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
+           if (isempty (tmpwith))
+             withclause{data_idx} = sprintf ("with %s %s %s %s %s",
+                                             style, lw, pt, lt,
+                                             colorspec);
+           else
+             withclause{data_idx} = tmpwith{1};
+           endif
+           if (nd == 3)
+             if (ischar (color))
+               if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [zcol; zcol(1)], [ccol; ccol(1)]]';
                else
-                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [zcol; zcol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, zcol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+                 data{data_idx} = [xcol, ycol, zcol, ccol]';
                endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
              else
-               if (ischar (color))
-                 if (! isnan (xcol) && ! isnan (ycol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-                                     [ccol; ccol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol, ccol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+               if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [zcol; zcol(1)]]';
                else
-                 if (! isnan (xcol) && ! isnan (ycol))
-                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
-                 else
-                   data{data_idx} = [xcol, ycol]';
-                 endif
-                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
+                 data{data_idx} = [xcol, ycol, zcol]';
                endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
              endif
-
-             if (length (tmpwith) > 1)
-               data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1);
-               parametric(data_idx) = parametric(data_idx - 1);
-               have_cdata(data_idx) = have_cdata(data_idx - 1);
-               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-               titlespec{data_idx} = "title \"\"";
-               usingclause{data_idx} = usingclause{data_idx - 1};
-               data{data_idx} = data{data_idx - 1};
-               withclause{data_idx} = tmpwith{2};
-             endif
-             if (length (tmpwith) > 2)
-               data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1);
-               parametric(data_idx) = parametric(data_idx - 1);
-               have_cdata(data_idx) = have_cdata(data_idx - 1);
-               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-               titlespec{data_idx} = "title \"\"";
-               usingclause{data_idx} = usingclause{data_idx - 1};
-               data{data_idx} = data{data_idx - 1};
-               withclause{data_idx} = tmpwith{3};
+           else
+             if (ischar (color))
+               if (! isnan (xcol) && ! isnan (ycol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                   [ccol; ccol(1)]]';
+               else
+                 data{data_idx} = [xcol, ycol, ccol]';
+               endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+             else
+               if (! isnan (xcol) && ! isnan (ycol))
+                 data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
+               else
+                 data{data_idx} = [xcol, ycol]';
+               endif
+               usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
              endif
            endif
-         endfor
 
-        case "surface"
-          view_map = true;
-          if (! (strncmp (obj.edgecolor, "none", 4)
-                 && strncmp (obj.facecolor, "none", 4)))
-            data_idx++;
-            is_image_data(data_idx) = false;
-            parametric(data_idx) = false;
-            have_cdata(data_idx) = true;
-            have_3d_patch(data_idx) = false;
-            style = do_linestyle_command (obj, obj.edgecolor,
-                                          data_idx, mono,
-                                          plot_stream);
+           if (length (tmpwith) > 1)
+             data_idx++;
+             is_image_data(data_idx) = is_image_data(data_idx - 1);
+             parametric(data_idx) = parametric(data_idx - 1);
+             have_cdata(data_idx) = have_cdata(data_idx - 1);
+             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+             titlespec{data_idx} = "title \"\"";
+             usingclause{data_idx} = usingclause{data_idx - 1};
+             data{data_idx} = data{data_idx - 1};
+             withclause{data_idx} = tmpwith{2};
+           endif
+           if (length (tmpwith) > 2)
+             data_idx++;
+             is_image_data(data_idx) = is_image_data(data_idx - 1);
+             parametric(data_idx) = parametric(data_idx - 1);
+             have_cdata(data_idx) = have_cdata(data_idx - 1);
+             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+             titlespec{data_idx} = "title \"\"";
+             usingclause{data_idx} = usingclause{data_idx - 1};
+             data{data_idx} = data{data_idx - 1};
+             withclause{data_idx} = tmpwith{3};
+           endif
+         endif
+       endfor
 
-            if (isempty (obj.displayname))
-              titlespec{data_idx} = "title \"\"";
-            else
-              tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-              titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
-            endif
-            withclause{data_idx} = sprintf ("with pm3d linestyle %d",
-                                            data_idx);
-            withpm3d = true;
-            pm3didx = data_idx;
-
-            xdat = obj.xdata;
-            ydat = obj.ydata;
-            zdat = obj.zdata;
-            cdat = obj.cdata;
+      case "surface"
+        view_map = true;
+        if (! (strcmp (obj.edgecolor, "none")
+               && strcmp (obj.facecolor, "none")))
+          data_idx++;
+          is_image_data(data_idx) = false;
+          parametric(data_idx) = false;
+          have_cdata(data_idx) = true;
+          have_3d_patch(data_idx) = false;
+          style = do_linestyle_command (obj, obj.edgecolor,
+                                        data_idx, mono,
+                                        plot_stream);
 
-            err = false;
-            if (! size_equal (zdat, cdat))
-              err = true;
-            endif
-            if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
-              if (rows (zdat) == length (ydat)
-                  && columns (zdat) == length (xdat))
-                [xdat, ydat] = meshgrid (xdat, ydat);
-              else
-                err = true;
-              endif
-            elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
-              if (! size_equal (xdat, ydat, zdat))
-                err = true;
-              endif
+          if (isempty (obj.displayname))
+            titlespec{data_idx} = "title \"\"";
+          else
+            tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
+            titlespec{data_idx} = ['title "' tmp '"'];
+          endif
+          withclause{data_idx} = sprintf ("with pm3d linestyle %d",
+                                          data_idx);
+          withpm3d = true;
+          pm3didx = data_idx;
+
+          xdat = obj.xdata;
+          ydat = obj.ydata;
+          zdat = obj.zdata;
+          cdat = obj.cdata;
+
+          err = false;
+          if (! size_equal (zdat, cdat))
+            err = true;
+          endif
+          if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
+            if (rows (zdat) == length (ydat)
+                && columns (zdat) == length (xdat))
+              [xdat, ydat] = meshgrid (xdat, ydat);
             else
               err = true;
             endif
-            if (err)
-              error ("__go_draw_axes__: invalid grid data");
+          elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
+            if (! size_equal (xdat, ydat, zdat))
+              err = true;
             endif
-            xlen = columns (zdat);
-            ylen = rows (zdat);
-            if (xlen == columns (xdat) && xlen == columns (ydat)
-                && ylen == rows (xdat) && ylen == rows (ydat))
-              len = 4 * xlen;
-              zz = zeros (ylen, len);
-              k = 1;
-              for kk = 1:4:len
-                zz(:,kk)   = xdat(:,k);
-                zz(:,kk+1) = ydat(:,k);
-                zz(:,kk+2) = zdat(:,k);
-                zz(:,kk+3) = cdat(:,k);
-                k++;
-              endfor
-              data{data_idx} = zz.';
-            endif
+          else
+            err = true;
+          endif
+          if (err)
+            error ("__go_draw_axes__: invalid grid data");
+          endif
+          xlen = columns (zdat);
+          ylen = rows (zdat);
+          if (xlen == columns (xdat) && xlen == columns (ydat)
+              && ylen == rows (xdat) && ylen == rows (ydat))
+            len = 4 * xlen;
+            zz = zeros (ylen, len);
+            k = 1;
+            for kk = 1:4:len
+              zz(:,kk)   = xdat(:,k);
+              zz(:,kk+1) = ydat(:,k);
+              zz(:,kk+2) = zdat(:,k);
+              zz(:,kk+3) = cdat(:,k);
+              k++;
+            endfor
+            data{data_idx} = zz.';
+          endif
 
-            if (doing_interp_color)
-              interp_str = "interpolate 0, 0";
-            else
-              ## No interpolation of facecolors.
-              interp_str = "";
-            endif
-            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
+          if (doing_interp_color)
+            interp_str = "interpolate 0, 0";
+          else
+            ## No interpolation of facecolors.
+            interp_str = "";
+          endif
+          usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
 
-            flat_interp_face = (strncmp (obj.facecolor, "flat", 4)
-                                || strncmp (obj.facecolor, "interp", 6));
-            flat_interp_edge = (strncmp (obj.edgecolor, "flat", 4)
-                                || strncmp (obj.edgecolor, "interp", 6));
+          flat_interp_face = (strcmp (obj.facecolor, "flat")
+                              || strcmp (obj.facecolor, "interp"));
+          flat_interp_edge = (strcmp (obj.edgecolor, "flat")
+                              || strcmp (obj.edgecolor, "interp"));
 
-            facecolor_none_or_white = (strncmp (obj.facecolor, "none", 4)
-                                       || (isnumeric (obj.facecolor)
-                                           && all (obj.facecolor == 1)));
-            hidden_removal = false;
-            fputs (plot_stream, "set style increment default;\n");
-            if (flat_interp_edge && facecolor_none_or_white)
-              withpm3d = false;
-              withclause{data_idx} = sprintf ("with %s palette", style {1});
-              fputs (plot_stream, "unset pm3d\n");
-              if (all (obj.facecolor == 1))
-                hidden_removal = true;
-              endif
-            elseif (facecolor_none_or_white)
-              if (all (obj.facecolor == 1))
-                hidden_removal = true;
-              endif
-              fputs (plot_stream,"unset pm3d;\n");
-              fputs (plot_stream,"set style increment user;\n");
-              withpm3d = false;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{1}, data_idx);
-              fputs (plot_stream, "unset pm3d\n");
+          facecolor_none_or_white = (strcmp (obj.facecolor, "none")
+                                     || (isnumeric (obj.facecolor)
+                                         && all (obj.facecolor == 1)));
+          hidden_removal = false;
+          fputs (plot_stream, "set style increment default;\n");
+          if (flat_interp_edge && facecolor_none_or_white)
+            withpm3d = false;
+            withclause{data_idx} = sprintf ("with %s palette", style {1});
+            fputs (plot_stream, "unset pm3d\n");
+            if (all (obj.facecolor == 1))
+              hidden_removal = true;
             endif
+          elseif (facecolor_none_or_white)
+            if (all (obj.facecolor == 1))
+              hidden_removal = true;
+            endif
+            fputs (plot_stream,"unset pm3d;\n");
+            fputs (plot_stream,"set style increment user;\n");
+            withpm3d = false;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{1}, data_idx);
+            fputs (plot_stream, "unset pm3d\n");
+          endif
 
-            if (doing_interp_color)
-              ## "depthorder" interferes with interpolation of colors.
-              dord = "scansautomatic";
-            else
-              dord = "depthorder";
-            endif
+          if (doing_interp_color)
+            ## "depthorder" interferes with interpolation of colors.
+            dord = "scansautomatic";
+          else
+            dord = "depthorder";
+          endif
 
-            if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
-              fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n",
+          if (flat_interp_face && strcmp (obj.edgecolor, "flat"))
+            fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n",
+                     interp_str, dord);
+          elseif (!facecolor_none_or_white)
+            if (strcmp (obj.edgecolor, "none"))
+              if (__gnuplot_has_feature__ ("transparent_surface")
+                  && isscalar (obj.facealpha))
+                fprintf (plot_stream,
+                         "set style fill transparent solid %f;\n",
+                         obj.facealpha);
+              endif
+              fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n",
                        interp_str, dord);
-            elseif (!facecolor_none_or_white)
-              if (strncmp (obj.edgecolor, "none", 4))
-                if (__gnuplot_has_feature__ ("transparent_surface")
-                    && isscalar (obj.facealpha))
-                  fprintf (plot_stream,
-                           "set style fill transparent solid %f;\n",
-                           obj.facealpha);
-                endif
-                fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n",
-                         interp_str, dord);
-              else
-                fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n",
-                         data_idx, interp_str, dord);
+            else
+              fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n",
+                       data_idx, interp_str, dord);
 
-                if (__gnuplot_has_feature__ ("transparent_surface")
-                    && isscalar (obj.facealpha))
-                  fprintf (plot_stream,
-                           "set style fill transparent solid %f;\n",
-                           obj.facealpha);
-                endif
+              if (__gnuplot_has_feature__ ("transparent_surface")
+                  && isscalar (obj.facealpha))
+                fprintf (plot_stream,
+                         "set style fill transparent solid %f;\n",
+                         obj.facealpha);
               endif
             endif
+          endif
 
-            zz = [];
-            if (length (style) > 1)
+          zz = [];
+          if (length (style) > 1)
+            len = 3 * xlen;
+            zz = zeros (ylen, len);
+            k = 1;
+            for kk = 1:3:len
+              zz(:,kk)   = xdat(:,k);
+              zz(:,kk+1) = ydat(:,k);
+              zz(:,kk+2) = zdat(:,k);
+              k++;
+            endfor
+            zz = zz.';
+
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{2}, data_idx);
+
+          endif
+          if (length (style) > 2)
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                            style{3}, data_idx);
+          endif
+          if (withpm3d && strcmp (style{1}, "linespoints"))
+            if (isempty (zz))
               len = 3 * xlen;
               zz = zeros (ylen, len);
               k = 1;
               for kk = 1:3:len
                 zz(:,kk)   = xdat(:,k);
                 zz(:,kk+1) = ydat(:,k);
                 zz(:,kk+2) = zdat(:,k);
                 k++;
               endfor
               zz = zz.';
-
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{2}, data_idx);
+            endif
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+            data{data_idx} = zz;
+            withclause{data_idx} = sprintf ("with points linestyle %d",
+                                            pm3didx);
+          endif
+        endif
 
-            endif
-            if (length (style) > 2)
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with %s linestyle %d",
-                                              style{3}, data_idx);
-            endif
-            if (withpm3d && strncmp (style {1}, "linespoints", 11))
-              if (isempty (zz))
-                len = 3 * xlen;
-                zz = zeros (ylen, len);
-                k = 1;
-                for kk = 1:3:len
-                  zz(:,kk)   = xdat(:,k);
-                  zz(:,kk+1) = ydat(:,k);
-                  zz(:,kk+2) = zdat(:,k);
-                  k++;
-                endfor
-                zz = zz.';
-              endif
-              data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1);
-              parametric(data_idx) = parametric(data_idx - 1);
-              have_cdata(data_idx) = false;
-              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-              titlespec{data_idx} = "title \"\"";
-              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-              data{data_idx} = zz;
-              withclause{data_idx} = sprintf ("with points linestyle %d",
-                                              pm3didx);
-            endif
-          endif
+      case "text"
+        [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        lpos = obj.position;
+        halign = obj.horizontalalignment;
+        valign = obj.verticalalignment;
+        angle = obj.rotation;
+        units = obj.units;
+        color = obj.color;
+        if (strcmpi (units, "normalized"))
+          units = "graph";
+        elseif (strcmp (axis_obj.yaxislocation, "right")
+                && strcmp (units, "data"))
+          units = "second";
+        else
+          units = "";
+        endif
+
+        if (isnumeric (color))
+          colorspec = get_text_colorspec (color, mono);
+        endif
 
-        case "text"
-          [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
-          fontspec = create_fontspec (f, s, gnuplot_term);
-          lpos = obj.position;
-          halign = obj.horizontalalignment;
-          valign = obj.verticalalignment;
-          angle = obj.rotation;
-          units = obj.units;
-          color = obj.color;
-          if (strcmpi (units, "normalized"))
-            units = "graph";
-          elseif (strcmp (axis_obj.yaxislocation, "right")
-                  && strcmp (units, "data"))
-            units = "second";
-          else
-            units = "";
-          endif
-
-          if (isnumeric (color))
-            colorspec = get_text_colorspec (color, mono);
-          endif
+        if (ischar (obj.string))
+          num_lines = rows (obj.string);
+        else
+          num_lines = numel (obj.string);
+        endif
+        switch (valign)
+          ## Text offset in characters. Relies on gnuplot for font metrics.
+          case "top"
+            dy = -0.5;
+          case "cap"
+            dy = -0.5;
+          case "middle"
+            dy = 0.5 * (num_lines - 1);
+          case "baseline"
+            dy = 0.5 + (num_lines - 1);
+          case "bottom"
+            dy = 0.5 + (num_lines - 1);
+        endswitch
+        ## Gnuplot's Character units are different for x/y and vary with
+        ## fontsize. The aspect ratio of 1:1.7 was determined by experiment
+        ## to work for eps/ps/etc. For the MacOS aqua terminal a value of 2.5
+        ## is needed. However, the difference is barely noticable.
+        dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
 
-          if (ischar (obj.string))
-            num_lines = rows (obj.string);
-          else
-            num_lines = numel (obj.string);
-          endif
-          switch valign
-            ## Text offset in characters. This relies on gnuplot for font metrics.
-            case "top"
-              dy = -0.5;
-            case "cap"
-              dy = -0.5;
-            case "middle"
-              dy = 0.5 * (num_lines - 1);
-            case "baseline"
-              dy = 0.5 + (num_lines - 1);
-            case "bottom"
-              dy = 0.5 + (num_lines - 1);
-          endswitch
-          ## Gnuplot's Character units are different for x/y and vary with fontsize. The aspect ratio
-          ## of 1:1.7 was determined by experiment to work for eps/ps/etc. For the MacOS aqua terminal
-          ## a value of 2.5 is needed. However, the difference is barely noticable.
-          dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
+        ## FIXME: Multiline text produced the gnuplot
+        ##        "warning: ft_render: skipping glyph"
+        if (nd == 3)
+          ## This produces the desired vertical alignment in 3D.
+          fprintf (plot_stream,
+                   "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
+                   undo_string_escapes (label), units, lpos(1),
+                   lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
+                   __do_enhanced_option__ (enhanced, obj), colorspec);
+        else
+          fprintf (plot_stream,
+                   "set label \"%s\" at %s %.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
+                   undo_string_escapes (label), units,
+                   lpos(1), lpos(2), halign, angle, dx_and_dy, fontspec,
+                   __do_enhanced_option__ (enhanced, obj), colorspec);
+        endif
+
+      case "hggroup"
+        ## Push group children into the kid list.
+        if (isempty (kids))
+          kids = obj.children;
+        elseif (! isempty (obj.children))
+          kids = [kids; obj.children];
+        endif
+
+      otherwise
+        error ("__go_draw_axes__: unknown object class, %s",
+               obj.type);
+    endswitch
+
+  endwhile
 
-          ## FIXME - Multiline text produced the gnuplot "warning: ft_render: skipping glyph"
-          if (nd == 3)
-            ## This produces the desired vertical alignment in 3D.
-            fprintf (plot_stream,
-                     "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
-                     undo_string_escapes (label), units, lpos(1),
-                     lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
-                     __do_enhanced_option__ (enhanced, obj), colorspec);
-          else
-            fprintf (plot_stream,
-                     "set label \"%s\" at %s %.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
-                     undo_string_escapes (label), units,
-                     lpos(1), lpos(2), halign, angle, dx_and_dy, fontspec,
-                     __do_enhanced_option__ (enhanced, obj), colorspec);
-          endif
+  ## This is need to prevent warnings for rotations in 3D plots, while
+  ## allowing colorbars with contours.
+  if (nd == 2 || (data_idx > 1 && !view_map))
+    fputs (plot_stream, "set pm3d implicit;\n");
+  else
+    fputs (plot_stream, "set pm3d explicit;\n");
+  endif
 
-        case "hggroup"
-          ## Push group children into the kid list.
-          if (isempty (kids))
-            kids = obj.children;
-          elseif (! isempty (obj.children))
-            kids = [kids; obj.children];
-          endif
+  if (isnan (hidden_removal) || hidden_removal)
+    fputs (plot_stream, "set hidden3d;\n");
+  else
+    fputs (plot_stream, "unset hidden3d;\n");
+  endif
+
+  have_data = (! (isempty (data) || all (cellfun ("isempty", data))));
 
-        otherwise
-          error ("__go_draw_axes__: unknown object class, %s",
-                 obj.type);
-      endswitch
-
-    endwhile
+  ## Note we don't use the [xy]2range of gnuplot as we don't use the
+  ## dual axis plotting features of gnuplot.
+  if (isempty (xlim))
+    return;
+  endif
+  if (strcmpi (axis_obj.xdir, "reverse"))
+    xdir = "reverse";
+  else
+    xdir = "noreverse";
+  endif
+  fprintf (plot_stream, "set xrange [%.15e:%.15e] %s;\n", xlim, xdir);
+  if (strcmpi (axis_obj.xaxislocation, "top"))
+    fprintf (plot_stream, "set x2range [%.15e:%.15e] %s;\n", xlim, xdir);
+  endif
 
-    ## This is need to prevent warnings for rotations in 3D plots, while
-    ## allowing colorbars with contours.
-    if (nd == 2 || (data_idx > 1 && !view_map))
-      fputs (plot_stream, "set pm3d implicit;\n");
-    else
-      fputs (plot_stream, "set pm3d explicit;\n");
-    endif
+  if (isempty (ylim))
+    return;
+  endif
+  if (strcmpi (axis_obj.ydir, "reverse"))
+    ydir = "reverse";
+  else
+    ydir = "noreverse";
+  endif
+  fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
+  if (strcmpi (axis_obj.yaxislocation, "right"))
+    fprintf (plot_stream, "set y2range [%.15e:%.15e] %s;\n", ylim, ydir);
+  endif
 
-    if (isnan (hidden_removal) || hidden_removal)
-      fputs (plot_stream, "set hidden3d;\n");
-    else
-      fputs (plot_stream, "unset hidden3d;\n");
-    endif
-
-    have_data = (! (isempty (data) || all (cellfun ("isempty", data))));
-
-    ## Note we don't use the [xy]2range of gnuplot as we don't use the
-    ## dual axis plotting features of gnuplot.
-    if (isempty (xlim))
+  if (nd == 3)
+    if (isempty (zlim))
       return;
     endif
-    if (strcmpi (axis_obj.xdir, "reverse"))
-      xdir = "reverse";
+    if (strcmpi (axis_obj.zdir, "reverse"))
+      zdir = "reverse";
     else
-      xdir = "noreverse";
-    endif
-    fprintf (plot_stream, "set xrange [%.15e:%.15e] %s;\n", xlim, xdir);
-    if (strcmpi (axis_obj.xaxislocation, "top"))
-      fprintf (plot_stream, "set x2range [%.15e:%.15e] %s;\n", xlim, xdir);
-    endif
-
-    if (isempty (ylim))
-      return;
+      zdir = "noreverse";
     endif
-    if (strcmpi (axis_obj.ydir, "reverse"))
-      ydir = "reverse";
-    else
-      ydir = "noreverse";
-    endif
-    fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
-    if (strcmpi (axis_obj.yaxislocation, "right"))
-      fprintf (plot_stream, "set y2range [%.15e:%.15e] %s;\n", ylim, ydir);
-    endif
+    fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
+  endif
 
-    if (nd == 3)
-      if (isempty (zlim))
-        return;
-      endif
-      if (strcmpi (axis_obj.zdir, "reverse"))
-        zdir = "reverse";
+  cmap = parent_figure_obj.colormap;
+  cmap_sz = rows (cmap);
+  if (! any (isinf (clim)))
+    if (truecolor || ! cdatadirect)
+      if (rows (addedcmap) > 0)
+        for i = 1:data_idx
+          if (have_3d_patch(i))
+            data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
+           endif
+        endfor
+        fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim(1), clim(2) *
+                 (cmap_sz + rows (addedcmap)) / cmap_sz);
       else
-        zdir = "noreverse";
-      endif
-      fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
-    endif
-
-    cmap = parent_figure_obj.colormap;
-    cmap_sz = rows (cmap);
-    if (! any (isinf (clim)))
-      if (truecolor || ! cdatadirect)
-        if (rows (addedcmap) > 0)
-          for i = 1:data_idx
-            if (have_3d_patch(i))
-              data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
-             endif
-          endfor
-          fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim(1), clim(2) *
-                   (cmap_sz + rows (addedcmap)) / cmap_sz);
-        else
-          fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim);
-        endif
-      else
-        fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
-                 rows (addedcmap));
-      endif
-    endif
-
-    if (strcmpi (axis_obj.box, "on"))
-      if (nd == 3)
-        fputs (plot_stream, "set border 4095;\n");
-      else
-        fputs (plot_stream, "set border 431;\n");
+        fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim);
       endif
     else
-      if (nd == 3)
-        fputs (plot_stream, "set border 895;\n");
-      elseif (! isempty (axis_obj.ytick))
-        if (strcmpi (axis_obj.yaxislocation, "right"))
-          fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
+      fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
+               rows (addedcmap));
+    endif
+  endif
+
+  if (strcmpi (axis_obj.box, "on"))
+    if (nd == 3)
+      fputs (plot_stream, "set border 4095;\n");
+    else
+      fputs (plot_stream, "set border 431;\n");
+    endif
+  else
+    if (nd == 3)
+      fputs (plot_stream, "set border 895;\n");
+    elseif (! isempty (axis_obj.ytick))
+      if (strcmpi (axis_obj.yaxislocation, "right"))
+        fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 12;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 9;\n");
+        else # xaxislocation == zero
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 12;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 9;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 8;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-        elseif (strcmpi (axis_obj.yaxislocation, "left"))
-          fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+          fputs (plot_stream, "set border 8;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
+                   axis_obj.linewidth);
+        endif
+      elseif (strcmpi (axis_obj.yaxislocation, "left"))
+        fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 6;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 6;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 3;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 2;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-        else # yaxislocation == zero
+          fputs (plot_stream, "set border 3;\n");
+        else # xaxislocation == zero
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 2;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
+                   axis_obj.linewidth);
+        endif
+      else # yaxislocation == zero
+        fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+                 axis_obj.tickdir);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 4;\n");
+        elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "set border 1;\n");
+        else # xaxislocation == zero
           fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
                    axis_obj.tickdir);
-          if (strcmpi (axis_obj.xaxislocation, "top"))
-            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 4;\n");
-          elseif (strcmpi (axis_obj.xaxislocation, "bottom"))
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "set border 1;\n");
-          else # xaxislocation == zero
-            fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
-                     axis_obj.tickdir);
-            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-                     axis_obj.tickdir);
-            fputs (plot_stream, "unset border;\n");
-            fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
-                     axis_obj.linewidth);
-          endif
-          fprintf (plot_stream, "set yzeroaxis lt -1 lw %f;\n",
+          fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                   axis_obj.tickdir);
+          fputs (plot_stream, "unset border;\n");
+          fprintf (plot_stream, "set xzeroaxis lt -1 lw %f;\n",
                    axis_obj.linewidth);
         endif
+        fprintf (plot_stream, "set yzeroaxis lt -1 lw %f;\n",
+                 axis_obj.linewidth);
+      endif
+    endif
+  endif
+
+  if (strcmpi (axis_obj.visible, "off"))
+    fputs (plot_stream, "unset border; unset tics\n");
+  else
+    fprintf (plot_stream, "set border lw %f;\n", axis_obj.linewidth);
+  endif
+
+  if (! isempty (hlgnd) && ! isempty (hlgnd.children)
+      && any (strcmpi (get (hlgnd.children, "visible"), "on")))
+    if (strcmpi (hlgnd.box, "on"))
+      box = "box";
+    else
+      box = "nobox";
+    endif
+    if (strcmpi (hlgnd.orientation, "vertical"))
+      horzvert = "vertical";
+    else
+      horzvert = "horizontal";
+    endif
+    if (strcmpi (hlgnd.textposition, "right"))
+      reverse = "reverse";
+    else
+      reverse = "noreverse";
+    endif
+    inout = "inside";
+    keypos = hlgnd.location;
+    if (ischar (keypos))
+      keypos = lower (keypos);
+      keyout = strfind (keypos, "outside");
+      if (! isempty (keyout))
+        inout = "outside";
+        keypos = keypos(1:keyout-1);
       endif
     endif
-
-    if (strcmpi (axis_obj.visible, "off"))
-      fputs (plot_stream, "unset border; unset tics\n");
+    switch (keypos)
+      case "north"
+        pos = "center top";
+      case "south"
+        pos = "center bottom";
+      case "east"
+        pos = "right center";
+      case "west"
+        pos = "left center";
+      case "northeast"
+        pos = "right top";
+      case "northwest"
+        pos = "left top";
+      case "southeast"
+        pos = "right bottom";
+      case "southwest"
+        pos = "left bottom";
+      case "best"
+        pos = "";
+        warning ("legend: 'Best' not yet implemented for location specifier.\n");
+        ## Least conflict with data in plot.
+        ## Least unused space outside plot.
+      otherwise
+        pos = "";
+    endswitch
+    if (__gnuplot_has_feature__ ("key_has_font_properties"))
+      [fontname, fontsize] = get_fontname_and_size (hlgnd);
+      fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
     else
-      fprintf (plot_stream, "set border lw %f;\n", axis_obj.linewidth);
+      fontspec = "";
+    endif
+    textcolors = get (findobj (hlgnd.children, "type", "text"), "color");
+    if (iscell (textcolors))
+      textcolors = cell2mat (textcolors);
+      textcolors = unique (textcolors, "rows");
     endif
+    if (rows (textcolors) > 1)
+      ## Gnuplot is unable to assign arbitrary colors to each text entry
+      ## for the key/legend.  But, the text color can be set to match the
+      ## color of the plot object.
+      colorspec = "textcolor variable";
+    else
+      colorspec = get_text_colorspec (textcolors, mono);
+    endif
+    fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
+             inout, pos, box, reverse, horzvert, fontspec, colorspec);
+  else
+    fputs (plot_stream, "unset key;\n");
+  endif
+  fputs (plot_stream, "set style data lines;\n");
 
-    if (! isempty (hlgnd) && ! isempty (hlgnd.children)
-        && any (strcmpi (get (hlgnd.children, "visible"), "on")))
-      if (strcmpi (hlgnd.box, "on"))
-        box = "box";
+  cmap = [cmap; addedcmap];
+  cmap_sz = cmap_sz + rows (addedcmap);
+  if (length (cmap) > 0)
+    fprintf (plot_stream,
+             "set palette positive color model RGB maxcolors %i;\n",
+             cmap_sz);
+    fprintf (plot_stream,
+             "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
+             cmap_sz);
+    fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
+    fwrite (plot_stream, "\n");
+  endif
+
+  fputs (plot_stream, "unset colorbox;\n");
+
+  if (have_data)
+    if (nd == 2)
+      plot_cmd = "plot";
+    else
+      plot_cmd = "splot";
+      rot_x = 90 - axis_obj.view(2);
+      rot_z = axis_obj.view(1);
+      while (rot_z < 0)
+        rot_z += 360;
+      endwhile
+      fputs (plot_stream, "set ticslevel 0;\n");
+      if (view_map && rot_x == 0 && rot_z == 0)
+        fputs (plot_stream, "set view map;\n");
       else
-        box = "nobox";
+        fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
       endif
-      if (strcmpi (hlgnd.orientation, "vertical"))
-        horzvert = "vertical";
-      else
-        horzvert = "horizontal";
-      endif
-      if (strcmpi (hlgnd.textposition, "right"))
-        reverse = "reverse";
-      else
-        reverse = "noreverse";
-      endif
-      inout = "inside";
-      keypos = hlgnd.location;
-      if (ischar (keypos))
-        keypos = lower (keypos);
-        keyout = strfind (keypos, "outside");
-        if (! isempty (keyout))
-          inout = "outside";
-          keypos = keypos(1:keyout-1);
+    endif
+    if (have_3d_patch (1))
+      fputs (plot_stream, "set pm3d depthorder\n");
+      fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
+    elseif (is_image_data (1))
+      if (numel (is_image_data) > 1 && is_image_data(2))
+        ## Remove terminating semicolon
+        n = max (strfind (withclause{1}, ";"));
+        if (! isempty (n))
+          withclause{1} = withclause{1}(1:n-1);
         endif
       endif
-      switch (keypos)
-        case "north"
-          pos = "center top";
-        case "south"
-          pos = "center bottom";
-        case "east"
-          pos = "right center";
-        case "west"
-          pos = "left center";
-        case "northeast"
-          pos = "right top";
-        case "northwest"
-          pos = "left top";
-        case "southeast"
-          pos = "right bottom";
-        case "southwest"
-          pos = "left bottom";
-        case "best"
-          pos = "";
-          warning ("legend: 'Best' not yet implemented for location specifier.\n");
-          ## Least conflict with data in plot.
-          ## Least unused space outside plot.
-        otherwise
-          pos = "";
-      endswitch
-      if (__gnuplot_has_feature__ ("key_has_font_properties"))
-        [fontname, fontsize] = get_fontname_and_size (hlgnd);
-        fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
-      else
-        fontspec = "";
-      endif
-      textcolors = get (findobj (hlgnd.children, "type", "text"), "color");
-      if (iscell (textcolors))
-        textcolors = cell2mat (textcolors);
-        textcolors = unique (textcolors, "rows");
-      endif
-      if (rows (textcolors) > 1)
-        ## Gnuplot is unable to assign arbitrary colors to each text entry
-        ## for the key/legend.  But, the text color can be set to match the
-        ## color of the plot object.
-        colorspec = "textcolor variable";
-      else
-        colorspec = get_text_colorspec (textcolors, mono);
-      endif
-      fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
-               inout, pos, box, reverse, horzvert, fontspec, colorspec);
+      fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
     else
-      fputs (plot_stream, "unset key;\n");
-    endif
-    fputs (plot_stream, "set style data lines;\n");
-
-    cmap = [cmap; addedcmap];
-    cmap_sz = cmap_sz + rows (addedcmap);
-    if (length (cmap) > 0)
-      fprintf (plot_stream,
-               "set palette positive color model RGB maxcolors %i;\n",
-               cmap_sz);
-      fprintf (plot_stream,
-               "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
-               cmap_sz);
-      fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
-      fwrite (plot_stream, "\n");
+      fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+               usingclause{1}, titlespec{1}, withclause{1});
     endif
-
-    fputs (plot_stream, "unset colorbox;\n");
-
-    if (have_data)
-      if (nd == 2)
-        plot_cmd = "plot";
-      else
-        plot_cmd = "splot";
-        rot_x = 90 - axis_obj.view(2);
-        rot_z = axis_obj.view(1);
-        while (rot_z < 0)
-          rot_z += 360;
-        endwhile
-        fputs (plot_stream, "set ticslevel 0;\n");
-        if (view_map && rot_x == 0 && rot_z == 0)
-          fputs (plot_stream, "set view map;\n");
-        else
-          fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
-        endif
-      endif
-      if (have_3d_patch (1))
-        fputs (plot_stream, "set pm3d depthorder\n");
-        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      elseif (is_image_data (1))
-        if (numel (is_image_data) > 1 && is_image_data(2))
-          ## Remove terminating semicolon
-          n = max (strfind (withclause{1}, ";"));
-          if (! isempty (n))
-            withclause{1} = withclause{1}(1:n-1);
-          endif
-        endif
-        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      else
-        fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
-                 usingclause{1}, titlespec{1}, withclause{1});
-      endif
-      for i = 2:data_idx
-        if (have_3d_patch (i))
-          fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
-                   usingclause{i}, titlespec{i}, withclause{i});
-        elseif (is_image_data (i))
-          if (! is_image_data (i-1))
-            fputs (plot_stream, "; ");
-            if (bg_is_set)
-              fputs (plot_stream, "unset obj 1; \\\n");
-              bg_is_set = false;
-            endif
-            if (fg_is_set)
-              fputs (plot_stream, "unset obj 2; \\\n");
-              fg_is_set = false;
-            endif
-            if (numel (is_image_data) > i && is_image_data(i+1))
-              ## Remove terminating semicolon
-              n = max (strfind (withclause{i}, ";"));
-              if (! isempty (n))
-                withclause{i} = withclause{i}(1:n-1);
-              endif
-            endif
-            fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-                     usingclause{i}, titlespec{i}, withclause{i});
-          else
-            ## For consecutive images continue with the same plot command
-            fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", ",",
-                     usingclause{i}, titlespec{i}, withclause{i});
-          endif
-        elseif (is_image_data (i-1))
+    for i = 2:data_idx
+      if (have_3d_patch (i))
+        fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
+                 usingclause{i}, titlespec{i}, withclause{i});
+      elseif (is_image_data (i))
+        if (! is_image_data (i-1))
+          fputs (plot_stream, "; ");
           if (bg_is_set)
             fputs (plot_stream, "unset obj 1; \\\n");
             bg_is_set = false;
           endif
           if (fg_is_set)
             fputs (plot_stream, "unset obj 2; \\\n");
             fg_is_set = false;
           endif
-          fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+          if (numel (is_image_data) > i && is_image_data(i+1))
+            ## Remove terminating semicolon
+            n = max (strfind (withclause{i}, ";"));
+            if (! isempty (n))
+              withclause{i} = withclause{i}(1:n-1);
+            endif
+          endif
+          fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                    usingclause{i}, titlespec{i}, withclause{i});
         else
-          fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
+          ## For consecutive images continue with the same plot command
+          fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", ",",
                    usingclause{i}, titlespec{i}, withclause{i});
         endif
-      endfor
-      fputs (plot_stream, ";\n");
-      for i = 1:data_idx
-        if (have_3d_patch (i))
-          ## Can't write 3d patch data as binary as can't plot more than
-          ## a single patch at a time and have to plot all patches together
-          ## so that the gnuplot depth ordering is done correctly
-          for j = 1 : 4 : columns (data{i})
-            if (j != 1)
-              fputs (plot_stream, "\n\n");
-            endif
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
-            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
-          endfor
-          fputs (plot_stream, "e\n");
-        elseif (is_image_data(i))
-          fwrite (plot_stream, data{i}, "float32");
-        else
-          __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i),
-                                  have_cdata(i));
+      elseif (is_image_data (i-1))
+        if (bg_is_set)
+          fputs (plot_stream, "unset obj 1; \\\n");
+          bg_is_set = false;
+        endif
+        if (fg_is_set)
+          fputs (plot_stream, "unset obj 2; \\\n");
+          fg_is_set = false;
         endif
-      endfor
-    else
-      fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
-    endif
-
-    ## Needed to allow mouse rotation with pcolor.
-    if (view_map)
-      fputs (plot_stream, "unset view;\n");
-    endif
+        fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+                 usingclause{i}, titlespec{i}, withclause{i});
+      else
+        fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
+                 usingclause{i}, titlespec{i}, withclause{i});
+      endif
+    endfor
+    fputs (plot_stream, ";\n");
+    for i = 1:data_idx
+      if (have_3d_patch (i))
+        ## Can't write 3d patch data as binary as can't plot more than
+        ## a single patch at a time and have to plot all patches together
+        ## so that the gnuplot depth ordering is done correctly
+        for j = 1 : 4 : columns (data{i})
+          if (j != 1)
+            fputs (plot_stream, "\n\n");
+          endif
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
+          fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
+        endfor
+        fputs (plot_stream, "e\n");
+      elseif (is_image_data(i))
+        fwrite (plot_stream, data{i}, "float32");
+      else
+        __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i),
+                                have_cdata(i));
+      endif
+    endfor
+  else
+    fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
+  endif
 
-    if (bg_is_set)
-      fputs (plot_stream, "unset obj 1;\n");
-      bg_is_set = false;
-    endif
+  ## Needed to allow mouse rotation with pcolor.
+  if (view_map)
+    fputs (plot_stream, "unset view;\n");
+  endif
 
-    fflush (plot_stream);
+  if (bg_is_set)
+    fputs (plot_stream, "unset obj 1;\n");
+    bg_is_set = false;
+  endif
 
-  else
-    print_usage ();
-  endif
+  fflush (plot_stream);
 
 endfunction
 
 function x = flip (x)
   if (rows (x) == 1)
     x = fliplr (x);
   elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
@@ -1830,18 +1826,18 @@ function style = do_linestyle_command (o
     if (isempty (lt))
       style {sidx} = "";
     else
       style {sidx} = "lines";
     endif
 
     facesame = true;
     if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
-        && !strncmp (obj.markerfacecolor, "none", 4))
-      if (strncmp (obj.markerfacecolor, "auto", 4)
+        && !strcmp (obj.markerfacecolor, "none"))
+      if (strcmp (obj.markerfacecolor, "auto")
           || ! isnumeric (obj.markerfacecolor)
           || (isnumeric (obj.markerfacecolor)
               && isequal (color, obj.markerfacecolor)))
         if (! isempty (pt2))
           fprintf (plot_stream, " pointtype %s", pt2);
           style {sidx} = strcat (style{sidx}, "points");
         endif
         if (isfield (obj, "markersize"))
@@ -1870,24 +1866,24 @@ function style = do_linestyle_command (o
           fprintf (plot_stream, " pointtype %s", pt2);
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       endif
     endif
     if (isfield (obj, "markeredgecolor")
-        && !strncmp (obj.markeredgecolor, "none", 4))
+        && !strcmp (obj.markeredgecolor, "none"))
       if (facesame && !isempty (pt)
-          && (strncmp (obj.markeredgecolor, "auto", 4)
+          && (strcmp (obj.markeredgecolor, "auto")
               || ! isnumeric (obj.markeredgecolor)
               || (isnumeric (obj.markeredgecolor)
                   && isequal (color, obj.markeredgecolor))))
         if (sidx == 1 && ((length (style {sidx}) == 5
-            && strncmp (style {sidx}, "lines", 5)) || isempty (style {sidx})))
+            && strncmp (style{sidx}, "lines", 5)) || isempty (style {sidx})))
           if (! isempty (pt))
             style {sidx} = strcat (style{sidx}, "points");
             fprintf (plot_stream, " pointtype %s", pt);
           endif
           if (isfield (obj, "markersize"))
             fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
           endif
         endif
@@ -1900,17 +1896,17 @@ function style = do_linestyle_command (o
           sidx ++;
           idx ++;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (! mono)
-          if (strncmp (obj.markeredgecolor, "auto", 4))
+          if (strcmp (obj.markeredgecolor, "auto"))
             fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                      round (255*color));
           elseif (isnumeric (obj.markeredgecolor) && ! mono)
             fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                      round (255*obj.markeredgecolor));
           endif
         endif
         if (! isempty (pt))
@@ -1944,17 +1940,17 @@ function [pt, pt2, obj] = gnuplot_pointt
         pt = "6";
         pt2 = "7";
       case "*"
         pt = pt2 = "3";
       case "."
         pt = "6";
         pt2 = "7";
         if (isfield (obj, "markerfacecolor")
-            || strncmp (obj.markerfacecolor, "none", 4))
+            || strcmp (obj.markerfacecolor, "none"))
           obj.markerfacecolor = "auto";
         endif
         if (isfield (obj, "markersize"))
           obj.markersize /= 3;
         else
           obj.markersize = 5;
         endif
       case "x"
@@ -1967,29 +1963,29 @@ function [pt, pt2, obj] = gnuplot_pointt
         pt2 = "13";
       case "^"
         pt = "8";
         pt2 = "9";
       case "v"
         pt = "10";
         pt2 = "11";
       case ">"
-        ## FIXME -- should be triangle pointing right, use triangle pointing up
+        ## FIXME: should be triangle pointing right, use triangle pointing up
         pt = "8";
         pt2 = "9";
       case "<"
-        ## FIXME -- should be triangle pointing left, use triangle pointing down
+        ## FIXME: should be triangle pointing left, use triangle pointing down
         pt = "10";
         pt2 = "11";
       case {"pentagram", "p"}
-        ## FIXME -- should be pentagram, using pentagon
+        ## FIXME: should be pentagram, using pentagon
         pt = "14";
         pt2 = "15";
       case {"hexagram", "h"}
-        ## FIXME -- should be 6 pt start, using "*" instead
+        ## FIXME: should be 6 pt start, using "*" instead
         pt = pt2 = "3";
       case "none"
         pt = pt2 = "";
       otherwise
         pt = pt2 = "";
     endswitch
   else
     pt = pt2 = "";
@@ -2257,27 +2253,27 @@ function [f, s, fnt, it, bld] = get_font
   endif
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
     if (! isempty (t.fontangle)
         && (strcmpi (t.fontangle, "italic")
             || strcmpi (t.fontangle, "oblique")))
-      f = cstrcat (f, "-bolditalic");
+      f = [f "-bolditalic"];
       it = true;
       bld = true;
     else
-      f = cstrcat (f, "-bold");
+      f = [f "-bold"];
       bld = true;
     endif
   elseif (! isempty (t.fontangle)
           && (strcmpi (t.fontangle, "italic")
               || strcmpi (t.fontangle, "oblique")))
-    f = cstrcat (f, "-italic");
+    f = [f "-italic"];
     it = true;
   endif
   if (isempty (t.fontsize))
     s = 10;
   else
     s = t.fontsize;
   endif
 endfunction
@@ -2362,81 +2358,75 @@ function str = __tex2enhanced__ (str, fn
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
   [s, e, m] = regexp (str, "\\\\([a-zA-Z]+|0)", "start", "end", "matches");
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
-      str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
+      str = [str(1:s(i) - 1) '{/Symbol \306}' str(s(i) + 2:end)];
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
         g = getfield (sym, f);
         ## FIXME The symbol font doesn't seem to support bold or italic
         ##if (bld)
         ##  if (it)
         ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
         ##  else
         ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
         ##  endif
         ##elseif (it)
         ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
         ##endif
-        str = cstrcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
+        str = [str(1:s(i) - 1) g str(e(i) + 1:end)];
       elseif (strncmp (f, "rm", 2))
         bld = false;
         it = false;
-        str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
+        str = [str(1:s(i) - 1) '/' fnt ' ' str(s(i) + 3:end)];
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
         it = true;
         if (bld)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bolditalic ' str(s(i) + 3:end)];
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-italic ' str(s(i) + 3:end)];
         endif
       elseif (strncmp (f, "bf", 2))
         bld = true;
         if (it)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                         str(2(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bolditalic ' str(s(i) + 3:end)];
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bold ' str(s(i) + 3:end)];
         endif
       elseif (strcmpi (f, "color"))
         ## FIXME Ignore \color but remove trailing {} block as well
         d = strfind (str(e(i) + 1:end),'}');
         if (isempty (d))
           warning ('syntax error in \color argument');
         else
-          str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
+          str = [str(1:s(i) - 1) str(e(i) + d + 1:end)];
         endif
       elseif (strcmpi (f, "fontname"))
         b1 = strfind (str(e(i) + 1:end),'{');
         b2 = strfind (str(e(i) + 1:end),'}');
         if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/',
-                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                         str(e(i) + b2(1) + 1:end));
+          str = [str(1:s(i) - 1), '/', str(e(i)+b1(1) + 1:e(i)+b2(1)-1), ...
+                 '{}', str(e(i) + b2(1) + 1:end)];
         endif
       elseif (strcmpi (f, "fontsize"))
         b1 = strfind (str(e(i) + 1:end),'{');
         b2 = strfind (str(e(i) + 1:end),'}');
         if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/=',
-                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                         str(e(i) + b2(1) + 1:end));
+          str = [str(1:s(i) - 1), '/=', str(e(i)+b1(1) + 1:e(i)+b2(1)-1), ...
+                 '{}', str(e(i) + b2(1) + 1:end)];
         endif
       else
         ## Last desperate attempt to treat the symbol. Look for things
         ## like \pix, that should be translated to the symbol Pi and x
         for j = 1 : length (flds)
           if (strncmp (flds{j}, f, length (flds{j})))
             g = getfield (sym, flds{j});
             ## FIXME The symbol font doesn't seem to support bold or italic
@@ -2444,18 +2434,17 @@ function str = __tex2enhanced__ (str, fn
             ##  if (it)
             ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
             ##  else
             ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
             ##  endif
             ##elseif (it)
             ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
             ##endif
-            str = cstrcat (str(1:s(i) - 1), g,
-                           str(s(i) + length (flds{j}) + 1:end));
+            str = [str(1:s(i) - 1) g str(s(i) + length (flds{j}) + 1:end)];
             break;
           endif
         endfor
       endif
     endif
   endfor
 
   ## Prepend @ to things  things like _0^x or _{-100}^{100} for
@@ -2502,36 +2491,36 @@ function str = __tex2enhanced__ (str, fn
               else
                 si++;
               endif
             endwhile
             l2 = l2 (min (length (l2), si));
             if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
                 length_string (str(s(i+1)+p+2:s(i+1)+p+l2-1)))
               ## Shortest already first!
-              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+              str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
             else
               ## Have to swap sub/super-script to get shortest first.
-              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
-                             str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
+              str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2), ...
+                     str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end)];
             endif
           else
             ## Have to swap sub/super-script to get shortest first.
-            str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
-                           str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
+            str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1), ...
+                   str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end)];
           endif
           i += 2;
           p ++;
         else
           i++;
         endif
       else
         if (s(i+1) == s(i) + 2)
           ## Shortest already first!
-          str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+          str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
           p ++;
           i += 2;
         else
           i ++;
         endif
       endif
     else
       i ++;
@@ -2665,8 +2654,9 @@ function retval = __do_enhanced_option__
   if (enhanced)
     if (strcmpi (obj.interpreter, "none"))
       retval = "noenhanced";
     else
       retval = "enhanced";
     endif
   endif
 endfunction
+
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/util/private/__go_draw_figure__.m
rename from scripts/plot/private/__go_draw_figure__.m
rename to scripts/plot/util/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/util/private/__go_draw_figure__.m
@@ -20,191 +20,187 @@
 ## @deftypefn {Function File} {} __go_draw_figure__ (@var{h}, @var{plot_stream}, @var{enhanced}, @var{mono})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function __go_draw_figure__ (h, plot_stream, enhanced, mono)
 
-  if (nargin == 4)
-    htype = get (h, "type");
-    if (strcmp (htype, "figure"))
-      ## Get complete list of children.
-      kids = allchild (h);
-      nkids = length (kids);
+  htype = get (h, "type");
+  if (strcmp (htype, "figure"))
+    ## Get complete list of children.
+    kids = allchild (h);
+    nkids = length (kids);
 
-      if (nkids > 0)
-        fputs (plot_stream, "\nreset;\n");
-        fputs (plot_stream, "set autoscale keepfix;\n");
-        fputs (plot_stream, "set origin 0, 0\n");
-        fputs (plot_stream, "set size 1, 1\n");
-        bg = get (h, "color");
-        if (isnumeric (bg))
-          fprintf (plot_stream, "set obj 1 rectangle from screen 0,0 to screen 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * bg);
-          bg_is_set = true;
-        else
-          bg_is_set = false;
-        endif
-        fg_was_set = false;
+    if (nkids > 0)
+      fputs (plot_stream, "\nreset;\n");
+      fputs (plot_stream, "set autoscale keepfix;\n");
+      fputs (plot_stream, "set origin 0, 0\n");
+      fputs (plot_stream, "set size 1, 1\n");
+      bg = get (h, "color");
+      if (isnumeric (bg))
+        fprintf (plot_stream, "set obj 1 rectangle from screen 0,0 to screen 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * bg);
+        bg_is_set = true;
+      else
+        bg_is_set = false;
+      endif
+      fg_was_set = false;
 
-        for i = nkids:-1:1
-          type = get (kids(i), "type");
-          switch (type)
-            case "axes"
-              if (strcmpi (get (kids (i), "tag"), "legend"))
-                ## This is so ugly. If there was a way of getting
-                ## gnuplot to give us the text extents of strings
-                ## then we could get rid of this mess.
-                lh = getfield (get (kids(i), "userdata"), "handle");
-                if (isscalar (lh))
-                  ## We have a legend with a single parent. It'll be handled
-                  ## below as a gnuplot key to the axis it corresponds to
-                  continue;
-                else
-                  ca = lh(1);
-                  ## Rely upon listener to convert axes position
-                  ## to "normalized" units.
-                  legend_axes_units = get (kids(i), "units");
-                  legend_axes_position = get (kids(i), "position");
-                  legend_axes_outerposition = get (kids(i), "outerposition");
-                  legend_axes_box = get (kids(i), "box");
-                  legend_axes_ylim = get (kids(i), "ylim");
-                  orig_axes_units = get (ca, "units");
-                  hlgnd = get (kids(i));
+      for i = nkids:-1:1
+        type = get (kids(i), "type");
+        switch (type)
+          case "axes"
+            if (strcmpi (get (kids (i), "tag"), "legend"))
+              ## This is so ugly. If there was a way of getting
+              ## gnuplot to give us the text extents of strings
+              ## then we could get rid of this mess.
+              lh = getfield (get (kids(i), "userdata"), "handle");
+              if (isscalar (lh))
+                ## We have a legend with a single parent. It'll be handled
+                ## below as a gnuplot key to the axis it corresponds to
+                continue;
+              else
+                ca = lh(1);
+                ## Rely upon listener to convert axes position
+                ## to "normalized" units.
+                legend_axes_units = get (kids(i), "units");
+                legend_axes_position = get (kids(i), "position");
+                legend_axes_outerposition = get (kids(i), "outerposition");
+                legend_axes_box = get (kids(i), "box");
+                legend_axes_ylim = get (kids(i), "ylim");
+                orig_axes_units = get (ca, "units");
+                hlgnd = get (kids(i));
 
-                  unwind_protect
-                    set (ca, "units", "normalized");
-                    set (kids(i), "units", "normalized", "box", "off",
-                         "ylim", [-2, -1], "position", get (ca(1), "position"),
-                         "outerposition", get (ca(1), "outerposition"));
+                unwind_protect
+                  set (ca, "units", "normalized");
+                  set (kids(i), "units", "normalized", "box", "off",
+                       "ylim", [-2, -1], "position", get (ca(1), "position"),
+                       "outerposition", get (ca(1), "outerposition"));
 
-                    ## Create a new set of lines with the appropriate
-                    ## displaynames, etc
-                    toberm = [];
-                    hobj = get (kids(i), "children");
-                    for j = numel (hobj) : -1 : 1
-                      if (! strcmp (get (hobj(j), "type"), "text"))
+                  ## Create a new set of lines with the appropriate
+                  ## displaynames, etc
+                  toberm = [];
+                  hobj = get (kids(i), "children");
+                  for j = numel (hobj) : -1 : 1
+                    if (! strcmp (get (hobj(j), "type"), "text"))
+                      continue;
+                    endif
+                    displayname = get (hobj(j), "string");
+                    ll = [];
+                    lm = [];
+                    for k = numel (hobj) : -1 : 1
+                      if (! strcmp (get (hobj(k), "type"), "line"))
                         continue;
                       endif
-                      displayname = get (hobj(j), "string");
-                      ll = [];
-                      lm = [];
-                      for k = numel (hobj) : -1 : 1
-                        if (! strcmp (get (hobj(k), "type"), "line"))
-                          continue;
-                        endif
-                        if (get (hobj(j), "userdata")
-                            != get (hobj(k), "userdata"))
-                          continue;
-                        endif
-                        if (! strcmp (get (hobj(k), "linestyle"), "none"))
-                          ll = hobj(k);
-                        endif
-                        if (! strcmp (get (hobj(k), "marker"), "none"))
-                          lm = hobj(k);
-                        endif
-                      endfor
-
-                      if (! isempty (ll))
-                        if (!isempty (lm))
-                          toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", get(ll,"linestyle"), "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
-                        else
-                          toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(ll,"color"), "linestyle", get(ll,"linestyle"), "marker", "none", "displayname", displayname, "parent", kids(i))];
-                        endif
-                      elseif (! isempty (lm))
-                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", "none", "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
+                      if (get (hobj(j), "userdata")
+                          != get (hobj(k), "userdata"))
+                        continue;
+                      endif
+                      if (! strcmp (get (hobj(k), "linestyle"), "none"))
+                        ll = hobj(k);
+                      endif
+                      if (! strcmp (get (hobj(k), "marker"), "none"))
+                        lm = hobj(k);
                       endif
                     endfor
-                    if (bg_is_set)
-                      fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
+
+                    if (! isempty (ll))
+                      if (!isempty (lm))
+                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", get(ll,"linestyle"), "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
+                      else
+                        toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(ll,"color"), "linestyle", get(ll,"linestyle"), "marker", "none", "displayname", displayname, "parent", kids(i))];
+                      endif
+                    elseif (! isempty (lm))
+                      toberm = [toberm, line("xdata",[0,0],"ydata",[0,0], "color", get(lm,"color"), "linestyle", "none", "marker", get(lm,"marker"), "markeredgecolor", get(lm,"markeredgecolor"), "markerfacecolor", get(lm,"markerfacecolor"), "markersize", get (lm, "markersize"), "displayname", displayname, "parent", kids(i))];
                     endif
-                    __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
-                                      bg_is_set, false, hlgnd);
-                  unwind_protect_cleanup
-                    ## Return axes "units" and "position" back to
-                    ## their original values.
-                    set (ca, "units", orig_axes_units);
-                    set (kids(i), "units", legend_axes_units,
-                         "box", legend_axes_box,
-                         "ylim", legend_axes_ylim,
-                         "position", legend_axes_position,
-                         "outerposition", legend_axes_outerposition);
-                    delete (toberm);
-                    bg_is_set = false;
-                  end_unwind_protect
-                endif
-              else
-                ## Rely upon listener to convert axes position
-                ## to "normalized" units.
-                orig_axes_units = get (kids(i), "units");
-                orig_axes_position = get (kids(i), "position");
-                unwind_protect
-                  set (kids(i), "units", "normalized");
-                  fg = get (kids(i), "color");
-                  if (isnumeric (fg) && strcmp (get (kids(i), "visible"), "on"))
-                    fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
-                    fg_is_set = true;
-                    fg_was_set = true;
-                  elseif (fg_was_set)
-                    fprintf (plot_stream, "unset obj 2\n");
-                    fg_is_set = false;
-                    fg_was_set = false;
-                  else
-                    fg_is_set = false;
-                  endif
+                  endfor
                   if (bg_is_set)
                     fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                   endif
-                  ## Find if this axes has an associated legend axes and pass it
-                  ## to __go_draw_axes__
-                  hlegend = [];
-                  fkids = get (h, "children");
-                  for j = 1 : numel (fkids)
-                    if (ishandle (fkids (j))
-                        && strcmp (get (fkids (j), "type"), "axes")
-                        && (strcmp (get (fkids (j), "tag"), "legend")))
-                      udata = get (fkids (j), "userdata");
-                      if (isscalar (udata.handle)
-                          && ! isempty (intersect (udata.handle, kids (i))))
-                        hlegend = get (fkids (j));
-                        break;
-                      endif
-                    endif
-                  endfor
                   __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
-                                    bg_is_set, fg_is_set, hlegend);
+                                    bg_is_set, false, hlgnd);
                 unwind_protect_cleanup
                   ## Return axes "units" and "position" back to
                   ## their original values.
-                  set (kids(i), "units", orig_axes_units);
-                  set (kids(i), "position", orig_axes_position);
+                  set (ca, "units", orig_axes_units);
+                  set (kids(i), "units", legend_axes_units,
+                       "box", legend_axes_box,
+                       "ylim", legend_axes_ylim,
+                       "position", legend_axes_position,
+                       "outerposition", legend_axes_outerposition);
+                  delete (toberm);
                   bg_is_set = false;
-                  fg_is_set = false;
                 end_unwind_protect
               endif
-            case "uimenu"
-              ## ignore uimenu objects
-              kids(i) = [];
-            otherwise
-              error ("__go_draw_figure__: unknown object class, %s", type);
-          endswitch
-        endfor
-        if (isempty (kids))
-          fputs (plot_stream, "\nreset; clear;\n");
-          fflush (plot_stream);
-        else
-          fputs (plot_stream, "\nunset multiplot;\n");
-        endif
-      else
+            else
+              ## Rely upon listener to convert axes position
+              ## to "normalized" units.
+              orig_axes_units = get (kids(i), "units");
+              orig_axes_position = get (kids(i), "position");
+              unwind_protect
+                set (kids(i), "units", "normalized");
+                fg = get (kids(i), "color");
+                if (isnumeric (fg) && strcmp (get (kids(i), "visible"), "on"))
+                  fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
+                  fg_is_set = true;
+                  fg_was_set = true;
+                elseif (fg_was_set)
+                  fprintf (plot_stream, "unset obj 2\n");
+                  fg_is_set = false;
+                  fg_was_set = false;
+                else
+                  fg_is_set = false;
+                endif
+                if (bg_is_set)
+                  fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
+                endif
+                ## Find if this axes has an associated legend axes and pass it
+                ## to __go_draw_axes__
+                hlegend = [];
+                fkids = get (h, "children");
+                for j = 1 : numel (fkids)
+                  if (ishandle (fkids (j))
+                      && strcmp (get (fkids (j), "type"), "axes")
+                      && (strcmp (get (fkids (j), "tag"), "legend")))
+                    udata = get (fkids (j), "userdata");
+                    if (isscalar (udata.handle)
+                        && ! isempty (intersect (udata.handle, kids (i))))
+                      hlegend = get (fkids (j));
+                      break;
+                    endif
+                  endif
+                endfor
+                __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
+                                  bg_is_set, fg_is_set, hlegend);
+              unwind_protect_cleanup
+                ## Return axes "units" and "position" back to
+                ## their original values.
+                set (kids(i), "units", orig_axes_units);
+                set (kids(i), "position", orig_axes_position);
+                bg_is_set = false;
+                fg_is_set = false;
+              end_unwind_protect
+            endif
+          case "uimenu"
+            ## ignore uimenu objects
+            kids(i) = [];
+          otherwise
+            error ("__go_draw_figure__: unknown object class, %s", type);
+        endswitch
+      endfor
+      if (isempty (kids))
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
+      else
+        fputs (plot_stream, "\nunset multiplot;\n");
       endif
     else
-      error ("__go_draw_figure__: expecting figure object, found '%s'",
-             htype);
+      fputs (plot_stream, "\nreset; clear;\n");
+      fflush (plot_stream);
     endif
   else
-    print_usage ();
+    error ("__go_draw_figure__: expecting figure object, found '%s'",
+           htype);
   endif
 
 endfunction
 
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
rename from scripts/plot/private/__print_parse_opts__.m
rename to scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -85,19 +85,19 @@ function arg_st = __print_parse_opts__ (
       elseif (strcmp (arg, "-append"))
         arg_st.append_to_file = true;
       elseif (strcmp (arg, "-mono"))
         arg_st.use_color = -1;
       elseif (strcmp (arg, "-solid"))
         arg_st.force_solid = 1;
       elseif (strcmp (arg, "-dashed"))
         arg_st.force_solid = -1;
-      elseif (strncmp (arg, "-portrait", numel (arg)))
+      elseif (strncmp (arg, "-portrait", length (arg)))
         arg_st.orientation = "portrait";
-      elseif (strncmp (arg, "-landscape", numel (arg)))
+      elseif (strncmp (arg, "-landscape", length (arg)))
         arg_st.orientation = "landscape";
       elseif (strcmp (arg, "-loose"))
         arg_st.loose = true;
         arg_st.tight_flag = false;
       elseif (strcmp (arg, "-tight"))
         arg_st.loose = false;
         arg_st.tight_flag = true;
       elseif (strcmp (arg, "-textspecial"))
@@ -117,24 +117,24 @@ function arg_st = __print_parse_opts__ (
       elseif (strncmp (arg, "-EPSTOOL:", 9))
         arg_st.epstool_binary = arg{10:end};
       elseif (strncmp (arg, "-FIG2DEV:", 9))
         arg_st.fig2dev_binary = arg{10:end};
       elseif (strncmp (arg, "-PSTOEDIT:", 9))
         arg_st.pstoedit_binary = arg{10:end};
       elseif (strncmpi (arg, "-textalphabits=", 15))
         n = find (arg == "=");
-        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+        if (! isempty (n) && n == numel (arg) - 1 && any (arg(end) == "124"))
           arg_st.ghostscript.antialiasing_textalphabits = str2num (arg(end));
         else
           error ("print: improper syntax, or value, for TextAlphaBits");
         endif
       elseif (strncmpi (arg, "-graphicsalphabits=", 19))
         n = find (arg == "=");
-        if (! isempty (n) && n == numel (arg) - 1 && ismember (arg(end), "124"))
+        if (! isempty (n) && n == numel (arg) - 1 && any (arg(end) == "124"))
           arg_st.ghostscript.antialiasing_graphicsalphabits = str2num (arg(end));
         else
           error ("print: improper syntax, or value, for GraphicsAlphaBits");
         endif
       elseif ((length (arg) > 2) && arg(1:2) == "-G")
         arg_st.ghostscript.binary = file_in_path (getenv ("PATH"), arg(3:end));
         if (isempty (arg_st.ghostscript.binary))
           error ("print: Ghostscript binary ""%s"" could not be located",
@@ -322,16 +322,32 @@ function arg_st = __print_parse_opts__ (
     ## Assume we are formating output for a printer
     arg_st.formatted_for_printing = true;
     arg_st.ghostscript.device = arg_st.devopt;
     arg_st.ghostscript.output = arg_st.name;
     arg_st.ghostscript.antialiasing = false;
     arg_st.ghostscript.epscrop = ! arg_st.loose;
   endif
 
+  if (arg_st.send_to_printer)
+    if (isempty (arg_st.name))
+      ## Pipe the ghostscript output 
+      arg_st.name = "-";
+    else
+      error ("print: a file name may not specified when spooling to a printer")
+    endif
+    if (! any (strcmp (arg_st.devopt, gs_device_list))
+      || ! any (strcmp (arg_st.devopt, {"pswrite", "ps2write"})))
+      ## Only postscript and supported ghostscript devices
+      error ("print: invalid format for spooling to a printer")
+    endif
+  elseif (isempty (arg_st.name))
+    error ("print: an output file name must be specified")
+  endif
+
   if (isempty (arg_st.canvas_size))
     if (isfigure (arg_st.figure))
       [arg_st.ghostscript.papersize, paperposition] = ...
                            gs_papersize (arg_st.figure, arg_st.orientation);
     else
       ## allows tests to be run
       arg_st.ghostscript.papersize = "letter";
       paperposition = [0.25, 2.50, 8.00, 6.00] * 72;
@@ -574,40 +590,40 @@ function [papersize, paperposition] = gs
   endif
 
   if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
     papersize = papertype;
     papersize(papersize=="-") = "";
     papersize = strrep (papersize, "us", "");
     switch (papersize)
-    case "a"
-      papersize = "letter";
-    case {"b", "tabloid"}
-      papersize = "11x17";
-    case {"c", "d", "e"}
-      papersize = strcat ("arch", papersize);
+      case "a"
+        papersize = "letter";
+      case {"b", "tabloid"}
+        papersize = "11x17";
+      case {"c", "d", "e"}
+        papersize = strcat ("arch", papersize);
     endswitch
     if (strncmp (papersize, "arch", 4))
       papersize(end) = upper (papersize(end));
     endif
   endif
 
 endfunction
 
 function value = convert2points (value, units)
-    switch (units)
+  switch (units)
     case "inches"
       value = value * 72;
     case "centimeters"
       value = value * 72 / 2.54;
     case "normalized"
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
-    endswitch
+  endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not priners.
   device_list = {"bmp16"; "bmp16m"; "bmp256"; "bmp32b"; "bmpgray"; ...
                  "epswrite"; "jpeg"; "jpegcymk"; "jpeggray"; "pbm"; ...
                  "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
                  "pcxcmyk"; "pcxgray"; "pcxmono"; "pdfwrite"; "pgm"; ...
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/util/private/__tight_eps_bbox__.m
rename from scripts/plot/private/__tight_eps_bbox__.m
rename to scripts/plot/util/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/util/private/__tight_eps_bbox__.m
@@ -53,17 +53,17 @@ function bb = __tight_eps_bbox__ (opts, 
 
   ## Attempt to fix the bbox in place.
   fid = fopen (eps_file_name, "r+");
   unwind_protect
     bbox_replaced = false;
     looking_for_bbox = true;
     while (looking_for_bbox)
       current_line = fgetl (fid);
-      if (strncmpi (current_line, box_string, numel (box_string)))
+      if (strncmpi (current_line, box_string, length (box_string)))
         line_length = numel (current_line);
         num_spaces = line_length - numel (tight_bbox_line);
         if (numel (current_line) >= numel (tight_bbox_line))
           new_line = tight_bbox_line;
           new_line(end+1:numel (current_line)) = " ";
           bbox_replaced = true;
           ## Back up to the beginning of the line (include EOL characters).
           if (ispc ())
diff --git a/scripts/plot/refresh.m b/scripts/plot/util/refresh.m
rename from scripts/plot/refresh.m
rename to scripts/plot/util/refresh.m
--- a/scripts/plot/refresh.m
+++ b/scripts/plot/util/refresh.m
@@ -14,19 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} refresh ()
 ## @deftypefnx {Function File} {} refresh (@var{h})
-## Refresh a figure, forcing it to be redrawn.  When called without an
-## argument the current figure is redrawn.  Otherwise, the figure pointed
-## to by @var{h} is redrawn.
+## Refresh a figure, forcing it to be redrawn.
+##
+## When called without an argument the current figure is redrawn.  Otherwise,
+## the figure with graphic handle @var{h} is redrawn.
 ## @seealso{drawnow}
 ## @end deftypefn
 
 function refresh (h)
 
   if (nargin > 1)
     print_usage ();
   elseif (nargin == 1)
@@ -36,8 +37,9 @@ function refresh (h)
   else
     h = gcf ();
   endif
 
   set (h, "__modified__", "on");
   drawnow ();
 
 endfunction
+
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/util/refreshdata.m
rename from scripts/plot/refreshdata.m
rename to scripts/plot/util/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/util/refreshdata.m
@@ -16,25 +16,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} refreshdata ()
 ## @deftypefnx {Function File} {} refreshdata (@var{h})
 ## @deftypefnx {Function File} {} refreshdata (@var{h}, @var{workspace})
 ## Evaluate any @samp{datasource} properties of the current figure and update
-## the plot if the corresponding data has changed.  If called with one or more
-## arguments @var{h} is a scalar or array of figure handles to refresh.  The
-## optional second argument @var{workspace} can take the following values.
+## the plot if the corresponding data has changed.
+##
+## If the first argument @var{h} is a list of graphic handles, then operate
+## on these objects rather than the current figure returned by @code{gcf}.
+##
+## The optional second argument @var{workspace} can take the following values:
 ##
 ## @table @asis
-## @item "base"
+## @item @qcode{"base"}
 ## Evaluate the datasource properties in the base workspace.  (default).
 ##
-## @item "caller"
+## @item @qcode{"caller"}
 ## Evaluate the datasource properties in the workspace of the function
 ## that called @code{refreshdata}.
 ## @end table
 ##
 ## An example of the use of @code{refreshdata} is:
 ##
 ## @example
 ## @group
@@ -54,67 +57,63 @@ function refreshdata (h, workspace)
 
   if (nargin == 0)
     h = gcf ();
     workspace = "base";
   else
     if (iscell (h))
       h = [h{:}];
     endif
-    if (!all (ishandle (h)) || !all (strcmp (get (h, "type"), "figure")))
-      error ("refreshdata: expecting a list of figure handles");
+    if (! all (isfigure (h)))
+      error ("refreshdata: H must be a list of figure handles");
     endif
-    if (nargin < 2)
+    if (nargin == 1)
       workspace = "base";
+    elseif (nargin == 2)
+      if (! ischar (workspace)
+          || ! any (strcmpi (workspace, {"base", "caller"})))
+        error ('refreshdata: WORKSPACE must be "base" or "caller"');
+      endif
+      workspace = tolower (workspace);
     else
-      if (   !ischar (workspace)
-          || !(strcmpi (workspace, "base")
-          || strcmpi (workspace, "caller")))
-        error ("refreshdata: expecting WORKSPACE to be \"base\" or ""caller\"");
-      else
-        workspace = tolower (workspace);
-      endif
+      print_usage ();
     endif
   endif
 
   h = findall (h);
   objs = [];
   props = {};
 
   for i = 1 : numel (h)
-    obj = get (h (i));
-    fldnames = fieldnames (obj);
-    m = regexpi (fieldnames (obj), '^.+datasource$', "match");
-    idx = ! cellfun ("isempty", m);
-    if (any (idx))
-      tmp = m(idx);
-      props = [props; {vertcat(tmp{:})}];
-      objs  = [objs ; h(i)];
-    endif
-  endfor
-
-  for i = 1 : length (objs)
-    for j = 1 : length (props {i})
-      expr = get (objs(i), props{i}{j});
-      if (!isempty (expr))
-        val = evalin (workspace, expr);
-        prop =  props{i}{j}(1:end-6);
-        if (! isequal (get (objs(i), prop), val))
-          set (objs(i), props{i}{j}(1:end-6), val);
-        endif
+    obj = get (h(i));
+    flds = fieldnames (obj);
+    ## regexp() is proper way to do searching, but is 3X slower.
+    ## Pretty unlikely that people are going to be adding datasource
+    ## properties that are not, in fact, datasources.
+    ## m = regexp (flds, '^.+datasource$');
+    m = strfind (flds, "datasource");
+    m = flds(!cellfun (@isempty, m));
+    for j = 1 : numel (m)
+      if (isempty (obj.(m{j})))
+        continue;  # datasource field doesn't point to anything
       endif
+      expr = obj.(m{j});       # datasource field
+      val = evalin (workspace, expr);
+      pdname = m{j}(1:end-6);  # property data name without "source"
+      set (h(i), pdname, val); 
     endfor
   endfor
-
 endfunction
 
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, 'ydatasource', 'y');
+%! title ('refreshdata() showing moving sine curve');
+%! axis manual;
 %! for i = 1 : 100
-%!   pause (0.1);
+%!   pause (0);
 %!   y = sin (x + 0.1 * i);
 %!   refreshdata (gcf, 'caller');
 %! end
 
diff --git a/scripts/plot/saveas.m b/scripts/plot/util/saveas.m
rename from scripts/plot/saveas.m
rename to scripts/plot/util/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/util/saveas.m
@@ -21,47 +21,47 @@
 ## @deftypefnx {Function File} {} saveas (@var{h}, @var{filename}, @var{fmt})
 ## Save graphic object @var{h} to the file @var{filename} in graphic
 ## format @var{fmt}.
 ##
 ## @var{fmt} should be one of the following formats:
 ##
 ## @table @code
 ##   @item ps
-##     Postscript
+##     PostScript
 ##
 ##   @item eps
-##     Encapsulated Postscript
+##     Encapsulated PostScript
 ##
 ##   @item jpg
 ##     JPEG Image
 ##
 ##   @item png
 ##     PNG Image
 ##
 ##   @item emf
 ##     Enhanced Meta File
 ##
 ##   @item pdf
 ##     Portable Document Format
 ## @end table
 ##
 ## All device formats specified in @code{print} may also be used.  If
 ## @var{fmt} is omitted it is extracted from the extension of @var{filename}.
-## The default format is @code{"pdf"}.
+## The default format is @qcode{"pdf"}.
 ##
 ## @example
 ## @group
 ## clf ();
 ## surf (peaks);
 ## saveas (1, "figure1.png");
 ## @end group
 ## @end example
 ##
-## @seealso{print}
+## @seealso{print, orient}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function  saveas (h, filename, fmt = "pdf")
 
   if ((nargin != 2) && (nargin != 3))
     print_usage ();
@@ -100,8 +100,9 @@ function  saveas (h, filename, fmt = "pd
     endif
   endif
 
   prt_opt = strcat ("-d", tolower (fmt));
 
   print (fig, filename, prt_opt);
 
 endfunction
+
diff --git a/scripts/plot/shg.m b/scripts/plot/util/shg.m
rename from scripts/plot/shg.m
rename to scripts/plot/util/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/util/shg.m
@@ -13,24 +13,26 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} shg
-## Show the graph window.  Currently, this is the same as executing
-## @code{drawnow}.
+## Show the graph window.
+##
+## Currently, this is the same as executing @code{drawnow}.
 ## @seealso{drawnow, figure}
 ## @end deftypefn
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
     warning ("shg: ignoring extra arguments");
   endif
 
   drawnow ();
 
 endfunction
+
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/util/struct2hdl.m
rename from scripts/plot/struct2hdl.m
rename to scripts/plot/util/struct2hdl.m
--- a/scripts/plot/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -13,28 +13,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} struct2hdl (@var{s})
 ## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p})
 ## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p}, @var{hilev})
-## Construct a handle object @var{h} from the structure @var{s}.  The structure
-## must contain the fields "handle", "type", "children", "properties", and
-## "special".  If the handle of an existing figure or axes is specified,
-## @var{p}, the new object will be created as a child of that object.
-## If no object handle is provided then a new figure and the necessary
-## children will be constructed using the default object values from
-## the root figure.
+## Construct a graphics handle object @var{h} from the structure @var{s}.
+##
+## The structure must contain the fields @qcode{"handle"}, @qcode{"type"},
+## @qcode{"children"}, @qcode{"properties"}, and @qcode{"special"}.  If the
+## handle of an existing figure or axes is specified, @var{p}, the new object
+## will be created as a child of that object.  If no parent handle is provided
+## then a new figure and the necessary children will be constructed using the
+## default values from the root figure.
 ##
 ## A third boolean argument @var{hilev} can be passed to specify whether
-## the function should try to preserve listeners/callbacks, e.g., for
-## legends or hggroups.  The default is false.
-## @seealso{hdl2struct, findobj, get, set}
+## the function should preserve listeners/callbacks, e.g., for legends or
+## hggroups.  The default is false.
+## @seealso{hdl2struct, findobj}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
 function [h, pout] = struct2hdl (s, p=[], hilev = false)
 
   fields = {"handle", "type", "children", "properties", "special"};
@@ -87,17 +88,17 @@ function [h, pout] = struct2hdl (s, p=[]
   endif
   ## read parent (last column) in p and remove it if duplicate
   par = p(2,end);
   tst = find (p(2,:) == par);
   if (numel (tst) > 1)
     p = p(1:2, 1:(tst(end)-1));
   endif
 
-  ## Place the "*mode" properties as the end to avoid having the updaters
+  ## Place the "*mode" properties at the end to avoid having the updaters
   ## change the mode to "manual" when the value is "auto".
   names = fieldnames (s.properties);
   n = strncmp (cellfun (@fliplr, names, "uniformoutput", false), "edom", 4);
   n = (n | strcmp (names, "activepositionproperty"));
   names = [names(!n); names(n)];
   if (strcmp (s.type, "axes"))
     n_pos = find (strcmp (names, "position") | strcmp (names, "outerposition"));
     if (strcmp (s.properties.activepositionproperty, "position"))
@@ -183,19 +184,19 @@ function [h, sout] = createaxes (s, p, p
         val = s.properties.(prop);
         propval = [propval, prop, val];
       endif
     endfor
     h = axes (propval{:}, "parent", par);
 
     if (isfield (s.properties, "__plotyy_axes__"))
       plty = s.properties.__plotyy_axes__;
-      addproperty ("__plotyy_axes__", h, "any");
+      addproperty ("__plotyy_axes__", h, "data");
       tmp = [p [s.handle; h]];
-      tst = arrayfun (@(x) any (plty == x), tmp(1:2:end));
+      tst = ismember (tmp(1:2:end), plty);
       if (sum (tst) == numel (plty))
         for ii = 1:numel (plty)
           plty(ii) = tmp(find (tmp == plty(ii)) + 1);
         endfor
         for ii = 1:numel (plty)
           set (plty(ii), "__plotyy_axes__", plty);
         endfor
       endif
@@ -300,17 +301,17 @@ function [h, sout] = createpatch (s, par
 endfunction
 
 function h = createtext (s, par)
   h = text ("parent", par);
   addmissingprops (h, s.properties);
 endfunction
 
 function h = createimage (s, par)
-  h = image ("parent", par);
+  h = image (1, "parent", par);
   addmissingprops (h, s.properties);
 endfunction
 
 function h = createsurface (s, par)
   h = surface ("parent", par);
   addmissingprops (h, s.properties);
 endfunction
 
@@ -412,17 +413,17 @@ function [h, sout, pout] = createhg_hile
     form = s.properties.format;
     xdata = s.properties.xdata;
     ydata = s.properties.ydata;
     xldata = s.properties.xldata;
     ldata = s.properties.ldata;
     xudata = s.properties.xudata;
     udata = s.properties.udata;
 
-    switch form
+    switch (form)
       case "xerr"
         h = errorbar (xdata, ydata, xldata, xudata, ">");
       case "yerr"
         h = errorbar (xdata, ydata, ldata, udata, "~");
       case "xyerr"
         h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "~>");
       case "box"
         h = errorbar (xdata, ydata, xldata, xudata, "#");
@@ -447,17 +448,18 @@ function [h, sout, pout] = createhg_hile
     ## FIXME - here we don't have access to brothers so we first create all
     ## the barseries of the bargroup (but the last), then retrieve information,
     ## and rebuild the whole bargroup.
     ## The duplicate are deleted after calling "setprops"
 
     bargroup = s.properties.bargroup;
     oldh = s.handle;
 
-    temp = arrayfun (@(x) any(x == bargroup), [p(1:2:end) oldh]);
+    temp = ismember ([p(1:2:end) oldh], bargroup);
+
     tst = sum (temp) == length (bargroup);
 
     if (isscalar (bargroup) || !tst)
       xdata = s.properties.xdata;
       ydata = s.properties.ydata;
 
       h = bar (xdata, ydata);
 
@@ -541,17 +543,21 @@ function [h, sout, pout] = createhg_hile
   sout = s;
   pout = p;
 endfunction
 
 function setprops (s, h, p, hilev)
   more off;
   if (strcmpi (s.properties.tag, ""))
     specs = s.children(s.special);
-    hdls = arrayfun (@(x) x.handle, specs);
+    if (isempty (specs))
+      hdls = [];
+    else
+      hdls = [specs.handle];
+    endif
     nh = length (hdls);
     msg = "";
     if (! nh)
       set (h, s.properties);
     else
       ## Specials are objects that where automatically constructed with
       ## current object. Among them are "x(yz)labels", "title", high
       ## level hggroup children
@@ -619,20 +625,21 @@ function out = valcomp (x, hdls)
     out = 0;
   endif
 endfunction
 
 function addmissingprops (h, props)
   hid = {"autopos_tag", "looseinset"};
   oldfields = fieldnames (props);
   curfields = fieldnames (get (h));
-  missing = cellfun (@(x) !any (strcmp (x, curfields)), oldfields);
+  missing = ! ismember (oldfields, curfields);
   idx = find (missing);
   for ii = 1:length (idx)
     prop = oldfields{idx(ii)};
     if (! any (strcmp (prop, hid)))
       addproperty (prop, h, "any");
     endif
   endfor
 endfunction
 
 
 ## FIXME: Need validation tests
+
diff --git a/scripts/plot/subplot.m b/scripts/plot/util/subplot.m
rename from scripts/plot/subplot.m
rename to scripts/plot/util/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -14,28 +14,33 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
-## Set up a plot grid with @var{rows} by @var{cols} subwindows and plot
-## in location given by @var{index}.
+## @deftypefnx {Function File} {} subplot (@var{hax})
+## @deftypefnx {Function File} {} subplot (@dots{}, "align")
+## @deftypefnx {Function File} {} subplot (@dots{}, "replace")
+## @deftypefnx {Function File} {} subplot (@dots{}, "position", @var{pos})
+## @deftypefnx {Function File} {} subplot (@dots{}, @var{prop}, @var{val}, @dots{})
+## @deftypefnx {Function File} {@var{hax} =} subplot (@dots{})
+## Set up a plot grid with @var{rows} by @var{cols} subwindows and set the
+## current axes for plotting (@code{gca}) to the location given by @var{index}.
 ##
-## If only one argument is supplied, then it must be a three digit value
-## specifying the location in digits 1 (rows) and 2 (columns) and the plot
-## index in digit 3.
+## If only one numeric argument is supplied, then it must be a three digit
+## value specifying the number of rows in digit 1, the number of
+## columns in digit 2, and the plot index in digit 3.
 ##
-## The plot index runs row-wise.  First all the columns in a row are filled
+## The plot index runs row-wise; First, all columns in a row are numbered
 ## and then the next row is filled.
 ##
-## For example, a plot with 2 by 3 grid will have plot indices running as
-## follows:
+## For example, a plot with 2x3 grid will have plot indices running as follows:
 ## @tex
 ## \vskip 10pt
 ## \hfil\vbox{\offinterlineskip\hrule
 ## \halign{\vrule#&&\qquad\hfil#\hfil\qquad\vrule\cr
 ## height13pt&1&2&3\cr height12pt&&&\cr\noalign{\hrule}
 ## height13pt&4&5&6\cr height12pt&&&\cr\noalign{\hrule}}}
 ## \hfil
 ## \vskip 10pt
@@ -47,71 +52,93 @@
 ## +-----+-----+-----+
 ## |  1  |  2  |  3  |
 ## +-----+-----+-----+
 ## |  4  |  5  |  6  |
 ## +-----+-----+-----+
 ## @end group
 ## @end example
 ##
-## @var{index} may be a vector.  In which case, the new axis will enclose
-## the grid locations specified.  The first demo illustrates an example:
+## @end ifnottex
+##
+## @var{index} may also be a vector.  In this case, the new axis will enclose
+## the grid locations specified.  The first demo illustrates this:
 ##
 ## @example
 ## demo ("subplot", 1)
 ## @end example
 ##
-## @end ifnottex
-## @seealso{axes, plot}
+## The index of the subplot to make active may also be specified by its axes
+## handle, @var{hax}, returned from a previous @code{subplot} command.
+##
+## If the option @qcode{"align"} is given then the plot boxes of the subwindows
+## will align, but this may leave no room for axis tick marks or labels.
+##
+## If the option @qcode{"replace"} is given then the subplot axis will be
+## reset, rather than just switching the current axis for plotting to the
+## requested subplot.
+##
+## The @qcode{"position"} property can be used to exactly position the subplot
+## axes within the current figure.  The option @var{pos} is a 4-element vector
+## [x, y, width, height] that determines the location and size of the axes.
+## The values in @var{pos} are normalized in the range [0,1].
+##
+## Any property/value pairs are passed directly to the underlying axes object.
+##
+## If the output @var{hax} is requested, subplot returns the axis handle for
+## the subplot.  This is useful for modifying the properties of a subplot
+## using @code{set}.
+## @seealso{axes, plot, gca, set}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function h = subplot (varargin)
 
   align_axes = false;
   replace_axes = false;
   have_position = false;
   initial_args_decoded = false;
 
-  if (nargin > 2)
+  if (nargin >= 3)
     ## R, C, N?
     arg1 = varargin{1};
     arg2 = varargin{2};
     arg3 = varargin{3};
-    if (isnumeric (arg1) && isscalar (arg1) && isnumeric (arg2)
-        && isscalar (arg2) && isnumeric (arg3))
+    if (   isnumeric (arg1) && isscalar (arg1)
+        && isnumeric (arg2) && isscalar (arg2)
+        && isnumeric (arg3))
       rows = arg1;
       cols = arg2;
       index = arg3;
-      varargin(1:3)= [];
+      varargin(1:3) = [];
       initial_args_decoded = true;
     endif
   endif
 
   if (! initial_args_decoded && nargin > 1)
-    ## check for 'position', pos, ...
+    ## check for "position", pos, ...
     if (strcmpi (varargin{1}, "position"))
       arg = varargin{2};
       if (isnumeric (arg) && numel (arg) == 4)
         pos = arg;
         varargin(1:2) = [];
         have_position = true;
         initial_args_decoded = true;
       else
-        error ("expecting position to be a 4-element numeric array");
+        error ("subplot: POSITION must be a 4-element numeric array");
       endif
     endif
   endif
     
   if (! initial_args_decoded && nargin > 0)
     arg = varargin{1};
-    if (nargin == 1 && ishandle (arg))
-      ## Axes handle?
+    if (nargin == 1 && isaxes (arg))
+      ## Axes handle
       axes (arg);
       cf = get (0, "currentfigure");
       set (cf, "nextplot", "add");
       return;
     elseif (isscalar (arg) && arg >= 0)
       ## RCN?
       index = rem (arg, 10);
       arg = (arg - index) / 10;
@@ -130,157 +157,155 @@ function h = subplot (varargin)
   endif
 
   if (! have_position)
     cols = round (cols);
     rows = round (rows);
     index = round (index);
 
     if (any (index < 1) || any (index > rows*cols))
-      error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS");
+      error ("subplot: INDEX value must be >= 1 and <= ROWS*COLS");
     endif
 
-    if (cols < 1 || rows < 1 || index < 1)
-      error ("subplot: COLS, ROWS, and INDEX must be be positive");
+    if (rows < 1 || cols < 1 || index < 1)
+      error ("subplot: ROWS, COLS, and INDEX must be be positive");
     endif
   endif
 
-  nargs = numel (varargin);
-  while (nargs > 0)
-    arg = varargin{1};
-    if (strcmpi (arg, "align"))
-      align_axes = true;
-    elseif (strcmpi (arg, "replace"))
-      replace_axes = true;
-    else
-      break;
-    endif
-    varargin(1) = [];
-    nargs--;
-  endwhile
+  ## Process "align" and "replace" options
+  idx = strcmpi (varargin, "align");
+  if (any (idx))
+    align_axes = true;
+    varargin(idx) = [];
+  endif
+
+  idx = strcmpi (varargin, "replace");
+  if (any (idx))
+    replace_axes = true;
+    varargin(idx) = [];
+  endif
 
   axesunits = get (0, "defaultaxesunits");
   cf = gcf ();
   figureunits = get (cf, "units");
   unwind_protect
-    units = "normalized";
-    set (0, "defaultaxesunits", units);
+    set (0, "defaultaxesunits", "normalized");
     set (cf, "units", "pixels");
 
     ## FIXME: At the moment we force gnuplot to use the aligned mode
     ##        which will set "activepositionproperty" to "position".
     ##        his can yield to text overlap between labels and titles
     ##        see bug #31610
     if (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
       align_axes = true;
     endif
 
     if (! have_position)
+      pos = subplot_position (rows, cols, index, "position");
+      outerpos = subplot_position (rows, cols, index, "outerposition");
+      box = [pos(1:2), pos(1:2)+pos(3:4)];
+      outerbox = [outerpos(1:2), outerpos(1:2)+outerpos(3:4)];
+      looseinset = [box(1:2)-outerbox(1:2), outerbox(3:4)-box(3:4)];
       if (align_axes)
-        pos = subplot_position (rows, cols, index, "position");
-      elseif (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
-        pos = subplot_position (rows, cols, index, "outerpositiontight");
+        activepositionproperty = "position";
       else
-        pos = subplot_position (rows, cols, index, "outerposition");
+        activepositionproperty = "outerposition";
       endif
     endif
 
     set (cf, "nextplot", "add");
 
     found = false;
     kids = get (cf, "children");
-    for child = reshape (kids, 1, numel (kids))
+    for child = kids(:)'
       ## Check whether this child is still valid; this might not be the
       ## case anymore due to the deletion of previous children (due to
       ## "deletefcn" callback or for legends/colorbars that are deleted
       ## with their corresponding axes).
       if (! ishandle (child))
         continue;
       endif
       if (strcmp (get (child, "type"), "axes"))
         ## Skip legend and colorbar objects.
-        if (strcmp (get (child, "tag"), "legend")
-            || strcmp (get (child, "tag"), "colorbar"))
+        if (any (strcmp (get (child, "tag"), {"legend", "colorbar"})))
           continue;
         endif
-        if (align_axes)
-          objpos = get (child, "position");
+        objpos = get (child, "outerposition");
+        if (all (abs (objpos - outerpos) < eps) && ! replace_axes)
+          ## If the new axes are in exactly the same position
+          ## as an existing axes object, use the existing axes.
+          found = true;
+          hsubplot = child;
         else
-          objpos = get (child, "outerposition");
-        endif
-        if (all (abs (objpos - pos) < eps) && ! replace_axes)
-          ## If the new axes are in exactly the same position as an
-          ## existing axes object, use the existing axes.
-          found = true;
-          tmp = child;
-        else
-          ## If the new axes overlap an old axes object, delete the old
-          ## axes.
+          ## If the new axes overlap an old axes object, delete the old axes.
+          if (align_axes)
+            objpos = get (child, "position");
+          endif
           x0 = pos(1);
           x1 = x0 + pos(3);
           y0 = pos(2);
           y1 = y0 + pos(4);
           objx0 = objpos(1);
           objx1 = objx0 + objpos(3);
           objy0 = objpos(2);
           objy1 = objy0 + objpos(4);
           if (! (x0 >= objx1 || x1 <= objx0 || y0 >= objy1 || y1 <= objy0))
             delete (child);
           endif
         endif
       endif
     endfor
 
     if (found)
-      set (cf, "currentaxes", tmp);
-    elseif (align_axes)
-      tmp = axes ("box", "off", "position", pos, varargin{:});
-    elseif (strcmp (get (cf, "__graphics_toolkit__"), "gnuplot"))
-      tmp = axes ("box", "off", "outerposition", pos, varargin{:});
+      ## Switch to existing subplot
+      set (cf, "currentaxes", hsubplot);
     else
-      tmp = axes ("looseinset", [0 0 0 0], "box", "off", "outerposition", pos,
-                  "autopos_tag", "subplot", varargin{:});
+      hsubplot = axes ("box", "off",
+                       "position", pos,
+                       "looseinset", looseinset,
+                       "activepositionproperty", activepositionproperty,
+                       varargin{:});
+      addproperty ("subplot_align", hsubplot, "boolean", true);
+      addlistener (hsubplot, "position", @subplot_align);
+      if (! align_axes)
+        set (hsubplot, "subplot_align", false)
+        subplot_align (hsubplot)
+      endif
     endif
 
   unwind_protect_cleanup
     set (0, "defaultaxesunits", axesunits);
     set (cf, "units", figureunits);
   end_unwind_protect
 
   if (nargout > 0)
-    h = tmp;
+    h = hsubplot;
   endif
 
 endfunction
 
 function pos = subplot_position (rows, cols, index, position_property)
 
   if (rows == 1 && cols == 1)
     ## Trivial result for subplot (1,1,1)
     if (strcmpi (position_property, "position"))
       pos = get (0, "defaultaxesposition");
     else
       pos = get (0, "defaultaxesouterposition");
     endif
-    return
+    return;
   endif
 
-  if (strcmp (position_property, "outerposition")
-      || strcmp (position_property, "outerpositiontight"))
+  if (strcmp (position_property, "outerposition"))
     margins.left   = 0.05;
     margins.bottom = 0.05;
     margins.right  = 0.05;
     margins.top    = 0.05;
-    if (strcmp (position_property, "outerpositiontight"))
-      margins.column = 0.;
-      margins.row = 0.;
-    else
-      margins.column = 0.04 / cols;
-      margins.row = 0.04 / rows;
-    endif
+    margins.column = 0.04 / cols;
+    margins.row    = 0.04 / rows;
     width = 1 - margins.left - margins.right - (cols-1)*margins.column;
     width = width / cols;
     height = 1 - margins.top - margins.bottom - (rows-1)*margins.row;
     height = height / rows;
   else
     defaultaxesposition = get (0, "defaultaxesposition");
 
     ## The outer margins surrounding all subplot "positions" are independent
@@ -304,17 +329,17 @@ function pos = subplot_position (rows, c
     height = height / rows;
   endif
 
   ## Index offsets from the lower left subplot
   yi = fix ((index(:)-1)/cols);
   xi = index(:) - yi*cols - 1;
   yi = (rows - 1) - yi;
 
-  ## Lower left corner of the subplot, i.e. position(1:2)
+  ## Lower left corner of the subplot, i.e., position(1:2)
   x0 = xi .* (width + margins.column) + margins.left;
   y0 = yi .* (height + margins.row) + margins.bottom;
 
   if (numel (x0) > 1)
     ## subplot (row, col, m:n)
     x1 = max (x0(:)) + width;
     y1 = max (y0(:)) + height;
     x0 = min (x0(:));
@@ -322,16 +347,43 @@ function pos = subplot_position (rows, c
     pos = [x0, y0, x1-x0, y1-y0];
   else
     ## subplot (row, col, num)
     pos = [x0, y0, width, height];
   endif
 
 endfunction
 
+function subplot_align (h, varargin)
+  persistent updating = false;
+
+  if (! updating)
+    unwind_protect
+      updating = true;
+      hfig = ancestor (h, "figure");
+      hsubplots = findall (hfig, "type", "axes", "subplot_align", "off");
+      if (! isempty (hsubplots))
+        tightinset = get (hsubplots, "tightinset");
+        if (iscell (tightinset))
+          tightinset = max (cell2mat (tightinset));
+        endif
+        looseinset = get (hsubplots, "looseinset");
+        if (iscell (looseinset))
+          looseinset = max (cell2mat (looseinset));
+        endif
+        looseinset = max (tightinset, looseinset);
+        set (hsubplots, "looseinset", looseinset);
+      endif
+    unwind_protect_cleanup
+      updating = false;
+    end_unwind_protect
+  endif
+
+endfunction
+
 
 %!demo
 %! clf;
 %! r = 3;
 %! c = 3;
 %! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
 %! for n = 1 : r*c
 %!   subplot (r, c, n);
@@ -359,8 +411,67 @@ endfunction
 %!   title (sprintf ('title (2,2,%d)', n));
 %! end
 %! subplot (1,2,1, 'align');
 %! plot (x, x);
 %! xlabel ('xlabel (1,2,1)');
 %! ylabel ('ylabel (1,2,1)');
 %! title ('title (1,2,1)');
 
+%!demo
+%! clf;
+%! x = 0:10;
+%! ax(1) = subplot (221);
+%! set (ax(1), 'tag', '1');
+%! plot (x, rand (3, 11))
+%! title ('x & y labels & ticklabels');
+%! xlabel xlabel
+%! ylabel ylabel
+%! ax(2) = subplot (222);
+%! set (ax(2), 'tag', '2');
+%! plot (x, rand (3, 11))
+%! title ('no labels');
+%! axis ('nolabel','tic')
+%! ax(3) = subplot (223);
+%! set (ax(3), 'tag', '3');
+%! plot (x, rand (3, 11))
+%! title ('no labels');
+%! axis ('nolabel','tic')
+%! ax(4) = subplot (224);
+%! set (ax(4), 'tag', '4');
+%! plot (x, rand (3, 11))
+%! title ('x & y labels & ticklabels');
+%! xlabel xlabel
+%! ylabel ylabel
+
+%!demo
+%! x = 0:10;
+%! subplot (221);
+%! plot (x, rand (3, 11))
+%! ylim ([0, 1]);
+%! text (0.5, 0.5, '{x,y}labels & {x,y}ticklabels', ...
+%!       'horizontalalignment', 'center', ...
+%!       'units', 'normalized');
+%! xlabel xlabel
+%! ylabel ylabel
+%! title title
+%! subplot (222);
+%! plot (x, rand (3, 11))
+%! axis ('labely');
+%! ylabel ylabel
+%! text (0.5, 0.5, 'no xlabels, xticklabels', ...
+%!       'horizontalalignment', 'center', ...
+%!       'units', 'normalized');
+%! subplot (223);
+%! plot (x, rand (3, 11))
+%! axis ('labelx');
+%! text (0.5, 0.5, 'no ylabels, yticklabels', ...
+%!       'horizontalalignment', 'center', ...
+%!       'units', 'normalized');
+%! xlabel xlabel
+%! title title
+%! subplot (224);
+%! plot (x, rand (3, 11))
+%! axis ('nolabel','tic');
+%! text (0.5, 0.5, 'no {x,y}labels, {x,y}ticklabels', ...
+%!       'horizontalalignment', 'center', ...
+%!       'units', 'normalized');
+
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -24,20 +24,20 @@
 ## The output convolution is a vector with length equal to
 ## @code{length (@var{a}) + length (@var{b}) - 1}.
 ## When @var{a} and @var{b} are the coefficient vectors of two polynomials, the
 ## convolution represents the coefficient vector of the product polynomial.
 ##
 ## The optional @var{shape} argument may be
 ##
 ## @table @asis
-## @item @var{shape} = "full"
+## @item @var{shape} = @qcode{"full"}
 ## Return the full convolution.  (default)
 ##
-## @item @var{shape} = "same"
+## @item @var{shape} = @qcode{"same"}
 ## Return the central part of the convolution with the same size as @var{a}.
 ## @end table
 ##
 ## @seealso{deconv, conv2, convn, fftconv}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -40,22 +40,22 @@
 ## In any case @var{coefs} is reshaped to a 2-D matrix of
 ## size @code{[@var{ni}*prod(@var{d} @var{m})] }
 ##
 ## @seealso{unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
 
-  # check number of arguments
+  ## check number of arguments
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  # check x
+  ## check x
   if (length (x) < 2)
     error ("mkpp: at least one interval is needed");
   endif
 
   if (!isvector (x))
     error ("mkpp: x must be a vector");
   endif
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -120,16 +120,17 @@ function ret = pchip (x, y, xi)
   ret = mkpp (x, coeffs, szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
+
 %!demo
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %! xi = 0:0.01:8;
 %! yspline = spline (x,y,xi);
 %! ypchip = pchip (x,y,xi);
 %! title ("pchip and spline fit to discontinuous function");
 %! plot (xi,yspline, xi,ypchip,"-", x,y,"+");
@@ -165,8 +166,9 @@ endfunction
 %!assert (yi3(:,:,2), ppval (pp,pi), 1e-14)
 %!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
 %!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 %!assert (size (yi2), [3,2,5,4])
 %!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 
 %!error (pchip (1,2));
 %!error (pchip (1,2,3));
+
diff --git a/scripts/polynomial/polyeig.m b/scripts/polynomial/polyeig.m
--- a/scripts/polynomial/polyeig.m
+++ b/scripts/polynomial/polyeig.m
@@ -41,23 +41,23 @@ function [ z, varargout ] = polyeig (var
     print_usage ();
   endif
 
   nin = numel (varargin);
 
   n = zeros (1, nin);
 
   for cnt = 1 : nin
-    if ! ( issquare (varargin{cnt}) )
+    if (! issquare (varargin{cnt}))
        error ("polyeig: coefficients must be square matrices");
     endif
     n(cnt) = size (varargin{cnt}, 1);
   endfor
 
-  if numel (unique (n)) > 1
+  if (numel (unique (n)) > 1)
        error ("polyeig: coefficients must have the same dimensions");
   endif
   n = unique (n);
 
   ## matrix polynomial degree
   l = nin - 1;
 
   ## form needed matrices
@@ -78,14 +78,16 @@ function [ z, varargout ] = polyeig (var
     z = z(1:n,:);
     ## max() takes the abs if complex:
     t = max (z);
     z /= diag (t);
   endif
 
 endfunction
 
+
 %!test
 %! C0 = [8, 0; 0, 4]; C1 = [1, 0; 0, 1];
 %! [v,z] = polyeig (C0, C1);
 %! assert (isequal (z(1), -8), true);
 %! d = C0*v + C1*v*z;
 %! assert (isequal (norm(d), 0.0), true);
+
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -110,17 +110,17 @@ function [p, s, mu] = polyfit (x, y, n)
   ## Construct the Vandermonde matrix.
   v = vander (x, n+1);
 
   ## Solve by QR decomposition.
   [q, r, k] = qr (v(:, polymask), 0);
   p = r \ (q' * y);
   p(k) = p;
   
-  if (n ~= m)
+  if (n != m)
     q = p; p = zeros (n+1, 1); 
     p(polymask) = q;
   endif
   
   if (nargout > 1)
     yf = v*p;
 
     if (y_is_row_vector)
@@ -132,22 +132,22 @@ function [p, s, mu] = polyfit (x, y, n)
 
     ## r.'*r is positive definite if X(:, polymask) is of full rank.
     ## Invert it by cholinv to avoid taking the square root of squared
     ## quantities. If cholinv fails, then X(:, polymask) is rank
     ## deficient and not invertible.
     try
       C = cholinv (r.'*r)(k, k);
     catch
-      C = NaN * ones (m+1, m+1);
+      C = NaN (m+1, m+1);
     end_try_catch
 
-    if (n ~= m)
+    if (n != m)
       ## fill matrices if required
-      s.X(:, ~polymask) = 0;
+      s.X(:, !polymask) = 0;
       s.R = zeros (n+1, n+1); s.R(polymask, polymask) = r;
       s.C = zeros (n+1, n+1); s.C(polymask, polymask) = C;
     else
       s.R = r; 
       s.C = C;
     endif
     s.df = l - m - 1;
     s.normr = norm (yf - y);
@@ -166,20 +166,20 @@ endfunction
 %!fail ("polyfit (x, x.^2+x+1)")
 %!fail ("polyfit (x, x.^2+x+1, [])")
 
 ## Test difficult case where scaling is really needed. This example
 ## demonstrates the rather poor result which occurs when the dependent
 ## variable is not normalized properly.
 ## Also check the usage of 2nd & 3rd output arguments.
 %!test
-%! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, \
+%! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, ...
 %!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
-%! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966,    \
-%!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201,    \
+%! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966, ...
+%!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201, ...
 %!       315600.7143, 315602.9508, 315605.1765 ];
 %! [p1, s1] = polyfit (x, y, 10);
 %! [p2, s2, mu] = polyfit (x, y, 10);
 %! assert (s2.normr < s1.normr);
 
 %!test
 %! x = 1:4;
 %! p0 = [1i, 0, 2i, 4];
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -27,17 +27,17 @@
 ## @ifnottex
 ##
 ## @example
 ## c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ##
 ## @end ifnottex
 ## and return it as a string or write it to the screen (if @var{nargout} is
-## zero).  @var{x} defaults to the string @code{"s"}.
+## zero).  @var{x} defaults to the string @qcode{"s"}.
 ## @seealso{polyreduce}
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -90,17 +90,17 @@ function yi = ppval (pp, xi)
   endif
 
   if (isvector (xi) && (d == 1))
     yi = reshape (yi, sxi);
   elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
     yi = shiftdim (yi, nd);
   endif
 
-  ##
+  ## FIXME: Why is this commented out, rather than just removed?
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
 
 endfunction
 
 
 %!shared b, c, pp, pp2, xi, abserr
@@ -122,8 +122,9 @@ endfunction
 %!test
 %! breaks = [0, 1, 2, 3];
 %! coefs = rand (6, 4);
 %! pp = mkpp (breaks, coefs, 2);
 %! ret = zeros (2, 4, 2);
 %! ret(:,:,1) = ppval (pp, breaks');
 %! ret(:,:,2) = ppval (pp, breaks');
 %! assert (ppval (pp, [breaks',breaks']), ret)
+
diff --git a/scripts/polynomial/private/__splinefit__.m b/scripts/polynomial/private/__splinefit__.m
--- a/scripts/polynomial/private/__splinefit__.m
+++ b/scripts/polynomial/private/__splinefit__.m
@@ -382,17 +382,17 @@ else
     % Reshape array
     yc = reshape(yc,pdim,nx);
 end
 
 % Check cc
 if isempty(cc)
     cc = ones(size(xc));
 elseif numel(size(cc)) ~= 2
-    error('arguments:ccsize1','Constraint coefficients cc must be 2D.')
+    error('arguments:ccsize1','Constraint coefficients cc must be 2-D.')
 elseif size(cc,2) ~= nx
     mess = 'Last dimension of cc must equal length of xc.';
     error('arguments:ccsize2',mess)
 end
 
 % Check high order derivatives
 if size(cc,1) >= n
     if any(any(cc(n:end,:)))
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -155,17 +155,17 @@ function [r, p, k, e] = residue (b, a, v
     if (nargin >= 4)
       e = varargin{2};
     else
       e = [];
     endif
     ## The inputs are the residue, pole, and direct part. Solve for the
     ## corresponding numerator and denominator polynomials
     [r, p] = rresidue (b, a, varargin{1}, toler, e);
-    return
+    return;
   endif
 
   ## Make sure both polynomials are in reduced form.
 
   a = polyreduce (a);
   b = polyreduce (b);
 
   b = b / a(1);
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -76,17 +76,17 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
   if (nargin != 1 || (! isvector (v) && ! isempty (v)))
     print_usage ();
-  elseif (any (isnan (v) | isinf (v)))
+  elseif (any (! isfinite (v)))
     error ("roots: inputs must not contain Inf or NaN");
   endif
 
   v = v(:);
   n = numel (v);
 
   ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ],
   ## we can remove the leading k zeros,
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -54,28 +54,28 @@
 ## deficiency.
 ##
 ## The splines are constructed of polynomials with degree @var{order}.
 ## The default is a cubic, @var{order}=3.  A spline with P pieces has
 ## P+@var{order} degrees of freedom.  With periodic boundary conditions
 ## the degrees of freedom are reduced to P.
 ##
 ## The optional property, @var{constaints}, is a structure specifying
-## linear constraints on the fit.  The structure has three fields, "xc",
-## "yc", and "cc".
+## linear constraints on the fit.  The structure has three fields, @qcode{"xc"},
+## @qcode{"yc"}, and @qcode{"cc"}.
 ##
 ## @table @asis
-## @item "xc"
+## @item @qcode{"xc"}
 ## Vector of the x-locations of the constraints.
 ##
-## @item "yc"
+## @item @qcode{"yc"}
 ## Constraining values at the locations @var{xc}.
 ## The default is an array of zeros.
 ##
-## @item "cc"
+## @item @qcode{"cc"}
 ## Coefficients (matrix).  The default is an array of ones.  The number of
 ## rows is limited to the order of the piecewise polynomials, @var{order}.
 ## @end table
 ##
 ## Constraints are linear combinations of derivatives of order 0 to
 ## @var{order}-1 according to
 ##
 ## @example
@@ -89,17 +89,17 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{interp1, unmkpp, ppval, spline, pchip, ppder, ppint, ppjumps}
 ## @end deftypefn
 
 function pp = splinefit (x, y, breaks, varargin)
   if (nargin > 3)
-    n = cellfun (@ischar, varargin, "uniformoutput", true);
+    n = cellfun ("isclass", varargin, "char");
     varargin(n) = lower (varargin(n));
     try
       props = struct (varargin{:});
     catch
       print_usage ();
     end_try_catch
   else
     props = struct ();
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -64,11 +64,13 @@ function addpref (group, pref, val)
       error ("expecting group to be a character string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -85,11 +85,13 @@ function retval = getpref (group, pref, 
       error ("expecting pref to be a character string or cellstr");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/ispref.m b/scripts/prefs/ispref.m
--- a/scripts/prefs/ispref.m
+++ b/scripts/prefs/ispref.m
@@ -50,11 +50,13 @@ function retval = ispref (group, pref)
       retval = false;
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/module.mk b/scripts/prefs/module.mk
--- a/scripts/prefs/module.mk
+++ b/scripts/prefs/module.mk
@@ -4,16 +4,18 @@ prefs_PRIVATE_FCN_FILES = \
   prefs/private/loadprefs.m \
   prefs/private/prefsfile.m \
   prefs/private/saveprefs.m
 
 prefs_FCN_FILES = \
   prefs/addpref.m \
   prefs/getpref.m \
   prefs/ispref.m \
+  prefs/prefdir.m \
+  prefs/preferences.m \
   prefs/rmpref.m \
   prefs/setpref.m \
   $(prefs_PRIVATE_FCN_FILES)
 
 FCN_FILES += $(prefs_FCN_FILES)
 
 PKG_ADD_FILES += prefs/PKG_ADD
 
diff --git a/scripts/prefs/prefdir.m b/scripts/prefs/prefdir.m
new file mode 100644
--- /dev/null
+++ b/scripts/prefs/prefdir.m
@@ -0,0 +1,48 @@
+## Copyright (C) 2013 John Donoghue
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Command} {} prefdir 
+## @deftypefnx {Command} {@var{dir} =} prefdir 
+## Return the directory that contains the preferences for Octave.
+##
+## Examples:
+##
+## Display the preferences directory
+##
+## @example
+## prefdir
+## @end example
+##
+## Change to the preferences folder
+##
+## @example
+## cd (prefdir)
+## @end example
+## @seealso{getpref, setpref, addpref, rmpref, ispref}
+## @end deftypefn
+
+## Author: John Donoghue
+## Version: 0.01
+
+function folder = prefdir ()
+
+  folder = getenv ("HOME");
+
+endfunction
+
diff --git a/scripts/prefs/preferences.m b/scripts/prefs/preferences.m
new file mode 100644
--- /dev/null
+++ b/scripts/prefs/preferences.m
@@ -0,0 +1,34 @@
+## Copyright (C) 2013 John Donoghue
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Command} {} preferences 
+## Display the GUI preferences dialog window for Octave.
+## @end deftypefn
+
+## Author: John Donoghue
+## Version: 0.01
+
+function preferences ()
+  if (isguirunning ())
+    __octave_link_show_preferences__ ();
+  else
+    warning ("preferences: GUI must be running to use preferences dialog");
+  endif
+endfunction
+
diff --git a/scripts/prefs/private/loadprefs.m b/scripts/prefs/private/loadprefs.m
--- a/scripts/prefs/private/loadprefs.m
+++ b/scripts/prefs/private/loadprefs.m
@@ -33,11 +33,13 @@ function retval = loadprefs ()
     tmp = load (file);
     retval= tmp.prefs;
   else
     retval = [];
   endif
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/private/prefsfile.m b/scripts/prefs/private/prefsfile.m
--- a/scripts/prefs/private/prefsfile.m
+++ b/scripts/prefs/private/prefsfile.m
@@ -20,15 +20,17 @@
 ## @deftypefn {Function File} {} prefsfile ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = prefsfile ()
 
-  retval = "~/.octave_prefs";
+  retval = [prefdir() filesep() ".octave_prefs"];
+  
+endfunction
 
-endfunction
 
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/private/saveprefs.m b/scripts/prefs/private/saveprefs.m
--- a/scripts/prefs/private/saveprefs.m
+++ b/scripts/prefs/private/saveprefs.m
@@ -26,11 +26,13 @@
 function retval = saveprefs (s)
 
   prefs = s;
 
   save (prefsfile (), "prefs");
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -57,11 +57,13 @@ function setpref (group, pref, val)
       error ("expecting group to be a character string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %% Testing these functions will require some care to avoid wiping out
 %% existing (or creating unwanted) preferences for the user running the
 %% tests.
+
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -55,29 +55,29 @@ function [c, ia, ib] = intersect (a, b, 
     if (nargin > 2)
       c = [a; b];
       [c, ic] = sortrows (c);
       ii = find (all (c(1:end-1,:) == c(2:end,:), 2));
       c = c(ii,:);
       len_a = rows (a);
     else
       c = [a(:); b(:)];
-      [c, ic] = sort (c);               ## [a(:);b(:)](ic) == c
+      [c, ic] = sort (c);               # [a(:);b(:)](ic) == c
       if (iscellstr (c))
         ii = find (strcmp (c(1:end-1), c(2:end)));
       else
         ii = find (c(1:end-1) == c(2:end));
       endif
       c = c(ii);
       len_a = length (a);
     endif
 
     if (nargout > 1)
-      ia = ja(ic(ii));                  ## a(ia) == c
-      ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
+      ia = ja(ic(ii));                  # a(ia) == c
+      ib = jb(ic(ii+1) - len_a);        # b(ib) == c
     endif
 
     if (nargin == 2 && (rows (b) == 1 || rows (a) == 1))
       c = c.';
     endif
   endif
 
 endfunction
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -43,17 +43,17 @@
 ## a = @{"abc"@};
 ## s = @{"abc", "def"@};
 ## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
-## With the optional third argument @code{"rows"}, and matrices
+## With the optional third argument @qcode{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
 ## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
 ## [tf, s_idx] = ismember (a, s, "rows")
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} powerset (@var{a})
 ## @deftypefnx {Function File} {} powerset (@var{a}, "rows")
 ## Compute the powerset (all subsets) of the set @var{a}.
 ##
 ## The set @var{a} must be a numerical matrix or a cell array of strings.  The
 ## output will always be a cell array of either vectors or strings.
 ##
-## With the optional second argument @code{"rows"}, each row of the set @var{a}
+## With the optional second argument @qcode{"rows"}, each row of the set @var{a}
 ## is considered one element of the set.  As a result, @var{a} must then be a
 ## numerical 2-D matrix.
 ##
 ## @seealso{unique, union, setxor, setdiff, ismember}
 ## @end deftypefn
 
 function p = powerset (a, byrows_arg)
 
diff --git a/scripts/set/private/validargs.m b/scripts/set/private/validargs.m
--- a/scripts/set/private/validargs.m
+++ b/scripts/set/private/validargs.m
@@ -50,8 +50,9 @@ function [x, y] = validargs (caller, x, 
     else
       error ("%s: invalid option: %s", caller, byrows_arg);
     endif
   else
     print_usage (caller);
   endif
 
 endfunction
+
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -21,17 +21,17 @@
 ## @deftypefn  {Function File} {} setdiff (@var{a}, @var{b})
 ## @deftypefnx {Function File} {} setdiff (@var{a}, @var{b}, "rows")
 ## @deftypefnx {Function File} {[@var{c}, @var{i}] =} setdiff (@var{a}, @var{b})
 ## Return the elements in @var{a} that are not in @var{b}, sorted in
 ## ascending order.  If @var{a} and @var{b} are both column vectors
 ## return a column vector, otherwise return a row vector.
 ## @var{a}, @var{b} may be cell arrays of string(s).
 ##
-## Given the optional third argument @samp{"rows"}, return the rows in
+## Given the optional third argument @qcode{"rows"}, return the rows in
 ## @var{a} that are not in @var{b}, sorted in ascending order by rows.
 ##
 ## If requested, return @var{i} such that @code{c = a(i)}.
 ## @seealso{unique, union, intersect, setxor, ismember}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Adapted-by: jwe
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -28,19 +28,19 @@
 ##
 ## @example
 ## @group
 ## union ([1, 2, 4], [2, 3, 5])
 ##     @result{} [1, 2, 3, 4, 5]
 ## @end group
 ## @end example
 ##
-## If the optional third input argument is the string "rows" then each row of
-## the matrices @var{a} and @var{b} will be considered as a single set element.
-## For example:
+## If the optional third input argument is the string @qcode{"rows"} then
+## each row of the matrices @var{a} and @var{b} will be considered as a
+## single set element.  For example:
 ##
 ## @example
 ## @group
 ## union ([1, 2; 2, 3], [1, 2; 3, 4], "rows")
 ##    @result{}  1   2
 ##        2   3
 ##        3   4
 ## @end group
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -24,26 +24,26 @@
 ## @deftypefnx {Function File} {} unique (@dots{}, "last")
 ## @deftypefnx {Function File} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
 ## Return the unique elements of @var{x}, sorted in ascending order.
 ## If the input @var{x} is a vector then the output is also a vector with the
 ## same orientation (row or column) as the input.  For a matrix input the
 ## output is always a column vector.  @var{x} may also be a cell array of
 ## strings.
 ##
-## If the optional argument @code{"rows"} is supplied, return the unique
+## If the optional argument @qcode{"rows"} is supplied, return the unique
 ## rows of @var{x}, sorted in ascending order.
 ##
 ## If requested, return index vectors @var{i} and @var{j} such that
 ## @code{x(i)==y} and @code{y(j)==x}.
 ##
-## Additionally, if @var{i} is a requested output then one of @code{"first"} or
-## @code{"last"} may be given as an input.  If @code{"last"} is specified,
-## return the highest possible indices in @var{i}, otherwise, if @code{"first"}
-## is specified, return the lowest.  The default is @code{"last"}.
+## Additionally, if @var{i} is a requested output then one of @qcode{"first"} or
+## @qcode{"last"} may be given as an input.  If @qcode{"last"} is specified,
+## return the highest possible indices in @var{i}, otherwise, if @qcode{"first"}
+## is specified, return the lowest.  The default is @qcode{"last"}.
 ## @seealso{union, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
 
 function [y, i, j] = unique (x, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
@@ -216,8 +216,9 @@ endfunction
 %! assert (a, [1,2,3]);
 %! assert (A(i,:), a);
 %! assert (a(j,:), A);
 
 %!error unique({"a", "b", "c"}, "UnknownOption")
 %!error unique({"a", "b", "c"}, "UnknownOption1", "UnknownOption2")
 %!error unique({"a", "b", "c"}, "rows", "UnknownOption2")
 %!error unique({"a", "b", "c"}, "UnknownOption1", "last")
+
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -111,8 +111,9 @@ function [a, b] = arch_fit (y, x, p, ite
     h   = Z * a;
     f   = esq ./ h - ones (T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
     a   = a + gamma * delta_a;
   endfor
 
 endfunction
+
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -95,8 +95,9 @@ function y = arch_rnd (a, b, t)
       e(t) = sqrt (h(t)) * randn;
       y(t) = b(1) + b(2:lb) * y(t-tb+1:t-1) + e(t);
     endfor
   endif
 
   y = y(1:t);
 
 endfunction
+
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -89,8 +89,9 @@ function [pval, lm] = arch_test (y, x, p
   [b, v_b, e] = ols (y, x);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chi2cdf (lm, p);
 
 endfunction
+
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -74,8 +74,9 @@ function x = arma_rnd (a, b, v, t, n)
   n = min (n, ar + br);
 
   e = sqrt (v) * randn (t + n, 1);
 
   x = filter (b, a, e);
   x = x(n + 1 : t + n);
 
 endfunction
+
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -23,18 +23,19 @@
 ##
 ## If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
 ## for each column in @var{x}.
 ##
 ## The second argument is optional.  If it is not specified, a value of 1
 ## is assumed.  This corresponds to removing a linear trend.
 ##
 ## The order of the polynomial can also be given as a string, in which case
-## @var{p} must be either @t{"constant"} (corresponds to @code{@var{p}=0}) or
-## @t{"linear"} (corresponds to @code{@var{p}=1}).
+## @var{p} must be either @qcode{"constant"} (corresponds to
+## @code{@var{p}=0}) or
+## @qcode{"linear"} (corresponds to @code{@var{p}=1}).
 ## @seealso{polyfit}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 October 1994
 ## Adapted-By: jwe
 
 function y = detrend (x, p = 1)
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -86,8 +86,9 @@ function [newphi, newv] = durbinlevinson
       oldv = newv;
       oldphi = newphi;
 
     endfor
 
   endif
 
 endfunction
+
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -62,46 +62,46 @@ function c = fftconv (x, y, n)
     endif
   endif
 
 endfunction
 
 
 %% FIXME: Borrow tests from conv.m.  May need a tolerance on the assert comparison
 %!test
-%!  x = ones (3,1);
-%!  y = ones (1,3);
-%!  b = 2;
-%!  c = 3;
-%!  assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
-%!  assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
-%!  assert (fftconv (x, y), [1, 2, 3, 2, 1], 5*eps);
-%!  assert (fftconv (y, x), [1; 2; 3; 2; 1], 5*eps);
-%!  assert (fftconv (c, x), [3; 3; 3], 5*eps);
-%!  assert (fftconv (c, y), [3, 3, 3], 5*eps);
-%!  assert (fftconv (x, c), [3; 3; 3], 5*eps);
-%!  assert (fftconv (y, c), [3, 3, 3], 5*eps);
-%!  assert (fftconv (b, c), 6, 5*eps);
+%! x = ones (3,1);
+%! y = ones (1,3);
+%! b = 2;
+%! c = 3;
+%! assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
+%! assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
+%! assert (fftconv (x, y), [1, 2, 3, 2, 1], 5*eps);
+%! assert (fftconv (y, x), [1; 2; 3; 2; 1], 5*eps);
+%! assert (fftconv (c, x), [3; 3; 3], 5*eps);
+%! assert (fftconv (c, y), [3, 3, 3], 5*eps);
+%! assert (fftconv (x, c), [3; 3; 3], 5*eps);
+%! assert (fftconv (y, c), [3, 3, 3], 5*eps);
+%! assert (fftconv (b, c), 6, 5*eps);
 
 %!test
-%!  a = 1:10;
-%!  b = 1:3;
-%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
+%! a = 1:10;
+%! b = 1:3;
+%! assert (size (conv (a,b)), [1, numel(a)+numel(b)-1]);
+%! assert (size (conv (b,a)), [1, numel(a)+numel(b)-1]);
 
-%!  a = (1:10).';
-%!  b = 1:3;
-%!  assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
-%!  assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])
+%! a = (1:10).';
+%! b = 1:3;
+%! assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1]);
+%! assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1]);
 
 %!test
-%!  a = 1:10;
-%!  b = (1:3).';
-%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
+%! a = 1:10;
+%! b = (1:3).';
+%! assert (size (conv (a,b)), [1, numel(a)+numel(b)-1]);
+%! assert (size (conv (b,a)), [1, numel(a)+numel(b)-1]);
 
 %% Test input validation
 %!error fftconv (1)
 %!error fftconv (1,2,3,4)
 %!error fftconv ([1, 2; 3, 4], 3)
 %!error fftconv (2, [])
 %!error fftconv ([1,1], [2,2] , [3, 4])
 
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -18,17 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fftfilt (@var{b}, @var{x}, @var{n})
 ##
 ## With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
 ## @var{b} using the FFT.
 ##
 ## Given the optional third argument, @var{n}, @code{fftfilt} uses the
-## overlap-add method to filter @var{x} with @var{b} using an N-point FFT.
+## overlap-add method to filter @var{x} with @var{b} using an @var{n}-point
+## FFT@.  The FFT size must be an even power of 2 and must be greater than
+## or equal to the length of @var{b}.  If the specified @var{n} does not
+## meet these criteria, it is automatically adjusted to the nearest value
+## that does.
 ##
 ## If @var{x} is a matrix, filter each column of the matrix.
 ## @seealso{filter, filter2}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
@@ -132,17 +136,17 @@ endfunction
 %!test
 %! b = [1 1];
 %! x = [1, zeros(1,9)];
 %! assert (fftfilt (b,  x  ), [1 1 0 0 0 0 0 0 0 0]  );
 %! assert (fftfilt (b,  x.'), [1 1 0 0 0 0 0 0 0 0].');
 %! assert (fftfilt (b.',x  ), [1 1 0 0 0 0 0 0 0 0]  );
 %! assert (fftfilt (b.',x.'), [1 1 0 0 0 0 0 0 0 0].');
 %! assert (fftfilt (b,  [x.' x.']), [1 1 0 0 0 0 0 0 0 0].'*[1 1]);
-%! assert (fftfilt (b,  [x.'+eps x.']) == [1 1 0 0 0 0 0 0 0 0].'*[1 1], [false(10, 1) true(10, 1)]);
+%! assert (fftfilt (b,  [x.'+2*eps x.']) == [1 1 0 0 0 0 0 0 0 0].'*[1 1], [false(10, 1) true(10, 1)]);
 
 %!test
 %! r = sqrt (1/2) * (1+i);
 %! b = b*r;
 %! assert (fftfilt (b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps  );
 %! assert (fftfilt (b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], 2*eps);
 %! assert (fftfilt (b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps  );
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -80,52 +80,52 @@ function retval = fftshift (x, dim)
       error ("fftshift: expecting vector or matrix argument");
     endif
   endif
 
 endfunction
 
 
 %!test
-%!  x = [0:7];
-%!  y = fftshift (x);
-%!  assert (y, [4 5 6 7 0 1 2 3]);
-%!  assert (fftshift (y), x);
+%! x = [0:7];
+%! y = fftshift (x);
+%! assert (y, [4 5 6 7 0 1 2 3]);
+%! assert (fftshift (y), x);
 
 %!test
-%!  x = [0:6];
-%!  y = fftshift (x);
-%!  assert (y, [4 5 6 0 1 2 3]);
-%!  assert (fftshift (y), [1 2 3 4 5 6 0]);
+%! x = [0:6];
+%! y = fftshift (x);
+%! assert (y, [4 5 6 0 1 2 3]);
+%! assert (fftshift (y), [1 2 3 4 5 6 0]);
 
 %!test
-%!  x = [0:7]';
-%!  y = fftshift (x);
-%!  assert (y, [4;5;6;7;0;1;2;3]);
-%!  assert (fftshift (y), x);
+%! x = [0:7]';
+%! y = fftshift (x);
+%! assert (y, [4;5;6;7;0;1;2;3]);
+%! assert (fftshift (y), x);
 
 %!test
-%!  x = [0:6]';
-%!  y = fftshift (x);
-%!  assert (y, [4;5;6;0;1;2;3]);
-%!  assert (fftshift (y), [1;2;3;4;5;6;0]);
+%! x = [0:6]';
+%! y = fftshift (x);
+%! assert (y, [4;5;6;0;1;2;3]);
+%! assert (fftshift (y), [1;2;3;4;5;6;0]);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = fftshift (x);
-%!  assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
-%!  assert (fftshift (y), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = fftshift (x);
+%! assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
+%! assert (fftshift (y), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = fftshift (x,1);
-%!  assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
-%!  assert (fftshift (y,1), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = fftshift (x,1);
+%! assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
+%! assert (fftshift (y,1), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = fftshift (x,2);
-%!  assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
-%!  assert (fftshift (y,2), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = fftshift (x,2);
+%! assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
+%! assert (fftshift (y,2), x);
 
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -19,23 +19,23 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
 ## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
 ## @var{shape} is specified, return an array of the desired shape.
 ## Possible values are:
 ##
 ## @table @asis
-## @item "full"
+## @item @qcode{"full"}
 ## pad @var{x} with zeros on all sides before filtering.
 ##
-## @item "same"
+## @item @qcode{"same"}
 ## unpadded @var{x} (default)
 ##
-## @item "valid"
+## @item @qcode{"valid"}
 ## trim @var{x} after filtering so edge effects are no included.
 ## @end table
 ##
 ## Note this is just a variation on convolution, with the parameters
 ## reversed and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -62,8 +62,9 @@ function retval = fractdiff (x, d)
     endif
 
   else
     error ("fractdiff: D must be > -1");
 
   endif
 
 endfunction
+
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -39,18 +39,18 @@
 ## If @var{a} is omitted, the denominator is assumed to be 1 (this
 ## corresponds to a simple FIR filter).
 ##
 ## If @var{n} is omitted, a value of 512 is assumed.
 ##
 ## For fastest computation, @var{n} should factor into a small number of
 ## small primes.
 ##
-## If the fourth argument, "whole", is omitted the response is evaluated at
-## frequencies between 0 and
+## If the fourth argument, @qcode{"whole"}, is omitted the response is
+## evaluated at frequencies between 0 and
 ## @ifnottex
 ##  pi.
 ## @end ifnottex
 ## @tex
 ##  $\pi$.
 ## @end tex
 ##
 ## @code{freqz (@var{b}, @var{a}, @var{w})}
@@ -173,17 +173,17 @@ function [h_r, f_r] = freqz (b, a, n, re
     ## Plot and don't return values.
     freqz_plot (f, h);
   endif
 
 endfunction
 
 
 %!test # correct values and fft-polyval consistency
-%! # butterworth filter, order 2, cutoff pi/2 radians
+%! ## butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
 %! [h,w] = freqz (b,a,32);
 %! assert (h(1),1,10*eps);
 %! assert (abs (h(17)).^2,0.5,10*eps);
 %! assert (h,freqz (b,a,w),10*eps); # fft should be consistent with polyval
 
 %!test # whole-half consistency
@@ -198,8 +198,9 @@ endfunction
 %! b = [1 1 1]/3; a = [1 0.2];
 %! [h,f] = freqz (b,a,16,320);
 %! assert (f,[0:15]'*10,10*eps);
 %! [h2,f2] = freqz (b,a,[0:15]*10,320);
 %! assert (f2,[0:15]*10,10*eps);
 %! assert (h,h2.',20*eps);
 %! [h3,f3] = freqz (b,a,32,"whole",320);
 %! assert (f3,[0:31]'*10,10*eps);
+
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -59,8 +59,9 @@ function freqz_plot (w, h)
   subplot (3, 1, 3);
   plot (w, phase*360/(2*pi));
   grid ("on");
   legend ("Phase (degrees)");
   xlabel ("Frequency");
   axis ([w(1), w(n)], "autoy", "label");
 
 endfunction
+
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -41,8 +41,9 @@ function H = hurst (x)
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
   RS = (max (w) - min (w)) ./ s;
   H = log (RS) / log (xr);
 
 endfunction
+
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -29,29 +29,30 @@
 ## [Pxx,w] = periodogram (@var{x},win,nfft).
 ##
 ## [Pxx,f] = periodogram (@var{x},win,nfft,Fs).
 ##
 ## [Pxx,f] = periodogram (@var{x},win,nfft,Fs,"range").
 ##
 ## @itemize
 ## @item x: data; if real-valued a one-sided spectrum is estimated,
-## if complex-valued or range indicates "@nospell{twosided}", the full
+## if complex-valued or range indicates @qcode{"@nospell{twosided}"}, the full
 ## spectrum is estimated.
 ##
 ## @item win: weight data with window, x.*win is used for further computation,
 ## if window is empty, a rectangular window is used.
 ##
 ## @item nfft: number of frequency bins, default max (256, 2.^ceil (log2 (length (x)))).
 ##
 ## @item Fs: sampling rate, default 1.
 ##
-## @item range: "@nospell{onesided}" computes spectrum from [0..nfft/2+1].
-## "@nospell{twosided}" computes spectrum from [0..nfft-1].  These strings
-## can appear at any position in the list input arguments after window.
+## @item range: @qcode{"@nospell{onesided}"} computes spectrum from [0..nfft/2+1].
+## @qcode{"@nospell{twosided}"} computes spectrum from [0..nfft-1].  These
+## strings can appear at any position in the list input arguments after
+## window.
 ##
 ## @item @nospell{Pxx}: one-, or two-sided power spectrum.
 ##
 ## @item w: angular frequency [0..2*pi) (two-sided) or [0..pi] one-sided.
 ##
 ## @item f: frequency [0..Fs) (two-sided) or [0..Fs/2] one-sided.
 ## @end itemize
 ## @end deftypefn
@@ -69,24 +70,24 @@ function [pxx, f] = periodogram (x, vara
 
   nfft = []; fs = []; range = []; window = [];
   j = 1;
   for k = 1:length (varargin)
     if (ischar (varargin{k}))
       range = varargin{k};
     else
       switch (j)
-      case 1
-        window = varargin{k};
-      case 2
-        nfft   = varargin{k};
-      case 3
-        fs     = varargin{k};
-      case 4
-        range  = varargin{k};
+        case 1
+          window = varargin{k};
+        case 2
+          nfft   = varargin{k};
+        case 3
+          fs     = varargin{k};
+        case 4
+          range  = varargin{k};
       endswitch
       j++;
     endif
   endfor
 
   [r, c] = size (x);
   if (r == 1)
     r = c;
@@ -183,8 +184,9 @@ function [pxx, f] = periodogram (x, vara
     endif
     grid on;
     title ("Periodogram Power Spectral Density Estimate");
   else
     pxx = Pxx;
   endif
 
 endfunction
+
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -22,18 +22,15 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular lag window
 
 function retval = rectangle_lw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n, 1);
   t = floor (1 / b);
 
   retval(1:t, 1) = ones (t, 1);
 
 endfunction
+
diff --git a/scripts/signal/private/rectangle_sw.m b/scripts/signal/private/rectangle_sw.m
--- a/scripts/signal/private/rectangle_sw.m
+++ b/scripts/signal/private/rectangle_sw.m
@@ -22,51 +22,18 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Rectangular spectral window
 
 function retval = rectangle_sw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n, 1);
   retval(1) = 2 / b + 1;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = sin ((2/b + 1) * l / 2) ./ sin (l / 2);
 
 endfunction
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/scripts/signal/private/triangle_lw.m b/scripts/signal/private/triangle_lw.m
--- a/scripts/signal/private/triangle_lw.m
+++ b/scripts/signal/private/triangle_lw.m
@@ -22,17 +22,13 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular lag window
 
 function retval = triangle_lw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = 1 - (0 : n-1)' * b;
   retval = max ([retval'; (zeros (1, n))])';
 
 endfunction
 
diff --git a/scripts/signal/private/triangle_sw.m b/scripts/signal/private/triangle_sw.m
--- a/scripts/signal/private/triangle_sw.m
+++ b/scripts/signal/private/triangle_sw.m
@@ -22,51 +22,18 @@
 ## estimation.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Triangular spectral window
 
 function retval = triangle_sw (n, b)
 
-  if (nargin != 2)
-    print_usage ();
-  endif
-
   retval = zeros (n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2)).^2;
 
 endfunction
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -12,54 +12,66 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} spectral_adf (@var{c}, @var{win}, @var{b})
+## @deftypefn  {Function File} {} spectral_adf (@var{c})
+## @deftypefnx {Function File} {} spectral_adf (@var{c}, @var{win})
+## @deftypefnx {Function File} {} spectral_adf (@var{c}, @var{win}, @var{b})
 ## Return the spectral density estimator given a vector of
 ## autocovariances @var{c}, window name @var{win}, and bandwidth,
 ## @var{b}.
 ##
-## The window name, e.g., @code{"triangle"} or @code{"rectangle"} is
-## used to search for a function called @code{@var{win}_sw}.
+## The window name, e.g., @qcode{"triangle"} or @qcode{"rectangle"} is
+## used to search for a function called @code{@var{win}_lw}.
 ##
 ## If @var{win} is omitted, the triangle window is used.  If @var{b} is
 ## omitted, @code{1 / sqrt (length (@var{x}))} is used.
+## @seealso{spectral_xdf}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
 function retval = spectral_adf (c, win, b)
 
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  endif
+
   cr = length (c);
 
   if (columns (c) > 1)
     c = c';
   endif
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (cr));
   endif
 
   if (nargin == 1)
     w = triangle_lw (cr, b);
+  elseif (! ischar (win))
+    error ("spectral_adf: WIN must be a string");
   else
-    win = str2func (cstrcat (win, "_lw"));
+    win = str2func ([win "_lw"]);
     w = feval (win, cr, b);
   endif
 
   c = c .* w;
 
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
 
 endfunction
 
 
-
+%% Test input validation
+%!error spectral_adf ();
+%!error spectral_adf (1, 2, 3, 4);
+%!error spectral_adf (1, 2);
+%!error spectral_adf (1, "invalid");
 
-
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -12,51 +12,67 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} spectral_xdf (@var{x}, @var{win}, @var{b})
+## @deftypefn  {Function File} {} spectral_xdf (@var{x})
+## @deftypefnx {Function File} {} spectral_xdf (@var{x}, @var{win})
+## @deftypefnx {Function File} {} spectral_xdf (@var{x}, @var{win}, @var{b})
 ## Return the spectral density estimator given a data vector @var{x},
 ## window name @var{win}, and bandwidth, @var{b}.
 ##
-## The window name, e.g., @code{"triangle"} or @code{"rectangle"} is
+## The window name, e.g., @qcode{"triangle"} or @qcode{"rectangle"} is
 ## used to search for a function called @code{@var{win}_sw}.
 ##
 ## If @var{win} is omitted, the triangle window is used.  If @var{b} is
 ## omitted, @code{1 / sqrt (length (@var{x}))} is used.
+## @seealso{spectral_adf}
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
 function retval = spectral_xdf (x, win, b)
 
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  endif
+
   xr = length (x);
 
   if (columns (x) > 1)
     x = x';
   endif
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (xr));
   endif
 
   if (nargin == 1)
     w = triangle_sw (xr, b);
+  elseif (! ischar (win))
+    error ("spectral_xdf: WIN must be a string");
   else
-    win = str2func (cstrcat (win, "_sw"));
+    win = str2func ([win "_sw"]);
     w = feval (win, xr, b);
   endif
 
   x = x - sum (x) / xr;
 
   retval = (abs (fft (x)) / xr).^2;
   retval = real (ifft (fft (retval) .* fft (w)));
 
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
 
 endfunction
 
+
+%% Test input validation
+%!error spectral_xdf ();
+%!error spectral_xdf (1, 2, 3, 4);
+%!error spectral_xdf (1, 2);
+%!error spectral_xdf (1, "invalid");
+
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -127,8 +127,9 @@ function [y, c] = stft (x, win_size, inc
 
   if (nargout == 1)
     y = abs (y(1:num_coef, :));
   else
     c = [win_size, inc, win_type];
   endif
 
 endfunction
+
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -65,8 +65,9 @@ function x = synthesis (y, c)
   nc = columns (z);
   for i = 1:nc
     z(:, i) = z(:, i) ./ w_coeff;
   endfor
 
   x = reshape (z, inc * nc, 1);
 
 endfunction
+
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -50,11 +50,8 @@ function [a, v] = yulewalker (c)
   endfor
 
   a = inv (CP) * cp;
   v = c(1) - a' * cp;
 
 endfunction
 
 
-
-
-
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -228,21 +228,21 @@ endfunction;
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!function y = afun (x, t, a)
-%!  switch t
-%!   case "notransp"
-%!     y = a * x;
-%!   case "transp"
-%!     y = a' * x;
+%!  switch (t)
+%!    case "notransp"
+%!      y = a * x;
+%!    case "transp"
+%!      y = a' * x;
 %!  endswitch
 %!endfunction
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -140,17 +140,17 @@ function [x, flag, relres, iter, resvec]
 
     ## Vector of the residual norms for each iteration.
     resvec = norm (res) / norm_b;
 
     ## Default behaviour we don't reach tolerance tol within maxit iterations.
     flag = 1;
 
     for iter = 1:maxit
-      rho_1 = res' * rr;
+      rho_1 = rr' * res;
 
       if (iter == 1)
         p = res;
       else
         beta = (rho_1 / rho_2) * (alpha / omega);
         p = res + beta * (p - omega * v);
       endif
 
@@ -158,17 +158,17 @@ function [x, flag, relres, iter, resvec]
 
       v = Ax (phat);
       alpha = rho_1 / (rr' * v);
       s = res - alpha * v;
 
       shat = precon (s);
 
       t = Ax (shat);
-      omega = (t' * s) / (t' * t);
+      omega = (s' * t) / (t' * t);
       x = x + alpha * phat + omega * shat;
       res = s - omega * t;
       rho_2 = rho_1;
 
       relres = norm (res) / norm_b;
       resvec = [resvec; relres];
 
       if (relres <= tol)
@@ -243,8 +243,13 @@ endfunction
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
 
+%!test
+%! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
+%! b = A * [1; 1];
+%! [x, flag, relres, iter, resvec] = bicgstab (A, b);
+%! assert (x, [1; 1], 1e-6);
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -30,8 +30,9 @@ function p = colperm (s)
   if (nargin != 1)
     print_usage ();
   endif
 
   [i, j] = find (s);
   idx = find (diff ([j; Inf]) != 0);
   [dummy, p] = sort (idx - [0; idx(1:(end-1))]);
 endfunction
+
diff --git a/scripts/sparse/eigs.m b/scripts/sparse/eigs.m
new file mode 100644
--- /dev/null
+++ b/scripts/sparse/eigs.m
@@ -0,0 +1,1110 @@
+## Copyright (C) 2005-2012 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{d} =} eigs (@var{A})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{k})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma}, @var{opts})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{B})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{B}, @var{k})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{B})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{k})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})
+## @deftypefnx {Function File} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})
+## @deftypefnx {Function File} {[@var{V}, @var{d}] =} eigs (@var{A}, @dots{})
+## @deftypefnx {Function File} {[@var{V}, @var{d}] =} eigs (@var{af}, @var{n}, @dots{})
+## @deftypefnx {Function File} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{A}, @dots{})
+## @deftypefnx {Function File} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{af}, @var{n}, @dots{})
+## Calculate a limited number of eigenvalues and eigenvectors of @var{A},
+## based on a selection criteria.  The number of eigenvalues and eigenvectors to
+## calculate is given by @var{k} and defaults to 6.
+## 
+## By default, @code{eigs} solve the equation
+## @tex
+## $A \nu = \lambda \nu$,
+## @end tex
+## @ifinfo
+## @code{A * v = lambda * v},
+## @end ifinfo
+## where
+## @tex
+## $\lambda$ is a scalar representing one of the eigenvalues, and $\nu$
+## @end tex
+## @ifinfo
+## @code{lambda} is a scalar representing one of the eigenvalues, and @code{v}
+## @end ifinfo
+## is the corresponding eigenvector.  If given the positive definite matrix
+## @var{B} then @code{eigs} solves the general eigenvalue equation
+## @tex
+## $A \nu = \lambda B \nu$.
+## @end tex
+## @ifinfo
+## @code{A * v = lambda * B * v}.
+## @end ifinfo
+## 
+## The argument @var{sigma} determines which eigenvalues are returned.
+## @var{sigma} can be either a scalar or a string.  When @var{sigma} is a
+## scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If
+## @var{sigma} is a string, it must have one of the following values.
+## 
+## @table @asis
+## @item @qcode{"lm"}
+## Largest Magnitude (default).
+## 
+## @item @qcode{"sm"}
+## Smallest Magnitude.
+## 
+## @item @qcode{"la"}
+## Largest Algebraic (valid only for real symmetric problems).
+## 
+## @item @qcode{"sa"}
+## Smallest Algebraic (valid only for real symmetric problems).
+## 
+## @item @qcode{"be"}
+## Both Ends, with one more from the high-end if @var{k} is odd (valid only for
+## real symmetric problems).
+## 
+## @item @qcode{"lr"}
+## Largest Real part (valid only for complex or unsymmetric problems).
+## 
+## @item @qcode{"sr"}
+## Smallest Real part (valid only for complex or unsymmetric problems).
+## 
+## @item @qcode{"li"}
+## Largest Imaginary part (valid only for complex or unsymmetric problems).
+## 
+## @item @qcode{"si"}
+## Smallest Imaginary part (valid only for complex or unsymmetric problems).
+## @end table
+## 
+## If @var{opts} is given, it is a structure defining possible options that
+## @code{eigs} should use.  The fields of the @var{opts} structure are:
+## 
+## @table @code
+## @item issym
+## If @var{af} is given, then flags whether the function @var{af} defines a
+## symmetric problem.  It is ignored if @var{A} is given.  The default is false.
+## 
+## @item isreal
+## If @var{af} is given, then flags whether the function @var{af} defines a
+## real problem.  It is ignored if @var{A} is given.  The default is true.
+## 
+## @item tol
+## Defines the required convergence tolerance, calculated as
+## @code{tol * norm (A)}.  The default is @code{eps}.
+## 
+## @item maxit
+## The maximum number of iterations.  The default is 300.
+## 
+## @item p
+## The number of Lanzcos basis vectors to use.  More vectors will result in
+## faster convergence, but a greater use of memory.  The optimal value of
+## @code{p} is problem dependent and should be in the range @var{k} to @var{n}.
+## The default value is @code{2 * @var{k}}.
+## 
+## @item v0
+## The starting vector for the algorithm.  An initial vector close to the
+## final vector will speed up convergence.  The default is for @sc{arpack}
+## to randomly generate a starting vector.  If specified, @code{v0} must be
+## an @var{n}-by-1 vector where @code{@var{n} = rows (@var{A})}
+## 
+## @item disp
+## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then
+## diagnostics are disabled.  The default value is 0.
+## 
+## @item cholB
+## Flag if @code{chol (@var{B})} is passed rather than @var{B}.  The default is
+## false.
+## 
+## @item permB
+## The permutation vector of the Cholesky@tie{}factorization of @var{B} if
+## @code{cholB} is true.  That is @code{chol (@var{B}(permB, permB))}.  The
+## default is @code{1:@var{n}}.
+## 
+## @end table
+## 
+## It is also possible to represent @var{A} by a function denoted @var{af}.
+## @var{af} must be followed by a scalar argument @var{n} defining the length
+## of the vector argument accepted by @var{af}.  @var{af} can be
+## a function handle, an inline function, or a string.  When @var{af} is a
+## string it holds the name of the function to use.
+## 
+## @var{af} is a function of the form @code{y = af (x)}
+## where the required return value of @var{af} is determined by
+## the value of @var{sigma}.  The four possible forms are
+## 
+## @table @code
+## @item A * x
+## if @var{sigma} is not given or is a string other than "sm".
+## 
+## @item A \ x
+## if @var{sigma} is 0 or "sm".
+## 
+## @item (A - sigma * I) \ x
+## for the standard eigenvalue problem, where @code{I} is the identity matrix of
+## the same size as @var{A}.
+## 
+## @item (A - sigma * B) \ x
+## for the general eigenvalue problem.
+## @end table
+## 
+## The return arguments of @code{eigs} depend on the number of return arguments
+## requested.  With a single return argument, a vector @var{d} of length @var{k}
+## is returned containing the @var{k} eigenvalues that have been found.  With
+## two return arguments, @var{V} is a @var{n}-by-@var{k} matrix whose columns
+## are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The
+## eigenvalues themselves are returned in @var{d} in the form of a
+## @var{n}-by-@var{k} matrix, where the elements on the diagonal are the
+## eigenvalues.
+## 
+## Given a third return argument @var{flag}, @code{eigs} returns the status
+## of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.
+## Any other value indicates a failure to converge.
+## 
+## This function is based on the @sc{arpack} package, written by R. Lehoucq,
+## K. Maschhoff, D. Sorensen, and C. Yang.  For more information see
+## @url{http://www.caam.rice.edu/software/ARPACK/}.
+## 
+## @seealso{eig, svds}
+## @end deftypefn
+
+function varargout = eigs (varargin)
+
+  ## For compatibility with Matlab, handle small matrix cases here
+  ## that ARPACK does not.
+
+  if (nargin == 0)
+    print_usage ();
+  endif
+
+  call_eig = false;
+  offset = 0;
+  k = 6;
+  sigma = "lm";
+
+  if (isnumeric (varargin{1}) && issquare (varargin{1}))
+    a = varargin{1};
+    if (nargin > 1 && isnumeric (varargin{2})
+        && issquare (varargin{2}) && size_equal (a, varargin{2}))
+      b = varargin{2};
+      offset = 1;
+    endif
+
+    if (rows (a) < 9)
+      call_eig = true;
+    endif
+    
+    if (nargin > 1 + offset)
+      tmp = varargin{2+offset};
+      if (isnumeric (tmp) && isscalar (tmp) && isreal (tmp)
+          && round (tmp) == tmp)
+        k = tmp;
+
+        if (rows (a) - k < 3)
+          call_eig = true;
+        endif
+      else
+        call_eig = false;
+      endif
+
+      if (nargin > 2 + offset)
+        tmp = varargin{3+offset};
+        if (ischar (tmp) || (isnumeric (tmp) && isscalar (tmp)))
+          sigma = tmp;
+        else
+          call_eig = false;
+        endif
+      endif
+    endif
+  endif
+
+  if (call_eig)
+    varargout = cell (1, min (2, max (1, nargout)));
+    if (offset)
+      real_valued = isreal (a) && isreal (b);
+      symmetric = issymmetric (a) && issymmetric (b);
+      [varargout{:}] = eig (a, b);
+    else
+      real_valued = isreal (a);
+      symmetric = issymmetric (a);
+      [varargout{:}] = eig (a);
+    endif
+    varargout = select (varargout, k, sigma, real_valued, symmetric);
+    if (nargout == 3)
+      varargout{3} = 0;
+    endif
+  else
+    varargout = cell (1, max (1, nargout));
+    [varargout{:}] = __eigs__ (varargin{:});
+  endif
+
+endfunction
+
+function out = select (args, k, sigma, real_valued, symmetric)
+
+  if (numel (args) == 1)
+    d = args{1};
+  else
+    d = diag (args{2});
+  endif
+
+  if (ischar (sigma))
+    switch (sigma)
+      case "lm"
+        [~, idx] = sort (abs (d), "descend");
+
+      case "sm"
+        [~, idx] = sort (abs (d), "ascend");
+
+      case "la"
+        if (real_valued && symmetric)
+          [~, idx] = sort (real (d), "descend");
+        else
+          error ("sigma = \"la\" requires real symmetric problem");
+        endif
+
+      case "sa"
+        if (real_valued && symmetric)
+          [~, idx] = sort (real (d), "ascend");
+        else
+          error ("sigma = \"sa\" requires real symmetric problem");
+        endif
+
+      case "be"
+        if (real_valued && symmetric)
+          [~, idx] = sort (real (d), "ascend");
+        else
+          error ("sigma = \"be\" requires real symmetric problem");
+        endif
+
+      case "lr"
+        if (! (real_valued || symmetric))
+          [~, idx] = sort (real (d), "descend");
+        else
+          error ("sigma = \"lr\" requires complex or unsymmetric problem");
+        endif
+
+      case "sr"
+        if (! (real_valued || symmetric))
+          [~, idx] = sort (real (d), "ascend");
+        else
+          error ("sigma = \"sr\" requires complex or unsymmetric problem");
+        endif
+
+      case "li"
+        if (! (real_valued || symmetric))
+          [~, idx] = sort (imag (d), "descend");
+        else
+          error ("sigma = \"li\" requires complex or unsymmetric problem");
+        endif
+
+      case "si"
+        if (! (real_valued || symmetric))
+          [~, idx] = sort (imag (d), "ascend");
+        else
+          error ("sigma = \"si\" requires complex or unsymmetric problem");
+        endif
+
+      otherwise
+        error ("unrecognized value for sigma: %s", sigma);
+    endswitch
+  endif
+
+  d = d(idx);
+
+  n = numel (d);
+
+  k = min (k, n);
+
+  if (strcmp (sigma, 'be'))
+    tmp = k / 2;
+    n1 = floor (tmp);
+    n2 = n - ceil (tmp) + 1;
+    selection = [1:floor(k/2), n2:n];
+  else
+    selection = 1:k;
+  endif
+
+  d = d(selection);
+
+  if (numel (args) == 1)
+    out{1} = d;
+  else
+    out{2} = diag (d);
+
+    v = args{1};
+    v = v(:,idx);
+    out{1} = v(selection,:);
+  endif
+
+endfunction
+
+
+#### SPARSE MATRIX VERSIONS ####
+
+## Real positive definite tests, n must be even
+%!shared n, k, A, d0, d2
+%! n = 20;
+%! k = 4;
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]);
+%! d0 = eig (A);
+%! d2 = sort (d0);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); # initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (d1, d0(end:-1:(end-k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (d1, d0(k:-1:1), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "la");
+%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sa");
+%! assert (d1, d2(1:k), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "be");
+%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1, "be");
+%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (eigs (A, k, 4.1), eigs (A, speye (n), k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (d1, d0(k:-1:1), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (d1, eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! AA = speye (10);
+%! fn = @(x) AA * x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! assert (eigs (fn, 10, AA, 3, "lm", opts), [1; 1; 1], 10*eps);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "la");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sa");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "be");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+## Real unsymmetric tests
+%!shared n, k, A, d0
+%! n = 20;
+%! k = 4;
+%! A =  sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]);
+%! d0 = eig (A);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (d0));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+
+## Complex hermitian tests
+%!shared n, k, A, d0
+%! n = 20;
+%! k = 4;
+%! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]);
+%! d0 = eig (A);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
+%! d1 = eigs (A, speye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, speye (n), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, speye (n)(q,q), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, speye (n), k, 4.1)), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, speye (n), k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK, HAVE_UMFPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*speye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+#### FULL MATRIX VERSIONS ####
+
+## Real positive definite tests, n must be even
+%!shared n, k, A, d0, d2
+%! n = 20;
+%! k = 4;
+%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),4*ones(1,n),ones(1,n-2)]));
+%! d0 = eig (A);
+%! d2 = sort (d0);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (d1, d0(end:-1:(end-k)),1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (d1, d0(k:-1:1), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "la");
+%! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sa");
+%! assert (d1, d2(1:k), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "be");
+%! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1, "be");
+%! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (eigs (A, k, 4.1), eigs (A, eye (n), k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (d1, d0(k:-1:1), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 1;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (d1, eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "la");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sa");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "be");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+## Real unsymmetric tests
+%!shared n, k, A, d0
+%! n = 20;
+%! k = 4;
+%! A =  full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),1:n,-ones(1,n-2)]));
+%! d0 = eig (A);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (d0));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 1;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+## Complex hermitian tests
+%!shared n, k, A, d0
+%! n = 20;
+%! k = 4;
+%! A = full (sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[1i*ones(1,n-2),4*ones(1,n),-1i*ones(1,n-2)]));
+%! d0 = eig (A);
+%! [~, idx] = sort (abs (d0));
+%! d0 = d0(idx);
+%! rand ("state", 42); % initialize generator to make eigs behavior reproducible
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k+1);
+%! assert (abs (d1), abs (d0(end:-1:(end-k))),1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sm");
+%! assert (abs (d1), abs (d0(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "lr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "sr");
+%! [~, idx] = sort (real (abs (d0)));
+%! d2 = d0(idx);
+%! assert (real (d1), real (d2(1:k)), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "li");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(end:-1:(end-k+1)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, "si");
+%! [~, idx] = sort (imag (abs (d0)));
+%! d2 = d0(idx);
+%! assert (sort (imag (d1)), sort (imag (d2(1:k))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, k, 4.1);
+%! [~, idx0] = sort (abs (d0 - 4.1));
+%! [~, idx1] = sort (abs (d1 - 4.1));
+%! assert (abs (d1(idx1)), abs (d0(idx0(1:k))), 1e-11);
+%! assert (sort (imag (d1(idx1))), sort (imag (d0(idx0(1:k)))), 1e-11);
+%!testif HAVE_ARPACK
+%! d1 = eigs (A, eye (n), k, "lm");
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! d1 = eigs (A, eye (n), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! opts.cholB = true;
+%! q = [2:n,1];
+%! opts.permB = q;
+%! d1 = eigs (A, eye (n)(q,q), k, 4.1, opts);
+%! assert (abs (abs (d1)), abs (eigs (A, k, 4.1)), 1e-11);
+%! assert (sort (imag (abs (d1))), sort (imag (eigs (A, k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (abs (eigs (A, k, 4.1)), abs (eigs (A, eye (n), k, 4.1)), 1e-11);
+%!testif HAVE_ARPACK
+%! assert (sort (imag (eigs (A, k, 4.1))), sort (imag (eigs (A, eye (n), k, 4.1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A * x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "lm", opts);
+%! assert (abs (d1), abs (d0(end:-1:(end-k+1))), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) A \ x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, "sm", opts);
+%! assert (abs (d1), d0(1:k), 1e-11);
+%!testif HAVE_ARPACK
+%! fn = @(x) (A - 4.1 * eye (n)) \ x;
+%! opts.issym = 0;  opts.isreal = 0;
+%! d1 = eigs (fn, n, k, 4.1, opts);
+%! assert (abs (d1), eigs (A, k, 4.1), 1e-11);
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sm");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "lr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "sr");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "li");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+%!testif HAVE_ARPACK
+%! [v1,d1] = eigs (A, k, "si");
+%! d1 = diag (d1);
+%! for i=1:k
+%!   assert (max (abs ((A - d1(i)*eye (n))*v1(:,i))), 0, 1e-11);
+%! endfor
+
+%!assert (eigs (diag (1:5), 5, "sa"), [1;2;3;4;5]);
+%!assert (eigs (diag (1:5), 5, "la"), [5;4;3;2;1]);
+%!assert (eigs (diag (1:5), 3, "be"), [1;4;5]);
+
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -15,22 +15,23 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} etreeplot (@var{A})
 ## @deftypefnx {Function File} {} etreeplot (@var{A}, @var{node_style}, @var{edge_style})
 ## Plot the elimination tree of the matrix @var{A} or
-## @xcode{@var{A}+@var{A}'} if @var{A} in not symmetric.  The optional
+## @tcode{@var{A}+@var{A}'} if @var{A} in not symmetric.  The optional
 ## parameters @var{node_style} and @var{edge_style} define the output
 ## style.
 ## @seealso{treeplot, gplot}
 ## @end deftypefn
 
 function etreeplot (A, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   treeplot (etree (A+A'), varargin{:});
 endfunction
+
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -229,8 +229,9 @@ endfunction
 
 
 %!error gmres (1)
 %!error gmres (1,2,3,4,5,6,7,8,9)
 %!error <A must be> gmres ({1},2)
 %!error <A must be a function or matrix> gmres ({1},2)
 %!error <M1 must be a function or matrix> gmres (1,2,3,4,5,{6})
 %!error <M2 must be a function or matrix> gmres (1,2,3,4,5,6,{7})
+
diff --git a/scripts/sparse/module.mk b/scripts/sparse/module.mk
--- a/scripts/sparse/module.mk
+++ b/scripts/sparse/module.mk
@@ -3,16 +3,17 @@ FCN_FILE_DIRS += sparse
 sparse_PRIVATE_FCN_FILES = \
 	sparse/private/__sprand_impl__.m
 
 sparse_FCN_FILES = \
   sparse/bicg.m \
   sparse/bicgstab.m \
   sparse/cgs.m \
   sparse/colperm.m \
+  sparse/eigs.m \
   sparse/etreeplot.m \
   sparse/gmres.m \
   sparse/gplot.m \
   sparse/nonzeros.m \
   sparse/pcg.m \
   sparse/pcr.m \
   sparse/spaugment.m \
   sparse/spconvert.m \
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -386,150 +386,150 @@ function [x, flag, relres, iter, resvec,
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
 endfunction
 
 
 %!demo
-%!  # Simplest usage of pcg (see also 'help pcg')
-%! 
-%!  N = 10;
-%!  A = diag ([1:N]); b = rand (N, 1);
-%!  y = A \ b;  # y is the true solution
-%!  x = pcg (A, b);
-%!  printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
-%! 
-%!  # You shouldn't be afraid if pcg issues some warning messages in this
-%!  # example: watch out in the second example, why it takes N iterations
-%!  # of pcg to converge to (a very accurate, by the way) solution
+%! ## Simplest usage of pcg (see also 'help pcg')
+%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! y = A \ b;  # y is the true solution
+%! x = pcg (A, b);
+%! printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
+%!
+%! ## You shouldn't be afraid if pcg issues some warning messages in this
+%! ## example: watch out in the second example, why it takes N iterations
+%! ## of pcg to converge to (a very accurate, by the way) solution
 
 %!demo
-%!  # Full output from pcg, except for the eigenvalue estimates
-%!  # We use this output to plot the convergence history
-%! 
-%!  N = 10;
-%!  A = diag ([1:N]); b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec] = pcg (A, b);
-%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec / resvec(1), "o-g");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
-%!  legend ("relative residual");
+%! ## Full output from pcg, except for the eigenvalue estimates
+%! ## We use this output to plot the convergence history
+%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcg (A, b);
+%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec / resvec(1), "o-g");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%! legend ("relative residual");
 
 %!demo
-%!  # Full output from pcg, including the eigenvalue estimates
-%!  # Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
-%! 
-%!  N = 10;
-%!  A = hilb (N); b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
-%!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  printf ("Actual condition number is   %g\n", cond (A));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  legend ("absolute residual", "absolute preconditioned residual");
+%! ## Full output from pcg, including the eigenvalue estimates
+%! ## Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
+%!
+%! N = 10;
+%! A = hilb (N); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
+%! printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%! printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
+%! printf ("Actual condition number is   %g\n", cond (A));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec, ["o-g";"+-r"]);
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! legend ("absolute residual", "absolute preconditioned residual");
 
 %!demo
-%!  # Full output from pcg, including the eigenvalue estimates
-%!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
-%!  # and that's the reason we need some preconditioner; here we take
-%!  # a very simple and not powerful Jacobi preconditioner,
-%!  # which is the diagonal of A
+%! ## Full output from pcg, including the eigenvalue estimates
+%! ## We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
+%! ## and that's the reason we need some preconditioner; here we take
+%! ## a very simple and not powerful Jacobi preconditioner,
+%! ## which is the diagonal of A.
 %!
-%!  N = 100;
-%!  A = zeros (N, N);
-%!  for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!    A(i:i+1, i:i+1) = [2 -1; -1 2];
-%!  endfor
-%!  b = rand (N, 1);
-%!  X = A \ b;  # X is the true solution
-%!  maxit = 80;
-%!  printf ("System condition number is %g\n", cond (A));
-%!  # No preconditioner: the convergence is very slow!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!   A(i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! maxit = 80;
+%! printf ("System condition number is %g\n", cond (A));
+%! ## No preconditioner: the convergence is very slow!
 %!
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%!  printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  title ("Convergence history");
-%!  semilogy ([0:iter], resvec(:,1), "o-g");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  legend ("NO preconditioning: absolute residual");
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
+%! printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
+%! title ("Convergence history");
+%! semilogy ([0:iter], resvec(:,1), "o-g");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! legend ("NO preconditioning: absolute residual");
 %!
-%!  pause (1);
-%!  # Test Jacobi preconditioner: it will not help much!!!
+%! pause (1);
+%! ## Test Jacobi preconditioner: it will not help much!!!
 %!
-%!  M = diag (diag (A)); # Jacobi preconditioner
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!  printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  hold on;
-%!  semilogy ([0:iter], resvec(:,1), "o-r");
-%!  legend ("NO preconditioning: absolute residual", ...
-%!          "JACOBI preconditioner: absolute residual");
+%! M = diag (diag (A)); # Jacobi preconditioner
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%! printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! hold on;
+%! semilogy ([0:iter], resvec(:,1), "o-r");
+%! legend ("NO preconditioning: absolute residual", ...
+%!         "JACOBI preconditioner: absolute residual");
 %!
-%!  pause (1);
-%!  # Test nonoverlapping block Jacobi preconditioner: it will help much!
+%! pause (1);
+%! ## Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
-%!  M = zeros (N, N); k = 4;
-%!  for i = 1 : k : N # form 1-D Laplacian matrix
-%!    M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
-%!  endfor
-%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!  printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
-%!  semilogy ([0:iter], resvec(:,1), "o-b");
-%!  legend ("NO preconditioning: absolute residual", ...
-%!          "JACOBI preconditioner: absolute residual", ...
-%!          "BLOCK JACOBI preconditioner: absolute residual");
-%!  hold off;
+%! M = zeros (N, N); k = 4;
+%! for i = 1 : k : N # form 1-D Laplacian matrix
+%!   M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
+%! endfor
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%! printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%! semilogy ([0:iter], resvec(:,1), "o-b");
+%! legend ("NO preconditioning: absolute residual", ...
+%!         "JACOBI preconditioner: absolute residual", ...
+%!         "BLOCK JACOBI preconditioner: absolute residual");
+%! hold off;
 
 %!test
-%! # solve small diagonal system
+%! ## solve small diagonal system
 %!
 %! N = 10;
 %! A = diag ([1:N]); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 0);
 
 %!test
-%! # solve small indefinite diagonal system
-%! # despite A is indefinite, the iteration continues and converges
-%! # indefiniteness of A is detected
+%! ## solve small indefinite diagonal system
+%! ## despite A is indefinite, the iteration continues and converges
+%! ## indefiniteness of A is detected
 %!
 %! N = 10;
 %! A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 3);
 
 %!test
-%! # solve tridiagonal system, do not converge in default 20 iterations
+%! ## solve tridiagonal system, do not converge in default 20 iterations
 %!
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
 %! assert (flag);
 %! assert (relres > 1.0);
 %! assert (iter, 20); # should perform max allowable default number of iterations
 
 %!test
-%! # solve tridiagonal system with 'perfect' preconditioner
-%! # which converges in one iteration, so the eigest does not
-%! # work and issues a warning
+%! ## solve tridiagonal system with 'perfect' preconditioner
+%! ## which converges in one iteration, so the eigest does not
+%! ## work and issues a warning
 %!
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!         A (i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -298,140 +298,140 @@ function [x, flag, relres, iter, resvec]
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! # Simplest usage of PCR (see also 'help pcr')
+%! ## Simplest usage of PCR (see also 'help pcr')
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
 %! y = A \ b;  # y is the true solution
 %! x = pcr (A,b);
 %! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%! # You shouldn't be afraid if PCR issues some warning messages in this
-%! # example: watch out in the second example, why it takes N iterations
-%! # of PCR to converge to (a very accurate, by the way) solution
+%! ## You shouldn't be afraid if PCR issues some warning messages in this
+%! ## example: watch out in the second example, why it takes N iterations
+%! ## of PCR to converge to (a very accurate, by the way) solution.
 
 %!demo
-%! # Full output from PCR
-%! # We use this output to plot the convergence history
+%! ## Full output from PCR
+%! ## We use this output to plot the convergence history
 %!
 %! N = 20;
 %! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcr (A,b);
 %! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
 %! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
 
 %!demo
-%! # Full output from PCR
-%! # We use indefinite matrix based on the Hilbert matrix, with one
-%! # strongly negative eigenvalue
-%! # Hilbert matrix is extremely ill conditioned, so is ours,
-%! # and that's why PCR WILL have problems
+%! ## Full output from PCR
+%! ## We use indefinite matrix based on the Hilbert matrix, with one
+%! ## strongly negative eigenvalue
+%! ## Hilbert matrix is extremely ill conditioned, so is ours,
+%! ## and that's why PCR WILL have problems
 %!
 %! N = 10;
 %! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
 %! X = A \ b;  # X is the true solution
 %! printf ("Condition number of A is   %g\n", cond (A));
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
 %! if (flag == 3)
 %!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
 %! end
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;absolute residual;");
 
 %!demo
-%! # Full output from PCR
-%! # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%! # and here we have cond(A) = O(N^2)
-%! # That's the reason we need some preconditioner; here we take
-%! # a very simple and not powerful Jacobi preconditioner,
-%! # which is the diagonal of A
+%! ## Full output from PCR
+%! ## We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%! ## and here we have cond(A) = O(N^2)
+%! ## That's the reason we need some preconditioner; here we take
+%! ## a very simple and not powerful Jacobi preconditioner,
+%! ## which is the diagonal of A.
 %!
-%! # Note that we use here indefinite preconditioners!
+%! ## Note that we use here indefinite preconditioners!
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! A = [A, zeros(size(A)); zeros(size(A)), -A];
 %! b = rand (2*N,1);
 %! X = A \ b;  # X is the true solution
 %! maxit = 80;
 %! printf ("System condition number is %g\n", cond (A));
-%! # No preconditioner: the convergence is very slow!
+%! ## No preconditioner: the convergence is very slow!
 %!
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
 %! clf;
 %! title ("Convergence history");
 %! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
 %! pause (1);
-%! # Test Jacobi preconditioner: it will not help much!!!
+%! ## Test Jacobi preconditioner: it will not help much!!!
 %!
 %! M = diag (diag (A)); # Jacobi preconditioner
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
 %! hold on;
 %! semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
 %! pause (1);
-%! # Test nonoverlapping block Jacobi preconditioner: this one should give
-%! # some convergence speedup!
+%! ## Test nonoverlapping block Jacobi preconditioner: this one should give
+%! ## some convergence speedup!
 %!
 %! M = zeros (N,N); k = 4;
 %! for i=1:k:N # get k x k diagonal blocks of A
 %!   M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
 %! endfor
 %! M = [M, zeros(size (M)); zeros(size(M)), -M];
 %! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
 %! semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
 %! hold off;
 
 %!test
-%! # solve small indefinite diagonal system
+%! ## solve small indefinite diagonal system
 %!
 %! N = 10;
 %! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcr (A,b,[],N+1);
 %! assert (norm (x-X) / norm (X) < 1e-10);
 %! assert (flag, 0);
 
 %!test
-%! # solve tridiagonal system, do not converge in default 20 iterations
-%! # should perform max allowable default number of iterations
+%! ## solve tridiagonal system, do not converge in default 20 iterations
+%! ## should perform max allowable default number of iterations
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec] = pcr (A,b,1e-12);
 %! assert (flag, 1);
 %! assert (relres > 0.6);
 %! assert (iter, 20);
 
 %!test
-%! # solve tridiagonal system with "perfect" preconditioner
-%! # converges in one iteration
+%! ## solve tridiagonal system with "perfect" preconditioner
+%! ## converges in one iteration
 %!
 %! N = 100;
 %! A = zeros (N,N);
 %! for i=1:N-1 # form 1-D Laplacian matrix
 %!   A(i:i+1,i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N,1);
 %! X = A \ b;  # X is the true solution
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -70,12 +70,12 @@ function S = __sprand_impl__ (varargin)
     k = min (length (idx), k);
     j = floor ((idx(1:k) - 1) / m);
     i = idx(1:k) - j * m;
   else
     idx = randperm (mn, k);
     [i, j] = ind2sub ([m, n], idx);
   endif
 
-
   S = sparse (i, j, randfun (k, 1), m, n);
 
 endfunction
+
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -86,8 +86,9 @@ function [A, c] = spdiags (v, c, m, n)
   endif
 
 endfunction
 
 
 %!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
 %!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
 %!assert (spdiags ([0.5 -1 0.5], 0:2, 1, 1), sparse(0.5))
+
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -70,8 +70,9 @@ endfunction
 %!error sprandn (3, 3.5, 0.5)
 %!error sprandn (3, 0, 0.5)
 %!error sprandn (3, 3, -1)
 %!error sprandn (3, 3, 2)
 
 %% Test very large, very low density matrix doesn't fail 
 %!test
 %! s = sprandn(1e6,1e6,1e-7);
+
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -116,17 +116,17 @@ function r = pick_rand_diag (n, k)
   ##
   ## Thanks to Zsbn Ambrus <ambrus@math.bme.hu> for most of the ideas
   ## of the implementation here, especially how to do the computation
   ## numerically to avoid overflow.
 
   ## Degenerate case
   if (k == 1)
     r = 1;
-    return
+    return;
   endif
 
   ## Compute the stuff described above
   a = n*(n - 1)/2;
   d = [mod(k,2):2:min(n,k)-2];
   m = (k - d)/2;
   q = (n - d).*(n - d - 1).*m ./ (d + 2)./(d + 1)./(a - m + 1);
 
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -35,23 +35,23 @@
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular values
 ## of @var{A}.  The number of singular values to calculate is given by @var{k}
 ## and defaults to 6.
 ##
 ## The argument @var{sigma} specifies which singular values to find.  When
-## @var{sigma} is the string 'L', the default, the largest singular values of
-## @var{A} are found.  Otherwise, @var{sigma} must be a real scalar and the
-## singular values closest to @var{sigma} are found.  As a corollary,
+## @var{sigma} is the string @qcode{'L'}, the default, the largest singular
+## values of @var{A} are found.  Otherwise, @var{sigma} must be a real scalar
+## and the singular values closest to @var{sigma} are found.  As a corollary,
 ## @code{@var{sigma} = 0} finds the smallest singular values.  Note that for
-## relatively small values of @var{sigma}, there is a chance that the requested
-## number of singular values will not be found.  In that case @var{sigma}
-## should be increased.
+## relatively small values of @var{sigma}, there is a chance that the
+## requested number of singular values will not be found.  In that case
+## @var{sigma} should be increased.
 ##
 ## @var{opts} is a structure defining options that @code{svds} will pass
 ## to @code{eigs}.  The possible fields of this structure are documented in
 ## @code{eigs}.  By default, @code{svds} sets the following three fields:
 ##
 ## @table @code
 ## @item tol
 ## The required convergence tolerance for the singular values.  The default
@@ -94,29 +94,29 @@ function [u, s, v, flag] = svds (A, k, s
 
   persistent root2 = sqrt (2);
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (ndims (A) > 2)
-    error ("svds: A must be a 2D matrix");
+    error ("svds: A must be a 2-D matrix");
   endif
 
   if (nargin < 4)
-    opts.tol = 0;   ## use ARPACK default
+    opts.tol = 0;    # use ARPACK default
     opts.disp = 0;
     opts.maxit = 300;
   else
     if (!isstruct (opts))
       error ("svds: OPTS must be a structure");
     endif
     if (!isfield (opts, "tol"))
-      opts.tol = 0;   ## use ARPACK default
+      opts.tol = 0;  # use ARPACK default
     else
       opts.tol = opts.tol / root2;
     endif
     if (isfield (opts, "v0"))
       if (!isvector (opts.v0) || (length (opts.v0) != sum (size (A))))
         error ("svds: OPTS.v0 must be a vector with rows(A)+columns(A) entries");
       endif
     endif
@@ -136,16 +136,19 @@ function [u, s, v, flag] = svds (A, k, s
     error ("svds: SIGMA must be a positive real value or the string 'L'");
   endif
 
   [m, n] = size (A);
   max_a = max (abs (nonzeros (A)));
   if (isempty (max_a))
     max_a = 0;
   endif
+  ## Must initialize variable value, otherwise it may appear to interpreter
+  ## that code is trying to call flag() colormap function.
+  flag = 0;  
 
   if (max_a == 0)
     s = zeros (k, 1);  # special case of zero matrix
   else
     if (nargin < 2)
       k = min ([6, m, n]);
     else
       k = min ([k, m, n]);
@@ -289,15 +292,15 @@ endfunction
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (zeros (10), k);
 %! assert (u2, eye (10, k));
 %! assert (s2, zeros (k));
 %! assert (v2, eye (10, 7));
 %!
 %!testif HAVE_ARPACK
 %! s = svds (speye (10));
-%! assert (s, ones (6, 1), 4*eps);
+%! assert (s, ones (6, 1), 8*eps);
 
 %!test
 %! ## Restore random number generator seeds at end of tests
 %! rand ("state", rand_state);
 %! randn ("state", randn_state);
 
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -139,17 +139,17 @@ function [x_coordinate, y_coordinate, he
       ## Add to idx the vector of parent descendants.
       stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
       ## We are in top level separator when we have one child and the
       ## flag is 1
       if (columns (idx) == 1 && top_level == 1)
         s++;
       else
-        # We aren't in top level separator now.
+        ## We aren't in top level separator now.
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
        left_most++;
        x_coordinate_r(par_number) = left_most;
        max_ht = min (max_ht, level);
        if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -88,8 +88,9 @@
 ## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
 
 
 %!error bessel ()
+
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -50,8 +50,9 @@ function retval = betaln (a, b)
 endfunction
 
 
 %!assert (betaln (3,4), log (beta (3,4)), eps)
 
 %% Test input validation
 %!error (betaln (1))
 %!error (betaln (1,2,3))
+
diff --git a/scripts/specfun/ellipke.m b/scripts/specfun/ellipke.m
--- a/scripts/specfun/ellipke.m
+++ b/scripts/specfun/ellipke.m
@@ -14,121 +14,122 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} ellipke (@var{m})
-## @deftypefnx {Function File} {} ellipke (@var{m}, @var{tol})
+## @deftypefn  {Function File} {@var{k} =} ellipke (@var{m})
+## @deftypefnx {Function File} {@var{k} =} ellipke (@var{m}, @var{tol})
 ## @deftypefnx {Function File} {[@var{k}, @var{e}] =} ellipke (@dots{})
-## Compute complete elliptic integral of the first K(@var{m}) and second
+## Compute complete elliptic integrals of the first K(@var{m}) and second
 ## E(@var{m}) kind.
 ##
-## @var{m} is either real array or scalar with 0 @leq{} m @leq{} 1.
+## @var{m} must be a scalar or real array with -Inf @leq{} @var{m} @leq{} 1.
+##
+## The optional input @var{tol} is currently ignored (@sc{matlab} uses this
+## to allow a faster, less accurate approximation).
 ##
-## @var{tol} is currently ignored (@sc{matlab} uses this to allow faster,
-## less accurate approximation).
+## Called with only one output, elliptic integrals of the first kind are
+## returned.
 ##
-## Ref: Abramowitz, Milton and Stegun, Irene A. Handbook of Mathematical
-## Functions, Dover, 1965, Chapter 17.
+## Reference: Milton Abramowitz and Irene A. Stegun,
+## @cite{Handbook of Mathematical Functions}, Chapter 17, Dover, 1965.
 ## @seealso{ellipj}
 ## @end deftypefn
 
 ## Author: David Billinghurst <David.Billinghurst@riotinto.com>
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Author: Jaakko Ruohio
 
 function [k, e] = ellipke (m)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  k = e = zeros (size (m));
   m = m(:);
-  if any (!isreal (m))
-    error ("ellipke must have real m");
-  endif
-  if any (m > 1)
-    error ("ellipke must have m <= 1");
+  if (! isreal (m))
+    error ("ellipke: M must be real");
+  elseif (any (m > 1))
+    error ("ellipke: M must be <= 1");
   endif
 
-  Nmax = 16;
-  idx = find (m == 1);
-  if (!isempty (idx))
-    k(idx) = Inf;
-    e(idx) = 1;
-  endif
+  k = e = zeros (size (m));
 
-  idx = find (m == -Inf);
-  if (!isempty (idx))
-    k(idx) = 0;
-    e(idx) = Inf;
-  endif
+  ## Handle extreme values
+  idx_1 = (m == 1);
+  k(idx_1) = Inf;
+  e(idx_1) = 1;
+
+  idx_neginf = (m == -Inf);
+  k(idx_neginf) = 0;
+  e(idx_neginf) = Inf;
 
   ## Arithmetic-Geometric Mean (AGM) algorithm
   ## ( Abramowitz and Stegun, Section 17.6 )
-  idx = find (m != 1 & m != -Inf);
-  if (!isempty (idx))
-    idx_neg = find (m < 0 & m != -Inf);
+  Nmax = 16;
+  idx = !idx_1 & !idx_neginf;
+  if (any (idx))
+    idx_neg = find (m < 0 & !idx_neginf);
     mult_k = 1./sqrt (1 - m(idx_neg));
     mult_e = sqrt (1 - m(idx_neg));
-    m(idx_neg) = -m(idx_neg)./(1 - m(idx_neg));
-    a = ones (length (idx), 1);
+    m(idx_neg) = -m(idx_neg) ./ (1 - m(idx_neg));
+    a = ones (sum (idx), 1);
     b = sqrt (1 - m(idx));
     c = sqrt (m(idx));
     f = 0.5;
-    sum = f*c.*c;
-    for n = 2:Nmax
+    sum = f*c.^2;
+    n = 2;
+    do
       t = (a + b)/2;
       c = (a - b)/2;
       b = sqrt (a.*b);
       a = t;
-      f = f * 2;
-      sum = sum + f*c.*c;
-      if (all (c./a < eps)) break; endif
-    endfor
-    if (n >= Nmax) error ("ellipke: not enough workspace"); endif
-    k(idx) = 0.5*pi./a;
-    e(idx) = 0.5*pi.*(1 - sum)./a;
-    k(idx_neg) = mult_k.*k(idx_neg);
-    e(idx_neg) = mult_e.*e(idx_neg);
+      f *= 2;
+      sum += f*c.^2;
+    until (all (c./a < eps) || (++n > Nmax))
+    if (n >= Nmax)
+      error ("ellipke: algorithm did not converge in %d iterations", Nmax);
+    endif
+    k(idx) = 0.5*pi ./ a;
+    e(idx) = 0.5*pi*(1 - sum) ./ a;
+    k(idx_neg) = mult_k .* k(idx_neg);
+    e(idx_neg) = mult_e .* e(idx_neg);
   endif
 
 endfunction
 
-%% Test complete elliptic functions of first and second kind
-%% against "exact" solution from Mathematica 3.0
+
+## Test complete elliptic functions of first and second kind
+## against "exact" solution from Mathematica 3.0
 %!test
-%! m = [0.0; 0.01; 0.1; 0.5; 0.9; 0.99; 1.0 ];
+%! m = [0.0; 0.01; 0.1; 0.5; 0.9; 0.99; 1.0];
 %! [k,e] = ellipke (m);
 %!
-%! # K(1.0) is really infinity - see below
 %! k_exp = [1.5707963267948966192;
 %!          1.5747455615173559527;
 %!          1.6124413487202193982;
 %!          1.8540746773013719184;
 %!          2.5780921133481731882;
 %!          3.6956373629898746778;
-%!          0.0 ];
+%!          Inf ];
 %! e_exp = [1.5707963267948966192;
 %!          1.5668619420216682912;
 %!          1.5307576368977632025;
 %!          1.3506438810476755025;
 %!          1.1047747327040733261;
 %!          1.0159935450252239356;
 %!          1.0 ];
-%! if k(7)==Inf, k(7)=0; endif;
 %! assert (k, k_exp, 8*eps);
 %! assert (e, e_exp, 8*eps);
 
-%% Test against A&S Table 17.1
+## Test against A&S Table 17.1
 %!test
 %! m = [0:5:50]'/100;
 %! k_exp = [1.570796326794897;
 %!          1.591003453790792;
 %!          1.612441348720219;
 %!          1.635256732264580;
 %!          1.659623598610528;
 %!          1.685750354812596;
@@ -147,11 +148,31 @@ endfunction
 %!          1.422691133;
 %!          1.399392139;
 %!          1.375401972;
 %!          1.350643881 ];
 %! [k,e] = ellipke (m);
 %! assert (k, k_exp, 1e-15);
 %! assert (e, e_exp, 1e-8);
 
-%% Test input validation
+## Test negative values against "exact" solution from Mathematica.
+%! m = [-0.01; -1; -5; -100; -1000; -Inf];
+%! [k,e] = ellipke (m);
+%!
+%! k_exp = [1.5668912730681963584;
+%!          1.3110287771460599052;
+%!          0.9555039270640439337;
+%!          0.3682192486091410329;
+%!          0.1530293349884987857;
+%!          0];
+%! e_exp = [1.5747159850169884130;
+%!          1.9100988945138560089;
+%!          2.8301982463458773125;
+%!          10.209260919814572009;
+%!          31.707204053711259719;
+%!          Inf ];
+%! assert (k, k_exp, 8*eps);
+%! assert (e, e_exp, 8*eps (e_exp));
+
+## Test input validation
 %!error ellipke ()
 %!error ellipke (1,2,3)
+
diff --git a/scripts/specfun/expint.m b/scripts/specfun/expint.m
--- a/scripts/specfun/expint.m
+++ b/scripts/specfun/expint.m
@@ -15,135 +15,152 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} expint (@var{x})
-## Compute the exponential integral,
+## Compute the exponential integral:
 ## @tex
 ## $$
-##  E_1 (x) = \int_x^\infty {e^{-t} \over t} dt.
+## {\rm E_1} (x) = \int_x^\infty {e^{-t} \over t} dt
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##               infinity
-##              /
-## expint (x) = | exp (-t)/t dt
-##              /
-##             x
+##            infinity
+##           /
+## E_1 (x) = | exp (-t)/t dt
+##           /
+##          x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
+## Note: For compatibility, this functions uses the @sc{matlab} definition
+## of the exponential integral.  Most other sources refer to this particular
+## value as @math{E_1 (x)}, and the exponential integral is
+## @tex
+## $$
+## {\rm Ei} (x) = - \int_{-x}^\infty {e^{-t} \over t} dt.
+## $$
+## @end tex
+## @ifnottex
+##
+## @example
+## @group
+##             infinity
+##            /
+## Ei (x) = - | exp (-t)/t dt
+##            /
+##          -x
+## @end group
+## @end example
+##
+## @end ifnottex
+## The two definitions are related, for positive real values of @var{x}, by
+## @tex
+## $
+## E_1 (-x) = -{\rm Ei} (x) - i\pi.
+## $
+## @end tex
+## @ifnottex
+## @w{@code{E_1 (-x) = -Ei (x) - i*pi}}.
+## @end ifnottex
 ## @end deftypefn
 
 function y = expint (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  y = expint_E1 (x);
-
-endfunction
+  y = x;  # Copy over all values, including NaNs
 
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} expint_E1 (@var{x})
-## Compute the exponential integral,
-## @verbatim
-##                    infinity
-##                   /
-##       expint(x) = | exp(-t)/t dt
-##                   /
-##                  x
-## @end verbatim
-## @end deftypefn
-
-function y = expint_E1 (x)
+  if (isreal (x))
+    idx = (x >= 0);
+    y(idx) = -expint_Ei (-x(idx));
 
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  y = x;
-
-  idx = (imag (x) > 0 & imag (x) != 0);
-  y(idx) = -expint_Ei (-y(idx)) - i.*pi;
+    idx = (x < 0);
+    y(idx) = -expint_Ei (-x(idx)) - i*pi;
+  else
+    idx = (imag (x) > 0);
+    y(idx) = -expint_Ei (-x(idx)) - i*pi;
 
-  idx = (imag (x) < 0 & imag (x) != 0);
-  y(idx) = -expint_Ei (-y(idx)) + i.*pi;
+    idx = (imag (x) < 0);
+    y(idx) = -expint_Ei (-x(idx)) + i*pi;
 
-  idx = (real (x) >= 0 & imag (x) == 0);
-  y(idx) = -expint_Ei (-y(idx));
+    isreal_idx = (imag (x) == 0);
+    idx = (isreal_idx & real (x) >= 0);
+    y(idx) = -expint_Ei (-x(idx));
 
-  idx = (real (x) < 0 & imag (x) == 0);
-  y(idx) = -expint_Ei (-y(idx)) - i.*pi;
+    idx = (isreal_idx & real (x) < 0);
+    y(idx) = -expint_Ei (-x(idx)) - i*pi;
+  endif
 
 endfunction
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} expint_Ei (@var{x})
-## Compute the exponential integral,
+## Compute the exponential integral:
 ## @verbatim
-##                      infinity
-##                     /
-##    expint_Ei(x) = - | exp(t)/t dt
-##                     /
-##                     -x
+##                       infinity
+##                      /
+##    expint_Ei (x) = - | exp(-t)/t dt
+##                      /
+##                    -x
 ## @end verbatim
 ## @end deftypefn
 
 function y = expint_Ei (x)
 
-  if (nargin != 1)
-    print_usage ();
-  endif
-
   y = zeros (size (x));
   F = @(x) exp (-x)./x;
-  s = prod (size (x));
 
-  for t = 1:s;
-    if (x(t) < 0 && imag (x(t)) == 0)
-      y(t) = -quad (F, -x(t), Inf);
+  for t = 1:numel (x)
+    xt = x(t);
+    if (xt < 0 && imag (xt) == 0)
+      ## Direct integration for most real inputs
+      y(t) = -quad (F, -xt, Inf, [0, 1e-10]);
+    elseif (xt > 2 && imag (xt) == 0)
+      persistent Ei_2 = 4.954234356001890;
+      y(t) = Ei_2 - quad (F, -xt, -2);
+    elseif (abs (xt) < 10)
+      ## Series Expansion for real (range [0,2]) or complex inputs (r < 10)
+      k = 1;
+      do
+        term = xt^k / (k*factorial (k));
+        y(t) += term;
+      until (abs (term) < eps (abs (y(t))) / 2 || k++ >= 100)
+      y(t) = 0.57721566490153286 + log (xt) + y(t);
     else
-      if (abs (x(t)) > 2 && imag (x(t)) == 0)
-        y(t) = expint_Ei (2) - quad (F, -x(t), -2);
+      ## FIXME: This expansion is accurate to only 1e-13 at the beginning
+      ##        near 10+i, although it becomes more accurate as the magnitude
+      ##        of xt grows.
+      if (imag (xt) <= 0)
+        persistent a1 = 4.03640;
+        persistent a2 = 1.15198;
+        persistent b1 = 5.03637;
+        persistent b2 = 4.19160;
+        y(t) = -(xt^2 - a1*xt + a2) ...
+               / ((xt^2 - b1*xt + b2) * (-xt) * exp (-xt)) ...
+               - i*pi;
       else
-        if (abs (x(t)) >= 10)
-          if (imag (x(t)) <= 0)
-            a1 = 4.03640;
-            a2 = 1.15198;
-            b1 = 5.03637;
-            b2 = 4.19160;
-            y(t) = -(x(t).^2 - a1.*x(t) + a2) ...
-                   ./ ((x(t).^2 - b1.*x(t) + b2) .* (-x(t)) .* exp (-x(t))) ...
-                   - i.*pi;
-          else
-            y(t) = conj (expint_Ei (conj (x(t))));
-          endif;
-        ## Serie Expansion
-        else
-          for k = 1:100;
-            y(t) = y(t) + x(t).^k ./ (k.*factorial (k));
-          endfor
-          y(t) = 0.577215664901532860606512090082402431 + log (x(t)) + y(t);
-        endif
-      endif
+        y(t) = conj (expint_Ei (conj (xt)));
+      endif;
     endif
   endfor
 endfunction
 
-%% Test against A&S Table 5.1
+
+## Test against A&S Table 5.1
 %!test
 %! x = [5:5:50]'/100;
 %! gamma = 0.5772156649;
 %! y_exp = [0.9876375971;
 %!          0.9755453033;
 %!          0.9637156702;
 %!          0.9521414833;
 %!          0.9408157528;
@@ -193,11 +210,57 @@ endfunction
 %!          0.064713129;
 %!          0.060294967;
 %!          0.056204378;
 %!          0.052414380;
 %!          0.048900511 ];
 %! y = expint (x);
 %! assert (y, y_exp, 1e-9);
 
-%% Test input validation
+## Series expansion (-2 < x < 0)
+## Expected values from Mathematica
+%!test  
+%! x = [-0.1; -0.5; -1; -1.5; -2];
+%! y_exp = [ 1.6228128139692767  - i*pi;
+%!          -0.45421990486317358 - i*pi;
+%!          -1.8951178163559368  - i*pi;
+%!          -3.3012854491297978  - i*pi;
+%!          -4.9542343560018902  - i*pi];
+%! y = expint (x);
+%! assert (y, y_exp, eps (real (y_exp)));
+
+## (x < -2, x real)
+%!test  
+%! x = [-2.5; -3; -10;-15; -25];
+%! y_exp = [-7.0737658945786007   - i*pi;
+%!          -9.9338325706254165   - i*pi;
+%!          -2492.2289762418777   - i*pi;
+%!          -234955.85249076830   - i*pi;
+%!          -3.0059509065255486e9 - i*pi];
+%! y = expint (x);
+%! assert (y, y_exp, 8*eps (real (y_exp)));
+
+## Complex values
+%!test
+%! x = [i; -1-i; 10-i; 10+i];
+%! y_exp = [-0.33740392290096813   - i*0.62471325642771360;
+%!          -1.7646259855638540    + i*0.75382280207927082;
+%!          1.90746381979783120e-6 + i*3.67354374003294739e-6;
+%!          1.90746381979783120e-6 - i*3.67354374003294739e-6];
+%! y = expint (x);
+%! assert (y, y_exp, 1e-12);
+
+## Exceptional values (-Inf, Inf, NaN, 0, 0.37250741078)
+%!test  
+%! x = [-Inf; Inf; NaN; 0; -0.3725074107813668];
+%! y_exp = [-Inf - i*pi;
+%!          -Inf;  # should be 0;
+%!          NaN;
+%!          Inf;
+%!          0 - i*pi];
+%! y = expint (x);
+%! assert (y, y_exp, 5*eps);
+
+## Test input validation
 %!error expint ()
 %!error expint (1,2)
+
+
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -17,22 +17,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{l} =} legendre (@var{n}, @var{x})
 ## @deftypefnx {Function File} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
 ## Compute the Legendre function of degree @var{n} and order
 ## @var{m} = 0 @dots{} N@.  The optional argument, @var{normalization},
-## may be one of @code{"unnorm"}, @code{"sch"}, or @code{"norm"}.
-## The default is @code{"unnorm"}.  The value of @var{n} must be a
+## may be one of @qcode{"unnorm"}, @qcode{"sch"}, or @qcode{"norm"}.
+## The default is @qcode{"unnorm"}.  The value of @var{n} must be a
 ## non-negative scalar integer.
 ##
 ## If the optional argument @var{normalization} is missing or is
-## @code{"unnorm"}, compute the Legendre function of degree @var{n} and
+## @qcode{"unnorm"}, compute the Legendre function of degree @var{n} and
 ## order @var{m} and return all values for @var{m} = 0 @dots{} @var{n}.
 ## The return value has one dimension more than @var{x}.
 ##
 ## The Legendre Function of degree @var{n} and order @var{m}:
 ##
 ## @tex
 ## $$
 ## P^m_n(x) = (-1)^m (1-x^2)^{m/2}{d^m\over {dx^m}}P_n (x)
@@ -79,17 +79,17 @@
 ## ------------------------------------
 ## m=0 | -1.00000 | -0.47250 | -0.08000
 ## m=1 |  0.00000 | -1.99420 | -1.98000
 ## m=2 |  0.00000 | -2.56500 | -4.32000
 ## m=3 |  0.00000 | -1.24229 | -3.24000
 ## @end group
 ## @end example
 ##
-## If the optional argument @code{normalization} is @code{"sch"},
+## If the optional argument @code{normalization} is @qcode{"sch"},
 ## compute the Schmidt semi-normalized associated Legendre function.
 ## The Schmidt semi-normalized associated Legendre function is related
 ## to the unnormalized Legendre functions by the following:
 ##
 ## For Legendre functions of degree n and order 0:
 ##
 ## @tex
 ## $$
@@ -122,17 +122,17 @@
 ##   m      m         m    2(n-m)! 0.5
 ## SP(x) = P(x) * (-1)  * [-------]
 ##   n      n              (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## If the optional argument @var{normalization} is @code{"norm"},
+## If the optional argument @var{normalization} is @qcode{"norm"},
 ## compute the fully normalized associated Legendre function.
 ## The fully normalized associated Legendre function is related
 ## to the unnormalized Legendre functions by the following:
 ##
 ## For Legendre functions of degree @var{n} and order @var{m}
 ##
 ## @tex
 ## $$
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -37,26 +37,26 @@
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function A = perms (v)
   if (nargin != 1)
     print_usage ();
   endif
-  vidx = [1:length(v)]';
+  vidx = uint8 ([1:length(v)]');
   n = length (vidx);
 
   if (n == 0)
     p = [];
   else
     p = vidx(1);
     for j = 2:n
       B = p;
-      p = zeros (prod (2:j), n);
+      p = zeros (prod (2:j), n, "uint8");
       k = rows (B);
       idx = 1:k;
       for i = j:-1:1
         p(idx,1:i-1) = B(:,1:i-1);
         p(idx,i) = vidx(j);
         p(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -17,17 +17,16 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} gallery (@var{name})
 ## @deftypefnx {Function File} {} gallery (@var{name}, @var{args})
 ## Create interesting matrices for testing.
 ##
-##
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{c} =} gallery ("cauchy", @var{x})
 ## @deftypefnx {Function File} {@var{c} =} gallery ("cauchy", @var{x}, @var{y})
 ## Create a Cauchy matrix.
 ##
 ## @end deftypefn
 ##
@@ -141,16 +140,39 @@
 ## @end deftypefn
 ##
 ## @deftypefn  {Function File} {@var{v} =} gallery ("house", @var{x})
 ## @deftypefnx {Function File} {[@var{v}, @var{beta}] =} gallery ("house", @var{x})
 ## Create a householder matrix.
 ##
 ## @end deftypefn
 ##
+## @deftypefn  {Function File} {@var{a} =} gallery ("integerdata", @var{imax}, [@var{M} @var{N} @dots{}], @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("integerdata", @var{imax}, @var{M}, @var{N}, @dots{}, @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("integerdata", [@var{imin}, @var{imax}], [@var{M} @var{N} @dots{}], @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("integerdata", [@var{imin}, @var{imax}], @var{M}, @var{N}, @dots{}, @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("integerdata", @dots{}, "@var{class}")
+## Create a matrix with random integers in the range [1, @var{imax}].
+## If @var{imin} is given then the integers are in the range
+## [@var{imin}, @var{imax}].
+##
+## The second input is a matrix of dimensions describing the size of the output.
+## The dimensions can also be input as comma-separated arguments.
+##
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The
+## values of the output matrix are always exactly the same
+## (reproducibility) for a given size input and @var{j} index.
+##
+## The final optional argument determines the class of the resulting matrix.
+## Possible values for @var{class}: @qcode{"uint8"}, @qcode{"uint16"},
+## @qcode{"uint32"}, @qcode{"int8"}, @qcode{"int16"}, int32", @qcode{"single"},
+## @qcode{"double"}.  The default is @qcode{"double"}.
+##
+## @end deftypefn
+##
 ## @deftypefn  {Function File} {@var{a} =} gallery ("invhess", @var{x})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("invhess", @var{x}, @var{y})
 ## Create the inverse of an upper Hessenberg matrix.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn {Function File} {@var{a} =} gallery ("invol", @var{n})
 ## Create an involutory matrix.
@@ -221,16 +243,35 @@
 ##
 ## @end deftypefn
 ##
 ## @deftypefn {Function File} {[@var{a}, @var{t}] =} gallery ("neumann", @var{n})
 ## Create a singular matrix from the discrete Neumann problem (sparse).
 ##
 ## @end deftypefn
 ##
+## @deftypefn  {Function File} {@var{a} =} gallery ("normaldata", [@var{M} @var{N} @dots{}], @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("normaldata", @var{M}, @var{N}, @dots{}, @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("normaldata", @dots{}, "@var{class}")
+## Create a matrix with random samples from the standard normal distribution
+## (mean = 0, std = 1).
+##
+## The first input is a matrix of dimensions describing the size of the output.
+## The dimensions can also be input as comma-separated arguments.
+##
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The
+## values of the output matrix are always exactly the same
+## (reproducibility) for a given size input and @var{j} index.
+##
+## The final optional argument determines the class of the resulting matrix.
+## Possible values for @var{class}: @qcode{"single"}, @qcode{"double"}.
+## The default is @qcode{"double"}.
+##
+## @end deftypefn
+##
 ## @deftypefn  {Function File} {@var{q} =} gallery ("orthog", @var{n})
 ## @deftypefnx {Function File} {@var{q} =} gallery ("orthog", @var{n}, @var{k})
 ## Create orthogonal and nearly orthogonal matrices.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn {Function File} {@var{a} =} gallery ("parter", @var{n})
 ## Create a Parter matrix (a Toeplitz matrix with singular values near pi).
@@ -323,16 +364,35 @@
 ##
 ## @deftypefn  {Function File} {@var{t} =} gallery ("triw", @var{n})
 ## @deftypefnx {Function File} {@var{t} =} gallery ("triw", @var{n}, @var{alpha})
 ## @deftypefnx {Function File} {@var{t} =} gallery ("triw", @var{n}, @var{alpha}, @var{k})
 ## Create an upper triangular matrix discussed by Kahan, Golub and Wilkinson.
 ##
 ## @end deftypefn
 ##
+## @deftypefn  {Function File} {@var{a} =} gallery ("uniformdata", [@var{M} @var{N} @dots{}], @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("uniformdata", @var{M}, @var{N}, @dots{}, @var{j})
+## @deftypefnx {Function File} {@var{a} =} gallery ("uniformdata", @dots{}, "@var{class}")
+## Create a matrix with random samples from the standard uniform distribution
+## (range [0,1]).
+##
+## The first input is a matrix of dimensions describing the size of the output.
+## The dimensions can also be input as comma-separated arguments.
+##
+## The input @var{j} is an integer index in the range [0, 2^32-1].  The
+## values of the output matrix are always exactly the same
+## (reproducibility) for a given size input and @var{j} index.
+##
+## The final optional argument determines the class of the resulting matrix.
+## Possible values for @var{class}: @qcode{"single"}, @qcode{"double"}.
+## The default is @qcode{"double"}.
+##
+## @end deftypefn
+##
 ## @deftypefn  {Function File} {@var{a} =} gallery ("wathen", @var{nx}, @var{ny})
 ## @deftypefnx {Function File} {@var{a} =} gallery ("wathen", @var{nx}, @var{ny}, @var{k})
 ## Create the Wathen matrix.
 ##
 ## @end deftypefn
 ##
 ## @deftypefn {Function File} {[@var{a}, @var{b}] =} gallery ("wilk", @var{n})
 ## Create various specific matrices devised/discussed by Wilkinson.
@@ -385,36 +445,34 @@ function [varargout] = gallery (name, va
     case "fiedler"    , [varargout{1:n_out}] = fiedler     (varargin{:});
     case "forsythe"   , [varargout{1:n_out}] = forsythe    (varargin{:});
     case "frank"      , [varargout{1:n_out}] = frank       (varargin{:});
     case "gearmat"    , [varargout{1:n_out}] = gearmat     (varargin{:});
     case "gcdmat"     , [varargout{1:n_out}] = gcdmat      (varargin{:});
     case "grcar"      , [varargout{1:n_out}] = grcar       (varargin{:});
     case "hanowa"     , [varargout{1:n_out}] = hanowa      (varargin{:});
     case "house"      , [varargout{1:n_out}] = house       (varargin{:});
-    case "integerdata"
-      error ("gallery: matrix %s not implemented.", name);
+    case "integerdata", [varargout{1:n_out}] = integerdata (varargin{:});
     case "invhess"    , [varargout{1:n_out}] = invhess     (varargin{:});
     case "invol"      , [varargout{1:n_out}] = invol       (varargin{:});
     case "ipjfact"    , [varargout{1:n_out}] = ipjfact     (varargin{:});
     case "jordbloc"   , [varargout{1:n_out}] = jordbloc    (varargin{:});
     case "kahan"      , [varargout{1:n_out}] = kahan       (varargin{:});
     case "kms"        , [varargout{1:n_out}] = kms         (varargin{:});
     case "krylov"     , [varargout{1:n_out}] = krylov      (varargin{:});
     case "lauchli"    , [varargout{1:n_out}] = lauchli     (varargin{:});
     case "lehmer"     , [varargout{1:n_out}] = lehmer      (varargin{:});
     case "leslie"
       error ("gallery: matrix %s not implemented.", name);
     case "lesp"       , [varargout{1:n_out}] = lesp        (varargin{:});
     case "lotkin"     , [varargout{1:n_out}] = lotkin      (varargin{:});
     case "minij"      , [varargout{1:n_out}] = minij       (varargin{:});
     case "moler"      , [varargout{1:n_out}] = moler       (varargin{:});
     case "neumann"    , [varargout{1:n_out}] = neumann     (varargin{:});
-    case "normaldata"
-      error ("gallery: matrix %s not implemented.", name);
+    case "normaldata" , [varargout{1:n_out}] = normaldata  (varargin{:});
     case "orthog"     , [varargout{1:n_out}] = orthog      (varargin{:});
     case "parter"     , [varargout{1:n_out}] = parter      (varargin{:});
     case "pei"        , [varargout{1:n_out}] = pei         (varargin{:});
     case "poisson"    , [varargout{1:n_out}] = poisson     (varargin{:});
     case "prolate"    , [varargout{1:n_out}] = prolate     (varargin{:});
     case "randcolu"
       error ("gallery: matrix %s not implemented.", name);
     case "randcorr"
@@ -429,18 +487,17 @@ function [varargout] = gallery (name, va
     case "ris"         , [varargout{1:n_out}] = ris         (varargin{:});
     case "sampling"
       error ("gallery: matrix %s not implemented.", name);
     case "smoke"       , [varargout{1:n_out}] = smoke       (varargin{:});
     case "toeppd"      , [varargout{1:n_out}] = toeppd      (varargin{:});
     case "toeppen"     , [varargout{1:n_out}] = toeppen     (varargin{:});
     case "tridiag"     , [varargout{1:n_out}] = tridiag     (varargin{:});
     case "triw"        , [varargout{1:n_out}] = triw        (varargin{:});
-    case "uniformdata"
-      error ("gallery: matrix %s not implemented.", name);
+    case "uniformdata" , [varargout{1:n_out}] = uniformdata (varargin{:});
     case "wathen"      , [varargout{1:n_out}] = wathen      (varargin{:});
     case "wilk"        , [varargout{1:n_out}] = wilk        (varargin{:});
     otherwise
       error ("gallery: unknown matrix with NAME %s", name);
   endswitch
 
 endfunction
 
@@ -740,17 +797,17 @@ function C = compar (A, k = 0)
   ##
   ##         Reference (e.g.):
   ##         N.J. Higham, A survey of condition number estimation for
   ##         triangular matrices, SIAM Review, 29 (1987), pp. 575-596.
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for compar matrix.");
   elseif (! isnumeric (A) || ndims (A) != 2)
-    error ("gallery: A must be a 2D matrix for compar matrix.");
+    error ("gallery: A must be a 2-D matrix for compar matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for compar matrix.");
   endif
 
   [m, n] = size (A);
   p = min (m, n);
 
   if (k == 0)
@@ -1263,16 +1320,58 @@ function [v, beta] = house (x)
   else
     v(1) = v(1) + s;
     beta = 1/(s'*v(1));                       # NB the conjugated s.
     ##  beta = 1/(abs (s) * (abs (s) +abs(x(1)) would guarantee beta real.
     ##  But beta as above can be non-real (due to rounding) only when x is complex.
   endif
 endfunction
 
+function A = integerdata (varargin)
+
+  if (nargin < 3)
+    error ("gallery: At least 3 arguments required for integerdata matrix.");
+  endif
+
+  if (isnumeric (varargin{end}))
+    jidx = varargin{end};
+    svec = [varargin{:}];
+    varargin(end) = [];
+  elseif (ischar (varargin{end}))
+    if (nargin < 4)
+      error (["gallery: CLASS argument requires 4 inputs " ...
+              "for integerdata matrix."]);
+    endif
+    jidx = varargin{end-1};
+    svec = [varargin{1:end-1}];
+    varargin(end-1) = [];
+  else 
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for integerdata matrix"]);
+  endif
+
+  if (! (isnumeric (jidx) && isscalar (jidx)
+         && jidx == fix (jidx)
+         && jidx >= 0 && jidx <= 0xFFFFFFFF))
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for integerdata matrix"]);
+  endif
+
+  ## Save and restore random state.  Initialization done so that reproducible
+  ## data is available from gallery depending on the jidx and size vector.
+  randstate = rand ("state"); 
+  unwind_protect
+    rand ("state", svec);
+    A = randi (varargin{:});
+  unwind_protect_cleanup
+    rand ("state", randstate);
+  end_unwind_protect
+
+endfunction
+
 function A = invhess (x, y)
   ## INVHESS  Inverse of an upper Hessenberg matrix.
   ##          INVHESS(X, Y), where X is an N-vector and Y an N-1 vector,
   ##          is the matrix whose lower triangle agrees with that of
   ##          ONES(N,1)*X' and whose strict upper triangle agrees with
   ##          that of [1 Y]*ONES(1,N).
   ##          The matrix is nonsingular if X(1) ~= 0 and X(i+1) ~= Y(i)
   ##          for all i, and its inverse is an upper Hessenberg matrix.
@@ -1310,17 +1409,17 @@ function A = invhess (x, y)
     y = -x(1:end-1);
   elseif (! isvector (y) || numel (y) != numel (x) -1)
     error ("gallery: Y must be a vector of length -1 than X for invhess matrix.");
   endif
 
   x = x(:);
   y = y(:);
 
-  ##  On next line, z = x'; A = z(ones(n,1),:) would be more efficient.
+  ##  FIXME: On next line, z = x'; A = z(ones(n,1),:) would be more efficient.
   A = ones (n, 1) * x';
   for j = 2:n
     A(1:j-1,j) = y(1:j-1);
   endfor
 endfunction
 
 function A = invol (n)
   ## INVOL   An involutory matrix.
@@ -1498,26 +1597,26 @@ function A = kms (n, rho = 0.5)
   ##        Reference:
   ##        W.F. Trench, Numerical solution of the eigenvalue problem
   ##        for Hermitian Toeplitz matrices, SIAM J. Matrix Analysis and Appl.,
   ##        10 (1989), pp. 135-146 (and see the references therein).
 
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for lauchli matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
-    error("gallery: N must be an integer for lauchli matrix.")
+    error ("gallery: N must be an integer for lauchli matrix.")
   elseif (! isscalar (mu))
-    error("gallery: MU must be a scalar for lauchli matrix.")
+    error ("gallery: MU must be a scalar for lauchli matrix.")
   endif
 
-  A = (1:n)'*ones(1,n);
-  A = abs(A - A');
+  A = (1:n)'*ones (1,n);
+  A = abs (A - A');
   A = rho .^ A;
-  if imag(rho)
-    A = conj(tril(A,-1)) + triu(A);
+  if (imag (rho))
+    A = conj (tril (A,-1)) + triu (A);
   endif
 endfunction
 
 function B = krylov (A, x, j)
   ## KRYLOV    Krylov matrix.
   ##           KRYLOV(A, x, j) is the Krylov matrix
   ##                [x, Ax, A^2x, ..., A^(j-1)x],
   ##           where A is an n-by-n matrix and x is an n-vector.
@@ -1526,17 +1625,17 @@ function B = krylov (A, x, j)
   ##
   ##           Reference:
   ##           G.H. Golub and C.F. Van Loan, Matrix Computations, second edition,
   ##           Johns Hopkins University Press, Baltimore, Maryland, 1989, p. 369.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for krylov matrix.");
   elseif (! isnumeric (A) || ! issquare (A) || ndims (A) != 2)
-    error ("gallery: A must be a square 2D matrix for krylov matrix.");
+    error ("gallery: A must be a square 2-D matrix for krylov matrix.");
   endif
 
   n = length (A);
   if (isscalar (A))
     n = A;
     A = randn (n);
   endif
 
@@ -1741,16 +1840,57 @@ function [A, T] = neumann (n)
 
   T = tridiag (n(1), -1, 2, -1);
   T(1,2) = -2;
   T(n(1),n(1)-1) = -2;
 
   A = kron (T, eye (n(2))) + kron (eye (n(2)), T);
 endfunction
 
+function A = normaldata (varargin)
+
+  if (nargin < 2)
+    error ("gallery: At least 2 arguments required for normaldata matrix.");
+  endif
+  if (isnumeric (varargin{end}))
+    jidx = varargin{end};
+    svec = [varargin{:}];
+    varargin(end) = [];
+  elseif (ischar (varargin{end}))
+    if (nargin < 3)
+      error (["gallery: CLASS argument requires 3 inputs " ...
+              "for normaldata matrix."]);
+    endif
+    jidx = varargin{end-1};
+    svec = [varargin{1:end-1}];
+    varargin(end-1) = [];
+  else 
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for normaldata matrix"]);
+  endif
+
+  if (! (isnumeric (jidx) && isscalar (jidx)
+         && jidx == fix (jidx)
+         && jidx >= 0 && jidx <= 0xFFFFFFFF))
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for normaldata matrix"]);
+  endif
+
+  ## Save and restore random state.  Initialization done so that reproducible
+  ## data is available from gallery depending on the jidx and size vector.
+  randstate = randn ("state"); 
+  unwind_protect
+    randn ("state", svec);
+    A = randn (varargin{:});
+  unwind_protect_cleanup
+    randn ("state", randstate);
+  end_unwind_protect
+
+endfunction
+
 function Q = orthog (n, k = 1)
   ## ORTHOG Orthogonal and nearly orthogonal matrices.
   ##        Q = ORTHOG(N, K) selects the K'th type of matrix of order N.
   ##        K > 0 for exactly orthogonal matrices, K < 0 for diagonal scalings of
   ##        orthogonal matrices.
   ##        Available types: (K = 1 is the default)
   ##        K = 1:  Q(i,j) = SQRT(2/(n+1)) * SIN( i*j*PI/(n+1) )
   ##                Symmetric eigenvector matrix for second difference matrix.
@@ -1804,17 +1944,17 @@ function Q = orthog (n, k = 1)
       Q = exp (m'*m*2*pi* sqrt (-1) / n) / sqrt (n);
 
     case (4)
       ## Helmert matrix
       Q = tril (ones (n));
       Q(1,2:n) = ones (1, n-1);
       for i = 2:n
         Q(i,i) = -(i-1);
-      end
+      endfor
       Q = diag (sqrt ([n 1:n-1] .* [1:n])) \ Q;
 
     case (5)
       ## Hartley matrix
       m = (0:n-1)'*(0:n-1) * (2*pi/n);
       Q = (cos (m) + sin (m)) / sqrt (n);
 
     case (-1)
@@ -1923,17 +2063,17 @@ function A = prolate (n, w = 0.25)
   elseif (! isnumeric (w) || ! isscalar (w))
     error ("gallery: W must be a scalar for prolate matrix.");
   endif
 
   a      = zeros (n, 1);
   a(1)   = 2*w;
   a(2:n) = sin (2*pi*w*(1:n-1)) ./ (pi*(1:n-1));
 
-  A = toeplitz(a);
+  A = toeplitz (a);
 endfunction
 
 function H = randhess (x)
   ## NOTE: this function was named ohess in the original Test Matrix Toolbox
   ## RANDHESS  Random, orthogonal upper Hessenberg matrix.
   ##        H = RANDHESS(N) is an N-by-N real, random, orthogonal
   ##        upper Hessenberg matrix.
   ##        Alternatively, H = RANDHESS(X), where X is an arbitrary real
@@ -2072,18 +2212,18 @@ function A = randsvd (n, kappa = sqrt (1
   m = n(1);
   n = n(end);
   p = min ([m n]);
 
   ## If A will be a vector
   if (p == 1)
     A = randn (m, n);
     A = A / norm (A);
-    return
-  end
+    return;
+  endif
 
   ##  Set up vector sigma of singular values.
   switch (abs (mode))
     case (1)
       sigma = ones (p, 1) ./ kappa;
       sigma(1) = 1;
     case (2)
       sigma = ones (p, 1);
@@ -2099,31 +2239,31 @@ function A = randsvd (n, kappa = sqrt (1
       sigma = exp (-rand (p, 1) * log (kappa));
     otherwise
       error ("gallery: unknown MODE '%d' for randsvd matrix.", mode);
   endswitch
 
   ##  Convert to diagonal matrix of singular values.
   if (mode < 0)
     sigma = sigma (p:-1:1);
-  end
+  endif
   sigma = diag (sigma);
 
   if (posdef)
     ## handle case where KAPPA was negative
     Q = qmult (p);
     A = Q' * sigma * Q;
     A = (A + A') / 2;  # Ensure matrix is symmetric.
-    return
+    return;
   endif
 
   if (m != n)
     ## Expand to m-by-n diagonal matrix
     sigma(m, n) = 0;
-  end
+  endif
 
   if (kl == 0 && ku == 0)
     ## Diagonal matrix requested - nothing more to do.
     A = sigma;
   else
     ##  A = U*sigma*V, where U, V are random orthogonal matrices from the
     ##  Haar distribution.
     A = qmult (sigma');
@@ -2247,18 +2387,18 @@ function A = smoke (n, k = 0)
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 to 2 arguments are required for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for smoke matrix.");
   elseif (! isnumeric (n) || ! isscalar (n))
     error ("gallery: K must be a numeric scalar for smoke matrix.");
   endif
 
-  w = exp(2*pi*i/n);
-  A = diag( [w.^(1:n-1) 1] ) + diag(ones(n-1,1),1);
+  w = exp (2*pi*i/n);
+  A = diag ( [w.^(1:n-1) 1] ) + diag (ones (n-1,1), 1);
 
   switch (k)
     case (0), A(n,1) = 1;
     case (1), # do nothing
     otherwise,
       error ("gallery: K must have a value of 0 or 1 for smoke matrix.");
   endswitch
 endfunction
@@ -2319,17 +2459,17 @@ function P = toeppen (n, a = 1, b = -10,
   ##           H. Rutishauser, On test matrices, Programmation en Mathematiques
   ##              Numeriques, Editions Centre Nat. Recherche Sci., Paris, 165,
   ##              1966, pp. 349-365.
 
   if (nargin < 1 || nargin > 6)
     error ("gallery: 1 to 6 arguments are required for toeppen matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be a numeric integer for toeppen matrix.");
-  elseif (any (cellfun (@(x) ! isnumeric (x) || ! isscalar (x), {a b c d e})))
+  elseif (any (! cellfun ("isnumeric", {a b c d e})) || any (cellfun ("numel", {a b c d e}) != 1))
     error ("gallery: A, B, C, D and E must be numeric scalars for toeppen matrix.");
   endif
 
   P = spdiags ([a*ones(n,1) b*ones(n,1) c*ones(n,1) d*ones(n,1) e*ones(n,1)],
                 -2:2, n, n);
 endfunction
 
 function T = tridiag (n, x = -1, y = 2, z = -1)
@@ -2421,16 +2561,57 @@ function t = triw (n, alpha = -1, k = -1
   endif
 
   m = n(1);              # Parameter n specifies dimension: m-by-n.
   n = n(end);
 
   t = tril (eye (m, n) + alpha * triu (ones (m, n), 1), k);
 endfunction
 
+function A = uniformdata (varargin)
+
+  if (nargin < 2)
+    error ("gallery: At least 2 arguments required for uniformdata matrix.");
+  endif
+  if (isnumeric (varargin{end}))
+    jidx = varargin{end};
+    svec = [varargin{:}];
+    varargin(end) = [];
+  elseif (ischar (varargin{end}))
+    if (nargin < 3)
+      error (["gallery: CLASS argument requires 3 inputs " ...
+              "for uniformdata matrix."]);
+    endif
+    jidx = varargin{end-1};
+    svec = [varargin{1:end-1}];
+    varargin(end-1) = [];
+  else 
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for uniformdata matrix"]);
+  endif
+
+  if (! (isnumeric (jidx) && isscalar (jidx)
+         && jidx == fix (jidx)
+         && jidx >= 0 && jidx <= 0xFFFFFFFF))
+    error (["gallery: J must be an integer in the range [0, 2^32-1] " ...
+            "for uniformdata matrix"]);
+  endif
+
+  ## Save and restore random state.  Initialization done so that reproducible
+  ## data is available from gallery depending on the jidx and size vector.
+  randstate = rand ("state"); 
+  unwind_protect
+    rand ("state", svec);
+    A = rand (varargin{:});
+  unwind_protect_cleanup
+    rand ("state", randstate);
+  end_unwind_protect
+
+endfunction
+
 function A = wathen (nx, ny, k = 0)
   ## # WATHEN returns the Wathen matrix.
   ##
   ##   Discussion:
   ##
   ##     The Wathen matrix is a finite element matrix which is sparse.
   ##
   ##     The entries of the matrix depend in part on a physical quantity
@@ -2666,8 +2847,9 @@ function A = bandred (A, kl, ku)
       A(j,j+ku+1:n) = zeros (1, n-j-ku);
     endif
   endfor
 
   if (flip)
     A = A';
   endif
 endfunction
+
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -91,18 +91,18 @@ function retval = toeplitz (c, r)
   ## Hermitian-symmetric matrix (actually, this will really only be
   ## Hermitian-symmetric if the first element of the vector is real).
   if (nargin == 1 && iscomplex (c))
     c = conj (c);
     c(1) = conj (c(1));
   endif
 
   if (issparse (c) && issparse (r))
-    c = c(:).';  ## enforce row vector
-    r = r(:).';  ## enforce row vector
+    c = c(:).';  # enforce row vector
+    r = r(:).';  # enforce row vector
     cidx = find (c);
     ridx = find (r);
 
     ## Ignore the first element in r.
     ridx = ridx(ridx > 1);
 
     ## Form matrix.
     retval = spdiags (repmat (c(cidx),nr,1),1-cidx,nr,nc) + ...
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -35,8 +35,9 @@ function __finish__ ()
   endif
 
 endfunction
 
 
 
 ## No test needed for internal helper function.
 %!assert (1)
+
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -34,23 +34,23 @@
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
 ##
 ## The optional argument @var{opt} selects the type of mean to compute.
 ## The following options are recognized:
 ##
 ## @table @asis
-## @item "a"
+## @item @qcode{"a"}
 ## Compute the (ordinary) arithmetic mean.  [default]
 ##
-## @item "g"
+## @item @qcode{"g"}
 ## Compute the geometric mean.
 ##
-## @item "h"
+## @item @qcode{"h"}
 ## Compute the harmonic mean.
 ## @end table
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
 ## Both @var{dim} and @var{opt} are optional.  If both are supplied,
 ## either may appear first.
 ## @seealso{median, mode}
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -40,51 +40,51 @@
 ##
 ## If @var{x} is a matrix, return the row vector containing the
 ## @var{p}-th moment of each column.
 ##
 ## The optional string @var{type} specifies the type of moment to be computed.
 ## Valid options are:
 ##
 ## @table @asis
-## @item "c"
+## @item @qcode{"c"}
 ##   Central Moment.  The moment about the mean defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N (x_i - \bar{x})^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## 1/N SUM_i (x(i) - mean(x))^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## @item "a"
+## @item @qcode{"a"}
 ##   Absolute Moment.  The moment about zero ignoring sign defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N {\left| x_i \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## 1/N SUM_i ( abs (x(i)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## @item "ac"
+## @item @qcode{"ac"}
 ##   Absolute Central Moment.  Defined as
 ## @tex
 ## $$
 ## {\sum_{i=1}^N {\left| x_i - \bar{x} \right|}^p \over N}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -92,8 +92,9 @@ function [q, s] = qqplot (x, dist, varar
 
   if (nargout == 0)
     plot (q, s);
     xlabel (q_label);
     ylabel ("sample points");
   endif
 
 endfunction
+
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -55,19 +55,19 @@ function cdf = binocdf (x, n, p)
   cdf(k) = NaN;
 
   k = (x >= n) & (n >= 0) & (n == fix (n) & (p >= 0) & (p <= 1));
   cdf(k) = 1;
 
   k = (x >= 0) & (x < n) & (n == fix (n)) & (p >= 0) & (p <= 1);
   tmp = floor (x(k));
   if (isscalar (n) && isscalar (p))
-    cdf(k) = 1 - betainc (p, tmp + 1, n - tmp);
+    cdf(k) = betainc (1 - p, n - tmp, tmp + 1);
   else
-    cdf(k) = 1 - betainc (p(k), tmp + 1, n(k) - tmp);
+    cdf(k) = betainc (1 .- p(k), n(k) - tmp, tmp + 1);
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/4 3/4 1 1];
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -16,16 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} geocdf (@var{x}, @var{p})
 ## For each element of @var{x}, compute the cumulative distribution function
 ## (CDF) at @var{x} of the geometric distribution with parameter @var{p}.
+##
+## The geometric distribution models the number of failures (@var{x}-1) of a
+## Bernoulli trial with probability @var{p} before the first success (@var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the geometric distribution
 
 function cdf = geocdf (x, p)
 
   if (nargin != 2)
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -16,16 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} geoinv (@var{x}, @var{p})
 ## For each element of @var{x}, compute the quantile (the inverse of
 ## the CDF) at @var{x} of the geometric distribution with parameter @var{p}.
+##
+## The geometric distribution models the number of failures (@var{x}-1) of a
+## Bernoulli trial with probability @var{p} before the first success (@var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the geometric distribution
 
 function inv = geoinv (x, p)
 
   if (nargin != 2)
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -16,16 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} geopdf (@var{x}, @var{p})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the geometric distribution with parameter @var{p}.
+##
+## The geometric distribution models the number of failures (@var{x}-1) of a
+## Bernoulli trial with probability @var{p} before the first success (@var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the geometric distribution
 
 function pdf = geopdf (x, p)
 
   if (nargin != 2)
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -28,16 +28,19 @@
 ## When called with a single size argument, return a square matrix with
 ## the dimension specified.  When called with more than one scalar argument the
 ## first two arguments are taken as the number of rows and columns and any
 ## further arguments specify additional matrix dimensions.  The size may also
 ## be specified with a vector of dimensions @var{sz}.
 ## 
 ## If no size arguments are given then the result matrix is the size of
 ## @var{p}.
+##
+## The geometric distribution models the number of failures (@var{x}-1) of a
+## Bernoulli trial with probability @var{p} before the first success (@var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 function rnd = geornd (p, varargin)
 
   if (nargin < 1)
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -49,23 +49,23 @@ function cdf = normcdf (x, mu = 0, sigma
 
   if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"));
     cdf = zeros (size (x), "single");
   else
     cdf = zeros (size (x));
   endif
 
   if (isscalar (mu) && isscalar (sigma))
-    if (!isinf (mu) && !isnan (mu) && (sigma > 0) && (sigma < Inf))
+    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
       cdf = stdnormal_cdf ((x - mu) / sigma);
     else
       cdf = NaN (size (x), class (cdf));
     endif
   else
-    k = isinf (mu) | isnan (mu) | !(sigma > 0) | !(sigma < Inf);
+    k = ! isfinite (mu) | !(sigma > 0) | !(sigma < Inf);
     cdf(k) = NaN;
 
     k = ! k;
     cdf(k) = stdnormal_cdf ((x(k) - mu(k)) ./ sigma(k));
   endif
 
 endfunction
 
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -49,21 +49,21 @@ function inv = norminv (x, mu = 0, sigma
 
   if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
     inv = NaN (size (x), "single");
   else
     inv = NaN (size (x));
   endif
 
   if (isscalar (mu) && isscalar (sigma))
-    if (!isinf (mu) && !isnan (mu) && (sigma > 0) && (sigma < Inf))
+    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
       inv =  mu + sigma * stdnormal_inv (x);
     endif
   else
-    k = !isinf (mu) & !isnan (mu) & (sigma > 0) & (sigma < Inf);
+    k = isfinite (mu) & (sigma > 0) & (sigma < Inf);
     inv(k) = mu(k) + sigma(k) .* stdnormal_inv (x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -49,17 +49,17 @@ function pdf = normpdf (x, mu = 0, sigma
 
   if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
     pdf = zeros (size (x), "single");
   else
     pdf = zeros (size (x));
   endif
 
   if (isscalar (mu) && isscalar (sigma))
-    if (!isinf (mu) && !isnan (mu) && (sigma > 0) && (sigma < Inf))
+    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
       pdf = stdnormal_pdf ((x - mu) / sigma) / sigma;
     else
       pdf = NaN (size (x), class (pdf));
     endif
   else
     k = isinf (mu) | !(sigma > 0) | !(sigma < Inf);
     pdf(k) = NaN;
 
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -78,24 +78,24 @@ function rnd = normrnd (mu, sigma, varar
 
   if (isa (mu, "single") || isa (sigma, "single"))
     cls = "single";
   else
     cls = "double";
   endif
 
   if (isscalar (mu) && isscalar (sigma))
-    if (!isnan (mu) && !isinf (mu) && (sigma > 0) && (sigma < Inf))
+    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
       rnd =  mu + sigma * randn (sz, cls);
     else
       rnd = NaN (sz, cls);
     endif
   else
     rnd = mu + sigma .* randn (sz, cls);
-    k = isnan (mu) | isinf (mu) | !(sigma > 0) | !(sigma < Inf);
+    k = ! isfinite (mu) | !(sigma > 0) | !(sigma < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
 %!assert (size (normrnd (1,2)), [1, 1])
 %!assert (size (normrnd (ones (2,1), 2)), [2, 1])
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -1,8 +1,9 @@
+## Copyright (C) 2013 Julien Bect
 ## Copyright (C) 2012 Rik Wehbring
 ## Copyright (C) 1995-2012 Kurt Hornik
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
@@ -46,21 +47,36 @@ function cdf = tcdf (x, n)
 
   if (isa (x, "single") || isa (n, "single"))
     cdf = zeros (size (x), "single");
   else
     cdf = zeros (size (x));
   endif
 
   k = !isinf (x) & (n > 0);
+
+  xx = x .^ 2;
+  x_big_abs = (xx > n);
+
+  ## deal with the case "abs(x) big"
+  kk = k & x_big_abs;
   if (isscalar (n))
-    cdf(k) = betainc (1 ./ (1 + x(k) .^ 2 / n), n/2, 1/2) / 2;
+    cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;
   else
-    cdf(k) = betainc (1 ./ (1 + x(k) .^ 2 ./ n(k)), n(k)/2, 1/2) / 2;
+    cdf(kk) = betainc (n(kk) ./ (n(kk) + xx(kk)), n(kk)/2, 1/2) / 2;
   endif
+
+  ## deal with the case "abs(x) small"
+  kk = k & !x_big_abs;
+  if (isscalar (n))
+    cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n + xx(kk)), 1/2, n/2));
+  else
+    cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n(kk) + xx(kk)), 1/2, n(kk)/2));
+  endif
+
   k &= (x > 0);
   if (any (k(:)))
     cdf(k) = 1 - cdf(k);
   endif
 
   k = isnan (x) | !(n > 0);
   cdf(k) = NaN;
 
@@ -87,8 +103,58 @@ endfunction
 %!error tcdf ()
 %!error tcdf (1)
 %!error tcdf (1,2,3)
 %!error tcdf (ones (3), ones (2))
 %!error tcdf (ones (2), ones (3))
 %!error tcdf (i, 2)
 %!error tcdf (2, i)
 
+## Check some reference values
+
+%!shared tol_rel
+%! tol_rel = 10 * eps;
+
+## check accuracy for small positive values
+%!assert (tcdf (10^(-10), 2.5), 0.50000000003618087, -tol_rel)
+%!assert (tcdf (10^(-11), 2.5), 0.50000000000361809, -tol_rel)
+%!assert (tcdf (10^(-12), 2.5), 0.50000000000036181, -tol_rel)
+%!assert (tcdf (10^(-13), 2.5), 0.50000000000003618, -tol_rel)
+%!assert (tcdf (10^(-14), 2.5), 0.50000000000000362, -tol_rel)
+%!assert (tcdf (10^(-15), 2.5), 0.50000000000000036, -tol_rel)
+%!assert (tcdf (10^(-16), 2.5), 0.50000000000000004, -tol_rel)
+
+## check accuracy for large negative values
+%!assert (tcdf (-10^1, 2.5), 2.2207478836537124e-03, -tol_rel)
+%!assert (tcdf (-10^2, 2.5), 7.1916492116661878e-06, -tol_rel)
+%!assert (tcdf (-10^3, 2.5), 2.2747463948307452e-08, -tol_rel)
+%!assert (tcdf (-10^4, 2.5), 7.1933970159922115e-11, -tol_rel)
+%!assert (tcdf (-10^5, 2.5), 2.2747519231756221e-13, -tol_rel)
+
+## # Reference values obtained using Python 2.7.4 and mpmath 0.17
+##
+## from mpmath import *
+##
+## mp.dps = 100
+##
+## def F(x_in, nu_in):
+##     x = mpf(x_in);
+##     nu = mpf(nu_in);
+##     t = nu / (nu + x*x)
+##     a = nu / 2
+##     b = mpf(0.5)
+##     F = betainc(a, b, 0, t, regularized=True) / 2
+##     if (x > 0):
+##         F = 1 - F
+##     return F
+##
+## nu = 2.5
+##
+## for i in range(1, 6):
+##     x = - power(mpf(10), mpf(i))
+##     print "%%!assert (tcdf (-10^%d, 2.5), %s, -eps)" \
+##         % (i, nstr(F(x, nu), 17))
+##
+## for i in range(10, 17):
+##     x = power(mpf(10), -mpf(i))
+##     print "%%!assert (tcdf (10^(-%d), 2.5), %s, -eps)" \
+##         % (i, nstr(F(x, nu), 17))
+
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -48,17 +48,17 @@ function pdf = tpdf (x, n)
     pdf = zeros (size (x), "single");
   else
     pdf = zeros (size (x));
   endif
 
   k = isnan (x) | !(n > 0) | !(n < Inf);
   pdf(k) = NaN;
 
-  k = !isinf (x) & !isnan (x) & (n > 0) & (n < Inf);
+  k = isfinite (x) & (n > 0) & (n < Inf);
   if (isscalar (n))
     pdf(k) = (exp (- (n + 1) * log (1 + x(k) .^ 2 / n)/2)
               / (sqrt (n) * beta (n/2, 1/2)));
   else
     pdf(k) = (exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k))/2)
               ./ (sqrt (n(k)) .* beta (n(k)/2, 1/2)));
   endif
 
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -47,8 +47,9 @@ function retval = wienrnd (t, d, n)
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
 
   retval = [((1: n*t)' / n), retval];
 
 endfunction
+
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -185,8 +185,9 @@ function [theta, beta, dev, dl, d2l, p] 
       e = ((x * beta) * ones (1, nz)) + ((y * 0 + 1) * theta');
     else
       e = (y * 0 + 1) * theta';
     endif
     gamma = diff ([(y * 0), (exp (e) ./ (1 + exp (e))), (y * 0 + 1)]')';
   endif
 
 endfunction
+
diff --git a/scripts/statistics/models/private/logistic_regression_derivatives.m b/scripts/statistics/models/private/logistic_regression_derivatives.m
--- a/scripts/statistics/models/private/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/private/logistic_regression_derivatives.m
@@ -25,23 +25,20 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p)
 
-  if (nargin != 6)
-    print_usage ();
-  endif
-
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
   dlogp = [(diag (v) * z - diag (v1) * z1), (diag (v - v1) * x)];
   dl = sum (dlogp)';
 
   ## second derivative
   w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
   d2l = [z, x]' * diag (w) * [z, x] - [z1, x]' * diag (w1) * [z1, x] ...
       - dlogp' * dlogp;
 
 endfunction
+
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/private/logistic_regression_likelihood.m
@@ -24,20 +24,17 @@
 ## @end deftypefn
 
 ## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Likelihood in logistic regression
 
 function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
 
-  if (nargin != 5)
-    print_usage ();
-  endif
-
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min (y), g1);
 
   p = g - g1;
   dev = -2 * sum (log (p));
 
 endfunction
+
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -103,8 +103,9 @@ function [pval, f, df_b, df_w] = anova (
     printf ("Total                %15.4f  %4d\n", SST, n - 1);
     printf ("\n");
     printf ("Test Statistic f     %15.4f\n", f);
     printf ("p-value              %15.4f\n", pval);
     printf ("\n");
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -60,8 +60,9 @@ function [pval, chisq, df] = bartlett_te
   df    = k;
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -61,8 +61,9 @@ function [pval, chisq, df] = chisquare_t
   chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -46,8 +46,9 @@ function [pval, chisq, df] = chisquare_t
   chisq = sum (sum (x));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -17,28 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cor_test (@var{x}, @var{y}, @var{alt}, @var{method})
 ## Test whether two samples @var{x} and @var{y} come from uncorrelated
 ## populations.
 ##
 ## The optional argument string @var{alt} describes the alternative
-## hypothesis, and can be @code{"!="} or @code{"<>"} (non-zero),
-## @code{">"} (greater than 0), or @code{"<"} (less than 0).  The
+## hypothesis, and can be @qcode{"!="} or @qcode{"<>"} (non-zero),
+## @qcode{">"} (greater than 0), or @qcode{"<"} (less than 0).  The
 ## default is the two-sided case.
 ##
 ## The optional argument string @var{method} specifies which
 ## correlation coefficient to use for testing.  If @var{method} is
-## @code{"pearson"} (default), the (usual) Pearson's product moment
+## @qcode{"pearson"} (default), the (usual) Pearson's product moment
 ## correlation coefficient is used.  In this case, the data should come
 ## from a bivariate normal distribution.  Otherwise, the other two
 ## methods offer nonparametric alternatives.  If @var{method} is
-## @code{"kendall"}, then Kendall's rank correlation tau is used.  If
-## @var{method} is @code{"spearman"}, then Spearman's rank correlation
+## @qcode{"kendall"}, then Kendall's rank correlation tau is used.  If
+## @var{method} is @qcode{"spearman"}, then Spearman's rank correlation
 ## rho is used.  Only the first character is necessary.
 ##
 ## The output is a structure with the following elements:
 ##
 ## @table @var
 ## @item pval
 ## The p-value of the test.
 ##
@@ -128,8 +128,9 @@ function t = cor_test (x, y, alt, method
 
   t.alternative = alt;
 
   if (nargout == 0)
     printf ("pval: %g\n", t.pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -70,8 +70,9 @@ function [pval, f, df_num, df_den] = f_t
   f      = diff' * inv (rr * inv (x' * x) * rr') * diff / (q * v);
   pval  = 1 - fcdf (f, df_num, df_den);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -65,8 +65,9 @@ function [pval, Tsq] = hotelling_test (x
   Tsq  = n * d * (cov (x) \ d');
   pval = 1 - fcdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -79,8 +79,9 @@ function [pval, Tsq] = hotelling_test_2 
   pval = 1 - fcdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
                     p, n_x + n_y - p - 1);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -31,21 +31,21 @@
 ## kolmogorov_smirnov_test (x, "unif", 2, 4)
 ## @end example
 ##
 ## @noindent
 ## @var{dist} can be any string for which a function @var{dist_cdf}
 ## that calculates the CDF of distribution @var{dist} exists.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative F
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative F
 ## != G@.  In this case, the test statistic @var{ks} follows a two-sided
-## Kolmogorov-Smirnov distribution.  If @var{alt} is @code{">"}, the
-## one-sided alternative F > G is considered.  Similarly for @code{"<"},
+## Kolmogorov-Smirnov distribution.  If @var{alt} is @qcode{">"}, the
+## one-sided alternative F > G is considered.  Similarly for @qcode{"<"},
 ## the one-sided alternative F > G is considered.  In this case, the
 ## test statistic @var{ks} has a one-sided Kolmogorov-Smirnov
 ## distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
@@ -116,12 +116,12 @@ endfunction
 ## test for recognition of logistic_cdf function
 %!assert (kolmogorov_smirnov_test (0:100, "logistic"), 0)
 ## test for  F < G
 %!assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"))
 
 %!error kolmogorov_smirnov_test (1)
 %!error <X must be a vector> kolmogorov_smirnov_test ({}, "unif", 2, 4)
 %!error <no not_a_distcdf or not_a_dist_cdf function found>
-%!  kolmogorov_smirnov_test (1, "not_a_dist");
+%! kolmogorov_smirnov_test (1, "not_a_dist");
 %!error <alternative foo not recognized>
-%!  kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
+%! kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -20,21 +20,21 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{ks}, @var{d}] =} kolmogorov_smirnov_test_2 (@var{x}, @var{y}, @var{alt})
 ## Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis
 ## that the samples @var{x} and @var{y} come from the same (continuous)
 ## distribution.  I.e., if F and G are the CDFs corresponding to the
 ## @var{x} and @var{y} samples, respectively, then the null is that F ==
 ## G.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative F
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative F
 ## != G@.  In this case, the test statistic @var{ks} follows a two-sided
-## Kolmogorov-Smirnov distribution.  If @var{alt} is @code{">"}, the
-## one-sided alternative F > G is considered.  Similarly for @code{"<"},
+## Kolmogorov-Smirnov distribution.  If @var{alt} is @qcode{">"}, the
+## one-sided alternative F > G is considered.  Similarly for @qcode{"<"},
 ## the one-sided alternative F < G is considered.  In this case, the
 ## test statistic @var{ks} has a one-sided Kolmogorov-Smirnov
 ## distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## The third returned value, @var{d}, is the test statistic, the maximum
 ## vertical distance between the two cumulative distribution functions.
@@ -97,8 +97,9 @@ function [pval, ks, d] = kolmogorov_smir
     error ("kolmogorov_smirnov_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{k}, @var{df}] =} kruskal_wallis_test (@var{x1}, @dots{})
-## Perform a Kruskal-Wallis one-factor "analysis of variance".
+## Perform a Kruskal-Wallis one-factor analysis of variance.
 ##
 ## Suppose a variable is observed for @var{k} > 1 different groups, and
 ## let @var{x1}, @dots{}, @var{xk} be the corresponding data vectors.
 ##
 ## Under the null hypothesis that the ranks in the pooled sample are not
 ## affected by the group memberships, the test statistic @var{k} is
 ## approximately chi-square with @var{df} = @var{k} - 1 degrees of
 ## freedom.
@@ -31,19 +31,20 @@
 ## If the data contains ties (some value appears more than once)
 ## @var{k} is divided by
 ##
 ## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
 ## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group
 ## of ties where @var{t} is the number of ties in the group and @var{n}
 ## is the total number of values in the input data.  For more info on
-## this adjustment see "Use of Ranks in One-Criterion Variance Analysis"
-## in Journal of the American Statistical Association, Vol. 47,
-## No. 260 (Dec 1952) by William H. Kruskal and W. Allen Wallis.
+## this adjustment see William H. Kruskal and W. Allen Wallis,
+## @cite{Use of Ranks in One-Criterion Variance Analysis}, 
+## Journal of the American Statistical Association, Vol. 47,
+## No. 260 (Dec 1952).
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{k}) is
 ## returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
@@ -92,8 +93,9 @@ function [pval, k, df] = kruskal_wallis_
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
 
 ## Test with ties
 %!assert (abs (kruskal_wallis_test ([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
+
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -154,8 +154,9 @@ function manova (x, g)
   printf ("# of variables: %d\n", p);
   printf ("\n");
   printf ("Wilks' Lambda:  %5.4f\n", Lambda);
   printf ("Approximate p:  %10.9f (chisquare approximation)\n", W_pval_1);
   printf ("                 %10.9f (F approximation)\n", W_pval_2);
   printf ("\n");
 
 endfunction
+
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -58,10 +58,8 @@ function [pval, chisq, df] = mcnemar_tes
   pval = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
 
-
-
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -20,20 +20,20 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{z}] =} prop_test_2 (@var{x1}, @var{n1}, @var{x2}, @var{n2}, @var{alt})
 ## If @var{x1} and @var{n1} are the counts of successes and trials in
 ## one sample, and @var{x2} and @var{n2} those in a second one, test the
 ## null hypothesis that the success probabilities @var{p1} and @var{p2}
 ## are the same.  Under the null, the test statistic @var{z}
 ## approximately follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @var{p1} != @var{p2}.  If @var{alt} is @code{">"}, the one-sided
-## alternative @var{p1} > @var{p2} is used.  Similarly for @code{"<"},
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @var{p1} != @var{p2}.  If @var{alt} is @qcode{">"}, the one-sided
+## alternative @var{p1} > @var{p2} is used.  Similarly for @qcode{"<"},
 ## the one-sided alternative @var{p1} < @var{p2} is used.
 ## The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
@@ -73,8 +73,9 @@ function [pval, z] = prop_test_2 (x1, n1
     error ("prop_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -51,8 +51,9 @@ function [pval, chisq] = run_test (x)
   chisq = diag (r' * A * r)' / n;
   pval  = chi2cdf (chisq, 6);
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -20,22 +20,22 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{b}, @var{n}] =} sign_test (@var{x}, @var{y}, @var{alt})
 ## For two matched-pair samples @var{x} and @var{y}, perform a sign test
 ## of the null hypothesis PROB (@var{x} > @var{y}) == PROB (@var{x} <
 ## @var{y}) == 1/2.  Under the null, the test statistic @var{b} roughly
 ## follows a binomial distribution with parameters @code{@var{n} = sum
 ## (@var{x} != @var{y})} and @var{p} = 1/2.
 ##
 ## With the optional argument @code{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @code{"!="} or @code{"<>"}, the
+## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the
 ## null hypothesis is tested against the two-sided alternative PROB
-## (@var{x} < @var{y}) != 1/2.  If @var{alt} is @code{">"}, the
+## (@var{x} < @var{y}) != 1/2.  If @var{alt} is @qcode{">"}, the
 ## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 ("x is
 ## stochastically greater than y") is considered.  Similarly for
-## @code{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) < 1/2
+## @qcode{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) < 1/2
 ## ("x is stochastically less than y") is considered.  The default is
 ## the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
@@ -76,8 +76,9 @@ function [pval, b, n] = sign_test (x, y,
     error ("sign_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -20,19 +20,19 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{t}, @var{df}] =} t_test (@var{x}, @var{m}, @var{alt})
 ## For a sample @var{x} from a normal distribution with unknown mean and
 ## variance, perform a t-test of the null hypothesis @code{mean
 ## (@var{x}) == @var{m}}.  Under the null, the test statistic @var{t}
 ## follows a Student distribution with @code{@var{df} = length (@var{x})
 ## - 1} degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @qcode{">"}, the
 ## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
 ## Similarly for @var{"<"}, the one-sided alternative @code{mean
 ## (@var{x}) < @var{m}} is considered.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
@@ -76,8 +76,9 @@ function [pval, t, df] = t_test (x, m, a
     error ("t_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -20,21 +20,21 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{t}, @var{df}] =} t_test_2 (@var{x}, @var{y}, @var{alt})
 ## For two samples x and y from normal distributions with unknown means
 ## and unknown equal variances, perform a two-sample t-test of the null
 ## hypothesis of equal means.  Under the null, the test statistic
 ## @var{t} follows a Student distribution with @var{df} degrees of
 ## freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{mean (@var{x}) != mean (@var{y})}.  If @var{alt} is @code{">"},
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{mean (@var{x}) != mean (@var{y})}.  If @var{alt} is @qcode{">"},
 ## the one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is
-## used.  Similarly for @code{"<"}, the one-sided alternative @code{mean
+## used.  Similarly for @qcode{"<"}, the one-sided alternative @code{mean
 ## (@var{x}) < mean (@var{y})} is used.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
@@ -77,8 +77,9 @@ function [pval, t, df] = t_test_2 (x, y,
     error ("t_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -22,19 +22,19 @@
 ## @nospell{@code{@var{rr} * @var{b} = @var{r}}} in a classical normal
 ## regression model @code{@var{y} = @var{x} * @var{b} + @var{e}}.  Under the
 ## null, the test statistic @var{t} follows a @var{t} distribution with
 ## @var{df} degrees of freedom.
 ##
 ## If @var{r} is omitted, a value of 0 is assumed.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @nospell{@code{@var{rr} * @var{b} != @var{r}}}.  If @var{alt} is @code{">"},
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @nospell{@code{@var{rr} * @var{b} != @var{r}}}.  If @var{alt} is @qcode{">"},
 ## the one-sided alternative
 ## @nospell{@code{@var{rr} * @var{b} > @var{r}}} is used.  Similarly for
 ## @var{"<"}, the one-sided alternative
 ## @nospell{@code{@var{rr} * @var{b} < @var{r}}} is used.  The default is the
 ## two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
@@ -92,8 +92,9 @@ function [pval, t, df] = t_test_regressi
     error ("t_test_regression: the value '%s' for alt is not possible", alt);
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -20,21 +20,21 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{z}] =} u_test (@var{x}, @var{y}, @var{alt})
 ## For two samples @var{x} and @var{y}, perform a Mann-Whitney U-test of
 ## the null hypothesis PROB (@var{x} > @var{y}) == 1/2 == PROB (@var{x}
 ## < @var{y}).  Under the null, the test statistic @var{z} approximately
 ## follows a standard normal distribution.  Note that this test is
 ## equivalent to the Wilcoxon rank-sum test.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## PROB (@var{x} > @var{y}) != 1/2.  If @var{alt} is @code{">"}, the
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## PROB (@var{x} > @var{y}) != 1/2.  If @var{alt} is @qcode{">"}, the
 ## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 is considered.
-## Similarly for @code{"<"}, the one-sided alternative PROB (@var{x} >
+## Similarly for @qcode{"<"}, the one-sided alternative PROB (@var{x} >
 ## @var{y}) < 1/2 is considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## This implementation is still incomplete---for small sample sizes,
@@ -78,8 +78,9 @@ function [pval, z] = u_test (x, y, alt)
     error ("u_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -20,19 +20,19 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{f}, @var{df_num}, @var{df_den}] =} var_test (@var{x}, @var{y}, @var{alt})
 ## For two samples @var{x} and @var{y} from normal distributions with
 ## unknown means and unknown variances, perform an F-test of the null
 ## hypothesis of equal variances.  Under the null, the test statistic
 ## @var{f} follows an F-distribution with @var{df_num} and @var{df_den}
 ## degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{var (@var{x}) != var (@var{y})}.  If @var{alt} is @code{">"},
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{var (@var{x}) != var (@var{y})}.  If @var{alt} is @qcode{">"},
 ## the one-sided alternative @code{var (@var{x}) > var (@var{y})} is
 ## used.  Similarly for "<", the one-sided alternative @code{var
 ## (@var{x}) > var (@var{y})} is used.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
@@ -73,8 +73,9 @@ function [pval, f, df_num, df_den] = var
     error ("var_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -20,21 +20,21 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{t}, @var{df}] =} welch_test (@var{x}, @var{y}, @var{alt})
 ## For two samples @var{x} and @var{y} from normal distributions with
 ## unknown means and unknown and not necessarily equal variances,
 ## perform a Welch test of the null hypothesis of equal means.
 ## Under the null, the test statistic @var{t} approximately follows a
 ## Student distribution with @var{df} degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @qcode{">"}, the
 ## one-sided alternative mean(x) > @var{m} is considered.  Similarly for
-## @code{"<"}, the one-sided alternative mean(x) < @var{m} is
+## @qcode{"<"}, the one-sided alternative mean(x) < @var{m} is
 ## considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
@@ -78,8 +78,9 @@ function [pval, t, df] = welch_test (x, 
     error ("welch_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -22,21 +22,21 @@
 ## Wilcoxon signed-rank test of the null hypothesis PROB (@var{x} >
 ## @var{y}) == 1/2.  Under the null, the test statistic @var{z}
 ## approximately follows a standard normal distribution when @var{n} > 25.
 ##
 ## @strong{Caution:} This function assumes a normal distribution for @var{z}
 ## and thus is invalid for @var{n} @leq{} 25.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## PROB (@var{x} > @var{y}) != 1/2.  If alt is @code{">"}, the one-sided
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## PROB (@var{x} > @var{y}) != 1/2.  If alt is @qcode{">"}, the one-sided
 ## alternative PROB (@var{x} > @var{y}) > 1/2 is considered.  Similarly
-## for @code{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) <
+## for @qcode{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) <
 ## 1/2 is considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
@@ -84,8 +84,9 @@ function [pval, z] = wilcoxon_test (x, y
     error ("wilcoxon_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -19,21 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{z}] =} z_test (@var{x}, @var{m}, @var{v}, @var{alt})
 ## Perform a Z-test of the null hypothesis @code{mean (@var{x}) ==
 ## @var{m}} for a sample @var{x} from a normal distribution with unknown
 ## mean and known variance @var{v}.  Under the null, the test statistic
 ## @var{z} follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @qcode{">"}, the
 ## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
-## Similarly for @code{"<"}, the one-sided alternative @code{mean
+## Similarly for @qcode{"<"}, the one-sided alternative @code{mean
 ## (@var{x}) < @var{m}} is considered.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
@@ -73,15 +73,16 @@ function [pval, z] = z_test (x, m, v, al
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = cstrcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
-                 "with known var(x) == %g:\n",
-                 "  pval = %g\n");
+    s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", ...
+         "with known var(x) == %g:\n",                       ...
+         "  pval = %g\n"];
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
+
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -19,21 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{z}] =} z_test_2 (@var{x}, @var{y}, @var{v_x}, @var{v_y}, @var{alt})
 ## For two samples @var{x} and @var{y} from normal distributions with
 ## unknown means and known variances @var{v_x} and @var{v_y}, perform a
 ## Z-test of the hypothesis of equal means.  Under the null, the test
 ## statistic @var{z} follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
-## interest can be selected.  If @var{alt} is @code{"!="} or
-## @code{"<>"}, the null is tested against the two-sided alternative
-## @code{mean (@var{x}) != mean (@var{y})}.  If alt is @code{">"}, the
+## interest can be selected.  If @var{alt} is @qcode{"!="} or
+## @qcode{"<>"}, the null is tested against the two-sided alternative
+## @code{mean (@var{x}) != mean (@var{y})}.  If alt is @qcode{">"}, the
 ## one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is used.
-## Similarly for @code{"<"}, the one-sided alternative @code{mean
+## Similarly for @qcode{"<"}, the one-sided alternative @code{mean
 ## (@var{x}) < mean (@var{y})} is used.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
@@ -73,16 +73,17 @@ function [pval, z] = z_test_2 (x, y, v_x
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = cstrcat ("Two-sample Z-test of mean(x) == mean(y) against ",
-                 "mean(x) %s mean(y),\n",
-                 "with known var(x) == %g and var(y) == %g:\n",
-                 "  pval = %g\n");
+    s = ["Two-sample Z-test of mean(x) == mean(y) against ", ...
+         "mean(x) %s mean(y),\n",                            ...
+         "with known var(x) == %g and var(y) == %g:\n",      ...
+         "  pval = %g\n"];
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
+
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -25,17 +25,17 @@
 ## @group
 ## base2dec ("11120", 3)
 ##    @result{} 123
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, return a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
-## corresponding value will be NaN@.  
+## corresponding value will be NaN@.
 ##
 ## If @var{s} is a cell array of strings, return a column vector with one
 ## value per cell element in @var{s}.
 ##
 ## If @var{base} is a string, the characters of @var{base} are used as the
 ## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -57,17 +57,17 @@ function retval = dec2base (d, base, len
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (iscell (d))
     d = cell2mat (d);
   endif
 
-  # Create column vector for algorithm
+  ## Create column vector for algorithm
   if (! iscolumn (d))
     d = d(:);
   endif
   
   ## Treat logical as numeric for compatibility with ML
   if (islogical (d))
     d = double (d);
   elseif (! isnumeric (d) || iscomplex (d) || any (d < 0 | d != fix (d)))
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -27,18 +27,18 @@
 ##
 ## @example
 ## @group
 ## index ("Teststring", "t")
 ##     @result{} 4
 ## @end group
 ## @end example
 ##
-## If @var{direction} is @samp{"first"}, return the first element found.
-## If @var{direction} is @samp{"last"}, return the last element found.
+## If @var{direction} is @qcode{"first"}, return the first element found.
+## If @var{direction} is @qcode{"last"}, return the last element found.
 ##
 ## @seealso{find, rindex}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 ## This is patterned after the AWK function of the same name.
 
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -30,55 +30,55 @@
 ## If @var{str} is a cell array, @code{isstrpop} is applied recursively
 ## to each element of the cell array.
 ##
 ## Numeric arrays are converted to character strings.
 ##
 ## The second argument @var{prop} must be one of
 ##
 ## @table @asis
-## @item "alpha"
+## @item @qcode{"alpha"}
 ## True for characters that are alphabetic (letters).
 ##
-## @item "alnum"
-## @itemx "alphanum"
+## @item  @qcode{"alnum"}
+## @itemx @qcode{"alphanum"}
 ## True for characters that are alphabetic or digits.
 ##
-## @item "lower"
+## @item @qcode{"lower"}
 ## True for lowercase letters.
 ##
-## @item "upper"
+## @item @qcode{"upper"}
 ## True for uppercase letters.
 ##
-## @item "digit"
+## @item @qcode{"digit"}
 ## True for decimal digits (0-9).
 ##
-## @item "xdigit"
+## @item @qcode{"xdigit"}
 ## True for hexadecimal digits (@nospell{a-fA-F0-9}).
 ##
-## @item "space"
-## @itemx "wspace"
+## @item  @qcode{"space"}
+## @itemx @qcode{"wspace"}
 ## True for whitespace characters (space, formfeed, newline, carriage
 ## return, tab, vertical tab).
 ##
-## @item "punct"
+## @item @qcode{"punct"}
 ## True for punctuation characters (printing characters except space
 ## or letter or digit).
 ##
-## @item "cntrl"
+## @item @qcode{"cntrl"}
 ## True for control characters.
 ##
-## @item "graph"
-## @itemx "graphic"
+## @item  @qcode{"graph"}
+## @itemx @qcode{"graphic"}
 ## True for printing characters except space.
 ##
-## @item "print"
+## @item @qcode{"print"}
 ## True for printing characters including space.
 ##
-## @item "ascii"
+## @item @qcode{"ascii"}
 ## True for characters that are in the range of ASCII encoding.
 ##
 ## @end table
 ##
 ## @seealso{isalpha, isalnum, islower, isupper, isdigit, isxdigit,
 ## isspace, ispunct, iscntrl, isgraph, isprint, isascii}
 ## @end deftypefn
 
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -24,17 +24,17 @@
 ## the @code{eval} function.
 ##
 ## The precision of the values is given by @var{n}.  If @var{n} is a
 ## scalar then both real and imaginary parts of the matrix are printed
 ## to the same precision.  Otherwise @code{@var{n}(1)} defines the
 ## precision of the real part and @code{@var{n}(2)} defines the
 ## precision of the imaginary part.  The default for @var{n} is 15.
 ##
-## If the argument "class" is given then the class of @var{x} is
+## If the argument @qcode{"class"} is given then the class of @var{x} is
 ## included in the string in such a way that @code{eval} will result in the
 ## construction of a matrix of the same class.
 ##
 ## @example
 ## @group
 ## mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
 ##      @result{} "[-0.3333+0.14i;0.3333-0.14i]"
 ##
@@ -98,36 +98,36 @@ function s = mat2str (x, n = 15, cls = "
       s = sprintf (fmt, real (x), imag (x));
     elseif (x_islogical)
       s = v{x+1};
     else
       s = sprintf (fmt, x);
     endif
   else
     ## Non-scalar X, print brackets
-    fmt = cstrcat (fmt, " ");
+    fmt = [fmt " "];
     if (x_iscomplex)
       t = x.';
       s = sprintf (fmt, [real(t(:))'; imag(t(:))']);
     elseif (x_islogical)
       t = v(x+1);
       s = cstrcat (sprintf (fmt, t{:}));
     else
       s = sprintf (fmt, x.');
     endif
 
-    s = cstrcat ("[", s);
+    s = ["[" s];
     s(end) = "]";
     idx = strfind (s, " ");
     nc = columns (x);
     s(idx(nc:nc:end)) = ";";
   endif
 
   if (strcmp ("class", cls))
-    s = cstrcat (class (x), "(", s, ")");
+    s = [class(x) "(" s ")"];
   endif
 
 endfunction
 
 
 %!assert (mat2str (0.7), "0.7")
 %!assert (mat2str (pi), "3.14159265358979")
 %!assert (mat2str (pi, 5), "3.1416")
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -19,29 +19,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} regexptranslate (@var{op}, @var{s})
 ## Translate a string for use in a regular expression.  This may
 ## include either wildcard replacement or special character escaping.
 ## The behavior is controlled by @var{op} which can take the following
 ## values
 ##
 ## @table @asis
-## @item "wildcard"
+## @item @qcode{"wildcard"}
 ## The wildcard characters @code{.}, @code{*}, and @code{?} are replaced
 ## with wildcards that are appropriate for a regular expression.
 ## For example:
 ##
 ## @example
 ## @group
 ## regexptranslate ("wildcard", "*.m")
 ##      @result{} ".*\.m"
 ## @end group
 ## @end example
 ##
-## @item "escape"
+## @item @qcode{"escape"}
 ## The characters @code{$.?[]}, that have special meaning for regular
 ## expressions are escaped so that they are treated literally.  For example:
 ##
 ## @example
 ## @group
 ## regexptranslate ("escape", "12.5")
 ##      @result{} "12\.5"
 ## @end group
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -27,17 +27,17 @@
 ## @example
 ## @group
 ## rindex ("Teststring", "t")
 ##      @result{} 6
 ## @end group
 ## @end example
 ##
 ## The @code{rindex} function is equivalent to @code{index} with
-## @var{direction} set to @samp{"last"}.
+## @var{direction} set to @qcode{"last"}.
 ##
 ## @seealso{find, index}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 ## This is patterned after the AWK function of the same name.
 
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -37,17 +37,17 @@
 ## conversion is successful.  If the conversion fails the numeric output,
 ## @var{x}, is empty and @var{state} is false.
 ##
 ## @strong{Caution:} As @code{str2num} uses the @code{eval} function
 ## to do the conversion, @code{str2num} will execute any code contained
 ## in the string @var{s}.  Use @code{str2double} for a safer and faster
 ## conversion.
 ##
-## For cell array of strings use @code{str2double}.  
+## For cell array of strings use @code{str2double}.
 ## @seealso{str2double, eval}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [m, state] = str2num (s)
 
   if (nargin != 1) 
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -15,29 +15,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
-## horizontally.  If the arguments are cells strings,  @code{strcat}
+## horizontally.  If the arguments are cell strings, @code{strcat}
 ## returns a cell string with the individual cells concatenated.
 ## For numerical input, each element is converted to the
-## corresponding ASCII character.  Trailing white space for each of
-## the inputs (@var{s1}, @var{S2}, @dots{}) is eliminated before they
-## are concatenated.
+## corresponding ASCII character.  Trailing white space for any
+## character string input is eliminated before the strings are
+## concatenated.  Note that cell string values do @strong{not} have
+## whitespace trimmed.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## strcat ("|", " leading space is preserved", "|")
-##     @result{} | leading space is perserved|
+##     @result{} | leading space is preserved|
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## strcat ("|", "trailing space is eliminated ", "|")
 ##     @result{} |trailing space is eliminated|
 ## @end group
@@ -57,72 +58,73 @@
 ##     @result{}
 ##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
-## s = @{ "ab"; "cde" @};
+## s = @{ "ab"; "cd " @};
 ## strcat (s, s, s)
 ##     @result{}
 ##         @{
 ##           [1,1] = ababab
-##           [2,1] = cdecdecde
+##           [2,1] = cd cd cd 
 ##         @}
 ## @end group
 ## @end example
 ##
 ## @seealso{cstrcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = strcat (varargin)
 
-  if (nargin > 0)
-    if (nargin == 1)
-      st = varargin{1};
-    elseif (nargin > 1)
-      ## Convert to cells of strings
-      uo = "uniformoutput";
-      reals = cellfun ("isreal", varargin);
-      if (any (reals))
-        varargin(reals) = cellfun ("char", varargin(reals), uo, false);
-      endif
-      chars = cellfun ("isclass", varargin, "char");
-      allchar = all (chars);
-      varargin(chars) = cellfun ("cellstr", varargin(chars), uo, false);
-      if (! all (cellfun ("isclass", varargin, "cell")))
-        error ("strcat: inputs must be strings or cells of strings");
-      endif
-
-      ## We don't actually need to bring all cells to common size, because
-      ## cellfun can now expand scalar cells.
-      err = common_size (varargin{:});
-
-      if (err)
-        error ("strcat: arguments must be the same size, or be scalars");
-      endif
-
-      ## Cellfun handles everything for us.
-      st = cellfun ("horzcat", varargin{:}, uo, false);
-
-      if (allchar)
-        ## If all inputs were strings, return strings.
-        st = char (st);
-      endif
-    endif
-  else
+  if (nargin == 0)
     print_usage ();
   endif
 
+  if (nargin == 1)
+    st = varargin{1};
+  else
+    ## Convert to cells of strings
+    uo = "uniformoutput";
+    reals = cellfun ("isreal", varargin);
+    if (any (reals))
+      varargin(reals) = cellfun ("char", varargin(reals), uo, false);
+    endif
+    chars = cellfun ("isclass", varargin, "char");
+    allchar = all (chars);
+    varargin(chars) = cellfun ("cellstr", varargin(chars), uo, false);
+    if (! all (cellfun ("isclass", varargin, "cell")))
+      error ("strcat: inputs must be strings or cells of strings");
+    endif
+
+    ## We don't actually need to bring all cells to common size, because
+    ## cellfun can now expand scalar cells.
+    err = common_size (varargin{:});
+
+    if (err)
+      error ("strcat: arguments must be the same size, or be scalars");
+    endif
+
+    ## Cellfun handles everything for us.
+    st = cellfun ("horzcat", varargin{:}, uo, false);
+
+    if (allchar)
+      ## If all inputs were strings, return strings.
+      st = char (st);
+    endif
+  endif
+
 endfunction
 
+
 ## test the dimensionality
 ## 1d
 %!assert (strcat ("ab ", "ab "), "abab")
 %!assert (strcat ({"ab "}, "ab "), {"ab ab"})
 %!assert (strcat ("ab ", {"ab "}), {"abab "})
 %!assert (strcat ({"ab "}, {"ab "}), {"ab ab "})
 %!assert (strcat ("", "ab"), "ab")
 %!assert (strcat ("", {"ab"}, {""}), {"ab"})
diff --git a/scripts/strings/strjoin.m b/scripts/strings/strjoin.m
--- a/scripts/strings/strjoin.m
+++ b/scripts/strings/strjoin.m
@@ -53,23 +53,23 @@ function rval = strjoin (cstr, delimiter
   elseif (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (! (iscellstr (cstr) && (ischar (delimiter) || iscellstr (delimiter))))
     print_usage ();
   endif
 
   if (numel (cstr) == 1)
     rval = cstr{1};
-    return
+    return;
   endif
 
   if (ischar (delimiter))
     delimiter = do_string_escapes (delimiter);
     delimiter = {delimiter};
-  end
+  endif
  
   num = numel (cstr); 
   if (numel (delimiter) == 1 && num > 1)
     delimiter = repmat (delimiter, 1, num);
     delimiter(end) = {""};
   elseif (num > 0 && numel (delimiter) != num - 1)
     error ("strjoin:cellstring_delimiter_mismatch",
       "strjoin: the number of delimiters does not match the number of strings")
@@ -80,17 +80,19 @@ function rval = strjoin (cstr, delimiter
   if (num == 0)
     rval = "";
   else
     rval = [[cstr(:).'; delimiter(:).']{:}];
   endif
 
 endfunction
 
+
 %!assert (strjoin ({"hello"}, "-"), "hello")
 %!assert (strjoin ({"hello", "world"}), "hello world")
 %!assert (strjoin ({"Octave", "Scilab", "Lush", "Yorick"}, "*"),
 %!  "Octave*Scilab*Lush*Yorick")
 %!assert (strjoin ({"space", "comma", "dash", "semicolon", "done"},
 %!  {" ", ",", "-", ";"}), "space comma,dash-semicolon;done")
 %!assert (strjoin ({'Octave','Scilab'},'\n'), "Octave\nScilab")
 %!assert (strjoin ({'Octave','Scilab'},{'\n'}), "Octave\\nScilab")
 %!assert (strjoin ({},'foo'), "")
+
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -16,18 +16,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} strjust (@var{s})
 ## @deftypefnx {Function File} {} strjust (@var{s}, @var{pos})
 ## Return the text, @var{s}, justified according to @var{pos}, which may
-## be @samp{"left"}, @samp{"center"}, or @samp{"right"}.  If @var{pos}
-## is omitted it defaults to @samp{"right"}.
+## be @qcode{"left"}, @qcode{"center"}, or @qcode{"right"}.  If @var{pos}
+## is omitted it defaults to @qcode{"right"}.
 ##
 ## Null characters are replaced by spaces.  All other character
 ## data are treated as non-white space.
 ##
 ## Example:
 ##
 ## @example
 ## @group
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -18,17 +18,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} strmatch (@var{s}, @var{A})
 ## @deftypefnx {Function File} {} strmatch (@var{s}, @var{A}, "exact")
 ## Return indices of entries of @var{A} which begin with the string @var{s}.
 ## The second argument @var{A} must be a string, character matrix, or a cell
-## array of strings.  If the third argument @code{"exact"} is not given, then
+## array of strings.  If the third argument @qcode{"exact"} is not given, then
 ## @var{s} only needs to match @var{A} up to the length of @var{s}.
 ## Trailing spaces and nulls in @var{s} and @var{A} are ignored when matching.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## strmatch ("apple", "apple juice")
@@ -38,17 +38,17 @@
 ##      @result{} [1; 2]
 ##
 ## strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
 ##      @result{} [1]
 ## @end group
 ## @end example
 ##
 ## @strong{Caution:} @code{strmatch} is scheduled for deprecation.  Use
-## @code{strncmp} (normal case), or @code{strcmp} ("exact" case), or
+## @code{strncmp} (normal case), or @code{strcmp} (@qcode{"exact"} case), or
 ## @code{regexp} in all new code.
 ## @seealso{strfind, findstr, strcmp, strncmp, strcmpi, strncmpi, find}
 ## @end deftypefn
 
 ## Author: Paul Kienzle, Alois Schloegl
 ## Adapted-by: jwe
 
 function idx = strmatch (s, A, exact)
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -154,26 +154,26 @@ function [result, matches] = strsplit (s
       print_usage ();
     endif
   endfor
 
   if (strcmpi (args.delimitertype, "default"))
     args.delimitertype = "simple";
   endif
 
-  # Save the length of the "delimitertype" parameter
-  length_deltype = numel (args.delimitertype);
+  ## Save the length of the "delimitertype" parameter
+  length_deltype = length (args.delimitertype);
 
   if (nargin == 1 || (nargin > 1 && (islogical (del) || isnumeric (del))))
     if (nargin > 1)
       ## Second input is the "collapsedelimiters" parameter
       args.collapsedelimiters = del;
     endif
     ## Set proper default for the delimiter type
-    if (strncmpi (args.delimitertype, "simple", numel (args.delimitertype)))
+    if (strncmpi (args.delimitertype, "simple", length (args.delimitertype)))
       del = {" ","\f","\n","\r","\t","\v"};
     else
       del = "\\s";
     endif
   endif
 
   if (! ischar (str) || (! ischar (del) && ! iscellstr (del)))
     error ("strsplit: S and DEL must be string values");
@@ -182,17 +182,17 @@ function [result, matches] = strsplit (s
   endif
 
   if (strncmpi (args.delimitertype, "simple", length_deltype))
     if (iscellstr (del))
       del = cellfun (@do_string_escapes, del, "uniformoutput", false);
     else
       del = do_string_escapes (del);
     endif
-    % This is clumsy, but needed for multi-row strings
+    ## This is clumsy, but needed for multi-row strings
     del = regexprep (del, '([^\w])', '\\$1');
   endif
 
   if (isempty (str))
     result = {str};
   elseif (strncmpi (args.delimitertype, "regularexpression", length_deltype)
           || strncmpi (args.delimitertype, "simple", length_deltype))
     if (iscellstr (del))
@@ -204,16 +204,17 @@ function [result, matches] = strsplit (s
     endif
     [result, ~, ~, ~, matches] = regexp (str, del, "split");
   else
     error ("strsplit:invalid_delimitertype",
            "strsplit: Invalid DELIMITERTYPE");
   endif
 endfunction
 
+
 %!shared str
 %! str = "The rain in Spain stays mainly in the plain.";
 % Split on all whitespace.
 %!assert (strsplit (str), {"The", "rain", "in", "Spain", "stays", ...
 %! "mainly", "in", "the", "plain."})
 % Split on "ain".
 %!assert (strsplit (str, "ain"), {"The r", " in Sp", " stays m", ...
 %!  "ly in the pl", "."})
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -206,19 +206,19 @@ endfunction
 
 %% Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
 %!assert (strtok (" this ".',"jkl "), "this".');
 
 %% Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
-%!   [t, r] = strtok (cstrcat ("beg", ch, "end"));
+%!   [t, r] = strtok (["beg", ch, "end"]);
 %!   assert (t, "beg");
-%!   assert (r, cstrcat (ch, "end"));
+%!   assert (r, [ch, "end"]);
 %! endfor
 
 %% Test input validation
 %!error strtok ()
 %!error strtok ("a", "b", "c")
 %!error <STR must be a string> strtok (1, "b")
 %!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
 
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -56,17 +56,17 @@ function s = untabify (t, tw = 8, dblank
     print_usage ();
   elseif (! (ischar (t) || iscellstr (t)))
     error ("untabify: T must be a string or cellstring");
   endif
 
   if (ischar (t))
     s = replace_tabs (t, tw);
   else
-    s = cellfun (@(str) replace_tabs (str, tw), t, "uniformoutput", false);
+    s = cellfun (@replace_tabs, t, {tw}, "uniformoutput", false);
   endif
 
   if (dblank)
     s = deblank (s);
   endif
 
 endfunction
 
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -23,21 +23,22 @@
 ## @deftypefnx {Function File} {@var{validstr} =} validatestring (@dots{}, @var{position})
 ## Verify that @var{str} is an element, or substring of an element, in
 ## @var{strarray}.
 ##
 ## When @var{str} is a character string to be tested, and @var{strarray} is a
 ## cellstr of valid values, then @var{validstr} will be the validated form
 ## of @var{str} where validation is defined as @var{str} being a member
 ## or substring of @var{validstr}.  This is useful for both verifying
-## and expanding short options, such as "r", to their longer forms, such as
-## "red".  If @var{str} is a substring of @var{validstr}, and there are
-## multiple matches, the shortest match will be returned if all matches are
-## substrings of each other.  Otherwise, an error will be raised because the
-## expansion of @var{str} is ambiguous.  All comparisons are case insensitive.
+## and expanding short options, such as @qcode{"r"}, to their longer forms,
+## such as @qcode{"red"}.  If @var{str} is a substring of @var{validstr}, and
+## there are multiple matches, the shortest match will be returned if all
+## matches are substrings of each other.  Otherwise, an error will be raised
+## because the expansion of @var{str} is ambiguous.  All comparisons are case
+## insensitive.
 ##
 ## The additional inputs @var{funcname}, @var{varname}, and @var{position}
 ## are optional and will make any generated validation error message more
 ## specific.
 ##
 ## Examples:
 ## @c Set example in small font to prevent overfull line
 ##
@@ -46,17 +47,17 @@
 ## validatestring ("r", @{"red", "green", "blue"@})
 ## @result{} "red"
 ##
 ## validatestring ("b", @{"red", "green", "blue", "black"@})
 ## @result{} error: validatestring: multiple unique matches were found for 'b':
 ##    blue, black
 ## @end group
 ## @end smallexample
-## 
+##
 ## @seealso{strcmp, strcmpi}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function str = validatestring (str, strarray, varargin)
 
   if (nargin < 2 || nargin > 5)
@@ -64,17 +65,17 @@ function str = validatestring (str, stra
   endif
 
   position = 0;
   ## Process input arguments
   if (! isempty (varargin) && isnumeric (varargin{end}))
     position = varargin{end};
     varargin(end) = [];
   endif
-  
+
   funcname = varname = "";
   char_idx = cellfun ("isclass", varargin, "char");
   n_chararg = sum (char_idx);
   if (n_chararg > 2)
     error ("validatestring: invalid number of character inputs (3)");
   elseif (n_chararg == 2)
     [funcname, varname] = deal (varargin{char_idx});
   elseif (n_chararg == 1)
@@ -106,31 +107,31 @@ function str = validatestring (str, stra
   endif
   if (position > 0)
     errstr = sprintf ("%sArgument position %d ", errstr, position);
   endif
   if (! isempty (errstr))
     errstr(end:end+1) = ":\n";
   endif
 
-  matches = strncmpi (str, strarray(:), numel (str));
+  matches = strncmpi (str, strarray(:), length (str));
   nmatches = sum (matches);
   if (nmatches == 0)
     error ("validatestring: %s'%s' does not match any of\n%s", errstr, str,
            sprintf ("%s, ", strarray{:})(1:end-2));
   elseif (nmatches == 1)
     str = strarray{matches};
   else
     ## Are the matches substrings of each other?
     ## If true, choose the shortest.  If not, raise an error.
     match_idx = find (matches);
     match_len = cellfun ("length", strarray(match_idx));
-    [min_len, min_idx] = min (match_len); 
+    [min_len, min_idx] = min (match_len);
     short_str = strarray{match_idx(min_idx)};
-    submatch = strncmpi (short_str, strarray(match_idx), min_len);    
+    submatch = strncmpi (short_str, strarray(match_idx), min_len);
     if (all (submatch))
       str = short_str;
     else
       error ("validatestring: %smultiple unique matches were found for '%s':\n%s",
              errstr, str, sprintf ("%s, ", strarray{match_idx})(1:end-2));
     endif
   endif
 
diff --git a/scripts/testfun/__have_feature__.m b/scripts/testfun/__have_feature__.m
--- a/scripts/testfun/__have_feature__.m
+++ b/scripts/testfun/__have_feature__.m
@@ -27,8 +27,9 @@ function retval = __have_feature__ (feat
     retval = (all (isfield (features, feature))
               && cellfun (@(x) features.(x), feature));
   elseif (ischar (feature))
     retval = isfield (features, feature) && features.(feature);
   else
     retval = false;
   endif
 endfunction
+
diff --git a/scripts/testfun/__printf_assert__.m b/scripts/testfun/__printf_assert__.m
--- a/scripts/testfun/__printf_assert__.m
+++ b/scripts/testfun/__printf_assert__.m
@@ -20,8 +20,9 @@
 ## @deftypefn {Function File} {} __printf_assert__ (@dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function __printf_assert__ (varargin)
   global _assert_printf;
   _assert_printf = cat (2, _assert_printf, sprintf (varargin{:}));
 endfunction
+
diff --git a/scripts/testfun/__prog_output_assert__.m b/scripts/testfun/__prog_output_assert__.m
--- a/scripts/testfun/__prog_output_assert__.m
+++ b/scripts/testfun/__prog_output_assert__.m
@@ -27,8 +27,9 @@ function ret = __prog_output_assert__ (s
     ret = isempty (str);
   elseif (_assert_printf(end) == "\n")
     ret = strcmp (_assert_printf(1:(end-1)), str);
   else
     ret = strcmp (_assert_printf, str);
   endif
   _assert_printf = "";
 endfunction
+
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -28,25 +28,25 @@ function __run_test_suite__ (fcndirs, fi
   fixedtestdir = fullfile (testsdir, "fixed");
   fcnfiledir = octave_config_info ("fcnfiledir");
   if (nargin == 0)
     fcndirs = { libinterptestdir, liboctavetestdir, fcnfiledir };
     fixedtestdirs = { fixedtestdir };
   endif
   global files_with_no_tests = {};
   global files_with_tests = {};
-  ## FIXME -- these names don't really make sense if we are running
-  ## tests for an installed copy of Octave.
+  ## FIXME: These names don't really make sense if we are running
+  ##        tests for an installed copy of Octave.
   global topsrcdir = fcnfiledir;
   global topbuilddir = testsdir;
   pso = page_screen_output ();
   warn_state = warning ("query", "quiet");
   warning ("on", "quiet");
   try
-    page_screen_output (0);
+    page_screen_output (false);
     warning ("off", "Octave:deprecated-function");
     fid = fopen ("fntests.log", "wt");
     if (fid < 0)
       error ("could not open fntests.log for writing");
     endif
     test ("", "explain", fid);
     dp = dn = dxf = dsk = 0;
     puts ("\nIntegrated test scripts:\n\n");
@@ -87,28 +87,28 @@ function __run_test_suite__ (fcndirs, fi
       puts ("Tests are most often skipped because the features they require\n");
       puts ("have been disabled.  Features are most often disabled because\n");
       puts ("they require dependencies that were not present when Octave\n");
       puts ("was built.  The configure script should have printed a summary\n");
       puts ("at the end of its run indicating which dependencies were not found.\n");
     endif
 
     ## Weed out deprecated and private functions
-    weed_idx = cellfun (@isempty, regexp (files_with_tests, '\bdeprecated\b|\bprivate\b', 'once'));
+    weed_idx = cellfun (@isempty, regexp (files_with_tests, '\<deprecated\>|\<private\>', 'once'));
     files_with_tests = files_with_tests(weed_idx);
-    weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\bdeprecated\b|\bprivate\b', 'once'));
+    weed_idx = cellfun (@isempty, regexp (files_with_no_tests, '\<deprecated\>|\<private\>', 'once'));
     files_with_no_tests = files_with_no_tests(weed_idx);
 
     report_files_with_no_tests (files_with_tests, files_with_no_tests, ".m");
 
     puts ("\nPlease help improve Octave by contributing tests for\n");
     puts ("these files (see the list in the file fntests.log).\n\n");
 
     fprintf (fid, "\nFiles with no tests:\n\n%s",
-            list_in_columns (files_with_no_tests, 80));
+                  list_in_columns (files_with_no_tests, 80));
     fclose (fid);
 
     page_screen_output (pso);
     warning (warn_state.state, "quiet");
   catch
     page_screen_output (pso);
     warning (warn_state.state, "quiet");
     disp (lasterr ());
@@ -128,87 +128,74 @@ function print_pass_fail (n, p)
       printf (" FAIL %d", nfail);
     endif
   endif
   puts ("\n");
 endfunction
 
 function retval = has_functions (f)
   n = length (f);
-  if (n > 3 && strcmp (f((end-2):end), ".cc"))
+  if (n > 3 && strcmpi (f((end-2):end), ".cc"))
     fid = fopen (f);
     if (fid >= 0)
       str = fread (fid, "*char")';
       fclose (fid);
-      retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\b', 'lineanchors'));
+      retval = ! isempty (regexp (str,'^(DEFUN|DEFUN_DLD)\>',
+                                      'lineanchors', 'once'));
     else
       error ("fopen failed: %s", f);
     endif
-  elseif (n > 2 && strcmp (f((end-1):end), ".m"))
+  elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
     retval = true;
   else
     retval = false;
   endif
 endfunction
 
 function retval = has_tests (f)
   fid = fopen (f);
   if (fid >= 0)
     str = fread (fid, "*char")';
     fclose (fid);
-    retval = ! isempty (regexp (str, '^%!(assert|error|fail|test|warning)', "lineanchors"));
-  else
-    error ("fopen failed: %s", f);
-  endif
-endfunction
-
-function retval = has_demos (f)
-  fid = fopen (f);
-  if (fid >= 0)
-    str = fread (fid, "*char")';
-    fclose (fid);
-    retval = ! isempty (regexp (str, '^%!demo', "lineanchors"));
+    retval = ! isempty (regexp (str, '^%!(assert|error|fail|test|warning)',
+                                     'lineanchors', 'once'));
   else
     error ("fopen failed: %s", f);
   endif
 endfunction
 
 function [dp, dn, dxf, dsk] = run_test_dir (fid, d);
   global files_with_tests;
   global files_with_no_tests;
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir
-        && ! strcmp (nm, ".") && ! strcmp (nm, "..")
-        && ! strcmp (nm, "private") && nm(1) != "@"
-        && ! strcmp (nm, "CVS"))
+        && nm(1) != "." && ! strcmp (nm, "private") && nm(1) != "@")
       [p, n, xf, sk] = run_test_dir (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
   saved_dir = pwd ();
   unwind_protect
     chdir (d);
     for i = 1:length (lst)
       nm = lst(i).name;
-      if (length (nm) > 4 && strcmp (nm((end-3):end), ".tst"))
+      if (length (nm) > 4 && strcmpi (nm((end-3):end), ".tst"))
         p = n = xf = sk = 0;
         ffnm = fullfile (d, nm);
         if (has_tests (ffnm))
           print_test_file_name (nm);
           [p, n, xf, sk] = test (nm, "quiet", fid);
           print_pass_fail (n, p);
           files_with_tests(end+1) = ffnm;
-        ##elseif (has_demos (ffnm))
-        ##  files_with_tests(end+1) = ffnm;
         else
           files_with_no_tests(end+1) = ffnm;
         endif
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
       endif
@@ -222,64 +209,62 @@ function [dp, dn, dxf, dsk] = run_test_s
   global files_with_tests;
   global files_with_no_tests;
   global topsrcdir;
   global topbuilddir;
   lst = dir (d);
   dp = dn = dxf = dsk = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
-    if (lst(i).isdir && ! strcmp (nm, ".") && ! strcmp (nm, "..")
-        && ! strcmp (nm, "CVS"))
+    if (lst(i).isdir && nm(1) != ".")
       [p, n, xf, sk] = run_test_script (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dsk += sk;
     endif
   endfor
   for i = 1:length (lst)
     nm = lst(i).name;
     ## Ignore hidden files
     if (nm(1) == '.')
       continue
     endif
     f = fullfile (d, nm);
-    if ((length (nm) > 2 && strcmp (nm((end-1):end), ".m"))
+    if ((length (nm) > 2 && strcmpi (nm((end-1):end), ".m"))
         || (length (nm) > 4
-            && (strcmp (nm((end-3):end), "-tst")
-                || strcmp (nm((end-3):end), ".tst"))))
+            && (   strcmpi (nm((end-3):end), "-tst")
+                || strcmpi (nm((end-3):end), ".tst"))))
       p = n = xf = 0;
-      ## Only run if it contains %!test, %!assert %!error or %!warning
+      ## Only run if it contains %!test, %!assert, %!error, %!fail, or %!warning
       if (has_tests (f))
         tmp = strrep (f, [topsrcdir, filesep], "");
         tmp = strrep (tmp, [topbuilddir, filesep], "");
         print_test_file_name (tmp);
         [p, n, xf, sk] = test (f, "quiet", fid);
         print_pass_fail (n, p);
         dp += p;
         dn += n;
         dxf += xf;
         dsk += sk;
         files_with_tests(end+1) = f;
-      ##elseif (has_demos (f))
-      ##  files_with_tests(end+1) = f;
       else
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
   endfor 
   ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
 endfunction
 
 function n = num_elts_matching_pattern (lst, pat)
-  n = sum (cellfun (@(x) !isempty (x), regexp (lst, pat, 'once')));
+  n = sum (! cellfun ("isempty", regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
-  pat = cstrcat ('\', typ, "$");
+  pat = ['\' typ "$"];
   n_with = num_elts_matching_pattern (with, pat);
   n_without = num_elts_matching_pattern (without, pat);
   n_tot = n_with + n_without;
   printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
 endfunction
+
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected})
 ## @deftypefnx {Function File} {} assert (@var{observed}, @var{expected}, @var{tol})
 ##
 ## Produce an error if the specified condition is not met.  @code{assert} can
 ## be called in three different ways.
 ##
 ## @table @code
-## @item assert (@var{cond})
+## @item  assert (@var{cond})
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
 ## error if @var{cond} is zero.  When called with more than one argument the
 ## additional arguments are passed to the @code{error} function.
 ##
 ## @item assert (@var{observed}, @var{expected})
 ## Produce an error if observed is not the same as expected.  Note that
@@ -42,296 +42,603 @@
 ## @item assert (@var{observed}, @var{expected}, @var{tol})
 ## Produce an error if observed is not the same as expected but equality
 ## comparison for numeric data uses a tolerance @var{tol}.
 ## If @var{tol} is positive then it is an absolute tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) > abs (@var{tol})}.
 ## If @var{tol} is negative then it is a relative tolerance which will produce
 ## an error if @code{abs (@var{observed} - @var{expected}) >
 ## abs (@var{tol} * @var{expected})}.  If @var{expected} is zero @var{tol} will
-## always be interpreted as an absolute tolerance.
+## always be interpreted as an absolute tolerance.  If @var{tol} is not scalar
+## its dimensions must agree with those of @var{observed} and @var{expected}
+## and tests are performed on an element-wise basis.
 ## @end table
 ## @seealso{test, fail, error}
 ## @end deftypefn
 
-## FIXME: Output throttling: don't print out the entire 100x100 matrix,
-## but instead give a summary; don't print out the whole list, just
-## say what the first different element is, etc.  To do this, make
-## the message generation type specific.
-
 function assert (cond, varargin)
 
-  in = deblank (argn(1,:));
-  for i = 2:rows (argn)
-    in = cstrcat (in, ",", deblank (argn(i,:)));
-  endfor
-  in = cstrcat ("(", in, ")");
+  if (nargin == 0 || nargin > 3)
+    print_usage ();
+  endif
+
+  persistent call_depth = -1;
+  persistent errmsg;
+
+  call_depth++;
+
+  if (call_depth == 0)
+    errmsg = "";
+  endif
 
   if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
     if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
+      call_depth--;
       if (nargin == 1)
-        ## Say which elements failed?
-        error ("assert %s failed", in);
+        ## Perhaps, say which elements failed?
+        argin = ["(" strjoin(cellstr (argn), ",") ")"];
+        error ("assert %s failed", argin);
       else
         error (varargin{:});
       endif
     endif
   else
-    if (nargin < 2 || nargin > 3)
-      print_usage ();
-    endif
-
     expected = varargin{1};
     if (nargin < 3)
       tol = 0;
     else
       tol = varargin{2};
     endif
 
-    if (exist ("argn") == 0)
-      argn = " ";
-    endif
-
-    coda = "";
-    iserror = 0;
-
+    ## Add to list as the errors accumulate.  If empty at end then no errors.
+    err.index = {};
+    err.observed = {};
+    err.expected = {};
+    err.reason = {};
 
     if (ischar (expected))
-      iserror = (! ischar (cond) || ! strcmp (cond, expected));
+      if (! ischar (cond))
+        err.index{end+1} = ".";
+        err.expected{end+1} = expected;
+        if (isnumeric (cond))
+          err.observed{end+1} = num2str (cond);
+          err.reason{end+1} = "Expected string, but observed number";
+        else
+          err.observed{end+1} = "O";
+          err.reason{end+1} = ["Expected string, but observed " class(cond)];
+        endif
+      elseif (! strcmp (cond, expected))
+        err.index{end+1} = "[]";
+        err.observed{end+1} = cond;
+        err.expected{end+1} = expected;
+        err.reason{end+1} = "Strings don't match";
+      endif
 
     elseif (iscell (expected))
-      if (! iscell (cond) || any (size (cond) != size (expected)))
-        iserror = 1;
+      if (! iscell (cond))
+        err.index{end+1} = ".";
+        err.observed{end+1} = "O";
+        err.expected{end+1} = "E";
+        err.reason{end+1} = ["Expected cell, but observed " class(cond)];
+      elseif (ndims (cond) != ndims (expected)
+              || any (size (cond) != size (expected)))
+        err.index{end+1} = ".";
+        err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
+        err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
+        err.reason{end+1} = "Dimensions don't match";
       else
         try
+          ## Recursively compare cell arrays
           for i = 1:length (expected(:))
             assert (cond{i}, expected{i}, tol);
           endfor
         catch
-          iserror = 1;
+          err.index{end+1} = "{}";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = "Cell configuration error";
         end_try_catch
       endif
 
     elseif (isstruct (expected))
-      if (! isstruct (cond) || any (size (cond) != size (expected))
-          || rows (fieldnames (cond)) != rows (fieldnames (expected)))
-        iserror = 1;
+      if (! isstruct (cond))
+        err.index{end+1} = ".";
+        err.observed{end+1} = "O";
+        err.expected{end+1} = "E";
+        err.reason{end+1} = ["Expected struct, but observed " class(cond)];
+      elseif (ndims (cond) != ndims (expected)
+              || any (size (cond) != size (expected))
+              || rows (fieldnames (cond)) != rows (fieldnames (expected)))
+
+        err.index{end+1} = ".";
+        err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
+        err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
+        err.reason{end+1} = "Structure sizes don't match";
       else
         try
-          #empty = numel (cond) == 0;
           empty = isempty (cond);
           normal = (numel (cond) == 1);
           for [v, k] = cond
             if (! isfield (expected, k))
-              error ();
+              err.index{end+1} = ".";
+              err.observed{end+1} = "O";
+              err.expected{end+1} = "E";
+              err.reason{end+1} = ["'" k "'" " is not an expected field"];
             endif
             if (empty)
               v = {};
             elseif (normal)
               v = {v};
             else
               v = v(:)';
             endif
+            ## Recursively call assert for struct array values
             assert (v, {expected.(k)}, tol);
           endfor
         catch
-          iserror = 1;
+          err.index{end+1} = ".";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = "Structure configuration error";
         end_try_catch
       endif
 
     elseif (ndims (cond) != ndims (expected)
             || any (size (cond) != size (expected)))
-      iserror = 1;
-      coda = "Dimensions don't match";
+      err.index{end+1} = ".";
+      err.observed{end+1} = ["O(" sprintf("%dx", size(cond))(1:end-1) ")"];
+      err.expected{end+1} = ["E(" sprintf("%dx", size(expected))(1:end-1) ")"];
+      err.reason{end+1} = "Dimensions don't match";
 
-    else
+    else  # Numeric comparison
       if (nargin < 3)
         ## Without explicit tolerance, be more strict.
         if (! strcmp (class (cond), class (expected)))
-          iserror = 1;
-          coda = cstrcat ("Class ", class (cond), " != ", class (expected));
+          err.index{end+1} = "()";
+          err.observed{end+1} = "O";
+          err.expected{end+1} = "E";
+          err.reason{end+1} = ["Class " class(cond) " != " class(expected)];
         elseif (isnumeric (cond))
           if (issparse (cond) != issparse (expected))
+            err.index{end+1} = "()";
+            err.observed{end+1} = "O";
+            err.expected{end+1} = "E";
             if (issparse (cond))
-              iserror = 1;
-              coda = "sparse != non-sparse";
+              err.reason{end+1} = "sparse != non-sparse";
             else
-              iserror = 1;
-              coda = "non-sparse != sparse";
+              err.reason{end+1} = "non-sparse != sparse";
             endif
           elseif (iscomplex (cond) != iscomplex (expected))
-            if (iscomplex (cond))
-              iserror = 1;
-              coda = "complex != real";
+            err.index{end+1} = "()";
+            err.observed{end+1} = "O";
+            err.expected{end+1} = "E";
+           if (iscomplex (cond))
+              err.reason{end+1} = "complex != real";
             else
-              iserror = 1;
-              coda = "real != complex";
+              err.reason{end+1} = "real != complex";
             endif
           endif
         endif
       endif
 
-      if (! iserror)
-        ## Numeric.
-        A = cond(:);
-        B = expected(:);
+      if (isempty (err.index))
+
+        A = cond;
+        B = expected;
+
         ## Check exceptional values.
-        if (any (isna (A) != isna (B)))
-          iserror = 1;
-          coda = "NAs don't match";
-        elseif (any (isnan (A) != isnan (B)))
-          iserror = 1;
-          coda = "NaNs don't match";
-          ## Try to avoid problems comparing strange values like Inf+NaNi.
-        elseif (any (isinf (A) != isinf (B))
-                || any (A(isinf (A) & ! isnan (A)) != B(isinf (B) & ! isnan (B))))
-          iserror = 1;
-          coda = "Infs don't match";
+        errvec = (  isna (real (A)) != isna (real (B))
+                  | isna (imag (A)) != isna (imag (B)));
+        erridx = find (errvec);
+        if (! isempty (erridx))
+          err.index(end+1:end+length (erridx)) = ...
+            ind2tuple (size (A), erridx);
+          err.observed(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (A(erridx) (:))));
+          err.expected(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (B(erridx) (:))));
+          err.reason(end+1:end+length (erridx)) = ...
+            repmat ({"'NA' mismatch"}, length (erridx), 1);
+        endif
+        errseen = errvec;
+
+        errvec = (  isnan (real (A)) != isnan (real (B))
+                  | isnan (imag (A)) != isnan (imag (B)));
+        erridx = find (errvec & !errseen);
+        if (! isempty (erridx))
+          err.index(end+1:end+length (erridx)) = ...
+            ind2tuple (size (A), erridx);
+          err.observed(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (A(erridx) (:))));
+          err.expected(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (B(erridx) (:))));
+          err.reason(end+1:end+length (erridx)) = ...
+            repmat ({"'NaN' mismatch"}, length (erridx), 1);
+        endif
+        errseen |= errvec;
+
+        errvec =   ((isinf (real (A)) | isinf (real (B))) ...
+                    & (real (A) != real (B)))             ...
+                 | ((isinf (imag (A)) | isinf (imag (B))) ...
+                    & (imag (A) != imag (B)));
+        erridx = find (errvec & !errseen);
+        if (! isempty (erridx))
+          err.index(end+1:end+length (erridx)) = ...
+            ind2tuple (size (A), erridx);
+          err.observed(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (A(erridx) (:))));
+          err.expected(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (B(erridx) (:))));
+          err.reason(end+1:end+length (erridx)) = ...
+            repmat ({"'Inf' mismatch"}, length (erridx), 1);
+        endif
+        errseen |= errvec;
+
+        ## Check normal values.
+        ## Replace exceptional values already checked above by zero.
+        A_null_real = real (A);
+        B_null_real = real (B);
+        exclude = errseen | ! isfinite (A_null_real) & ! isfinite (B_null_real);
+        A_null_real(exclude) = 0;
+        B_null_real(exclude) = 0;
+        A_null_imag = imag (A);
+        B_null_imag = imag (B);
+        exclude = errseen | ! isfinite (A_null_imag) & ! isfinite (B_null_imag);
+        A_null_imag(exclude) = 0;
+        B_null_imag(exclude) = 0;
+        A_null = complex (A_null_real, A_null_imag);
+        B_null = complex (B_null_real, B_null_imag);
+        if (isscalar (tol))
+          mtol = tol * ones (size (A));
         else
-          ## Check normal values.
-          A = A(isfinite (A));
-          B = B(isfinite (B));
-          if (tol == 0)
-            err = any (A != B);
-            errtype = "values do not match";
-          elseif (tol >= 0)
-            err = max (abs (A - B));
-            errtype = "maximum absolute error %g exceeds tolerance %g";
-          else
-            abserr = max (abs (A(B == 0)));
-            A = A(B != 0);
-            B = B(B != 0);
-            relerr = max (abs (A - B) ./ abs (B));
-            err = max ([abserr; relerr]);
-            errtype = "maximum relative error %g exceeds tolerance %g";
+          mtol = tol;
+        endif
+
+        k = (mtol == 0);
+        erridx = find ((A_null != B_null) & k);
+        if (! isempty (erridx))
+          err.index(end+1:end+length (erridx)) = ...
+            ind2tuple (size (A), erridx);
+          err.observed(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (A(erridx) (:))));
+          err.expected(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (B(erridx) (:))));
+          err.reason(end+1:end+length (erridx)) = ...
+            ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
+            [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
+        endif
+
+        k = (mtol > 0);
+        erridx = find ((abs (A_null - B_null) > mtol) & k);
+        if (! isempty (erridx))
+          err.index(end+1:end+length (erridx)) = ...
+            ind2tuple (size (A), erridx);
+          err.observed(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (A(erridx) (:))));
+          err.expected(end+1:end+length (erridx)) = ...
+            strtrim (cellstr (num2str (B(erridx) (:))));
+          err.reason(end+1:end+length (erridx)) = ...
+            ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",...
+            [abs(A_null(erridx) - B_null(erridx))(:) mtol(erridx)(:)]')), "\n");
+        endif
+
+        k = (mtol < 0);
+        if (any (k(:)))
+          ## Test for absolute error where relative error can't be calculated.
+          erridx = find ((B_null == 0) & abs (A_null) > abs (mtol) & k);
+          if (! isempty (erridx))
+            err.index(end+1:end+length (erridx)) = ...
+              ind2tuple (size (A), erridx);
+            err.observed(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (A(erridx) (:))));
+            err.expected(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (B(erridx) (:))));
+            err.reason(end+1:end+length (erridx)) = ...
+              ostrsplit (deblank (sprintf ("Abs err %.5g exceeds tol %.5g\n",
+              [abs(A_null(erridx) - B_null(erridx)) -mtol(erridx)]')), "\n");
           endif
-          if (err > abs (tol))
-            iserror = 1;
-            coda = sprintf (errtype, err, abs (tol));
+          ## Test for relative error
+          Bdiv = Inf (size (B_null));
+          Bdiv(k & (B_null != 0)) = B_null(k & (B_null != 0));
+          relerr = abs ((A_null - B_null) ./ abs (Bdiv));
+          erridx = find ((relerr > abs (mtol)) & k);
+          if (! isempty (erridx))
+            err.index(end+1:end+length (erridx)) = ...
+              ind2tuple (size (A), erridx);
+            err.observed(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (A(erridx) (:))));
+            err.expected(end+1:end+length (erridx)) = ...
+              strtrim (cellstr (num2str (B(erridx) (:))));
+            err.reason(end+1:end+length (erridx)) = ...
+              ostrsplit (deblank (sprintf ("Rel err %.5g exceeds tol %.5g\n",
+              [relerr(erridx)(:) -mtol(erridx)(:)]')), "\n");
           endif
         endif
       endif
 
     endif
 
-    if (! iserror)
-      return;
+    ## Print any errors
+    if (! isempty (err.index))
+      argin = ["(" strjoin(cellstr (argn), ",") ")"];
+      if (! isempty (errmsg))
+        errmsg = [errmsg "\n"];
+      endif
+      errmsg = [errmsg, pprint(argin, err)];
     endif
 
-    ## Pretty print the "expected but got" info, trimming leading and
-    ## trailing "\n".
-    str = disp (expected);
-    idx = find (str != "\n");
-    if (! isempty (idx))
-      str = str(idx(1):idx(end));
+  endif
+
+  call_depth--;
+
+  if (call_depth == -1)
+    ## Last time through.  If there were any errors on any pass, raise a flag.
+    if (! isempty (errmsg))
+      error (errmsg);
     endif
-    str2 = disp (cond);
-    idx = find (str2 != "\n");
-    if (! isempty (idx))
-      str2 = str2 (idx(1):idx(end));
-    endif
-    msg = cstrcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
-    if (! isempty (coda))
-      msg = cstrcat (msg, "\n", coda);
-    endif
-    error ("%s", msg);
   endif
 
 endfunction
 
 
 ## empty input
 %!assert ([])
 %!assert (zeros (3,0), zeros (3,0))
-%!error assert (zeros (3,0), zeros (0,2))
-%!error assert (zeros (3,0), [])
+%!error <O\(3x0\)\s+E\(0x2\)> assert (zeros (3,0), zeros (0,2))
+%!error <Dimensions don't match> assert (zeros (3,0), [])
 %!error <Dimensions don't match> assert (zeros (2,0,2), zeros (2,0))
 
 ## conditions
 %!assert (isempty ([]))
 %!assert (1)
 %!error assert (0)
 %!assert (ones (3,1))
 %!assert (ones (1,3))
 %!assert (ones (3,4))
 %!error assert ([1,0,1])
 %!error assert ([1;1;0])
 %!error assert ([1,0;1,1])
 
 ## scalars
-%!error assert (3, [3,3; 3,3])
-%!error assert ([3,3; 3,3], 3)
+%!error <Dimensions don't match> assert (3, [3,3])
+%!error <Dimensions don't match> assert (3, [3,3; 3,3])
+%!error <Dimensions don't match> assert ([3,3; 3,3], 3)
 %!assert (3, 3)
+%!error <Abs err 1 exceeds tol> assert (3, 4)
 %!assert (3+eps, 3, eps)
 %!assert (3, 3+eps, eps)
-%!error assert (3+2*eps, 3, eps)
-%!error assert (3, 3+2*eps, eps)
+%!error <Abs err 4.4409e-16 exceeds tol> assert (3+2*eps, 3, eps)
+%!error <Abs err 4.4409e-16 exceeds tol> assert (3, 3+2*eps, eps)
 
 ## vectors
 %!assert ([1,2,3],[1,2,3]);
 %!assert ([1;2;3],[1;2;3]);
-%!error assert ([2;2;3],[1;2;3]);
-%!error assert ([1,2,3],[1;2;3]);
-%!error assert ([1,2],[1,2,3]);
-%!error assert ([1;2;3],[1;2]);
+%!error <Abs err 1 exceeds tol 0> assert ([2,2,3,3],[1,2,3,4]);
+%!error <Abs err 1 exceeds tol 0.5> assert ([2,2,3,3],[1,2,3,4],0.5);
+%!error <Rel err 1 exceeds tol 0.1> assert ([2,2,3,5],[1,2,3,4],-0.1);
+%!error <Abs err 1 exceeds tol 0> assert ([6;6;7;7],[5;6;7;8]);
+%!error <Abs err 1 exceeds tol 0.5> assert ([6;6;7;7],[5;6;7;8],0.5);
+%!error <Rel err .* exceeds tol 0.1> assert ([6;6;7;7],[5;6;7;8],-0.1);
+%!error <Dimensions don't match> assert ([1,2,3],[1;2;3]);
+%!error <Dimensions don't match> assert ([1,2],[1,2,3]);
+%!error <Dimensions don't match> assert ([1;2;3],[1;2]);
+
+## matrices
 %!assert ([1,2;3,4],[1,2;3,4]);
-%!error assert ([1,4;3,4],[1,2;3,4])
-%!error assert ([1,3;2,4;3,5],[1,2;3,4])
+%!error <\(1,2\)\s+4\s+2> assert ([1,4;3,4],[1,2;3,4])
+%!error <Dimensions don't match> assert ([1,3;2,4;3,5],[1,2;3,4])
+%!test  # 2-D matrix
+%! A = [1 2 3]'*[1,2];
+%! assert (A, A);
+%! fail ("assert (A.*(A!=2),A)");
+%!test  # N-D matrix
+%! X = zeros (2,2,3);
+%! Y = X;
+%! Y(1,2,3) = 1.5;
+%! fail ("assert (X,Y)", "\(1,2,3\).*Abs err 1.5 exceeds tol 0");
 
 ## must give a small tolerance for floating point errors on relative
 %!assert (100+100*eps, 100, -2*eps)
 %!assert (100, 100+100*eps, -2*eps)
-%!error assert (100+300*eps, 100, -2*eps)
-%!error assert (100, 100+300*eps, -2*eps)
-%!error assert (3, [3,3])
-%!error assert (3, 4)
+%!error <Rel err .* exceeds tol> assert (100+300*eps, 100, -2*eps)
+%!error <Rel err .* exceeds tol> assert (100, 100+300*eps, -2*eps)
 
 ## test relative vs. absolute tolerances
-%!test  assert (0.1+eps, 0.1,  2*eps);  # accept absolute
-%!error assert (0.1+eps, 0.1, -2*eps);  # fail relative
-%!test  assert (100+100*eps, 100, -2*eps);  # accept relative
-%!error assert (100+100*eps, 100,  2*eps);  # fail absolute
+%!test  assert (0.1+eps, 0.1,  2*eps);
+%!error <Rel err 2.2204e-15 exceeds tol> assert (0.1+eps, 0.1, -2*eps);
+%!test  assert (100+100*eps, 100, -2*eps);
+%!error <Abs err 2.8422e-14 exceeds tol> assert (100+100*eps, 100,  2*eps);
+
+## Corner case of relative tolerance with 0 divider
+%!error <Abs err 2 exceeds tol 0.1> assert (2, 0, -0.1)
+
+## Extra checking of inputs when tolerance unspecified.
+%!error <Class single != double> assert (single (1), 1)
+%!error <Class uint8 != uint16> assert (uint8 (1), uint16 (1))
+%!error <sparse != non-sparse> assert (sparse([1]), [1])
+%!error <non-sparse != sparse> assert ([1], sparse([1]))
+%!error <complex != real> assert (1+i, 1)
+%!error <real != complex> assert (1, 1+i)
 
 ## exceptional values
 %!assert ([NaN, NA, Inf, -Inf, 1+eps, eps], [NaN, NA, Inf, -Inf, 1, 0], eps)
-%!error assert (NaN, 1)
-%!error assert (NA, 1)
-%!error assert (-Inf, Inf)
+
+%!error <'NaN' mismatch> assert (NaN, 1)
+%!error <'NaN' mismatch> assert ([NaN 1], [1 NaN])
+%!test
+%! try
+%!   assert ([NaN 1], [1 NaN]);
+%! catch
+%!   errmsg = lasterr ();
+%!   if (sum (errmsg () == "\n") != 4)
+%!     error ("Too many errors reported for NaN assert");
+%!   elseif (strfind (errmsg, "NA"))
+%!     error ("NA reported for NaN assert");
+%!   elseif (strfind (errmsg, "Abs err NaN exceeds tol 0"))
+%!     error ("Abs err reported for NaN assert");
+%!   endif
+%! end_try_catch
+
+%!error <'NA' mismatch> assert (NA, 1)
+%!error assert ([NA 1]', [1 NA]')
+%!test
+%! try
+%!   assert ([NA 1]', [1 NA]');
+%! catch
+%!   errmsg = lasterr ();
+%!   if (sum (errmsg () == "\n") != 4)
+%!     error ("Too many errors reported for NA assert");
+%!   elseif (strfind (errmsg, "NaN"))
+%!     error ("NaN reported for NA assert");
+%!   elseif (strfind (errmsg, "Abs err NA exceeds tol 0"))
+%!     error ("Abs err reported for NA assert");
+%!   endif
+%! end_try_catch
+%!error assert ([(complex (NA, 1)) (complex (2, NA))], [(complex (NA, 2)) 2])
+
+%!error <'Inf' mismatch> assert (-Inf, Inf)
+%!error <'Inf' mismatch> assert ([-Inf Inf], [Inf -Inf])
+%!test
+%! try
+%!   assert (complex (Inf, 0.2), complex (-Inf, 0.2 + 2*eps), eps);
+%! catch
+%!   errmsg = lasterr ();
+%!   if (sum (errmsg () == "\n") != 3)
+%!     error ("Too many errors reported for Inf assert");
+%!   elseif (strfind (errmsg, "Abs err"))
+%!     error ("Abs err reported for Inf assert");
+%!   endif
+%! end_try_catch
+%!error <Abs err> assert (complex (Inf, 0.2), complex (Inf, 0.2 + 2*eps), eps)
 
 ## strings
 %!assert ("dog", "dog")
-%!error assert ("dog", "cat")
-%!error assert ("dog", 3)
-%!error assert (3, "dog")
-
-## structures
-%!shared x,y
-%! x.a = 1; x.b=[2, 2];
-%! y.a = 1; y.b=[2, 2];
-%!assert (x, y)
-%!test y.b=3;
-%!error assert (x, y)
-%!error assert (3, x)
-%!error assert (x, 3)
-%!test
-%! # Empty structures
-%! x = resize (x, 0, 1);
-%! y = resize (y, 0, 1);
-%! assert (x, y);
+%!error <Strings don't match> assert ("dog", "cat")
+%!error <Expected string, but observed number> assert (3, "dog")
+%!error <Class char != double> assert ("dog", [3 3 3])
+%!error <Expected string, but observed cell> assert ({"dog"}, "dog")
+%!error <Expected string, but observed struct> assert (struct ("dog", 3), "dog")
 
 ## cell arrays
+%!error <Expected cell, but observed double> assert (1, {1})
+%!error <Dimensions don't match> assert (cell (1,2,3), cell (3,2,1))
+%!test
+%! x = {{{1}}, 2};  # cell with multiple levels
+%! y = x;
+%! assert (x,y);
+%! y{1}{1}{1} = 3;
+%! fail ("assert (x,y)", "Abs err 2 exceeds tol 0");
+
 %!test
 %! x = {[3], [1,2,3]; 100+100*eps, "dog"};
 %! y = x;
 %! assert (x, y);
 %! y = x; y(1,1) = [2];
 %! fail ("assert (x, y)");
 %! y = x; y(1,2) = [0, 2, 3];
 %! fail ("assert (x, y)");
 %! y = x; y(2,1) = 101;
 %! fail ("assert (x, y)");
 %! y = x; y(2,2) = "cat";
 %! fail ("assert (x, y)");
+%! y = x; y(1,1) = [2];  y(1,2) = [0, 2, 3]; y(2,1) = 101; y(2,2) = "cat";
+%! fail ("assert (x, y)");
 
-%% Test input validation
-%!error assert
+## structures
+%!error <Expected struct, but observed double> assert (1, struct ("a", 1))
+%!error <Structure sizes don't match>
+%! x(1,2,3).a = 1;
+%! y(1,2).a = 1;
+%! assert (x,y);
+%!error <Structure sizes don't match>
+%! x(1,2,3).a = 1;
+%! y(3,2,2).a = 1;
+%! assert (x,y);
+%!error <Structure sizes don't match>
+%! x.a = 1;
+%! x.b = 1;
+%! y.a = 1;
+%! assert (x,y);
+%!error <'b' is not an expected field>
+%! x.b = 1;
+%! y.a = 1;
+%! assert (x,y);
+
+%!test
+%! x.a = 1; x.b=[2, 2];
+%! y.a = 1; y.b=[2, 2];
+%! assert (x, y);
+%! y.b=3;
+%! fail ("assert (x, y)");
+%! fail ("assert (3, x)");
+%! fail ("assert (x, 3)");
+%! ## Empty structures
+%! x = resize (x, 0, 1);
+%! y = resize (y, 0, 1);
+%! assert (x, y);
+
+## vector of tolerances
+%!test
+%! x = [-40:0];
+%! y1 = (10.^x).*(10.^x);
+%! y2 = 10.^(2*x);
+%! assert (y1, y2, eps (y1));
+%! fail ("assert (y1, y2 + eps*1e-70, eps (y1))");
+
+## Multiple tolerances
+%!test
+%! x = [1 2; 3 4];
+%! y = [0 -1; 1 2];
+%! tol = [-0.1 0; -0.2 0.3];
+%! try
+%!   assert (x, y, tol);
+%! catch
+%!   errmsg = lasterr ();
+%!   if (sum (errmsg () == "\n") != 6)
+%!     error ("Incorrect number of errors reported");
+%!   endif
+%!   assert (!isempty (regexp (errmsg, '\(1,2\).*Abs err 3 exceeds tol 0\>')));
+%!   assert (!isempty (regexp (errmsg, '\(2,2\).*Abs err 2 exceeds tol 0.3')));
+%!   assert (!isempty (regexp (errmsg, '\(1,1\).*Abs err 1 exceeds tol 0.1')));
+%!   assert (!isempty (regexp (errmsg, '\(2,1\).*Rel err 2 exceeds tol 0.2')));
+%! end_try_catch
+
+## test input validation
+%!error assert ()
 %!error assert (1,2,3,4)
 
+
+## Convert all error indices into tuple format
+function cout = ind2tuple (matsize, erridx)
+
+  cout = cell (numel (erridx), 1);
+  tmp = cell (1, numel (matsize));
+  [tmp{:}] = ind2sub (matsize, erridx (:));
+  subs = [tmp{:}];
+  if (numel (matsize) == 2)
+    subs = subs(:, matsize != 1);
+  endif
+  for i = 1:numel (erridx)
+    loc = sprintf ("%d,", subs(i,:));
+    cout{i} = ["(" loc(1:end-1) ")"];
+  endfor
+
+endfunction
+
+
+## Pretty print the various errors in a condensed tabular format.
+function str = pprint (argin, err)
+
+  str = ["ASSERT errors for:  assert " argin "\n"];
+  str = [str, "\n  Location  |  Observed  |  Expected  |  Reason\n"];
+  for i = 1:length (err.index)
+    leni = length (err.index{i});
+    leno = length (err.observed{i});
+    lene = length (err.expected{i});
+    str = [str, sprintf("%*s%*s %*s%*s %*s%*s   %s\n",
+                        6+fix(leni/2), err.index{i}   , 6-fix(leni/2), "",
+                        6+fix(leno/2), err.observed{i}, 6-fix(leno/2), "",
+                        6+fix(lene/2), err.expected{i}, 6-fix(lene/2), "",
+                        err.reason{i})];
+  endfor
+
+endfunction
+
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -23,19 +23,19 @@
 ## @deftypefnx {Function File} {} demo ("@var{name}", @var{n})
 ##
 ## Run example code block @var{n} associated with the function @var{name}.
 ## If @var{n} is not specified, all examples are run.
 ##
 ## Examples are stored in the script file, or in a file with the same
 ## name but no extension located on Octave's load path.  To keep examples
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
-## example must also be introduced by the keyword 'demo' flush left to the
-## prefix with no intervening spaces.  The remainder of the example can
-## contain arbitrary Octave code.  For example:
+## example must also be introduced by the keyword @qcode{"demo"} flush left
+## to the prefix with no intervening spaces.  The remainder of the example
+## can contain arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
 ## %!demo
 ## %! t = 0:0.01:2*pi;
 ## %! x = sin (t);
 ## %! plot (t, x);
 ## %! %-------------------------------------------------
@@ -62,18 +62,18 @@
 ## with a new @code{figure} command between each plot, or using @code{subplot}
 ## to put multiple plots in the same window.
 ##
 ## Also, because demo evaluates within a function context, you cannot
 ## define new functions inside a demo.  If you must have function blocks,
 ## rather than just anonymous functions or inline functions, you will have to
 ## use @code{eval (example ("function",n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
-## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
-## with the 'if' on the same line as 'demo'.  For example:
+## multiple lines, you must wrap your demo in @qcode{"if 1 <demo stuff> endif"}
+## with the @qcode{"if"} on the same line as @qcode{"demo"}.  For example:
 ##
 ## @example
 ## @group
 ## %!demo if 1
 ## %!  function y=f(x)
 ## %!    y=x;
 ## %!  endfunction
 ## %!  f(3)
@@ -123,17 +123,17 @@ function demo (name, n)
     if (i > 1)
       input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## Use an environment without variables
-      eval (cstrcat ("function __demo__ ()\n", block, "\nendfunction"));
+      eval (["function __demo__()\n" block "\nendfunction"]);
       ## Display the code that will be executed before executing it
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
       __demo__;
     catch
       ## Let the programmer know which demo failed.
       printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} example @var{name}
 ## @deftypefnx {Command} {} example @var{name} @var{n}
 ## @deftypefnx {Function File} {} example ("@var{name}")
 ## @deftypefnx {Function File} {} example ("@var{name}", @var{n})
 ## @deftypefnx {Function File} {[@var{s}, @var{idx}] =} example (@dots{})
 ##
 ## Display the code for example @var{n} associated with the function
-## "@var{name}", but do not run it.  If @var{n} is not specified, all examples
+## @var{name}, but do not run it.  If @var{n} is not specified, all examples
 ## are displayed.
 ##
 ## When called with output arguments, the examples are returned in the form of
 ## a string @var{s}, with @var{idx} indicating the ending position of the
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -15,78 +15,101 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rundemos ()
 ## @deftypefnx {Function File} {} rundemos (@var{directory})
 ## Execute built-in demos for all function files in the specified directory.
+## Also executes demos in any C++ source files found in the directory, for
+## use with dynamically linked functions.
+##
 ## If no directory is specified, operate on all directories in Octave's
 ## search path for functions.
 ## @seealso{runtests, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function rundemos (directory)
 
   if (nargin == 0)
     dirs = ostrsplit (path (), pathsep ());
+    do_class_dirs = true;
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
+    elseif (is_rooted_relative_filename (directory))
+      dirs = {canonicalize_file_name(directory)};
     else
-      directory = regexprep (directory, ['\',filesep(),'$'], "");
+      if (directory(end) == filesep ())
+        directory = directory(1:end-1);
+      endif
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
       else
         error ("rundemos: DIRECTORY argument must be a valid pathname");
       endif
     endif
+    do_class_dirs = false;
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
-    run_all_demos (d);
+    run_all_demos (d, do_class_dirs);
   endfor
 
 endfunction
 
-function run_all_demos (directory)
-  dirinfo = dir (directory);
-  flist = {dirinfo.name};
+function run_all_demos (directory, do_class_dirs)
+  flist = readdir (directory);
+  dirs = {};
   for i = 1:numel (flist)
     f = flist{i};
-    if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
+    if ((length (f) > 2 && strcmpi (f((end-1):end), ".m")) ||
+        (length (f) > 3 && strcmpi (f((end-2):end), ".cc")))
       f = fullfile (directory, f);
       if (has_demos (f))
         try
           demo (f);
         catch
           printf ("error: %s\n\n", lasterror().message);
         end_try_catch
         if (i != numel (flist))
           input ("Press <enter> to continue: ", "s");
         endif
       endif
+    elseif (f(1) == "@")
+      f = fullfile (directory, f);
+      if (isdir (f))
+        dirs(end+1) = f;
+      endif
     endif
   endfor
+
+  ## Recurse into class directories since they are implied in the path
+  if (do_class_dirs)
+    for i = 1:numel (dirs)
+      d = dirs{i};
+      run_all_demos (d, false);
+    endfor
+  endif
 endfunction
 
 function retval = has_demos (f)
   fid = fopen (f);
   if (f < 0)
     error ("rundemos: fopen failed: %s", f);
   else
-    str = fscanf (fid, "%s");
+    str = fread (fid, "*char").';
     fclose (fid);
-    retval = strfind (str, "%!demo");
+    retval = ! isempty (regexp (str, '^%!demo', 'lineanchors', 'once'));
   endif
 endfunction
 
 
 %!error rundemos ("foo", 1)
 %!error <DIRECTORY argument> rundemos ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
 
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -15,82 +15,125 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} runtests ()
 ## @deftypefnx {Function File} {} runtests (@var{directory})
 ## Execute built-in tests for all function files in the specified directory.
+## Also executes tests in any C++ source files found in the directory, for
+## use with dynamically linked functions.
+##
 ## If no directory is specified, operate on all directories in Octave's
 ## search path for functions.
 ## @seealso{rundemos, path}
 ## @end deftypefn
 
 ## Author: jwe
 
 function runtests (directory)
 
   if (nargin == 0)
     dirs = ostrsplit (path (), pathsep ());
+    do_class_dirs = true;
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
+    elseif (is_rooted_relative_filename (directory))
+      dirs = {canonicalize_file_name(directory)};
     else
-      directory = regexprep (directory, ['\',filesep(),'$'], "");
+      if (directory(end) == filesep ())
+        directory = directory(1:end-1);
+      endif
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
         dirs = {fullname};
       else
         error ("runtests: DIRECTORY argument must be a valid pathname");
       endif
     endif
+    do_class_dirs = false;
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
-    run_all_tests (d);
+    run_all_tests (d, do_class_dirs);
   endfor
 
 endfunction
 
-function run_all_tests (directory)
-  dirinfo = dir (directory);
-  flist = {dirinfo.name};
+function run_all_tests (directory, do_class_dirs)
+  flist = readdir (directory);
+  dirs = {};
   no_tests = {};
   printf ("Processing files in %s:\n\n", directory);
   fflush (stdout);
   for i = 1:numel (flist)
     f = flist{i};
-    if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
+    if ((length (f) > 2 && strcmpi (f((end-1):end), ".m")) ||
+        (length (f) > 3 && strcmpi (f((end-2):end), ".cc")))
       ff = fullfile (directory, f);
       if (has_tests (ff))
         print_test_file_name (f);
         [p, n, xf, sk] = test (ff, "quiet");
         print_pass_fail (n, p);
         fflush (stdout);
-      else
-        no_tests{end+1} = f;
+      elseif (has_functions (ff))
+        no_tests(end+1) = f;
+      endif
+    elseif (f(1) == "@")
+      f = fullfile (directory, f);
+      if (isdir (f))
+        dirs(end+1) = f;
       endif
     endif
   endfor
   if (! isempty (no_tests))
     printf ("\nThe following files in %s have no tests:\n\n", directory);
     printf ("%s", list_in_columns (no_tests));
   endif
+
+  ## Recurse into class directories since they are implied in the path
+  if (do_class_dirs)
+    for i = 1:numel (dirs)
+      d = dirs{i};
+      run_all_tests (d, false);
+    endfor
+  endif
+endfunction
+
+function retval = has_functions (f)
+  n = length (f);
+  if (n > 3 && strcmpi (f((end-2):end), ".cc"))
+    fid = fopen (f);
+    if (fid >= 0)
+      str = fread (fid, "*char")';
+      fclose (fid);
+      retval = ! isempty (regexp (str,'^(?:DEFUN|DEFUN_DLD|DEFUNX)\>',
+                                      'lineanchors', 'once'));
+    else
+      error ("fopen failed: %s", f);
+    endif
+  elseif (n > 2 && strcmpi (f((end-1):end), ".m"))
+    retval = true;
+  else
+    retval = false;
+  endif
 endfunction
 
 function retval = has_tests (f)
   fid = fopen (f);
   if (fid >= 0)
-    str = fread (fid, "*char")';
+    str = fread (fid, "*char").';
     fclose (fid);
-    retval = ! isempty (regexp (str, '^%!(test|assert|error|warning)', "lineanchors"));
+    retval = ! isempty (regexp (str, '^%!(?:test|assert|error|warning)',
+                                     'lineanchors', 'once'));
   else
     error ("runtests: fopen failed: %s", f);
   endif
 endfunction
 
 function print_pass_fail (n, p)
   if (n > 0)
     printf (" PASS %4d/%-4d", p, n);
@@ -101,8 +144,13 @@ function print_pass_fail (n, p)
   endif
   puts ("\n");
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 55-length (nm));
   printf ("  %s %s", nm, filler);
 endfunction
+
+
+%!error runtests ("foo", 1)
+%!error <DIRECTORY argument> runtests ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
+
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -182,24 +182,24 @@ function [__order, __test_n, __tnew, __t
   assert (__test_n >= 1);
 
   __torig = __tnew = zeros (size (__test_n));
 
   ## Print and plot the data if no output is requested.
   do_display = (nargout == 0);
 
   if (do_display)
-    disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
+    disp (["testing " __f1 "\ninit: " __init]);
   endif
 
   ## Add semicolon closure to all code fragments in case user has not done so.
-  __init = cstrcat (__init, ";");
-  __f1 = cstrcat (__f1, ";");
+  __init(end+1) = ";";
+  __f1(end+1) = ";";
   if (! isempty (__f2))
-    __f2 = cstrcat (__f2, ";");
+    __f2(end+1) = ";";
   endif
 
   ## Make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
   n = 1;
   k = 0;
   eval (__init);
   eval (__f1);
@@ -212,29 +212,29 @@ function [__order, __test_n, __tnew, __t
     n = __test_n(k);
     eval (__init);
 
     if (do_display)
       printf ("n%i = %i  ", k, n);
       fflush (stdout);
     endif
 
-    eval (cstrcat ("__t = time();", __f1, "__v1=ans; __t = time()-__t;"));
+    eval (["__t = time();" __f1 "__v1=ans; __t = time()-__t;"]);
     if (__t < 0.25)
-      eval (cstrcat ("__t2 = time();", __f1, "__t2 = time()-__t2;"));
-      eval (cstrcat ("__t3 = time();", __f1, "__t3 = time()-__t3;"));
+      eval (["__t2 = time();" __f1 "__t2 = time()-__t2;"]);
+      eval (["__t3 = time();" __f1 "__t3 = time()-__t3;"]);
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
     if (! isempty (__f2))
-      eval (cstrcat ("__t = time();", __f2, "__v2=ans; __t = time()-__t;"));
+      eval (["__t = time();" __f2 "__v2=ans; __t = time()-__t;"]);
       if (__t < 0.25)
-        eval (cstrcat ("__t2 = time();", __f2, "__t2 = time()-__t2;"));
-        eval (cstrcat ("__t3 = time();", __f2, "__t3 = time()-__t3;"));
+        eval (["__t2 = time();" __f2 "__t2 = time()-__t2;"]);
+        eval (["__t3 = time();" __f2 "__t3 = time()-__t3;"]);
         __t = min ([__t, __t2, __t3]);
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
         assert (__v1, __v2, __tol);
       endif
     endif
 
@@ -275,37 +275,35 @@ function [__order, __test_n, __tnew, __t
     endif
   endif
 
   if (do_display && isempty (__f2))
 
     loglog (__test_n, __tnew*1000, "*-g;execution time;");
     xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title ({__f1, cstrcat("init: ", __init)});
+    title ({__f1, ["init: " __init]});
 
   elseif (do_display)
 
     subplot (1, 2, 1);
     semilogx (__test_n, __torig./__tnew,
-              cstrcat ("-*r;", strrep (__f1, ";", "."), " / ",
-                       strrep (__f2, ";", "."), ";"),
-               __test_n, __tnew./__torig,
-              cstrcat ("-*g;", strrep (__f2, ";", "."), " / ",
-                       strrep (__f1, ";", "."), ";"));
+             ["-*r;" strrep(__f1, ";", ".") " / " strrep(__f2, ";", ".") ";"],
+              __test_n, __tnew./__torig,
+             ["-*g;", strrep(__f2, ";", ".") " / " strrep(__f1, ";", ".") ";"]);
     title ("Speedup Ratio");
     xlabel ("test length");
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-            cstrcat ("*-g;", strrep (__f1, ";", "."), ";"),
+            ["*-g;" strrep(__f1,";",".") ";"],
             __test_n, __torig*1000,
-            cstrcat ("*-r;", strrep (__f2,";","."), ";"));
-    title ({"Execution Times", cstrcat("init: ", __init)});
+            ["*-r;" strrep(__f2,";",".") ";"]);
+    title ({"Execution Times", ["init: " __init]});
     xlabel ("test length");
     ylabel ("best execution time (ms)");
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
   endif
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -29,47 +29,48 @@
 ## @code{test} can be called as a command or as a function.  Called with
 ## a single argument @var{name}, the tests are run interactively and stop
 ## after the first error is encountered.
 ##
 ## With a second argument the tests which are performed and the amount of
 ## output is selected.
 ##
 ## @table @asis
-## @item "quiet"
+## @item @qcode{"quiet"}
 ##  Don't report all the tests as they happen, just the errors.
 ##
-## @item "normal"
+## @item @qcode{"normal"}
 ## Report all tests as they happen, but don't do tests which require
 ## user interaction.
 ##
-## @item "verbose"
+## @item @qcode{"verbose"}
 ## Do tests which require user interaction.
 ## @end table
 ##
 ## The argument @var{fid} can be used to allow batch processing.  Errors
 ## can be written to the already open file defined by @var{fid}, and
 ## hopefully when Octave crashes this file will tell you what was happening
 ## when it did.  You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
 ## which case the contents of the file will be replaced with the log from
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
 ## true if all of the tests were successful.  Called with two output arguments
 ## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
-## If the second argument is the string "grabdemo", the contents of the demo
-## blocks are extracted but not executed.  Code for all code blocks is
-## concatenated and returned as @var{code} with @var{idx} being a vector of
-## positions of the ends of the demo blocks.
+## If the second argument is the string @qcode{"grabdemo"}, the contents of
+## the demo blocks are extracted but not executed.  Code for all code blocks
+## is concatenated and returned as @var{code} with @var{idx} being a vector
+## of positions of the ends of the demo blocks.
 ##
-## If the second argument is "explain", then @var{name} is ignored and an
-## explanation of the line markers used is written to the file @var{fid}.
+## If the second argument is @qcode{"explain"}, then @var{name} is ignored
+## and an explanation of the line markers used is written to the file
+## @var{fid}.
 ## @seealso{assert, fail, error, demo, example}
 ## @end deftypefn
 
 ## FIXME: * Consider using keyword fail rather then error?  This allows us
 ## to make a functional form of error blocks, which means we
 ## can include them in test sections which means that we can use
 ## octave flow control for both kinds of tests.
 
@@ -150,20 +151,20 @@ function [__ret1, __ret2, __ret3, __ret4
     return;
   else
     error ("test: unknown flag '%s'", __flag);
   endif
 
   ## Locate the file to test.
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
-    __file = file_in_loadpath (cstrcat (__name, ".m"), "all");
+    __file = file_in_loadpath ([__name ".m"], "all");
   endif
   if (isempty (__file))
-    __file = file_in_loadpath (cstrcat (__name, ".cc"), "all");
+    __file = file_in_loadpath ([__name ".cc"], "all");
   endif
   if (iscell (__file))
       ## If repeats, return first in path.
     if (isempty (__file))
       __file = "";
     else
       __file = __file{1};
     endif
@@ -224,17 +225,17 @@ function [__ret1, __ret2, __ret3, __ret4
   endif
 
   ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## Ready to start tests ... if in batch mode, tell us what is happening.
   if (__verbose)
-    disp (cstrcat (__signal_file, __file));
+    disp ([__signal_file, __file]);
   endif
 
   ## Assume all tests will pass.
   __all_success = 1;
 
   ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
   __shared = " ";
@@ -276,17 +277,17 @@ function [__ret1, __ret2, __ret3, __ret4
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
         if (isempty (__demo_code))
           __demo_code = __code;
           __demo_idx = [1, length(__demo_code)+1];
         else
-          __demo_code = cstrcat (__demo_code, __code);
+          __demo_code = [__demo_code, __code];
           __demo_idx = [__demo_idx, length(__demo_code)+1];
         endif
 
       elseif (__rundemo && __isdemo)
         try
           ## process the code in an environment without variables
           eval (sprintf ("function __test__ ()\n%s\nendfunction", __code));
           __test__;
@@ -321,19 +322,19 @@ function [__ret1, __ret2, __ret3, __ret4
       if (! isempty (__idx))
         __vars = __vars(1:__idx(1)-1);
       endif
 
       ## Assign default values to variables.
       try
         __vars = deblank (__vars);
         if (! isempty (__vars))
-          eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
+          eval ([strrep(__vars, ",", "=[];"), "=[];"]);
           __shared = __vars;
-          __shared_r = cstrcat ("[ ", __vars, "] = ");
+          __shared_r = ["[ ", __vars, "] = "];
         else
           __shared = " ";
           __shared_r = " ";
         endif
       catch
         ## Couldn't declare, so don't initialize.
         __code = "";
         __success = 0;
@@ -352,17 +353,17 @@ function [__ret1, __ret2, __ret3, __ret4
       if (isempty (__name_position))
         __success = 0;
         __msg = sprintf ("%stest failed: missing function name\n",
                          __signal_fail);
       else
         __name = __block(__name_position(1):__name_position(2));
         __code = __block;
         try
-          eval (__code); ## Define the function
+          eval (__code);  # Define the function
           __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
                            __signal_fail, lasterr ());
         end_try_catch
       endif
       __code = "";
@@ -387,70 +388,84 @@ function [__ret1, __ret2, __ret3, __ret4
 
     elseif (strcmp (__type, "error") || strcmp (__type, "warning"))
       __istest = 1;
       __warning = strcmp (__type, "warning");
       [__pattern, __id, __code] = getpattern (__code);
       if (__id)
         __patstr = ["id=",__id];
       else
-        __patstr = ["<",__pattern,">"];
+        if (! strcmp (__pattern, '.'))
+          __patstr = ["<",__pattern,">"];
+        else
+          __patstr = ifelse (__warning, "a warning", "an error");
+        endif
       endif
       try
         eval (sprintf ("function __test__(%s)\n%s\nendfunction",
                        __shared, __code));
       catch
         __success = 0;
         __msg = sprintf ("%stest failed: syntax error\n%s",
                          __signal_fail, lasterr ());
       end_try_catch
 
       if (__success)
         __success = 0;
         __warnstate = warning ("query", "quiet");
         warning ("on", "quiet");
+        ## Clear error and warning strings before starting
+        lasterr ("");
+        lastwarn ("");
         try
+          ## FIXME: lastwarn () must be called once from *WITHIN* the try block
+          ##        or subsequent warning/lastwarn statements may fail.
+          ##        Likely this is something to do with the specialness of
+          ##        the try block which is disabling normal errors.
+          lastwarn ();
           eval (sprintf ("__test__(%s);", __shared));
           if (! __warning)
-            __msg = sprintf ("%sexpected %s but got no error\n",
+            __msg = sprintf ("%serror failed.\nExpected %s but got no error\n",
                              __signal_fail, __patstr);
           else
             if (! isempty (__id))
-              [~, __err] = lastwarn;
+              [~, __err] = lastwarn ();
               __mismatch = ! strcmp (__err, __id);
             else
-              __err = trimerr (lastwarn, "warning");
+              __err = trimerr (lastwarn (), "warning");
               __mismatch = isempty (regexp (__err, __pattern, "once"));
             endif
             warning (__warnstate.state, "quiet");
             if (isempty (__err))
-              __msg = sprintf ("%sexpected %s but got no warning\n",
-                             __signal_fail, __patstr);
+              __msg = sprintf (["%swarning failed.\n" ...
+                                "Expected %s but got no warning\n"],
+                               __signal_fail, __patstr);
             elseif (__mismatch)
-              __msg = sprintf ("%sexpected %s but got %s\n",
+              __msg = sprintf ("%swarning failed.\nExpected %s but got <%s>\n",
                                __signal_fail, __patstr, __err);
             else
               __success = 1;
             endif
           endif
 
         catch
           if (! isempty (__id))
-            [~, __err] = lasterr;
+            [~, __err] = lasterr ();
             __mismatch = ! strcmp (__err, __id);
           else
-            __err = trimerr (lasterr, "error");
+            __err = trimerr (lasterr (), "error");
             __mismatch = isempty (regexp (__err, __pattern, "once"));
           endif
           warning (__warnstate.state, "quiet");
           if (__warning)
-            __msg = sprintf ("%sexpected warning %s but got error %s\n",
+            __msg = sprintf (["%swarning failed.\n" ...
+                              "Expected warning %s but got error <%s>\n"],
                              __signal_fail, __patstr, __err);
           elseif (__mismatch)
-            __msg = sprintf ("%sexpected %s but got %s\n",
+            __msg = sprintf ("%serror failed.\nExpected %s but got <%s>\n",
                              __signal_fail, __patstr, __err);
           else
             __success = 1;
           endif
         end_try_catch
         clear __test__;
       endif
       ## Code already processed.
@@ -560,23 +575,26 @@ function [__ret1, __ret2, __ret3, __ret4
     __successes += __success * __istest;
   endfor
   ## Clear any test functions created
   eval (__clear, "");
 
   if (nargout == 0)
     if (__tests || __xfail || __xskip)
       if (__xfail)
-        printf ("PASSES %d out of %d tests (%d expected failures)\n",
-                __successes, __tests, __xfail);
+        printf ("PASSES %d out of %d test%s (%d expected failure%s)\n",
+                __successes, __tests, ifelse (__tests > 1, "s", ""),
+                __xfail, ifelse (__xfail > 1, "s", ""));
       else
-        printf ("PASSES %d out of %d tests\n", __successes, __tests);
+        printf ("PASSES %d out of %d test%s\n", __successes, __tests,
+               ifelse (__tests > 1, "s", ""));
       endif
       if (__xskip)
-        printf ("Skipped %d tests due to missing features\n", __xskip);
+        printf ("Skipped %d test%s due to missing features\n", __xskip,
+                ifelse (__xskip > 1, "s", ""));
       endif
     else
       printf ("%s%s has no tests available\n", __signal_empty, __file);
     endif
   elseif (__grabdemo)
     __ret1 = __demo_code;
     __ret2 = __demo_idx;
   elseif (nargout == 1)
@@ -634,30 +652,27 @@ function [pattern, id, rest] = getpatter
     endif
   elseif (strncmp (str, "id=", 3))
     [id, rest] = strtok (str(4:end));
   endif
 endfunction
 
 ## Strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks.
 function msg = trimerr (msg, prefix)
-  idx = index (msg, cstrcat (prefix, ":"));
+  idx = index (msg, [prefix ":"]);
   if (idx > 0)
     msg(1:idx+length(prefix)) = [];
   endif
-  msg = trimleft (deblank (msg));
+  msg = strtrim (msg);
 endfunction
 
 ## Strip leading blanks from string.
 function str = trimleft (str)
-  idx = find (isspace (str));
-  leading = find (idx == 1:length (idx));
-  if (! isempty (leading))
-    str = str(leading(end)+1:end);
-  endif
+  idx = find (! isspace (str), 1);
+  str = str(idx:end);
 endfunction
 
 ## Make a structure out of the named variables
 ## (based on Etienne Grossmann's tar function).
 function s = bundle (varargin)
   for i = 1:nargin
     s.(deblank (argn(i,:))) = varargin{i};
   endfor
@@ -667,24 +682,25 @@ function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
   body = [];
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (length (ln) >= 2 && strcmp (ln(1:2), "%!"))
         body = [body, "\n"];
         if (length (ln) > 2)
-          body = cstrcat (body, ln(3:end));
+          body = [body, ln(3:end)];
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
+
 ### example from toeplitz
 %!shared msg1,msg2
 %! msg1="C must be a vector";
 %! msg2="C and R must be vectors";
 %!fail ('toeplitz ([])', msg1);
 %!fail ('toeplitz ([1,2;3,4])', msg1);
 %!fail ('toeplitz ([1,2],[])', msg2);
 %!fail ('toeplitz ([1,2],[1,2;3,4])', msg2);
@@ -729,19 +745,19 @@ endfunction
 %! S = abs (S (2:fftn*4000/Fs,:)); # magnitude in range 0<f<=4000 Hz.
 %! S = S/max(max(S));          # normalize magnitude so that max is 0 dB.
 %! S = max (S, 10^(-40/10));   # clip below -40 dB.
 %! S = min (S, 10^(-3/10));    # clip above -3 dB.
 %! imagesc (flipud (20*log10 (S)), 1);
 %! % you should now see a spectrogram in the image window
 
 
-### now test test itself
+## now test 'test' itself
 
-%!## usage and error testing
+## usage and error testing
 % !fail ('test','usage.*test')           # no args, generates usage()
 % !fail ('test (1,2,3,4)','usage.*test') # too many args, generates usage()
 %!fail ('test ("test", "bogus")','unknown flag')  # incorrect args
 %!fail ('garbage','garbage.*undefined')  # usage on nonexistent function should be
 
 %!error test                     # no args, generates usage()
 %!error test (1,2,3,4)           # too many args, generates usage()
 %!error <unknown flag> test ("test", 'bogus'); # incorrect args, generates error()
@@ -749,17 +765,17 @@ endfunction
 
 %!error test ("test", 'bogus');  # test without pattern
 
 %!test
 %! lastwarn();            # clear last warning just in case
 
 %!warning <warning message> warning ('warning message');
 
-%!## test of shared variables
+## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
 %!test   assert (a,3)     # variable should equal 3
 %!shared b,c              # replace shared variables
 %!test assert (!exist ("a", "var"));  # a no longer exists
 %!test assert (isempty (b));   # variables start off empty
 %!shared a,b,c            # recreate a shared variable
 %!test assert (isempty (a));   # value is empty even if it had a previous value
@@ -787,27 +803,27 @@ endfunction
 %! x = 2*y;
 %! z = 3*y;
 %!endfunction
 %!test                   # Test a test function with multiple returns
 %! [x,z] = __test_a (3);
 %! assert (x,6);
 %! assert (z,9);
 
-%!## test of assert block
+## test of assert block
 %!assert (isempty ([]))      # support for test assert shorthand
 
-%!## demo blocks
+## demo blocks
 %!demo                   # multiline demo block
 %! t = [0:0.01:2*pi]; x = sin (t);
 %! plot (t,x);
 %! % you should now see a sine wave in your figure window
 %!demo a=3               # single line demo blocks work too
 
-%!## this is a comment block. it can contain anything.
+## this is a comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
 %! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
 % !# failure tests.  All the following should fail. These tests should
 % !# be disabled unless you are developing test() since users don't
 % !# like to be presented with expected failures.  I use % ! to disable.
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -16,18 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{d} =} addtodate (@var{d}, @var{q}, @var{f})
 ## Add @var{q} amount of time (with units @var{f}) to the serial datenum,
 ## @var{d}.
 ##
-## @var{f} must be one of "year", "month", "day", "hour", "minute", "second",
-## or "millisecond".
+## @var{f} must be one of @qcode{"year"}, @qcode{"month"}, @qcode{"day"},
+## @qcode{"hour"}, @qcode{"minute"}, @qcode{"second"}, or
+## @qcode{"millisecond"}.
 ## @seealso{datenum, datevec, etime}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function d = addtodate (d, q, f)
 
   persistent mult = struct ("day", 1, "hour", 1/24, "minute", 1/1440, ...
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} asctime (@var{tm_struct})
 ## Convert a time structure to a string using the following 
-## format: "ddd mmm mm HH:MM:SS yyyy".  For example:
+## format: @qcode{"ddd mmm mm HH:MM:SS yyyy"}.  For example:
 ##
 ## @example
 ## @group
 ## asctime (localtime (time ()))
 ##      @result{} "Mon Feb 17 01:15:06 1997"
 ## @end group
 ## @end example
 ##
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -49,13 +49,14 @@ function retval = clock ()
   retval(2) = tm.mon + 1;
   retval(3) = tm.mday;
   retval(4) = tm.hour;
   retval(5) = tm.min;
   retval(6) = tm.sec + tm.usec / 1e6;
 
 endfunction
 
+
 %!test
 %! t1 = clock;
 %! t2 = str2num (strftime ("[%Y, %m, %d, %H, %M, %S]", localtime (time ())));
 %! assert (etime (t1, t2) < 1);
 
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -198,8 +198,9 @@ endfunction
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 
 %% Test input validation
 %!error datenum ()
 %!error datenum (1,2,3,4,5,6,7)
 %!error <expected date vector containing> datenum ([1, 2])
 %!error <expected date vector containing> datenum ([1,2,3,4,5,6,7])
 %!error <all inputs must be of class double> datenum (int32 (2000), int32 (1), int32 (1))
+
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -32,26 +32,26 @@
 ## are to be interpreted in.  If not specified, it defaults to the current
 ## year minus 50.
 ##
 ## For example, the date 730736.65149 (2000-09-07 15:38:09.0934) would be
 ## formatted as follows:
 ##
 ## @multitable @columnfractions 0.1 0.45 0.35
 ## @headitem Code @tab Format @tab Example
-## @item  0 @tab dd-mmm-yyyy HH:MM:SS   @tab 07-Sep-2000 15:38:09
-## @item  1 @tab dd-mmm-yyyy            @tab 07-Sep-2000
-## @item  2 @tab mm/dd/yy               @tab 09/07/00
-## @item  3 @tab mmm                    @tab Sep
-## @item  4 @tab m                      @tab S
-## @item  5 @tab mm                     @tab 09
-## @item  6 @tab mm/dd                  @tab 09/07
-## @item  7 @tab dd                     @tab 07
-## @item  8 @tab ddd                    @tab Thu
-## @item  9 @tab d                      @tab T
+## @item 0 @tab dd-mmm-yyyy HH:MM:SS   @tab 07-Sep-2000 15:38:09
+## @item 1 @tab dd-mmm-yyyy            @tab 07-Sep-2000
+## @item 2 @tab mm/dd/yy               @tab 09/07/00
+## @item 3 @tab mmm                    @tab Sep
+## @item 4 @tab m                      @tab S
+## @item 5 @tab mm                     @tab 09
+## @item 6 @tab mm/dd                  @tab 09/07
+## @item 7 @tab dd                     @tab 07
+## @item 8 @tab ddd                    @tab Thu
+## @item 9 @tab d                      @tab T
 ## @item 10 @tab yyyy                   @tab 2000
 ## @item 11 @tab yy                     @tab 00
 ## @item 12 @tab mmmyy                  @tab Sep00
 ## @item 13 @tab HH:MM:SS               @tab 15:38:09
 ## @item 14 @tab HH:MM:SS PM            @tab 03:38:09 PM
 ## @item 15 @tab HH:MM                  @tab 15:38
 ## @item 16 @tab HH:MM PM               @tab 03:38 PM
 ## @item 17 @tab QQ-YY                  @tab Q3-00
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -19,33 +19,45 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} datetick ()
 ## @deftypefnx {Function File} {} datetick (@var{form})
 ## @deftypefnx {Function File} {} datetick (@var{axis}, @var{form})
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keeplimits")
 ## @deftypefnx {Function File} {} datetick (@dots{}, "keepticks")
 ## @deftypefnx {Function File} {} datetick (@var{hax}, @dots{})
 ## Add date formatted tick labels to an axis.  The axis to apply the
-## ticks to is determined by @var{axis} which can take the values "x",
-## "y", or "z".  The default value is "x".  The formatting of the labels is
-## determined by the variable @var{form}, which can either be a string or
-## positive integer that @code{datestr} accepts.
+## ticks to is determined by @var{axis} which can take the values @qcode{"x"},
+## @qcode{"y"}, or @qcode{"z"}.  The default value is @qcode{"x"}.  The
+## formatting of the labels is determined by the variable @var{form}, which
+## can either be a string or positive integer that @code{datestr} accepts.
 ## @seealso{datenum, datestr}
 ## @end deftypefn
 
 function datetick (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ("datetick", varargin{:});
+  [hax, varargin, nargin] = __plt_get_axis_arg__ ("datetick", varargin{:});
 
-  oldh = gca ();
+  oldfig = [];
+  if (! isempty (hax))
+    oldfig = get (0, "currentfigure");
+  endif
+  if (isempty (hax))
+    hax = gca ();
+  endif 
+
   unwind_protect
-    axes (h);
+    ## FIXME: This will bring the axes to the top of the stack.
+    ##        This may not always be desirable if there are multiple axes
+    ##        objects.
+    axes (hax);
     __datetick__ (varargin{:});
   unwind_protect_cleanup
-    axes (oldh);
+    if (! isempty (oldfig))
+      set (0, "currentfigure", oldfig);
+    endif
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
 %! yr = 1900:10:2000;
@@ -56,55 +68,50 @@ endfunction
 %! xlabel ("Year");
 %! datetick ("x", "YYYY");
 
 %!demo
 %! clf;
 %! yr = 1988:2:2002;
 %! yr = datenum (yr,1,1);
 %! pr = [12.1 13.3 12.6 13.1 13.3 14.1 14.4 15.2];
-%! plot (yr, pr);
+%! plot (yr, pr, "-o");
 %! xlabel ("year");
 %! ylabel ("average price");
 %! ax = gca;
 %! set (ax, "xtick", datenum (1990:5:2005,1,1));
 %! datetick (2, "keepticks");
 %! set (ax, "ytick", 12:16);
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
 
 function __datetick__ (varargin)
 
   keeplimits = false;
+  idx = strcmpi (varargin, "keeplimits");
+  if (any (idx))
+    keeplimits = true;
+    varargin = varargin(! idx);
+  endif
   keepticks = false;
-  idx = [];
-  for i = 1 : nargin
-    arg = varargin {i};
-    if (ischar (arg))
-      if (strcmpi (arg, "keeplimits"))
-        keeplimits = true;
-        idx = [idx, i];
-      elseif (strcmpi (arg, "keepticks"))
-        keepticks = true;
-        idx = [idx, i];
-      endif
-    endif
-  endfor
+  idx = strcmpi (varargin, "keepticks");
+  if (any (idx))
+    keepticks = true;
+    varargin = varargin(! idx);
+  endif
 
-  varargin(idx) = [];
-  nargin = length (varargin);
+  nargin = numel (varargin); 
   form = [];
   ax = "x";
 
   if (nargin != 0)
     arg = varargin{1};
-    if (ischar (arg) && (strcmp (arg, "x") || strcmp (arg, "y")
-                         || strcmp (arg, "z")))
-      ax = arg;
+    if (ischar (arg) && any (strcmpi (arg, {"x", "y", "z"})))
+      ax = tolower (arg);
       if (nargin > 1)
         form = varargin{2};
         varargin(1:2) = [];
       else
         varargin(1) = [];
       endif
     else
       form = arg;
@@ -116,36 +123,36 @@ function __datetick__ (varargin)
   if (length (varargin) > 0)
     startdate = varargin{1};
   else
     startdate = [];
   endif
 
   if (! isempty (form))
     if (isnumeric (form))
-      if (! isscalar (form) || floor (form) != form || form < 0)
+      if (! isscalar (form) || form < 0 || form != fix (form))
         error ("datetick: expecting FORM argument to be a positive integer");
       endif
     elseif (! ischar (form))
       error ("datetick: expecting valid date format string");
     endif
   endif
 
   if (keepticks)
-    ticks = get (gca (), strcat (ax, "tick"));
+    ticks = get (gca (), [ax "tick"]);
   else
     ## Need to do our own axis tick position calculation as
     ## year, etc, don't fallback on nice datenum values.
     objs = findall (gca ());
     xmax = NaN;
     xmin = NaN;
     for i = 1 : length (objs)
       fld = get (objs (i));
-      if (isfield (fld, strcat (ax, "data")))
-        xdata = getfield (fld, strcat (ax, "data"))(:);
+      if (isfield (fld, [ax "data"]))
+        xdata = getfield (fld, [ax "data"])(:);
         xmin = min (xmin, min (xdata));
         xmax = max (xmax, max (xdata));
       endif
     endfor
 
     if (isnan (xmin) || isnan (xmax))
       xmin = 0;
       xmax = 1;
@@ -204,17 +211,17 @@ function __datetick__ (varargin)
       form = 13;
     elseif (r < 2)
       ## hours
       form = 15;
     elseif (r < 15)
       ## days
       form = 8;
     elseif (r < 365)
-      ## FIXME -- FORM should be 19 for European users who use dd/mm
+      ## FIXME: FORM should be 19 for European users who use dd/mm
       ## instead of mm/dd.  How can that be determined automatically?
       ## months
       form = 6;
     elseif (r < 90*12)
       ## quarters
       form = 27;
     else
       ## years
@@ -238,27 +245,27 @@ function __datetick__ (varargin)
       sticks = datestr (ticks, form);
     endif
   endif
 
   sticks = mat2cell (sticks, ones (rows (sticks), 1), columns (sticks));
 
   if (keepticks)
     if (keeplimits)
-      set (gca (), strcat (ax, "ticklabel"), sticks);
+      set (gca (), [ax "ticklabel"], sticks);
     else
-      set (gca (), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
-      [min(ticks), max(ticks)]);
+      set (gca (), [ax "ticklabel"], sticks,
+                   [ax "lim"], [min(ticks), max(ticks)]);
     endif
   else
     if (keeplimits)
-      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
+      set (gca (), [ax "tick"], ticks, [ax "ticklabel"], sticks);
     else
-      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
-      strcat (ax, "lim"), [min(ticks), max(ticks)]);
+      set (gca (), [ax "tick"], ticks, [ax "ticklabel"], sticks,
+                   [ax "lim"], [min(ticks), max(ticks)]);
     endif
   endif
 endfunction
 
 function [a, b] = __magform__ (x)
   if (x == 0)
     a = 0;
     b = 0;
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -19,24 +19,24 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{n}, @var{s}] =} weekday (@var{d})
 ## @deftypefnx {Function File} {[@var{n}, @var{s}] =} weekday (@var{d}, @var{format})
 ## Return the day of the week as a number in @var{n} and as a string in @var{s}.
 ## The days of the week are numbered 1--7 with the first day being Sunday.
 ##
 ## @var{d} is a serial date number or a date string.
 ##
-## If the string @var{format} is not present or is equal to "short" then
+## If the string @var{format} is not present or is equal to @qcode{"short"} then
 ## @var{s} will contain the abbreviated name of the weekday.  If @var{format}
-## is "long" then @var{s} will contain the full name.
+## is @qcode{"long"} then @var{s} will contain the full name.
 ##
 ## Table of return values based on @var{format}:
 ##
 ## @multitable @columnfractions .06 .13 .16
-## @headitem @var{n} @tab "short" @tab "long"
+## @headitem @var{n} @tab @qcode{"short"} @tab @qcode{"long"}
 ## @item 1 @tab Sun @tab Sunday
 ## @item 2 @tab Mon @tab Monday
 ## @item 3 @tab Tue @tab Tuesday
 ## @item 4 @tab Wed @tab Wednesday
 ## @item 5 @tab Thu @tab Thursday
 ## @item 6 @tab Fri @tab Friday
 ## @item 7 @tab Sat @tab Saturday
 ## @end multitable
diff --git a/scripts/ui/errordlg.m b/scripts/ui/errordlg.m
--- a/scripts/ui/errordlg.m
+++ b/scripts/ui/errordlg.m
@@ -19,31 +19,33 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} errordlg (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} errordlg (@var{msg}, @var{title})
 ## Display @var{msg} using an error dialog box.
 ##
 ## The message may have multiple lines separated by newline characters
 ## ("\n"), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
-## set the dialog caption.  The default title is "Error Dialog".
+## set the dialog caption.  The default title is @qcode{"Error Dialog"}.
 ##
 ## The return value is always 1.
 ## @seealso{helpdlg, inputdlg, listdlg, msgbox, questdlg, warndlg}
 ## @end deftypefn
 
 function retval = errordlg (msg, title = "Error Dialog")
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("errdlg", msg, title, "error");
 
 endfunction
 
-%!demo
-%!  disp('- test errordlg with prompt only.');
-%!  errordlg('Oops, an expected error occured');
 
 %!demo
-%!  disp('- test errordlg with prompt and caption.');
-%!  errordlg('Oops another error','This is a very long and informative caption');
+%! disp ('- test errordlg with prompt only.');
+%! errordlg ('Oops, an expected error occured');
+
+%!demo
+%! disp ('- test errordlg with prompt and caption.');
+%! errordlg ('Oops another error','This is a very long and informative caption');
+
diff --git a/scripts/ui/helpdlg.m b/scripts/ui/helpdlg.m
--- a/scripts/ui/helpdlg.m
+++ b/scripts/ui/helpdlg.m
@@ -19,31 +19,33 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} helpdlg (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} helpdlg (@var{msg}, @var{title})
 ## Display @var{msg} in a help dialog box.
 ##
 ## The message may have multiple lines separated by newline characters
 ## ("\n"), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
-## set the dialog caption.  The default title is "Help Dialog".
+## set the dialog caption.  The default title is @qcode{"Help Dialog"}.
 ##
 ## The return value is always 1.
 ## @seealso{errordlg, inputdlg, listdlg, msgbox, questdlg, warndlg}
 ## @end deftypefn
 
 function retval = helpdlg (msg, title = "Help Dialog")
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("helpdlg", msg, title, "help");
 
 endfunction
 
-%!demo
-%!  disp('- test helpdlg with a help message only.');
-%!  helpdlg("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
 
 %!demo
-%!  disp('- test helpdlg with help message and caption.');
-%!  helpdlg('You should see a single line.','A help dialog');
+%! disp ('- test helpdlg with a help message only.');
+%! helpdlg ("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
+
+%!demo
+%! disp ('- test helpdlg with help message and caption.');
+%! helpdlg ('You should see a single line.','A help dialog');
+
diff --git a/scripts/ui/inputdlg.m b/scripts/ui/inputdlg.m
--- a/scripts/ui/inputdlg.m
+++ b/scripts/ui/inputdlg.m
@@ -27,17 +27,18 @@
 ##
 ## Inputs:
 ##
 ## @table @var
 ## @item prompt
 ## A cell array with strings labeling each text field.  This input is required. 
 ##
 ## @item title
-## String to use for the caption of the dialog.  The default is "Input Dialog".
+## String to use for the caption of the dialog.  The default is @qcode{"Input
+## Dialog"}.
 ##
 ## @item rowscols
 ## Specifies the size of the text fields and can take three forms:
 ##
 ## @enumerate
 ## @item a scalar value which defines the number of rows used for each
 ## text field.
 ##
@@ -60,17 +61,17 @@
 function cstr = inputdlg (prompt, title = "Input Dialog", varargin)
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (iscell (prompt))
     ## Silently extract only char elements
-    prompt = prompt(cellfun ("ischar", prompt));
+    prompt = prompt(cellfun ("isclass", prompt, "char"));
   elseif (ischar (prompt))
     prompt = {prompt};
   else
     error ("inputdlg: PROMPT must be a character string or cellstr array");
   endif
 
   if (! ischar (title))
     error ("inputdlg: TITLE must be a character string");
@@ -137,69 +138,71 @@ function cstr = inputdlg (prompt, title 
       cstr = cellstr (user_inputs);
     endif
   else
     error ("inputdlg is not available in this version of Octave");
   endif
 
 endfunction
 
-%!demo
-%!  disp('- test inputdlg with prompt and caption only.');
-%!  prompt = {'Width','Height','Depth'};
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions' );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
 
 %!demo
-%!  disp('- test inputdlg with prescribed scalar (2 lines per text field) and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.1','2.2','3.3'};
-%!  rc = 2;
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prompt and caption only.');
+%! prompt = {'Width','Height','Depth'};
+%! dims = inputdlg (prompt, 'Enter Box Dimensions');
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
+
+%!demo
+%! disp ('- test inputdlg with prescribed scalar (2 lines per text field) and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.1','2.2','3.3'};
+%! rc = 2;
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!    helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
 
 %!demo
-%!  disp('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.10', '2.10', '3.10'};
-%!  rc = [1,2,3];  % NOTE: must be an array
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.10', '2.10', '3.10'};
+%! rc = [1,2,3];  % NOTE: must be an array
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
 
 %!demo
-%!  disp('- test inputdlg with prescribed row by column sizes and defaults.');
-%!  prompt = {'Width','Height','Depth'};
-%!  default = {'1.10', '2.20', '3.30'};
-%!  rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
-%!  dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
-%!  if isempty(dims)
-%!     helpdlg('Canceled by user', 'Information');
-%!  else
-%!     volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
-%!     surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
-%!                    str2num(dims{2}) * str2num(dims{3}) + ...
-%!                    str2num(dims{1}) * str2num(dims{3}));
-%!     helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
-%!  end
+%! disp ('- test inputdlg with prescribed row by column sizes and defaults.');
+%! prompt = {'Width','Height','Depth'};
+%! default = {'1.10', '2.20', '3.30'};
+%! rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
+%! dims = inputdlg (prompt, 'Enter Box Dimensions',rc,default);
+%! if (isempty (dims))
+%!   helpdlg ('Canceled by user', 'Information');
+%! else
+%!   volume  = str2num (dims{1}) * str2num (dims{2}) * str2num (dims{3});
+%!   surface = 2 * (str2num (dims{1}) * str2num (dims{2}) + ...
+%!                  str2num (dims{2}) * str2num (dims{3}) + ...
+%!                  str2num (dims{1}) * str2num (dims{3}));
+%!   helpdlg (sprintf ('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+%! end
+
diff --git a/scripts/ui/listdlg.m b/scripts/ui/listdlg.m
--- a/scripts/ui/listdlg.m
+++ b/scripts/ui/listdlg.m
@@ -22,47 +22,47 @@
 ## selection indices @var{sel} and a flag @var{ok} indicating how the
 ## user closed the dialog box.  The value of @var{ok} is 1 if the user
 ## closed the box with the OK button, otherwise it is 0 and @var{sel} is
 ## empty.
 ##
 ## The indices in @var{sel} are 1-based.
 ##
 ## The arguments are specified in form of @var{key}, @var{value} pairs. 
-## The "ListString" argument pair must be specified.
+## The @qcode{"ListString"} argument pair must be specified.
 ##
 ## Valid @var{key} and @var{value} pairs are:
 ##
 ## @table @asis
-## @item "ListString"
+## @item @qcode{"ListString"}
 ## a cell array of strings comprising the content of the list.
 ##
-## @item "SelectionMode"
-## can be either "Single" or "Multiple" (default).
+## @item @qcode{"SelectionMode"}
+## can be either @qcode{"Single"} or @qcode{"Multiple"} (default).
 ##
-## @item "ListSize"
+## @item @qcode{"ListSize"}
 ## a vector with two elements @var{width} and @var{height} defining
 ## the size of the list field in pixels.  Default is [160 300].
 ##
-## @item "InitialValue"
+## @item @qcode{"InitialValue"}
 ## a vector containing 1-based indices of preselected elements.  Default
 ## is 1 (first item).
 ##
-## @item "Name"
+## @item @qcode{"Name"}
 ## a string to be used as the dialog caption.  Default is "".
 ##
-## @item "PromptString"
+## @item @qcode{"PromptString"}
 ## a cell array of strings to be displayed above the list field.  Default
 ## is @{@}.
 ##
-## @item "OKString"
-## a string used to label the OK button.  Default is "OK".
+## @item @qcode{"OKString"}
+## a string used to label the OK button.  Default is @qcode{"OK"}.
 ##
-## @item "CancelString"
-## a string used to label the Cancel button.  Default is "Cancel".
+## @item @qcode{"CancelString"}
+## a string used to label the Cancel button.  Default is @qcode{"Cancel"}.
 ## @end table
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## [sel, ok] = listdlg ("ListString", @{"An item", "another", "yet another"@},
 ##                      "SelectionMode", "Multiple");
@@ -89,31 +89,31 @@ function [sel, ok] = listdlg (varargin)
   initialvalue = 1;
   name = "";
   prompt = {};
   okstring = "OK";
   cancelstring = "Cancel";
 
   ## handle key, value pairs
   for i = 1:2:nargin-1
-    if strcmp (varargin{i}, "ListString")
+    if (strcmp (varargin{i}, "ListString"))
       listcell = varargin{i+1};
-    elseif strcmp (varargin{i}, "SelectionMode")
+    elseif (strcmp (varargin{i}, "SelectionMode"))
       selmode = varargin{i+1};
-    elseif strcmp (varargin{i}, "ListSize")
+    elseif (strcmp (varargin{i}, "ListSize"))
       listsize = varargin{i+1};
-    elseif strcmp (varargin{i}, "InitialValue")
+    elseif (strcmp (varargin{i}, "InitialValue"))
       initialvalue = varargin{i+1};
-    elseif strcmp (varargin{i}, "Name")
+    elseif (strcmp (varargin{i}, "Name"))
       name = varargin{i+1};
-    elseif strcmp (varargin{i}, "PromptString")
+    elseif (strcmp (varargin{i}, "PromptString"))
       prompt = varargin{i+1};
-    elseif strcmp (varargin{i}, "OKString")
+    elseif (strcmp (varargin{i}, "OKString"))
       okstring = varargin{i+1};
-    elseif strcmp (varargin{i}, "CancelString")
+    elseif (strcmp (varargin{i}, "CancelString"))
       cancelstring = varargin{i+1};
     endif
   endfor
 
   ## make sure prompt strings are a cell array
   if (! iscell (prompt))
     prompt = {prompt};
   endif
@@ -132,17 +132,17 @@ function [sel, ok] = listdlg (varargin)
     [sel, ok] = __octave_link_list_dialog__ (listcell, selmode, listsize,
                                             initialvalue, name, prompt,
                                             okstring, cancelstring);
   elseif (__have_feature__ ("JAVA"))
     ## transform matrices to cell arrays of strings
     ## swap width and height to correct calling format for JDialogBox
     listsize = {num2str(listsize(2)), num2str(listsize(1))};
     initialvalue = arrayfun (@num2str, initialvalue, "UniformOutput", false);
-    if isempty(prompt)
+    if (isempty (prompt))
       prompt = {""};
     endif
 
     ret = javaMethod ("listdlg", "org.octave.JDialogBox", listcell,
                       selmode, listsize, initialvalue, name, prompt,
                       okstring, cancelstring);
 
     if (numel (ret) > 0)
@@ -153,40 +153,42 @@ function [sel, ok] = listdlg (varargin)
       ok = 0;
     endif
   else
     error ("listdlg is not available in this version of Octave");
   endif
 
 endfunction
 
+
 %!demo
-%!  disp('- test listdlg with selectionmode single. No caption, no prompt.');
-%!  itemlist = {'An item \\alpha', 'another', 'yet another'};
-%!  s = listdlg ( 'ListString',itemlist, 'SelectionMode','Single' );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with selectionmode single. No caption, no prompt.');
+%! itemlist = {'An item \\alpha', 'another', 'yet another'};
+%! s = listdlg ('ListString',itemlist, 'SelectionMode','Single');
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
 
 %!demo
-%!  disp('- test listdlg with selectionmode and preselection. Has caption and two lines prompt.');
-%!  itemlist = {'An item \\alpha', 'another', 'yet another'};
-%!  s = listdlg ( 'ListString',itemlist, ...
-%!                'SelectionMode','Multiple', ...
-%!                'Name','Selection Dialog', ...
-%!                'InitialValue',[1,2,3,4],
-%!                'PromptString',{'Select <b>an</b> item...', '...or <b>multiple</b> items'} );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with selectionmode and preselection. Has caption and two lines prompt.');
+%! itemlist = {'An item \\alpha', 'another', 'yet another'};
+%! s = listdlg ('ListString',itemlist, ...
+%!              'SelectionMode','Multiple', ...
+%!              'Name','Selection Dialog', ...
+%!              'InitialValue',[1,2,3,4],
+%!              'PromptString',{'Select <b>an</b> item...', '...or <b>multiple</b> items'} );
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
 
 %!demo
-%!  disp('- test listdlg with listsize.');
-%!  itemlist = {"Neutron","Electron","Quark","Proton","Neutrino"};
-%!  s = listdlg ( "ListString",itemlist,
-%!                "Name","Bits and Pieces",
-%!                "ListSize",[200 75] );
-%!  imax = numel (s);
-%!  for i=1:1:imax
-%!     disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
-%!  end
+%! disp ('- test listdlg with listsize.');
+%! itemlist = {"Neutron","Electron","Quark","Proton","Neutrino"};
+%! s = listdlg ("ListString",itemlist,
+%!              "Name","Bits and Pieces",
+%!              "ListSize",[200 75] );
+%! imax = numel (s);
+%! for i=1:1:imax
+%!   disp (['Selected: ',num2str (i),': ', itemlist{s (i)}]);
+%! end
+
diff --git a/scripts/ui/msgbox.m b/scripts/ui/msgbox.m
--- a/scripts/ui/msgbox.m
+++ b/scripts/ui/msgbox.m
@@ -18,37 +18,39 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} msgbox (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title})
 ## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title}, @var{icon})
 ## Display @var{msg} using a message dialog box. 
 ##
 ## The message may have multiple lines separated by newline characters
-## (@code{"\n"}), or it may be a cellstr array with one element for each
+## (@qcode{"\n"}), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
 ## decorate the dialog caption.
 ##
 ## The optional argument @var{icon} selects a dialog icon. 
-## It can be one of @code{"none"} (default), @code{"error"}, @code{"help"}, or
-## @code{"warn"}.
+## It can be one of @qcode{"none"} (default), @qcode{"error"},
+## @qcode{"help"}, or @qcode{"warn"}.
 ##
 ## The return value is always 1.
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg}
 ## @end deftypefn
 
 function retval = msgbox (msg, title = "", varargin)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   retval = message_dialog ("msgbox", msg, title, varargin{:});
 
 endfunction
 
-%!demo
-%!  disp('- test msgbox message only.');
-%!  msgbox("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
 
 %!demo
-%!  disp('- test msgbox message and caption.');
-%!  msgbox('You should see a single line.','A msgbox');
+%! disp('- test msgbox message only.');
+%! msgbox("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
+
+%!demo
+%! disp('- test msgbox message and caption.');
+%! msgbox('You should see a single line.','A msgbox');
+
diff --git a/scripts/ui/private/message_dialog.m b/scripts/ui/private/message_dialog.m
--- a/scripts/ui/private/message_dialog.m
+++ b/scripts/ui/private/message_dialog.m
@@ -58,8 +58,9 @@ function retval = message_dialog (caller
     retval = __octave_link_message_dialog__ (icon, msg, title);
   elseif (__have_feature__ ("JAVA"))
     retval = javaMethod (dlg, "org.octave.JDialogBox", msg, title);
   else
     error ("%s is not available in this version of Octave", dlg);
   endif
 
 endfunction
+
diff --git a/scripts/ui/questdlg.m b/scripts/ui/questdlg.m
--- a/scripts/ui/questdlg.m
+++ b/scripts/ui/questdlg.m
@@ -33,17 +33,18 @@
 ## decorate the dialog caption.
 ##
 ## The string @var{default} identifies the default button, 
 ## which is activated by pressing the @key{ENTER} key.
 ## It must match one of the strings given in @var{btn1}, @var{btn2}, or
 ## @var{btn3}.
 ##
 ## If only @var{msg} and @var{title} are specified, three buttons with
-## the default captions "Yes", "No", and "Cancel" are used.
+## the default captions @qcode{"Yes"}, @qcode{"No"}, and @qcode{"Cancel"} are
+## used.
 ##
 ## If only two button captions, @var{btn1} and @var{btn2}, are specified 
 ## the dialog will have only these two buttons.
 ##
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, warndlg}
 ## @end deftypefn
 
 function btn = questdlg (msg, title = "Question Dialog", varargin)
@@ -76,37 +77,37 @@ function btn = questdlg (msg, title = "Q
     case 0
       ## use default default
 
     case 1
       ## default button string
       options{4} = varargin{1};  # default
       if (! any (strcmp (options{4}, options(1:3))))
         error (defbtn_error_msg);
-      end
+      endif
 
     case 3
       ## two buttons and default button string
       options{1} = varargin{1};  # button1
       options{2} = "";           # not used, no middle button
       options{3} = varargin{2};  # button3
       options{4} = varargin{3};  # default
       if (! any (strcmp (options{4}, options([1 3]))))
         error (defbtn_error_msg);
-      end
+      endif
 
     case 4
       ## three buttons and default button string
       options{1} = varargin{1};  # button1
       options{2} = varargin{2};  # button2
       options{3} = varargin{3};  # button3
       options{4} = varargin{4};  # default
       if (! any (strcmp (options{4}, options(1:3))))
         error (defbtn_error_msg);
-      end
+      endif
 
     otherwise
       print_usage ();
 
   endswitch
 
   if (__octave_link_enabled__ ())
     btn = __octave_link_question_dialog__ (msg, title, options{1}, options{2},
@@ -115,60 +116,61 @@ function btn = questdlg (msg, title = "Q
     btn = javaMethod ("questdlg", "org.octave.JDialogBox", msg,
                       title, options);
   else
     error ("questdlg is not available in this version of Octave");
   endif
 
 endfunction
 
+
 %!demo
-%!  disp('- test questdlg with two buttons');
-%!  a = questdlg('Would you like some free money?',...
+%! disp ('- test questdlg with two buttons');
+%! a = questdlg ('Would you like some free money?',...
 %!               '$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $',...
 %!               'No', 'Cancel', 'Cancel');
-%!  if strcmp (a, 'No')
-%!    msgbox('Suit yourself.', 'Message Box');
-%!  endif
+%! if (strcmp (a, 'No'))
+%!   msgbox ('Suit yourself.', 'Message Box');
+%! endif
 
 %!demo
-%!  disp('- test questdlg with message and title only.');
-%!  a = 'No';
-%!  c = 0;
-%!  while (strcmp(a, 'No') || !c)
-%!    a = questdlg('Close this Question Dialog?', 'Reductio Ad Absurdum');
-%!    if strcmp(a, 'Yes')
-%!      q = 'Are you sure?';
-%!      while (strcmp(a, 'Yes') && !c)
-%!        a = questdlg(q, 'Reductio Ad Absurdum');
-%!        word = ' really';
-%!        i = strfind(q, word);
-%!        if isempty( i )
-%!          i = strfind(q, ' sure');
-%!          q = [q '!'];
-%!        else
-%!          word = [word ','];
-%!        endif
-%!        q = [q(1:i-1) word q(i:end)];
-%!      endwhile
-%!    endif
-%!    if strcmp(a, 'Cancel')
-%!      warndlg('Answer "Yes" or "No".', 'Warning Dialog');
-%!      a = 'No';
-%!      c = 1;
-%!    endif
-%!  endwhile
-%!  msgbox('Whew!');
+%! disp ('- test questdlg with message and title only.');
+%! a = 'No';
+%! c = 0;
+%! while (strcmp (a, 'No') || !c)
+%!   a = questdlg ('Close this Question Dialog?', 'Reductio Ad Absurdum');
+%!   if (strcmp (a, 'Yes'))
+%!     q = 'Are you sure?';
+%!     while (strcmp (a, 'Yes') && !c)
+%!       a = questdlg (q, 'Reductio Ad Absurdum');
+%!       word = ' really';
+%!       i = strfind (q, word);
+%!       if (isempty (i))
+%!         i = strfind (q, ' sure');
+%!         q = [q '!'];
+%!       else
+%!         word = [word ','];
+%!       endif
+%!       q = [q(1:i-1) word q(i:end)];
+%!     endwhile
+%!   endif
+%!   if (strcmp (a, 'Cancel'))
+%!     warndlg ('Answer "Yes" or "No".', 'Warning Dialog');
+%!     a = 'No';
+%!     c = 1;
+%!   endif
+%! endwhile
+%! msgbox ('Whew!');
 
 %!demo
-%!  disp('- test questdlg with five inputs');
-%!  ans = questdlg('Are you ready Steve?', 'Brian', 'No', 'Uh huh', 'Uh huh');
-%!  if !strcmp (ans, 'No')
-%!    ans = questdlg ('Andy?', 'Brian', 'No', 'Yeah', 'Yeah');
-%!    if !strcmp (ans, 'No')
-%!      ans = questdlg ('Mick?', 'Brian', 'No', 'Okay', 'Okay');
-%!      if !strcmp (ans, 'No')
-%!        ans = msgbox ("Well all right, fellas.    \n\n     Let''s GO!!!!!",...
-%!                      'Ballroom Blitz', 'none');
-%!      endif
-%!    endif
-%!  endif
+%! disp ('- test questdlg with five inputs');
+%! ans = questdlg ('Are you ready Steve?', 'Brian', 'No', 'Uh huh', 'Uh huh');
+%! if (! strcmp (ans, 'No'))
+%!   ans = questdlg ('Andy?', 'Brian', 'No', 'Yeah', 'Yeah');
+%!   if (! strcmp (ans, 'No'))
+%!     ans = questdlg ('Mick?', 'Brian', 'No', 'Okay', 'Okay');
+%!     if (! strcmp (ans, 'No'))
+%!       ans = msgbox ("Well all right, fellas.    \n\n     Let''s GO!!!!!",...
+%!                     'Ballroom Blitz', 'none');
+%!     endif
+%!   endif
+%! endif
 
diff --git a/scripts/ui/warndlg.m b/scripts/ui/warndlg.m
--- a/scripts/ui/warndlg.m
+++ b/scripts/ui/warndlg.m
@@ -19,30 +19,32 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} warndlg (@var{msg})
 ## @deftypefnx {Function File} {@var{h} =} warndlg (@var{msg}, @var{title})
 ## Display @var{msg} using a warning dialog box. 
 ##
 ## The message may have multiple lines separated by newline characters
 ## ("\n"), or it may be a cellstr array with one element for each
 ## line.  The optional input @var{title} (character string) can be used to
-## set the dialog caption.  The default title is "Warning Dialog".
+## set the dialog caption.  The default title is @qcode{"Warning Dialog"}.
 ##
 ## @seealso{helpdlg, inputdlg, listdlg, questdlg}
 ## @end deftypefn
 
 function retval = warndlg (msg, title = "Warning Dialog")
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = message_dialog ("warndlg", msg, title, "warn");
 
 endfunction
 
-%!demo
-%!  disp('- test warndlg with prompt only.');
-%!  warndlg('Oh, a warning occured');
 
 %!demo
-%!  disp('- test warndlg with prompt and caption.');
-%!  warndlg('Oh, No...','This is the last Warning');
+%! disp ('- test warndlg with prompt only.');
+%! warndlg ('Oh, a warning occured');
+
+%!demo
+%! disp ('- test warndlg with prompt and caption.');
+%! warndlg ('Oh, No...','This is the last Warning');
+
diff --git a/src/main.cc b/src/main.cc
--- a/src/main.cc
+++ b/src/main.cc
@@ -36,18 +36,37 @@ main (int argc, char **argv)
 
   octave_process_command_line (argc, argv);
 
   sysdep_init ();
 
   install_defaults ();
 
   if (octave_starting_gui ())
-    retval = octave_start_gui (argc, argv);
+    retval = octave_start_gui (argc, argv, octave_fork_gui ());
   else
     {
       octave_initialize_interpreter (argc, argv, 0);
 
       retval = octave_execute_interpreter ();
     }
 
   return retval;
 }
+
+
+/*!
+@mainpage Source code documentation for GNU Octave
+
+GNU Octave is a high-level language, primarily intended for numerical
+computations.  It provides a convenient interactive command line
+interface for solving linear and nonlinear problems numerically, and
+for performing other numerical experiments.  It may also be used as a
+batch-oriented language for data processing.
+
+GNU Octave is free software. You may redistribute it and/or modify it
+under the terms of the <a href="http://www.gnu.org/licenses/">GNU
+General Public License</a> as published by the Free Software Foundation.
+
+This is the developer documentation for Octave's own source code. It is
+intended to help for hacking Octave. It may also be useful for
+understanding the Octave API when writing your own .oct files.
+*/
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -29,16 +29,17 @@ FCN_FILES = \
   error.tst \
   eval-catch.tst \
   for.tst \
   func.tst \
   global.tst \
   if.tst \
   index.tst \
   io.tst \
+  jit.tst \
   line-continue.tst \
   logical-index.tst \
   null-assign.tst \
   parser.tst \
   prefer.tst \
   range.tst \
   recursion.tst \
   return.tst \
@@ -93,16 +94,17 @@ EXTRA_DIST = \
   $(FCN_FILES)
 
 CLEANFILES = \
   sparse.tst \
   bc-overload-tests.stamp \
   $(GENERATED_BC_OVERLOADS_FILES)
 
 DISTCLEANFILES = \
+  .gdbinit \
   fntests.log
 
 fixedtestsdir := $(octtestsdir)/fixed
 
 nobase_fixedtests_DATA = \
   sparse.tst \
   $(GENERATED_BC_OVERLOADS_FILES) \
   $(filter-out fntests.m, $(FCN_FILES))
diff --git a/test/args.tst b/test/args.tst
--- a/test/args.tst
+++ b/test/args.tst
@@ -118,119 +118,119 @@
 %! assert ([s t u v], [1 2 3 4]);
 
 ## Test default arguments
 ## numeric
 %!function f (x = 0)
 %!  assert (x, 0);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## numeric vector (spaces)
 %!function f (x = [0 1 2])
 %!  assert (x, [0 1 2]);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## numeric vector (range)
 %!function f (x = 1:3)
 %!  assert (x, 1:3);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## numeric vector (commas)
 %!function f (x = [0,1,2])
 %!  assert (x, [0 1 2]);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## numeric vector (commas and spaces)
 %!function f (x = [0, 1, 2])
 %!  assert (x, [0 1 2]);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## numeric matrix
 %!function f (x = [0, 1, 2;3, 4, 5])
 %!  assert (x, [0 1 2;3 4 5]);
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## empty cell
 %!function f (x = {})
 %!  assert (x, {});
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## full cell
 %!function f (x = {1})
 %!  assert (x, {1});
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## many cells
 %!function f (x = {1 'a' "b" 2.0 struct("a", 3)})
 %!  assert (x, {1 'a' "b" 2.0 struct("a", 3)});
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## struct
 %!function f (x = struct("a", 3))
 %!  assert (x, struct ("a", 3));
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## char (double quotes)
 %!function f (x = "a")
 %!  assert (x, "a");
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## char (single quotes)
 %!function f (x = 'a')
 %!  assert (x, "a");
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## char (string, double quotes)
 %!function f (x = "abc123")
 %!  assert (x, "abc123");
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## char (string, double quotes, punctuation)
 %!function f (x = "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\")
 %!  assert (x, "abc123`1234567890-=~!@#$%^&*()_+[]{}|;':\",./<>?\\");
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## Function handle (builtin)
 %!function f (x = @sin)
 %!  finfo = functions (x);
 %!  fname = finfo.function;
 %!  assert (isa (x, "function_handle") && strcmp (fname, "sin"));
 %!endfunction
 %!test
-%!  f()
+%! f()
 
 ## Function handle (anonymous)
 %!function f (x = @(x) x.^2)
 %!  finfo = functions (x);
 %!  ftype = finfo.type;
 %!  assert (isa (x, "function_handle") && strcmp (ftype, "anonymous"));
 %!endfunction
 %!test
-%!  f()
+%! f()
 
diff --git a/test/build-sparse-tests.sh b/test/build-sparse-tests.sh
--- a/test/build-sparse-tests.sh
+++ b/test/build-sparse-tests.sh
@@ -320,34 +320,34 @@ gen_elementop_tests() {
 %!assert (bf.*as, sparse (bf.*af))
 
 %!assert (as./bf, sparse (af./bf), 100*eps)
 %!assert (bf.\as, sparse (bf.\af), 100*eps)
 
 %!test
 %! sv = as.^bf;
 %! fv = af.^bf;
-%! idx = find (af~=0);
+%! idx = find (af!=0);
 %! assert (sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 gen_sparsesparse_elementop_tests() {
     cat >>$TESTS <<EOF
 %!assert (as==bs, sparse (af==bf))
 %!assert (as!=bs, sparse (af!=bf))
 %!assert (as+bs, sparse (af+bf))
 %!assert (as-bs, sparse (af-bf))
 %!assert (as.*bs, sparse (af.*bf))
 %!xtest assert (as./bs, sparse (af./bf), 100*eps)
 %!test
 %! sv = as.^bs;
 %! fv = af.^bf;
-%! idx = find (af~=0);
+%! idx = find (af!=0);
 %! assert(sv(:)(idx), sparse (fv(:)(idx)), 100*eps)
 
 EOF
 }
 
 # test matrix-matrix left and right division: uses as,af,bs,bf
 gen_divop_tests() {
     cat >>$TESTS <<EOF
@@ -572,21 +572,21 @@ gen_unaryop_tests() {
 %!test
 %! [ii,jj,vv,nr,nc] = find (as);
 %! assert (af, full (sparse (ii,jj,vv,nr,nc)));
 %!assert (nnz (as), sum (af(:)!=0))
 %!assert (nnz (as), nnz (af))
 %!assert (issparse (as.'))
 %!assert (issparse (as'))
 %!assert (issparse (-as))
-%!assert (~as, sparse (~af))
+%!assert (!as, sparse (!af))
 %!assert (as.', sparse (af.'));
 %!assert (as',  sparse (af'));
 %!assert (-as, sparse (-af));
-%!assert (~as, sparse (~af));
+%!assert (!as, sparse (!af));
 %!error [i,j] = size (af);as(i-1,j+1);
 %!error [i,j] = size (af);as(i+1,j-1);
 %!test
 %! [Is,Js,Vs] = find (as);
 %! [If,Jf,Vf] = find (af);
 %! assert (Is, If);
 %! assert (Js, Jf);
 %! assert (Vs, Vf);
@@ -648,44 +648,44 @@ gen_square_tests() {
 
 %!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L(P,:)*U(:,Q), bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # inverse
 %! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
@@ -752,44 +752,44 @@ gen_rectangular_tests() {
     cat >>$TESTS <<EOF
 %!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
 %!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L (P,:)*U (:,Q), bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 %!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
-%! # triangularity
+%! ## triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
 EOF
 }
 
@@ -1199,17 +1199,17 @@ gen_rectangular_tests
 gen_section
 gen_sparsesparse_ordering_tests
 gen_section
 echo '%!test af = real (af);' >> $TESTS
 gen_rectangular_tests
 gen_section
 gen_save_tests
 gen_section
-echo '%!test bf = bf+1i*(bf~=0);' >> $TESTS
+echo '%!test bf = bf+1i*(bf!=0);' >> $TESTS
 gen_rectangular_tests
 gen_section
 
 # square operations
 if $preset; then
     echo '%!test af = [1+1i,2-1i,0,0;0,0,0,3+2i;0,0,0,4];' >> $TESTS
     echo '%! as = sparse (af);' >> $TESTS
     echo '%!test bf = [0,1-1i,0,0;2+1i,0,0,0;3-1i,2+3i,0,0];' >> $TESTS
@@ -1237,17 +1237,17 @@ gen_section
 echo '%!test bf = real (bf);' >> $TESTS
 echo '%! bs = sparse (bf);' >> $TESTS
 gen_square_tests
 gen_section
 echo '%!test af = real (af);' >> $TESTS
 echo '%! as = sparse (af);' >> $TESTS
 gen_square_tests
 gen_section
-echo '%!test bf = bf+1i*(bf~=0);' >> $TESTS
+echo '%!test bf = bf+1i*(bf!=0);' >> $TESTS
 echo '%! bs = sparse (bf);' >> $TESTS
 gen_square_tests
 gen_section
 
 # cholesky tests
 if $preset; then
   echo '%!test bf = [5,0,1+1i,0;0,5,0,1-2i;1-1i,0,5,0;0,1+2i,0,5];' >> $TESTS
   echo '%! bs = sparse (bf);' >> $TESTS
diff --git a/test/classes/@Snork/end.m b/test/classes/@Snork/end.m
--- a/test/classes/@Snork/end.m
+++ b/test/classes/@Snork/end.m
@@ -1,9 +1,9 @@
 function r = end (snk, index_pos, num_indices)
 
-  if (num_indices ~= 1)
+  if (num_indices != 1)
     error ('Snork object may only have one index')
   end
 
   r = length (snk.cack);
 
 end
diff --git a/test/classes/@Snork/mpower.m b/test/classes/@Snork/mpower.m
--- a/test/classes/@Snork/mpower.m
+++ b/test/classes/@Snork/mpower.m
@@ -1,10 +1,10 @@
 function s = mpower (s1, x)
 
-  if (~isa (s1, 'Snork') || isa (x, 'Snork'))
+  if (!isa (s1, 'Snork') || isa (x, 'Snork'))
     error ('mpower Snork!!!');
   end
 
   s = s1;
   s.gick = s.gick ^ x;
 
 end
diff --git a/test/classes/@Snork/ne.m b/test/classes/@Snork/ne.m
--- a/test/classes/@Snork/ne.m
+++ b/test/classes/@Snork/ne.m
@@ -1,5 +1,5 @@
 function b = ne (s1, s2)
 
-  b = ~(s1 == s2);
+  b = !(s1 == s2);
 
 end
diff --git a/test/classes/@Snork/power.m b/test/classes/@Snork/power.m
--- a/test/classes/@Snork/power.m
+++ b/test/classes/@Snork/power.m
@@ -1,10 +1,10 @@
 function s = power (s1, x)
 
-  if (~isa (s1, 'Snork') || isa (x, 'Snork'))
+  if (!isa (s1, 'Snork') || isa (x, 'Snork'))
     error ('power Snork!!!');
   end
 
   s = s1;
   s.gick = s.gick .^ x;
 
 end
diff --git a/test/classes/@Snork/subsasgn.m b/test/classes/@Snork/subsasgn.m
--- a/test/classes/@Snork/subsasgn.m
+++ b/test/classes/@Snork/subsasgn.m
@@ -1,28 +1,28 @@
 function snk = subsasgn (snk, s, val)
 
   if (length (s) < 1)
     error ('Snork: needs index');
   end
   switch (s(1).type)
     case '()'
       ind = s(1).subs;
-      if (numel (ind) ~= 1)
+      if (numel (ind) != 1)
         error ('Snork: need exactly one index');
       else
         if (length (s) == 1)
           snk.cack(ind{1}) = val;
         else
           error ('Snork: chained subscripts not allowed for {}');
         end
       end
     case '{}'
       ind = s(1).subs;
-      if (numel (ind) ~= 1)
+      if (numel (ind) != 1)
         error ('Snork: need exactly one index');
       else
         if (length (s) == 1)
           snk.cack(ind{1}) = val;
         else
           error ('Snork: chained subscripts not allowed for {}');
         end
       end
diff --git a/test/classes/@Snork/subsref.m b/test/classes/@Snork/subsref.m
--- a/test/classes/@Snork/subsref.m
+++ b/test/classes/@Snork/subsref.m
@@ -1,24 +1,24 @@
 function b = subsref (snk, s)
 
   if (isempty (s))
     error ('Snork: missing index');
   end
   switch (s(1).type)
     case '()'
       ind = s(1).subs;
-      if (numel (ind) ~= 1)
+      if (numel (ind) != 1)
         error ('Snork: need exactly one index');
       else
         b = snk.cack(ind{1});
       end
     case '{}'
       ind = s(1).subs;
-      if (numel (ind) ~= 1)
+      if (numel (ind) != 1)
         error ('Snork: need exactly one index');
       else
         b = snk.cack(ind{1});
       end
     case '.'
       fld = s.subs;
       if (strcmp (fld, 'gick'))
         b = snk.gick;
diff --git a/test/classes/@Spork/loadobj.m b/test/classes/@Spork/loadobj.m
--- a/test/classes/@Spork/loadobj.m
+++ b/test/classes/@Spork/loadobj.m
@@ -1,8 +1,8 @@
 function out = loadobj (in)
 
   out = in;
-  if (~isa (in, 'Spork'))
+  if (!isa (in, 'Spork'))
     out.cack = [];
   end
 
 end
diff --git a/test/classes/classes.tst b/test/classes/classes.tst
--- a/test/classes/classes.tst
+++ b/test/classes/classes.tst
@@ -54,19 +54,19 @@
 %! assert (isequal (gick (snk),4));
 %!  snk(1) = 3;
 %!test snk{end} = 9;
 %! assert (isequal (cack (snk), [3 1 2 9]));
 %! assert (isequal (getStash (snk), 1));             % Check private functions.
 %! assert (isobject (snk));
 %! assert (isequal (class (snk), 'Snork'));
 %! assert (isa (snk, 'Snork'));
-%! assert (~isa (snk, 'Sneetch'));
+%! assert (!isa (snk, 'Sneetch'));
 %! assert (ismethod (snk, 'gick'));
-%! assert (~ismethod (snk, 'bletch'));
+%! assert (!ismethod (snk, 'bletch'));
 %! assert (exist ('snk') == 1);
 %! assert (exist ('blink') == 0);
 %!test snk1 = Snork (snk);
 %! assert (isequal (class (snk1), 'Snork'));
 %! assert (isequal (gick (snk1), 4));
 %!test snk2 = Snork (-3);
 %! assert (isequal (class (snk2), 'Snork'));
 %! assert (isequal (gick (snk2), -3));
@@ -267,27 +267,27 @@
 %!test  s = s3 \ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
 %!test  s = s3 \ x2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
 %!test  s = x3 \ s2;  assert (isa (s, 'Snork') && isequal (s.gick, x3 \ x2));
 
 %% Test overloaded eq (==) for the Snork class
 %!assert (s1 == s1)
 %!assert (s1 == x1)
 %!assert (x1 == s1)
-%!assert (~(s1 == (s1 + 1)))
-%!assert (~(s1 == (x1 + 1)))
-%!assert (~(x1 == (s1 + 1)))
+%!assert (!(s1 == (s1 + 1)))
+%!assert (!(s1 == (x1 + 1)))
+%!assert (!(x1 == (s1 + 1)))
 
-%% Test overloaded ne (~=) for the Snork class
-%!assert (~(s1 ~= s1))
-%!assert (~(s1 ~= x1))
-%!assert (~(x1 ~= s1))
-%!assert (s1 ~= (s1 + 1))
-%!assert (x1 ~= (s1 + 1))
-%!assert (s1 ~= (x1 + 1))
+%% Test overloaded ne (!=) for the Snork class
+%!assert (!(s1 != s1))
+%!assert (!(s1 != x1))
+%!assert (!(x1 != s1))
+%!assert (s1 != (s1 + 1))
+%!assert (x1 != (s1 + 1))
+%!assert (s1 != (x1 + 1))
 
 %% Test overloaded lt (<) for the Snork class
 %!assert (s1 < (s1 + 1))
 %!assert (s1 < (x1 + 1))
 %!assert (x1 < (s1 + 1))
 
 %% Test overloaded gt (>) for the Snork class
 %!assert (s1 > (s1 - 1))
diff --git a/test/error.tst b/test/error.tst
--- a/test/error.tst
+++ b/test/error.tst
@@ -13,81 +13,71 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Test %!error usage
 
-%% test/octave.test/error/error-1.m
 %!function g ()
 %!  error ("foo");
 %!endfunction
 %!function f ()
 %!  g ();
 %!endfunction
 %!error <foo> f ()
 
-%% test/octave.test/error/error-2.m
 %!function g ()
 %!  error ("foo\n");
 %!endfunction
 %!function f ()
 %!  g
 %!endfunction
 %!error <foo> f ()
 
-%% test/octave.test/error/error-3.m
 %!error error ()
 
-%% test/octave.test/error/error-4.m
 %!error <foo> error ("foo\n")
 
 ## Test %!warning usage
 
-%% test/octave.test/error/warning-1.m
 %!function g ()
 %!  warning ("foo");
 %!endfunction
 %!function f ()
 %!  g;
 %!endfunction
 %!warning <foo> f ()
 
-%% test/octave.test/error/warning-2.m
 %!test
 %! st.identifier = "backtrace";
 %! ws = warning ("query", "backtrace");
 %! warning ("on", "backtrace");
 %! st.state = "on";
 %! assert (warning ("query", "backtrace"), st);
 %! warning ("off", "backtrace");
 %! st.state = "off";
 %! assert (warning ("query", "backtrace"), st);
 %! warning (ws.state, "backtrace");
 
 ## Test usage() function
 
-%% test/octave.test/error/usage-1.m
 %!function g ()
 %!  usage ("foo");
 %!endfunction
 %!function f ()
 %!  g ();
 %!endfunction
 %!error <foo> f ()
 
-%% test/octave.test/error/usage-2.m
 %!function g ()
 %!  usage ("foo");
 %!endfunction
 %!function f ()
 %!  g
 %!endfunction
 %!error <foo> f ()
 
-%% test/octave.test/error/usage-3.m
 %!error usage ()
 
-%% test/octave.test/error/usage-4.m
 %!error <foo> usage ("foo\n")
 
diff --git a/test/eval-catch.tst b/test/eval-catch.tst
--- a/test/eval-catch.tst
+++ b/test/eval-catch.tst
@@ -11,63 +11,54 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/eval-catch/eval-catch-1.m
 %!test
 %! eval ("clear a; a;", "");
 
-%% test/octave.test/eval-catch/eval-catch-2.m
 %!test
 %! eval ("", "error ('Should not get here');");
 
-%% test/octave.test/eval-catch/eval-catch-3.m
 %!test
 %! eval ("clear a; a; x = 0;", "x = 1;");
 %! assert (x, 1);
 
-%% test/octave.test/eval-catch/eval-catch-5.m
 %!test
 %! eval ("clear a; a; str = '';", "str=lasterr;");
 %! assert (lasterr()(1:13), "'a' undefined");
 %! assert (str(1:13), "'a' undefined");
 
-%% test/octave.test/eval-catch/eval-catch-6.m
 %!test
 %! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
 %! assert (lasterr()(1:18), "user-defined error");
 %! assert (str(1:18), "user-defined error");
 
-%% test/octave.test/eval-catch/eval-catch-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = cstrcat ("<", s, ">");
+%!  ms = ["<" s ">"];
 %!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
 %! assert (mangle (lasterr)(1:14), "<'a' undefined");
 %! assert (str(1:14), "<'a' undefined");
 
-%% test/octave.test/eval-catch/eval-catch-8.m
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
 %! "str2 = lasterr;");
 %! assert (str1(1:13), "'a' undefined");
 %! assert (str2(1:13), "'b' undefined");
 
-%% test/octave.test/eval-catch/eval-catch-9.m
 %!test
 %! eval ("clear a; a; str1='';",
 %! "eval (\"clear b; b; str2='';\", \"str2=lasterr;\"); str1=lasterr;");
 %! assert (str1(1:13), "'b' undefined");
 %! assert (str2(1:13), "'b' undefined");
 
-%% test/octave.test/eval-catch/eval-catch-10.m
 %!test
 %! eval ("eval (\"clear a; a; str='';\",\"error (cstrcat (\\\"rethrow: \\\", lasterr));str='';\");",
 %! "str=lasterr;");
 %! assert (str(1:22), "rethrow: 'a' undefined");
 
diff --git a/test/for.tst b/test/for.tst
--- a/test/for.tst
+++ b/test/for.tst
@@ -11,86 +11,77 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/for/for-1.m
 %!test
 %! for i = 1
 %!   __printf_assert__ ("%d", i);
-%! end
+%! end  # "end" is part of test, check not using "endfor"
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1"));
 
-%% test/octave.test/for/for-2.m
 %!test
 %! for i = 1:4
 %!   __printf_assert__ ("%d", i);
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1234"));
 
-%% test/octave.test/for/for-3.m
 %!test
 %! for i = [1,2,3,4]
 %!   __printf_assert__ ("%d", i);
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1234"));
 
-%% test/octave.test/for/for-4.m
 %!test
 %! for i = [1,2;3,4]
 %!   __printf_assert__ ("%d", i(1,1));
 %!   __printf_assert__ ("%d", i(2,1));
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1324"));
 
-%% test/octave.test/for/for-5.m
 %!test
 %! for i = I
 %!   __printf_assert__ ("%d", imag (i));
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1"));
 
-%% test/octave.test/for/for-6.m
 %!test
 %! for i = [1,2,3,4]*I
 %!   __printf_assert__ ("%d", imag (i));
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1234"));
 
-%% test/octave.test/for/for-7.m
 %!test
 %! for i = [1,2;3,4]*I
 %!   __printf_assert__ ("%d", imag (i(1,1)));
 %!   __printf_assert__ ("%d", imag (i(2,1)));
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("1324"));
 
-%% test/octave.test/for/for-8.m
 %!test
 %! for i = [1,2,3,4]
 %!   if (i > 2)
 %!     break;
 %!   endif
 %!   __printf_assert__ ("%d", i);
 %! endfor
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("12"));
 
-%% test/octave.test/for/for-9.m
 %!test
 %! for i = [1,2,3,4]
 %!   if (i < 3)
 %!     continue;
 %!   endif
 %!   __printf_assert__ ("%d", i);
 %! endfor
 %! __printf_assert__ ("\n");
@@ -105,15 +96,30 @@
 
 %!test
 %! a = {1,3;2,4};
 %! j = 0;
 %! for i = cat (3, a, cellfun (@(x) 4 + x, a, "UniformOutput", 0))
 %!   assert (i, {1 + 2*j; 2 + 2*j++})
 %! endfor
 
-%% test parsing of single-quoted character string appearing at the
-%% beginning of a for loop
+## test parsing of single-quoted character string appearing at the
+## beginning of a for loop
 %!test
 %! for i = 1:5
 %!   'foo';
 %! endfor
 %! assert (i, 5);
+
+%!test
+%! parfor i = 1
+%!   __printf_assert__ ("%d", i);
+%! end  # "end" is part of test, check not using "endparfor"
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1"));
+
+%!test
+%! parfor i = 1:4
+%!   __printf_assert__ ("%d", i);
+%! endparfor
+%! __printf_assert__ ("\n");
+%! assert (__prog_output_assert__ ("1234"));
+
diff --git a/test/global.tst b/test/global.tst
--- a/test/global.tst
+++ b/test/global.tst
@@ -11,77 +11,69 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/global/global-1.m
 %!test
 %! global G = 1;
 %! assert (G,1);
 
-%% test/octave.test/global/global-2.m
 %!function f ()
 %!  global G;
 %!  assert (G,1);
 %!endfunction
 %!test
 %! global G = 1;
 %! f;
 
-%% test/octave.test/global/global-3.m
 %!function f ()
 %!  fail ("G");
 %!endfunction
 %!test
 %! global G = 1;
 %! f ();
 
-%% test/octave.test/global/global-4.m
 %!function f ()
 %!  global H = 1;
 %!endfunction
 %!test
-%!  f;
-%!  fail ("H");
+%! f;
+%! fail ("H");
 
-%% test/octave.test/global/global-5.m
 %!function f ()
 %!  global H = 1;
 %!endfunction
 %!test
 %!function g ()
 %!  fail ("H");
 %!test
 %! g ();
 
-%% test/octave.test/global/global-6.m
 %!function f ()
 %!  global H = 1;
 %!endfunction
 %!function g ()
 %!  global H;
 %!  assert (H,1);
 %!endfunction
 %!test
 %! f ();
 %! g ();
 
-%% test/octave.test/global/global-7.m
 %!test
 %!function f ()
 %!  global H = 1;
 %!endfunction
 %!test
 %! fail ("H");
 
-%% test/octave.test/global/global-8.m
 %!function f ()
 %!  global H = 1;
 %!endfunction
 %!function g ()
 %!  global H;
 %!  assert (H,1);
 %!endfunction
 %!test
diff --git a/test/if.tst b/test/if.tst
--- a/test/if.tst
+++ b/test/if.tst
@@ -11,96 +11,91 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/if/if-1.m
 %!test
 %! i = 0;
 %! if (i == 0)
 %!   i++;
 %!   __printf_assert__ ("%d\n", i);
-%! endif
+%! end  # "end" is part of test, check not using "endif"
 %! assert (__prog_output_assert__ ("1"));
 
-%% test/octave.test/if/if-2.m
 %!test
 %! if (eye (2))
 %!   __printf_assert__ ("fail\n");
 %! else
 %!   __printf_assert__ ("pass\n");
-%! end
+%! endif
 %! assert (__prog_output_assert__ ("pass"));
 
-%% test/octave.test/if/if-3.m
 %!test
 %! x = 2;
 %! if (eye (2))
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("pass\n");
 %! endif
 %! assert (__prog_output_assert__ ("pass"));
 
-%% test/octave.test/if/if-4.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! elseif (y)
 %!   __printf_assert__ ("pass\n");
-%! end
+%! endif
 %! assert (__prog_output_assert__ ("pass"));
 
-%% test/octave.test/if/if-5.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (eye (2))
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! else
 %!   __printf_assert__ ("pass\n");
 %! endif
 %! assert (__prog_output_assert__ ("pass"));
 
-%% test/octave.test/if/if-6.m
 %!test
 %! x = 0;
 %! y = -2;
 %! if (y)
 %!   __printf_assert__ ("pass\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
 %! elseif (x)
 %!   __printf_assert__ ("fail\n");
-%! end
+%! endif
 %! assert (__prog_output_assert__ ("pass"));
 
-%% test parsing of single-quoted character string appearing at the
-%% beginning of an if condition
+## test parsing of single-quoted character string appearing at the
+## beginning of an if condition
 %!test
 %! if (1)
 %!   'foo';
 %!   x = 13;
 %! endif
 %! assert (x, 13);
 
-%% test parsing of single-quoted character string appearing at the
-%% beginning of an if condition
+## test parsing of single-quoted character string appearing at the
+## beginning of an if condition
 %!test
 %! if (0)
 %!   x = 42;
 %! elseif (1)
 %!   'foo';
 %!   x = 13;
 %! endif
 %! assert (x, 13);
+
diff --git a/test/index.tst b/test/index.tst
--- a/test/index.tst
+++ b/test/index.tst
@@ -129,17 +129,17 @@
 %!assert (b(1,[]), zeros (1,0))
 %!assert (b(:,3), [5;7])
 %!assert (b([1,2],3), [5;7])
 %!assert (b(true (2,1), 3), [5;7])
 %!assert (b(false (2,1), 3), zeros (0,1))
 %!assert (b([],3), zeros (0,1))
 
 %!shared x
-%! # Dummy shared block to clear any previous definitions
+%! ## Dummy shared block to clear any previous definitions
 %! x = 1;
 
 %!test
 %! a(1,:) = [1,3];
 %! assert (a, [1,3]);
 
 %!test
 %! a(1,:) = [1;3];
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -15,17 +15,16 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## FIXME: we should skip (or mark as an expected failure) the test for
 ## saving sparse matrices to MAT files when using 64-bit indexing since
 ## that is not implemented yet.
 
-%% test/octave.test/io/load-save.m
 %!function [ret, files] = testls (input)
 %!  ## flag a1 global so as to test the storage of global flags
 %!  global a1;
 %!
 %!  ## Input or output, so as to be able to exchange between versions
 %!  if (nargin < 1)
 %!    input = 0;
 %!  endif
@@ -174,17 +173,17 @@
 %!        error ("failed: %s global test", file);
 %!      endif
 %!    endfor
 %!  endif
 %!
 %!  ret = 1;
 %!endfunction
 
-%!test
+%!testif HAVE_ZLIB
 %!
 %! [save_status, save_files] = testls (0);
 %! [load_status, load_files] = testls (1);
 %!
 %! for f = [save_files, load_files]
 %!   unlink (f{1});
 %! endfor
 %!
@@ -218,48 +217,43 @@
 %!         STR.struct_fld.y == 1);
 %!
 %! delete struct.dat;
 
 %!test
 %! matrix1 = rand (100, 2);
 %! save -ascii matrix.ascii matrix1
 %! matrix2 = load ("matrix.ascii");
-%! assert (matrix1, matrix2, 1e-9)
+%! assert (matrix1, matrix2, 1e-9);
 %!
 %! delete matrix.ascii;
 
 %!error <unable to find file> load ("")
 
 %% FIXME: This test is disabled as it writes to stdout and there is no easy
 %% way to recover output.  Need to spawn new octave process and pipe stdout
 %% somewhere to treat this case.
-%% test/octave.test/io/puts-1.m
 %!#test
 %! puts ("foo\n");
 
-%% test/octave.test/io/puts-2.m
 %!assert (puts (1),-1)
 
-%% test/octave.test/io/puts-3.m
 %!error <Invalid call to puts> puts ()
-
-%% test/octave.test/io/puts-4.m
 %!error <Invalid call to puts> puts (1, 2)
 
 %!assert (sscanf ('123456', '%10c'), '123456')
 %!assert (sscanf ('123456', '%10s'), '123456')
 
 %!assert (sscanf (['ab'; 'cd'], '%s'), 'acbd')
 
-%!assert (sscanf ('02:08:30', '%i:%i:%i'), [2; 0]);
-%!assert (sscanf ('02:08:30', '%d:%d:%d'), [2; 8; 30]);
+%!assert (sscanf ('02:08:30', '%i:%i:%i'), [2; 0])
+%!assert (sscanf ('02:08:30', '%d:%d:%d'), [2; 8; 30])
 
-%!assert (sscanf ('0177 08', '%i'), [127; 0; 8]);
-%!assert (sscanf ('0177 08', '%d'), [177; 8]);
+%!assert (sscanf ('0177 08', '%i'), [127; 0; 8])
+%!assert (sscanf ('0177 08', '%d'), [177; 8])
 
 %!test
 %! [val, count, msg, pos] = sscanf ("3I2", "%f");
 %! assert (val, 3);
 %! assert (count, 1);
 %! assert (msg, "");
 %! assert (pos, 2);
 
@@ -272,79 +266,69 @@
 
 %!test
 %! [val, count, msg, pos] = sscanf ("3Inf2", "%f");
 %! assert (val, [3; Inf; 2]);
 %! assert (count, 3);
 %! assert (msg, "");
 %! assert (pos, 6);
 
-%% test/octave.test/io/sscanf-1.m
 %!test
 %! [a, b, c] = sscanf ("1.2 3 foo", "%f%d%s", "C");
 %! [v1, c1, m1] = sscanf ("1 2 3 4 5 6", "%d");
 %! [v2, c2, m2] = sscanf ("1 2 bar 3 4 5 6", "%d");
 %!
 %! assert ((a == 1.2 && b == 3 && c == "foo"
 %! && v1 == [1; 2; 3; 4; 5; 6] && c1 == 6 && ischar (m1)
 %! && v2 == [1; 2] && c2 == 2 && ischar (m2)));
 
-%% test/octave.test/io/sscanf-2.m
 %!error <Invalid call to sscanf> sscanf ()
-
-%% test/octave.test/io/sscanf-3.m
 %!error sscanf (1, 2)
-
-%% test/octave.test/io/sscanf-4.m
 %!error <Invalid call to sscanf> sscanf ("foo", "bar", "C", 1)
 
-%% test/octave.test/io/sscanf-5.m
 %!test
 %! [x, n] = sscanf ("   0.024000 0.200 0.200 2.000         1987           5           0  0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 4 5 1 2    2 5 5 8 2 8 12 6 15 18 28 26 47 88 118 162 192 130 88 56 27 23 14 9 6 3 4 1 0    2 3 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.026000 0.250 0.250 2.100         3115           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0    0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1    1 1 0 1 0 1 3 2 0 5 15 25 44 66 145 179 193 172 104 57 17 11 12 2 1 0 1 1 0 1    0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.028000 0.300 0.300 2.200         4929           3           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0    1 0 1 0 1 2 2 3 2 3 14 21 49 80 148 184 218 159 124 63 37 13 12 3 1 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.030000 0.350 0.350 2.300         7051           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1    0 0 1 0 0 0 2 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1    0 0 0 2 0 0 0 1 5 6 14 28 51 88 154 177 208 169 124 65 39 15 5 3 3 2 1 0 1 0 1   0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.032000 0.400 0.400 2.400         9113           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0    1 0 0 0 0 2 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 2 0    1 0 0 1 1 0 2 3 5 3 17 30 60 117 156 189 209 129 102 64 56 16 11 4 2 2 0 0 0 0   1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0   0.034000 0.450 0.450 2.500        11811           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0    0 0 2 1 0 0 1 0 5 5 15 21 57 99 149 190 195 159 130 69 41 16 10 2 5 3 0 1 0 0    0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.036000 0.500 0.500 2.600        14985           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0    0 0 0 0 1 0 0 2 2 6 10 34 60 95 126 177 194 155 99 71 44 17 6 7 2 0 0 0 3 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.038000 0.550 0.550 2.700        18391           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 2    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 2 0 0 1 1 0 1    2 1 0 0 0 1 0 1 3 6 19 27 52 95 161 154 169 134 94 64 37 19 9 6 0 2 1 0 0 0 0    1 2 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 2 2 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.040000 0.600 0.600 2.800        22933           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1    0 0 0 0 0 2 0 3 4 7 18 27 47 82 134 163 133 138 101 58 34 26 10 5 2 1 2 1 1 0    2 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.042000 0.650 0.650 2.900        27719           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 1 1 2 8 16 37 51 87 128 153 146 123 105 62 35 24 8 3 5 0 1 2 1 0 0   0 1 1 1 0 0 0 1 0 1 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.044000 0.700 0.700 3.000        32922           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 2 0    0 0 0 0 0 0 0 2 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1    1 1 0 0 0 1 4 3 5 5 15 35 54 88 132 168 149 105 92 62 30 16 17 4 5 1 0 0 1 0 1   1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.046000 0.750 0.750 3.100        38973           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0    0 0 0 1 0 0 0 4 3 5 20 37 56 94 110 135 149 124 84 58 36 17 14 7 1 0 2 0 1 0 0   1 1 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1    1 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0    1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.048000 0.800 0.800 3.200        45376           5           0  1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 2 1 1 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0    0 0 0 1 0 0 0 0 1 3 18 34 55 82 104 135 116 99 79 60 51 29 10 4 3 1 1 1 0 0 1    0 0 0 1 0 0 3 1 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1    0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.050000 0.850 0.850 3.300        52060           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1    0 0 0 0 0 2 2 1 3 12 24 40 39 107 121 127 138 100 86 68 44 23 15 7 3 1 1 0 1 1   0 0 2 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 0 0 2 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.052000 0.900 0.900 3.400        59454           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1    0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 2 0 2 1 0 0 0 1 0    0 1 0 0 0 0 0 3 3 6 21 32 68 90 132 111 122 107 73 57 47 24 11 7 4 2 2 1 0 0 0   0 0 0 0 0 1 0 0 1 0 0 2 0 1 1 0 0 1 0 0 0 0 0 3 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0   0.054000 0.950 0.950 3.500        67013           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0    1 0 1 0 1 2 4 3 7 9 28 31 71 94 115 96 108 78 82 60 38 17 12 11 4 3 1 1 0 2 1    0 0 0 2 1 3 0 0 0 0 3 0 0 1 0 0 0 0 0 0 0 2 0 0 0 1 0 2 0 1 0 2 0 1 0 0 1 0 0    0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0   0.056000 1.000 1.000 3.600        75475           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 2 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 3 0 0 1    1 2 0 1 4 0 1 8 6 7 17 41 56 71 109 113 84 103 72 54 35 22 6 9 1 7 5 4 0 0 1 0   0 0 0 0 0 1 0 0 2 1 0 0 0 0 2 0 0 1 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 0 0 1 0 1    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0 0 1 0 0 0 0 0 0 1 1 0 0 2 0 0 0 0    0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.058000 1.050 1.050 3.700        83558           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0    2 0 0 1 0 3 2 3 6 15 27 41 77 73 94 94 92 76 61 56 42 23 13 11 6 2 1 2 0 1 2 0   0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 0 2 0 0 0 0 0 1 2 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.060000 1.100 1.100 3.800        93087           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1    0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 2 2 0 0 0 1 0 1 1 0 0 0 1 1 0 4    0 0 1 2 0 3 1 3 5 13 33 31 65 75 77 96 97 80 59 45 36 32 18 2 5 0 1 0 0 1 0 0    3 0 0 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 0 2 0 0 2 0 1 0    0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0    0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.062000 1.150 1.150 3.900       102829           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0    0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 2 0 2    1 2 0 0 2 4 3 5 11 9 23 43 53 68 65 87 83 77 59 49 34 18 15 9 4 2 3 2 0 0 0 4    0 1 1 0 0 2 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 2 0 0 0 0 1 0 0 1 1 1 1 0 0 0 1 0    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0   0.064000 1.200 1.200 4.000       113442           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0    0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1    2 0 0 0 2 0 4 5 11 13 29 39 61 68 61 75 76 74 73 44 37 29 19 6 3 3 2 0 1 2 1 0   0 0 0 1 1 1 0 1 1 0 0 0 1 0 1 1 0 1 2 0 2 1 1 1 0 0 0 0 1 0 0 1 1 1 1 1 0 0 0    0 0 0 0 1 0 0 0 0 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0    0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0   0.066000 1.250 1.250 4.100       126668           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1    0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 2 3 0 2 1 2 0 1 0 3 0 0 0 1 0 1 1 3    0 0 1 3 0 2 4 3 12 12 30 48 56 66 77 78 71 82 52 31 32 19 20 16 8 2 1 3 0 0 2    1 0 1 0 1 0 0 0 1 3 1 0 1 0 1 1 1 0 0 0 0 0 2 0 2 0 0 0 0 0 1 0 0 0 0 1 1 0 0    0 0 0 1 0 0 0 0 0 2 0 3 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.068000 1.300 1.300 4.200       138042           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 2 0 0 1 0 1 0 0 0 0 0    0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0    0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 3 0 0 1 0 0 1 2 0 0 0 3 0 1 0 0 3 0    1 0 1 1 3 1 4 7 11 14 27 36 44 68 72 70 71 45 44 46 29 13 16 11 5 2 0 3 0 0 0    0 1 1 2 0 0 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 2 0 0 1 1 0 1 1 1 0    0 1 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 0 1 0 0 1 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0   0.070000 1.350 1.350 4.300       152335           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0    1 0 0 0 2 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 1 1 1 0 1 1 0 1 1 1 1 0 2 0    0 0 0 0 2 0 1 7 14 19 34 35 54 72 68 72 68 58 48 36 37 27 25 17 1 4 1 0 0 0 1    2 2 0 0 1 1 1 2 1 0 3 1 0 1 0 2 1 0 0 0 1 1 1 2 0 0 0 0 1 1 0 1 1 0 2 1 1 1 1    0 0 0 1 1 0 0 2 0 0 1 0 0 0 1 1 0 2 1 1 0 0 0 0 2 0 0 0 0 0 0 0 1 1 0 0 0 0 1    0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0   0.072000 1.400 1.400 4.400       166280           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0    0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0    2 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 3 4 2 2 0 0 0 0 0 1 1 3 1 0 3 2 2    1 2 2 0 2 2 1 8 14 26 24 29 47 47 68 65 63 55 42 41 26 29 17 8 4 4 1 0 1 2 0 0   0 1 1 2 0 1 2 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 2 1 2 1 0 0 0 0 0 1 1 2 0 2 2 0    0 0 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0    0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0   0.074000 1.450 1.450 4.500       179484           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0    1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 1 0 0 1 0 1 2 0 0 0 0 0 0 0 0 0 1 0    0 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 1 1 1 2 0 0 1 1 2 1 0    1 1 2 2 0 1 5 6 10 20 43 50 57 62 53 62 66 45 42 33 27 26 23 14 3 0 2 0 1 0 0    1 1 0 0 2 1 1 0 0 3 0 1 1 1 0 1 1 0 1 0 1 2 1 0 0 1 2 0 2 0 0 0 0 1 1 3 1 0 0    2 1 1 1 0 0 0 0 0 0 1 2 0 1 0 0 0 0 0 1 1 0 2 0 0 0 0 0 1 0 2 1 0 0 0 0 0 0 1    0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0   0.076000 1.500 1.500 4.600       197657           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0    0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0    0 0 1 0 1 0 0 0 0 0 0 0 0 1 2 0 0 0 2 1 1 0 1 1 0 1 1 3 2 1 1 2 1 0 1 0 0 0 0    0 1 1 1 0 5 3 7 12 24 38 32 41 48 54 66 71 49 46 31 38 25 15 8 6 6 5 0 1 3 0 1   1 1 1 1 0 1 2 0 1 0 0 0 1 0 2 1 2 0 0 0 0 1 3 1 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0    4 1 1 1 0 3 0 0 0 2 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0   0.078000 1.550 1.550 4.700       212054           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0    0 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1    0 0 2 0 0 0 1 0 0 1 0 1 1 0 1 3 1 0 0 1 2 0 0 0 1 0 0 0 0 0 2 1 2 1 1 1 0 0 1    5 1 1 2 3 5 7 9 11 22 31 37 48 50 52 54 57 37 38 38 33 24 11 19 11 3 1 2 0 3 3   2 1 0 1 3 0 1 1 1 1 1 2 0 0 0 1 1 2 0 1 1 3 0 1 1 0 0 1 0 2 0 1 0 0 1 3 0 2 0    1 0 1 2 0 1 1 1 1 1 0 3 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0    0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0   0.080000 1.600 1.600 4.800       231971           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1    0 0 0 0 2 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 2 1 0 1 1 1 0 1 0 0 1 0 1 3 0 0 0 1 0    0 0 1 1 1 0 0 4 1 1 0 2 0 1 1 1 2 0 0 0 1 0 1 2 1 2 3 2 0 1 0 4 3 1 1 1 1 3 1    0 0 0 2 1 0 2 7 17 13 29 47 58 59 52 38 51 51 38 34 35 21 14 13 4 1 0 1 1 1 0    2 2 4 1 0 1 1 4 0 0 0 2 0 2 2 2 0 0 1 3 2 1 1 2 2 2 2 1 0 3 0 2 1 2 1 2 2 0 0    1 1 0 2 0 2 2 0 1 0 2 2 3 1 2 3 1 1 0 1 0 2 0 1 2 1 2 0 2 1 0 0 3 0 0 1 1 1 1    0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0   0.082000 1.650 1.650 4.900       252503           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 2 0 0    0 0 0 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0    0 0 0 0 2 0 0 1 0 1 2 2 2 1 0 2 0 1 0 1 1 2 2 0 3 0 0 4 1 0 0 3 0 0 1 2 0 1 1    1 3 0 1 0 2 9 11 25 27 34 53 41 49 43 47 36 31 38 22 30 22 18 9 5 9 2 2 1 2 2    3 1 4 1 1 0 0 1 2 0 2 1 0 0 1 3 2 2 1 0 0 0 1 2 1 0 0 0 2 1 1 0 2 0 0 1 0 0 2    1 3 1 1 1 0 2 1 1 0 2 1 0 1 3 0 0 0 0 2 0 0 1 0 0 0 0 0 1 2 1 1 1 0 2 1 0 0 0    2 0 1 0 0 0 0 1 0 0 0 0 1 0 0 2 0 1 0 1 0 0 0 0 0 0 0 0 0 0   0.084000 1.700 1.700 5.000       267889           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1    0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0    0 1 0 1 1 0 3 0 1 1 1 0 1 2 1 0 2 0 2 4 0 1 0 0 0 1 1 0 1 3 2 0 2 0 4 0 0 2 0    1 4 2 4 3 3 6 10 14 28 37 54 36 40 52 40 50 46 40 32 26 29 12 18 5 2 0 2 4 1 2   1 0 2 1 2 2 1 0 1 0 2 1 2 4 1 1 5 1 0 2 0 1 2 3 2 2 1 2 1 0 2 1 2 1 1 4 1 2 1    4 0 2 2 0 0 3 1 0 2 0 0 1 1 1 0 0 2 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 0 1 0    0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.086000 1.750 1.750 5.100       290294           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0    0 0 0 0 1 0 0 0 0 1 0 0 0 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 2    1 0 1 0 1 0 0 2 2 0 1 2 2 0 2 0 2 0 1 0 0 1 1 1 3 1 1 1 1 3 4 1 1 2 2 2 1 0 3    0 0 0 2 4 5 6 16 18 20 31 40 54 55 46 41 52 35 27 21 28 27 20 15 8 6 7 1 0 0 3   0 0 2 2 0 3 1 3 1 1 2 0 0 1 2 1 3 2 0 1 2 1 3 1 1 1 1 1 2 0 2 1 0 1 1 1 3 1 1    2 0 1 0 1 0 2 1 1 0 0 1 2 0 3 1 1 0 0 0 1 3 1 1 1 0 0 1 2 1 0 0 1 1 1 0 0 1 0    0 0 0 0 0 2 0 1 0 0 0 2 1 0 2 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0   0.088000 1.800 1.800 5.200       312476           6           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 0 0 0    0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 2 0 0 0 1 0 1 0 0 0 0 0 0 2    1 0 0 1 0 0 1 1 1 1 4 2 0 1 0 0 3 0 0 0 0 0 1 1 4 0 0 0 0 1 1 2 1 0 3 0 0 2 2    4 0 3 1 6 9 10 13 21 24 32 43 33 41 43 49 50 32 26 31 27 12 16 17 3 3 3 5 0 3    0 2 1 3 3 2 1 2 3 1 2 1 1 1 2 0 1 1 0 2 0 3 0 0 2 0 0 0 0 1 0 1 1 3 3 0 1 1 1    1 1 1 2 2 2 0 3 1 0 2 2 2 0 0 0 0 3 1 2 5 1 1 2 0 0 3 3 0 2 2 0 0 0 0 1 2 0 0    1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0   0.090000 1.850 1.850 5.300       337348           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 2 0 1 0 1 0 0 0 1 0 0 0    0 0 0 1 0 0 0 0 2 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0    2 0 0 0 1 3 2 0 0 2 2 3 3 2 2 2 0 0 1 1 3 1 3 0 0 0 0 0 0 1 2 1 2 1 2 2 2 0 1    1 0 4 2 2 7 6 15 22 21 39 37 50 31 51 30 33 34 34 26 21 14 13 10 9 4 3 3 4 2 2   0 1 2 3 3 0 1 3 2 5 3 2 2 4 0 2 3 0 4 2 1 2 2 2 4 2 1 3 1 3 2 1 3 1 2 4 1 1 1    1 2 4 1 3 3 3 1 0 4 1 0 1 1 1 1 2 3 0 3 0 0 4 1 1 1 0 2 2 2 1 2 2 0 1 1 0 0 0    2 0 1 0 1 0 0 1 0 0 0 1 3 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0   0.092000 1.900 1.900 5.400       357303           3           0  0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 0 0 1 0    0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 3 1 0 1 0 0 0 0 1 0 0 1 0 0 1 1 2 2 0 0 2    2 1 1 1 1 1 1 0 1 0 0 1 1 1 3 1 1 1 1 1 0 1 4 0 1 1 1 3 0 1 1 2 2 2 0 2 3 2 2    2 2 1 2 1 3 8 22 14 32 36 46 39 42 39 29 36 38 26 24 26 18 16 19 10 9 3 6 5 0    3 2 1 1 1 2 0 2 1 1 0 1 1 3 1 0 2 4 2 2 1 4 1 2 2 1 1 0 1 2 0 2 2 2 4 2 1 1 0    2 1 3 1 2 3 4 2 3 2 3 0 1 2 1 0 0 0 4 1 1 1 2 1 3 1 0 5 1 0 0 0 0 0 0 1 0 2 0    1 2 1 0 1 0 0 0 0 0 1 1 0 1 0 1 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0   0.094000 1.950 1.950 5.500       383138           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0    0 0 1 0 0 2 1 0 1 1 1 0 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 2 1 1 1 1    2 1 0 2 0 1 0 3 2 1 3 0 1 3 1 1 0 5 0 1 0 1 2 0 0 1 1 2 0 0 6 1 0 3 2 2 3 4 5    0 4 2 1 5 4 11 15 22 27 28 57 38 38 40 38 39 38 27 26 30 18 14 10 10 4 4 4 3 3   2 2 2 2 1 1 1 1 2 2 3 4 1 2 3 1 2 1 2 2 2 1 3 2 1 5 0 1 1 1 3 2 2 2 1 3 1 1 0    3 2 2 0 0 2 2 2 0 0 0 2 0 1 3 1 2 3 2 1 1 0 1 1 1 0 3 2 2 1 0 0 1 3 1 1 0 1 0    0 0 0 0 1 0 0 0 0 1 0 0 3 1 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0   0.096000 2.000 2.000 5.600       409868           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 0 2 0 0    1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 2 0 1 0 0 2 0 2 0 0 0 0 1 0 0 2 1    2 2 2 1 2 1 1 1 1 1 2 0 0 1 1 0 1 0 2 1 2 0 2 0 3 1 2 1 3 1 5 0 2 2 1 2 4 1 2    0 3 1 4 7 5 9 13 22 19 31 27 28 41 34 39 37 22 23 21 22 17 23 15 8 9 3 8 0 3 1   2 2 2 3 1 0 4 2 4 2 2 2 2 4 2 1 1 0 2 0 3 0 3 2 2 1 2 2 1 4 1 2 2 1 1 5 2 1 2    1 2 2 1 0 2 4 3 2 1 2 2 3 2 3 1 2 1 1 1 1 2 1 1 2 2 1 2 3 2 1 1 0 2 2 4 0 1 1    1 1 1 0 0 1 1 3 0 0 0 0 0 1 0 0 2 0 1 2 0 1 1 1 0 1 0 1 0 0   0.098000 2.050 2.050 5.700       439102           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 0    0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 2 0 0 1 1 1 1 2 0 1 1 0 0 0 0 1 1 1 0 4 0 0    0 2 1 1 0 3 4 0 1 2 2 1 0 3 0 3 2 0 0 2 0 1 0 0 1 0 1 3 1 3 5 0 2 2 3 5 2 2 2    0 3 2 3 6 5 16 21 19 23 28 29 35 42 42 44 39 33 23 30 18 25 24 15 13 5 4 2 2 0   3 3 0 0 1 3 0 1 1 3 2 4 3 4 2 1 1 1 3 1 0 0 2 2 4 2 2 1 4 2 4 2 2 2 1 2 2 1 2    0 4 2 2 3 1 2 1 1 2 2 1 2 4 2 1 4 1 2 2 2 2 0 2 0 3 0 1 0 2 1 0 4 2 1 3 2 1 0    2 1 1 1 1 0 1 1 2 1 1 1 2 0 1 0 2 1 1 0 0 1 0 0 1 0 0 0 0 0 0   0.100000 2.100 2.100 5.800       467340           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 0 0 1 2 0 0 0 0 0 1 0 2 0 0 2 0 0 1 1 0 0    0 1 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 2 0 2    2 4 1 0 1 1 2 3 4 1 4 1 5 1 2 1 0 2 2 2 1 5 4 1 5 4 0 1 2 4 2 2 0 2 1 2 5 4 1    1 1 2 5 7 9 16 23 31 15 22 36 36 44 42 29 31 28 28 18 35 12 10 13 8 4 3 2 2 5    1 2 3 3 1 3 3 5 2 0 3 4 1 2 2 3 0 0 5 2 3 6 2 1 2 5 3 4 3 1 1 1 1 2 2 4 0 2 3    1 2 1 2 4 5 4 3 5 2 1 2 0 5 0 2 2 4 1 0 4 1 0 2 1 2 0 0 1 3 2 4 3 0 2 3 3 3 4    2 2 0 0 0 0 1 1 0 3 2 0 1 2 0 4 2 1 1 1 2 0 0 0 0 0 0 0 0 0 0   0.102000 2.150 2.150 5.900       497495           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 2 1 0 0 0 0 1 0 1 0 0 0 0 1 2    0 0 0 0 0 2 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 2 0 0 1 0 0 0 1 0 2 2 1 0 0 0    2 0 2 1 1 1 6 3 2 0 3 2 2 2 1 1 3 4 1 0 1 2 4 2 3 3 1 1 1 1 3 3 1 4 1 3 4 3 2    3 1 2 2 5 11 11 14 26 27 28 28 28 36 39 42 29 33 24 20 29 18 13 17 13 6 10 4 3   3 6 1 0 1 0 2 1 3 2 3 1 2 3 1 2 1 2 0 2 2 3 1 3 1 1 2 4 4 1 4 3 2 2 3 5 5 3 0    2 5 3 5 1 4 1 1 3 4 2 2 2 2 1 3 0 1 1 2 2 4 2 1 3 2 0 1 2 1 0 2 3 1 2 0 0 0 2    0 0 1 3 0 0 1 2 0 3 1 0 3 1 2 2 1 1 2 0 0 0 0 2 0 0 1 0 0 0 0 0   0.104000 2.200 2.200 6.000       529288           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0    0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 1 3 0 2 0 2 0 0    3 2 2 0 4 0 3 2 2 1 3 1 7 3 1 1 0 4 3 2 1 0 0 3 2 3 5 2 1 4 1 5 1 0 3 2 3 0 1    2 4 7 3 7 8 12 15 20 24 34 39 34 35 27 36 34 23 22 26 15 24 12 12 14 5 3 0 7 1   1 3 5 1 2 2 2 4 3 1 2 5 2 2 3 1 1 4 2 1 3 0 4 5 4 6 4 5 3 3 3 3 1 1 5 0 6 1 2    4 2 3 2 1 3 2 0 0 0 1 3 3 0 1 4 0 3 2 3 0 3 3 0 2 3 4 3 1 1 1 2 5 3 1 2 1 1 2    4 1 0 2 4 1 3 0 0 3 0 1 3 0 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0   0.106000 2.250 2.250 6.100       560628           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 2 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1    1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 2 0 0 0 0 2 0 3 1 1 0 0 2 2 2 0 5 2 1    1 1 1 3 1 2 3 0 1 0 0 0 0 1 0 2 2 1 2 1 0 4 3 2 1 2 1 0 4 2 2 0 2 1 1 2 3 1 2    1 2 4 4 11 12 17 19 19 29 30 24 30 35 51 32 36 34 31 19 22 17 11 19 11 7 6 6 3   4 0 3 3 2 0 2 2 2 3 1 5 3 2 3 5 1 0 2 2 5 4 2 3 2 0 1 6 1 2 2 2 2 1 1 2 2 1 4    3 2 2 1 2 5 2 0 2 0 2 5 4 5 2 1 3 6 1 3 4 4 0 0 6 0 2 6 1 2 2 2 0 1 3 1 3 4 2    1 4 2 1 2 3 3 0 3 1 0 2 0 2 1 0 2 1 2 0 0 1 1 0 2 0 0 0 0 0 0 0   0.108000 2.300 2.300 6.200       593293           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 2 0 2 2 1 0 0 2 0 1 0 1 0 0 1 2 2 1 0    0 1 0 2 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 0 1 1 1 2 2 1 0 1 1 0 1 5 0 2 4 1 0 1 4    2 1 3 2 2 3 2 3 2 0 0 3 4 3 1 3 2 2 0 3 0 2 4 0 3 2 5 1 2 1 4 6 1 2 4 0 3 6 1    7 6 4 5 4 10 16 24 22 20 40 37 44 34 29 21 28 36 36 27 23 24 14 10 4 5 2 5 3 6   2 3 3 1 4 2 1 5 1 3 5 3 2 1 2 2 6 2 3 1 1 0 5 3 3 3 4 5 2 2 3 3 5 5 1 6 2 3 2    6 0 5 2 4 3 5 1 2 2 5 1 2 3 1 2 2 2 4 2 5 5 2 2 2 5 0 1 2 5 2 3 2 3 1 1 2 4 0    2 1 4 2 1 1 1 0 1 2 0 0 1 3 1 0 2 1 1 3 3 2 0 0 0 1 2 0 0 0 0   0.110000 2.350 2.350 6.300       636559           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 0 0 0 1 1 2 0 0 1 0 0 0 0 0 0 0    1 2 0 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 2 0 1 0 1 0 1 0 0 1 1 3 0 1 2 2 0 2 1    1 1 1 0 1 0 1 3 0 3 2 3 4 3 3 4 3 3 2 6 3 1 1 1 2 4 2 3 1 5 1 3 1 4 5 3 3 2 1    3 7 4 3 10 19 17 19 23 27 28 33 39 36 23 23 32 32 16 19 35 23 12 11 12 8 4 5 7   1 2 2 1 2 3 5 4 2 3 2 6 4 4 2 4 1 2 2 1 2 3 0 4 2 1 2 6 2 2 1 3 3 1 6 4 8 5 2    3 5 2 3 0 3 2 3 1 2 2 3 4 3 8 6 2 1 4 6 3 1 2 0 2 0 2 5 0 3 3 3 3 1 3 3 2 5 4    2 1 4 2 2 4 4 1 3 2 5 2 3 1 2 0 4 0 1 0 6 3 1 2 0 2 0 1 0 0 0 0   0.112000 2.400 2.400 6.400       670484           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 2    0 1 1 1 3 0 0 0 2 1 3 0 1 1 1 0 1 1 1 0 0 1 2 0 1 3 1 5 2 3 0 4 0 2 0 0 1 2 1    0 1 0 0 1 0 2 2 3 2 3 2 2 2 3 4 4 2 3 5 3 3 2 3 3 4 2 4 0 3 2 4 4 1 3 1 3 4 2    2 5 2 8 6 12 17 14 22 27 26 29 39 30 24 36 22 22 20 9 19 15 5 12 16 4 7 5 7 5    5 1 4 5 5 4 4 1 4 4 3 3 3 4 2 2 4 2 4 4 4 4 0 2 3 2 1 4 3 6 1 3 3 3 4 5 4 2 2    2 5 3 0 2 5 4 2 5 3 5 1 1 3 1 1 3 6 6 2 3 2 0 3 2 4 3 4 1 2 2 6 2 0 3 2 2 5 3    3 5 2 1 0 3 1 1 2 2 0 1 1 3 2 3 2 1 1 1 1 3 2 1 0 0 0 0 0 0 0   0.114000 2.450 2.450 6.500       711783           4           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 1 0 2 1 2 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1    1 2 0 1 1 0 0 0 2 1 1 1 1 1 2 1 2 3 3 1 1 1 2 3 1 3 2 2 1 0 1 1 4 4 4 1 0 4 0    0 1 1 2 1 3 2 0 3 4 1 1 1 1 3 2 0 1 3 2 1 2 1 0 3 3 2 5 4 2 5 3 4 2 2 5 3 3 3    3 5 5 8 7 14 12 28 22 24 23 36 33 26 32 27 26 18 30 24 15 13 19 15 17 6 5 7 5    4 3 5 3 1 4 4 9 5 3 1 4 0 0 6 2 5 3 3 3 1 2 3 2 4 1 5 5 3 8 2 1 1 4 1 7 5 6 6    4 4 3 2 6 3 3 3 3 1 3 4 5 4 3 4 3 1 2 3 1 2 1 2 2 6 5 2 2 2 4 2 2 0 2 3 3 2 7    4 4 1 4 2 0 3 1 1 2 1 2 3 1 3 2 2 4 3 1 4 0 0 4 2 2 2 1 0 0 0 0   0.116000 2.500 2.500 6.600       745364           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 2 1 1 2 1 1 1 0 1 0 2 0 1 1    0 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 2 3 0 1 4 4 0 4 0 1 0 1 3 3 0 2 1 2 3    2 1 1 1 2 0 4 0 0 4 5 2 5 4 1 3 5 5 4 0 4 4 2 3 2 3 5 2 2 4 2 3 4 2 3 3 3 3 3    2 4 12 10 13 14 19 22 23 24 36 19 32 25 25 36 24 18 20 21 14 18 13 8 6 9 2 9 5   2 5 3 4 4 3 3 0 4 3 2 5 3 4 2 2 6 3 4 0 2 4 1 3 4 7 4 5 3 2 4 5 5 3 4 4 4 2 3    2 4 4 2 1 5 7 1 5 2 4 1 5 5 3 4 4 3 2 4 2 4 0 6 2 3 4 1 2 2 2 4 1 4 2 2 2 5 6    5 1 4 4 2 3 3 3 1 4 3 4 2 6 2 5 3 2 2 1 3 2 2 5 1 1 0 0 1 0 0 0   0.118000 2.550 2.550 6.700       791846           4           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0    1 4 1 2 3 0 3 1 0 1 1 1 0 3 1 2 1 1 1 0 0 1 1 1 3 1 3 2 3 1 2 2 1 3 2 4 1 4 0    2 4 1 4 3 2 1 1 2 1 3 2 3 3 2 1 1 5 3 3 3 3 2 3 4 3 5 3 1 1 2 2 3 5 1 2 1 1 4    4 6 9 6 6 13 17 21 20 24 22 25 20 29 23 28 30 26 27 18 20 17 16 17 12 10 8 5 6   6 6 4 3 1 2 4 6 9 2 2 3 5 7 6 2 3 8 5 4 5 6 4 6 5 3 5 3 2 5 3 2 8 3 5 4 5 3 5    4 3 4 8 4 3 8 3 3 3 1 1 2 2 5 4 7 3 2 3 3 2 2 3 6 3 2 2 1 1 5 2 5 6 3 5 3 4 1    3 1 2 1 0 4 1 4 2 2 2 3 1 1 1 1 3 2 0 1 6 1 1 0 2 1 0 1 0 0 0 0   0.120000 2.600 2.600 6.800       833394           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 2 1 1 1 2 1 0 0 0 1 0 1 0 0 0 1 0 0 1 1 2 1 0 0    0 0 0 2 2 0 3 1 0 0 2 1 1 1 1 0 1 2 1 5 0 1 0 2 2 1 2 0 4 2 1 4 3 4 2 2 1 2 1    5 2 3 1 3 0 2 2 2 2 3 4 0 4 2 3 3 4 5 2 2 6 3 4 5 5 5 3 4 6 5 1 3 0 5 4 5 1 3    2 2 6 18 13 17 27 27 21 28 28 24 26 27 29 23 21 16 17 19 22 14 11 9 5 14 7 7 6   4 4 12 3 6 4 5 4 6 4 2 0 1 8 1 6 8 5 2 3 4 5 6 4 2 5 8 3 1 1 6 3 7 8 4 1 6 5 2   8 11 5 6 5 6 2 4 5 1 2 7 2 2 5 5 6 3 3 2 3 8 5 1 9 3 3 2 3 6 3 5 3 2 4 6 3 1 3   5 4 4 4 6 3 3 5 0 2 2 5 1 3 2 2 1 4 2 0 2 2 2 2 4 1 2 1 2 1 1 0   0.122000 2.650 2.650 6.900       876007           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 2 1 1 1 1 2 2 1 0 0 1 0 0 0 1 1 0 0 0 2 0 0    4 1 0 2 1 2 0 1 2 0 1 3 2 1 0 1 1 0 1 2 1 0 2 3 3 5 3 3 3 0 1 4 0 1 5 3 4 3 1    2 2 2 4 1 3 3 3 2 3 2 3 2 1 4 4 2 2 5 5 3 4 1 2 1 2 4 2 4 7 2 4 4 2 7 3 5 7 5    3 6 8 10 10 18 21 22 24 14 25 27 29 31 22 25 24 21 27 20 19 22 19 14 13 14 10    5 7 3 4 5 5 3 1 4 3 8 4 5 4 0 3 4 3 4 1 7 6 1 1 3 4 4 3 4 3 6 4 3 4 2 4 4 3 5    6 5 1 1 6 2 6 6 3 5 5 3 2 6 5 4 3 4 6 4 3 5 5 6 5 6 2 4 2 1 2 2 4 2 7 6 2 1 3    1 5 2 1 2 4 3 3 3 2 5 2 4 1 4 3 2 2 5 5 1 1 3 3 2 2 2 2 1 0 0 0 0 0   0.124000 2.700 2.700 7.000       925764           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 3 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0    1 2 0 0 3 2 0 1 2 1 1 2 0 2 1 2 2 0 0 2 3 2 3 2 2 3 2 2 4 0 2 0 5 1 3 2 3 1 2    3 2 0 6 4 3 6 2 5 0 5 2 1 4 4 5 7 4 2 3 5 2 0 2 5 2 4 7 4 4 4 8 5 3 1 7 2 2 1    5 5 5 14 19 16 22 18 30 29 25 36 23 23 22 25 25 27 26 23 14 20 16 16 10 6 6 6    4 2 6 6 6 6 6 4 6 1 0 3 4 4 5 2 4 3 2 4 4 5 5 5 6 10 6 3 6 8 5 5 8 7 4 6 4 3 4   8 5 5 7 4 6 3 5 8 4 3 4 4 3 4 3 1 3 3 7 2 4 8 3 6 4 3 3 2 5 4 4 3 7 4 5 4 4 3    4 7 2 3 3 4 3 0 2 2 4 3 4 2 4 2 2 6 4 4 6 6 1 5 1 1 2 1 0 0 0 0 0   0.126000 2.750 2.750 7.100       969560           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 1 2 0 2 0 2 2 0 1 1 1 0 0 1 0 1 1 1 1 2 0    1 2 2 1 2 0 0 1 0 1 0 2 1 0 1 0 1 1 2 0 3 0 3 4 3 1 3 2 0 4 0 1 2 0 3 1 1 2 3    2 2 2 5 1 7 1 5 1 5 4 2 0 0 1 2 1 3 2 3 3 5 4 10 10 2 5 11 4 1 2 1 7 3 5 4 4 1   5 10 8 7 9 9 20 20 21 33 21 28 20 27 32 21 29 22 20 24 15 13 27 14 13 15 10 9    3 11 6 7 5 3 6 8 5 4 4 1 3 3 5 2 7 3 6 6 1 6 4 6 5 3 4 2 4 3 3 9 4 5 4 4 5 2 3   10 4 3 2 6 10 6 3 6 5 5 5 4 8 8 5 4 3 6 4 4 2 4 4 4 5 7 4 4 4 4 5 2 2 3 4 5 2    1 3 2 6 2 7 7 1 6 4 4 6 5 5 4 0 2 2 3 2 7 5 0 4 1 1 4 6 1 0 3 2 0 0 1   0.128000 2.800 2.800 7.200      1022713           5           0  0 0 0 0 0 0 0 0 0 0 0 1 0 2 0 0 0 1 0 1 1 0 0 1 1 1 0 0 0 2 1 0 0 4 0 0 1 2 3    1 1 0 1 0 1 0 3 1 1 1 2 2 1 1 1 3 1 0 2 4 2 1 2 1 2 0 3 1 3 2 1 5 2 1 3 1 2 1    5 3 2 1 2 5 3 8 2 3 2 5 5 4 3 6 4 4 4 3 2 3 8 4 3 4 5 4 5 4 7 6 5 3 3 3 5 2 9    10 7 9 12 11 13 17 15 22 19 33 24 28 30 26 21 24 22 27 20 26 16 10 10 9 20 10    7 4 5 7 7 2 7 5 3 5 1 6 1 5 7 5 6 3 1 5 1 1 3 4 8 6 3 9 5 5 3 6 7 4 6 7 6 4 2    4 6 2 3 6 5 6 7 6 4 4 9 6 8 6 9 7 1 2 6 2 7 5 4 4 4 4 5 5 4 4 3 6 3 5 3 6 4 3    6 6 2 5 2 8 4 5 3 6 5 4 5 8 4 3 5 6 5 5 2 8 1 2 2 5 4 1 3 0 0 0 0 0   0.130000 2.850 2.850 7.300      1081669           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 5 0 0 2 2 0 0 1 0 0 0 1 1 0 2 0 2 2 2 1 0    1 0 2 2 3 1 1 0 2 0 1 0 2 1 1 2 2 0 1 4 3 0 2 1 1 0 2 5 2 1 0 1 3 2 5 2 1 2 5    2 3 4 3 6 6 6 4 6 6 3 1 3 2 3 4 7 5 2 9 7 4 1 4 4 3 2 2 2 7 4 8 4 7 4 6 8 5 1    8 6 10 18 21 18 15 21 24 21 26 22 30 28 27 23 22 21 17 25 20 17 13 17 9 12 7 8   5 4 4 5 5 2 4 1 1 2 5 7 6 4 9 7 7 5 5 5 5 5 2 4 5 3 6 8 2 4 9 4 10 5 1 4 5 5 5   10 3 2 8 6 5 7 3 13 3 3 6 5 1 4 5 9 5 2 7 4 5 6 3 5 6 5 4 5 9 6 4 3 4 4 4 5 8    5 5 0 3 6 3 4 3 7 5 6 4 3 3 6 8 4 1 3 1 2 7 3 4 6 6 1 3 4 1 0 1 0 0   0.132000 2.900 2.900 7.400      1131887           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 1 1 0 0 0 1 2 2 1 1 0 2 1 1 0 1 1 1 0 2 2 3 1 0 1 0    1 0 2 0 2 0 1 4 0 1 2 2 0 0 0 2 3 0 1 2 3 0 1 2 3 5 6 2 2 3 1 4 4 8 4 3 3 3 7    2 2 5 7 4 1 2 4 8 1 5 2 7 3 4 2 9 6 5 5 6 2 2 3 6 2 5 6 7 7 2 8 3 3 3 3 6 6 5    3 10 15 15 17 19 13 29 20 23 22 34 28 28 33 20 20 22 17 22 18 15 19 14 11 9 13   6 6 13 4 2 9 8 8 7 6 5 6 4 4 9 6 2 8 9 7 2 6 3 7 3 6 3 7 4 4 5 4 5 6 4 7 5 4     10 2 6 6 8 3 6 6 9 5 8 8 7 6 4 8 5 7 5 5 7 3 5 5 5 10 7 3 8 7 5 7 2 4 4 6 4 10   7 6 4 4 4 4 3 2 4 2 6 5 9 7 3 2 6 2 5 1 5 6 2 2 1 9 2 5 2 5 1 0 0 0 1 1   0.134000 2.950 2.950 7.500      1185706           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 2 1 0 1 1 0 0 0 0 0 1 0 1 1 2 0 1 0 1 2 0 0 0    1 1 0 1 1 1 0 2 2 0 1 3 3 2 3 0 0 2 2 3 2 1 1 3 0 0 1 1 3 4 3 1 1 9 1 4 0 1 3    4 1 3 2 6 4 7 7 3 2 8 5 2 5 2 4 6 7 3 7 7 8 4 7 2 4 7 7 9 9 2 5 5 8 3 5 7 3 6    10 6 10 15 10 13 14 29 21 23 37 26 20 28 20 16 24 25 16 19 21 20 20 17 11 10     12 8 7 7 5 5 5 4 5 6 7 3 6 5 7 5 11 9 6 8 11 6 4 6 8 8 7 7 7 4 5 4 8 5 4 3 4 8   10 7 9 4 7 6 8 9 7 3 5 7 7 6 2 6 4 7 3 9 8 12 7 6 6 6 4 5 7 2 4 7 3 2 4 4 7 1    4 5 0 4 6 3 10 8 5 4 3 4 5 7 5 7 5 7 3 5 2 5 6 4 5 2 4 1 6 6 2 4 2 0 0 1 0   0.136000 3.000 3.000 7.600      1238426           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 2 4 0 2 0 2 2 0 1 1 1 0 2 1 1 2 1 0 1 1 0 3 1 0    0 1 0 1 0 0 2 1 1 0 4 0 2 6 3 3 4 0 3 1 2 4 0 4 4 0 1 5 2 2 5 1 3 4 3 3 5 2 4    4 6 2 5 3 4 5 4 5 6 7 5 6 2 8 3 4 7 2 4 4 3 7 6 5 1 4 8 3 7 10 3 3 6 1 5 3 8     11 5 7 15 11 15 17 21 23 21 24 28 16 21 29 15 22 27 28 20 13 19 13 7 15 10 11    9 6 8 8 4 7 5 4 6 5 10 6 7 8 9 3 5 5 9 5 9 4 4 4 3 5 7 4 10 6 8 4 9 8 4 6 7 9    11 6 8 3 5 8 12 3 6 9 7 11 9 6 7 4 7 7 7 2 5 4 5 0 2 9 5 5 5 10 7 5 6 3 9 4 4    13 2 7 5 7 4 7 2 0 4 5 4 4 6 8 1 2 5 6 4 7 3 11 4 3 3 5 5 4 4 3 1 4 2 2 1 1 0   0.138000 3.050 3.050 7.700      1299809           6           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 2 1 1 0 0 1 0 0 2 0 1 2 0 0 3 0 0 1 3 1    2 0 2 0 1 1 2 1 2 3 2 1 2 5 2 2 2 4 3 2 5 3 0 3 2 4 5 4 3 0 5 4 1 4 3 8 6 4 4    7 4 5 4 3 6 5 6 10 3 6 6 2 6 3 4 4 3 6 7 6 8 3 4 7 5 4 9 2 4 8 5 9 8 3 7 5 7 7   13 7 11 15 17 16 18 18 18 20 17 26 25 19 20 26 31 22 18 20 18 14 11 16 4 7 11    10 8 9 9 6 3 8 8 7 5 6 10 3 5 6 6 3 12 7 8 8 2 10 4 13 9 9 12 4 5 9 7 9 5 7 4    8 9 6 7 8 10 8 7 5 7 11 6 4 4 4 6 4 9 4 5 9 10 7 4 12 7 4 9 5 10 10 6 8 4 7 2    4 7 2 6 8 4 11 3 3 9 7 6 7 3 8 7 4 8 5 3 7 4 5 5 7 4 6 7 5 5 3 5 2 5 4 1 2 0 0   1   0.140000 3.100 3.100 7.800      1361810           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 3 2 1 0 0 0 1 1 1 2 0 0 0 0 1 0 2 2 2 1 0 0 3 3 0    2 0 6 2 3 1 0 3 3 1 2 2 5 3 5 3 3 2 2 7 3 2 2 3 4 2 3 4 4 1 3 7 4 5 4 2 3 5 4    2 1 3 6 3 4 3 8 7 6 5 3 5 11 5 5 3 3 7 3 6 4 4 2 4 4 4 1 5 5 9 6 6 9 3 10 8 6    8 3 10 8 16 16 13 18 23 29 25 19 19 20 27 19 22 27 24 21 15 18 11 20 21 17 12    5 18 6 12 7 9 11 7 12 11 4 8 8 4 8 7 7 2 6 4 4 9 6 9 3 4 7 7 7 4 10 4 11 5 8 8   8 5 4 4 8 6 4 9 8 12 12 8 5 8 3 10 8 7 5 3 5 6 8 5 6 10 7 2 11 2 5 5 6 8 10 2    7 5 5 14 2 7 3 9 3 5 2 8 2 3 4 4 7 9 5 4 7 6 7 5 6 3 5 4 7 6 7 7 9 3 0 2 1 1 1   0 0   0.142000 3.150 3.150 7.900      1429499           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 2 1 1 0 0 0 3 0 2 2 1 0 3 0 2 1 3 0 0 1    1 3 1 2 4 1 5 3 5 1 0 7 1 3 2 3 2 2 2 3 0 0 1 3 6 3 2 2 4 4 4 6 4 3 6 4 10 3 7   2 5 4 7 4 5 8 4 7 4 1 7 11 5 2 10 2 11 3 7 8 10 9 6 3 5 3 6 3 10 11 5 5 9 7 10   8 9 5 15 11 9 18 18 15 24 17 23 17 19 25 17 24 18 37 16 17 21 17 14 20 17 15     15 9 4 11 7 3 8 10 8 8 6 8 3 4 5 8 4 6 3 9 9 6 2 10 4 4 3 8 4 9 1 7 5 9 7 10 9   10 4 6 5 8 6 6 10 10 6 5 7 6 6 10 5 7 8 8 8 7 7 11 12 8 3 10 6 9 13 11 4 6 7 6   3 10 5 8 4 7 7 7 5 8 4 9 5 5 7 6 6 7 11 11 7 8 5 3 5 7 7 10 3 3 6 5 7 9 2 3 7    1 0 0 0 0 1   0.144000 3.200 3.200 8.000      1493946           3           0  0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 2 3 0 0 1 2 1 1 1 4 1 0 1 0 1 2 1 3 1 1 1 1 2    1 1 3 2 6 0 4 0 1 4 2 4 5 2 1 3 0 2 2 4 2 3 2 4 3 5 4 4 4 1 5 1 3 4 5 6 4 7 2    8 8 8 5 3 6 0 7 3 2 2 5 7 5 7 5 8 9 6 4 3 6 8 6 10 2 5 6 3 3 6 6 6 6 17 5 10 6   6 11 11 13 12 21 26 18 24 21 24 23 30 18 22 20 24 19 13 17 25 22 17 15 8 13 7    10 8 9 6 7 9 8 7 8 9 7 7 6 12 5 9 9 12 9 12 6 9 7 10 7 7 4 9 7 4 2 7 4 5 8 8 9   7 6 7 5 9 4 8 13 6 5 4 7 9 6 7 7 9 4 4 5 8 10 9 10 6 6 7 9 12 11 8 8 9 11 5 8    7 5 5 8 5 9 10 5 5 11 11 6 8 8 4 8 5 5 5 4 7 4 5 6 5 6 6 7 7 4 2 6 3 2 1 0 0 0   0 0   0.146000 3.250 3.250 8.100      1562352           5           0  0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 2 0 1 2 1 1 0 0 1 0 1 2 0 0 0 3 1 2 0 4 4 2 0    0 2 3 2 0 1 3 3 4 0 1 4 3 3 4 5 5 4 2 1 4 2 5 3 2 7 6 3 5 6 5 5 5 1 5 2 7 4 8    7 4 6 5 7 5 3 5 8 1 6 4 6 8 7 6 7 6 3 4 6 3 5 8 4 10 3 3 11 6 5 3 9 6 4 3 17 9   11 11 24 13 15 14 25 26 26 21 17 32 32 22 18 25 29 29 27 24 21 12 23 14 12 11    9 17 7 9 11 3 7 6 5 5 12 3 6 8 7 4 7 11 10 8 9 5 8 2 10 9 8 10 10 7 7 4 7 5 7    7 9 10 8 7 7 16 6 8 10 5 6 6 12 12 7 11 11 8 9 7 8 12 10 7 8 7 11 8 9 7 7 4 9    4 7 14 9 8 8 13 9 8 7 13 5 9 5 7 4 9 5 7 8 7 8 7 3 10 9 3 4 4 4 5 2 6 6 3 5 10   4 4 2 3 0 1 0 0   0.148000 3.300 3.300 8.200      1630559           3           0  0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 4 2 1 1 1 2 1 2 0 2 1 5 0 1 1 4 0 2 1 4 5 3 0    1 1 1 2 1 3 3 3 1 1 1 1 1 3 4 6 6 8 8 4 3 2 7 2 2 1 7 4 4 5 1 10 6 4 4 4 3 3 3   6 11 6 4 5 4 8 5 5 9 4 5 5 7 6 4 13 12 3 6 7 5 2 7 9 7 8 8 4 7 6 4 10 6 8 9 9    9 13 15 17 23 25 13 16 24 22 26 21 27 24 24 21 21 21 15 17 22 25 21 22 17 14     11 8 12 5 9 7 8 5 11 10 6 6 5 9 13 10 9 8 8 8 6 4 9 10 9 9 7 8 7 5 7 8 14 13 5   14 5 12 11 8 9 6 5 4 9 13 7 10 13 11 11 8 5 9 10 8 7 6 7 13 3 13 8 7 13 17 5 8   5 10 7 12 7 6 6 9 7 8 8 11 8 11 9 11 11 8 5 6 10 4 9 3 10 8 7 10 8 7 8 10 10 7   4 11 5 7 8 2 4 3 0 0 1 0 1   0.150000 3.350 3.350 8.300      1707576           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 1 2 1 0 2 0 2 3 1 3 2 2 2 2 0 2 1 4 3 2 2 3    1 2 1 0 2 2 4 2 5 3 3 5 2 8 4 5 4 2 3 6 7 6 1 0 7 4 7 7 6 5 4 3 4 6 6 7 6 2 7    4 4 2 5 5 6 9 3 3 3 6 6 5 3 5 7 8 8 6 8 8 6 8 3 9 6 6 8 8 6 4 8 6 6 10 4 11 6    11 15 23 16 8 17 20 21 19 24 15 14 19 21 30 25 21 15 19 16 18 21 21 15 14 12     16 8 10 12 7 10 9 8 10 10 7 9 8 10 12 6 6 9 11 6 5 9 12 6 7 12 7 5 6 8 5 9 4     11 9 8 8 10 7 6 10 7 11 13 7 4 13 11 8 11 9 16 6 12 11 10 10 19 2 9 11 8 7 8 8   6 13 6 10 12 12 9 12 9 9 8 7 7 9 6 12 8 4 9 9 8 5 7 8 9 5 12 5 7 5 9 10 9 10 3   6 6 8 7 11 3 5 5 4 2 0 0 0 0   0.152000 3.400 3.400 8.400      1777231           3           0  0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 1 3 1 0 3 4 2 3 3 3 3 3 2 1 1 1 1 3 3 0    1 8 0 0 5 3 7 4 4 4 4 4 3 5 2 2 5 3 6 1 7 6 1 2 2 5 2 1 6 6 8 7 7 5 10 4 1 6 9   3 4 5 3 5 8 4 9 8 11 8 3 2 7 7 9 10 9 10 8 6 8 6 8 7 10 8 7 3 8 4 10 7 6 8 9 6   5 16 9 19 24 23 17 23 24 22 30 21 15 23 27 20 20 20 18 20 23 18 17 15 19 17 18   13 9 4 4 7 12 7 10 4 8 6 10 5 6 13 2 3 8 7 8 7 3 11 8 7 9 7 19 7 8 9 6 14 8 8    11 10 11 13 14 10 16 8 9 13 8 9 9 12 7 12 11 6 9 15 5 9 9 9 11 11 13 6 10 6 4    12 9 9 12 11 8 6 9 16 10 10 10 8 10 10 6 7 4 1 15 6 8 4 9 13 11 8 10 11 9 8 3    3 6 6 7 9 4 6 8 7 4 2 1 2 2 1 0   0.154000 3.450 3.450 8.500      1849489           6           0  0 0 0 0 0 0 0 0 0 0 1 1 3 0 1 2 2 0 1 4 1 1 0 1 0 2 1 0 0 1 1 1 1 6 3 6 1 3 1    3 3 0 6 0 4 2 7 4 6 4 4 3 7 4 5 7 5 5 2 3 9 9 2 5 5 3 9 4 2 7 6 2 8 2 5 7 12 6   5 4 5 10 4 12 10 6 4 14 7 9 10 11 7 7 7 7 3 9 7 4 3 8 7 5 7 9 6 8 9 6 8 8 12 6   5 11 12 13 11 13 21 26 19 23 25 18 23 22 23 23 18 27 20 15 20 25 24 19 18 12     14 13 15 8 15 10 11 7 9 13 11 12 13 11 11 7 11 13 6 5 10 6 6 10 8 14 5 14 11 8   5 9 7 10 10 8 7 15 13 3 13 12 18 15 7 10 9 10 8 15 9 6 8 9 10 10 9 5 7 7 5 10    11 13 12 12 12 10 6 17 10 11 9 4 8 7 6 6 9 12 8 16 18 7 5 10 8 12 10 15 6 13     11 6 10 16 10 11 16 8 9 5 11 10 14 11 5 2 5 7 3 1 1 0 1 0   0.156000 3.500 3.500 8.600      1920727           4           0  0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 2 1 2 0 3 0 1 1 0 1 0 3 0 4 4 1 3 1 2 3 3 4 3    1 2 3 9 5 2 3 7 3 3 6 5 2 6 1 4 3 2 3 6 5 1 8 3 8 5 3 7 6 13 11 9 5 8 7 7 5 8    7 4 8 6 4 10 4 6 5 6 9 9 12 6 7 10 9 9 8 8 3 8 9 8 8 2 12 11 13 8 13 7 8 6 6 9   6 8 16 13 14 16 16 22 20 21 21 17 20 18 19 22 20 11 20 22 21 14 19 15 23 17 15   12 14 19 16 10 11 14 11 9 11 9 12 8 16 14 9 6 18 10 11 7 10 11 17 10 13 8 10     12 9 12 7 7 10 10 11 11 9 8 8 14 10 10 9 14 9 14 13 9 19 16 17 4 11 8 12 11 10   21 6 10 8 9 12 9 7 7 12 7 16 14 10 13 6 13 8 9 10 6 10 8 7 10 4 6 11 19 12 6 7   5 8 11 10 12 13 9 6 10 5 11 11 4 14 10 7 2 6 5 1 2 5 1 1 0 0   0.158000 3.550 3.550 8.700      1999833           3           0  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 2 3 2 2 2 1 2 3 0 1 0 1 3 2 0 0 3 2 3 2 5 7 0    3 4 1 10 7 7 4 5 2 3 4 3 8 3 6 4 4 4 8 2 3 4 5 5 7 1 6 7 8 1 6 8 1 4 4 11 9 4    7 11 9 10 5 6 8 4 3 9 7 9 11 5 5 8 8 4 8 7 8 11 9 12 6 4 13 4 12 10 6 9 11 10    11 10 11 11 11 14 15 14 23 18 17 29 16 26 23 15 19 14 18 19 22 31 13 21 20 12    16 15 14 18 17 15 8 12 14 13 10 10 10 10 10 13 11 6 8 11 8 14 8 10 11 11 8 10    13 5 14 7 12 9 10 10 12 15 18 8 6 9 9 12 8 9 20 14 16 10 11 14 5 5 13 6 11 9     11 15 6 9 13 11 7 8 7 10 8 16 12 11 8 10 14 11 17 11 8 16 13 9 10 5 10 17 13     14 16 8 10 9 11 5 10 9 10 12 8 11 12 11 8 6 7 12 15 13 12 7 13 5 0 3 2 0 0 0 0   0.160000 3.600 3.600 8.800      2073149           3           0  0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 1 2 1 2 2 1 0 2 2 1 0 3 6 4 5 5 2 2 2 5 5 3 6 4    6 4 5 2 4 4 3 2 4 6 3 3 6 5 7 4 5 7 5 3 5 6 13 5 3 10 5 9 7 4 5 6 5 10 6 5 5 6   6 4 14 7 6 11 6 9 10 9 8 5 3 8 10 10 6 6 8 9 5 6 14 7 11 10 9 9 11 13 8 4 5 10   12 6 16 8 8 7 19 20 23 10 16 27 25 23 19 26 21 16 20 21 24 18 25 8 11 13 16 18   13 22 18 9 16 4 16 10 12 13 9 7 9 8 17 11 10 13 10 14 4 9 12 16 8 9 16 17 13     11 14 8 8 13 9 11 15 10 11 14 8 6 4 9 11 18 9 9 8 9 15 11 11 11 9 6 13 13 10 7   8 10 15 14 9 7 4 10 12 17 10 14 13 10 10 12 20 9 7 6 11 15 11 10 8 9 6 10 13     17 6 8 9 6 13 13 16 10 15 5 11 14 11 12 6 5 12 9 4 9 2 4 1 1 0 0 0   0.162000 3.650 3.650 8.900      2156456           5           0  0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 2 0 1 1 3 2 3 4 3 3 2 1 3 6 5 2 3 4 4 3 6 2 3    4 4 5 5 3 4 1 4 5 9 3 3 4 3 3 8 5 6 12 2 10 3 4 6 8 9 8 8 2 2 7 5 8 2 8 9 7 2    6 8 6 5 8 2 7 5 6 13 5 6 8 11 6 10 5 6 3 8 10 11 10 10 14 10 11 8 11 8 12 6 12   5 15 12 13 10 13 13 18 23 12 21 18 21 23 20 30 20 23 26 24 24 21 21 29 19 21     16 23 20 13 19 13 16 11 15 13 13 11 8 11 14 14 13 4 16 15 18 13 9 19 8 11 6 9    14 8 13 12 13 10 13 10 14 11 13 11 8 10 13 11 11 14 11 8 14 11 10 9 14 12 14     18 8 12 7 13 12 10 14 14 8 12 17 11 13 9 12 12 15 7 9 13 17 11 11 11 12 17 12    11 16 15 8 9 12 7 13 15 11 16 7 10 7 14 5 18 10 10 8 8 6 6 13 14 6 9 11 9 9 3    5 1 1 3 0 0   0.164000 3.700 3.700 9.000      2234753           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 4 1 4 2 1 3 1 1 3 2 3 3 1 3 6 2 4 4 3 3 3 6 5 2    6 4 1 3 3 7 1 4 4 6 12 4 5 2 6 4 9 3 1 8 11 5 2 7 6 3 8 4 7 3 8 3 9 6 7 8 9 2    7 6 9 6 15 6 9 5 9 4 9 17 15 10 2 10 6 8 12 12 11 12 10 9 7 11 8 7 5 11 10 14    16 7 7 7 13 15 10 16 17 21 19 14 18 24 19 27 27 24 20 22 24 21 20 14 24 17 17    18 32 15 12 13 15 12 8 14 11 11 19 11 14 15 18 10 5 12 11 11 9 15 9 7 9 16 12    9 12 10 15 9 18 7 11 12 14 7 20 8 10 13 14 11 6 6 9 11 8 10 16 8 17 13 17 9 16   11 10 9 13 20 17 14 12 10 13 11 9 9 17 20 10 16 8 14 13 14 18 15 15 8 10 12 11   22 12 13 9 12 9 11 14 19 12 12 8 8 12 11 19 11 11 12 15 11 15 13 9 9 10 9 4 9    4 2 1 0 0   0.166000 3.750 3.750 9.100      2327990           3           0  0 0 0 0 0 0 0 0 0 0 0 0 3 2 2 0 1 2 2 1 1 0 0 3 1 4 2 6 4 2 4 3 2 5 5 2 3 1 3    1 2 10 2 7 4 3 4 3 3 4 3 10 6 9 6 3 8 5 5 3 4 4 6 8 4 4 7 5 5 11 14 5 3 6 8 8    7 10 11 7 17 7 11 10 8 7 8 12 13 11 12 6 13 9 7 7 6 5 8 13 10 10 14 11 11 8 12   15 14 9 13 10 9 18 13 18 12 23 14 17 24 15 23 25 31 19 17 29 19 19 19 26 25 19   17 22 19 19 19 11 11 12 22 21 8 10 18 10 14 19 17 13 14 10 6 9 10 15 11 5 13     13 11 11 17 16 9 7 14 7 19 6 10 13 7 12 18 14 7 12 15 13 13 9 13 13 13 12 12     14 12 19 10 16 18 18 12 8 10 10 9 7 14 9 11 13 12 8 15 12 11 10 12 11 17 15 19   14 14 12 7 7 12 11 15 16 12 11 12 10 19 19 12 14 12 15 11 20 13 7 18 9 15 19     16 11 5 9 8 6 2 4 0 2 0 1   0.168000 3.800 3.800 9.200      2406866           3           0  0 0 0 0 0 0 0 0 0 1 0 2 0 1 0 2 3 2 3 1 2 1 2 2 5 2 1 2 3 2 2 2 5 3 5 3 3 1 3    6 8 6 1 3 9 6 3 6 10 5 5 7 4 5 7 12 9 5 7 5 6 6 8 3 5 4 7 8 5 6 5 8 13 4 10 2    10 9 7 7 16 9 10 9 13 8 12 9 13 15 9 15 9 10 11 6 6 6 7 7 6 8 15 9 8 9 6 12 12   11 14 12 11 13 8 17 18 18 11 14 19 14 25 21 15 10 15 19 27 23 22 24 17 19 18     12 16 22 21 25 9 25 15 19 15 21 15 8 11 13 12 10 12 7 13 11 17 11 13 10 16 19    14 23 11 8 12 13 10 9 17 4 14 10 7 10 17 14 11 11 20 18 13 8 12 6 8 13 12 23     15 14 15 16 9 14 9 13 14 17 11 17 11 10 15 17 11 6 12 12 14 15 17 12 16 16 8     17 15 15 10 15 11 10 15 12 13 9 12 9 12 15 12 6 18 7 15 14 12 21 18 11 10 18     11 19 11 7 11 3 2 5 4 0 1 1   0.170000 3.850 3.850 9.300      2508471           7           0  0 0 0 0 0 0 0 0 0 0 0 0 1 3 1 2 1 4 3 3 1 2 7 0 3 2 2 2 2 5 2 3 2 3 3 4 3 7 3    5 3 4 4 6 2 3 10 4 11 3 13 7 7 5 6 3 8 10 6 6 4 10 11 4 12 7 8 9 7 7 8 4 6 7 9   9 5 9 11 5 14 9 10 7 9 8 8 5 6 11 13 14 10 10 10 10 8 9 9 9 9 14 14 13 11 8 18   9 10 9 16 12 13 15 13 10 17 16 20 14 22 20 26 29 29 27 24 20 37 21 24 13 18 13   28 24 22 25 21 13 14 15 9 11 18 8 16 17 16 13 12 16 11 11 17 15 11 15 10 11 12   13 12 12 20 15 14 15 16 12 17 15 15 12 10 14 14 17 15 19 15 13 13 11 12 16 14    17 16 8 16 12 8 14 13 13 10 10 9 12 11 19 20 13 11 4 15 11 14 11 20 18 18 13     20 12 20 21 15 15 12 13 18 18 11 16 9 14 9 18 11 10 11 20 11 13 17 13 13 12 14   16 10 12 12 23 12 11 12 8 8 1 0 1 2 0   0.172000 3.900 3.900 9.400      2591210           3           0  0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 4 4 3 2 1 3 3 2 3 0 3 6 1 3 1 5 5 4 3 9 9 0 4 7    5 3 5 5 8 7 3 3 5 5 8 5 11 10 8 10 3 6 6 6 7 7 8 8 12 9 6 10 8 7 10 8 8 10 4 6   12 20 4 6 11 7 9 10 7 5 10 6 12 11 7 13 13 16 12 6 8 14 13 9 7 5 14 17 17 10     12 11 6 13 11 17 3 23 13 21 12 21 28 11 23 30 28 23 24 26 26 17 21 15 27 23 33   16 22 25 11 20 22 23 21 20 7 21 13 16 12 16 16 13 18 18 9 13 16 15 9 20 13 19    15 8 9 11 14 13 10 9 10 16 15 14 17 15 19 16 12 14 12 14 14 16 19 19 4 24 8 12   15 16 11 15 14 20 14 13 13 14 16 19 14 13 19 14 18 23 15 15 4 14 17 14 8 10 15   20 11 15 19 12 9 13 12 11 16 12 16 13 14 16 13 16 16 19 19 12 11 10 19 15 15     14 12 5 11 18 17 10 13 12 9 6 2 0 0 1 0   0.174000 3.950 3.950 9.500      2675515           3           0  0 0 0 0 0 0 0 0 0 0 2 0 1 1 0 2 1 2 3 3 1 3 1 3 7 5 3 6 4 3 9 4 5 2 5 3 3 3 6    9 5 5 2 6 8 5 8 4 8 5 6 5 6 4 6 3 7 11 6 9 9 3 6 6 7 6 8 7 9 12 18 6 9 8 11 11   8 14 15 15 11 15 13 9 19 10 15 14 9 4 18 5 8 10 8 10 13 9 12 11 8 8 12 6 15 8    9 9 18 7 17 21 9 13 18 14 21 24 18 22 17 26 15 21 23 25 19 26 23 20 27 17 27     20 26 15 22 15 19 15 16 24 12 15 24 13 13 17 11 7 10 21 15 15 16 13 20 22 12     16 12 16 15 14 18 11 12 14 14 24 10 13 16 19 8 11 18 19 15 15 23 16 16 11 12     18 11 13 14 16 10 14 13 18 12 15 15 14 8 11 17 12 22 13 12 14 15 10 11 15 19     15 12 17 8 21 23 13 19 11 8 12 15 11 14 15 19 15 10 17 9 16 14 18 14 16 14 14    23 14 14 13 16 12 14 15 14 9 14 7 5 2 3 1 1 1   0.176000 4.000 4.000 9.600      2779386           5           0  0 0 0 0 0 0 0 0 0 0 0 2 2 3 0 1 3 0 6 2 6 3 1 5 0 4 1 6 5 1 6 3 6 5 6 2 5 4 5    3 9 8 5 7 5 8 4 12 8 12 6 8 5 7 5 7 10 5 5 6 7 9 7 10 7 10 10 8 12 10 6 13 10    11 12 11 10 10 16 9 6 12 9 11 17 10 11 10 14 11 16 7 11 13 12 10 17 14 11 13     12 10 13 16 16 17 17 15 14 11 8 15 13 27 22 14 19 17 22 22 27 18 28 19 27 32     24 33 21 17 23 12 27 25 20 20 17 22 14 15 22 21 14 9 16 12 19 16 17 16 16 20     14 18 15 14 18 10 12 9 16 12 12 10 13 19 12 12 15 14 15 22 12 11 15 18 19 18     10 6 11 14 10 23 17 14 16 19 10 10 16 19 17 23 16 18 19 18 16 12 14 14 14 13     11 10 24 21 22 26 18 18 18 14 17 5 13 17 11 13 16 14 18 16 9 15 15 18 16 14 21   13 22 17 9 8 16 17 16 16 19 7 20 19 18 16 10 6 10 6 3 5 1 0 0 2   0.178000 4.050 4.050 9.700      2869617           3           0  0 0 0 0 0 0 0 0 0 0 2 2 2 0 1 4 1 3 2 2 1 2 3 2 2 4 4 7 5 6 5 3 6 6 5 7 8 1 5    2 3 5 5 8 10 7 6 10 9 6 8 9 7 8 10 15 4 10 5 8 8 6 11 8 8 11 7 5 8 14 5 11 7     13 10 9 7 8 9 14 12 10 9 11 6 14 15 14 13 11 9 18 18 10 14 14 10 12 16 12 9 8    14 15 6 11 11 12 10 14 12 11 18 13 13 27 16 23 23 20 21 32 20 18 25 22 24 32     25 34 19 23 21 25 22 25 19 23 19 21 16 19 16 18 9 18 6 13 12 13 18 12 8 19 14    14 11 16 13 15 14 21 11 14 14 13 11 20 14 14 26 10 22 16 18 15 20 24 18 19 19    16 14 14 14 21 13 19 18 20 13 17 11 17 14 22 17 15 15 20 8 21 15 16 16 23 17     13 19 21 20 12 15 18 15 19 15 18 17 20 15 13 14 24 18 15 15 14 18 20 19 17 19    20 21 21 15 19 19 17 11 16 16 11 23 10 20 13 10 5 10 2 3 1 1 0   0.180000 4.100 4.100 9.800      2975040           3           0  0 0 0 0 0 0 0 0 1 0 0 1 2 2 4 4 2 4 4 1 2 5 0 3 3 5 2 5 5 4 9 2 7 8 4 8 3 11 6   10 4 7 8 6 6 5 8 8 7 11 4 4 11 12 7 11 7 10 11 7 11 11 10 9 7 13 12 18 8 14 12   14 12 8 8 16 10 10 14 16 10 6 8 15 15 15 22 13 19 18 12 6 11 10 7 12 12 24 15    17 9 17 21 10 17 18 14 14 14 9 22 11 23 17 15 23 32 20 11 12 20 15 23 30 20 25   19 26 29 19 27 23 15 19 11 30 16 21 24 18 18 14 8 6 25 13 21 13 13 19 13 21 25   23 18 14 14 13 20 12 14 8 10 25 14 15 20 15 10 15 16 21 8 15 20 21 20 13 16 15   20 11 18 17 17 9 12 24 19 13 18 17 20 14 15 20 10 23 19 25 8 7 13 14 11 15 18    13 10 12 10 17 11 24 16 17 11 12 13 16 20 14 26 12 17 13 14 16 16 6 20 16 23     22 11 17 16 14 25 19 17 21 22 19 13 19 16 18 10 11 7 4 6 0 0 2   0.182000 4.150 4.150 9.900      3083416           6           0  0 0 0 0 0 0 0 0 0 0 2 1 1 4 1 3 4 3 5 6 2 1 4 2 3 5 6 6 7 2 4 1 11 7 5 2 6 6 8   9 8 12 7 11 9 6 12 7 8 9 6 6 8 11 6 6 8 11 8 11 12 11 13 9 10 7 9 6 11 9 13 12   12 8 14 15 8 9 8 8 11 22 16 6 11 16 15 9 13 12 12 13 11 15 9 9 16 14 14 12 21    12 12 12 16 19 10 15 18 8 16 14 16 16 21 30 22 9 25 19 19 26 23 33 25 22 21 19   21 20 20 21 20 26 20 29 27 25 25 21 20 25 21 21 18 14 19 15 6 20 18 16 20 16     13 13 15 15 15 15 22 16 15 15 11 21 19 11 19 13 14 15 17 21 12 18 12 22 18 21    18 13 23 15 18 9 21 11 14 23 18 21 25 18 22 15 21 23 15 15 16 19 21 18 19 21     17 13 24 23 22 19 14 20 22 15 14 14 20 20 23 13 18 15 18 20 20 24 9 12 17 21     21 12 16 17 16 16 21 26 19 15 21 22 24 15 11 13 13 6 8 1 4 0 1 0   0.184000 4.200 4.200 10.00      3174897           3           0  0 0 0 0 0 0 0 0 0 0 1 1 2 3 0 5 4 3 3 0 7 3 2 4 2 8 6 4 5 9 3 8 6 4 2 7 6 8 7    9 3 5 8 5 9 7 7 6 11 14 7 12 9 9 5 15 12 14 15 12 9 11 5 8 13 11 12 10 9 17 12   11 8 17 11 19 11 15 9 11 7 15 14 16 16 16 7 12 10 14 13 13 16 16 11 15 13 14     12 16 11 12 13 17 10 13 19 11 17 11 13 14 13 10 19 19 23 24 22 24 24 31 19 23    22 28 21 25 29 17 23 17 21 30 22 19 25 27 27 22 23 23 17 25 17 20 17 12 23 21    9 17 20 16 19 16 17 20 9 16 11 22 16 15 12 15 17 23 24 16 16 18 26 11 16 20 18   10 14 17 26 19 17 15 17 19 12 21 20 24 17 27 13 16 18 19 23 14 19 14 10 11 18    19 6 15 21 23 25 17 17 18 21 27 20 17 18 20 25 22 20 18 22 18 17 15 24 16 15     22 18 22 14 20 20 22 18 22 25 19 26 12 19 19 13 12 16 19 14 9 7 5 4 2 0 2   0.186000 4.250 4.250 10.10      3283256           3           0  0 0 0 0 0 0 0 1 0 0 1 1 4 1 5 2 5 5 3 4 6 3 2 4 7 8 2 6 6 4 10 7 8 7 5 4 4 9 8   18 10 7 6 6 13 12 10 13 10 7 15 4 7 10 13 12 8 8 13 5 14 6 9 14 9 10 16 12 13    11 8 12 11 10 13 9 11 15 17 23 18 13 10 12 11 12 14 14 14 10 12 12 16 13 15 13   13 14 18 10 13 17 14 14 14 12 12 8 18 14 23 20 16 19 16 16 16 27 18 21 19 20     19 37 22 21 22 28 24 26 18 21 28 21 22 21 21 22 16 15 13 22 22 27 22 11 13 20    10 17 16 19 20 30 18 25 8 7 22 18 17 14 23 16 17 11 16 24 19 18 22 15 15 23 16   13 15 22 14 8 12 18 13 15 22 17 15 15 17 27 21 19 21 24 17 10 12 14 19 17 22     18 19 17 28 19 15 14 16 28 17 20 15 11 22 18 19 16 21 17 24 19 22 22 20 10 20    18 18 18 21 18 23 18 32 26 21 21 22 20 22 16 17 20 22 21 17 13 13 11 9 5 0 1 1   1   0.188000 4.300 4.300 10.20      3396610           5           0  0 0 0 0 0 0 0 0 0 0 1 2 3 0 2 5 5 4 3 3 5 1 2 3 6 9 3 3 3 8 7 2 9 5 7 5 11 8 9   7 6 9 6 4 5 8 6 10 9 14 10 15 6 7 13 15 10 13 7 15 10 10 11 14 14 6 7 17 13 19   3 13 9 6 13 13 14 10 11 12 16 17 13 10 15 15 19 19 11 11 15 11 13 9 13 20 8 18   14 18 23 23 23 15 19 20 14 11 7 18 16 15 22 28 20 24 22 25 17 20 39 24 26 25     25 33 25 25 25 33 15 29 18 29 18 12 18 23 17 24 28 22 16 20 33 23 18 23 26 23    15 24 16 16 16 16 17 15 15 16 14 11 9 23 17 13 13 18 12 19 20 30 20 20 15 21     19 16 18 20 23 19 15 10 11 15 19 13 22 22 18 19 16 19 23 16 10 25 23 20 21 20    31 19 19 18 15 22 18 14 13 21 18 19 22 19 16 17 21 14 20 26 18 26 22 19 26 19    20 22 15 13 24 23 15 21 21 21 27 18 22 19 24 17 22 16 18 23 10 12 3 5 3 3 0 0   0.190000 4.350 4.350 10.30      3502025           3           0  0 0 0 0 0 0 0 0 0 0 0 3 0 3 2 3 4 4 3 4 5 10 7 6 6 4 5 12 10 6 6 13 10 6 7 14    9 6 13 10 12 16 3 9 9 7 5 6 13 11 10 8 11 19 12 14 13 16 13 14 9 12 14 13 14     16 10 14 7 16 18 16 9 15 11 20 15 10 14 14 11 14 17 10 6 16 10 15 12 17 17 20    15 7 12 23 15 8 13 12 8 16 15 20 16 16 20 14 11 20 24 23 20 16 18 27 25 31 27    27 25 21 31 27 20 23 24 32 17 21 34 27 17 19 19 25 30 27 21 24 28 30 19 26 21    14 16 21 23 27 8 17 21 17 11 23 15 22 15 18 10 17 20 23 18 18 17 19 22 15 22     21 19 23 18 18 26 17 18 26 18 24 15 22 23 23 19 23 25 23 24 26 10 21 16 32 23    18 19 24 21 28 26 22 19 19 14 30 21 24 23 22 21 13 27 20 27 24 15 20 22 22 13    25 14 19 32 21 18 18 23 22 22 14 18 20 24 14 19 20 18 17 24 29 27 20 12 18 17    11 9 2 3 2 1 0   0.192000 4.400 4.400 10.40      3593938           3           0  0 0 0 0 0 0 0 0 0 0 1 0 1 1 2 3 4 7 8 1 5 6 8 3 7 5 4 9 8 8 7 7 9 7 9 9 15 5 7   8 15 14 9 9 13 8 8 15 10 7 10 9 10 14 7 8 18 16 17 11 14 15 13 8 15 8 15 18 16   16 22 12 8 16 13 10 13 13 10 21 11 10 16 16 13 13 17 16 20 23 13 22 16 14 15     22 19 22 15 22 24 16 16 16 19 12 15 16 17 20 18 19 26 17 23 18 32 20 28 36 22    25 30 29 31 36 24 24 21 29 24 32 29 30 23 34 19 33 34 25 20 31 27 24 16 14 21    20 13 24 17 28 13 24 16 26 15 26 21 11 15 20 13 20 18 25 23 18 24 26 22 16 22    14 13 16 20 24 25 19 29 20 15 20 16 25 26 21 22 17 24 22 21 17 23 23 15 19 30    23 17 21 19 18 21 26 14 29 24 20 33 19 15 20 23 28 19 23 25 15 19 17 31 23 18    29 26 25 14 24 25 18 19 19 24 35 31 23 23 14 15 19 11 20 19 24 17 16 9 10 12 3   2 2 0 1   0.194000 4.450 4.450 10.50      3712573           7           0  0 0 0 0 0 0 0 0 0 0 0 1 1 1 5 3 5 4 3 11 3 10 4 6 7 8 5 5 5 8 9 12 7 7 11 8 6    7 9 10 13 10 6 13 9 9 9 11 14 14 12 13 10 6 13 13 15 12 13 19 8 14 13 16 11 13   14 15 9 15 16 13 16 17 17 17 23 18 16 19 10 13 18 16 10 9 21 11 22 14 20 14 18   13 15 12 13 14 16 14 15 20 29 17 14 18 8 15 21 15 19 15 22 20 17 15 23 26 16     26 24 23 23 23 23 30 24 29 28 26 35 33 31 22 23 22 20 37 22 27 33 26 27 26 17    16 18 27 22 21 24 18 18 18 17 15 18 14 19 24 22 15 20 21 15 19 25 15 16 26 19    22 29 20 16 13 15 16 32 24 23 13 33 17 22 18 18 23 24 22 21 20 26 21 16 22 18    18 16 15 26 26 17 22 21 13 25 24 13 23 18 18 25 32 20 24 21 17 19 24 24 23 33    19 19 21 32 18 22 23 19 23 32 18 31 22 25 23 23 31 29 21 16 20 20 15 22 14 12    5 10 9 2 1 0 1   0.196000 4.500 4.500 10.60      3829518           3           0  0 0 0 0 0 0 0 0 0 1 2 2 1 6 2 6 5 9 3 5 6 8 6 3 8 10 7 11 9 4 8 9 5 11 10 13 9   16 13 10 9 5 12 9 15 10 13 9 12 18 14 19 9 13 14 12 13 21 17 17 18 16 13 12 16   14 18 10 15 15 16 11 15 22 17 19 17 11 12 26 12 17 19 18 21 20 27 17 18 19 21    14 19 16 12 16 21 20 18 8 17 17 13 13 18 15 19 15 19 20 28 21 29 27 27 34 24     26 31 25 24 16 17 23 23 30 28 18 28 32 28 37 18 26 18 16 33 21 31 21 20 22 19    20 25 18 18 20 11 17 20 22 23 14 14 17 18 20 25 20 19 20 22 19 16 33 25 21 21    24 18 16 22 29 22 16 27 26 28 21 20 22 17 25 23 20 23 18 16 19 26 22 21 22 23    15 20 19 17 23 19 20 15 22 18 22 26 23 23 31 17 29 18 13 15 19 18 24 22 28 22    17 23 24 26 21 23 25 24 29 26 18 41 24 29 22 27 23 28 16 30 24 18 23 19 17 18    21 17 14 8 2 5 2 0 0   0.198000 4.550 4.550 10.70      3950740           3           0  0 0 0 0 0 0 0 0 1 1 1 2 1 3 7 5 6 7 7 7 4 5 6 4 1 8 9 10 9 8 10 8 12 6 10 8 10   8 11 9 10 15 7 11 8 13 11 13 15 15 17 12 10 8 17 12 9 14 12 14 11 14 21 14 15    20 18 16 8 15 22 24 14 10 18 14 15 16 12 10 16 21 16 25 17 20 17 17 20 15 24     15 17 22 25 17 13 22 18 20 19 11 21 22 21 16 21 24 16 22 17 21 17 24 22 24 35    27 24 28 24 32 37 34 25 24 29 37 37 25 28 21 23 24 22 21 20 25 22 32 19 21 22    24 20 21 20 22 18 27 17 14 20 22 22 22 14 19 20 20 21 23 22 14 20 21 23 20 18    23 20 25 31 24 18 22 14 23 22 21 23 27 27 20 21 18 22 23 24 23 21 18 22 17 22    21 35 15 24 24 12 27 30 27 28 22 31 24 24 19 27 24 28 23 25 26 35 27 22 29 21    24 18 19 26 33 29 31 23 25 19 24 26 21 10 23 24 26 28 20 27 26 17 29 22 18 14    22 8 10 11 4 4 1 2 0   0.200000 4.600 4.600 10.80      4068161           5           0  0 0 0 0 0 0 0 0 0 1 1 0 1 5 5 2 9 3 11 6 9 8 7 7 8 3 3 13 10 8 7 5 8 13 8 7 14   12 10 7 15 13 13 11 12 12 14 12 13 12 10 15 11 14 7 16 15 8 15 13 15 13 18 13    17 21 15 12 13 13 17 18 18 18 16 19 20 17 14 17 24 13 12 18 19 19 13 21 18 26    21 23 16 14 18 19 13 33 13 19 20 14 20 23 14 26 19 22 21 21 16 27 30 25 28 22    32 21 30 27 31 21 30 22 27 27 31 27 21 17 38 41 17 21 20 19 30 24 27 20 20 21    30 20 19 19 31 25 24 13 21 23 19 24 33 24 17 20 17 12 25 23 18 24 11 24 25 22    33 20 11 22 31 21 20 26 27 21 26 24 14 23 23 20 20 26 28 10 20 27 24 22 17 27    28 20 23 23 33 20 24 26 32 33 29 21 25 24 17 18 19 27 26 20 24 26 24 24 26 21    19 24 21 36 32 18 33 33 20 23 25 33 19 27 25 27 24 27 21 21 23 28 18 27 25 19    24 15 17 12 15 7 2 1 0 0 ", "%f ", Inf);
 %! assert (rows (x) == n);
 
 %% Note use fprintf so output not sent to stdout
-%% test/octave.test/io/printf-1.m
 %!test
 %! nm = tmpnam ();
 %! fid1 = fopen (nm,"w");
 %! x = fprintf (fid1, "%s: %d\n", "test", 1);
 %! fclose (fid1);
 %! fid2 = fopen (nm,"r");
 %! str = fscanf (fid2,"%s");
 %! fclose (fid2);
 %! unlink (nm);
 %! assert (x, 8);
 %! assert (str, "test:1");
 
-%% test/octave.test/io/printf-2.m
 %!error printf (1)
-
-%% test/octave.test/io/printf-3.m
 %!error <Invalid call to printf> printf ()
 
-%% test/octave.test/io/sprintf-1.m
 %!test
 %! [s, msg, status] = sprintf ("%s: %d\n", "test", 1);
-%!
 %! assert (s == "test: 1\n" && ischar (msg) && status == 8);
 
-%% test/octave.test/io/sprintf-2.m
-%!error sprintf (1)
+%!assert (sprintf ("%-+6.2f", Inf), "+Inf  ")
+%!assert (sprintf ("%-6.2f", Inf), "Inf   ")
+%!assert (sprintf ("%-+6.2f", nan), "+NaN  ")  # lowercase nan is part of test
+%!assert (sprintf ("%-6.2f", nan), "NaN   ")
+%!assert (sprintf ("%-+6.2f", NA), "+NA   ")
+%!assert (sprintf ("%-6.2f", NA), "NA    ")
 
-%% test/octave.test/io/sprintf-3.m
 %!error <Invalid call to sprintf> sprintf ()
+%!error <format TEMPLATE must be a string> sprintf (1)
 
-%% test/octave.test/io/fopen-1.m
 %!test
-%! arch_list = {"native"; "ieee-le"; "ieee-be"; "vaxd"; "vaxg"; "cray"};
-%! warning ("off", "Octave:fopen-mode")
+%! arch_list = {"native"; "ieee-le"; "ieee-be"};
+%! warning ("off", "Octave:fopen-mode");
 %! status = 1;
 %!
-%! for i = 1:6
+%! for i = 1:3
 %!   arch = arch_list{i};
 %!   for j = 1:4
 %!     if (j == 1)
 %!       mode_list = {"w"; "r"; "a"};
 %!     elseif (j == 2)
 %!       mode_list = {"w+"; "r+"; "a+"};
 %!     elseif (j == 3)
 %!       mode_list = {"W"; "R"; "A"};
@@ -357,26 +341,26 @@
 %!       [id, err] = fopen (nm, mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = cstrcat (mode, "b");
+%!       tmp_mode = [mode, "b"];
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = cstrcat (mode, "t");
+%!       tmp_mode = [mode, "t"];
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
@@ -388,53 +372,38 @@
 %!   endfor
 %!   if (status == 0)
 %!     break;
 %!   endif
 %! endfor
 %!
 %! assert (status == 1);
 
-%% test/octave.test/io/fopen-2.m
 %!test
 %! s.a = 1;
 %! fail ("fopen (s)");
 
-%% test/octave.test/io/fopen-3.m
 %!error fopen ("foo", "x")
 
-%% test/octave.test/io/fopen-4.m
 %! fopen ("foo", "wb", "noodle");
 %! assert (__prog_output_assert__ ("error:"));
 
-%% test/octave.test/io/fopen-5.m
 %!error <Invalid call to fopen> fopen ()
-
-%% test/octave.test/io/fopen-6.m
 %!error <Invalid call to fopen> fopen ("foo", "wb", "native", 1)
 
-%% test/octave.test/io/fclose-1.m
 %!error fclose (0)
-
-%% test/octave.test/io/fclose-2.m
 %!error <Invalid call to fclose> fclose (1, 2)
 
-%% test/octave.test/io/tmpnam-1.m
 %!assert (ischar (tmpnam ()))
 
-%% test/octave.test/io/tmpnam-2.m
 %!warning tmpnam (1);
-
-%% test/octave.test/io/tmpnam-3.m
 %!warning tmpnam ("foo", 1);
 
-%% test/octave.test/io/tmpnam-4.m
 %!error <Invalid call to tmpnam> tmpnam (1, 2, 3)
 
-%% test/octave.test/io/binary-io-1.m
 %!test
 %! type_list = ["char"; "char*1"; "integer*1"; "int8";
 %! "schar"; "signed char"; "uchar"; "unsigned char";
 %! "short"; "ushort"; "unsigned short"; "int";
 %! "uint"; "unsigned int"; "long"; "ulong"; "unsigned long";
 %! "float"; "float32"; "real*4"; "double"; "float64";
 %! "real*8"; "int16"; "integer*2"; "int32"; "integer*4"];
 %!
@@ -459,17 +428,16 @@
 %!       __printf_assert__ ("ok\n");
 %!     endif
 %!   endif
 %! endif
 %!
 %! unlink (nm);
 %! assert (__prog_output_assert__ ("ok"));
 
-%% test/octave.test/io/file-pos-1.m
 %!test
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! if (id > 0)
 %!   fprintf (id, "%d\n", 1:100);
 %!   fclose (id);
 %!   id = fopen (nm, "rb");
 %!   if (id > 0)
@@ -497,124 +465,65 @@
 %!           error ("bombed!!");
 %!         endif
 %!       endif
 %!     endif
 %!   endif
 %! endif
 %! unlink (nm);
 
-%% test/octave.test/io/fputs-1.m
+%!assert (fputs (1, 1),-1)
+
 %!error <Invalid call to fputs> fputs ()
-
-%% test/octave.test/io/fputs-2.m
 %!error <Invalid call to fputs> fputs (1, "foo", 1)
 
-%% test/octave.test/io/fputs-3.m
-%!assert (fputs (1, 1),-1)
+%!error fgetl ("foo", 1)
 
-%% test/octave.test/io/fgetl-1.m
 %!error <Invalid call to fgetl> fgetl ()
-
-%% test/octave.test/io/fgetl-2.m
 %!error <Invalid call to fgetl> fgetl (1, 2, 3)
 
-%% test/octave.test/io/fgetl-3.m
-%!error fgetl ("foo", 1)
+%!error fgets ("foo", 1)
 
-%% test/octave.test/io/fgets-1.m
 %!error <Invalid call to fgets> fgets ()
-
-%% test/octave.test/io/fgets-2.m
 %!error <Invalid call to fgets> fgets (1, 2, 3)
 
-%% test/octave.test/io/fgets-3.m
-%!error fgets ("foo", 1)
-
-%% test/octave.test/io/fprintf-1.m
-%!error <Invalid call to fprintf> fprintf ()
-
-%% test/octave.test/io/fprintf-2.m
-%!error <Invalid call to fprintf> fprintf (1)
-
-%% test/octave.test/io/fprintf-3.m
 %!test
 %! s.a = 1;
 %! fail ("fprintf (s)", "Invalid call to fprintf");
 
-%% test/octave.test/io/fprintf-4.m
+%!error <Invalid call to fprintf> fprintf ()
+%!error <Invalid call to fprintf> fprintf (1)
 %!error fprintf (1, 1)
-
-%% test/octave.test/io/fprintf-5.m
 %!error fprintf (-1, "foo")
 
-%% test/octave.test/io/fscanf-1.m
-%!error <Invalid call to fscanf> fscanf ()
-
-%% test/octave.test/io/fscanf-2.m
-%!error <Invalid call to fscanf> fscanf (1)
-
-%% test/octave.test/io/fscanf-3.m
 %!error fscanf ("foo", "bar")
 
-%% test/octave.test/io/fread-1.m
-%!error <Invalid call to fread> fread ()
+%!error <Invalid call to fscanf> fscanf ()
+%!error <Invalid call to fscanf> fscanf (1)
 
-%% test/octave.test/io/fread-2.m
+%!error <Invalid call to fread> fread ()
 %!error <Invalid call to fread> fread (1, 2, "char", 1, "native", 2)
-
-%% test/octave.test/io/fread-3.m
 %!error fread ("foo")
 
-%% test/octave.test/io/fwrite-1.m
 %!error <Invalid call to fwrite> fwrite ()
-
-%% test/octave.test/io/fwrite-2.m
 %!error <Invalid call to fwrite> fwrite (1, rand (10), "char", 1, "native", 2)
-
-%% test/octave.test/io/fwrite-3.m
 %!error fwrite ("foo", 1)
 
-%% test/octave.test/io/feof-1.m
 %!error <Invalid call to feof> feof ()
-
-%% test/octave.test/io/feof-2.m
 %!error <Invalid call to feof> feof (1, 2)
-
-%% test/octave.test/io/feof-3.m
 %!error feof ("foo")
 
-%% test/octave.test/io/ferror-1.m
 %!error <Invalid call to ferror> ferror ()
-
-%% test/octave.test/io/ferror-2.m
 %!error <Invalid call to ferror> ferror (1, 'clear', 2)
-
-%% test/octave.test/io/ferror-3.m
 %!error ferror ("foo")
 
-%% test/octave.test/io/ftell-1.m
 %!error <Invalid call to ftell> ftell ()
-
-%% test/octave.test/io/ftell-2.m
 %!error <Invalid call to ftell> ftell (1, 2)
-
-%% test/octave.test/io/ftell-3.m
 %!error ftell ("foo")
 
-%% test/octave.test/io/fseek-1.m
 %!error <Invalid call to fseek> fseek ()
-
-%% test/octave.test/io/fseek-2.m
 %!error <Invalid call to fseek> fseek (1, 0, SEEK_SET, 1)
-
-%% test/octave.test/io/fseek-3.m
 %!error fseek ("foo", 0, SEEK_SET)
 
-%% test/octave.test/io/frewind-1.m
 %!error <Invalid call to frewind> frewind ()
-
-%% test/octave.test/io/frewind-2.m
 %!error <Invalid call to frewind> frewind (1, 2)
-
-%% test/octave.test/io/frewind-3.m
 %!error frewind ("foo")
 
diff --git a/test/jit.tst b/test/jit.tst
new file mode 100644
--- /dev/null
+++ b/test/jit.tst
@@ -0,0 +1,431 @@
+## Copyright (C) 2012 Max Brister
+## 
+## This file is part of Octave.
+## 
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 3 of the License, or (at your
+## option) any later version.
+## 
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
+## 
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## Author: Max Brister <max@2bass.com>
+
+## Turn on JIT and set defaults before running tests
+%!testif HAVE_LLVM
+%! global __old_jit_enable__;
+%! global __old_jit_startcnt__;
+%! __old_jit_enable__ = jit_enable (true);
+%! __old_jit_startcnt__ = jit_startcnt (1000);
+
+## Test some simple cases that compile.
+
+%!testif HAVE_LLVM
+%! for i=1:1e6
+%!   if (i < 5)
+%!     break;
+%!   else
+%!     break;
+%!   endif
+%! endfor
+%! assert (i, 1);
+
+%!testif HAVE_LLVM
+%! while (1)
+%!   if (1)
+%!     break;
+%!   else
+%!     break;
+%!   endif
+%! endwhile
+
+%!testif HAVE_LLVM
+%! for i=1:1e6
+%!   if (i == 100)
+%!     break;
+%!   endif
+%! endfor
+%! assert (i, 100);
+
+## Also test parfor keyword
+%!testif HAVE_LLVM
+%! parfor i=1:1e6
+%!   if (i == 100)
+%!     break;
+%!   endif
+%! endparfor
+%! assert (i, 100);
+
+%!testif HAVE_LLVM
+%! inc = 1e-5;
+%! result = 0;
+%! for ii = 0:inc:1
+%!   result = result + inc * (1/3 * ii * ii);
+%! endfor
+%! assert (abs (result - 1/9) < 1e-5);
+
+%!testif HAVE_LLVM
+%! inc = 1e-5;
+%! result = 0;
+%! for ii = 0:inc:1
+%!   ## the ^ operator's result is complex
+%!   result = result + inc * (1/3 * ii ^ 2);
+%! endfor
+%! assert (abs (result - 1/9) < 1e-5);
+
+%!testif HAVE_LLVM
+%! temp = 1+1i;
+%! nan = NaN;
+%! while (1)
+%!   temp = temp - 1i;
+%!   temp = temp * nan;
+%!   break;
+%! endwhile
+%! assert (imag (temp), 0);
+
+%!testif HAVE_LLVM
+%! temp = 1+1i;
+%! nan = NaN+1i;
+%! while (1)
+%!   nan = nan - 1i;
+%!   temp = temp - 1i;
+%!   temp = temp * nan;
+%!   break;
+%! endwhile
+%! assert (imag (temp), 0);
+
+%!testif HAVE_LLVM
+%! temp = 1+1i;
+%! while (1)
+%!   temp = temp * 5;
+%!   break;
+%! endwhile
+%! assert (temp, 5+5i);
+
+%!testif HAVE_LLVM
+%! nr = 1001;
+%! mat = zeros (1, nr);
+%! for i = 1:nr
+%!   mat(i) = i;
+%! endfor
+%! assert (mat == 1:nr);
+
+%!testif HAVE_LLVM
+%! nr = 1001;
+%! mat = 1:nr;
+%! mat(end) = 0; # force mat to a matrix
+%! total = 0;
+%! for i = 1:nr
+%!   total = mat(i) + total;
+%! endfor
+%! assert (sum (mat) == total);
+
+%!testif HAVE_LLVM
+%! nr = 1001;
+%! mat = [3 1 5];
+%! try
+%!   for i = 1:nr
+%!     if (i > 500)
+%!       result = mat(100);
+%!     else
+%!       result = i;
+%!     endif
+%!   endfor
+%! catch
+%! end_try_catch
+%! assert (result == 500);
+
+%!function result = gen_test (n)
+%!  result = double (rand (1, n) > .01);
+%!endfunction
+
+%!function z = vectorized (A, K)
+%!  temp = ones (1, K);
+%!  z = conv (A, temp);
+%!  z = z > K-1;
+%!  z = conv (z, temp);
+%!  z = z(K:end-K+1);
+%!  z = z >= 1;
+%!endfunction
+
+%!function z = loopy (A, K)
+%!  z = A;
+%!  n = numel (A);
+%!  counter = 0;
+%!  for ii=1:n
+%!    if (z(ii))
+%!      counter = counter + 1;
+%!    else
+%!      if (counter > 0 && counter < K)
+%!        z(ii-counter:ii-1) = 0;
+%!      endif
+%!      counter = 0;
+%!    endif
+%!  endfor
+%!
+%!  if (counter > 0 && counter < K)
+%!    z(end-counter+1:end) = 0;
+%!  endif
+%!endfunction
+
+%!testif HAVE_LLVM
+%! test_set = gen_test (10000);
+%! assert (all (vectorized (test_set, 3) == loopy (test_set, 3)));
+
+%!testif HAVE_LLVM
+%! niter = 1001;
+%! i = 0;
+%! while (i < niter)
+%!   i = i + 1;
+%! endwhile
+%! assert (i == niter);
+
+%!testif HAVE_LLVM
+%! niter = 1001;
+%! result = 0;
+%! m = [5 10];
+%! for i=1:niter
+%!   result = result + m(end);
+%! endfor
+%! assert (result == m(end) * niter);
+
+%!testif HAVE_LLVM
+%! ndim = 100;
+%! result = 0;
+%! m = zeros (ndim);
+%! m(:) = 1:ndim^2;
+%! i = 1;
+%! while (i <= ndim)
+%!   for j = 1:ndim
+%!     result = result + m(i, j);
+%!    endfor
+%!   i = i + 1;
+%! endwhile
+%! assert (result == sum (sum (m)));
+
+%!testif HAVE_LLVM
+%! ndim = 100;
+%! m = zeros (ndim);
+%! i = 1;
+%! while (i <= ndim)
+%!   for j = 1:ndim
+%!     m(i, j) = (j - 1) * ndim + i;
+%!   endfor
+%!   i = i + 1;
+%! endwhile
+%! m2 = zeros (ndim);
+%! m2(:) = 1:(ndim^2);
+%! assert (all (m == m2));
+
+%!testif HAVE_LLVM
+%! ndim = 2;
+%! m = zeros (ndim, ndim, ndim, ndim);
+%! result = 0;
+%! i0 = 1;
+%! while (i0 <= ndim)
+%!   for i1 = 1:ndim
+%!     for i2 = 1:ndim
+%!       for i3 = 1:ndim
+%!         m(i0, i1, i2, i3) = 1;
+%!         m(i0, i1, i2, i3, 1, 1, 1, 1, 1, 1) = 1;
+%!         result = result + m(i0, i1, i2, i3);
+%!       endfor
+%!     endfor
+%!   endfor
+%!   i0 = i0 + 1;
+%! endwhile
+%! expected = ones (ndim, ndim, ndim, ndim);
+%! assert (all (m == expected));
+%! assert (result == sum (expected (:)));
+
+%!function test_divide ()
+%! state = warning ("query", "Octave:divide-by-zero").state;
+%! unwind_protect
+%!   warning ("error", "Octave:divide-by-zero");
+%!   for i=1:1e5
+%!     a = 1;
+%!     a / 0;
+%!   endfor
+%! unwind_protect_cleanup
+%!   warning (state, "Octave:divide-by-zero");
+%! end_unwind_protect
+%!endfunction
+
+%!testif HAVE_LLVM
+%! lasterr ("");
+%! try
+%!   test_divide ();
+%! end_try_catch
+%! assert (strcmp (lasterr (), "division by zero"));
+
+%!testif HAVE_LLVM
+%! while (1)
+%!   a = 0;
+%!   result = a / 1;
+%!   break;
+%! endwhile
+%! assert (result, 0);
+
+%!testif HAVE_LLVM
+%! m = zeros (2, 1001);
+%! for i=1:1001
+%!   m(end, i) = i;
+%!   m(end - 1, end - i + 1) = i;
+%! endfor
+%! m2 = zeros (2, 1001);
+%! m2(1, :) = fliplr (1:1001);
+%! m2(2, :) = 1:1001;
+%! assert (m, m2);
+
+%!testif HAVE_LLVM
+%! m = [1 2 3];
+%! for i=1:1001
+%!   m = sin (m);
+%!   break;
+%! endfor
+%! assert (m == sin ([1  2 3]));
+
+%!testif HAVE_LLVM
+%! i = 0;
+%! while i < 10
+%!   i += 1;
+%! endwhile
+%! assert (i == 10);
+
+%!testif HAVE_LLVM
+%! i = 0;
+%! while i < 10
+%!   a = ++i;
+%! endwhile
+%! assert (i == 10);
+%! assert (a == 10);
+%!testif HAVE_LLVM
+%! i = 0;
+%! while i < 10
+%!   a = i++;
+%! endwhile
+%! assert (i == 10);
+%! assert (a == 9);
+
+%!testif HAVE_LLVM
+%! num = 2;
+%! a = zeros (1, num);
+%! i = 1;
+%! while i <= num
+%!   a(i) = norm (eye (i));
+%!   ++i;
+%! endwhile
+%! assert (a, ones (1, num));
+
+%!function test_compute_idom ()
+%! while (li <= length (l1) && si <= length (s1))
+%!   if (l1 (li) < s1 (si))
+%!     if (li == si)
+%!       break;
+%!     endif;
+%!     li++;
+%!   else
+%!     si++;
+%!   endif;
+%! endwhile
+
+%!testif HAVE_LLVM
+%! lasterr ("");
+%! try
+%!   test_compute_idom ();
+%! end_try_catch
+%! assert (! isempty (lasterr ()));
+
+%!function x = test_overload (a)
+%!  while (1)
+%!    x = a;
+%!    break;
+%!  endwhile
+%!endfunction
+
+%!testif HAVE_LLVM
+%! assert (test_overload (1), 1);
+%! assert (test_overload ([1 2]), [1 2]);
+
+%!function a = bubble (a = [3 2 1])
+%!  swapped = 1;
+%!  n = length (a);
+%!  while (swapped)
+%!    swapped = 0;
+%!    for i = 1:n-1
+%!      if (a(i) > a(i + 1))
+%!        swapped = 1;
+%!        temp = a(i);
+%!        a(i) = a(i + 1);
+%!        a(i + 1) = temp;
+%!      endif
+%!    endfor
+%!  endwhile
+%!endfunction
+
+%!testif HAVE_LLVM
+%! assert (bubble (), [1 2 3]);
+
+%!testif HAVE_LLVM
+%! a = 0;
+%! b = 1;
+%! for i=1:1e3
+%!   for j=1:2
+%!     a = a + b;
+%!   endfor
+%! endfor
+%! assert (a, 2000);
+%! assert (b, 1);
+
+%!testif HAVE_LLVM
+%! a = [1+1i 1+2i];
+%! b = 0;
+%! while (1)
+%!   b = a(1);
+%!   break;
+%! endwhile
+%! assert (b, a(1));
+
+%!function test_undef ()
+%!  for i=1:1e7
+%!    XXX;
+%!  endfor
+%!endfunction
+
+%!testif HAVE_LLVM
+%! lasterr ("");
+%! try
+%!   test_undef ();
+%! end_try_catch
+%! assert (strncmp (lasterr (), "'XXX' undefined near", 20));
+
+%!shared id
+%! id = @(x) x;
+
+%!testif HAVE_LLVM
+%! assert (id (1), 1);
+%! assert (id (1+1i), 1+1i);
+%! assert (id (1, 2), 1);
+
+%!testif HAVE_LLVM
+%! lasterr ("");
+%! try
+%!   id ();
+%! end_try_catch
+%! assert (strncmp (lasterr (), "'x' undefined near", 18));
+
+## Restore JIT settings
+%!testif HAVE_LLVM
+%! global __old_jit_enable__;
+%! global __old_jit_startcnt__;
+%! jit_enable (__old_jit_enable__);
+%! jit_startcnt (__old_jit_startcnt__);
+%! clear -g __old_jit_enable__ __old_jit_startcnt__;
+
diff --git a/test/line-continue.tst b/test/line-continue.tst
--- a/test/line-continue.tst
+++ b/test/line-continue.tst
@@ -66,15 +66,19 @@
 %! assert (y, x);
 
 %!test
 %! x = [1 ,...
 %! 2];
 %! y = [1,2];
 %! assert (y, x);
 
-%% test/oc tave.test/contin/contin-16.m
 %!test
 %! x = [ 1 , ...
 %! 2];
 %! y = [1,2];
 %! assert  (y, x);
 
+%!test
+%! x = [ 1 , ...anything after the ... is ignored
+%! 2];
+%! y = [1,2];
+%! assert  (y, x);
diff --git a/test/nest/varg_nest2.m b/test/nest/varg_nest2.m
--- a/test/nest/varg_nest2.m
+++ b/test/nest/varg_nest2.m
@@ -1,14 +1,14 @@
 function x = varg_nest2
   [a, b] = f;
   x = a;
 
   if nargout == 1
     x = a;
   endif
 
-  function a, b = f
+  function [a, b] = f
     if nargout == 2
       a = b = 5;
     endif
   endfunction
 endfunction
diff --git a/test/parser.tst b/test/parser.tst
--- a/test/parser.tst
+++ b/test/parser.tst
@@ -30,227 +30,239 @@
 
 ## Tests for operator precedence as documented in section 8.8 of manual
 ## There are 13 levels of precedence from "parentheses and indexing" (highest)
 ## down to "statement operators" (lowest).
 ##
 ## Level 13 (parentheses and indexing)
 ## Overrides all other levels
 %!test
-%!  a.b = 1;
-%!  assert (a. b++, 1)
-%!  assert (a.b, 2)
-%!  clear a;
-%!  a.b = [0 1];
-%!  b = 2;
-%!  assert (a.b', [0;1])
-%!  assert (!a .b, logical ([1 0]))
-%!  assert (3*a .b, [0 3])
-%!  assert (a. b-1, [-1 0])
-%!  assert (a. b:3, 0:3)
-%!  assert (a. b>0.5, logical ([0 1]))
-%!  assert (a. b&0, logical ([0 0]))
-%!  assert (a. b|0, logical ([0 1]))
-%!  a.b = [1 2];
-%!  assert (a. b&&0, false)
-%!  assert (a. b||0, true)
-%!  a.b += a. b*2;
-%!  assert (a.b, [3 6])
+%! a.b = 1;
+%! assert (a. b++, 1);
+%! assert (a.b, 2);
+%! clear a;
+%! a.b = [0 1];
+%! b = 2;
+%! assert (a.b', [0;1]);
+%! assert (!a .b, logical ([1 0]));
+%! assert (3*a .b, [0 3]);
+%! assert (a. b-1, [-1 0]);
+%! assert (a. b:3, 0:3);
+%! assert (a. b>0.5, logical ([0 1]));
+%! assert (a. b&0, logical ([0 0]));
+%! assert (a. b|0, logical ([0 1]));
+%! a.b = [1 2];
+%! assert (a. b&&0, false);
+%! assert (a. b||0, true);
+%! a.b += a. b*2;
+%! assert (a.b, [3 6]);
 ## Level 12 (postfix increment and decrement)
 %!test
-%!  a = [3 5];
-%!  assert (2.^a ++, [8 32])
-%!  assert (a, [4 6])
-%!  assert (a--', [4; 6])
-%!  assert (a, [3 5])
-%!  a = 0;
-%!  assert (!a --, true)
-%!  assert (-a ++, 1)
-%!  assert (3*a ++, 0)
-%!  assert (a++-2, -1)
-%!  assert (1:a ++, 1:2)
-%!  assert (4>a++, true)
-%!  a = [0 -1];
-%!  assert ([1 1] & a++, logical ([0 1]))
-%!  assert ([0 0] | a++, logical ([1 0]))
-%!  a = 0;
-%!  assert (1 && a ++, false)
-%!  assert (0 || a --, true)
-%!  a = 5; b = 2;
-%!  b +=a ++;
-%!  assert (b, 7)
+%! a = [3 5];
+%! assert (2.^a ++, [8 32]);
+%! assert (a, [4 6]);
+%! assert (a--', [4; 6]);
+%! assert (a, [3 5]);
+%! a = 0;
+%! assert (!a --, true);
+%! assert (-a ++, 1);
+%! assert (3*a ++, 0);
+%! assert (a++-2, -1);
+%! assert (1:a ++, 1:2);
+%! assert (4>a++, true);
+%! a = [0 -1];
+%! assert ([1 1] & a++, logical ([0 1]));
+%! assert ([0 0] | a++, logical ([1 0]));
+%! a = 0;
+%! assert (1 && a ++, false);
+%! assert (0 || a --, true);
+%! a = 5; b = 2;
+%! b +=a ++;
+%! assert (b, 7);
 
 ## Level 11 (transpose and exponentiation)
 %!test
-%!  assert (-2 ^2, -4)
-%!  assert (!0 ^0, false)
-%!  assert (2*3 ^2, 18)
-%!  assert (2+3 ^2, 11)
-%!  assert ([1:10](1:2 ^2), [1 2 3 4])
-%!  assert (3>2 ^2, false)
-%!  assert (1&0 ^0, true)
-%!  assert (0|0 ^0, true)
-%!  assert (1&&0 ^0, true)
-%!  assert (0||0 ^0, true)
-%!  a = 3;
-%!  a *= 0 ^0;
-%!  assert (a, 3)
+%! assert (-2 ^2, -4);
+%! assert (!0 ^0, false);
+%! assert (2*3 ^2, 18);
+%! assert (2+3 ^2, 11);
+%! assert ([1:10](1:2 ^2), [1 2 3 4]);
+%! assert (3>2 ^2, false);
+%! assert (1&0 ^0, true);
+%! assert (0|0 ^0, true);
+%! assert (1&&0 ^0, true);
+%! assert (0||0 ^0, true);
+%! a = 3;
+%! a *= 0 ^0;
+%! assert (a, 3);
 ## Level 10 (unary plus/minus, prefix increment/decrement, not)
 %!test
-%!  a = 2;
-%!  assert (++ a*3, 9)
-%!  assert (-- a-2, 0)
-%!  assert (a, 2)
-%!  assert (! a-2, -2)
-%!  assert ([1:10](++ a:5), 3:5)
-%!  a = [1 0];
-%!  assert (! a>=[1 0], [false true])
-%!  a = 0;
-%!  assert (++ a&1, true)
-%!  assert (-- a|0, false)
-%!  assert (-- a&&1, true)
-%!  assert (++ a||0, false)
-%!  a = 3;
-%!  a *= ++a;
-%!  assert (a, 16)
+%! a = 2;
+%! assert (++ a*3, 9);
+%! assert (-- a-2, 0);
+%! assert (a, 2);
+%! assert (! a-2, -2);
+%! assert ([1:10](++ a:5), 3:5);
+%! a = [1 0];
+%! assert (! a>=[1 0], [false true]);
+%! a = 0;
+%! assert (++ a&1, true);
+%! assert (-- a|0, false);
+%! assert (-- a&&1, true);
+%! assert (++ a||0, false);
+%! a = 3;
+%! a *= ++a;
+%! assert (a, 16);
 ## Level 9 (multiply, divide)
 %!test
-%!  assert (3+4 * 5, 23)
-%!  assert (5 * 1:6, [5 6])
-%!  assert (3>1 * 5, false)
-%!  assert (1&1 * 0, false)
-%!  assert (1|1 * 0, true)
-%!  assert (1&&1 * 0, false)
-%!  assert (1||1 * 0, true)
-%!  a = 3;
-%!  a /= a * 2;
-%!  assert (a, 0.5)
+%! assert (3+4 * 5, 23);
+%! assert (5 * 1:6, [5 6]);
+%! assert (3>1 * 5, false);
+%! assert (1&1 * 0, false);
+%! assert (1|1 * 0, true);
+%! assert (1&&1 * 0, false);
+%! assert (1||1 * 0, true);
+%! a = 3;
+%! a /= a * 2;
+%! assert (a, 0.5);
 ## Level 8 (add, subtract)
 %!test
-%!  assert ([2 + 1:6], 3:6)
-%!  assert (3>1 + 5, false)
-%!  assert (1&1 - 1, false)
-%!  assert (0|1 - 2, true)
-%!  assert (1&&1 - 1, false)
-%!  assert (0||1 - 2, true)
-%!  a = 3;
-%!  a *= 1 + 1;
-%!  assert (a, 6)
+%! assert ([2 + 1:6], 3:6);
+%! assert (3>1 + 5, false);
+%! assert (1&1 - 1, false);
+%! assert (0|1 - 2, true);
+%! assert (1&&1 - 1, false);
+%! assert (0||1 - 2, true);
+%! a = 3;
+%! a *= 1 + 1;
+%! assert (a, 6);
 ## Level 7 (colon)
 %!test
-%!  assert (5:-1: 3>4, [true false false])
-%!  assert (1: 3&1, [true true true])
-%!  assert (1: 3|0, [true true true])
-%!  assert (-1: 3&&1, false)
-%!  assert (-1: 3||0, false)
-%!  a = [1:3];
-%!  a += 3 : 5;
-%!  assert (a, [4 6 8])
+%! assert (5:-1: 3>4, [true false false]);
+%! assert (1: 3&1, [true true true]);
+%! assert (1: 3|0, [true true true]);
+%! assert (-1: 3&&1, false);
+%! assert (-1: 3||0, false);
+%! a = [1:3];
+%! a += 3 : 5;
+%! assert (a, [4 6 8]);
 ## Level 6 (relational)
 %!test
-%!  assert (0 == -1&0, false)
-%!  assert (1 == -1|0, false)
-%!  assert (0 == -1&&0, false)
-%!  assert (1 == -1||0, false)
-%!  a = 2;
-%!  a *= 3 > 1;
-%!  assert (a, 2)
+%! assert (0 == -1&0, false);
+%! assert (1 == -1|0, false);
+%! assert (0 == -1&&0, false);
+%! assert (1 == -1||0, false);
+%! a = 2;
+%! a *= 3 > 1;
+%! assert (a, 2);
 ## Level 5 (element-wise and)
 %!test
-%!  assert (0 & 1|1, true)
-%!  assert ([0 1] & 1&&1, false)
-%!  assert (0 & 1||1, true)
-%!  a = 2;
-%!  a *= 3 & 1;
-%!  assert (a, 2)
+%! assert (0 & 1|1, true);
+%! assert ([0 1] & 1&&1, false);
+%! assert (0 & 1||1, true);
+%! a = 2;
+%! a *= 3 & 1;
+%! assert (a, 2);
 ## Level 4 (element-wise or)
 %!test
-%!  assert ([0 1] | 1&&0, false)
-%!  assert ([0 1] | 1||0, true)
-%!  a = 2;
-%!  a *= 0 | 1;
-%!  assert (a, 2)
+%! assert ([0 1] | 1&&0, false);
+%! assert ([0 1] | 1||0, true);
+%! a = 2;
+%! a *= 0 | 1;
+%! assert (a, 2);
 ## Level 3 (logical and)
 %!test
-%!  assert (0 && 1||1, true)
-%!  a = 2;
-%!  a *= 3 && 1;
-%!  assert (a, 2)
+%! assert (0 && 1||1, true);
+%! a = 2;
+%! a *= 3 && 1;
+%! assert (a, 2);
 ## Level 2 (logical or)
 %!test
-%!  a = 2;
-%!  a *= 0 || 1;
-%!  assert (a, 2)
+%! a = 2;
+%! a *= 0 || 1;
+%! assert (a, 2);
 
 ## Tests for operator precedence within each level where ordering should
 ## be left to right except for postfix and assignment operators.
 
 ## Level 13 (parentheses and indexing)
 %!test
-%!  a.b1 = 2;
-%!  assert (a.(strcat('b','1'))++, 2)
-%!  assert (a.b1, 3)
-%!  b = {1 2 3 4 5};
-%!  assert (b{(a. b1 + 1)}, 4)
-%!  b = 1:5;
-%!  assert (b(a. b1 + 1), 4)
-%!  assert ([2 3].^2', [4; 9])
+%! a.b1 = 2;
+%! assert (a.(strcat('b','1'))++, 2);
+%! assert (a.b1, 3);
+%! b = {1 2 3 4 5};
+%! assert (b{(a. b1 + 1)}, 4);
+%! b = 1:5;
+%! assert (b(a. b1 + 1), 4);
+%! assert ([2 3].^2', [4; 9]);
 ## Level 12 (postfix increment and decrement)
 ## No tests possible since a++-- is not valid
 ## Level 11 (transpose and exponentiation)
-## Note: Exponentiation works left to right for compatibility with Matlab.
-%!  assert (2^3**2, 64)
-%!  assert ([2 3].^2.', [4;9])
-%!  assert ([2 3].'.^2, [4;9])
-%!  assert (3*4i'.', 0 - 12i)
-%!  assert (3*4i.'.', 0 + 12i)
+## Note: Exponentiation should be left-to-right, but Octave does right-to-left.
+##       See bug #33304.
+%!test
+%! assert (2^3**2, 64);
+%! assert ([2 3].^2.', [4;9]);
+%! assert ([2 3].'.^2, [4;9]);
+%! assert (3*4i'.', 0 - 12i);
+%! assert (3*4i.'.', 0 + 12i);
+%! assert (2^-4^3, (1/16)^3);
+%! assert (2^+4^3, 16^3);
+%! assert (2^~0^2, 4);
+
+## Note: Exponentiation should be left-to-right, but Octave does right-to-left.
+##       See bug #33304.
+
 ## Level 10 (unary plus/minus, prefix increment/decrement, not)
 %!test
-%!  assert (+-+1, -1)
-%!  a = -1;
-%!  assert (!++a, true)
-%!  assert (a, 0)
-%!  assert (-~a, -1)
-%!  assert (!~--a, true)
-%!  assert (a, -1)
+%! assert (+-+1, -1);
+%! a = -1;
+%! assert (!++a, true);
+%! assert (a, 0);
+%! assert (-~a, -1);
+%! assert (!~--a, true);
+%! assert (a, -1);
 ## Level 9 (multiply, divide)
 %!test
-%!  assert (3 * 4 / 5, 2.4)
-%!  assert (3 ./ 4 .* 5, 3.75)
-%!  assert (2 * 4 \ 6, 0.75)
-%!  assert (2 .\ 4 .* 6, 12)
+%! assert (3 * 4 / 5, 2.4);
+%! assert (3 ./ 4 .* 5, 3.75);
+%! assert (2 * 4 \ 6, 0.75);
+%! assert (2 .\ 4 .* 6, 12);
 ## Level 8 (add, subtract)
 %!test
-%!  assert (-3 - 4 + 1 + 3 * 2, 0)
+%! assert (-3 - 4 + 1 + 3 * 2, 0);
 ## Level 7 (colon)
-## No tests possible because colon operator can't be combined with second colon operator
+## No tests possible because colon operator can't be combined
+## with second colon operator.
 ## Level 6 (relational)
 %!test
-%!  assert (0 < 1 <= 0.5 == 0 >= 0.5 > 0, true)
-%!  assert (1 < 1 == 0 != 0, true)
-%!  assert (1 < 1 == 0 ~= 0, true)
+%! assert (0 < 1 <= 0.5 == 0 >= 0.5 > 0, true);
+%! assert (1 < 1 == 0 != 0, true);
+%! assert (1 < 1 == 0 ~= 0, true);
 ## Level 5 (element-wise and)
-## No tests possible.  Only one operator (&) at this precedence level and operation is associative.
+## No tests possible.  Only one operator (&) at this precedence level
+## and operation is associative.
 ## Level 4 (element-wise or)
-## No tests possible.  Only one operator (|) at this precedence level and operation is associative.
+## No tests possible.  Only one operator (|) at this precedence level
+## and operation is associative.
 ## Level 3 (logical and)
 %!test
-%!  a = 1;
-%!  assert (1 && 0 && ++a, false)
-%!  assert (a, 1)
+%! a = 1;
+%! assert (1 && 0 && ++a, false);
+%! assert (a, 1);
 ## Level 2 (logical or)
 %!test
-%!  a = 1;
-%!  assert (0 || 1 || ++a, true)
-%!  assert (a, 1)
+%! a = 1;
+%! assert (0 || 1 || ++a, true);
+%! assert (a, 1);
 ## Level 1 (assignment)
 %!test
 %! a = 2; b = 5; c = 7;
-%! assert (a += b *= c += 1, 42)
-%! assert (b == 40 && c == 8)
+%! assert (a += b *= c += 1, 42);
+%! assert (b == 40 && c == 8);
 
 ## Test creation of anonymous functions
 
 %!test
 %! af_in_cell = {@(x) [1 2]};
 %! assert (af_in_cell{1}(), [1, 2]);
 
 %!test
diff --git a/test/prefer.tst b/test/prefer.tst
--- a/test/prefer.tst
+++ b/test/prefer.tst
@@ -11,217 +11,187 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/prefer/prefer-1.m
 %!test
 %! m = [3 2];
 %! assert (all (m == (3:-1:2)));
 
-%% test/octave.test/prefer/prefer-2.m
 %!test
 %! m = [3,
 %! 2];
 %! assert (all (m == (3:-1:2)'));
 
-%% test/octave.test/prefer/prefer-3.m
 %!test
 %! a = 2;
 %! assert ([a - 1], 1);
 
-%% test/octave.test/prefer/prefer-4.m
 %!test
 %! m = [3,2];
 %! fail ("[m ']");
 
-%% test/octave.test/prefer/prefer-5.m
 %!assert (all ([3 2] == (3:-1:2)));
 
-%% test/octave.test/prefer/prefer-6.m
 %!assert (all ([3, 2] == (3:-1:2)));
 
-%% test/octave.test/prefer/prefer-7.m
 %!test
 %! m = [3,2];
 %! assert (all ([m (1)] == (3:-1:1)));
 
-%% test/octave.test/prefer/prefer-8.m
 %!test
 %! m = [3,2];
 %! assert ([m(1)],3);
 
-%% test/octave.test/prefer/prefer-10.m
 %!test
 %! a = 2;
 %! assert ([a- 1], 1);
 
-%% test/octave.test/prefer/prefer-11.m
 %!test
 %! a = 1;
 %! assert (all ([a -1] == (1:-2:-1)));
 
-%% test/octave.test/prefer/prefer-12.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("off", "Octave:str-to-num");
 %! assert ("d" + 0, 100);
 %! warning (wsn.state, "Octave:str-to-num");
 
-%% test/octave.test/prefer/prefer-13.m
 %!test
 %! wsn = warning ("query", "Octave:str-to-num");
 %! warning ("on", "Octave:str-to-num");
 %! fail ("'d' + 0", "warning");
 %! warning (wsn.state, "Octave:str-to-num");
 
-%% test/octave.test/prefer/prefer-14.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("off", "Ocave:imag-to-real");
 %! assert (eye (1+i), 1);
 %! warning (wir.state, "Ocave:imag-to-real");
 
-%% test/octave.test/prefer/prefer-15.m
 %!test
 %! wir = warning ("query", "Ocave:imag-to-real");
 %! warning ("on", "Ocave:imag-to-real");
 %! fail ("eye (1+i)", "warning");
 %! warning (wir.state, "Ocave:imag-to-real");
 
-%% test/octave.test/prefer/prefer-17.m
 %!test
 %! wrre = warning ("query", "Octave:resize-on-range-error");
 %! warning ("off", "Octave:resize-on-range-error");
 %! clear a;
 %! a(2) = 1; a(3) = 2;
 %! assert (all (a == [0,1,2]));
 %! warning (wrre.state, "Octave:resize-on-range-error");
 
-%% test/octave.test/prefer/prefer-18.m
 %!test
 %! clear a;
 %! a(1) = 1; a(2) = 2;
 %! assert (all (a == [1,2]));
 
-%% test/octave.test/prefer/prefer-21.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (0);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[]")));
 %! assert (isempty (findstr (b{1} ,"[](0x0)")));
 %! print_empty_dimensions (ped);
 
-%% test/octave.test/prefer/prefer-22.m
 %!test
 %! ped = print_empty_dimensions ();
 %! print_empty_dimensions (1);
 %! a = cell (1, 1);
 %! b = type ("-q", "a");
 %! assert (!isempty (findstr (b{1}, "[](0x0)")));
 %! print_empty_dimensions (ped);
 
-%% test/octave.test/prefer/prefer-23.m
 %!assert (all (size (inv ([])) == [0, 0]));
 
-%% test/octave.test/prefer/prefer-24.m
 %!assert (all (svd ([]) == zeros (0, 1)));
 
-%% test/octave.test/prefer/prefer-27.m
 %!test
 %! sp = save_precision ();
 %! save_precision (1);
 %! x = pi;
 %! nm = tmpnam ();
 %! save ("-text", nm, "x");
 %! clear x;
 %! load (nm);
 %! unlink (nm);
 %! assert (x,3);
 %! save_precision (sp);
 
-%% test/octave.test/prefer/prefer-28.m
 %!test
 %! sp = save_precision ();
 %! save_precision (5);
 %! x = pi;
 %! nm = tmpnam ();
 %! save ("-text", nm, "x");
 %! clear x;
 %! load (nm);
 %! unlink (nm);
 %! assert (x, 3.1416);
 %! save_precision (sp);
 
 %% FIXME: How to capture standard output for comparison?
-%% test/octave.test/prefer/prefer-29.m
 %!function f ()
 %! 1
 %!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (0);
 %! f
 %! assert (??);
 %! silent_functions (sf);
 
 %% FIXME: Same problem as above!!!
-%% test/octave.test/prefer/prefer-30.m
 %!function f ()
 %! 1
 %!endfunction
 %!#test
 %! sf = silent_functions ();
 %! silent_functions (1);
 %! f
 %! assert (??);
 %! silent_functions (sf);
 
-%% test/octave.test/prefer/prefer-32.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("on", "Octave:neg-dim-as-zero");
 %! fail ("eye (-1) == []", "warning");
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
-%% test/octave.test/prefer/prefer-33.m
 %!test
 %! wndz = warning ("query", "Octave:neg-dim-as-zero");
 %! warning ("off", "Octave:neg-dim-as-zero");
 %! assert (all (size (eye (-1)) == [0, 0]));
 %! warning (wndz.state, "Octave:neg-dim-as-zero");
 
-%% test/octave.test/prefer/prefer-34.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("off", "Octave:assign-as-truth-value");
 %! if (x = 1) 1; endif
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
-%% test/octave.test/prefer/prefer-35.m
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("on", "Octave:assign-as-truth-value");
 %! fail ("if (x = 1) 1; endif", "warning");
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
-%% test/octave.test/prefer/prefer-38.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("off", "Octave:divide-by-zero");
 %! assert (isinf (1/0));
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
-%% test/octave.test/prefer/prefer-39.m
 %!test
 %! wdbz = warning ("query", "Octave:divide-by-zero");
 %! warning ("on", "Octave:divide-by-zero");
 %! a = 1;
 %! b = 0;
 %! fail ("isinf (a/b);", "warning")
 %! warning (wdbz.state, "Octave:divide-by-zero");
 
diff --git a/test/recursion.tst b/test/recursion.tst
--- a/test/recursion.tst
+++ b/test/recursion.tst
@@ -11,29 +11,27 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/recursion/recursion-1.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = x * f (x-1);
 %!  endif
 %!endfunction
 %!
 %!assert (f (5), 120)
 
-%% test/octave.test/recursion/recursion-2.m
 %!function y = f (x)
 %!  if (x == 1)
 %!    y = x;
 %!    return;
 %!  else
 %!    y = f (x-1) * x;
 %!  endif
 %!endfunction
diff --git a/test/return.tst b/test/return.tst
--- a/test/return.tst
+++ b/test/return.tst
@@ -11,21 +11,19 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/return/return-1.m
 %!function y = f ()
 %!  y = 1;
 %!  return;
 %!  y = 2;
 %!endfunction
 %!
 %!assert (f (), 1)
 
-%% test/octave.test/return/return-2.m
 %!test
 %! return;
 
diff --git a/test/slice.tst b/test/slice.tst
--- a/test/slice.tst
+++ b/test/slice.tst
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %!function x = set_slice (size, dim, slice)
 %!  x = ones (size);
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    case 31
 %!      x(slice, :, :) = 2;
diff --git a/test/struct.tst b/test/struct.tst
--- a/test/struct.tst
+++ b/test/struct.tst
@@ -11,105 +11,83 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/struct/fieldnames-1.m
 %!test
 %! s.a = 1;
 %! c = fieldnames (s);
 %! assert (iscell (c) && strcmp (c{1}, "a"));
 
-%% test/octave.test/struct/fieldnames-2.m
 %!test
 %! s.a.b = 1;
 %! c = fieldnames (s.a);
 %! assert (iscell (c) && strcmp (c{1}, "b"));
 
-%% test/octave.test/struct/fieldnames-3.m
 %!error <Invalid call to fieldnames> fieldnames ();
 
-%% test/octave.test/struct/fieldnames-4.m
 %!test
 %! s.a = 1;
 %! fail ("fieldnames (s, 1)", "Invalid call to fieldnames");
 
-%% test/octave.test/struct/fieldnames-5.m
 %!error fieldnames (1);
 
-%% test/octave.test/struct/isfield-1.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
 %! assert (isfield (s, "a"));
 
-%% test/octave.test/struct/isfield-2.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
 %! assert (!(isfield (s, "b")));
 
-%% test/octave.test/struct/isfield-3.m
 %!error <Invalid call to isfield> isfield ();
 
-%% test/octave.test/struct/isfield-4.m
 %!test
 %! s.aaa = 1;
 %! s.a = 2;
 %! fail ("isfield (s, 'a', 3);", "Invalid call to isfield");
 
-%% test/octave.test/struct/isfield-5.m
 %!assert (isfield (1, "m") == 0);
 
-%% test/octave.test/struct/isfield-6.m
 %!test
 %! s.a = 2;
 %! assert (isfield (s, 2) == 0);
 
-%% test/octave.test/struct/isstruct-1.m
 %!assert (!(isstruct (1)))
 
-%% test/octave.test/struct/isstruct-2.m
 %!assert (!(isstruct ([1, 2])))
 
-%% test/octave.test/struct/isstruct-3.m
 %!assert (!(isstruct ([])))
 
-%% test/octave.test/struct/isstruct-4.m
 %!assert (!(isstruct ([1, 2; 3, 4])))
 
-%% test/octave.test/struct/isstruct-5.m
 %!assert (!(isstruct ("t")))
 
-%% test/octave.test/struct/isstruct-6.m
 %!assert (!(isstruct ("test")))
 
-%% test/octave.test/struct/isstruct-7.m
 %!assert (!(isstruct (["test"; "ing"])))
 
 %!assert (!(isstruct ({1})))
 
-%% test/octave.test/struct/isstruct-8.m
 %!test
 %! s.a = 1;
 %! assert (isstruct (s));
 
-%% test/octave.test/struct/isstruct-9.m
 %!test
 %! s.a.b = 1;
 %! assert (isstruct (s.a));
 
-%% test/octave.test/struct/isstruct-10.m
 %!error <Invalid call to isstruct> isstruct ();
 
-%% test/octave.test/struct/isstruct-11.m
 %!test
 %! s.a = 1;
 %! fail ("isstruct (s, 1)", "Invalid call to isstruct");
 
 ## increment element of matrix stored in struct array field
 %!test
 %! a = struct ("c", {[1, 2, 3], [4, 5, 6], [7, 8, 9]});
 %! a(2).c(3)++;
diff --git a/test/switch.tst b/test/switch.tst
--- a/test/switch.tst
+++ b/test/switch.tst
@@ -11,91 +11,86 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/switch/switch-1.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %!
-%! switch 0 case 1 x = a; case 2 x = b; otherwise x = c; endswitch
-%! switch 1 case 1 y = a; case 2 y = b; otherwise y = c; endswitch
-%! switch 2 case 1 z = a; case 2 z = b; otherwise z = c; endswitch
-%! switch 3 case 1 p = a; case 2 p = b; otherwise p = c; endswitch
+%! ## "end" is part of test, check not using "endswitch"
+%! switch (0) case 1 x = a; case 2 x = b; otherwise x = c; end
+%! switch (1) case 1 y = a; case 2 y = b; otherwise y = c; endswitch
+%! switch (2) case 1 z = a; case 2 z = b; otherwise z = c; endswitch
+%! switch (3) case 1 p = a; case 2 p = b; otherwise p = c; endswitch
 %!
 %! assert (x == c && y == a && z == b && p == c);
 
-%% test/octave.test/switch/switch-2.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %!
 %! x = zeros (1, 4);
 %!
 %! k = 1;
 %!
 %! for i = 0:3
 %! switch (i)
 %!   case a
-%!    x(k) = a;
+%!     x(k) = a;
 %!   case b
-%!    x(k) = b;
+%!     x(k) = b;
 %!   otherwise
-%!    x(k) = c;
+%!     x(k) = c;
 %!   endswitch
 %!   k++;
 %! endfor
 %!
 %! assert (all (x == [3, 1, 2, 3]));
 
-%% test/octave.test/switch/switch-3.m
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %!
 %! x = zeros (1, 4);
 %!
 %! k = 1;
 %!
 %! for i = 0:3
 %!   switch (i)
-%!   case a
-%!    x(k) = a;
+%!     case a
+%!       x(k) = a;
 %!   endswitch
 %!   k++;
 %! endfor
 %!
 %! assert (all (x == [0, 1, 0, 0]));
 
 %!test
 %! a = 1;
 %!
-%! switch 1
-%! otherwise
-%!   a = 2;
+%! switch (1)
+%!   otherwise
+%!     a = 2;
 %! endswitch
 %!
 %! assert (a == 2);
 
 
-%% test/octave.test/switch/switch-4.m
 %!error <syntax error> eval ("switch endswitch")
 
-%% test/octave.test/switch/switch-5.m
 %!error <syntax error> eval ("switch case endswitch")
 
-%% test/octave.test/switch/switch-6.m
 %!error <syntax error> eval ("switch 1 default 1; endswitch")
 
 %% test parsing of single-quoted character string appearing immediately
 %% after a switch case
 %!test
 %! switch (1)
 %!   case 1
 %!     'foo';
diff --git a/test/system.tst b/test/system.tst
--- a/test/system.tst
+++ b/test/system.tst
@@ -11,70 +11,59 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/system/cputime-1.m
 %!test
 %! [t1, u1, s1] = cputime ();
 %! for i = 1:200
 %!   sin (i);
 %! endfor
 %! [t2, u2, s2] = cputime ();
 %! assert (t1, u1 + s1);
 %! assert (t2 == u2 + s2);
 %! assert (t2 >= t1);
 %! assert (u2 >= u2);
 %! assert (s2 >= s2);
 %!#assert (t1 == u1 + s1 && t2 == u2 + s2 && t2 >= t1 && u2 >= u2 && s2 >= s2);
 
-%% test/octave.test/system/tic-toc-1.m
 %!test
 %! tic ();
 %! sleep (2);
 %! assert (toc () > 0);
 
-%% test/octave.test/system/pause-1.m
 %!test
 %! pause (0);
 %! __printf_assert__ ("ok\n");
 %! assert (__prog_output_assert__ ("ok"));
 
-%% test/octave.test/system/pause-2.m
 %!error <Invalid call to pause> pause (1, 2)
 
-%% test/octave.test/system/sleep-1.m
 %!test
 %! sleep (0);
 %! __printf_assert__ ("ok\n");
 %! assert (__prog_output_assert__ ("ok"));
 
-%% test/octave.test/system/sleep-2.m
 %!error <Invalid call to sleep> sleep ()
 
-%% test/octave.test/system/sleep-3.m
 %!error <Invalid call to sleep> sleep (1, 2)
 
-%% test/octave.test/system/usleep-1.m
 %!test
 %! usleep (0);
 %! __printf_assert__ ("ok\n");
 %! assert (__prog_output_assert__ ("ok"));
 
-%% test/octave.test/system/usleep-2.m
 %!error <Invalid call to usleep> usleep ()
 
-%% test/octave.test/system/usleep-3.m
 %!error <Invalid call to usleep> usleep (1, 2)
 
-%% test/octave.test/system/rename-1.m
 %!test
 %! from = tmpnam ();
 %! to = tmpnam ();
 %! id = fopen (from, "wb");
 %! if (id > 0 && fclose (id) == 0)
 %!   [s, e] = stat (from);
 %!   if (! e)
 %!     if (rename (from, to) == 0)
@@ -83,76 +72,62 @@
 %!         [s, e] = stat (to);
 %!         assert (e == 0);
 %!         unlink (to);
 %!       endif
 %!     endif
 %!   endif
 %! endif
 
-%% test/octave.test/system/rename-2.m
 %!error <Invalid call to rename> rename ()
 
-%% test/octave.test/system/rename-3.m
 %!error <Invalid call to rename> rename ("foo", "bar", 1)
 
-%% test/octave.test/system/unlink-1.m
 %!test
 %! nm = tmpnam ();
 %! if ((id = fopen (nm, "wb")) > 0)
 %!   [s, err] = stat (nm);
 %!   if (! err && fclose (id) == 0 && unlink (nm) == 0)
 %!     [s, err] = stat (nm);
 %!     assert (err < 0);
 %!   endif
 %! endif
 
-%% test/octave.test/system/unlink-2.m
 %!error <Invalid call to unlink> unlink ()
 
-%% test/octave.test/system/unlink-3.m
 %!error <Invalid call to unlink> unlink ("foo", 1)
 
-%% test/octave.test/system/readdir-1.m
 %!test
 %! [files, status, msg] = readdir (filesep);
 %! assert (iscell (files) && status == 0 && strcmp (msg, ""));
 
-%% test/octave.test/system/readdir-2.m
 %!error <Invalid call to readdir> readdir ()
 
-%% test/octave.test/system/readdir-3.m
 %!error <Invalid call to readdir> readdir ("foo", 1)
 
-%% test/octave.test/system/mk-rm-dir-1.m
 %!test
 %! nm = tmpnam ();
 %! e1 = mkdir (nm);
 %! [s2, e2] = stat (nm);
 %! e3 = rmdir (nm);
 %! [s4, e4] = stat (nm);
 %! assert ((e1 && strcmp (s2.modestr(1), "d") && e3 && e4 < 0));
 
-%% test/octave.test/system/mkdir-1.m
 %!error <Invalid call to mkdir> mkdir ()
 
-%% test/octave.test/system/mkdir-2.m
 %!error <Invalid call to mkdir> mkdir ("foo", 1, 2)
 
-%% test/octave.test/system/rmdir-1.m
 %!error <Invalid call to rmdir> rmdir ()
 
-%% test/octave.test/system/rmdir-2.m
 %!test
 %! crr = confirm_recursive_rmdir ();
 %! confirm_recursive_rmdir (0);
 %! assert (!rmdir ("foo", "s"));
 %! confirm_recursive_rmdir (crr);
 
-%% test/octave.test/system/umask-1.m
 %!test
 %! orig_umask = umask (0);
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s1 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %!
@@ -160,330 +135,259 @@
 %! nm = tmpnam ();
 %! id = fopen (nm, "wb");
 %! s2 = stat (nm);
 %! fclose (id);
 %! unlink (nm);
 %!
 %! assert (deblank (s1.modestr), "-rw-rw-rw-");
 %! assert (deblank (s2.modestr), "----------");
-%! # Restore original umask value
+%! ## Restore original umask value
 %! umask (orig_umask);
 
-%% test/octave.test/system/umask-2.m
 %!error <Invalid call to umask> umask ()
 
-%% test/octave.test/system/umask-3.m
 %!error <Invalid call to umask> umask (1, 2)
 
-%% test/octave.test/system/stat-1.m
 %!test
 %! [s, err, msg] = stat (filesep);
 %! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
-%% test/octave.test/system/stat-2.m
 %!error <Invalid call to stat> stat ()
 
-%% test/octave.test/system/stat-3.m
 %!error <Invalid call to stat> stat ("foo", 1)
 
-%% test/octave.test/system/lstat-1.m
 %!test
 %! [s, err, msg] = lstat (filesep);
 %! assert ((err == 0
 %! && isstruct (s)
 %! && isfield (s, "dev")
 %! && isfield (s, "ino")
 %! && isfield (s, "modestr")
 %! && isfield (s, "nlink")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "size")
 %! && isfield (s, "atime")
 %! && isfield (s, "mtime")
 %! && isfield (s, "ctime")
 %! && ischar (msg)));
 
-%% test/octave.test/system/lstat-2.m
 %!error <Invalid call to lstat> lstat ()
 
-%% test/octave.test/system/lstat-3.m
 %!error <Invalid call to lstat> lstat ("foo", 1)
 
-%% test/octave.test/system/glob-1.m
 %!assert (iscell (glob ([filesep "*"])))
 
-%% test/octave.test/system/glob-2.m
 %!error <Invalid call to glob> glob ()
 
-%% test/octave.test/system/glob-3.m
 %!error <Invalid call to glob> glob ("foo", 1)
 
-%% test/octave.test/system/fnmatch-1.m
 %!test
 %! string_fill_char = char (0);
 %! assert ((fnmatch ("a*a", {"aba"; "xxxba"; "aa"}) == [1; 0; 1]
 %! && fnmatch ({"a*a"; "b*b"}, "bob")
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"}) == [1; 0]
 %! && fnmatch ("x[0-5]*", {"x1"; "x6"; "x001"}) == [1; 0; 1]
 %! && fnmatch ("x???y", {"xabcy"; "xy"}) == [1; 0]));
 
-%% test/octave.test/system/fnmatch-2.m
 %!error <Invalid call to fnmatch> fnmatch ()
 
-%% test/octave.test/system/fnmatch-3.m
 %!error <Invalid call to fnmatch> fnmatch ("foo", "bar", 3)
 
-%% test/octave.test/system/file_in_path-1.m
 %!assert (ischar (file_in_path (path (), "date.m")))
 
-%% test/octave.test/system/file_in_path-2.m
 %!error <invalid option> file_in_path ("foo", "bar", 1)
 
-%% test/octave.test/system/file_in_path-3.m
 %!error <Invalid call to file_in_path> file_in_path ()
 
-%% test/octave.test/system/file_in_path-4.m
 %!error <Invalid call to file_in_path> file_in_path ("foo", "bar", "baz", "ooka")
 
-%% test/octave.test/system/tilde_expand-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwuid (getuid ());
 %! assert ((strcmp (x.dir, tilde_expand ("~"))
 %! && strcmp (x.dir, tilde_expand (sprintf ("~%s", x.name)))
 %! && strcmp ("foobar", tilde_expand ("foobar"))));
 
-%% test/octave.test/system/tilde_expand-2.m
 %!error <Invalid call to tilde_expand> tilde_expand ()
 
-%% test/octave.test/system/tilde_expand-3.m
 %!error <Invalid call to tilde_expand> tilde_expand ("str", 2)
 
-%% test/octave.test/system/getpgrp-1.m
 %!testif HAVE_GETPGRP
 %! assert (getpgrp () > 0);
 
-%% test/octave.test/system/getpgrp-2.m
 %!error <... getpgrp> getpgrp (1)
 
-%% test/octave.test/system/getpid-1.m
 %!assert (getpid () > 0)
 
-%% test/octave.test/system/getpid-2.m
 %!error <... getpid> getpid (1)
 
-%% test/octave.test/system/getppid-1.m
 %!testif HAVE_GETPPID
 %! assert (getppid () > 0);
 
-%% test/octave.test/system/getppid-2.m
 %!error <... getppid> getppid (1)
 
-%% test/octave.test/system/geteuid-1.m
 %!assert (geteuid () >= 0)
 
-%% test/octave.test/system/geteuid-2.m
 %!error <... geteuid> geteuid (1)
 
-%% test/octave.test/system/getuid-1.m
 %!assert (getuid () >= 0)
 
-%% test/octave.test/system/getuid-2.m
 %!error <... getuid> getuid (1)
 
-%% test/octave.test/system/getegid-1.m
 %!assert (getegid () >= 0)
 
-%% test/octave.test/system/getegid-2.m
 %!error <... getegid> getegid (1)
 
-%% test/octave.test/system/getgid-1.m
 %!assert (getgid () >= 0)
 
-%% test/octave.test/system/getgid-2.m
 %!error <... getgid> getgid (1)
 
-%% test/octave.test/system/getenv-1.m
 %!assert (getenv ("HOME"), tilde_expand ("~"))
 
-%% test/octave.test/system/getenv-2.m
 %!error <Invalid call to getenv> getenv ()
 
-%% test/octave.test/system/getenv-3.m
 %!error <Invalid call to getenv> getenv ("foo", 1)
 
-%% test/octave.test/system/getenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
 %! fail ("getenv (1)", "warning");
 %! warning (wns.state, "Octave:num-to-str");
 
-%% test/octave.test/system/putenv-1.m
 %!test
 %! putenv ("foobar", "baz");
 %! assert (getenv ("foobar"), "baz");
 
-%% test/octave.test/system/putenv-2.m
 %!error <Invalid call to putenv> putenv ()
 
-%% test/octave.test/system/putenv-3.m
 %!error <Invalid call to putenv> putenv ("foo", "bar", 1)
 
-%% test/octave.test/system/putenv-4.m
 %!test
 %! wns = warning ("query", "Octave:num-to-str");
 %! warning ("on", "Octave:num-to-str");
 %! fail ("putenv (1, 2)","warning");
 %! warning (wns.state, "Octave:num-to-str");
 
-%% test/octave.test/system/cd-1.m
 %!test
 %! xdir = pwd ();
 %! cd /
 %! d1 = pwd ();
 %! cd (xdir);
 %! if (ispc () && ! isunix ())
-%!   # should be a drive letter
+%!   ## should be a drive letter
 %!   assert (length (d1), 3);
 %!   assert (d1(2), ":");
 %!   assert (d1(3), "\\");
 %! else
 %!   assert ("/", d1);
 %! endif
 %! assert (pwd (), xdir);
 
-%% test/octave.test/system/cd-2.m
 %!error cd (1)
 
-%% test/octave.test/system/pwd-1.m
 %!assert (ischar (pwd ()))
 
-%% test/octave.test/system/getpwent-1.m
 %!testif HAVE_GETPWENT
 %! s = getpwent ();
 %! endpwent ();
 %! assert ((isstruct (s)
 %! && isfield (s, "name")
 %! && isfield (s, "passwd")
 %! && isfield (s, "uid")
 %! && isfield (s, "gid")
 %! && isfield (s, "gecos")
 %! && isfield (s, "dir")
 %! && isfield (s, "shell")));
 
-%% test/octave.test/system/getpwent-2.m
 %!error <Invalid call to getpwent> getpwent (1)
 
-%% test/octave.test/system/getpwuid-1.m
 %!testif HAVE_GETPWUID
 %! x = getpwent ();
 %! y = getpwuid (x.uid);
 %! endpwent ();
 %! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
-%% test/octave.test/system/getpwuid-2.m
 %!error <Invalid call to getpwuid> getpwuid ()
 
-%% test/octave.test/system/getpwuid-3.m
 %!error <Invalid call to getpwuid> getpwuid (1, 2)
 
-%% test/octave.test/system/getpwnam-1.m
 %!testif HAVE_GETPWNAM
 %! x = getpwent ();
 %! y = getpwnam (x.name);
 %! endpwent ();
 %! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
-%% test/octave.test/system/getpwnam-2.m
 %!error <Invalid call to getpwnam> getpwnam ()
 
-%% test/octave.test/system/getpwnam-3.m
 %!error <Invalid call to getpwnam> getpwnam ("foo", 1)
 
-%% test/octave.test/system/setpwent-1.m
 %!testif HAVE_SETPWENT
 %! x = getpwent ();
 %! setpwent ();
 %! y = getpwent ();
 %! endpwent ();
 %! assert (strcmp (x.name, y.name) && x.uid == y.uid && x.gid == y.gid);
 
-%% test/octave.test/system/setpwent-2.m
 %!error <Invalid call to setpwent> setpwent (1)
 
-%% test/octave.test/system/endpwent-1.m
 %!error <Invalid call to endpwent> endpwent (1)
 
-%% test/octave.test/system/getgrent-1.m
 %!testif HAVE_GETGRENT
 %! x = getgrent ();
 %! endgrent ();
 %! assert ((isstruct (x)
 %! && isfield (x, "name")
 %! && isfield (x, "passwd")
 %! && isfield (x, "gid")
 %! && isfield (x, "mem")));
 
-%% test/octave.test/system/getgrent-2.m
 %!error <Invalid call to getgrent> getgrent (1)
 
-%% test/octave.test/system/getgrgid-1.m
 %!testif HAVE_GETGRGID
 %! x = getgrent ();
 %! y = getgrgid (x.gid);
 %! endgrent ();
 %! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
-%% test/octave.test/system/getgrgid-2.m
 %!error <Invalid call to getgrgid> getgrgid ()
 
-%% test/octave.test/system/getgrgid-3.m
 %!error <Invalid call to getgrgid> getgrgid (1, 2)
 
-%% test/octave.test/system/getgrnam-1.m
 %!testif HAVE_GETGRNAM
 %! x = getgrent ();
 %! y = getgrnam (x.name);
 %! endgrent ();
 %! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
-%% test/octave.test/system/getgrnam-2.m
 %!error <Invalid call to getgrnam> getgrnam ()
 
-%% test/octave.test/system/getgrnam-3.m
 %!error <Invalid call to getgrnam> getgrnam ("foo", 1)
 
-%% test/octave.test/system/setgrent-1.m
 %!testif HAVE_SETGRENT
 %! x = getgrent ();
 %! setgrent ();
 %! y = getgrent ();
 %! endgrent ();
 %! assert (strcmp (x.name, y.name) && x.gid == y.gid);
 
-%% test/octave.test/system/setgrent-2.m
 %!error <Invalid call to setgrent> setgrent (1)
 
-%% test/octave.test/system/endgrent-1.m
 %!error <Invalid call to endgrent> endgrent (1)
 
-%% test/octave.test/system/isieee-1.m
 %!assert (isieee () == 1 || isieee () == 0)
 
-%% test/octave.test/system/octave_config_info-1.m
 %!assert (isstruct (octave_config_info ()))
 
-%% test/octave.test/system/getrusage-1.m
 %!assert (isstruct (getrusage ()))
 
diff --git a/test/try.tst b/test/try.tst
--- a/test/try.tst
+++ b/test/try.tst
@@ -11,129 +11,172 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/try/try-1.m
 %!test
 %! try
 %! catch
 %!   error ("Shoudn't get here");
-%! end_try_catch
+%! end  # "end" is part of test, check not using "end_try_catch"
 
-%% test/octave.test/try/try-2.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %! catch
 %! end_try_catch
 %! a = 1;
 %! assert (a,1);
 
-%% test/octave.test/try/try-3.m
 %!test
 %! clear x;
 %! try
 %!   clear a;
 %!   a;
 %!   x = 1;
 %! catch
 %! end_try_catch
 %! a = 2;
 %! assert (!exist ('x'));
 %! assert (a,2);
 
-%% test/octave.test/try/try-4.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %! catch
 %!   x = 1;
 %! end_try_catch
 %! assert (exist ('x'));
 
-%% test/octave.test/try/try-5.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   assert (lasterr()(1:13), "'a' undefined");
 %! end_try_catch
 %! assert (lasterr()(1:13), "'a' undefined");
 
-%% test/octave.test/try/try-6.m
 %!test
 %! try
 %!   error ("user-defined error");
 %! catch
 %!   assert (lasterr, "user-defined error");
 %! end_try_catch
 
-%% test/octave.test/try/try-7.m
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = cstrcat ("<", s, ">");
+%!  ms = ["<" s ">"];
 %!endfunction
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   assert (mangle (lasterr)(1:14), "<'a' undefined");
 %! end_try_catch
 
-%% test/octave.test/try/try-8.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
 %!     assert (lasterr()(1:13), "'a' undefined");
 %!   end_try_catch
 %!   clear b;
 %!   b;
 %!   error ("Shoudn't get here");
 %! catch
 %!   assert (lasterr()(1:13), "'b' undefined");
 %! end_try_catch
 
-%% test/octave.test/try/try-9.m
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   try
 %!     assert (lasterr()(1:13), "'a' undefined");
 %!     clear b;
 %!     b;
 %!     error ("Shoudn't get here");
 %!   catch
 %!     assert (lasterr()(1:13), "'b' undefined");
 %!   end_try_catch
 %! end_try_catch
 
-%% test/octave.test/try/try-10.m
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     error (cstrcat ("rethrow: ", lasterr));
+%!     error (["rethrow: " lasterr]);
 %!   end_try_catch
 %! catch
 %!   assert (lasterr()(1:22), "rethrow: 'a' undefined");
 %! end_try_catch
 
+%!test
+%! clear myerr;
+%! try
+%!   error ("user-defined error");
+%! catch myerr
+%!   assert (myerr.message, "user-defined error");
+%! end_try_catch
+
+%!test
+%! try
+%!   clear a;
+%!   error ("user-defined error");
+%! catch a=1;
+%!   assert (lasterr, "user-defined error");
+%!   assert (a, 1);
+%! end_try_catch
+
+%!test
+%! clear myerr1
+%! clear myerr2
+%! try
+%!   try
+%!     clear a;
+%!     a;
+%!   catch myerr1
+%!     error (myerr1);
+%!   end_try_catch
+%! catch myerr2
+%!   assert (myerr1.message, myerr2.message);
+%!   assert (myerr1.identifier, myerr2.identifier);
+%! end_try_catch
+
+%!test
+%! x = 1;
+%! try error ("foo"); catch x; assert (x.message, "foo"); end_try_catch
+
+%!test
+%! x = 1;
+%! try error ("foo"); catch x end_try_catch
+%! assert (x.message, "foo");
+
+%!test
+%! x = 1;
+%! try error ("foo"); catch, x; assert (x, 1); end_try_catch
+
+%!test
+%! x = 1;
+%! try error ("foo"); catch; x; assert (x, 1); end_try_catch
+
+%!test
+%! x = 1;
+%! try error ("foo"); catch
+%!   x; assert (x, 1); end_try_catch
diff --git a/test/unwind.tst b/test/unwind.tst
--- a/test/unwind.tst
+++ b/test/unwind.tst
@@ -11,38 +11,36 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/unwind/unwind-1.m
 %!function y = f (x)
 %!  global g;
 %!  save_g = g;
 %!  unwind_protect
 %!    g = 0;
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
 %!    y = [y, g];
 %!  unwind_protect_cleanup
 %!    g = save_g;
 %!    y = [y, g];
-%!  end_unwind_protect
+%!  end  # "end" is part of test, check not using "end_unwind_protect"
 %!endfunction
 %!
 %!test
 %! global g = -1;
 %! y = f ([3,4]);
 %! assert (y, [0,1,-1]);
 
-%% test/octave.test/unwind/unwind-2.m
 %!function y = f (x)
 %!  global g;
 %!  save_g = g;
 %!  unwind_protect
 %!    g = 0;
 %!    y = g;
 %!    [1,2;x];
 %!    g = 1;
diff --git a/test/while.tst b/test/while.tst
--- a/test/while.tst
+++ b/test/while.tst
@@ -11,57 +11,52 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-%% test/octave.test/while/while-1.m
 %!test
 %! i = 0;
 %! while (eye (2))
 %!   i++;
 %!   __printf_assert__ ("%d\n", i);
-%! endwhile
+%! end  # "end" is part of test, check not using "endwhile"
 %! assert (__prog_output_assert__ (""));
 
-%% test/octave.test/while/while-2.m
 %!test
 %! i = 5;
 %! while (--i)
 %!   __printf_assert__ ("%d", i);
 %! endwhile
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("4321"));
 
-%% test/octave.test/while/while-3.m
 %!test
 %! i = 5;
 %! while (i)
 %!   i--;
 %!   __printf_assert__ ("%d", i);
 %! endwhile
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("43210"));
 
-%% test/octave.test/while/while-4.m
 %!test
 %! i = 0;
 %! while (i++ < 20)
 %!   if (i > 2)
 %!     break;
 %!   endif
 %!   __printf_assert__ ("%d", i);
 %! endwhile
 %! __printf_assert__ ("\n");
 %! assert (__prog_output_assert__ ("12"));
 
-%% test/octave.test/while/while-5.m
 %!test
 %! i = 0;
 %! while (++i < 5)
 %!   if (i < 3)
 %!     continue;
 %!   endif
 %!   __printf_assert__ ("%d", i);
 %! endwhile
