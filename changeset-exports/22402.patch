# HG changeset patch
# User Rik <rik@octave.org>
# Date 1472494165 25200
#      Mon Aug 29 11:09:25 2016 -0700
# Node ID 4caa7b28d18347de79a4433e21649670e6f44339
# Parent  e748c6df991d3d1b9f686c31d9b74a84bb46fbff
maint: Style check C++ code in liboctave/

* Array-C.cc, Array-b.cc, Array-ch.cc, Array-d.cc, Array-f.cc, Array-fC.cc,
Array-i.cc, Array-idx-vec.cc, Array-s.cc, Array-str.cc, Array-util.cc,
Array-util.h, Array-voidp.cc, Array.cc, Array.h, CColVector.cc, CColVector.h,
CDiagMatrix.cc, CDiagMatrix.h, CMatrix.cc, CMatrix.h, CNDArray.cc, CNDArray.h,
CRowVector.cc, CRowVector.h, CSparse.cc, CSparse.h, DiagArray2.cc,
DiagArray2.h, MArray-C.cc, MArray-d.cc, MArray-f.cc, MArray-fC.cc, MArray-i.cc,
MArray-s.cc, MArray.cc, MArray.h, MDiagArray2.cc, MDiagArray2.h, MSparse-C.cc,
MSparse-d.cc, MSparse.cc, MSparse.h, Matrix.h, MatrixType.cc, MatrixType.h,
PermMatrix.cc, PermMatrix.h, Range.cc, Range.h, Sparse-C.cc, Sparse-b.cc,
Sparse-d.cc, Sparse.cc, Sparse.h, boolMatrix.cc, boolMatrix.h, boolNDArray.cc,
boolNDArray.h, boolSparse.cc, boolSparse.h, chMatrix.cc, chMatrix.h,
chNDArray.cc, chNDArray.h, dColVector.cc, dColVector.h, dDiagMatrix.cc,
dDiagMatrix.h, dMatrix.cc, dMatrix.h, dNDArray.cc, dNDArray.h, dRowVector.cc,
dRowVector.h, dSparse.cc, dSparse.h, dim-vector.cc, dim-vector.h,
fCColVector.cc, fCColVector.h, fCDiagMatrix.cc, fCDiagMatrix.h, fCMatrix.cc,
fCMatrix.h, fCNDArray.cc, fCNDArray.h, fCRowVector.cc, fCRowVector.h,
fColVector.cc, fColVector.h, fDiagMatrix.cc, fDiagMatrix.h, fMatrix.cc,
fMatrix.h, fNDArray.cc, fNDArray.h, fRowVector.cc, fRowVector.h, idx-vector.cc,
idx-vector.h, int16NDArray.cc, int16NDArray.h, int32NDArray.cc, int32NDArray.h,
int64NDArray.cc, int64NDArray.h, int8NDArray.cc, int8NDArray.h, intNDArray.cc,
intNDArray.h, uint16NDArray.cc, uint16NDArray.h, uint32NDArray.cc,
uint32NDArray.h, uint64NDArray.h, uint8NDArray.h, blaswrap.c, cquit.c,
f77-extern.cc, f77-fcn.c, f77-fcn.h, lo-error.c, lo-error.h, quit.cc, quit.h,
liboctave-build-info.h, liboctave-build-info.in.cc, CollocWt.cc, CollocWt.h,
DAE.h, DAEFunc.h, DAERT.h, DAERTFunc.h, DASPK.cc, DASPK.h, DASRT.cc, DASRT.h,
DASSL.cc, DASSL.h, DET.h, EIG.cc, EIG.h, LSODE.cc, LSODE.h, ODE.h, ODEFunc.h,
ODES.cc, ODES.h, ODESFunc.h, Quad.cc, Quad.h, aepbalance.cc, aepbalance.h,
base-dae.h, base-de.h, base-min.h, bsxfun-decl.h, bsxfun-defs.cc, bsxfun.h,
chol.cc, chol.h, eigs-base.cc, eigs-base.h, fEIG.cc, fEIG.h, gepbalance.cc,
gepbalance.h, gsvd.cc, gsvd.h, hess.cc, hess.h, lo-amos-proto.h,
lo-arpack-proto.h, lo-blas-proto.h, lo-fftpack-proto.h, lo-lapack-proto.h,
lo-mappers.cc, lo-mappers.h, lo-qrupdate-proto.h, lo-ranlib-proto.h,
lo-slatec-proto.h, lo-specfun.cc, lo-specfun.h, lu.cc, lu.h, oct-convn.cc,
oct-fftw.cc, oct-fftw.h, oct-norm.h, oct-rand.cc, oct-rand.h, oct-spparms.cc,
oct-spparms.h, qr.cc, qr.h, qrp.cc, qrp.h, randgamma.cc, randgamma.h,
randmtzig.cc, randmtzig.h, randpoisson.cc, randpoisson.h, schur.cc, schur.h,
sparse-chol.cc, sparse-chol.h, sparse-dmsolve.cc, sparse-dmsolve.h,
sparse-lu.cc, sparse-lu.h, sparse-qr.cc, sparse-qr.h, svd.cc, svd.h,
Sparse-diag-op-defs.h, Sparse-op-decls.h, Sparse-op-defs.h,
Sparse-perm-op-defs.h, mx-base.h, mx-defs.h, mx-ext.h, mx-inlines.cc,
mx-op-decl.h, mx-op-defs.h, child-list.cc, child-list.h, dir-ops.cc, dir-ops.h,
file-ops.cc, file-ops.h, file-stat.cc, file-stat.h, lo-sysdep.cc, lo-sysdep.h,
mach-info.cc, mach-info.h, oct-env.cc, oct-env.h, oct-group.cc, oct-group.h,
oct-passwd.cc, oct-passwd.h, oct-syscalls.cc, oct-time.cc, oct-time.h,
oct-uname.cc, oct-uname.h, action-container.h, base-list.h, byte-swap.h,
caseless-str.h, cmd-edit.cc, cmd-edit.h, cmd-hist.cc, cmd-hist.h, data-conv.cc,
data-conv.h, f2c-main.c, functor.h, glob-match.cc, glob-match.h, kpse.cc,
kpse.h, lo-array-errwarn.cc, lo-array-errwarn.h, lo-array-gripes.cc,
lo-array-gripes.h, lo-cutils.c, lo-cutils.h, lo-hash.cc, lo-hash.h, lo-ieee.cc,
lo-ieee.h, lo-macros.h, lo-math.h, lo-regexp.cc, lo-regexp.h, lo-traits.h,
lo-utils.cc, lo-utils.h, oct-alloc.h, oct-base64.cc, oct-binmap.h, oct-cmplx.h,
oct-glob.cc, oct-glob.h, oct-inttypes-fwd.h, oct-inttypes.cc, oct-inttypes.h,
oct-locbuf.cc, oct-mutex.cc, oct-mutex.h, oct-refcount.h, oct-rl-edit.c,
oct-rl-edit.h, oct-rl-hist.c, oct-rl-hist.h, oct-shlib.cc, oct-shlib.h,
oct-sort.cc, oct-sort.h, oct-sparse.h, oct-string.cc, oct-string.h,
pathsearch.cc, pathsearch.h, singleton-cleanup.cc, singleton-cleanup.h,
sparse-sort.cc, sparse-sort.h, sparse-util.cc, sparse-util.h, str-vec.cc,
str-vec.h, sun-utils.h, unwind-prot.cc, unwind-prot.h, url-transfer.cc,
url-transfer.h, areadlink-wrapper.c, areadlink-wrapper.h,
async-system-wrapper.c, async-system-wrapper.h, base64-wrappers.c,
base64-wrappers.h, canonicalize-file-name-wrapper.c,
canonicalize-file-name-wrapper.h, dirent-wrappers.c, dirent-wrappers.h,
fcntl-wrappers.c, fcntl-wrappers.h, filepos-wrappers.c, filepos-wrappers.h,
fpucw-wrappers.c, fpucw-wrappers.h, gen-tempname-wrapper.c,
gen-tempname-wrapper.h, getopt-wrapper.c, glob-wrappers.c, hash-wrappers.c,
hash-wrappers.h, math-wrappers.c, math-wrappers.h, mkostemp-wrapper.c,
mkostemp-wrapper.h, nanosleep-wrapper.c, nanosleep-wrapper.h, nproc-wrapper.c,
nproc-wrapper.h, octave-popen2.c, octave-popen2.h, putenv-wrapper.c,
putenv-wrapper.h, set-program-name-wrapper.c, set-program-name-wrapper.h,
signal-wrappers.c, signal-wrappers.h, stat-wrappers.c, stat-wrappers.h,
strdup-wrapper.c, strdup-wrapper.h, strftime-wrapper.c, strftime-wrapper.h,
strmode-wrapper.c, strmode-wrapper.h, strptime-wrapper.c, strptime-wrapper.h,
time-wrappers.c, time-wrappers.h, tmpfile-wrapper.c, tmpfile-wrapper.h,
uname-wrapper.c, uname-wrapper.h, unistd-wrappers.c, unistd-wrappers.h,
unsetenv-wrapper.c, unsetenv-wrapper.h, vasprintf-wrapper.c,
vasprintf-wrapper.h, wait-for-input.c, wait-for-input.h, wait-wrappers.c,
wait-wrappers.h:
Wrap long lines < 80 characters.  Update incorrect indentation.

diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -96,8 +96,9 @@ INSTANTIATE_ARRAY (Complex, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<Complex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<Complex>;
+
diff --git a/liboctave/array/Array-b.cc b/liboctave/array/Array-b.cc
--- a/liboctave/array/Array-b.cc
+++ b/liboctave/array/Array-b.cc
@@ -121,8 +121,9 @@ INSTANTIATE_ARRAY (bool, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<bool>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<bool>;
+
diff --git a/liboctave/array/Array-ch.cc b/liboctave/array/Array-ch.cc
--- a/liboctave/array/Array-ch.cc
+++ b/liboctave/array/Array-ch.cc
@@ -45,8 +45,9 @@ INSTANTIATE_ARRAY (char, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<char>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<char>;
+
diff --git a/liboctave/array/Array-d.cc b/liboctave/array/Array-d.cc
--- a/liboctave/array/Array-d.cc
+++ b/liboctave/array/Array-d.cc
@@ -167,8 +167,9 @@ INSTANTIATE_ARRAY (double, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<double>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<double>;
+
diff --git a/liboctave/array/Array-f.cc b/liboctave/array/Array-f.cc
--- a/liboctave/array/Array-f.cc
+++ b/liboctave/array/Array-f.cc
@@ -167,8 +167,9 @@ INSTANTIATE_ARRAY (float, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<float>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<float>;
+
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -96,8 +96,9 @@ INSTANTIATE_ARRAY (FloatComplex, OCTAVE_
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<FloatComplex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<FloatComplex>;
+
diff --git a/liboctave/array/Array-i.cc b/liboctave/array/Array-i.cc
--- a/liboctave/array/Array-i.cc
+++ b/liboctave/array/Array-i.cc
@@ -71,8 +71,9 @@ INSTANTIATE_ARRAY (octave_uint8, OCTAVE_
 INSTANTIATE_ARRAY (octave_uint16, OCTAVE_API);
 INSTANTIATE_ARRAY (octave_uint32, OCTAVE_API);
 INSTANTIATE_ARRAY (octave_uint64, OCTAVE_API);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<int>;
+
diff --git a/liboctave/array/Array-idx-vec.cc b/liboctave/array/Array-idx-vec.cc
--- a/liboctave/array/Array-idx-vec.cc
+++ b/liboctave/array/Array-idx-vec.cc
@@ -34,8 +34,9 @@ along with Octave; see the file COPYING.
 // Prevent implicit instantiations on some systems (Windows, others?)
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 NO_INSTANTIATE_ARRAY_SORT (idx_vector);
 
 INSTANTIATE_ARRAY (idx_vector, OCTAVE_API);
+
diff --git a/liboctave/array/Array-s.cc b/liboctave/array/Array-s.cc
--- a/liboctave/array/Array-s.cc
+++ b/liboctave/array/Array-s.cc
@@ -42,8 +42,9 @@ extern template class OCTAVE_API Array<o
 template class OCTAVE_API octave_sort<short>;
 
 INSTANTIATE_ARRAY (short, OCTAVE_API);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class DiagArray2<short>;
+
diff --git a/liboctave/array/Array-str.cc b/liboctave/array/Array-str.cc
--- a/liboctave/array/Array-str.cc
+++ b/liboctave/array/Array-str.cc
@@ -37,8 +37,9 @@ along with Octave; see the file COPYING.
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 template class OCTAVE_API octave_sort<std::string>;
 
 INSTANTIATE_ARRAY (std::string, OCTAVE_API);
+
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -553,17 +553,17 @@ sub2ind (const dim_vector& dv, const Arr
           all_ranges = all_ranges && idx.is_range ();
           if (clen < 0)
             clen = idx.length (n);
           else if (clen != idx.length (n))
             (*current_liboctave_error_handler)
               ("sub2ind: lengths of indices must match");
 
           if (idx.extent (n) > n)
-              octave::err_index_out_of_range (len, i+1, idx.extent (n), n);
+            octave::err_index_out_of_range (len, i+1, idx.extent (n), n);
         }
       catch (octave::index_exception& e)
         {
           e.set_pos_if_unset (len, i+1);
           e.set_var ();
           std::string msg = e.message ();
           (*current_liboctave_error_with_id_handler)
             (e.err_id (), msg.c_str ());
@@ -663,8 +663,9 @@ ind2sub (const dim_vector& dv, const idx
 int
 permute_vector_compare (const void *a, const void *b)
 {
   const permute_vector *pva = static_cast<const permute_vector *> (a);
   const permute_vector *pvb = static_cast<const permute_vector *> (b);
 
   return pva->pidx > pvb->pidx;
 }
+
diff --git a/liboctave/array/Array-util.h b/liboctave/array/Array-util.h
--- a/liboctave/array/Array-util.h
+++ b/liboctave/array/Array-util.h
@@ -110,8 +110,9 @@ permute_vector
 {
   octave_idx_type pidx;
   octave_idx_type iidx;
 };
 
 extern int OCTAVE_API permute_vector_compare (const void *a, const void *b);
 
 #endif
+
diff --git a/liboctave/array/Array-voidp.cc b/liboctave/array/Array-voidp.cc
--- a/liboctave/array/Array-voidp.cc
+++ b/liboctave/array/Array-voidp.cc
@@ -35,8 +35,9 @@ along with Octave; see the file COPYING.
 // that can lead to duplicate definitions of static data members.
 
 extern template class OCTAVE_API Array<idx_vector>;
 extern template class OCTAVE_API Array<octave_idx_type>;
 
 NO_INSTANTIATE_ARRAY_SORT (void *);
 
 INSTANTIATE_ARRAY (void *, OCTAVE_API);
+
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -852,17 +852,18 @@ Array<T>::index (const Array<idx_vector>
       // Get dimensions, allowing Fortran indexing in the last dim.
       dim_vector dv = dimensions.redim (ial);
 
       // Check for out of bounds conditions.
       bool all_colons = true;
       for (int i = 0; i < ial; i++)
         {
           if (ia(i).extent (dv(i)) != dv(i))
-            octave::err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
+            octave::err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i),
+                                            dimensions); // throws
 
           all_colons = all_colons && ia(i).is_colon ();
         }
 
       if (all_colons)
         {
           // A(:,:,...,:) produces a shallow copy.
           dv.chop_trailing_singletons ();
@@ -2864,8 +2865,9 @@ operator << (std::ostream& os, const Arr
               if (i != m - 1)
                 increment_index (ra_idx, a_dims, 2);
             }
         }
     }
 
   return os;
 }
+
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -911,8 +911,9 @@ public:
   { return ArrayClass::xelem (ra_idx); }
 };
 
 template <typename T>
 std::ostream&
 operator << (std::ostream& os, const Array<T>& a);
 
 #endif
+
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -484,8 +484,9 @@ operator >> (std::istream& is, ComplexCo
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
+
diff --git a/liboctave/array/CColVector.h b/liboctave/array/CColVector.h
--- a/liboctave/array/CColVector.h
+++ b/liboctave/array/CColVector.h
@@ -146,8 +146,9 @@ public:
   void clear (octave_idx_type n)
   { Array<Complex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, ComplexColumnVector, Complex)
 
 #endif
+
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -506,8 +506,9 @@ operator << (std::ostream& os, const Com
             os << " " /* setw (field_width) */ << a.elem (i, i);
           else
             os << " " /* setw (field_width) */ << ZERO;
         }
       os << "\n";
     }
   return os;
 }
+
diff --git a/liboctave/array/CDiagMatrix.h b/liboctave/array/CDiagMatrix.h
--- a/liboctave/array/CDiagMatrix.h
+++ b/liboctave/array/CDiagMatrix.h
@@ -153,8 +153,9 @@ OCTAVE_API ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const DiagMatrix& b);
 
 OCTAVE_API ComplexDiagMatrix
 operator * (const DiagMatrix& a, const ComplexDiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, ComplexDiagMatrix, Complex)
 
 #endif
+
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -851,17 +851,18 @@ ComplexMatrix::finverse (MatrixType &mat
   double anorm =
     retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
-    F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
+    F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                               info));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       // Now calculate the condition number for non-singular matrix.
@@ -937,17 +938,18 @@ ComplexMatrix::inverse (MatrixType &matt
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
 {
   ComplexMatrix retval;
 
-  octave::math::svd<ComplexMatrix> result (*this, octave::math::svd<ComplexMatrix>::Type::economy);
+  octave::math::svd<ComplexMatrix> result (*this,
+      octave::math::svd<ComplexMatrix>::Type::economy);
 
   DiagMatrix S = result.singular_values ();
   ComplexMatrix U = result.left_singular_matrix ();
   ComplexMatrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -1100,17 +1102,18 @@ ComplexMatrix::fourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
@@ -1141,17 +1144,18 @@ ComplexMatrix::ifourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
@@ -1185,17 +1189,18 @@ ComplexMatrix::fourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
@@ -1207,17 +1212,18 @@ ComplexMatrix::fourier2d (void) const
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                               F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
@@ -1251,17 +1257,18 @@ ComplexMatrix::ifourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
@@ -1276,17 +1283,18 @@ ComplexMatrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                               F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
@@ -1402,17 +1410,18 @@ ComplexMatrix::determinant (MatrixType& 
 
       // Calculate (always, see bug #45577) the norm of the matrix, for later use.
       double anorm = xnorm (*this, 1);
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
-        F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
+        F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                   info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = ComplexDET ();
         }
@@ -1596,17 +1605,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
               if (octave::math::isnan (anorm))
                 info = -1;
               else
-                F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
+                F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                           info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
               else
                 {
@@ -1925,17 +1935,18 @@ ComplexMatrix::fsolve (MatrixType &matty
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
-            F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
+            F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                       info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -2425,17 +2436,18 @@ ComplexMatrix::lssolve (const ComplexMat
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval), maxmn,
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
+                                 F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
@@ -2462,17 +2474,18 @@ ComplexMatrix::lssolve (const ComplexMat
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
+                                 F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2613,26 +2626,28 @@ ComplexMatrix::lssolve (const ComplexCol
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval), maxmn,
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
+                                 F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
+                                 F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
@@ -3252,17 +3267,21 @@ operator >> (std::istream& is, ComplexMa
 }
 
 ComplexMatrix
 Givens (const Complex& x, const Complex& y)
 {
   double cc;
   Complex cs, temp_r;
 
-  F77_FUNC (zlartg, ZLARTG) (F77_CONST_DBLE_CMPLX_ARG (&x), F77_CONST_DBLE_CMPLX_ARG (&y), cc, F77_DBLE_CMPLX_ARG (&cs), F77_DBLE_CMPLX_ARG (&temp_r));
+  F77_FUNC (zlartg, ZLARTG) (F77_CONST_DBLE_CMPLX_ARG (&x),
+                             F77_CONST_DBLE_CMPLX_ARG (&y),
+                             cc,
+                             F77_DBLE_CMPLX_ARG (&cs),
+                             F77_DBLE_CMPLX_ARG (&temp_r));
 
   ComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
@@ -3438,25 +3457,28 @@ xgemm (const ComplexMatrix& a, const Com
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
-              F77_FUNC (xzdotu, XZDOTU) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
+              F77_FUNC (xzdotu, XZDOTU) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
+                                         F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
                                          F77_DBLE_CMPLX_ARG (c));
               if (cja) *c = octave::math::conj (*c);
             }
           else if (cja)
-            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
+                                       F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
                                        F77_DBLE_CMPLX_ARG (c));
           else
-            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
+                                       F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
                                        F77_DBLE_CMPLX_ARG (c));
         }
       else if (b_nc == 1 && ! cjb)
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    lda, tda, 1.0,  F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda,
                                    F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), 1
@@ -3472,17 +3494,18 @@ xgemm (const ComplexMatrix& a, const Com
         }
       else
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           const char ctrb = get_blas_trans_arg (trb, cjb);
           F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    F77_CONST_CHAR_ARG2 (&ctrb, 1),
                                    a_nr, b_nc, a_nc, 1.0, F77_CONST_DBLE_CMPLX_ARG (a.data ()),
-                                   lda, F77_CONST_DBLE_CMPLX_ARG (b.data ()), ldb, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
+                                   lda, F77_CONST_DBLE_CMPLX_ARG (b.data ()), ldb, 0.0, F77_DBLE_CMPLX_ARG (c),
+                                   a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
@@ -3549,17 +3572,18 @@ min (const ComplexMatrix& a, const Compl
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
+            result(i, j) = octave::math::min (octave::math::real (a(i, j)),
+                                              octave::math::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3623,17 +3647,18 @@ max (const ComplexMatrix& a, const Compl
         }
 
       // FIXME: is it so much faster?
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
+              result(i, j) = octave::math::max (octave::math::real (a(i, j)),
+                                                octave::math::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
@@ -3684,8 +3709,9 @@ ComplexMatrix linspace (const ComplexCol
 MS_CMP_OPS (ComplexMatrix, Complex)
 MS_BOOL_OPS (ComplexMatrix, Complex)
 
 SM_CMP_OPS (Complex, ComplexMatrix)
 SM_BOOL_OPS (Complex, ComplexMatrix)
 
 MM_CMP_OPS (ComplexMatrix, ComplexMatrix)
 MM_BOOL_OPS (ComplexMatrix, ComplexMatrix)
+
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -464,8 +464,9 @@ SM_CMP_OP_DECLS (Complex, ComplexMatrix,
 SM_BOOL_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (ComplexMatrix, ComplexMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, ComplexMatrix, Complex)
 
 #endif
+
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -222,17 +222,18 @@ ComplexNDArray::fourier (int dim) const
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
-          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp), F77_DBLE_CMPLX_ARG (pwsave));
+          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp),
+                                   F77_DBLE_CMPLX_ARG (pwsave));
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
@@ -269,17 +270,18 @@ ComplexNDArray::ifourier (int dim) const
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
-          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp), F77_DBLE_CMPLX_ARG (pwsave));
+          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp),
+                                   F77_DBLE_CMPLX_ARG (pwsave));
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
                                                    static_cast<double> (npts);
         }
     }
 
   return retval;
@@ -315,17 +317,18 @@ ComplexNDArray::fourier2d (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
@@ -363,17 +366,18 @@ ComplexNDArray::ifourier2d (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) =
                   prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
@@ -411,17 +415,18 @@ ComplexNDArray::fourierNd (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
@@ -458,17 +463,18 @@ ComplexNDArray::ifourierNd (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) =
                   prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
@@ -554,17 +560,18 @@ ComplexNDArray::all_integers (double& ma
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val
+          || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 ComplexNDArray::too_large_for_float (void) const
@@ -886,8 +893,9 @@ ComplexNDArray& operator /= (ComplexNDAr
     do_ms_inplace_op<Complex, double> (a, s, mx_inline_div2);
   return a;
 }
 
 BSXFUN_STDOP_DEFS_MXLOOP (ComplexNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (ComplexNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, ComplexNDArray, mx_inline_pow)
+
diff --git a/liboctave/array/CNDArray.h b/liboctave/array/CNDArray.h
--- a/liboctave/array/CNDArray.h
+++ b/liboctave/array/CNDArray.h
@@ -171,8 +171,9 @@ extern OCTAVE_API ComplexNDArray& operat
 extern OCTAVE_API ComplexNDArray& operator /= (ComplexNDArray& a, double s);
 
 BSXFUN_STDOP_DECLS (ComplexNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (ComplexNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, ComplexNDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -408,17 +408,18 @@ operator * (const ComplexRowVector& v, c
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
   if (len != 0)
-    F77_FUNC (xzdotu, XZDOTU) (len, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_DBLE_CMPLX_ARG (&retval));
+    F77_FUNC (xzdotu, XZDOTU) (len, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1,
+                               F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_DBLE_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
 
 ComplexRowVector
 linspace (const Complex& x1, const Complex& x2, octave_idx_type n)
@@ -435,8 +436,9 @@ linspace (const Complex& x1, const Compl
   Complex delta = (x2 - x1) / (n - 1.0);
   for (octave_idx_type i = 1; i < n-1; i++)
     retval(i) = x1 + static_cast<double> (i)*delta;
 
   retval(n-1) = x2;
 
   return retval;
 }
+
diff --git a/liboctave/array/CRowVector.h b/liboctave/array/CRowVector.h
--- a/liboctave/array/CRowVector.h
+++ b/liboctave/array/CRowVector.h
@@ -137,8 +137,9 @@ Complex OCTAVE_API operator * (const Com
 // other operations
 
 OCTAVE_API ComplexRowVector linspace (const Complex& x1, const Complex& x2,
                                       octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, ComplexRowVector, Complex)
 
 #endif
+
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -175,17 +175,19 @@ SparseComplexMatrix::is_hermitian (void)
         }
 
       return true;
     }
 
   return false;
 }
 
-static const Complex Complex_NaN_result (octave::numeric_limits<double>::NaN (), octave::numeric_limits<double>::NaN ());
+static const Complex
+  Complex_NaN_result (octave::numeric_limits<double>::NaN (),
+                      octave::numeric_limits<double>::NaN ());
 
 SparseComplexMatrix
 SparseComplexMatrix::max (int dim) const
 {
   Array<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
@@ -1026,17 +1028,19 @@ SparseComplexMatrix::inverse (MatrixType
       if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          octave::math::sparse_lu<SparseComplexMatrix> fact (*this, Qinit, Matrix (), false, false);
+          octave::math::sparse_lu<SparseComplexMatrix> fact (*this,
+                                                             Qinit, Matrix (),
+                                                             false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseComplexMatrix InvL = fact.L ().transpose ().
                                      tinverse (tmp_typ, info, rcond2,
                                                true, false);
           SparseComplexMatrix InvU = fact.U ().
                                      tinverse (tmp_typ, info, rcond2,
                                                true, false).transpose ();
@@ -3679,17 +3683,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (result),
                                    b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -3736,17 +3741,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
@@ -3835,17 +3841,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
+          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -3871,17 +3878,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt,
+                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             F77_DBLE_CMPLX_ARG (DU2), pipvt,
                              F77_DBLE_CMPLX_ARG (work), b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
@@ -3979,17 +3987,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4037,17 +4046,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
@@ -4134,17 +4144,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
+          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4172,17 +4183,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt,
+                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             F77_DBLE_CMPLX_ARG (DU2), pipvt,
                              F77_DBLE_CMPLX_ARG (Bx), b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       // FIXME: This should probably be a warning so that
                       //        error value can be passed back.
                       (*current_liboctave_error_handler)
@@ -4389,17 +4401,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper,
+                                     F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           // Throw-away extra info LAPACK gives so as to not
           // change output.
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
@@ -4668,17 +4681,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+                                     F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
@@ -4949,17 +4963,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+                                     F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
@@ -5233,17 +5248,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+                                     F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
@@ -6794,17 +6810,17 @@ SparseComplexMatrix::solve (MatrixType &
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #if defined (USE_QRSOLVE)
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
-                       SparseComplexMatrix> (*this, b, err);
+      SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
@@ -7183,17 +7199,18 @@ SparseComplexMatrix::all_integers (doubl
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val
+          || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
@@ -7751,8 +7768,9 @@ SPARSE_SMS_BOOL_OPS (SparseComplexMatrix
 
 SPARSE_SSM_CMP_OPS (Complex, 0.0, real, SparseComplexMatrix,
                     0.0, real)
 SPARSE_SSM_BOOL_OPS (Complex, SparseComplexMatrix, 0.0)
 
 SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, real, SparseComplexMatrix,
                      0.0, real)
 SPARSE_SMSM_BOOL_OPS (SparseComplexMatrix, SparseComplexMatrix, 0.0)
+
diff --git a/liboctave/array/CSparse.h b/liboctave/array/CSparse.h
--- a/liboctave/array/CSparse.h
+++ b/liboctave/array/CSparse.h
@@ -547,8 +547,9 @@ SPARSE_SSM_CMP_OP_DECLS (Complex, Sparse
 SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
 SPARSE_SMSM_BOOL_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseComplexMatrix, ComplexMatrix, Complex)
 
 #endif
+
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -140,8 +140,9 @@ DiagArray2<T>::check_idx (octave_idx_typ
   if (r < 0 || r >= dim1 ())
     octave::err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
 
   if (c < 0 || c >= dim2 ())
     octave::err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
 
   return ok;
 }
+
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -183,8 +183,9 @@ public:
   { Array<T>::print_info (os, prefix); }
 
 private:
 
   bool check_idx (octave_idx_type r, octave_idx_type c) const;
 };
 
 #endif
+
diff --git a/liboctave/array/MArray-C.cc b/liboctave/array/MArray-C.cc
--- a/liboctave/array/MArray-C.cc
+++ b/liboctave/array/MArray-C.cc
@@ -36,8 +36,9 @@ template class OCTAVE_API MArray<Complex
 INSTANTIATE_MARRAY_FRIENDS (Complex, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<Complex>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (Complex, OCTAVE_API)
+
diff --git a/liboctave/array/MArray-d.cc b/liboctave/array/MArray-d.cc
--- a/liboctave/array/MArray-d.cc
+++ b/liboctave/array/MArray-d.cc
@@ -34,8 +34,9 @@ template class OCTAVE_API MArray<double>
 INSTANTIATE_MARRAY_FRIENDS (double, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<double>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (double, OCTAVE_API)
+
diff --git a/liboctave/array/MArray-f.cc b/liboctave/array/MArray-f.cc
--- a/liboctave/array/MArray-f.cc
+++ b/liboctave/array/MArray-f.cc
@@ -34,8 +34,9 @@ template class OCTAVE_API MArray<float>;
 INSTANTIATE_MARRAY_FRIENDS (float, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<float>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (float, OCTAVE_API)
+
diff --git a/liboctave/array/MArray-fC.cc b/liboctave/array/MArray-fC.cc
--- a/liboctave/array/MArray-fC.cc
+++ b/liboctave/array/MArray-fC.cc
@@ -36,8 +36,9 @@ template class OCTAVE_API MArray<FloatCo
 INSTANTIATE_MARRAY_FRIENDS (FloatComplex, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<FloatComplex>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (FloatComplex, OCTAVE_API)
+
diff --git a/liboctave/array/MArray-i.cc b/liboctave/array/MArray-i.cc
--- a/liboctave/array/MArray-i.cc
+++ b/liboctave/array/MArray-i.cc
@@ -71,8 +71,9 @@ INSTANTIATE_MARRAY_FRIENDS (octave_uint3
 INSTANTIATE_MARRAY_FRIENDS (octave_uint64, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<int>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (int, OCTAVE_API)
+
diff --git a/liboctave/array/MArray-s.cc b/liboctave/array/MArray-s.cc
--- a/liboctave/array/MArray-s.cc
+++ b/liboctave/array/MArray-s.cc
@@ -41,8 +41,9 @@ template short xmax<short> (short, short
 INSTANTIATE_MARRAY_FRIENDS (short, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class OCTAVE_API MDiagArray2<short>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (short, OCTAVE_API)
+
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -81,17 +81,17 @@ MArray<T>::idx_add (const idx_vector& id
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
 }
 
 template <typename T, T op (typename ref_param<T>::type,
-                         typename ref_param<T>::type)>
+                            typename ref_param<T>::type)>
 struct _idxbinop_helper
 {
   T *array;
   const T *vals;
   _idxbinop_helper (T *a, const T *v) : array (a), vals (v) { }
   void operator () (octave_idx_type i)
   { array[i] = op (array[i], *vals++); }
 };
@@ -354,8 +354,9 @@ operator + (const MArray<T>& a)
 }
 
 template <typename T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
   return do_mx_unary_op<T, T> (a, mx_inline_uminus);
 }
+
diff --git a/liboctave/array/MArray.h b/liboctave/array/MArray.h
--- a/liboctave/array/MArray.h
+++ b/liboctave/array/MArray.h
@@ -257,8 +257,9 @@ public:
                                           const MDiagArray2<T>&);       \
   template API MDiagArray2<T> operator - (const MDiagArray2<T>&,        \
                                           const MDiagArray2<T>&);       \
   template API MDiagArray2<T> product (const MDiagArray2<T>&,           \
                                        const MDiagArray2<T>&);
 
 #endif
 
+
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -65,17 +65,17 @@ MARRAY_DAS_OP (/, mx_inline_div)
 
 // Element by element scalar by MDiagArray2 ops.
 
 template <typename T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
   return MDiagArray2<T> (do_sm_binary_op<T, T, T> (s, a, mx_inline_mul),
-                                                   a.d1, a.d2);
+                         a.d1, a.d2);
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN)                                     \
   template <typename T>                                                 \
   MDiagArray2<T>                                                        \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b)                \
@@ -101,8 +101,9 @@ operator + (const MDiagArray2<T>& a)
 
 template <typename T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
   return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus),
                          a.d1, a.d2);
 }
+
diff --git a/liboctave/array/MDiagArray2.h b/liboctave/array/MDiagArray2.h
--- a/liboctave/array/MDiagArray2.h
+++ b/liboctave/array/MDiagArray2.h
@@ -170,8 +170,9 @@ public:
   inline R                                                              \
   product (const R& x, const R& y)                                      \
   {                                                                     \
     return R (product (dynamic_cast<const B<T>&> (x),                   \
                        dynamic_cast<const B<T>&> (y)));                 \
   }
 
 #endif
+
diff --git a/liboctave/array/MSparse-C.cc b/liboctave/array/MSparse-C.cc
--- a/liboctave/array/MSparse-C.cc
+++ b/liboctave/array/MSparse-C.cc
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include "oct-cmplx.h"
 
 #include "MSparse.h"
 
 template class OCTAVE_API MSparse<Complex>;
 
 INSTANTIATE_SPARSE_FRIENDS (Complex, OCTAVE_API);
+
diff --git a/liboctave/array/MSparse-d.cc b/liboctave/array/MSparse-d.cc
--- a/liboctave/array/MSparse-d.cc
+++ b/liboctave/array/MSparse-d.cc
@@ -25,8 +25,9 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "MSparse.h"
 
 template class OCTAVE_API MSparse<double>;
 
 INSTANTIATE_SPARSE_FRIENDS (double, OCTAVE_API);
+
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -601,8 +601,9 @@ MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
   octave_idx_type nz = a.nnz ();
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data (i) = - retval.data (i);
   return retval;
 }
+
diff --git a/liboctave/array/MSparse.h b/liboctave/array/MSparse.h
--- a/liboctave/array/MSparse.h
+++ b/liboctave/array/MSparse.h
@@ -205,8 +205,9 @@ public:
   SPARSE_BINOP_FWD_FCN (R, operator -, T, dynamic_cast<const B<T>&>,    \
                         R, dynamic_cast<const B<T>&>, R)                \
   SPARSE_BINOP_FWD_FCN (R, product,    T, dynamic_cast<const B<T>&>,    \
                         R, dynamic_cast<const B<T>&>, R)                \
   SPARSE_BINOP_FWD_FCN (R, quotient, T, dynamic_cast<const B<T>&>,      \
                         R, dynamic_cast<const B<T>&>, R)
 
 #endif
+
diff --git a/liboctave/array/Matrix.h b/liboctave/array/Matrix.h
--- a/liboctave/array/Matrix.h
+++ b/liboctave/array/Matrix.h
@@ -31,8 +31,9 @@ along with Octave; see the file COPYING.
 
 #include "mx-base.h"
 
 #include "mx-ext.h"
 
 #include "mx-ops.h"
 
 #endif
+
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -977,8 +977,9 @@ MatrixType::transpose (void) const
 
   return retval;
 }
 
 // Instantiate MatrixType template constructors that we need.
 
 template MatrixType::MatrixType (const MSparse<double>&);
 template MatrixType::MatrixType (const MSparse<Complex>&);
+
diff --git a/liboctave/array/MatrixType.h b/liboctave/array/MatrixType.h
--- a/liboctave/array/MatrixType.h
+++ b/liboctave/array/MatrixType.h
@@ -181,8 +181,9 @@ private:
   octave_idx_type lower_band;
   bool dense;
   bool full;
   octave_idx_type nperm;
   octave_idx_type *perm;
 };
 
 #endif
+
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -228,8 +228,9 @@ operator *(const PermMatrix& a, const Pe
 
   if (n != b.rows ())
     octave::err_nonconformant ("operator *", n, n, b.rows (), b.rows ());
 
   r = PermMatrix (ia.index (idx_vector (ib)), true, false);
 
   return r;
 }
+
diff --git a/liboctave/array/PermMatrix.h b/liboctave/array/PermMatrix.h
--- a/liboctave/array/PermMatrix.h
+++ b/liboctave/array/PermMatrix.h
@@ -126,8 +126,9 @@ private:
 };
 
 // Multiplying permutations together.
 PermMatrix
 OCTAVE_API
 operator * (const PermMatrix& a, const PermMatrix& b);
 
 #endif
+
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -576,8 +576,9 @@ Range::limit_internal (void) const
 void
 Range::init (void)
 {
   rng_numel = numel_internal ();
   rng_limit = limit_internal ();
 
   clear_cache ();
 }
+
diff --git a/liboctave/array/Range.h b/liboctave/array/Range.h
--- a/liboctave/array/Range.h
+++ b/liboctave/array/Range.h
@@ -57,17 +57,18 @@ public:
     rng_limit = limit_internal ();
   }
 
   // For operators' usage (to preserve element count).
   Range (double b, double i, octave_idx_type n)
     : rng_base (b), rng_limit (b + (n-1) * i), rng_inc (i),
       rng_numel (n), cache ()
   {
-    if (! octave::math::finite (b) || ! octave::math::finite (i) || ! octave::math::finite (rng_limit))
+    if (! octave::math::finite (b) || ! octave::math::finite (i)
+        || ! octave::math::finite (rng_limit))
       rng_numel = -2;
     else
       {
         // Code below is only needed if the resulting range must be 100%
         // correctly constructed.  If the Range object created is only
         // a temporary one used by operators this may be unnecessary.
 
         rng_limit = limit_internal ();
@@ -150,17 +151,18 @@ private:
 
 protected:
 
   // For operators' usage (to allow all values to be set directly).
   Range (double b, double l, double i, octave_idx_type n)
     : rng_base (b), rng_limit (l), rng_inc (i),
       rng_numel (n), cache ()
   {
-    if (! octave::math::finite (b) || ! octave::math::finite (i) || ! octave::math::finite (l))
+    if (! octave::math::finite (b) || ! octave::math::finite (i)
+        || ! octave::math::finite (l))
       rng_numel = -2;
   }
 };
 
 extern OCTAVE_API Range operator - (const Range& r);
 
 extern OCTAVE_API Range operator + (double x, const Range& r);
 
@@ -170,8 +172,9 @@ extern OCTAVE_API Range operator - (doub
 
 extern OCTAVE_API Range operator - (const Range& r, double x);
 
 extern OCTAVE_API Range operator * (double x, const Range& r);
 
 extern OCTAVE_API Range operator * (const Range& r, double x);
 
 #endif
+
diff --git a/liboctave/array/Sparse-C.cc b/liboctave/array/Sparse-C.cc
--- a/liboctave/array/Sparse-C.cc
+++ b/liboctave/array/Sparse-C.cc
@@ -57,8 +57,9 @@ sparse_descending_compare<Complex> (cons
           || ((xabs (a) == xabs (b)) && (arg (a) > arg (b))));
 }
 
 INSTANTIATE_SPARSE (Complex, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<Complex>&);
 #endif
+
diff --git a/liboctave/array/Sparse-b.cc b/liboctave/array/Sparse-b.cc
--- a/liboctave/array/Sparse-b.cc
+++ b/liboctave/array/Sparse-b.cc
@@ -37,8 +37,9 @@ Sparse<bool>::SparseRep::any_element_is_
   return false;
 }
 
 INSTANTIATE_SPARSE (bool, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<bool>&);
 #endif
+
diff --git a/liboctave/array/Sparse-d.cc b/liboctave/array/Sparse-d.cc
--- a/liboctave/array/Sparse-d.cc
+++ b/liboctave/array/Sparse-d.cc
@@ -45,8 +45,9 @@ sparse_descending_compare<double> (doubl
   return (octave::math::isnan (a) || (a > b));
 }
 
 INSTANTIATE_SPARSE (double, OCTAVE_API);
 
 #if 0
 template std::ostream& operator << (std::ostream&, const Sparse<double>&);
 #endif
+
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -3011,8 +3011,9 @@ Sparse<T>::print_info (std::ostream& os,
      << prefix << "rep->count:  " << rep->count << "\n";
 }
 
 #define INSTANTIATE_SPARSE(T, API)                                      \
   template class API Sparse<T>;                                         \
   template std::istream&                                                \
   read_sparse_matrix<T> (std::istream& is, Sparse<T>& a,                \
                          T (*read_fcn) (std::istream&));
+
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -700,8 +700,9 @@ public:
 };
 
 template <typename T>
 std::istream&
 read_sparse_matrix (std::istream& is, Sparse<T>& a,
                     T (*read_fcn) (std::istream&));
 
 #endif
+
diff --git a/liboctave/array/boolMatrix.cc b/liboctave/array/boolMatrix.cc
--- a/liboctave/array/boolMatrix.cc
+++ b/liboctave/array/boolMatrix.cc
@@ -83,8 +83,9 @@ boolMatrix::diag (octave_idx_type k) con
 {
   return Array<bool>::diag (k);
 }
 
 MM_BOOL_OPS (boolMatrix, boolMatrix)
 MS_BOOL_OPS (boolMatrix, bool)
 SM_BOOL_OPS (bool, boolMatrix)
 MM_CMP_OPS (boolMatrix, boolMatrix)
+
diff --git a/liboctave/array/boolMatrix.h b/liboctave/array/boolMatrix.h
--- a/liboctave/array/boolMatrix.h
+++ b/liboctave/array/boolMatrix.h
@@ -87,8 +87,9 @@ public:
 };
 
 MM_BOOL_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 MS_BOOL_OP_DECLS (boolMatrix, bool, OCTAVE_API)
 SM_BOOL_OP_DECLS (bool, boolMatrix, OCTAVE_API)
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/boolNDArray.cc b/liboctave/array/boolNDArray.cc
--- a/liboctave/array/boolNDArray.cc
+++ b/liboctave/array/boolNDArray.cc
@@ -163,8 +163,9 @@ mx_el_or_assign (boolNDArray& a, const b
     do_mm_inplace_op<bool, bool> (a, b, mx_inline_or2, mx_inline_or2,
                                   "operator |=");
 
   return a;
 }
 
 BSXFUN_OP_DEF_MXLOOP (and, boolNDArray, mx_inline_and)
 BSXFUN_OP_DEF_MXLOOP (or, boolNDArray, mx_inline_or)
+
diff --git a/liboctave/array/boolNDArray.h b/liboctave/array/boolNDArray.h
--- a/liboctave/array/boolNDArray.h
+++ b/liboctave/array/boolNDArray.h
@@ -115,8 +115,9 @@ extern OCTAVE_API boolNDArray&
 mx_el_and_assign (boolNDArray& m, const boolNDArray& a);
 extern OCTAVE_API boolNDArray&
 mx_el_or_assign (boolNDArray& m, const boolNDArray& a);
 
 BSXFUN_OP_DECL (and, boolNDArray, OCTAVE_API);
 BSXFUN_OP_DECL (or, boolNDArray, OCTAVE_API);
 
 #endif
+
diff --git a/liboctave/array/boolSparse.cc b/liboctave/array/boolSparse.cc
--- a/liboctave/array/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -323,8 +323,9 @@ SparseBoolMatrix::ipermute (const Array<
 SPARSE_SMS_EQNE_OPS (SparseBoolMatrix, false, , bool, false, )
 SPARSE_SMS_BOOL_OPS (SparseBoolMatrix, bool, false)
 
 SPARSE_SSM_EQNE_OPS (bool, false, , SparseBoolMatrix, false, )
 SPARSE_SSM_BOOL_OPS (bool, SparseBoolMatrix, false)
 
 SPARSE_SMSM_EQNE_OPS (SparseBoolMatrix, false, , SparseBoolMatrix, false, )
 SPARSE_SMSM_BOOL_OPS (SparseBoolMatrix, SparseBoolMatrix, false)
+
diff --git a/liboctave/array/boolSparse.h b/liboctave/array/boolSparse.h
--- a/liboctave/array/boolSparse.h
+++ b/liboctave/array/boolSparse.h
@@ -143,8 +143,9 @@ SPARSE_SMS_BOOL_OP_DECLS (SparseBoolMatr
 
 SPARSE_SSM_EQNE_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
 
 SPARSE_SMSM_EQNE_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix, OCTAVE_API)
 SPARSE_SMSM_BOOL_OP_DECLS (SparseBoolMatrix, SparseBoolMatrix, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/chMatrix.cc b/liboctave/array/chMatrix.cc
--- a/liboctave/array/chMatrix.cc
+++ b/liboctave/array/chMatrix.cc
@@ -133,8 +133,9 @@ charMatrix::extract (octave_idx_type r1,
 MS_CMP_OPS (charMatrix, char)
 MS_BOOL_OPS (charMatrix, char)
 
 SM_CMP_OPS (char, charMatrix)
 SM_BOOL_OPS (char, charMatrix)
 
 MM_CMP_OPS (charMatrix, charMatrix)
 MM_BOOL_OPS (charMatrix, charMatrix)
+
diff --git a/liboctave/array/chMatrix.h b/liboctave/array/chMatrix.h
--- a/liboctave/array/chMatrix.h
+++ b/liboctave/array/chMatrix.h
@@ -105,8 +105,9 @@ MS_BOOL_OP_DECLS (charMatrix, char, OCTA
 
 SM_CMP_OP_DECLS (char, charMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (char, charMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (charMatrix, charMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (charMatrix, charMatrix, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -252,8 +252,9 @@ NDS_BOOL_OPS (charNDArray, char)
 
 SND_CMP_OPS (char, charNDArray)
 SND_BOOL_OPS (char, charNDArray)
 
 NDND_CMP_OPS (charNDArray, charNDArray)
 NDND_BOOL_OPS (charNDArray, charNDArray)
 
 BSXFUN_STDREL_DEFS_MXLOOP (charNDArray)
+
diff --git a/liboctave/array/chNDArray.h b/liboctave/array/chNDArray.h
--- a/liboctave/array/chNDArray.h
+++ b/liboctave/array/chNDArray.h
@@ -119,8 +119,9 @@ SND_CMP_OP_DECLS (char, charNDArray, OCT
 SND_BOOL_OP_DECLS (char, charNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (charNDArray, charNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (charNDArray, charNDArray, OCTAVE_API)
 
 BSXFUN_STDREL_DECLS (charNDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -295,8 +295,9 @@ operator >> (std::istream& is, ColumnVec
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
+
diff --git a/liboctave/array/dColVector.h b/liboctave/array/dColVector.h
--- a/liboctave/array/dColVector.h
+++ b/liboctave/array/dColVector.h
@@ -118,8 +118,9 @@ public:
 // Publish externally used friend functions.
 
 extern OCTAVE_API ColumnVector real (const ComplexColumnVector& a);
 extern OCTAVE_API ColumnVector imag (const ComplexColumnVector& a);
 
 MARRAY_FORWARD_DEFS (MArray, ColumnVector, double)
 
 #endif
+
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -340,8 +340,9 @@ operator << (std::ostream& os, const Dia
             os << " " /* setw (field_width) */ << a.elem (i, i);
           else
             os << " " /* setw (field_width) */ << 0.0;
         }
       os << "\n";
     }
   return os;
 }
+
diff --git a/liboctave/array/dDiagMatrix.h b/liboctave/array/dDiagMatrix.h
--- a/liboctave/array/dDiagMatrix.h
+++ b/liboctave/array/dDiagMatrix.h
@@ -120,8 +120,9 @@ OCTAVE_API DiagMatrix imag (const Comple
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 OCTAVE_API DiagMatrix
 operator * (const DiagMatrix& a, const DiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, DiagMatrix, double)
 
 #endif
+
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -640,17 +640,18 @@ Matrix::inverse (MatrixType &mattype, oc
     }
 
   return ret;
 }
 
 Matrix
 Matrix::pseudo_inverse (double tol) const
 {
-  octave::math::svd<Matrix> result (*this, octave::math::svd<Matrix>::Type::economy);
+  octave::math::svd<Matrix> result (*this,
+                                    octave::math::svd<Matrix>::Type::economy);
 
   DiagMatrix S = result.singular_values ();
   Matrix U = result.left_singular_matrix ();
   Matrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -799,17 +800,18 @@ Matrix::fourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
@@ -840,17 +842,18 @@ Matrix::ifourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   return retval;
 }
 
@@ -884,17 +887,18 @@ Matrix::fourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
@@ -906,17 +910,18 @@ Matrix::fourier2d (void) const
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                               F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i];
     }
 
   return retval;
 }
 
@@ -950,17 +955,18 @@ Matrix::ifourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_DBLE_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
@@ -975,17 +981,18 @@ Matrix::ifourier2d (void) const
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
       for (octave_idx_type i = 0; i < npts; i++)
         prow[i] = tmp_data[i*nr + j];
 
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                               F77_DBLE_CMPLX_ARG (pwsave));
 
       for (octave_idx_type i = 0; i < npts; i++)
         tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
     }
 
   return retval;
 }
 
@@ -3097,8 +3104,9 @@ Matrix linspace (const ColumnVector& x1,
 MS_CMP_OPS (Matrix, double)
 MS_BOOL_OPS (Matrix, double)
 
 SM_CMP_OPS (double, Matrix)
 SM_BOOL_OPS (double, Matrix)
 
 MM_CMP_OPS (Matrix, Matrix)
 MM_BOOL_OPS (Matrix, Matrix)
+
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -397,8 +397,9 @@ MM_CMP_OP_DECLS (Matrix, Matrix, OCTAVE_
 MM_BOOL_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, Matrix, double)
 
 template <typename T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
+
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -263,17 +263,18 @@ NDArray::fourier (int dim) const
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
-          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp), F77_DBLE_CMPLX_ARG (pwsave));
+          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp),
+                                   F77_DBLE_CMPLX_ARG (pwsave));
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
@@ -310,17 +311,18 @@ NDArray::ifourier (int dim) const
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
-          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp), F77_DBLE_CMPLX_ARG (pwsave));
+          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp),
+                                   F77_DBLE_CMPLX_ARG (pwsave));
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
                                                    static_cast<double> (npts);
         }
     }
 
   return retval;
@@ -356,17 +358,18 @@ NDArray::fourier2d (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
@@ -404,17 +407,18 @@ NDArray::ifourier2d (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) =
                   prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
@@ -452,17 +456,18 @@ NDArray::fourierNd (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
@@ -499,17 +504,18 @@ NDArray::ifourierNd (void) const
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow), F77_DBLE_CMPLX_ARG (pwsave));
+              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
+                                       F77_DBLE_CMPLX_ARG (pwsave));
 
               for (octave_idx_type l = 0; l < npts; l++)
                 retval((l + k*npts)*stride + j*dist) =
                   prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
@@ -898,8 +904,9 @@ NDND_BOOL_OPS (NDArray, NDArray)
 BSXFUN_STDOP_DEFS_MXLOOP (NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, NDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, ComplexNDArray,
                        NDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, NDArray,
                        ComplexNDArray, mx_inline_pow)
+
diff --git a/liboctave/array/dNDArray.h b/liboctave/array/dNDArray.h
--- a/liboctave/array/dNDArray.h
+++ b/liboctave/array/dNDArray.h
@@ -189,8 +189,9 @@ BSXFUN_STDREL_DECLS (NDArray, OCTAVE_API
 
 BSXFUN_OP_DECL (pow, NDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, ComplexNDArray, ComplexNDArray,
                  NDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, ComplexNDArray, NDArray,
                  ComplexNDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -306,8 +306,9 @@ operator * (const RowVector& v, const Co
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
 {
   ComplexRowVector tmp (v);
   return tmp * a;
 }
+
diff --git a/liboctave/array/dRowVector.h b/liboctave/array/dRowVector.h
--- a/liboctave/array/dRowVector.h
+++ b/liboctave/array/dRowVector.h
@@ -114,8 +114,9 @@ Complex OCTAVE_API operator * (const Row
 
 // other operations
 
 OCTAVE_API RowVector linspace (double x1, double x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, RowVector, double)
 
 #endif
+
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -994,17 +994,17 @@ SparseMatrix::tinverse (MatrixType &matt
 
               // get A(m,m)
               double pivot;
               if (typ == MatrixType::Permuted_Upper)
                 pivot = data (cidx (jidx+1) - 1);
               else
                 pivot = data (cidx (jidx));
               if (pivot == 0.)
-                  (*current_liboctave_error_handler) ("division by zero");
+                (*current_liboctave_error_handler) ("division by zero");
 
               work[j] = v / pivot;
             }
 
           // get A(m,m)
           octave_idx_type colUp;
           if (typ == MatrixType::Permuted_Upper)
             colUp = cidx (perm[iidx]+1) - 1;
@@ -1106,17 +1106,19 @@ SparseMatrix::inverse (MatrixType &matty
       if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          octave::math::sparse_lu<SparseMatrix> fact (*this, Qinit, Matrix (), false, false);
+          octave::math::sparse_lu<SparseMatrix> fact (*this,
+                                                      Qinit, Matrix (),
+                                                      false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                               info, rcond2, true, false);
           SparseMatrix InvU = fact.U ().tinverse (tmp_typ, info, rcond2,
                                                   true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
@@ -4058,17 +4060,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4116,17 +4119,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
@@ -7880,8 +7884,9 @@ max (const SparseMatrix& a, const Sparse
 SPARSE_SMS_CMP_OPS (SparseMatrix, 0.0, , double, 0.0, )
 SPARSE_SMS_BOOL_OPS (SparseMatrix, double, 0.0)
 
 SPARSE_SSM_CMP_OPS (double, 0.0, , SparseMatrix, 0.0, )
 SPARSE_SSM_BOOL_OPS (double, SparseMatrix, 0.0)
 
 SPARSE_SMSM_CMP_OPS (SparseMatrix, 0.0, , SparseMatrix, 0.0, )
 SPARSE_SMSM_BOOL_OPS (SparseMatrix, SparseMatrix, 0.0)
+
diff --git a/liboctave/array/dSparse.h b/liboctave/array/dSparse.h
--- a/liboctave/array/dSparse.h
+++ b/liboctave/array/dSparse.h
@@ -505,8 +505,9 @@ SPARSE_SSM_CMP_OP_DECLS (double, SparseM
 SPARSE_SSM_BOOL_OP_DECLS (double, SparseMatrix, OCTAVE_API)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseMatrix, SparseMatrix, OCTAVE_API)
 SPARSE_SMSM_BOOL_OP_DECLS (SparseMatrix, SparseMatrix, OCTAVE_API)
 
 SPARSE_FORWARD_DEFS (MSparse, SparseMatrix, Matrix, double)
 
 #endif
+
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -305,8 +305,9 @@ dim_vector::redim (int n) const
       for (int i = n; i < n_dims; i++)
         k *= rep[i];
 
       retval.rep[n-1] = k;
 
       return retval;
     }
 }
+
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -565,8 +565,9 @@ operator == (const dim_vector& a, const 
 
 inline bool
 operator != (const dim_vector& a, const dim_vector& b)
 {
   return ! operator == (a, b);
 }
 
 #endif
+
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -485,8 +485,9 @@ operator >> (std::istream& is, FloatComp
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
+
diff --git a/liboctave/array/fCColVector.h b/liboctave/array/fCColVector.h
--- a/liboctave/array/fCColVector.h
+++ b/liboctave/array/fCColVector.h
@@ -153,8 +153,9 @@ public:
   void clear (octave_idx_type n)
   { Array<FloatComplex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexColumnVector, FloatComplex)
 
 #endif
+
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -510,8 +510,9 @@ operator << (std::ostream& os, const Flo
             os << " " /* setw (field_width) */ << a.elem (i, i);
           else
             os << " " /* setw (field_width) */ << ZERO;
         }
       os << "\n";
     }
   return os;
 }
+
diff --git a/liboctave/array/fCDiagMatrix.h b/liboctave/array/fCDiagMatrix.h
--- a/liboctave/array/fCDiagMatrix.h
+++ b/liboctave/array/fCDiagMatrix.h
@@ -159,8 +159,9 @@ OCTAVE_API FloatComplexDiagMatrix
 operator * (const FloatComplexDiagMatrix& a, const FloatDiagMatrix& b);
 
 OCTAVE_API FloatComplexDiagMatrix
 operator * (const FloatDiagMatrix& a, const FloatComplexDiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, FloatComplexDiagMatrix, FloatComplex)
 
 #endif
+
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -940,17 +940,18 @@ FloatComplexMatrix::inverse (MatrixType 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
 {
   FloatComplexMatrix retval;
 
-  octave::math::svd<FloatComplexMatrix> result (*this, octave::math::svd<FloatComplexMatrix>::Type::economy);
+  octave::math::svd<FloatComplexMatrix> result
+    (*this, octave::math::svd<FloatComplexMatrix>::Type::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatComplexMatrix U = result.left_singular_matrix ();
   FloatComplexMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -1103,17 +1104,18 @@ FloatComplexMatrix::fourier (void) const
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier (void) const
 {
@@ -1144,17 +1146,18 @@ FloatComplexMatrix::ifourier (void) cons
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   return retval;
 }
 
@@ -1188,17 +1191,18 @@ FloatComplexMatrix::fourier2d (void) con
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
@@ -1254,17 +1258,18 @@ FloatComplexMatrix::ifourier2d (void) co
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
@@ -2448,17 +2453,18 @@ FloatComplexMatrix::lssolve (const Float
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval), maxmn,
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
+                                 F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
@@ -2485,17 +2491,18 @@ FloatComplexMatrix::lssolve (const Float
 
           if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
+                                 F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2639,26 +2646,28 @@ FloatComplexMatrix::lssolve (const Float
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval), maxmn,
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
+                                 F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
+                                 F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
@@ -3281,17 +3290,18 @@ operator >> (std::istream& is, FloatComp
 }
 
 FloatComplexMatrix
 Givens (const FloatComplex& x, const FloatComplex& y)
 {
   float cc;
   FloatComplex cs, temp_r;
 
-  F77_FUNC (clartg, CLARTG) (F77_CONST_CMPLX_ARG (&x), F77_CONST_CMPLX_ARG (&y), cc, F77_CMPLX_ARG (&cs), F77_CMPLX_ARG (&temp_r));
+  F77_FUNC (clartg, CLARTG) (F77_CONST_CMPLX_ARG (&x), F77_CONST_CMPLX_ARG (&y),
+                             cc, F77_CMPLX_ARG (&cs), F77_CMPLX_ARG (&temp_r));
 
   FloatComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
@@ -3469,25 +3479,28 @@ xgemm (const FloatComplexMatrix& a, cons
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
-              F77_FUNC (xcdotu, XCDOTU) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
+              F77_FUNC (xcdotu, XCDOTU) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1,
+                                         F77_CONST_CMPLX_ARG (b.data ()), 1,
                                          F77_CMPLX_ARG (c));
               if (cja) *c = octave::math::conj (*c);
             }
           else if (cja)
-            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1,
+                                       F77_CONST_CMPLX_ARG (b.data ()), 1,
                                        F77_CMPLX_ARG (c));
           else
-            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (b.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1,
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (b.data ()), 1,
+                                       F77_CONST_CMPLX_ARG (a.data ()), 1,
                                        F77_CMPLX_ARG (c));
         }
       else if (b_nc == 1 && ! cjb)
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    lda, tda, 1.0,  F77_CONST_CMPLX_ARG (a.data ()), lda,
                                    F77_CONST_CMPLX_ARG (b.data ()), 1, 0.0, F77_CMPLX_ARG (c), 1
@@ -3581,17 +3594,18 @@ min (const FloatComplexMatrix& a, const 
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
+            result(i, j) = octave::math::min (octave::math::real (a(i, j)),
+                                              octave::math::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3654,17 +3668,18 @@ max (const FloatComplexMatrix& a, const 
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
+              result(i, j) = octave::math::max (octave::math::real (a(i, j)),
+                                                octave::math::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
@@ -3716,8 +3731,9 @@ FloatComplexMatrix linspace (const Float
 MS_CMP_OPS (FloatComplexMatrix, FloatComplex)
 MS_BOOL_OPS (FloatComplexMatrix, FloatComplex)
 
 SM_CMP_OPS (FloatComplex, FloatComplexMatrix)
 SM_BOOL_OPS (FloatComplex, FloatComplexMatrix)
 
 MM_CMP_OPS (FloatComplexMatrix, FloatComplexMatrix)
 MM_BOOL_OPS (FloatComplexMatrix, FloatComplexMatrix)
+
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -492,8 +492,9 @@ SM_CMP_OP_DECLS (FloatComplex, FloatComp
 SM_BOOL_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatComplexMatrix, FloatComplexMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (FloatComplexMatrix, FloatComplexMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexMatrix, FloatComplex)
 
 #endif
+
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -554,17 +554,18 @@ FloatComplexNDArray::all_integers (float
         max_val = i_val;
 
       if (r_val < min_val)
         min_val = r_val;
 
       if (i_val < min_val)
         min_val = i_val;
 
-      if (octave::math::x_nint (r_val) != r_val || octave::math::x_nint (i_val) != i_val)
+      if (octave::math::x_nint (r_val) != r_val
+          || octave::math::x_nint (i_val) != i_val)
         return false;
     }
 
   return true;
 }
 
 bool
 FloatComplexNDArray::too_large_for_float (void) const
@@ -901,8 +902,9 @@ FloatComplexNDArray& operator /= (FloatC
     do_ms_inplace_op<FloatComplex, float> (a, s, mx_inline_div2);
   return a;
 }
 
 BSXFUN_STDOP_DEFS_MXLOOP (FloatComplexNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (FloatComplexNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, FloatComplexNDArray, mx_inline_pow)
+
diff --git a/liboctave/array/fCNDArray.h b/liboctave/array/fCNDArray.h
--- a/liboctave/array/fCNDArray.h
+++ b/liboctave/array/fCNDArray.h
@@ -178,8 +178,9 @@ extern OCTAVE_API FloatComplexNDArray& o
                                                     float s);
 
 BSXFUN_STDOP_DECLS (FloatComplexNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatComplexNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatComplexNDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -410,17 +410,18 @@ operator * (const FloatComplexRowVector&
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
-    F77_FUNC (xcdotu, XCDOTU) (len, F77_CONST_CMPLX_ARG (v.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CMPLX_ARG (&retval));
+    F77_FUNC (xcdotu, XCDOTU) (len, F77_CONST_CMPLX_ARG (v.data ()), 1,
+                               F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
 
 FloatComplexRowVector
 linspace (const FloatComplex& x1, const FloatComplex& x2, octave_idx_type n)
@@ -437,8 +438,9 @@ linspace (const FloatComplex& x1, const 
   FloatComplex delta = (x2 - x1) / (n - 1.0f);
   for (octave_idx_type i = 1; i < n-1; i++)
     retval(i) = x1 + static_cast<float> (i)*delta;
 
   retval(n-1) = x2;
 
   return retval;
 }
+
diff --git a/liboctave/array/fCRowVector.h b/liboctave/array/fCRowVector.h
--- a/liboctave/array/fCRowVector.h
+++ b/liboctave/array/fCRowVector.h
@@ -144,8 +144,9 @@ FloatComplex OCTAVE_API operator * (cons
 // other operations
 
 OCTAVE_API FloatComplexRowVector linspace (const FloatComplex& x1,
     const FloatComplex& x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexRowVector, FloatComplex)
 
 #endif
+
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -295,8 +295,9 @@ operator >> (std::istream& is, FloatColu
           if (is)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
+
diff --git a/liboctave/array/fColVector.h b/liboctave/array/fColVector.h
--- a/liboctave/array/fColVector.h
+++ b/liboctave/array/fColVector.h
@@ -121,8 +121,9 @@ public:
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatColumnVector real (const FloatComplexColumnVector& a);
 extern OCTAVE_API FloatColumnVector imag (const FloatComplexColumnVector& a);
 
 MARRAY_FORWARD_DEFS (MArray, FloatColumnVector, float)
 
 #endif
+
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -340,8 +340,9 @@ operator << (std::ostream& os, const Flo
             os << " " /* setw (field_width) */ << a.elem (i, i);
           else
             os << " " /* setw (field_width) */ << 0.0;
         }
       os << "\n";
     }
   return os;
 }
+
diff --git a/liboctave/array/fDiagMatrix.h b/liboctave/array/fDiagMatrix.h
--- a/liboctave/array/fDiagMatrix.h
+++ b/liboctave/array/fDiagMatrix.h
@@ -121,8 +121,9 @@ OCTAVE_API FloatDiagMatrix imag (const F
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 OCTAVE_API FloatDiagMatrix operator * (const FloatDiagMatrix& a,
                                        const FloatDiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, FloatDiagMatrix, float)
 
 #endif
+
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -646,17 +646,18 @@ FloatMatrix::inverse (MatrixType &mattyp
     }
 
   return ret;
 }
 
 FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
 {
-  octave::math::svd<FloatMatrix> result (*this, octave::math::svd<FloatMatrix>::Type::economy);
+  octave::math::svd<FloatMatrix> result (*this,
+                                         octave::math::svd<FloatMatrix>::Type::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatMatrix U = result.left_singular_matrix ();
   FloatMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -805,17 +806,18 @@ FloatMatrix::fourier (void) const
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier (void) const
 {
@@ -846,17 +848,18 @@ FloatMatrix::ifourier (void) const
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   return retval;
 }
 
@@ -890,17 +893,18 @@ FloatMatrix::fourier2d (void) const
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (dim_vector (nn, 1));
   pwsave = wsave.fortran_vec ();
@@ -956,17 +960,18 @@ FloatMatrix::ifourier2d (void) const
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
 
   for (octave_idx_type j = 0; j < nsamples; j++)
     {
       octave_quit ();
 
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]), F77_CMPLX_ARG (pwsave));
+      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
+                               F77_CMPLX_ARG (pwsave));
     }
 
   for (octave_idx_type j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
@@ -3107,8 +3112,9 @@ FloatMatrix linspace (const FloatColumnV
 MS_CMP_OPS (FloatMatrix, float)
 MS_BOOL_OPS (FloatMatrix, float)
 
 SM_CMP_OPS (float, FloatMatrix)
 SM_BOOL_OPS (float, FloatMatrix)
 
 MM_CMP_OPS (FloatMatrix, FloatMatrix)
 MM_BOOL_OPS (FloatMatrix, FloatMatrix)
+
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -413,8 +413,9 @@ MM_CMP_OP_DECLS (FloatMatrix, FloatMatri
 MM_BOOL_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, FloatMatrix, float)
 
 template <typename T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
+
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -867,8 +867,9 @@ NDND_BOOL_OPS (FloatNDArray, FloatNDArra
 BSXFUN_STDOP_DEFS_MXLOOP (FloatNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (FloatNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, FloatNDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatComplexNDArray,
                        FloatNDArray, mx_inline_pow)
 BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatNDArray,
                        FloatComplexNDArray, mx_inline_pow)
+
diff --git a/liboctave/array/fNDArray.h b/liboctave/array/fNDArray.h
--- a/liboctave/array/fNDArray.h
+++ b/liboctave/array/fNDArray.h
@@ -185,8 +185,9 @@ BSXFUN_STDREL_DECLS (FloatNDArray, OCTAV
 
 BSXFUN_OP_DECL (pow, FloatNDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatComplexNDArray,
                  FloatNDArray, OCTAVE_API)
 BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatNDArray,
                  FloatComplexNDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -306,8 +306,9 @@ operator * (const FloatRowVector& v, con
 }
 
 FloatComplex
 operator * (const FloatRowVector& v, const FloatComplexColumnVector& a)
 {
   FloatComplexRowVector tmp (v);
   return tmp * a;
 }
+
diff --git a/liboctave/array/fRowVector.h b/liboctave/array/fRowVector.h
--- a/liboctave/array/fRowVector.h
+++ b/liboctave/array/fRowVector.h
@@ -118,8 +118,9 @@ Complex OCTAVE_API operator * (const Flo
 
 // other operations
 
 OCTAVE_API FloatRowVector linspace (float x1, float x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, FloatRowVector, float)
 
 #endif
+
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -110,17 +110,21 @@ std::ostream&
 idx_vector::idx_colon_rep::print (std::ostream& os) const
 {
   return os << ":";
 }
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
-  : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
+  : start(_start),
+    len (_step ? std::max ((_limit - _start) / _step,
+                           static_cast<octave_idx_type> (0))
+               : -1),
+    step (_step)
 {
   if (len < 0)
     err_invalid_range ();
   if (start < 0)
     octave::err_invalid_index (start);
   if (step < 0 && start + (len-1)*step < 0)
     octave::err_invalid_index (start + (len-1)*step);
 }
@@ -1320,8 +1324,9 @@ INSTANTIATE_SCALAR_VECTOR_REP_CONST (oct
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint64)
 
 /*
 
 %!error id=Octave:index-out-of-bounds 1(find ([1,1] != 0))
 %!assert ((1:3)(find ([1,0,1] != 0)), [1,3])
 
 */
+
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -175,18 +175,20 @@ private:
     octave_idx_type xelem (octave_idx_type i) const
     { return start + i * step; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
-    { return len ? std::max (n, (start + 1 + (step < 0 ? 0 : step * (len - 1))))
-                 : n; }
+    {
+      return len ? std::max (n, start + 1 + (step < 0 ? 0 : step * (len - 1)))
+                 : n;
+    }
 
     idx_class_type idx_class (void) const { return class_range; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
@@ -1032,8 +1034,9 @@ public:
 
 private:
 
   idx_base_rep *rep;
 
 };
 
 #endif
+
diff --git a/liboctave/array/int16NDArray.cc b/liboctave/array/int16NDArray.cc
--- a/liboctave/array/int16NDArray.cc
+++ b/liboctave/array/int16NDArray.cc
@@ -53,8 +53,9 @@ NDND_BOOL_OPS (int16NDArray, int16NDArra
 MINMAX_FCNS (int16NDArray, octave_int16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int16NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int16NDArray, mx_inline_pow)
 
 BSXFUN_POW_MIXED_MXLOOP (int16NDArray)
+
diff --git a/liboctave/array/int16NDArray.h b/liboctave/array/int16NDArray.h
--- a/liboctave/array/int16NDArray.h
+++ b/liboctave/array/int16NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, int16NDArra
 
 MINMAX_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int16NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(int16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int16NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/int32NDArray.cc b/liboctave/array/int32NDArray.cc
--- a/liboctave/array/int32NDArray.cc
+++ b/liboctave/array/int32NDArray.cc
@@ -52,8 +52,9 @@ NDND_BOOL_OPS (int32NDArray, int32NDArra
 
 MINMAX_FCNS (int32NDArray, octave_int32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int32NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int32NDArray, mx_inline_pow)
 BSXFUN_POW_MIXED_MXLOOP (int32NDArray)
+
diff --git a/liboctave/array/int32NDArray.h b/liboctave/array/int32NDArray.h
--- a/liboctave/array/int32NDArray.h
+++ b/liboctave/array/int32NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, int32NDArra
 
 MINMAX_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int32NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(int32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int32NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/int64NDArray.cc b/liboctave/array/int64NDArray.cc
--- a/liboctave/array/int64NDArray.cc
+++ b/liboctave/array/int64NDArray.cc
@@ -53,8 +53,9 @@ NDND_BOOL_OPS (int64NDArray, int64NDArra
 MINMAX_FCNS (int64NDArray, octave_int64)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int64NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int64NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int64NDArray, mx_inline_pow)
 
 BSXFUN_POW_MIXED_MXLOOP (int64NDArray)
+
diff --git a/liboctave/array/int64NDArray.h b/liboctave/array/int64NDArray.h
--- a/liboctave/array/int64NDArray.h
+++ b/liboctave/array/int64NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, int64NDArra
 
 MINMAX_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int64NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(int64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int64NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/int8NDArray.cc b/liboctave/array/int8NDArray.cc
--- a/liboctave/array/int8NDArray.cc
+++ b/liboctave/array/int8NDArray.cc
@@ -52,8 +52,9 @@ NDND_BOOL_OPS (int8NDArray, int8NDArray)
 
 MINMAX_FCNS (int8NDArray, octave_int8)
 
 BSXFUN_STDOP_DEFS_MXLOOP (int8NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (int8NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, int8NDArray, mx_inline_pow)
 BSXFUN_POW_MIXED_MXLOOP (int8NDArray)
+
diff --git a/liboctave/array/int8NDArray.h b/liboctave/array/int8NDArray.h
--- a/liboctave/array/int8NDArray.h
+++ b/liboctave/array/int8NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, int8NDArray
 
 MINMAX_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (int8NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(int8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (int8NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -294,8 +294,9 @@ intNDArray<T>::cummin (Array<octave_idx_
 }
 
 template <typename T>
 intNDArray<T>
 intNDArray<T>::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<T> (*this, dim, order, mx_inline_diff);
 }
+
diff --git a/liboctave/array/intNDArray.h b/liboctave/array/intNDArray.h
--- a/liboctave/array/intNDArray.h
+++ b/liboctave/array/intNDArray.h
@@ -127,8 +127,9 @@ public:
 
 template <typename T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
 template <typename T>
 std::istream& operator >> (std::istream& is, intNDArray<T>& a);
 
 #endif
+
diff --git a/liboctave/array/uint16NDArray.cc b/liboctave/array/uint16NDArray.cc
--- a/liboctave/array/uint16NDArray.cc
+++ b/liboctave/array/uint16NDArray.cc
@@ -52,8 +52,9 @@ NDND_BOOL_OPS (uint16NDArray, uint16NDAr
 
 MINMAX_FCNS (uint16NDArray, octave_uint16)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint16NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint16NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, uint16NDArray, mx_inline_pow)
 BSXFUN_POW_MIXED_MXLOOP (uint16NDArray)
+
diff --git a/liboctave/array/uint16NDArray.h b/liboctave/array/uint16NDArray.h
--- a/liboctave/array/uint16NDArray.h
+++ b/liboctave/array/uint16NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, uint16NDArr
 
 MINMAX_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint16NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(uint16NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint16NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/uint32NDArray.cc b/liboctave/array/uint32NDArray.cc
--- a/liboctave/array/uint32NDArray.cc
+++ b/liboctave/array/uint32NDArray.cc
@@ -52,8 +52,9 @@ NDND_BOOL_OPS (uint32NDArray, uint32NDAr
 
 MINMAX_FCNS (uint32NDArray, octave_uint32)
 
 BSXFUN_STDOP_DEFS_MXLOOP (uint32NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (uint32NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, uint32NDArray, mx_inline_pow)
 BSXFUN_POW_MIXED_MXLOOP (uint32NDArray)
+
diff --git a/liboctave/array/uint32NDArray.h b/liboctave/array/uint32NDArray.h
--- a/liboctave/array/uint32NDArray.h
+++ b/liboctave/array/uint32NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, uint32NDArr
 
 MINMAX_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint32NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(uint32NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint32NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/uint64NDArray.h b/liboctave/array/uint64NDArray.h
--- a/liboctave/array/uint64NDArray.h
+++ b/liboctave/array/uint64NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, uint64NDArr
 
 MINMAX_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint64NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(uint64NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint64NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/array/uint8NDArray.h b/liboctave/array/uint8NDArray.h
--- a/liboctave/array/uint8NDArray.h
+++ b/liboctave/array/uint8NDArray.h
@@ -45,8 +45,9 @@ MARRAY_FORWARD_DEFS (MArray, uint8NDArra
 
 MINMAX_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 BSXFUN_STDOP_DECLS (uint8NDArray, OCTAVE_API)
 BSXFUN_MIXED_INT_DECLS(uint8NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (uint8NDArray, OCTAVE_API)
 
 #endif
+
diff --git a/liboctave/cruft/misc/blaswrap.c b/liboctave/cruft/misc/blaswrap.c
--- a/liboctave/cruft/misc/blaswrap.c
+++ b/liboctave/cruft/misc/blaswrap.c
@@ -287,8 +287,9 @@ static void initVecLibWrappers (void)
 static void finiVecLibWrappers (void)
 {
   if (apple_vecLib)
     dlclose (apple_vecLib);
   apple_vecLib = 0;
 }
 
 #endif /* USE_BLASWRAP */
+
diff --git a/liboctave/cruft/misc/cquit.c b/liboctave/cruft/misc/cquit.c
--- a/liboctave/cruft/misc/cquit.c
+++ b/liboctave/cruft/misc/cquit.c
@@ -59,8 +59,9 @@ sig_atomic_t octave_interrupt_state = 0;
 
 sig_atomic_t octave_exception_state = 0;
 
 sig_atomic_t octave_exit_exception_status = 0;
 
 sig_atomic_t octave_exit_exception_safe_to_return = 0;
 
 volatile sig_atomic_t octave_signal_caught = 0;
+
diff --git a/liboctave/cruft/misc/f77-extern.cc b/liboctave/cruft/misc/f77-extern.cc
--- a/liboctave/cruft/misc/f77-extern.cc
+++ b/liboctave/cruft/misc/f77-extern.cc
@@ -28,8 +28,9 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 
 // This whole file is a kluge just to avoid unresolved symbol errors
 // when creating shared versions of libcruft.
 
 // So we can check to see if an exception has occurred.
 int f77_exception_encountered = 0;
+
diff --git a/liboctave/cruft/misc/f77-fcn.c b/liboctave/cruft/misc/f77-fcn.c
--- a/liboctave/cruft/misc/f77-fcn.c
+++ b/liboctave/cruft/misc/f77-fcn.c
@@ -63,8 +63,9 @@ F77_FUNC (xstopx, XSTOPX) (const char *s
   /* Skip printing message if it is just a single blank character.  */
   if (s && slen > 0 && ! (slen == 1 && *s == ' '))
     (*current_liboctave_error_handler) ("%.*s", slen, s);
 
   octave_jump_to_enclosing_context ();
 
   F77_NORETURN (0)
 }
+
diff --git a/liboctave/cruft/misc/f77-fcn.h b/liboctave/cruft/misc/f77-fcn.h
--- a/liboctave/cruft/misc/f77-fcn.h
+++ b/liboctave/cruft/misc/f77-fcn.h
@@ -363,8 +363,9 @@ F77_RET_T
 F77_FUNC (xstopx, XSTOPX) (F77_CONST_CHAR_ARG_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/liboctave/cruft/misc/lo-error.c b/liboctave/cruft/misc/lo-error.c
--- a/liboctave/cruft/misc/lo-error.c
+++ b/liboctave/cruft/misc/lo-error.c
@@ -29,30 +29,30 @@ along with Octave; see the file COPYING.
 #include <stdlib.h>
 
 #include "lo-error.h"
 
 /* Having this file in this directory is a kluge to avoid unresolved
    symbol errors when creating shared versions of libcruft. */
 
 /* Pointer to the current error handling function. */
-OCTAVE_NORETURN liboctave_error_handler current_liboctave_error_handler
-  = liboctave_fatal;
+OCTAVE_NORETURN liboctave_error_handler
+  current_liboctave_error_handler = liboctave_fatal;
 
 /* Pointer to the current error_with_id handling function. */
-OCTAVE_NORETURN liboctave_error_with_id_handler current_liboctave_error_with_id_handler
-  = liboctave_fatal_with_id;
+OCTAVE_NORETURN liboctave_error_with_id_handler
+  current_liboctave_error_with_id_handler = liboctave_fatal_with_id;
 
 /* Pointer to the current warning handler. */
-liboctave_warning_handler current_liboctave_warning_handler
-  = liboctave_warning;
+liboctave_warning_handler
+  current_liboctave_warning_handler = liboctave_warning;
 
 /* Pointer to the current warning_with_id handler. */
-liboctave_warning_with_id_handler current_liboctave_warning_with_id_handler
-  = liboctave_warning_with_id;
+liboctave_warning_with_id_handler
+  current_liboctave_warning_with_id_handler = liboctave_warning_with_id;
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   if (name)
     fprintf (stderr, "%s: ", name);
 
   vfprintf (stderr, fmt, args);
@@ -65,17 +65,18 @@ set_liboctave_error_handler (OCTAVE_NORE
 {
   if (f)
     current_liboctave_error_handler = f;
   else
     current_liboctave_error_handler = liboctave_fatal;
 }
 
 void
-set_liboctave_error_with_id_handler (OCTAVE_NORETURN liboctave_error_with_id_handler f)
+set_liboctave_error_with_id_handler (OCTAVE_NORETURN
+                                     liboctave_error_with_id_handler f)
 {
   if (f)
     current_liboctave_error_with_id_handler = f;
   else
     current_liboctave_error_with_id_handler = liboctave_fatal_with_id;
 }
 
 void
@@ -134,8 +135,9 @@ liboctave_warning_with_id (const char *i
 {
   octave_unused_parameter (id);
 
   va_list args;
   va_start (args, fmt);
   verror ("warning", fmt, args);
   va_end (args);
 }
+
diff --git a/liboctave/cruft/misc/lo-error.h b/liboctave/cruft/misc/lo-error.h
--- a/liboctave/cruft/misc/lo-error.h
+++ b/liboctave/cruft/misc/lo-error.h
@@ -38,31 +38,36 @@ void liboctave_fatal_with_id (const char
 extern void
 liboctave_warning (const char *fmt, ...);
 
 extern void
 liboctave_warning_with_id (const char *id, const char *fmt, ...);
 
 typedef void (*liboctave_error_handler) (const char *, ...);
 
-typedef void (*liboctave_error_with_id_handler) (const char *, const char *, ...);
+typedef void (*liboctave_error_with_id_handler) (const char *, const char *,
+                                                 ...);
 
 typedef void (*liboctave_warning_handler) (const char *, ...);
 
-typedef void (*liboctave_warning_with_id_handler) (const char *, const char *, ...);
+typedef void (*liboctave_warning_with_id_handler) (const char *, const char *,
+                                                   ...);
 
 /* Would be nice to make these pointers private, but we want to share
    them among all the liboctave classes. */
-OCTAVE_NORETURN OCTAVE_API extern liboctave_error_handler current_liboctave_error_handler;
+OCTAVE_NORETURN OCTAVE_API extern liboctave_error_handler
+  current_liboctave_error_handler;
 
-OCTAVE_NORETURN OCTAVE_API extern liboctave_error_with_id_handler current_liboctave_error_with_id_handler;
+OCTAVE_NORETURN OCTAVE_API extern liboctave_error_with_id_handler
+  current_liboctave_error_with_id_handler;
 
 OCTAVE_API extern liboctave_warning_handler current_liboctave_warning_handler;
 
-OCTAVE_API extern liboctave_warning_with_id_handler current_liboctave_warning_with_id_handler;
+OCTAVE_API extern liboctave_warning_with_id_handler
+  current_liboctave_warning_with_id_handler;
 
 OCTAVE_API extern void
 set_liboctave_error_handler (OCTAVE_NORETURN liboctave_error_handler f);
 
 OCTAVE_API extern void
 set_liboctave_error_with_id_handler (OCTAVE_NORETURN liboctave_error_with_id_handler f);
 
 OCTAVE_API extern void
@@ -71,8 +76,9 @@ set_liboctave_warning_handler (liboctave
 OCTAVE_API extern void
 set_liboctave_warning_with_id_handler (liboctave_warning_with_id_handler f);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/liboctave/cruft/misc/quit.cc b/liboctave/cruft/misc/quit.cc
--- a/liboctave/cruft/misc/quit.cc
+++ b/liboctave/cruft/misc/quit.cc
@@ -111,8 +111,9 @@ octave_rethrow_exception (void)
                              octave_exit_exception_safe_to_return);
           break;
 
         default:
           break;
         }
     }
 }
+
diff --git a/liboctave/cruft/misc/quit.h b/liboctave/cruft/misc/quit.h
--- a/liboctave/cruft/misc/quit.h
+++ b/liboctave/cruft/misc/quit.h
@@ -314,8 +314,9 @@ inline void octave_quit (void)
 
 extern OCTAVE_API void (*octave_signal_hook) (void);
 extern OCTAVE_API void (*octave_interrupt_hook) (void);
 extern OCTAVE_API void (*octave_bad_alloc_hook) (void);
 
 #endif
 
 #endif
+
diff --git a/liboctave/liboctave-build-info.h b/liboctave/liboctave-build-info.h
--- a/liboctave/liboctave-build-info.h
+++ b/liboctave/liboctave-build-info.h
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include <ctime>
 
 #include <string>
 
 extern OCTAVE_API std::string liboctave_hg_id (void);
 
 #endif
+
diff --git a/liboctave/liboctave-build-info.in.cc b/liboctave/liboctave-build-info.in.cc
--- a/liboctave/liboctave-build-info.in.cc
+++ b/liboctave/liboctave-build-info.in.cc
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #include "liboctave-build-info.h"
 
 std::string
 liboctave_hg_id (void)
 {
   return "%OCTAVE_HG_ID%";
 }
+
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -494,8 +494,9 @@ operator << (std::ostream& os, const Col
   os << a.Alpha << " " << a.Beta << "\n\n"
      << a.r << "\n\n"
      << a.q << "\n\n"
      << a.A << "\n"
      << a.B << "\n";
 
   return os;
 }
+
diff --git a/liboctave/numeric/CollocWt.h b/liboctave/numeric/CollocWt.h
--- a/liboctave/numeric/CollocWt.h
+++ b/liboctave/numeric/CollocWt.h
@@ -185,8 +185,9 @@ protected:
   bool initialized;
 
   void init (void);
 
   void error (const char *msg);
 };
 
 #endif
+
diff --git a/liboctave/numeric/DAE.h b/liboctave/numeric/DAE.h
--- a/liboctave/numeric/DAE.h
+++ b/liboctave/numeric/DAE.h
@@ -56,8 +56,9 @@ public:
       }
     return *this;
   }
 
   virtual ~DAE (void) { }
 };
 
 #endif
+
diff --git a/liboctave/numeric/DAEFunc.h b/liboctave/numeric/DAEFunc.h
--- a/liboctave/numeric/DAEFunc.h
+++ b/liboctave/numeric/DAEFunc.h
@@ -97,8 +97,9 @@ protected:
   // after any internal data has changed.  Derived classes may use
   // this information (and change it) to know when to (re)initialize
   // their own internal data related to this object.
 
   bool reset;
 };
 
 #endif
+
diff --git a/liboctave/numeric/DAERT.h b/liboctave/numeric/DAERT.h
--- a/liboctave/numeric/DAERT.h
+++ b/liboctave/numeric/DAERT.h
@@ -63,8 +63,9 @@ public:
   void initialize (const ColumnVector& xx, const ColumnVector& xxdot,
                    double tt)
   {
     base_diff_alg_eqn::initialize (xx, xxdot, tt);
   }
 };
 
 #endif
+
diff --git a/liboctave/numeric/DAERTFunc.h b/liboctave/numeric/DAERTFunc.h
--- a/liboctave/numeric/DAERTFunc.h
+++ b/liboctave/numeric/DAERTFunc.h
@@ -82,8 +82,9 @@ protected:
   // after any internal data has changed.  Derived classes may use
   // this information (and change it) to know when to (re)initialize
   // their own internal data related to this object.
 
   bool reset;
 };
 
 #endif
+
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -326,17 +326,17 @@ DASPK::do_integrate (double tout)
               {
                 // FIXME: Should this be a warning?
                 (*current_liboctave_error_handler)
                   ("daspk: inequality constraint types size mismatch");
                 integration_error = true;
                 return retval;
               }
           }
-          // Fall through...
+        // Fall through...
 
         case 0:
         case 2:
           info(9) = eiq;
           break;
 
         default:
           // FIXME: Should this be a warning?
@@ -783,8 +783,9 @@ DASPK::error_message (void) const
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
 }
+
diff --git a/liboctave/numeric/DASPK.h b/liboctave/numeric/DASPK.h
--- a/liboctave/numeric/DASPK.h
+++ b/liboctave/numeric/DASPK.h
@@ -76,8 +76,9 @@ private:
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 };
 
 #endif
+
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -642,8 +642,9 @@ DASRT::error_message (void) const
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
 }
+
diff --git a/liboctave/numeric/DASRT.h b/liboctave/numeric/DASRT.h
--- a/liboctave/numeric/DASRT.h
+++ b/liboctave/numeric/DASRT.h
@@ -118,8 +118,9 @@ private:
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 
   void integrate (double t);
 };
 
 #endif
+
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -574,8 +574,9 @@ DASSL::error_message (void) const
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
 }
+
diff --git a/liboctave/numeric/DASSL.h b/liboctave/numeric/DASSL.h
--- a/liboctave/numeric/DASSL.h
+++ b/liboctave/numeric/DASSL.h
@@ -76,8 +76,9 @@ private:
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 };
 
 #endif
+
diff --git a/liboctave/numeric/DET.h b/liboctave/numeric/DET.h
--- a/liboctave/numeric/DET.h
+++ b/liboctave/numeric/DET.h
@@ -85,8 +85,9 @@ private:
 
 // Provide the old types by typedefs.
 typedef base_det<double> DET;
 typedef base_det<float> FloatDET;
 typedef base_det<Complex> ComplexDET;
 typedef base_det<FloatComplex> FloatComplexDET;
 
 #endif
+
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -749,8 +749,9 @@ EIG::hermitian_init (const ComplexMatrix
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = ComplexColumnVector (wr);
   v = calc_rev ? ComplexMatrix (atmp) : ComplexMatrix ();
   w = calc_lev ? ComplexMatrix (atmp) : ComplexMatrix ();
 
   return info;
 }
+
diff --git a/liboctave/numeric/EIG.h b/liboctave/numeric/EIG.h
--- a/liboctave/numeric/EIG.h
+++ b/liboctave/numeric/EIG.h
@@ -149,8 +149,9 @@ private:
 
   octave_idx_type hermitian_init (const ComplexMatrix& a,
                                   const ComplexMatrix& b,
                                   bool calc_rev, bool calc_lev);
 
 };
 
 #endif
+
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -500,8 +500,9 @@ LSODE::do_integrate (const ColumnVector&
 
           if (integration_error)
             return retval;
         }
     }
 
   return retval;
 }
+
diff --git a/liboctave/numeric/LSODE.h b/liboctave/numeric/LSODE.h
--- a/liboctave/numeric/LSODE.h
+++ b/liboctave/numeric/LSODE.h
@@ -72,8 +72,9 @@ private:
   Array<double> rwork;
 
   double rel_tol;
 
   Array<double> abs_tol;
 };
 
 #endif
+
diff --git a/liboctave/numeric/ODE.h b/liboctave/numeric/ODE.h
--- a/liboctave/numeric/ODE.h
+++ b/liboctave/numeric/ODE.h
@@ -109,8 +109,9 @@ public:
                             const ColumnVector& ttcrit)
   {
     initialize (x0, t0);
     return do_integrate (tt, ttcrit);
   }
 };
 
 #endif
+
diff --git a/liboctave/numeric/ODEFunc.h b/liboctave/numeric/ODEFunc.h
--- a/liboctave/numeric/ODEFunc.h
+++ b/liboctave/numeric/ODEFunc.h
@@ -88,8 +88,9 @@ protected:
   // after any internal data has changed.  Derived classes may use
   // this information (and change it) to know when to (re)initialize
   // their own internal data related to this object.
 
   bool reset;
 };
 
 #endif
+
diff --git a/liboctave/numeric/ODES.cc b/liboctave/numeric/ODES.cc
--- a/liboctave/numeric/ODES.cc
+++ b/liboctave/numeric/ODES.cc
@@ -37,8 +37,9 @@ ODES::initialize (const ColumnVector& xx
 void
 ODES::initialize (const ColumnVector& xx, double tt,
                   const ColumnVector& xtheta)
 {
   base_diff_eqn::initialize (xx, tt);
   xdot = ColumnVector (xx.numel (), 0.0);
   theta = xtheta;
 }
+
diff --git a/liboctave/numeric/ODES.h b/liboctave/numeric/ODES.h
--- a/liboctave/numeric/ODES.h
+++ b/liboctave/numeric/ODES.h
@@ -74,8 +74,9 @@ protected:
   // State vector time derivatives.
   ColumnVector xdot;
 
   // Parameter vector.
   ColumnVector theta;
 };
 
 #endif
+
diff --git a/liboctave/numeric/ODESFunc.h b/liboctave/numeric/ODESFunc.h
--- a/liboctave/numeric/ODESFunc.h
+++ b/liboctave/numeric/ODESFunc.h
@@ -102,8 +102,9 @@ public:
 protected:
 
   ODES_fsub fsub;
   ODES_bsub bsub;
   ODES_jsub jsub;
 };
 
 #endif
+
diff --git a/liboctave/numeric/Quad.cc b/liboctave/numeric/Quad.cc
--- a/liboctave/numeric/Quad.cc
+++ b/liboctave/numeric/Quad.cc
@@ -294,8 +294,9 @@ FloatIndefQuad::do_integrate (octave_idx
   float rel_tol = single_precision_relative_tolerance ();
 
   F77_XFCN (qagi, QAGI, (float_user_function, bound, inf, abs_tol, rel_tol,
                          result, abserr, neval, ier, leniw, lenw,
                          last, piwork, pwork));
 
   return result;
 }
+
diff --git a/liboctave/numeric/Quad.h b/liboctave/numeric/Quad.h
--- a/liboctave/numeric/Quad.h
+++ b/liboctave/numeric/Quad.h
@@ -169,18 +169,18 @@ public:
   IndefQuad (integrand_fcn fcn, double b, IntegralType t)
     : Quad (fcn), bound (b), type (t) { }
 
   ~IndefQuad (void) { }
 
   double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                        double& abserr);
 
-OCTAVE_NORETURN float do_integrate (octave_idx_type& ier,
-                                    octave_idx_type& neval, float& abserr);
+  OCTAVE_NORETURN float do_integrate (octave_idx_type& ier,
+                                      octave_idx_type& neval, float& abserr);
 
 private:
 
   double bound;
   IntegralType type;
 };
 
 class
@@ -244,8 +244,9 @@ public:
 
 private:
 
   float bound;
   IntegralType type;
 };
 
 #endif
+
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -225,8 +225,9 @@ namespace octave
 
     template class aepbalance<FloatMatrix>;
 
     template class aepbalance<ComplexMatrix>;
 
     template class aepbalance<FloatComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/aepbalance.h b/liboctave/numeric/aepbalance.h
--- a/liboctave/numeric/aepbalance.h
+++ b/liboctave/numeric/aepbalance.h
@@ -119,8 +119,9 @@ namespace octave
       octave_idx_type ilo;
       octave_idx_type ihi;
       char job;
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/base-dae.h b/liboctave/numeric/base-dae.h
--- a/liboctave/numeric/base-dae.h
+++ b/liboctave/numeric/base-dae.h
@@ -73,8 +73,9 @@ public:
   ColumnVector state_derivative (void) { return xdot; }
 
 protected:
 
   ColumnVector xdot;
 };
 
 #endif
+
diff --git a/liboctave/numeric/base-de.h b/liboctave/numeric/base-de.h
--- a/liboctave/numeric/base-de.h
+++ b/liboctave/numeric/base-de.h
@@ -114,8 +114,9 @@ protected:
   bool restart;
 
   bool integration_error;
 
   octave_idx_type istate;
 };
 
 #endif
+
diff --git a/liboctave/numeric/base-min.h b/liboctave/numeric/base-min.h
--- a/liboctave/numeric/base-min.h
+++ b/liboctave/numeric/base-min.h
@@ -119,8 +119,9 @@ public:
   octave_idx_type size (void) const { return x.numel (); }
 
 protected:
 
   ColumnVector x;
 };
 
 #endif
+
diff --git a/liboctave/numeric/bsxfun-decl.h b/liboctave/numeric/bsxfun-decl.h
--- a/liboctave/numeric/bsxfun-decl.h
+++ b/liboctave/numeric/bsxfun-decl.h
@@ -54,8 +54,9 @@ along with Octave; see the file COPYING.
   BSXFUN_REL_DECL (eq, ARRAY, API)              \
   BSXFUN_REL_DECL (ne, ARRAY, API)              \
   BSXFUN_REL_DECL (lt, ARRAY, API)              \
   BSXFUN_REL_DECL (le, ARRAY, API)              \
   BSXFUN_REL_DECL (gt, ARRAY, API)              \
   BSXFUN_REL_DECL (ge, ARRAY, API)
 
 #endif
+
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -253,8 +253,9 @@ do_inplace_bsxfun_op (Array<R>& r, const
 //For bsxfun power with mixed integer/float types
 #define BSXFUN_POW_MIXED_MXLOOP(INT_TYPE)                               \
   BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, INT_TYPE, NDArray, mx_inline_pow) \
   BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, INT_TYPE, FloatNDArray, mx_inline_pow) \
   BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, NDArray, INT_TYPE,  mx_inline_pow) \
   BSXFUN_OP2_DEF_MXLOOP (pow, INT_TYPE, FloatNDArray, INT_TYPE, mx_inline_pow)
 
 #endif
+
diff --git a/liboctave/numeric/bsxfun.h b/liboctave/numeric/bsxfun.h
--- a/liboctave/numeric/bsxfun.h
+++ b/liboctave/numeric/bsxfun.h
@@ -82,8 +82,9 @@ is_valid_inplace_bsxfun (const std::stri
      name.c_str ());
 
   return true;
 }
 
 #include "bsxfun-defs.cc"
 
 #endif
+
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -791,35 +791,38 @@ namespace octave
       Complex *h = chol_mat.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
         anorm = xnorm (a, 1);
 
       if (is_upper)
-        F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_DBLE_CMPLX_ARG (h), n, info
+        F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                   F77_DBLE_CMPLX_ARG (h), n, info
                                    F77_CHAR_ARG_LEN (1)));
       else
-        F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, F77_DBLE_CMPLX_ARG (h), n, info
+        F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                                   F77_DBLE_CMPLX_ARG (h), n, info
                                    F77_CHAR_ARG_LEN (1)));
 
       xrcond = 0.0;
       if (info > 0)
         chol_mat.resize (info - 1, info - 1);
       else if (calc_cond)
         {
           octave_idx_type zpocon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           Array<Complex> z (dim_vector (2*n, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (n, 1));
           double *prz = rz.fortran_vec ();
-          F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_DBLE_CMPLX_ARG (h),
+          F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                     F77_DBLE_CMPLX_ARG (h),
                                      n, anorm, xrcond, F77_DBLE_CMPLX_ARG (pz), prz, zpocon_info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (zpocon_info != 0)
             info = -1;
         }
 
       return info;
@@ -835,17 +838,18 @@ namespace octave
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zch1up, ZCH1UP, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (zch1up, ZCH1UP, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
     }
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::downdate (const ComplexColumnVector& u)
     {
       octave_idx_type info = -1;
@@ -854,17 +858,18 @@ namespace octave
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zch1dn, ZCH1DN, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (zch1dn, ZCH1DN, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
       return info;
     }
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::insert_sym (const ComplexColumnVector& u,
@@ -880,34 +885,36 @@ namespace octave
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       chol_mat.resize (n+1, n+1);
 
-      F77_XFCN (zchinx, ZCHINX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (zchinx, ZCHINX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  j + 1, F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<ComplexMatrix>::delete_sym (octave_idx_type j)
     {
       octave_idx_type n = chol_mat.rows ();
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchdex, ZCHDEX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (zchdex, ZCHDEX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  j + 1, rw));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<ComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
@@ -915,17 +922,18 @@ namespace octave
       octave_idx_type n = chol_mat.rows ();
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, n);
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchshx, ZCHSHX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (zchshx, ZCHSHX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
     }
 
 #endif
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::init (const FloatComplexMatrix& a, bool upper,
@@ -962,20 +970,22 @@ namespace octave
       FloatComplex *h = chol_mat.fortran_vec ();
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
         anorm = xnorm (a, 1);
 
       if (is_upper)
-        F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_CMPLX_ARG (h), n, info
+        F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_CMPLX_ARG (h),
+                                   n, info
                                    F77_CHAR_ARG_LEN (1)));
       else
-        F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, F77_CMPLX_ARG (h), n, info
+        F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, F77_CMPLX_ARG (h),
+                                   n, info
                                    F77_CHAR_ARG_LEN (1)));
 
       xrcond = 0.0;
       if (info > 0)
         chol_mat.resize (info - 1, info - 1);
       else if (calc_cond)
         {
           octave_idx_type cpocon_info = 0;
@@ -1006,17 +1016,18 @@ namespace octave
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cch1up, CCH1UP, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (cch1up, CCH1UP, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  F77_CMPLX_ARG (utmp.fortran_vec ()), rw));
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::downdate (const FloatComplexColumnVector& u)
     {
       octave_idx_type info = -1;
@@ -1025,17 +1036,18 @@ namespace octave
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cch1dn, CCH1DN, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (cch1dn, CCH1DN, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  F77_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
       return info;
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::insert_sym (const FloatComplexColumnVector& u,
@@ -1051,34 +1063,36 @@ namespace octave
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       chol_mat.resize (n+1, n+1);
 
-      F77_XFCN (cchinx, CCHINX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (cchinx, CCHINX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  j + 1, F77_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::delete_sym (octave_idx_type j)
     {
       octave_idx_type n = chol_mat.rows ();
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchdex, CCHDEX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (cchdex, CCHDEX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  j + 1, rw));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
@@ -1086,17 +1100,18 @@ namespace octave
       octave_idx_type n = chol_mat.rows ();
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchshx, CCHSHX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+      F77_XFCN (cchshx, CCHSHX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
+                                 chol_mat.rows (),
                                  i + 1, j + 1, F77_CMPLX_ARG (w), rw));
     }
 
 #endif
 
     // Instantiations we need.
 
     template class chol<Matrix>;
@@ -1115,8 +1130,9 @@ namespace octave
 
     template FloatMatrix
     chol2inv<FloatMatrix> (const FloatMatrix& r);
 
     template FloatComplexMatrix
     chol2inv<FloatComplexMatrix> (const FloatComplexMatrix& r);
   }
 }
+
diff --git a/liboctave/numeric/chol.h b/liboctave/numeric/chol.h
--- a/liboctave/numeric/chol.h
+++ b/liboctave/numeric/chol.h
@@ -100,8 +100,9 @@ namespace octave
 
     template <typename T>
     T
     chol2inv (const T& r);
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -171,18 +171,20 @@ vector_product (const SparseComplexMatri
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           nr, nc, 1.0,  F77_CONST_DBLE_CMPLX_ARG (m.data ()), nr,
-                           F77_CONST_DBLE_CMPLX_ARG (x), 1, 0.0, F77_DBLE_CMPLX_ARG (y), 1
+                           nr, nc, 1.0, F77_CONST_DBLE_CMPLX_ARG (m.data ()),
+                           nr,
+                           F77_CONST_DBLE_CMPLX_ARG (x), 1, 0.0,
+                           F77_DBLE_CMPLX_ARG (y), 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("eigs: unrecoverable error in zgemv");
 
   return true;
 }
 
@@ -633,17 +635,18 @@ EigsRealSymmetricMatrix (const M& m, con
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k < 1 || k > n - 2)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
@@ -651,17 +654,18 @@ EigsRealSymmetricMatrix (const M& m, con
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -763,17 +767,17 @@ EigsRealSymmetricMatrix (const M& m, con
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
-                                    workd + iptr(1) - 1))
+                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dsaupd", info);
 
@@ -895,17 +899,18 @@ EigsRealSymmetricMatrixShift (const M& m
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
@@ -924,17 +929,18 @@ EigsRealSymmetricMatrixShift (const M& m
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -1181,17 +1187,18 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (! have_sigma)
     {
@@ -1427,17 +1434,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
@@ -1445,17 +1453,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -1557,17 +1566,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
-                                    workd + iptr(1) - 1))
+                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in dnaupd", info);
 
@@ -1749,17 +1758,18 @@ EigsRealNonSymmetricMatrixShift (const M
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
@@ -1767,17 +1777,18 @@ EigsRealNonSymmetricMatrixShift (const M
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -2078,17 +2089,18 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (! have_sigma)
     {
@@ -2375,17 +2387,18 @@ EigsComplexNonSymmetricMatrix (const M& 
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
@@ -2393,17 +2406,18 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA"
       && typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI"
       && typ != "SI")
     (*current_liboctave_error_handler) ("eigs: unrecognized sigma value");
@@ -2463,19 +2477,21 @@ EigsComplexNonSymmetricMatrix (const M& 
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
-         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
+         F77_CONST_CHAR_ARG2 (typ.c_str (), 2),
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+         iparam, ipntr,
+         F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+         info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
@@ -2505,17 +2521,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
               mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
           else if (! vector_product (m, workd + iptr(0) - 1,
-                                    workd + iptr(1) - 1))
+                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             (*current_liboctave_error_handler)
               ("eigs: error %d in znaupd", info);
 
@@ -2540,21 +2556,25 @@ EigsComplexNonSymmetricMatrix (const M& 
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d),
+     F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma),
+     F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
-     F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+     iparam, ipntr,
+     F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+     info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
@@ -2651,17 +2671,18 @@ EigsComplexNonSymmetricMatrixShift (cons
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (have_b && cholB && ! permB.is_empty ())
     {
@@ -2669,17 +2690,18 @@ EigsComplexNonSymmetricMatrixShift (cons
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type bidx = static_cast<octave_idx_type> (permB(i));
 
-          if (checked(bidx) || bidx < 0 || bidx >= n || octave::math::x_nint (bidx) != bidx)
+          if (checked(bidx) || bidx < 0 || bidx >= n
+              || octave::math::x_nint (bidx) != bidx)
             (*current_liboctave_error_handler) ("eigs: permB vector invalid");
         }
     }
 
   char bmat = 'I';
   if (have_b)
     bmat = 'G';
 
@@ -2720,19 +2742,20 @@ EigsComplexNonSymmetricMatrixShift (cons
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
-         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
-         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+         iparam, ipntr,
+         F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+         info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
@@ -2842,21 +2865,25 @@ EigsComplexNonSymmetricMatrixShift (cons
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d),
+     F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma),
+     F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
-     F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+     iparam, ipntr,
+     F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+     info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
@@ -2938,17 +2965,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
         p = 20;
 
       if (p > n - 1)
         p = n - 1;
     }
 
   if (k <= 0 || k >= n - 1)
     (*current_liboctave_error_handler)
-      ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
+      ("eigs: Invalid number of eigenvalues to extract"
+       " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
   if (! have_sigma)
     {
@@ -3005,19 +3033,20 @@ EigsComplexNonSymmetricFunc (EigsComplex
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
-         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
-         F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+         iparam, ipntr,
+         F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+         info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
           if (iter++)
@@ -3082,21 +3111,25 @@ EigsComplexNonSymmetricFunc (EigsComplex
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d),
+     F77_DBLE_CMPLX_ARG (z), n, F77_DBLE_CMPLX_ARG (&sigma),
+     F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
-     F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
+     iparam, ipntr,
+     F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
+     info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
@@ -3251,8 +3284,9 @@ octave_idx_type
 EigsComplexNonSymmetricMatrixShift<SparseComplexMatrix>
   (const SparseComplexMatrix& m, Complex sigma, octave_idx_type k,
    octave_idx_type p, octave_idx_type& info, ComplexMatrix& eig_vec,
    ComplexColumnVector& eig_val, const SparseComplexMatrix& _b,
    ColumnVector& permB, ComplexColumnVector& cresid, std::ostream& os,
    double tol, bool rvec, bool cholB, int disp, int maxit);
 
 #endif
+
diff --git a/liboctave/numeric/eigs-base.h b/liboctave/numeric/eigs-base.h
--- a/liboctave/numeric/eigs-base.h
+++ b/liboctave/numeric/eigs-base.h
@@ -29,17 +29,18 @@ along with Octave; see the file COPYING.
 
 class ColumnVector;
 class ComplexColumnVector;
 class Matrix;
 class ComplexMatrix;
 
 typedef ColumnVector (*EigsFunc) (const ColumnVector& x, int& eigs_error);
 
-typedef ComplexColumnVector (*EigsComplexFunc) (const ComplexColumnVector& x, int& eigs_error);
+typedef ComplexColumnVector (*EigsComplexFunc) (const ComplexColumnVector& x,
+                                                int& eigs_error);
 
 template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
                          octave_idx_type& info, Matrix& eig_vec,
                          ColumnVector& eig_val, const M& _b,
                          ColumnVector& permB, ColumnVector& resid,
@@ -124,8 +125,9 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type& info, ComplexMatrix& eig_vec,
                              ComplexColumnVector& eig_val,
                              ComplexColumnVector& cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit);
 
 #endif
+
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -26,17 +26,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "fEIG.h"
 #include "fColVector.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 
 octave_idx_type
-FloatEIG::init (const FloatMatrix& a, bool calc_rev, bool calc_lev, bool balance)
+FloatEIG::init (const FloatMatrix& a, bool calc_rev, bool calc_lev,
+                bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_rev, calc_lev);
 
@@ -741,8 +742,9 @@ FloatEIG::hermitian_init (const FloatCom
     (*current_liboctave_error_handler) ("zhegv failed to converge");
 
   lambda = FloatComplexColumnVector (wr);
   v = calc_rev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
   w = calc_lev ? FloatComplexMatrix (atmp) : FloatComplexMatrix ();
 
   return info;
 }
+
diff --git a/liboctave/numeric/fEIG.h b/liboctave/numeric/fEIG.h
--- a/liboctave/numeric/fEIG.h
+++ b/liboctave/numeric/fEIG.h
@@ -150,8 +150,9 @@ private:
 
   octave_idx_type hermitian_init (const FloatComplexMatrix& a,
                                   const FloatComplexMatrix& b,
                                   bool calc_rev, bool calc_lev);
 
 };
 
 #endif
+
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -310,8 +310,9 @@ namespace octave
 
     template class gepbalance<FloatMatrix>;
 
     template class gepbalance<ComplexMatrix>;
 
     template class gepbalance<FloatComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/gepbalance.h b/liboctave/numeric/gepbalance.h
--- a/liboctave/numeric/gepbalance.h
+++ b/liboctave/numeric/gepbalance.h
@@ -85,8 +85,9 @@ namespace octave
       RT balancing_mat2;
 
       octave_idx_type init (const T& a, const T& b, const std::string& job);
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -26,22 +26,22 @@
 #include "dDiagMatrix.h"
 #include "dMatrix.h"
 
 #include <vector>
 
 template <>
 void
 gsvd<Matrix>::ggsvd (char& jobu, char& jobv, char& jobq, octave_idx_type m,
-                    octave_idx_type n, octave_idx_type p, octave_idx_type& k,
-                    octave_idx_type& l, double *tmp_dataA, octave_idx_type m1,
-                    double *tmp_dataB, octave_idx_type p1, Matrix& alpha,
-                    Matrix& beta, double *u, octave_idx_type nrow_u, double *v,
-                    octave_idx_type nrow_v, double *q, octave_idx_type nrow_q,
-                    Matrix& work, octave_idx_type* iwork, octave_idx_type& info)
+                     octave_idx_type n, octave_idx_type p, octave_idx_type& k,
+                     octave_idx_type& l, double *tmp_dataA, octave_idx_type m1,
+                     double *tmp_dataB, octave_idx_type p1, Matrix& alpha,
+                     Matrix& beta, double *u, octave_idx_type nrow_u, double *v,
+                     octave_idx_type nrow_v, double *q, octave_idx_type nrow_q,
+                     Matrix& work, octave_idx_type* iwork, octave_idx_type& info)
 {
   F77_XFCN (dggsvd, DGGSVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                              F77_CONST_CHAR_ARG2 (&jobv, 1),
                              F77_CONST_CHAR_ARG2 (&jobq, 1),
                              m, n, p, k, l, tmp_dataA, m1,
                              tmp_dataB, p1, alpha.fortran_vec (),
                              beta.fortran_vec (), u, nrow_u,
                              v, nrow_v, q, nrow_q, work.fortran_vec (),
@@ -160,34 +160,34 @@ gsvd<T>::gsvd (const T& a, const T& b, g
   octave_idx_type nrow_u = m;
   octave_idx_type nrow_v = p;
   octave_idx_type nrow_q = n;
 
   octave_idx_type k, l;
 
   switch (gsvd_type)
     {
-      case gsvd<T>::Type::sigma_only:
+    case gsvd<T>::Type::sigma_only:
 
-        // Note:  for this case, both jobu and jobv should be 'N', but
-        // there seems to be a bug in dgesvd from Lapack V2.0.  To
-        // demonstrate the bug, set both jobu and jobv to 'N' and find
-        // the singular values of [eye(3), eye(3)].  The result is
-        // [-sqrt(2), -sqrt(2), -sqrt(2)].
-        //
-        // For Lapack 3.0, this problem seems to be fixed.
+      // Note:  for this case, both jobu and jobv should be 'N', but
+      // there seems to be a bug in dgesvd from Lapack V2.0.  To
+      // demonstrate the bug, set both jobu and jobv to 'N' and find
+      // the singular values of [eye(3), eye(3)].  The result is
+      // [-sqrt(2), -sqrt(2), -sqrt(2)].
+      //
+      // For Lapack 3.0, this problem seems to be fixed.
 
-        jobu = 'N';
-        jobv = 'N';
-        jobq = 'N';
-        nrow_u = nrow_v = nrow_q = 1;
-        break;
+      jobu = 'N';
+      jobv = 'N';
+      jobq = 'N';
+      nrow_u = nrow_v = nrow_q = 1;
+      break;
 
-      default:
-        break;
+    default:
+      break;
     }
 
   type = gsvd_type;
 
   if (! (jobu == 'N' || jobu == 'O'))
     left_smA.resize (nrow_u, m);
 
   P *u = left_smA.fortran_vec ();
@@ -242,26 +242,27 @@ gsvd<T>::gsvd (const T& a, const T& b, g
                     for (j = 0; j < k+l; j++)
                       R.xelem (i, j) = atmp.xelem (i, astart + j);
                 }
               else
                 {
                   // (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N),
                   // ( 0  R22 R23 )
 
-                   for (i = 0; i < m; i++)
-                     for (j = 0; j < k+l; j++)
-                       R.xelem (i, j) = atmp.xelem (i, astart + j);
-                   // and R33 is stored in B(M-K+1:L,N+M-K-L+1:N)
-                   for (i = k+l-1; i >=m; i--) {
-                     for (j = 0; j < m; j++)
-                       R.xelem(i, j) = 0.0;
-                     for (j = m; j < k+l; j++)
-                       R.xelem (i, j) = btmp.xelem (i - k, astart + j);
-                   }
+                  for (i = 0; i < m; i++)
+                    for (j = 0; j < k+l; j++)
+                      R.xelem (i, j) = atmp.xelem (i, astart + j);
+                  // and R33 is stored in B(M-K+1:L,N+M-K-L+1:N)
+                  for (i = k+l-1; i >=m; i--)
+                    {
+                      for (j = 0; j < m; j++)
+                        R.xelem(i, j) = 0.0;
+                      for (j = m; j < k+l; j++)
+                        R.xelem (i, j) = btmp.xelem (i - k, astart + j);
+                    }
                 }
             }
 
           if (m-k-l >= 0)
             {
               // Fills in C and S
               sigmaA.resize (l, l);
               sigmaB.resize (l, l);
@@ -286,8 +287,9 @@ gsvd<T>::gsvd (const T& a, const T& b, g
     }
 }
 
 // Instantiations we need.
 
 template class gsvd<Matrix>;
 
 template class gsvd<ComplexMatrix>;
+
diff --git a/liboctave/numeric/gsvd.h b/liboctave/numeric/gsvd.h
--- a/liboctave/numeric/gsvd.h
+++ b/liboctave/numeric/gsvd.h
@@ -42,30 +42,30 @@ public:
 
   gsvd (const gsvd& a)
     : type (a.type),
       sigmaA (a.sigmaA), sigmaB (a.sigmaB),
       left_smA (a.left_smA), left_smB (a.left_smB), right_sm (a.right_sm),
       R(a.R) { }
 
   gsvd& operator = (const gsvd& a)
-    {
-      if (this != &a)
-        {
-          type = a.type;
-          sigmaA = a.sigmaA;
-          sigmaB = a.sigmaB;
-          left_smA = a.left_smA;
-          left_smB = a.left_smB;
-          right_sm = a.right_sm;
-          R = a.R;
-        }
+  {
+    if (this != &a)
+      {
+        type = a.type;
+        sigmaA = a.sigmaA;
+        sigmaB = a.sigmaB;
+        left_smA = a.left_smA;
+        left_smB = a.left_smB;
+        right_sm = a.right_sm;
+        R = a.R;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~gsvd (void) { }
 
   DiagMatrix singular_values_A (void) const { return sigmaA; }
   DiagMatrix singular_values_B (void) const { return sigmaB; }
 
   T left_singular_matrix_A (void) const;
   T left_singular_matrix_B (void) const;
@@ -88,8 +88,9 @@ private:
               octave_idx_type& l, P *tmp_dataA, octave_idx_type m1,
               P *tmp_dataB, octave_idx_type p1, Matrix& alpha, Matrix& beta,
               P *u, octave_idx_type nrow_u, P *v, octave_idx_type nrow_v, P *q,
               octave_idx_type nrow_q, T& work, octave_idx_type* iwork,
               octave_idx_type& info);
 };
 
 #endif
+
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -192,22 +192,24 @@ namespace octave
                                  F77_CHAR_ARG_LEN (1)));
 
       Array<Complex> tau (dim_vector (n-1, 1));
       Complex *ptau = tau.fortran_vec ();
 
       Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
-      F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (h), n, F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork), lwork, info));
+      F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (h), n,
+                                 F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork), lwork, info));
 
       unitary_hess_mat = hess_mat;
       Complex *z = unitary_hess_mat.fortran_vec ();
 
-      F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (z), n, F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork),
+      F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (z), n,
+                                 F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork),
                                  lwork, info));
 
       F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, ilo, ihi, pscale, n, F77_DBLE_CMPLX_ARG (z), n, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -256,22 +258,24 @@ namespace octave
                                  F77_CHAR_ARG_LEN (1)));
 
       Array<FloatComplex> tau (dim_vector (n-1, 1));
       FloatComplex *ptau = tau.fortran_vec ();
 
       Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
-      F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, F77_CMPLX_ARG (h), n, F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork), lwork, info));
+      F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, F77_CMPLX_ARG (h), n,
+                                 F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork), lwork, info));
 
       unitary_hess_mat = hess_mat;
       FloatComplex *z = unitary_hess_mat.fortran_vec ();
 
-      F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, F77_CMPLX_ARG (z), n, F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork),
+      F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, F77_CMPLX_ARG (z), n,
+                                 F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork),
                                  lwork, info));
 
       F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, ilo, ihi, pscale, n, F77_CMPLX_ARG (z), n, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -283,8 +287,9 @@ namespace octave
         for (octave_idx_type j = 0; j < a_nc; j++)
           for (octave_idx_type i = j+2; i < a_nr; i++)
             hess_mat.elem (i, j) = 0;
 
       return info;
     }
   }
 }
+
diff --git a/liboctave/numeric/hess.h b/liboctave/numeric/hess.h
--- a/liboctave/numeric/hess.h
+++ b/liboctave/numeric/hess.h
@@ -84,8 +84,9 @@ namespace octave
 
     template <typename T>
     extern std::ostream&
     operator << (std::ostream& os, const hess<T>& a);
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-amos-proto.h b/liboctave/numeric/lo-amos-proto.h
--- a/liboctave/numeric/lo-amos-proto.h
+++ b/liboctave/numeric/lo-amos-proto.h
@@ -117,8 +117,9 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (zbiry, ZBIRY) (const F77_DBLE&, const F77_DBLE&,
                            const F77_INT&, const F77_INT&,
                            F77_DBLE&, F77_DBLE&, F77_INT&);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-arpack-proto.h b/liboctave/numeric/lo-arpack-proto.h
--- a/liboctave/numeric/lo-arpack-proto.h
+++ b/liboctave/numeric/lo-arpack-proto.h
@@ -132,8 +132,9 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 #endif
 
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-blas-proto.h b/liboctave/numeric/lo-blas-proto.h
--- a/liboctave/numeric/lo-blas-proto.h
+++ b/liboctave/numeric/lo-blas-proto.h
@@ -201,8 +201,9 @@ extern "C"
   // XERBLA
 
   F77_RET_T
   F77_FUNC (xerbla, XERBLA) (F77_CONST_CHAR_ARG_DECL, const F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-fftpack-proto.h b/liboctave/numeric/lo-fftpack-proto.h
--- a/liboctave/numeric/lo-fftpack-proto.h
+++ b/liboctave/numeric/lo-fftpack-proto.h
@@ -55,8 +55,9 @@ extern "C"
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const F77_INT&, F77_CMPLX*);
 
   F77_RET_T
   F77_FUNC (zffti, ZFFTI) (const F77_INT&, F77_DBLE_CMPLX*);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-lapack-proto.h b/liboctave/numeric/lo-lapack-proto.h
--- a/liboctave/numeric/lo-lapack-proto.h
+++ b/liboctave/numeric/lo-lapack-proto.h
@@ -1085,17 +1085,18 @@ extern "C"
   F77_FUNC (dlartg, DLARTG) (const F77_DBLE&, const F77_DBLE&, F77_DBLE&,
                              F77_DBLE&, F77_DBLE&);
 
   F77_RET_T
   F77_FUNC (slartg, SLARTG) (const F77_REAL&, const F77_REAL&, F77_REAL&,
                              F77_REAL&, F77_REAL&);
 
   F77_RET_T
-  F77_FUNC (zlartg, ZLARTG) (const F77_DBLE_CMPLX*, const F77_DBLE_CMPLX*, F77_DBLE&,
+  F77_FUNC (zlartg, ZLARTG) (const F77_DBLE_CMPLX*, const F77_DBLE_CMPLX*,
+                             F77_DBLE&,
                              F77_DBLE_CMPLX*, F77_DBLE_CMPLX*);
 
   // ORGHR
 
   F77_RET_T
   F77_FUNC (dorghr, DORGHR) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, F77_DBLE*, F77_DBLE*,
@@ -1661,8 +1662,9 @@ extern "C"
   F77_RET_T
   F77_FUNC (zungqr, ZUNGQR) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_INT&);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -100,17 +100,17 @@ namespace octave
       static Complex i (0, 1);
 
       Complex tmp;
 
       if (std::imag (x) == 0.0)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
-          // This effectively chooses the same phase of the branch cut as Matlab.
+          // This chooses the same phase of the branch cut as Matlab.
           double xr = std::real (x);
           tmp = Complex (1.0 - xr*xr);
         }
       else
         tmp = 1.0 - x*x;
 
       return -i * log (x + i * sqrt (tmp));
 #endif
@@ -130,17 +130,17 @@ namespace octave
       static FloatComplex i (0, 1);
 
       FloatComplex tmp;
 
       if (std::imag (x) == 0.0f)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
-          // This effectively chooses the same phase of the branch cut as Matlab.
+          // This chooses the same phase of the branch cut as Matlab.
           float xr = std::real (x);
           tmp = FloatComplex (1.0f - xr*xr);
         }
       else
         tmp = 1.0f - x*x;
 
       return -i * log (x + i * sqrt (tmp));
 #endif
@@ -160,17 +160,17 @@ namespace octave
       static Complex i (0, 1);
 
       Complex tmp;
 
       if (std::imag (x) == 0.0)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
-          // This effectively chooses the same phase of the branch cut as Matlab.
+          // This chooses the same phase of the branch cut as Matlab.
           double xr = std::real (x);
           tmp = Complex (1.0 - xr*xr);
         }
       else
         tmp = 1.0 - x*x;
 
       return -i * log (i*x + sqrt (tmp));
 #endif
@@ -190,17 +190,17 @@ namespace octave
       static FloatComplex i (0, 1);
 
       FloatComplex tmp;
 
       if (std::imag (x) == 0.0f)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
-          // This effectively chooses the same phase of the branch cut as Matlab.
+          // This chooses the same phase of the branch cut as Matlab.
           float xr = std::real (x);
           tmp = FloatComplex (1.0f - xr*xr);
         }
       else
         tmp = 1.0f - x*x;
 
       return -i * log (i*x + sqrt (tmp));
 #endif
@@ -408,28 +408,30 @@ namespace octave
     octave_idx_type
     nint_big (double x)
     {
       if (x > std::numeric_limits<octave_idx_type>::max ())
         return std::numeric_limits<octave_idx_type>::max ();
       else if (x < std::numeric_limits<octave_idx_type>::min ())
         return std::numeric_limits<octave_idx_type>::min ();
       else
-        return static_cast<octave_idx_type> ((x > 0.0) ? (x + 0.5) : (x - 0.5));
+        return static_cast<octave_idx_type> ((x > 0.0) ? (x + 0.5)
+                                                       : (x - 0.5));
     }
 
     octave_idx_type
     nint_big (float x)
     {
       if (x > std::numeric_limits<octave_idx_type>::max ())
         return std::numeric_limits<octave_idx_type>::max ();
       else if (x < std::numeric_limits<octave_idx_type>::min ())
         return std::numeric_limits<octave_idx_type>::min ();
       else
-        return static_cast<octave_idx_type> ((x > 0.0f) ? (x + 0.5f) : (x - 0.5f));
+        return static_cast<octave_idx_type> ((x > 0.0f) ? (x + 0.5f)
+                                                        : (x - 0.5f));
     }
 
     int
     nint (double x)
     {
       if (x > std::numeric_limits<int>::max ())
         return std::numeric_limits<int>::max ();
       else if (x < std::numeric_limits<int>::min ())
@@ -453,17 +455,18 @@ namespace octave
     rc_acos (double x)
     {
       return fabs (x) > 1.0 ? acos (Complex (x)) : Complex (::acos (x));
     }
 
     FloatComplex
     rc_acos (float x)
     {
-      return fabsf (x) > 1.0f ? acos (FloatComplex (x)) : FloatComplex (::acosf (x));
+      return fabsf (x) > 1.0f ? acos (FloatComplex (x))
+                              : FloatComplex (::acosf (x));
     }
 
     Complex
     rc_acosh (double x)
     {
       return x < 1.0 ? acosh (Complex (x)) : Complex (acosh (x));
     }
 
@@ -477,78 +480,85 @@ namespace octave
     rc_asin (double x)
     {
       return fabs (x) > 1.0 ? asin (Complex (x)) : Complex (::asin (x));
     }
 
     FloatComplex
     rc_asin (float x)
     {
-      return fabsf (x) > 1.0f ? asin (FloatComplex (x)) : FloatComplex (::asinf (x));
+      return fabsf (x) > 1.0f ? asin (FloatComplex (x))
+                              : FloatComplex (::asinf (x));
     }
 
     Complex
     rc_atanh (double x)
     {
       return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
     }
 
     FloatComplex
     rc_atanh (float x)
     {
-      return fabsf (x) > 1.0f ? atanh (FloatComplex (x)) : FloatComplex (atanh (x));
+      return fabsf (x) > 1.0f ? atanh (FloatComplex (x))
+                              : FloatComplex (atanh (x));
     }
 
     Complex
     rc_log (double x)
     {
       const double pi = 3.14159265358979323846;
       return x < 0.0 ? Complex (std::log (-x), pi) : Complex (std::log (x));
     }
 
     FloatComplex
     rc_log (float x)
     {
       const float pi = 3.14159265358979323846f;
-      return x < 0.0f ? FloatComplex (std::log (-x), pi) : FloatComplex (std::log (x));
+      return x < 0.0f ? FloatComplex (std::log (-x), pi)
+                      : FloatComplex (std::log (x));
     }
 
     Complex
     rc_log2 (double x)
     {
       const double pil2 = 4.53236014182719380962; // = pi / log(2)
       return x < 0.0 ? Complex (log2 (-x), pil2) : Complex (log2 (x));
     }
 
     FloatComplex
     rc_log2 (float x)
     {
       const float pil2 = 4.53236014182719380962f; // = pi / log(2)
-      return x < 0.0f ? FloatComplex (log2 (-x), pil2) : FloatComplex (log2 (x));
+      return x < 0.0f ? FloatComplex (log2 (-x), pil2)
+                      : FloatComplex (log2 (x));
     }
 
     Complex
     rc_log10 (double x)
     {
       const double pil10 = 1.36437635384184134748; // = pi / log(10)
       return x < 0.0 ? Complex (log10 (-x), pil10) : Complex (log10 (x));
     }
 
     FloatComplex
     rc_log10 (float x)
     {
       const float pil10 = 1.36437635384184134748f; // = pi / log(10)
-      return x < 0.0f ? FloatComplex (log10 (-x), pil10) : FloatComplex (log10f (x));
+      return x < 0.0f ? FloatComplex (log10 (-x), pil10)
+                      : FloatComplex (log10f (x));
     }
 
     Complex
     rc_sqrt (double x)
     {
       return x < 0.0 ? Complex (0.0, sqrt (-x)) : Complex (sqrt (x));
     }
 
     FloatComplex
     rc_sqrt (float x)
     {
-      return x < 0.0f ? FloatComplex (0.0f, sqrtf (-x)) : FloatComplex (sqrtf (x));
+      return x < 0.0f ? FloatComplex (0.0f, sqrtf (-x))
+                      : FloatComplex (sqrtf (x));
     }
   }
 }
+
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -886,8 +886,9 @@ inline FloatComplex rc_log10 (float x) {
 OCTAVE_DEPRECATED ("use 'octave::math::rc_sqrt' instead")
 inline Complex rc_sqrt (double x) { return octave::math::rc_sqrt (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::rc_sqrt' instead")
 inline FloatComplex rc_sqrt (float x) { return octave::math::rc_sqrt (x); }
 
 #endif
 
 #endif
+
diff --git a/liboctave/numeric/lo-qrupdate-proto.h b/liboctave/numeric/lo-qrupdate-proto.h
--- a/liboctave/numeric/lo-qrupdate-proto.h
+++ b/liboctave/numeric/lo-qrupdate-proto.h
@@ -369,8 +369,9 @@ extern "C"
                                F77_INT *, const F77_DBLE_CMPLX *,
                                const F77_DBLE_CMPLX *, F77_DBLE_CMPLX *);
 
 #endif
 
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-ranlib-proto.h b/liboctave/numeric/lo-ranlib-proto.h
--- a/liboctave/numeric/lo-ranlib-proto.h
+++ b/liboctave/numeric/lo-ranlib-proto.h
@@ -53,8 +53,9 @@ extern "C"
   F77_RET_T
   F77_FUNC (setcgn, SETCGN) (const F77_INT4&);
 
   F77_RET_T
   F77_FUNC (setsd, SETSD) (const F77_INT4&, const F77_INT4&);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-slatec-proto.h b/liboctave/numeric/lo-slatec-proto.h
--- a/liboctave/numeric/lo-slatec-proto.h
+++ b/liboctave/numeric/lo-slatec-proto.h
@@ -126,8 +126,9 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (dpsifn, DPSIFN) (const F77_DBLE*, const F77_INT&,
                              const F77_INT&, const F77_INT&,
                              F77_DBLE*, F77_INT*, F77_INT*);
 }
 
 #endif
+
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -934,17 +934,17 @@ namespace octave
         {
           alpha = -alpha;
 
           Complex tmp = zbesi (z, alpha, kode, ierr);
 
           if (ierr == 0 || ierr == 3)
             {
               Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
-                * zbesk (z, alpha, kode, ierr);
+                             * zbesk (z, alpha, kode, ierr);
 
               if (kode == 2)
                 {
                   // Compensate for different scaling factor of besk.
                   tmp2 *= exp (-z - std::abs (z.real ()));
                 }
 
               tmp += tmp2;
@@ -1410,17 +1410,18 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesj, CBESJ) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
+          F77_FUNC (cbesj, CBESJ) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
+                                   F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               float expz = exp (std::abs (z.imag ()));
               y *= expz;
             }
 
           if (z.imag () == 0.0 && z.real () >= 0.0)
@@ -1437,22 +1438,22 @@ namespace octave
             tmp = - tmp;
           retval = bessel_return_value (tmp, ierr);
         }
       else
         {
           alpha = -alpha;
 
           FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
-            * cbesj (z, alpha, kode, ierr);
+                             * cbesj (z, alpha, kode, ierr);
 
           if (ierr == 0 || ierr == 3)
             {
               tmp -= sinf (static_cast<float> (M_PI) * alpha)
-                * cbesy (z, alpha, kode, ierr);
+                     * cbesy (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
             retval = FloatComplex (octave::numeric_limits<float>::NaN (),
                                    octave::numeric_limits<float>::NaN ());
         }
 
@@ -1475,17 +1476,18 @@ namespace octave
           ierr = 0;
 
           if (z.real () == 0.0 && z.imag () == 0.0)
             {
               y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
-              F77_FUNC (cbesy, CBESY) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, F77_CMPLX_ARG (&w), ierr);
+              F77_FUNC (cbesy, CBESY) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
+                                       F77_CMPLX_ARG (&y), nz, F77_CMPLX_ARG (&w), ierr);
 
               if (kode != 2)
                 {
                   float expz = exp (std::abs (z.imag ()));
                   y *= expz;
                 }
 
               if (z.imag () == 0.0 && z.real () >= 0.0)
@@ -1503,22 +1505,22 @@ namespace octave
             tmp = - tmp;
           retval = bessel_return_value (tmp, ierr);
         }
       else
         {
           alpha = -alpha;
 
           FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
-            * cbesy (z, alpha, kode, ierr);
+                             * cbesy (z, alpha, kode, ierr);
 
           if (ierr == 0 || ierr == 3)
             {
               tmp += sinf (static_cast<float> (M_PI) * alpha)
-                * cbesj (z, alpha, kode, ierr);
+                     * cbesj (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
             retval = FloatComplex (octave::numeric_limits<float>::NaN (),
                                    octave::numeric_limits<float>::NaN ());
         }
 
@@ -1531,17 +1533,18 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesi, CBESI) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
+          F77_FUNC (cbesi, CBESI) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
+                                   F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               float expz = exp (std::abs (z.real ()));
               y *= expz;
             }
 
           if (z.imag () == 0.0 && z.real () >= 0.0)
@@ -1553,18 +1556,18 @@ namespace octave
         {
           alpha = -alpha;
 
           FloatComplex tmp = cbesi (z, alpha, kode, ierr);
 
           if (ierr == 0 || ierr == 3)
             {
               FloatComplex tmp2 = static_cast<float> (2.0 / M_PI)
-                * sinf (static_cast<float> (M_PI) * alpha)
-                * cbesk (z, alpha, kode, ierr);
+                                  * sinf (static_cast<float> (M_PI) * alpha)
+                                  * cbesk (z, alpha, kode, ierr);
 
               if (kode == 2)
                 {
                   // Compensate for different scaling factor of besk.
                   tmp2 *= exp (-z - std::abs (z.real ()));
                 }
 
               tmp += tmp2;
@@ -1593,17 +1596,18 @@ namespace octave
           ierr = 0;
 
           if (z.real () == 0.0 && z.imag () == 0.0)
             {
               y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
-              F77_FUNC (cbesk, CBESK) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
+              F77_FUNC (cbesk, CBESK) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
+                                       F77_CMPLX_ARG (&y), nz, ierr);
 
               if (kode != 2)
                 {
                   FloatComplex expz = exp (-z);
 
                   float rexpz = expz.real ();
                   float iexpz = expz.imag ();
 
@@ -1635,17 +1639,18 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, 1, F77_CMPLX_ARG (&y), nz, ierr);
+          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, 1,
+                                   F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
 
               float rexpz = expz.real ();
               float iexpz = expz.imag ();
 
@@ -1659,17 +1664,17 @@ namespace octave
         }
       else
         {
           alpha = -alpha;
 
           static const FloatComplex eye = FloatComplex (0.0, 1.0);
 
           FloatComplex tmp = exp (static_cast<float> (M_PI) * alpha * eye)
-            * cbesh1 (z, alpha, kode, ierr);
+                             * cbesh1 (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
 
       return retval;
     }
 
     static inline FloatComplex
@@ -1678,17 +1683,18 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
+          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 2, 1,
+                                   F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
 
               float rexpz = expz.real ();
               float iexpz = expz.imag ();
 
@@ -1702,17 +1708,17 @@ namespace octave
         }
       else
         {
           alpha = -alpha;
 
           static const FloatComplex eye = FloatComplex (0.0, 1.0);
 
           FloatComplex tmp = exp (-static_cast<float> (M_PI) * alpha * eye)
-            * cbesh2 (z, alpha, kode, ierr);
+                             * cbesh2 (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
 
       return retval;
     }
 
     typedef FloatComplex (*fptr) (const FloatComplex&, float, int,
@@ -2099,17 +2105,18 @@ namespace octave
     airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
       FloatComplex a;
 
       octave_idx_type nz;
 
       octave_idx_type id = deriv ? 1 : 0;
 
-      F77_FUNC (cairy, CAIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a), nz, ierr);
+      F77_FUNC (cairy, CAIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a),
+                               nz, ierr);
 
       float ar = a.real ();
       float ai = a.imag ();
 
       if (! scaled)
         {
           FloatComplex expz = exp (- 2.0f / 3.0f * z * sqrt (z));
 
@@ -2130,17 +2137,18 @@ namespace octave
 
     FloatComplex
     biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
       FloatComplex a;
 
       octave_idx_type id = deriv ? 1 : 0;
 
-      F77_FUNC (cbiry, CBIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a), ierr);
+      F77_FUNC (cbiry, CBIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a),
+                               ierr);
 
       float ar = a.real ();
       float ai = a.imag ();
 
       if (! scaled)
         {
           FloatComplex expz = exp (std::abs (std::real (2.0f / 3.0f * z * sqrt (z))));
 
@@ -2535,17 +2543,17 @@ namespace octave
 
     // FIXME: there is still room for improvement here...
 
     double
     gammainc (double x, double a, bool& err)
     {
       if (a < 0.0 || x < 0.0)
         (*current_liboctave_error_handler)
-              ("gammainc: A and X must be non-negative");
+          ("gammainc: A and X must be non-negative");
 
       err = false;
 
       double retval;
 
       F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
 
       return retval;
@@ -2698,17 +2706,17 @@ namespace octave
       return retval;
     }
 
     float
     gammainc (float x, float a, bool& err)
     {
       if (a < 0.0 || x < 0.0)
         (*current_liboctave_error_handler)
-              ("gammainc: A and X must be non-negative");
+          ("gammainc: A and X must be non-negative");
 
       err = false;
 
       float retval;
 
       F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
 
       return retval;
@@ -3504,17 +3512,18 @@ namespace octave
     {
       static const int Nmax = 16;
       double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
       int n, Nn, ii;
 
       if (m < 0 || m > 1)
         {
           (*current_liboctave_warning_with_id_handler)
-            ("Octave:ellipj-invalid-m", "ellipj: invalid M value, required value 0 <= M <= 1");
+            ("Octave:ellipj-invalid-m",
+             "ellipj: invalid M value, required value 0 <= M <= 1");
 
           sn = cn = dn = lo_ieee_nan_value ();
 
           return;
         }
 
       double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
       if (m < sqrt_eps)
@@ -3624,17 +3633,18 @@ namespace octave
     template <typename T>
     static T
     lanczos_approximation_psi (const T zc)
     {
       // Coefficients for C.Lanczos expansion of psi function from XLiFE++
       // gammaFunctions psi_coef[k] = - (2k+1) * lg_coef[k] (see melina++
       // gamma functions -1/12, 3/360,-5/1260, 7/1680,-9/1188,
       // 11*691/360360,-13/156, 15*3617/122400, ? , ?
-      static const T dg_coeff[10] = {
+      static const T dg_coeff[10] =
+      {
         -0.83333333333333333e-1, 0.83333333333333333e-2,
         -0.39682539682539683e-2, 0.41666666666666667e-2,
         -0.75757575757575758e-2, 0.21092796092796093e-1,
         -0.83333333333333333e-1, 0.4432598039215686,
         -0.3053954330270122e+1,  0.125318899521531e+2
       };
 
       T overz2  = T (1.0) / (zc * zc);
@@ -3646,17 +3656,18 @@ namespace octave
       p += xlog (zc) - T (0.5) / zc;
       return p;
     }
 
     template <typename T>
     T
     xpsi (T z)
     {
-      static const double euler_mascheroni = 0.577215664901532860606512090082402431042;
+      static const double euler_mascheroni =
+        0.577215664901532860606512090082402431042;
 
       const bool is_int = (octave::math::floor (z) == z);
 
       T p = 0;
       if (z <= 0)
         {
           // limits - zeros of the gamma function
           if (is_int)
@@ -3958,8 +3969,9 @@ Array<double> betaincinv (double x, cons
 Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
 
 Array<double> betaincinv (const Array<double>& x, double a, double b) { return octave::math::betaincinv (x, a, b); }
 Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
 Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b) { return octave::math::betaincinv (x, a, b); }
 Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
 
 #endif
+
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -90,165 +90,287 @@ namespace octave
     extern OCTAVE_API double gamma (double x);
     extern OCTAVE_API double lgamma (double x);
     extern OCTAVE_API Complex rc_lgamma (double x);
 
     extern OCTAVE_API float gamma (float x);
     extern OCTAVE_API float lgamma (float x);
     extern OCTAVE_API FloatComplex rc_lgamma (float x);
 
-    extern OCTAVE_API Complex besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex besseli (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex besselk (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselj (double alpha, const Complex& x, bool scaled,
+                                       octave_idx_type& ierr);
+    extern OCTAVE_API Complex bessely (double alpha, const Complex& x, bool scaled,
+                                       octave_idx_type& ierr);
+    extern OCTAVE_API Complex besseli (double alpha, const Complex& x, bool scaled,
+                                       octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselk (double alpha, const Complex& x, bool scaled,
+                                       octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselh1 (double alpha, const Complex& x, bool scaled,
+                                        octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselh2 (double alpha, const Complex& x, bool scaled,
+                                        octave_idx_type& ierr);
 
-    extern OCTAVE_API ComplexMatrix besselj (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix bessely (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besseli (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselk (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh1 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh2 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (double alpha, const ComplexMatrix& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (double alpha, const ComplexMatrix& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (double alpha, const ComplexMatrix& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (double alpha, const ComplexMatrix& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (double alpha, const ComplexMatrix& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (double alpha, const ComplexMatrix& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const Complex& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const Complex& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const Complex& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const Complex& x,
+                                             bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const Complex& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const Complex& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha,
+                                             const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha,
+                                             const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha,
+                                             const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha,
+                                             const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha,
+                                              const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha,
+                                              const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexNDArray besselj (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray bessely (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besseli (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselk (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh1 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh2 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (double alpha, const ComplexNDArray& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (double alpha, const ComplexNDArray& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (double alpha, const ComplexNDArray& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (double alpha, const ComplexNDArray& x,
+                                              bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (double alpha,
+                                               const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (double alpha,
+                                               const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha,
+                                              const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha,
+                                              const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha,
+                                              const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha,
+                                              const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha,
+                                               const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha,
+                                               const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha,
+                                              const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha,
+                                              const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha,
+                                              const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha,
+                                              const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha,
+                                               const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha,
+                                               const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexMatrix besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const RowVector& alpha,
+                                             const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const RowVector& alpha,
+                                             const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const RowVector& alpha,
+                                             const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const RowVector& alpha,
+                                             const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const RowVector& alpha,
+                                              const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const RowVector& alpha,
+                                              const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplex besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex besseli (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex besselk (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselj (float alpha, const FloatComplex& x,
+                                            bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex bessely (float alpha, const FloatComplex& x,
+                                            bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besseli (float alpha, const FloatComplex& x,
+                                            bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselk (float alpha, const FloatComplex& x,
+                                            bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselh1 (float alpha, const FloatComplex& x,
+                                             bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselh2 (float alpha, const FloatComplex& x,
+                                             bool scaled, octave_idx_type& ierr);
 
-    extern OCTAVE_API FloatComplexMatrix besselj (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix bessely (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besseli (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselk (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (float alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (float alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (float alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (float alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (float alpha,
+                                                   const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (float alpha,
+                                                   const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha,
+                                                  const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha,
+                                                  const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha,
+                                                  const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha,
+                                                  const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha,
+                                                  const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha,
+                                                   const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha,
+                                                   const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexNDArray besselj (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray bessely (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besseli (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselk (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (float alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (float alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (float alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (float alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (float alpha,
+                                                    const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (float alpha,
+                                                    const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha,
+                                                   const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha,
+                                                    const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha,
+                                                    const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha,
+                                                   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha,
+                                                    const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha,
+                                                    const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexMatrix besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatRowVector& alpha,
+                                                  const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatRowVector& alpha,
+                                                  const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatRowVector& alpha,
+                                                  const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatRowVector& alpha,
+                                                  const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatRowVector& alpha,
+                                                   const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatRowVector& alpha,
+                                                   const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled,
+                                    octave_idx_type& ierr);
+    extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled,
+                                    octave_idx_type& ierr);
 
-    extern OCTAVE_API ComplexMatrix airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexMatrix biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix airy (const ComplexMatrix& z, bool deriv,
+                                          bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix biry (const ComplexMatrix& z, bool deriv,
+                                          bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API ComplexNDArray airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API ComplexNDArray biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray airy (const ComplexNDArray& z, bool deriv,
+                                           bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray biry (const ComplexNDArray& z, bool deriv,
+                                           bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-    extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv,
+                                         bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv,
+                                         bool scaled, octave_idx_type& ierr);
 
-    extern OCTAVE_API FloatComplexMatrix airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexMatrix biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix airy (const FloatComplexMatrix& z,
+                                               bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix biry (const FloatComplexMatrix& z,
+                                               bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-    extern OCTAVE_API FloatComplexNDArray airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
-    extern OCTAVE_API FloatComplexNDArray biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray airy (const FloatComplexNDArray& z,
+                                                bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray biry (const FloatComplexNDArray& z,
+                                                bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
     extern OCTAVE_API double betainc (double x, double a, double b);
-    extern OCTAVE_API Array<double> betainc (double x, double a, const Array<double>& b);
-    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, double b);
-    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (double x, double a,
+                                             const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a,
+                                             double b);
+    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a,
+                                             const Array<double>& b);
 
-    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
-    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, const Array<double>& b);
-    extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, double b);
-    extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a,
+                                             double b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a,
+                                             const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x,
+                                             const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x,
+                                             const Array<double>& a, const Array<double>& b);
 
     extern OCTAVE_API float betainc (float x, float a, float b);
-    extern OCTAVE_API Array<float> betainc (float x, float a, const Array<float>& b);
-    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, float b);
-    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (float x, float a,
+                                            const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a,
+                                            float b);
+    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a,
+                                            const Array<float>& b);
 
-    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
-    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, const Array<float>& b);
-    extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, float b);
-    extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a,
+                                            float b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a,
+                                            const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x,
+                                            const Array<float>& a, float b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x,
+                                            const Array<float>& a, const Array<float>& b);
 
     extern OCTAVE_API double gammainc (double x, double a, bool& err);
     inline double gammainc (double x, double a)
     {
       bool err;
       return gammainc (x, a, err);
     }
 
@@ -264,21 +386,23 @@ namespace octave
     inline float gammainc (float x, float a)
     {
       bool err;
       return gammainc (x, a, err);
     }
 
     extern OCTAVE_API FloatMatrix gammainc (float x, const FloatMatrix& a);
     extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, float a);
-    extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, const FloatMatrix& a);
+    extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x,
+                                            const FloatMatrix& a);
 
     extern OCTAVE_API FloatNDArray gammainc (float x, const FloatNDArray& a);
     extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, float a);
-    extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a);
+    extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x,
+                                             const FloatNDArray& a);
 
     extern OCTAVE_API Complex rc_log1p (double x);
     extern OCTAVE_API FloatComplex rc_log1p (float x);
 
     extern OCTAVE_API double erfinv (double x);
     extern OCTAVE_API float erfinv (float x);
 
     extern OCTAVE_API double erfcinv (double x);
@@ -295,27 +419,36 @@ namespace octave
     extern OCTAVE_API FloatComplex erfi (const FloatComplex& x);
 
     extern OCTAVE_API float dawson (float x);
     extern OCTAVE_API double dawson (double x);
     extern OCTAVE_API Complex dawson (const Complex& x);
     extern OCTAVE_API FloatComplex dawson (const FloatComplex& x);
 
     extern OCTAVE_API double betaincinv (double x, double a, double b);
-    extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
-    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
-    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (double x, double a,
+                                                const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a,
+                                                double b);
+    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a,
+                                                const Array<double>& b);
 
-    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
-    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
-    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
-    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a,
+                                                double b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a,
+                                                const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x,
+                                                const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x,
+                                                const Array<double>& a, const Array<double>& b);
 
-    extern OCTAVE_API void ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
-    extern OCTAVE_API void ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err);
+    extern OCTAVE_API void ellipj (double u, double m, double& sn, double& cn,
+                                   double& dn, double& err);
+    extern OCTAVE_API void ellipj (const Complex& u, double m, Complex& sn,
+                                   Complex& cn, Complex& dn, double& err);
 
     extern OCTAVE_API double psi (double x);
     extern OCTAVE_API float psi (float x);
 
     extern OCTAVE_API Complex psi (const Complex& x);
     extern OCTAVE_API FloatComplex psi (const FloatComplex& x);
 
     extern OCTAVE_API double psi (octave_idx_type n, double z);
@@ -856,8 +989,9 @@ inline float
 psi (octave_idx_type n, float z)
 {
   return octave::math::psi (n, z);
 }
 
 #endif
 
 #endif
+
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -529,17 +529,18 @@ namespace octave
       ipvt.resize (dim_vector (mn, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       Complex *tmp_data = a_fact.fortran_vec ();
 
       octave_idx_type info = 0;
 
-      F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, F77_DBLE_CMPLX_ARG (tmp_data), a_nr, pipvt, info));
+      F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, F77_DBLE_CMPLX_ARG (tmp_data), a_nr,
+                                 pipvt, info));
 
       for (octave_idx_type i = 0; i < mn; i++)
         pipvt[i] -= 1;
     }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
     template <>
@@ -557,18 +558,20 @@ namespace octave
       octave_idx_type n = r.columns ();
       octave_idx_type k = l.columns ();
 
       if (u.numel () != m || v.numel () != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
-      F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
-                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
+      F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()), m,
+                                 F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
+                                 F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
     }
 
     template <>
     void
     lu<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
@@ -584,17 +587,18 @@ namespace octave
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
           F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
                                      m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
-                                     F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
+                                     F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
+                                     F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
         }
     }
 
     template <>
     void
     lu<ComplexMatrix>::update_piv (const ComplexColumnVector& u,
                                    const ComplexColumnVector& v)
     {
@@ -613,17 +617,18 @@ namespace octave
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
                                    m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
-                                   F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
+                                   F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
+                                   F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
     template <>
     void
     lu<ComplexMatrix>::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       if (packed ())
@@ -643,17 +648,18 @@ namespace octave
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
           F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
                                        m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
                                        ipvt.fortran_vec (),
-                                       F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
+                                       F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
+                                       F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatComplexMatrix>::lu (const FloatComplexMatrix& a)
@@ -665,17 +671,18 @@ namespace octave
       ipvt.resize (dim_vector (mn, 1));
       octave_idx_type *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       FloatComplex *tmp_data = a_fact.fortran_vec ();
 
       octave_idx_type info = 0;
 
-      F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, F77_CMPLX_ARG (tmp_data), a_nr, pipvt, info));
+      F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, F77_CMPLX_ARG (tmp_data), a_nr, pipvt,
+                                 info));
 
       for (octave_idx_type i = 0; i < mn; i++)
         pipvt[i] -= 1;
     }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
     template <>
@@ -692,17 +699,18 @@ namespace octave
       octave_idx_type m = l.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = l.columns ();
 
       if (u.numel () == m && v.numel () == n)
         {
           FloatComplexColumnVector utmp = u;
           FloatComplexColumnVector vtmp = v;
-          F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m, F77_CMPLX_ARG (r.fortran_vec ()), k,
+          F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m,
+                                     F77_CMPLX_ARG (r.fortran_vec ()), k,
                                      F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ())));
         }
       else
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
     }
 
     template <>
     void
@@ -752,17 +760,18 @@ namespace octave
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
                                    m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
-                                   F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()), F77_CMPLX_ARG (w)));
+                                   F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()),
+                                   F77_CMPLX_ARG (w)));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
     template <>
     void
     lu<FloatComplexMatrix>::update_piv (const FloatComplexMatrix& u,
                                         const FloatComplexMatrix& v)
     {
@@ -783,17 +792,18 @@ namespace octave
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatComplexColumnVector utmp = u.column (i);
           FloatComplexColumnVector vtmp = v.column (i);
           F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
                                        m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                        ipvt.fortran_vec (),
-                                       F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()), F77_CMPLX_ARG (w)));
+                                       F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()),
+                                       F77_CMPLX_ARG (w)));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     // Instantiations we need.
 
@@ -801,8 +811,9 @@ namespace octave
 
     template class lu<FloatMatrix>;
 
     template class lu<ComplexMatrix>;
 
     template class lu<FloatComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/lu.h b/liboctave/numeric/lu.h
--- a/liboctave/numeric/lu.h
+++ b/liboctave/numeric/lu.h
@@ -97,8 +97,9 @@ namespace octave
       T l_fact;
 
       Array<octave_idx_type> ipvt;
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -185,8 +185,9 @@ convolve (const MArray<T>& a, const MArr
   }
 
 CONV_DEFS ( , )
 CONV_DEFS (Complex, )
 CONV_DEFS (Complex, Complex)
 CONV_DEFS (Float, Float)
 CONV_DEFS (FloatComplex, Float)
 CONV_DEFS (FloatComplex, FloatComplex)
+
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -880,18 +880,18 @@ octave_fftw::fft (const double *in, Comp
 int
 octave_fftw::fft (const Complex *in, Complex *out, size_t npts,
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   void *vplan = octave_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
-                                                     nsamples, stride,
-                                                     dist, in, out);
+                                                  nsamples, stride,
+                                                  dist, in, out);
   fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
 
   fftw_execute_dft (plan,
                     reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
                     reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
@@ -900,18 +900,18 @@ int
 octave_fftw::ifft (const Complex *in, Complex *out, size_t npts,
                    size_t nsamples, octave_idx_type stride,
                    octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   void *vplan = octave_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
-                                                     nsamples, stride,
-                                                     dist, in, out);
+                                                  nsamples, stride,
+                                                  dist, in, out);
   fftw_plan plan = reinterpret_cast<fftw_plan> (vplan);
 
   fftw_execute_dft (plan,
                     reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
                     reinterpret_cast<fftw_complex *> (out));
 
   const Complex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
@@ -1111,18 +1111,18 @@ int
 octave_fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank,
                      const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   void *vplan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD,
-                                                            rank, dv, 1, 1,
-                                                            dist, in, out);
+                                                        rank, dv, 1, 1,
+                                                        dist, in, out);
   fftwf_plan plan = reinterpret_cast<fftwf_plan> (vplan);
 
   fftwf_execute_dft (plan,
                      reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
                      reinterpret_cast<fftwf_complex *> (out));
 
   const size_t npts = dv.numel ();
   const FloatComplex scale = npts;
@@ -1148,8 +1148,9 @@ std::string
 octave_fftwf_version (void)
 {
 #if defined (HAVE_FFTW)
   return fftwf_version;
 #else
   return "none";
 #endif
 }
+
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -165,17 +165,17 @@ private:
   // howmany
   octave_idx_type rh;
 
   // dims
   dim_vector rn;
 
   bool rsimd_align;
 
-  // number of threads.  Always 1 unless compiled with Multi-threading
+  // number of threads.  Always 1 unless compiled with multi-threading
   // support.
   int nthreads;
 };
 
 class
 OCTAVE_API
 octave_float_fftw_planner
 {
@@ -310,17 +310,17 @@ private:
   // howmany
   octave_idx_type rh;
 
   // dims
   dim_vector rn;
 
   bool rsimd_align;
 
-  // number of threads.  Always 1 unless compiled with Multi-threading
+  // number of threads.  Always 1 unless compiled with multi-threading
   // support.
   int nthreads;
 };
 
 class
 OCTAVE_API
 octave_fftw
 {
@@ -363,8 +363,9 @@ private:
   octave_fftw (const octave_fftw&);
   octave_fftw& operator = (const octave_fftw&);
 };
 
 extern OCTAVE_API std::string octave_fftw_version (void);
 extern OCTAVE_API std::string octave_fftwf_version (void);
 
 #endif
+
diff --git a/liboctave/numeric/oct-norm.h b/liboctave/numeric/oct-norm.h
--- a/liboctave/numeric/oct-norm.h
+++ b/liboctave/numeric/oct-norm.h
@@ -61,8 +61,9 @@ DECLARE_COLROW_NORM_FUNCS(, , double)
 DECLARE_COLROW_NORM_FUNCS(Complex, , double)
 DECLARE_COLROW_NORM_FUNCS(Float, Float, float)
 DECLARE_COLROW_NORM_FUNCS(FloatComplex, Float, float)
 
 DECLARE_COLROW_NORM_FUNCS(Sparse, , double)
 DECLARE_COLROW_NORM_FUNCS(SparseComplex, , double)
 
 #endif
+
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -868,8 +868,9 @@ octave_rand::fill (octave_idx_type len, 
         ("rand: invalid distribution ID = %d", current_distribution);
       break;
     }
 
   save_state ();
 
   return;
 }
+
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -45,17 +45,18 @@ public:
 
   ~octave_rand (void) { }
 
   static bool instance_ok (void);
 
   // Return the current seed.
   static double seed (void)
   {
-    return instance_ok () ? instance->do_seed () : octave::numeric_limits<double>::NaN ();
+    return instance_ok () ? instance->do_seed ()
+                          : octave::numeric_limits<double>::NaN ();
   }
 
   // Set the seed.
   static void seed (double s)
   {
     if (instance_ok ())
       instance->do_seed (s);
   }
@@ -130,23 +131,25 @@ public:
   {
     if (instance_ok ())
       instance->do_gamma_distribution ();
   }
 
   // Return the next number from the sequence.
   static double scalar (double a = 1.0)
   {
-    return instance_ok () ? instance->do_scalar (a) : octave::numeric_limits<double>::NaN ();
+    return instance_ok () ? instance->do_scalar (a)
+                          : octave::numeric_limits<double>::NaN ();
   }
 
   // Return the next number from the sequence.
   static float float_scalar (float a = 1.0)
   {
-    return instance_ok () ? instance->do_float_scalar (a) : octave::numeric_limits<float>::NaN ();
+    return instance_ok () ? instance->do_float_scalar (a)
+                          : octave::numeric_limits<float>::NaN ();
   }
 
   // Return an array of numbers from the sequence.
   static Array<double> vector (octave_idx_type n, double a = 1.0)
   {
     return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
   }
 
@@ -269,8 +272,9 @@ private:
   void switch_to_generator (int dist);
 
   void fill (octave_idx_type len, double *v, double a);
 
   void fill (octave_idx_type len, float *v, float a);
 };
 
 #endif
+
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -89,17 +89,18 @@ bool
 octave_sparse_params::set_key (const std::string& key, const double& val)
 {
   return instance_ok () ? instance->do_set_key (key, val) : false;
 }
 
 double
 octave_sparse_params::get_key (const std::string& key)
 {
-  return instance_ok () ? instance->do_get_key (key) : octave::numeric_limits<double>::NaN ();
+  return instance_ok () ? instance->do_get_key (key)
+                        : octave::numeric_limits<double>::NaN ();
 }
 
 double
 octave_sparse_params::get_bandden (void)
 {
   return instance_ok () ? instance->do_get_bandden () : 0.0;
 }
 
@@ -214,8 +215,9 @@ octave_sparse_params::do_get_key (const 
 
 void
 octave_sparse_params::do_print_info (std::ostream& os,
                                      const std::string& prefix) const
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     os << prefix << keys(i) << ": " << params(i) << "\n";
 }
+
diff --git a/liboctave/numeric/oct-spparms.h b/liboctave/numeric/oct-spparms.h
--- a/liboctave/numeric/oct-spparms.h
+++ b/liboctave/numeric/oct-spparms.h
@@ -116,8 +116,9 @@ private:
   double do_get_bandden (void);
 
   void do_print_info (std::ostream& os, const std::string& prefix) const;
 
   void init_keys (void);
 };
 
 #endif
+
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -721,17 +721,18 @@ namespace octave
                                  r.fortran_vec (), r.rows (),
                                  i + 1, j + 1, w));
     }
 
 #endif
 
     template <>
     void
-    qr<FloatMatrix>::form (octave_idx_type n, FloatMatrix& afact, float *tau, type qr_type)
+    qr<FloatMatrix>::form (octave_idx_type n, FloatMatrix& afact, float *tau,
+                           type qr_type)
     {
       octave_idx_type m = afact.rows ();
       octave_idx_type min_mn = std::min (m, n);
       octave_idx_type info;
 
       if (qr_type == qr<FloatMatrix>::raw)
         {
           for (octave_idx_type j = 0; j < min_mn; j++)
@@ -898,17 +899,18 @@ namespace octave
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), w));
     }
 
     template <>
     void
-    qr<FloatMatrix>::insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j)
+    qr<FloatMatrix>::insert_col (const FloatMatrix& u,
+                                 const Array<octave_idx_type>& j)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
       octave_idx_type nj = js.numel ();
@@ -1135,24 +1137,26 @@ namespace octave
               r = afact;
             }
 
           if (m > 0)
             {
               octave_idx_type k = q.columns ();
               // workspace query.
               Complex clwork;
-              F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+              F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                         m, F77_DBLE_CMPLX_ARG (tau),
                                          F77_DBLE_CMPLX_ARG (&clwork), -1, info));
 
               // allocate buffer and do the job.
               octave_idx_type lwork = clwork.real ();
               lwork = std::max (lwork, static_cast<octave_idx_type> (1));
               OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-              F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+              F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                         m, F77_DBLE_CMPLX_ARG (tau),
                                          F77_DBLE_CMPLX_ARG (work), lwork, info));
             }
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
@@ -1168,50 +1172,54 @@ namespace octave
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
         afact.resize (m, m);
 
       if (m > 0)
         {
           // workspace query.
           Complex clwork;
-          F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+          F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m,
+                                     F77_DBLE_CMPLX_ARG (tau),
                                      F77_DBLE_CMPLX_ARG (&clwork), -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
           lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-          F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+          F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m,
+                                     F77_DBLE_CMPLX_ARG (tau),
                                      F77_DBLE_CMPLX_ARG (work), lwork, info));
         }
 
       form (n, afact, tau, qr_type);
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
-    qr<ComplexMatrix>::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
+    qr<ComplexMatrix>::update (const ComplexColumnVector& u,
+                               const ComplexColumnVector& v)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       if (u.numel () != m || v.numel () != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqr1up, ZQR1UP, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
-                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
+                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
+                                 F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
                                  F77_DBLE_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
     qr<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       octave_idx_type m = q.rows ();
@@ -1224,17 +1232,18 @@ namespace octave
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
           F77_XFCN (zqr1up, ZQR1UP, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                      m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
-                                     F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
+                                     F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
+                                     F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
                                      F77_DBLE_CMPLX_ARG (w), rw));
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_col (const ComplexColumnVector& u, octave_idx_type j)
     {
@@ -1254,24 +1263,26 @@ namespace octave
         }
       else
         {
           r.resize (k, n+1);
         }
 
       ComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrinc, ZQRINC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+      F77_XFCN (zqrinc, ZQRINC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                 q.rows (),
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
                                  F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
-    qr<ComplexMatrix>::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
+    qr<ComplexMatrix>::insert_col (const ComplexMatrix& u,
+                                   const Array<octave_idx_type>& j)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
       octave_idx_type nj = js.numel ();
@@ -1319,17 +1330,18 @@ namespace octave
       octave_idx_type m = q.rows ();
       octave_idx_type k = r.rows ();
       octave_idx_type n = r.columns ();
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrdec, ZQRDEC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+      F77_XFCN (zqrdec, ZQRDEC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                 q.rows (),
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1, rw));
 
       if (k < m)
         {
           q.resize (m, k-1);
           r.resize (k-1, n-1);
         }
       else
@@ -1394,17 +1406,18 @@ namespace octave
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       ComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrinr, ZQRINR, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+      F77_XFCN (zqrinr, ZQRINR, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                 q.rows (),
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (),
                                  j + 1, F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
 
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_row (octave_idx_type j)
@@ -1414,17 +1427,18 @@ namespace octave
 
       if (! q.is_square ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       OCTAVE_LOCAL_BUFFER (double, rw, m);
-      F77_XFCN (zqrder, ZQRDER, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+      F77_XFCN (zqrder, ZQRDER, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                 q.rows (),
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
                                  F77_DBLE_CMPLX_ARG (w), rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
@@ -1445,17 +1459,18 @@ namespace octave
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (),
                                  i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
     }
 
 #endif
 
     template <>
     void
-    qr<FloatComplexMatrix>::form (octave_idx_type n, FloatComplexMatrix& afact, FloatComplex *tau, type qr_type)
+    qr<FloatComplexMatrix>::form (octave_idx_type n, FloatComplexMatrix& afact,
+                                  FloatComplex *tau, type qr_type)
     {
       octave_idx_type m = afact.rows ();
       octave_idx_type min_mn = std::min (m, n);
       octave_idx_type info;
 
       if (qr_type == qr<FloatComplexMatrix>::raw)
         {
           for (octave_idx_type j = 0; j < min_mn; j++)
@@ -1499,24 +1514,26 @@ namespace octave
               r = afact;
             }
 
           if (m > 0)
             {
               octave_idx_type k = q.columns ();
               // workspace query.
               FloatComplex clwork;
-              F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+              F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m,
+                                         F77_CMPLX_ARG (tau),
                                          F77_CMPLX_ARG (&clwork), -1, info));
 
               // allocate buffer and do the job.
               octave_idx_type lwork = clwork.real ();
               lwork = std::max (lwork, static_cast<octave_idx_type> (1));
               OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-              F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+              F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m,
+                                         F77_CMPLX_ARG (tau),
                                          F77_CMPLX_ARG (work), lwork, info));
             }
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
@@ -1532,35 +1549,38 @@ namespace octave
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
         afact.resize (m, m);
 
       if (m > 0)
         {
           // workspace query.
           FloatComplex clwork;
-          F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+          F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m,
+                                     F77_CMPLX_ARG (tau),
                                      F77_CMPLX_ARG (&clwork), -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
           lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-          F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+          F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m,
+                                     F77_CMPLX_ARG (tau),
                                      F77_CMPLX_ARG (work), lwork, info));
         }
 
       form (n, afact, tau, qr_type);
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
-    qr<FloatComplexMatrix>::update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
+    qr<FloatComplexMatrix>::update (const FloatComplexColumnVector& u,
+                                    const FloatComplexColumnVector& v)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       if (u.numel () != m || v.numel () != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
@@ -1571,17 +1591,18 @@ namespace octave
       F77_XFCN (cqr1up, CQR1UP, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()),
                                  m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                  F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ()),
                                  F77_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
-    qr<FloatComplexMatrix>::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
+    qr<FloatComplexMatrix>::update (const FloatComplexMatrix& u,
+                                    const FloatComplexMatrix& v)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
@@ -1595,17 +1616,18 @@ namespace octave
                                      m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                      F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ()),
                                      F77_CMPLX_ARG (w), rw));
         }
     }
 
     template <>
     void
-    qr<FloatComplexMatrix>::insert_col (const FloatComplexColumnVector& u, octave_idx_type j)
+    qr<FloatComplexMatrix>::insert_col (const FloatComplexColumnVector& u,
+                                        octave_idx_type j)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       if (u.numel () != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
       if (j < 0 || j > n)
@@ -1625,17 +1647,18 @@ namespace octave
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinc, CQRINC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
                                  F77_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
                                  F77_CONST_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
-    qr<FloatComplexMatrix>::insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j)
+    qr<FloatComplexMatrix>::insert_col (const FloatComplexMatrix& u,
+                                        const Array<octave_idx_type>& j)
     {
       octave_idx_type m = q.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = q.columns ();
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
       octave_idx_type nj = js.numel ();
@@ -1742,17 +1765,18 @@ namespace octave
               r.resize (k, n - nj);
             }
 
         }
     }
 
     template <>
     void
-    qr<FloatComplexMatrix>::insert_row (const FloatComplexRowVector& u, octave_idx_type j)
+    qr<FloatComplexMatrix>::insert_row (const FloatComplexRowVector& u,
+                                        octave_idx_type j)
     {
       octave_idx_type m = r.rows ();
       octave_idx_type n = r.columns ();
       octave_idx_type k = std::min (m, n);
 
       if (! q.is_square () || u.numel () != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
       if (j < 0 || j > m)
@@ -1817,8 +1841,9 @@ namespace octave
 
     template class qr<FloatMatrix>;
 
     template class qr<ComplexMatrix>;
 
     template class qr<FloatComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/qr.h b/liboctave/numeric/qr.h
--- a/liboctave/numeric/qr.h
+++ b/liboctave/numeric/qr.h
@@ -39,21 +39,21 @@ namespace octave
     {
     public:
 
       typedef typename T::element_type ELT_T;
       typedef typename T::row_vector_type RV_T;
       typedef typename T::column_vector_type CV_T;
 
       enum type
-        {
-          std,
-          raw,
-          economy
-        };
+      {
+        std,
+        raw,
+        economy
+      };
 
       qr (void) : q (), r () { }
 
       qr (const T& a, type qr_type = qr::std)
         : q (), r ()
       {
         init (a, qr_type);
       }
@@ -111,8 +111,9 @@ namespace octave
       void form (octave_idx_type n, T& afact, ELT_T *tau, type qr_type);
     };
 
     extern void warn_qrupdate_once (void);
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -300,8 +300,9 @@ namespace octave
     qrp<FloatComplexMatrix>::Pvec (void) const
     {
       Array<float> pa (p.col_perm_vec ());
       FloatRowVector pv (MArray<float> (pa) + 1.0f);
       return pv;
     }
   }
 }
+
diff --git a/liboctave/numeric/qrp.h b/liboctave/numeric/qrp.h
--- a/liboctave/numeric/qrp.h
+++ b/liboctave/numeric/qrp.h
@@ -71,8 +71,9 @@ namespace octave
     private:
 
       PermMatrix p;
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -188,8 +188,9 @@ oct_fill_float_randg (float a, octave_id
 
 float
 oct_float_randg (float a)
 {
   float ret;
   oct_fill_float_randg (a,1,&ret);
   return ret;
 }
+
diff --git a/liboctave/numeric/randgamma.h b/liboctave/numeric/randgamma.h
--- a/liboctave/numeric/randgamma.h
+++ b/liboctave/numeric/randgamma.h
@@ -31,8 +31,9 @@ along with Octave; see the file COPYING.
 extern OCTAVE_API double oct_randg (double a);
 extern OCTAVE_API void oct_fill_randg (double a, octave_idx_type n, double *p);
 
 extern OCTAVE_API float oct_float_randg (float a);
 extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n,
                                              float *p);
 
 #endif
+
diff --git a/liboctave/numeric/randmtzig.cc b/liboctave/numeric/randmtzig.cc
--- a/liboctave/numeric/randmtzig.cc
+++ b/liboctave/numeric/randmtzig.cc
@@ -260,17 +260,18 @@ oct_init_by_entropy (void)
   FILE* urandom = std::fopen ("/dev/urandom", "rb");
   if (urandom)
     {
       while (n < MT_N)
         {
           unsigned char word[4];
           if (std::fread (word, 4, 1, urandom) != 1)
             break;
-          entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(static_cast<uint32_t>(word[3])<<24);
+          entropy[n++] = word[0] + (word[1]<<8) + (word[2]<<16)
+                         + (static_cast<uint32_t> (word[3])<<24);
         }
       std::fclose (urandom);
     }
 
   /* If there isn't enough entropy, gather some from various sources */
 
   octave::sys::time now;
 
@@ -858,8 +859,9 @@ oct_fill_float_randn (octave_idx_type n,
 
 void
 oct_fill_float_rande (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
     p[i] = oct_float_rande ();
 }
+
diff --git a/liboctave/numeric/randmtzig.h b/liboctave/numeric/randmtzig.h
--- a/liboctave/numeric/randmtzig.h
+++ b/liboctave/numeric/randmtzig.h
@@ -89,8 +89,9 @@ extern OCTAVE_API void oct_fill_randu (o
 extern OCTAVE_API void oct_fill_randn (octave_idx_type n, double *p);
 extern OCTAVE_API void oct_fill_rande (octave_idx_type n, double *p);
 
 extern OCTAVE_API void oct_fill_float_randu (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_randn (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_rande (octave_idx_type n, float *p);
 
 #endif
+
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -609,8 +609,9 @@ oct_float_randp (float FL)
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       ret = std::floor (RNOR*sqrt (L) + L + 0.5);
       if (ret < 0.0) ret = 0.0; /* will probably never happen */
     }
   return ret;
 }
+
diff --git a/liboctave/numeric/randpoisson.h b/liboctave/numeric/randpoisson.h
--- a/liboctave/numeric/randpoisson.h
+++ b/liboctave/numeric/randpoisson.h
@@ -36,8 +36,9 @@ oct_fill_randp (double L, octave_idx_typ
 
 extern OCTAVE_API float
 oct_float_randp (float L);
 
 extern OCTAVE_API void
 oct_fill_float_randp (float L, octave_idx_type n, float *p);
 
 #endif
+
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -309,17 +309,18 @@ namespace octave
       octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
       Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
       octave_idx_type *pbwork = bwork.fortran_vec ();
 
       F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                                  F77_CONST_CHAR_ARG2 (&sort, 1),
                                  selector,
                                  F77_CONST_CHAR_ARG2 (&sense, 1),
-                                 n, F77_DBLE_CMPLX_ARG (s), n, sdim, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (q), n, rconde, rcondv,
+                                 n, F77_DBLE_CMPLX_ARG (s), n, sdim, F77_DBLE_CMPLX_ARG (pw),
+                                 F77_DBLE_CMPLX_ARG (q), n, rconde, rcondv,
                                  F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, pbwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       return info;
     }
 
@@ -416,28 +417,30 @@ namespace octave
       octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
       Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
       octave_idx_type *pbwork = bwork.fortran_vec ();
 
       F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                                  F77_CONST_CHAR_ARG2 (&sort, 1),
                                  selector,
                                  F77_CONST_CHAR_ARG2 (&sense, 1),
-                                 n, F77_CMPLX_ARG (s), n, sdim, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (q), n, rconde, rcondv,
+                                 n, F77_CMPLX_ARG (s), n, sdim, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (q), n, rconde,
+                                 rcondv,
                                  F77_CMPLX_ARG (pwork), lwork, prwork, pbwork, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       return info;
     }
 
     template <>
     schur<FloatComplexMatrix>
-    rsf2csf<FloatComplexMatrix, FloatMatrix> (const FloatMatrix& s_arg, const FloatMatrix& u_arg)
+    rsf2csf<FloatComplexMatrix, FloatMatrix> (const FloatMatrix& s_arg,
+                                              const FloatMatrix& u_arg)
     {
       FloatComplexMatrix s (s_arg);
       FloatComplexMatrix u (u_arg);
 
       octave_idx_type n = s.rows ();
 
       if (s.columns () != n || u.rows () != n || u.columns () != n)
         (*current_liboctave_error_handler)
@@ -461,8 +464,9 @@ namespace octave
 
     template class schur<FloatComplexMatrix>;
 
     template class schur<FloatMatrix>;
 
     template class schur<Matrix>;
   }
 }
+
diff --git a/liboctave/numeric/schur.h b/liboctave/numeric/schur.h
--- a/liboctave/numeric/schur.h
+++ b/liboctave/numeric/schur.h
@@ -99,8 +99,9 @@ namespace octave
 
     template <typename RT, typename AT>
     extern schur<RT>
     rsf2csf (const AT& s, const AT& u);
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -572,25 +572,27 @@ namespace octave
 
     // SparseComplexMatrix specialization (the value for the NATURAL
     // parameter in the sparse_chol<T>::sparse_chol_rep constructor is
     // different from the default).
 
     template <>
     sparse_chol<SparseComplexMatrix>::sparse_chol (const SparseComplexMatrix& a,
                                                    octave_idx_type& info)
-      : rep (
-             new sparse_chol<SparseComplexMatrix>::sparse_chol_rep (a, info, true, false))
+      : rep (new sparse_chol<SparseComplexMatrix>::sparse_chol_rep (a, info,
+                                                                    true,
+                                                                    false))
     { }
 
     // Instantiations we need.
 
     template class sparse_chol<SparseMatrix>;
 
     template class sparse_chol<SparseComplexMatrix>;
 
     template SparseMatrix
     chol2inv<SparseMatrix> (const SparseMatrix& r);
 
     template SparseComplexMatrix
     chol2inv<SparseComplexMatrix> (const SparseComplexMatrix& r);
   }
 }
+
diff --git a/liboctave/numeric/sparse-chol.h b/liboctave/numeric/sparse-chol.h
--- a/liboctave/numeric/sparse-chol.h
+++ b/liboctave/numeric/sparse-chol.h
@@ -92,14 +92,15 @@ namespace octave
 
     template <typename chol_type>
     chol_type
     chol2inv (const chol_type& r);
 
     // SparseComplexMatrix specialization.
 
     template <>
-    sparse_chol<SparseComplexMatrix>::sparse_chol (const SparseComplexMatrix& a,
-                                                   octave_idx_type& info);
+    sparse_chol<SparseComplexMatrix>::sparse_chol
+      (const SparseComplexMatrix& a, octave_idx_type& info);
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -408,17 +408,18 @@ dmsolve (const ST &a, const T &b, octave
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2],
+                                           b_nr, 0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
 
           if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[2], 0, b_nc);
@@ -456,17 +457,18 @@ dmsolve (const ST &a, const T &b, octave
             }
         }
 
       // Trailing under-determined block
       if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1], 0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1],
+                                           0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
 
 #else
 
diff --git a/liboctave/numeric/sparse-dmsolve.h b/liboctave/numeric/sparse-dmsolve.h
--- a/liboctave/numeric/sparse-dmsolve.h
+++ b/liboctave/numeric/sparse-dmsolve.h
@@ -26,8 +26,9 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 template <typename RT, typename ST, typename T>
 RT
 dmsolve (const ST& a, const T& b, octave_idx_type& info);
 
 #endif
+
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -54,17 +54,18 @@ namespace octave
     umfpack_free_numeric (void **Numeric);
 
     template <typename T>
     void
     umfpack_free_symbolic (void **Symbolic);
 
     template <typename T>
     octave_idx_type
-    umfpack_get_lunz (octave_idx_type *lnz, octave_idx_type *unz, void *Numeric);
+    umfpack_get_lunz (octave_idx_type *lnz, octave_idx_type *unz,
+                      void *Numeric);
 
     template <typename T>
     octave_idx_type
     umfpack_get_numeric (octave_idx_type *Lp, octave_idx_type *Lj,
                          T *Lx, // Or Lz_packed
                          octave_idx_type *Up, octave_idx_type *Ui,
                          T *Ux, // Or Uz_packed
                          octave_idx_type *p, octave_idx_type *q,
@@ -92,17 +93,18 @@ namespace octave
 
     template <typename T>
     void
     umfpack_report_info (const double *Control, const double *Info);
 
     template <typename T>
     void
     umfpack_report_matrix (octave_idx_type n_row, octave_idx_type n_col,
-                           const octave_idx_type *Ap, const octave_idx_type *Ai,
+                           const octave_idx_type *Ap,
+                           const octave_idx_type *Ai,
                            const T *Ax, // Or Az_packed
                            octave_idx_type col_form, const double *Control);
 
     template <typename T>
     void
     umfpack_report_numeric (void *Numeric, const double *Control);
 
     template <typename T>
@@ -205,17 +207,18 @@ namespace octave
 
     template <>
     inline void
     umfpack_report_matrix<double>
     (octave_idx_type n_row, octave_idx_type n_col, const octave_idx_type *Ap,
      const octave_idx_type *Ai, const double *Ax, octave_idx_type col_form,
      const double *Control)
     {
-      UMFPACK_DNAME (report_matrix) (n_row, n_col, Ap, Ai, Ax, col_form, Control);
+      UMFPACK_DNAME (report_matrix) (n_row, n_col, Ap, Ai, Ax,
+                                     col_form, Control);
     }
 
     template <>
     inline void
     umfpack_report_numeric<double> (void *Numeric, const double *Control)
     {
       UMFPACK_DNAME (report_numeric) (Numeric, Control);
     }
@@ -426,39 +429,43 @@ namespace octave
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       umfpack_report_control<lu_elt_type> (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const lu_elt_type *Ax = a.data ();
 
-      umfpack_report_matrix<lu_elt_type> (nr, nc, Ap, Ai, Ax, static_cast<octave_idx_type> (1), control);
+      umfpack_report_matrix<lu_elt_type> (nr, nc, Ap, Ai, Ax,
+                                          static_cast<octave_idx_type> (1),
+                                          control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax, 0, &Symbolic, control, info);
+      int status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax, 0,
+                                                   &Symbolic, control, info);
 
       if (status < 0)
         {
           umfpack_report_status<lu_elt_type> (control, status);
           umfpack_report_info<lu_elt_type> (control, info);
 
           umfpack_free_symbolic<lu_elt_type> (&Symbolic);
 
           (*current_liboctave_error_handler)
             ("sparse_lu: symbolic factorization failed");
         }
       else
         {
           umfpack_report_symbolic<lu_elt_type> (Symbolic, control);
 
           void *Numeric;
-          status = umfpack_numeric<lu_elt_type> (Ap, Ai, Ax, Symbolic, &Numeric, control, info);
+          status = umfpack_numeric<lu_elt_type> (Ap, Ai, Ax, Symbolic,
+                                                 &Numeric, control, info);
           umfpack_free_symbolic<lu_elt_type> (&Symbolic);
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               umfpack_report_status<lu_elt_type> (control, status);
               umfpack_report_info<lu_elt_type> (control, info);
@@ -485,26 +492,28 @@ namespace octave
                   (*current_liboctave_error_handler)
                     ("sparse_lu: extracting LU factors failed");
                 }
               else
                 {
                   octave_idx_type n_inner = (nr < nc ? nr : nc);
 
                   if (lnz < 1)
-                    Lfact = lu_type (n_inner, nr, static_cast<octave_idx_type> (1));
+                    Lfact = lu_type (n_inner, nr,
+                                     static_cast<octave_idx_type> (1));
                   else
                     Lfact = lu_type (n_inner, nr, lnz);
 
                   octave_idx_type *Ltp = Lfact.cidx ();
                   octave_idx_type *Ltj = Lfact.ridx ();
                   lu_elt_type *Ltx = Lfact.data ();
 
                   if (unz < 1)
-                    Ufact = lu_type (n_inner, nc, static_cast<octave_idx_type> (1));
+                    Ufact = lu_type (n_inner, nc,
+                                     static_cast<octave_idx_type> (1));
                   else
                     Ufact = lu_type (n_inner, nc, unz);
 
                   octave_idx_type *Up = Ufact.cidx ();
                   octave_idx_type *Uj = Ufact.ridx ();
                   lu_elt_type *Ux = Ufact.data ();
 
                   Rfact = SparseMatrix (nr, nr, nr);
@@ -518,17 +527,21 @@ namespace octave
 
                   P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
-                  status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx, Up, Uj, Ux, p, q, 0, &do_recip, Rx, Numeric);
+                  status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx,
+                                                             Up, Uj, Ux,
+                                                             p, q, 0,
+                                                             &do_recip, Rx,
+                                                             Numeric);
 
                   umfpack_free_numeric<lu_elt_type> (&Numeric);
 
                   if (status < 0)
                     {
                       umfpack_report_status<lu_elt_type> (control, status);
 
                       (*current_liboctave_error_handler)
@@ -537,18 +550,28 @@ namespace octave
                   else
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
-                      umfpack_report_matrix<lu_elt_type> (nr, n_inner, Lfact.cidx (), Lfact.ridx (), Lfact.data (), static_cast<octave_idx_type> (1), control);
-                      umfpack_report_matrix<lu_elt_type> (n_inner, nc, Ufact.cidx (), Ufact.ridx (), Ufact.data (), static_cast<octave_idx_type> (1), control);
+                      umfpack_report_matrix<lu_elt_type> (nr, n_inner,
+                                                          Lfact.cidx (),
+                                                          Lfact.ridx (),
+                                                          Lfact.data (),
+                                                          static_cast<octave_idx_type> (1),
+                                                          control);
+                      umfpack_report_matrix<lu_elt_type> (n_inner, nc,
+                                                          Ufact.cidx (),
+                                                          Ufact.ridx (),
+                                                          Ufact.data (),
+                                                          static_cast<octave_idx_type> (1),
+                                                          control);
                       umfpack_report_perm<lu_elt_type> (nr, p, control);
                       umfpack_report_perm<lu_elt_type> (nc, q, control);
                     }
 
                   umfpack_report_info<lu_elt_type> (control, info);
                 }
             }
         }
@@ -631,32 +654,36 @@ namespace octave
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       umfpack_report_control<lu_elt_type> (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const lu_elt_type *Ax = a.data ();
 
-      umfpack_report_matrix<lu_elt_type> (nr, nc, Ap, Ai, Ax, static_cast<octave_idx_type> (1), control);
+      umfpack_report_matrix<lu_elt_type> (nr, nc, Ap, Ai, Ax,
+                                          static_cast<octave_idx_type> (1),
+                                          control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do
         {
           OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
           for (octave_idx_type i = 0; i < nc; i++)
             qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
-          status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax, qinit, &Symbolic, control, info);
+          status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax,
+                                                   qinit, &Symbolic, control,
+                                                   info);
         }
       while (0);
 
       if (status < 0)
         {
           umfpack_report_status<lu_elt_type> (control, status);
           umfpack_report_info<lu_elt_type> (control, info);
 
@@ -665,17 +692,18 @@ namespace octave
           (*current_liboctave_error_handler)
             ("sparse_lu: symbolic factorization failed");
         }
       else
         {
           umfpack_report_symbolic<lu_elt_type> (Symbolic, control);
 
           void *Numeric;
-          status = umfpack_numeric<lu_elt_type> (Ap, Ai, Ax, Symbolic, &Numeric, control, info);
+          status = umfpack_numeric<lu_elt_type> (Ap, Ai, Ax, Symbolic,
+                                                 &Numeric, control, info);
           umfpack_free_symbolic<lu_elt_type> (&Symbolic);
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               umfpack_report_status<lu_elt_type> (control, status);
               umfpack_report_info<lu_elt_type> (control, info);
@@ -702,26 +730,28 @@ namespace octave
                   (*current_liboctave_error_handler)
                     ("sparse_lu: extracting LU factors failed");
                 }
               else
                 {
                   octave_idx_type n_inner = (nr < nc ? nr : nc);
 
                   if (lnz < 1)
-                    Lfact = lu_type (n_inner, nr, static_cast<octave_idx_type> (1));
+                    Lfact = lu_type (n_inner, nr,
+                                     static_cast<octave_idx_type> (1));
                   else
                     Lfact = lu_type (n_inner, nr, lnz);
 
                   octave_idx_type *Ltp = Lfact.cidx ();
                   octave_idx_type *Ltj = Lfact.ridx ();
                   lu_elt_type *Ltx = Lfact.data ();
 
                   if (unz < 1)
-                    Ufact = lu_type (n_inner, nc, static_cast<octave_idx_type> (1));
+                    Ufact = lu_type (n_inner, nc,
+                                     static_cast<octave_idx_type> (1));
                   else
                     Ufact = lu_type (n_inner, nc, unz);
 
                   octave_idx_type *Up = Ufact.cidx ();
                   octave_idx_type *Uj = Ufact.ridx ();
                   lu_elt_type *Ux = Ufact.data ();
 
                   Rfact = SparseMatrix (nr, nr, nr);
@@ -735,17 +765,21 @@ namespace octave
 
                   P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
-                  status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx, Up, Uj, Ux, p, q, 0, &do_recip, Rx, Numeric);
+                  status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx,
+                                                             Up, Uj, Ux,
+                                                             p, q, 0,
+                                                             &do_recip,
+                                                             Rx, Numeric);
 
                   umfpack_free_numeric<lu_elt_type> (&Numeric);
 
                   if (status < 0)
                     {
                       umfpack_report_status<lu_elt_type> (control, status);
 
                       (*current_liboctave_error_handler)
@@ -754,18 +788,28 @@ namespace octave
                   else
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
-                      umfpack_report_matrix<lu_elt_type> (nr, n_inner, Lfact.cidx (), Lfact.ridx (), Lfact.data (), static_cast<octave_idx_type> (1), control);
-                      umfpack_report_matrix<lu_elt_type> (n_inner, nc, Ufact.cidx (), Ufact.ridx (), Ufact.data (), static_cast<octave_idx_type> (1), control);
+                      umfpack_report_matrix<lu_elt_type> (nr, n_inner,
+                                                          Lfact.cidx (),
+                                                          Lfact.ridx (),
+                                                          Lfact.data (),
+                                                          static_cast<octave_idx_type> (1),
+                                                          control);
+                      umfpack_report_matrix<lu_elt_type> (n_inner, nc,
+                                                          Ufact.cidx (),
+                                                          Ufact.ridx (),
+                                                          Ufact.data (),
+                                                          static_cast<octave_idx_type> (1),
+                                                          control);
                       umfpack_report_perm<lu_elt_type> (nr, p, control);
                       umfpack_report_perm<lu_elt_type> (nc, q, control);
                     }
 
                   umfpack_report_info<lu_elt_type> (control, info);
                 }
             }
         }
@@ -912,8 +956,9 @@ namespace octave
 
     // Instantiations we need.
 
     template class sparse_lu<SparseMatrix>;
 
     template class sparse_lu<SparseComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/sparse-lu.h b/liboctave/numeric/sparse-lu.h
--- a/liboctave/numeric/sparse-lu.h
+++ b/liboctave/numeric/sparse-lu.h
@@ -115,8 +115,9 @@ namespace octave
 
       MArray<octave_idx_type> P;
       MArray<octave_idx_type> Q;
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -949,17 +949,18 @@ namespace octave
 
       A.nzmax = a.nnz ();
       A.m = nrows;
       A.n = ncols;
       // Cast away const on A, with full knowledge that CSparse won't touch it
       // Prevents the methods below making a copy of the data.
       A.p = const_cast<octave_idx_type *>(a.cidx ());
       A.i = const_cast<octave_idx_type *>(a.ridx ());
-      A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *> (a.data ()));
+      A.x = const_cast<cs_complex_t *> (
+              reinterpret_cast<const cs_complex_t *> (a.data ()));
       A.nz = -1;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
       N = CXSPARSE_ZNAME (_qr) (&A, S);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       if (! N)
@@ -1039,17 +1040,18 @@ namespace octave
       CXSPARSE_ZNAME (_spfree) (N->U);
       N->U = CXSPARSE_ZNAME (_transpose) (D, 1);
       CXSPARSE_ZNAME (_spfree) (D);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       octave_idx_type nc = N->U->n;
       octave_idx_type nz = N->U->nzmax;
 
-      SparseComplexMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
+      SparseComplexMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows),
+                               nc, nz);
 
       for (octave_idx_type j = 0; j < nc+1; j++)
         ret.xcidx (j) = N->U->p[j];
 
       for (octave_idx_type j = 0; j < nz; j++)
         {
           ret.xridx (j) = N->U->i[j];
           ret.xdata (j) = reinterpret_cast<Complex *>(N->U->x)[j];
@@ -1070,45 +1072,50 @@ namespace octave
     ComplexMatrix
     sparse_qr<SparseComplexMatrix>::sparse_qr_rep::C (const ComplexMatrix& b) const
     {
 #if defined (HAVE_CXSPARSE)
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
       octave_idx_type nc = N->L->n;
       octave_idx_type nr = nrows;
-      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
+      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *> (b.fortran_vec ());
       ComplexMatrix ret (b_nr, b_nc);
       Complex *vec = ret.fortran_vec ();
 
       if (nr < 0 || nc < 0 || nr != b_nr)
         (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
       if (nr == 0 || nc == 0 || b_nc == 0)
         ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
       else
         {
           OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
 
-          for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
+          for (volatile octave_idx_type j = 0, idx = 0;
+               j < b_nc;
+               j++, idx += b_nr)
             {
               octave_quit ();
 
               volatile octave_idx_type nm = (nr < nc ? nr : nc);
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
+              CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec + idx,
+                                       reinterpret_cast<cs_complex_t *> (buf),
+                                       b_nr);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               for (volatile octave_idx_type i = 0; i < nm; i++)
                 {
                   octave_quit ();
 
                   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-                  CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
+                  CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i],
+                                            reinterpret_cast<cs_complex_t *> (buf));
                   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
                 }
 
               for (octave_idx_type i = 0; i < b_nr; i++)
                 vec[i+idx] = buf[i];
             }
         }
 
@@ -1151,25 +1158,28 @@ namespace octave
             {
               octave_quit ();
 
               bvec[j] = cs_complex_t (1.0, 0.0);
 
               volatile octave_idx_type nm = (nr < nc ? nr : nc);
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
+              CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec,
+                                       reinterpret_cast<cs_complex_t *> (buf),
+                                       nr);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               for (volatile octave_idx_type i = 0; i < nm; i++)
                 {
                   octave_quit ();
 
                   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-                  CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
+                  CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i],
+                                            reinterpret_cast<cs_complex_t *> (buf));
                   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
                 }
 
               for (octave_idx_type i = 0; i < nr; i++)
                 vec[i+idx] = buf[i];
 
               bvec[j] = cs_complex_t (0.0, 0.0);
             }
@@ -1182,18 +1192,19 @@ namespace octave
       return ComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
-    sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<SparseComplexMatrix, SparseComplexMatrix>
-    (const SparseComplexMatrix& b, octave_idx_type& info) const
+    sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<SparseComplexMatrix,
+                                                       SparseComplexMatrix>
+      (const SparseComplexMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       octave_idx_type nr = nrows;
       octave_idx_type nc = ncols;
 
@@ -1297,18 +1308,19 @@ namespace octave
       return SparseComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
-    sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<SparseComplexMatrix, SparseComplexMatrix>
-    (const SparseComplexMatrix& b, octave_idx_type& info) const
+    sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<SparseComplexMatrix,
+                                                       SparseComplexMatrix>
+      (const SparseComplexMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       // These are swapped because the original matrix was transposed in
       // sparse_qr<SparseMatrix>::solve.
 
@@ -1418,18 +1430,19 @@ namespace octave
       return SparseComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     ComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<double>, ComplexMatrix>
-    (const MArray<double>& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<double>,
+                                                              ComplexMatrix>
+      (const MArray<double>& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       octave_idx_type nr = nrows;
       octave_idx_type nc = ncols;
 
@@ -1448,17 +1461,19 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < S->m2; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (S->pinv,
+                                   reinterpret_cast<cs_complex_t *>(Xx),
+                                   buf, nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
@@ -1482,18 +1497,19 @@ namespace octave
       return ComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     ComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<double>, ComplexMatrix>
-    (const MArray<double>& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<double>,
+                                                              ComplexMatrix>
+      (const MArray<double>& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       // These are swapped because the original matrix was transposed in
       // sparse_qr<SparseComplexMatrix>::solve.
 
@@ -1521,17 +1537,18 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx),
+                                  buf, nr);
           CXSPARSE_ZNAME (_utsolve) (N->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -1555,18 +1572,19 @@ namespace octave
       return ComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<SparseMatrix, SparseComplexMatrix>
-    (const SparseMatrix& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<SparseMatrix,
+                                                              SparseComplexMatrix>
+      (const SparseMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       octave_idx_type nr = nrows;
       octave_idx_type nc = ncols;
 
@@ -1588,31 +1606,35 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < S->m2; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (S->pinv,
+                                   reinterpret_cast<cs_complex_t *>(Xx),
+                                   buf, nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (N->U, buf);
-          CXSPARSE_ZNAME (_ipvec) (S->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_ipvec) (S->q, buf,
+                                   reinterpret_cast<cs_complex_t *> (Xx),
+                                   nc);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
 
               if (tmp != 0.0)
                 {
@@ -1646,18 +1668,19 @@ namespace octave
       return SparseComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<SparseMatrix, SparseComplexMatrix>
-    (const SparseMatrix& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<SparseMatrix,
+                                                              SparseComplexMatrix>
+      (const SparseMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       // These are swapped because the original matrix was transposed in
       // sparse_qr<SparseComplexMatrix>::solve.
 
@@ -1687,31 +1710,35 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec) (S->q,
+                                  reinterpret_cast<cs_complex_t *>(Xx),
+                                  buf, nr);
           CXSPARSE_ZNAME (_utsolve) (N->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_pvec) (S->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_pvec) (S->pinv, buf,
+                                  reinterpret_cast<cs_complex_t *> (Xx),
+                                  nc);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
 
               if (tmp != 0.0)
                 {
@@ -1745,34 +1772,36 @@ namespace octave
       return SparseComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     ComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<Complex>, ComplexMatrix>
-    (const MArray<Complex>& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<Complex>,
+                                                              ComplexMatrix>
+      (const MArray<Complex>& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       octave_idx_type nr = nrows;
       octave_idx_type nc = ncols;
 
       octave_idx_type b_nc = b.cols ();
       octave_idx_type b_nr = b.rows ();
 
-      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
+      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>
+                                 (b.fortran_vec ());
 
       ComplexMatrix x (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec ());
+                          (x.fortran_vec ());
 
       OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, S->m2);
 
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
 
@@ -1809,33 +1838,35 @@ namespace octave
       return ComplexMatrix ();
 
 #endif
     }
 
     template <>
     template <>
     ComplexMatrix
-    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<Complex>, ComplexMatrix>
-    (const MArray<Complex>& b, octave_idx_type& info) const
+    sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<Complex>,
+                                                              ComplexMatrix>
+      (const MArray<Complex>& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       // These are swapped because the original matrix was transposed in
       // sparse_qr<SparseComplexMatrix>::solve.
 
       octave_idx_type nr = ncols;
       octave_idx_type nc = nrows;
 
       octave_idx_type b_nc = b.cols ();
       octave_idx_type b_nr = b.rows ();
 
-      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
+      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>
+                                 (b.fortran_vec ());
 
       ComplexMatrix x (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
 
       volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
 
       OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
       OCTAVE_LOCAL_BUFFER (double, B, nr);
@@ -1882,17 +1913,17 @@ namespace octave
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
     sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<SparseComplexMatrix, SparseComplexMatrix>
-    (const SparseComplexMatrix& b, octave_idx_type& info) const
+      (const SparseComplexMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       octave_idx_type nr = nrows;
       octave_idx_type nc = ncols;
 
@@ -1914,31 +1945,35 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < S->m2; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (S->pinv,
+                                   reinterpret_cast<cs_complex_t *>(Xx),
+                                   buf, nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (N->U, buf);
-          CXSPARSE_ZNAME (_ipvec) (S->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_ipvec) (S->q, buf,
+                                   reinterpret_cast<cs_complex_t *> (Xx),
+                                   nc);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
 
               if (tmp != 0.0)
                 {
@@ -1973,17 +2008,17 @@ namespace octave
 
 #endif
     }
 
     template <>
     template <>
     SparseComplexMatrix
     sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<SparseComplexMatrix, SparseComplexMatrix>
-    (const SparseComplexMatrix& b, octave_idx_type& info) const
+      (const SparseComplexMatrix& b, octave_idx_type& info) const
     {
       info = -1;
 
 #if defined (HAVE_CXSPARSE)
 
       // These are swapped because the original matrix was transposed in
       // sparse_qr<SparseComplexMatrix>::solve.
 
@@ -2013,31 +2048,33 @@ namespace octave
 
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
 
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = cs_complex_t (0.0, 0.0);
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+          CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx),
+                                  buf, nr);
           CXSPARSE_ZNAME (_utsolve) (N->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_pvec) (S->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+          CXSPARSE_ZNAME (_pvec) (S->pinv, buf,
+                                  reinterpret_cast<cs_complex_t *>(Xx), nc);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
 
               if (tmp != 0.0)
                 {
@@ -2204,17 +2241,17 @@ namespace octave
 
       octave_idx_type b_nc = b.cols ();
       octave_idx_type b_nr = b.rows ();
 
       int order = cxsparse_defaults<SPARSE_T>::order;
 
       if (nr < 0 || nc < 0 || nr != b_nr)
         (*current_liboctave_error_handler)
-               ("matrix dimension mismatch in solution of minimum norm problem");
+          ("matrix dimension mismatch in solution of minimum norm problem");
 
       if (nr == 0 || nc == 0 || b_nc == 0)
         {
           info = 0;
 
           return RET_T (nc, b_nc, 0.0);
         }
       else if (nr >= nc)
@@ -2246,67 +2283,78 @@ namespace octave
     {
       return rep->template wide_solve<RHS_T, RET_T> (b, info);
     }
 
     Matrix
     qrsolve (const SparseMatrix& a, const MArray<double>& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseMatrix>::solve<MArray<double>, Matrix> (a, b, info);
+      return sparse_qr<SparseMatrix>::solve<MArray<double>, Matrix> (a, b,
+                                                                     info);
     }
 
     SparseMatrix
     qrsolve (const SparseMatrix& a, const SparseMatrix& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseMatrix>::solve<SparseMatrix, SparseMatrix> (a, b, info);
+      return sparse_qr<SparseMatrix>::solve<SparseMatrix, SparseMatrix> (a, b,
+                                                                         info);
     }
 
     ComplexMatrix
     qrsolve (const SparseMatrix& a, const MArray<Complex>& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseMatrix>::solve<MArray<Complex>, ComplexMatrix> (a, b, info);
+      return sparse_qr<SparseMatrix>::solve<MArray<Complex>,
+                                            ComplexMatrix> (a, b, info);
     }
 
     SparseComplexMatrix
     qrsolve (const SparseMatrix& a, const SparseComplexMatrix& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseMatrix>::solve<SparseComplexMatrix, SparseComplexMatrix> (a, b, info);
+      return sparse_qr<SparseMatrix>::solve<SparseComplexMatrix,
+                                            SparseComplexMatrix> (a, b, info);
     }
 
     ComplexMatrix
     qrsolve (const SparseComplexMatrix& a, const MArray<double>& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseComplexMatrix>::solve<MArray<double>, ComplexMatrix> (a, b, info);
+      return sparse_qr<SparseComplexMatrix>::solve<MArray<double>,
+                                                   ComplexMatrix> (a, b, info);
     }
 
     SparseComplexMatrix
     qrsolve (const SparseComplexMatrix& a, const SparseMatrix& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseComplexMatrix>::solve<SparseMatrix, SparseComplexMatrix> (a, b, info);
+      return sparse_qr<SparseComplexMatrix>::solve<SparseMatrix,
+                                                   SparseComplexMatrix>
+                                             (a, b, info);
     }
 
     ComplexMatrix
     qrsolve (const SparseComplexMatrix& a, const MArray<Complex>& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseComplexMatrix>::solve<MArray<Complex>, ComplexMatrix> (a, b, info);
+      return sparse_qr<SparseComplexMatrix>::solve<MArray<Complex>,
+                                                   ComplexMatrix> (a, b, info);
     }
 
     SparseComplexMatrix
     qrsolve (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
              octave_idx_type& info)
     {
-      return sparse_qr<SparseComplexMatrix>::solve<SparseComplexMatrix, SparseComplexMatrix> (a, b, info);
+      return sparse_qr<SparseComplexMatrix>::solve<SparseComplexMatrix,
+                                                   SparseComplexMatrix>
+                                             (a, b, info);
     }
 
     // Instantiations we need.
 
     template class sparse_qr<SparseMatrix>;
 
     template class sparse_qr<SparseComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/sparse-qr.h b/liboctave/numeric/sparse-qr.h
--- a/liboctave/numeric/sparse-qr.h
+++ b/liboctave/numeric/sparse-qr.h
@@ -127,8 +127,9 @@ namespace octave
              octave_idx_type& info);
 
     typedef sparse_qr<SparseMatrix> SparseQR;
     typedef sparse_qr<SparseComplexMatrix> SparseComplexQR;
   }
 }
 
 #endif
+
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -408,8 +408,9 @@ namespace octave
 
     template class svd<FloatMatrix>;
 
     template class svd<ComplexMatrix>;
 
     template class svd<FloatComplexMatrix>;
   }
 }
+
diff --git a/liboctave/numeric/svd.h b/liboctave/numeric/svd.h
--- a/liboctave/numeric/svd.h
+++ b/liboctave/numeric/svd.h
@@ -38,25 +38,25 @@ namespace octave
     {
     public:
 
       typedef typename T::real_diag_matrix_type DM_T;
 
       enum class Type
       {
         std,
-          economy,
-          sigma_only
-          };
+        economy,
+        sigma_only
+      };
 
       enum class Driver
       {
         GESVD,
-          GESDD
-          };
+        GESDD
+      };
 
       svd (void)
         : m_type (), m_driver (), left_sm (), sigma (), right_sm ()
       { }
 
       svd (const T& a, svd::Type type = svd::Type::std,
            svd::Driver driver = svd::Driver::GESVD);
 
@@ -109,8 +109,9 @@ namespace octave
                   octave_idx_type nrow_vt1, std::vector<P>& work,
                   octave_idx_type& lwork,
                   octave_idx_type* iwork, octave_idx_type& info);
     };
   }
 }
 
 #endif
+
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -172,44 +172,50 @@ RT do_commutative_add_dm_sm (const DM& d
                                  identity_val<typename SM::element_type> (),
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_add_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    octave::err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator +",
+                               d.rows (), d.cols (), a.rows (), a.cols ());
   else
     return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_sub_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    octave::err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator -",
+                               d.rows (), d.cols (), a.rows (), a.cols ());
 
-  return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
+  return inner_do_add_sm_dm<RT> (a, d,
+                                 std::negate<typename SM::element_type> (),
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_add_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    octave::err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
+    octave::err_nonconformant ("operator +",
+                               a.rows (), a.cols (), d.rows (), d.cols ());
 
   return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_sub_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
-    octave::err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
+    octave::err_nonconformant ("operator -",
+                               a.rows (), a.cols (), d.rows (), d.cols ());
 
   return inner_do_add_sm_dm<RT> (a, d,
                                  identity_val<typename SM::element_type> (),
                                  std::negate<typename DM::element_type> ());
 }
 
 #endif
+
diff --git a/liboctave/operators/Sparse-op-decls.h b/liboctave/operators/Sparse-op-decls.h
--- a/liboctave/operators/Sparse-op-decls.h
+++ b/liboctave/operators/Sparse-op-decls.h
@@ -179,8 +179,9 @@ class SparseBoolMatrix;
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
 #define SPARSE_SMM_OP_DECLS(R1, R2, M1, M2, API)        \
   SPARSE_SMM_BIN_OP_DECLS (R1, R2, M1, M2, API)         \
   SPARSE_SMM_CMP_OP_DECLS (M1, M2, API)                 \
   SPARSE_SMM_BOOL_OP_DECLS (M1, M2, API)
 
 #endif
+
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1983,8 +1983,9 @@ along with Octave; see the file COPYING.
               for (octave_idx_type k = 0 ; k < nr; k++)                 \
                 retval.xelem (k,col) += tmpval * m.elem (k,i);          \
             }                                                           \
         }                                                               \
       return retval;                                                    \
     }
 
 #endif
+
diff --git a/liboctave/operators/Sparse-perm-op-defs.h b/liboctave/operators/Sparse-perm-op-defs.h
--- a/liboctave/operators/Sparse-perm-op-defs.h
+++ b/liboctave/operators/Sparse-perm-op-defs.h
@@ -59,17 +59,18 @@ SM octinternal_do_mul_colpm_sm (const oc
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
   const octave_idx_type nr = a.rows ();
   if (p.cols () != nr)
-    octave::err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
+    octave::err_nonconformant ("operator *",
+                               p.rows (), p.cols (), a.rows (), a.cols ());
 
   return octinternal_do_mul_colpm_sm (p.col_perm_vec ().data (), a);
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_rowpm (const SM& a, const octave_idx_type *prow)
 // For a row permutation, iterate across the source a and stuff the
 // results into the correct destination column in r.
@@ -142,14 +143,16 @@ SM octinternal_do_mul_sm_colpm (const SM
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_pm (const SM& a, const PermMatrix& p)
 {
   const octave_idx_type nc = a.cols ();
   if (p.rows () != nc)
-    octave::err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
+    octave::err_nonconformant ("operator *",
+                               a.rows (), a.cols (), p.rows (), p.cols ());
 
   return octinternal_do_mul_sm_colpm (a, p.col_perm_vec ().data ());
 }
 
 #endif
+
diff --git a/liboctave/operators/mx-base.h b/liboctave/operators/mx-base.h
--- a/liboctave/operators/mx-base.h
+++ b/liboctave/operators/mx-base.h
@@ -83,8 +83,9 @@ along with Octave; see the file COPYING.
 #include "int64NDArray.h"
 
 #include "uint8NDArray.h"
 #include "uint16NDArray.h"
 #include "uint32NDArray.h"
 #include "uint64NDArray.h"
 
 #endif
+
diff --git a/liboctave/operators/mx-defs.h b/liboctave/operators/mx-defs.h
--- a/liboctave/operators/mx-defs.h
+++ b/liboctave/operators/mx-defs.h
@@ -113,8 +113,9 @@ inline char
 get_blas_char (blas_trans_type transt)
 {
   return static_cast<char> (transt);
 }
 
 #  endif
 
 #endif
+
diff --git a/liboctave/operators/mx-ext.h b/liboctave/operators/mx-ext.h
--- a/liboctave/operators/mx-ext.h
+++ b/liboctave/operators/mx-ext.h
@@ -66,8 +66,9 @@ along with Octave; see the file COPYING.
 
 #include "lu.h"
 
 // Result of a QR decomposition.
 
 #include "qr.h"
 
 #endif
+
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -544,17 +544,18 @@ do_mx_check (const Array<T>& a,
 {
   return op (a.numel (), a.data ());
 }
 
 // NOTE: we don't use std::norm because it typically does some heavyweight
 // magic to avoid underflows, which we don't need here.
 template <typename T>
 inline T cabsq (const std::complex<T>& c)
-{ return c.real () * c.real () + c.imag () * c.imag ();
+{
+  return c.real () * c.real () + c.imag () * c.imag ();
 }
 
 // default.  works for integers and bool.
 template <typename T>
 inline bool
 xis_true (T x)
 {
   return x;
@@ -1693,8 +1694,9 @@ mx_inline_xsum (const T *v, T *r,
 
   for (octave_idx_type i = 0; i < m; i++)
     r[i] += e[i];
 }
 
 OP_RED_FCNN (mx_inline_xsum, T, T)
 
 #endif
+
diff --git a/liboctave/operators/mx-op-decl.h b/liboctave/operators/mx-op-decl.h
--- a/liboctave/operators/mx-op-decl.h
+++ b/liboctave/operators/mx-op-decl.h
@@ -298,8 +298,9 @@ class boolNDArray;
 #define PMM_BIN_OP_DECLS(R, PM, M, API)         \
   BIN_OP_DECL (R, operator *, PM, M, API);
 
 #define MPM_BIN_OP_DECLS(R, M, PM, API)         \
   BIN_OP_DECL (R, operator *, M, PM, API);
 
 #endif
 
+
diff --git a/liboctave/operators/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
--- a/liboctave/operators/mx-op-defs.h
+++ b/liboctave/operators/mx-op-defs.h
@@ -631,8 +631,9 @@ along with Octave; see the file COPYING.
 #define NDND_MAPPER_BODY(R, NAME)               \
   R retval (dims ());                           \
   octave_idx_type n = numel ();                 \
   for (octave_idx_type i = 0; i < n; i++)       \
     retval.xelem (i) = NAME (elem (i));         \
   return retval;
 
 #endif
+
diff --git a/liboctave/system/child-list.cc b/liboctave/system/child-list.cc
--- a/liboctave/system/child-list.cc
+++ b/liboctave/system/child-list.cc
@@ -156,8 +156,9 @@ namespace octave
                 break;
               }
           }
       }
 
     return retval;
   }
 }
+
diff --git a/liboctave/system/child-list.h b/liboctave/system/child-list.h
--- a/liboctave/system/child-list.h
+++ b/liboctave/system/child-list.h
@@ -47,29 +47,29 @@ namespace octave
 
     typedef bool (*child_event_handler) (pid_t, int);
 
     child (pid_t id = -1, child_event_handler f = 0)
       : pid (id), handler (f), have_status (0), status (0) { }
 
     child (const child& oc)
       : pid (oc.pid), handler (oc.handler),
-      have_status (oc.have_status), status (oc.status) { }
+        have_status (oc.have_status), status (oc.status) { }
 
     child& operator = (const child& oc)
-      {
-        if (&oc != this)
-          {
-            pid = oc.pid;
-            handler = oc.handler;
-            have_status = oc.have_status;
-            status = oc.status;
-          }
-        return *this;
-      }
+    {
+      if (&oc != this)
+        {
+          pid = oc.pid;
+          handler = oc.handler;
+          have_status = oc.have_status;
+          status = oc.status;
+        }
+      return *this;
+    }
 
     ~child (void) { }
 
     // The process id of this child.
     pid_t pid;
 
     // The function we call if an event happens for this child.
     child_event_handler handler;
@@ -129,8 +129,9 @@ OCTAVE_DEPRECATED ("use 'octave::child' 
 typedef octave::child octave_child;
 
 OCTAVE_DEPRECATED ("use 'octave::child_list' instead")
 typedef octave::child_list octave_child_list;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -103,8 +103,9 @@ namespace octave
 
     unsigned int
     dir_entry::max_name_length (void)
     {
       return octave_name_max_wrapper ();
     }
   }
 }
+
diff --git a/liboctave/system/dir-ops.h b/liboctave/system/dir-ops.h
--- a/liboctave/system/dir-ops.h
+++ b/liboctave/system/dir-ops.h
@@ -36,36 +36,36 @@ namespace octave
     class
     OCTAVE_API
     dir_entry
     {
     public:
 
       dir_entry (const std::string& n = "")
         : name (n), dir (0), fail (false), errmsg ()
-        {
-          if (! name.empty ())
-            open ();
-        }
+      {
+        if (! name.empty ())
+          open ();
+      }
 
       dir_entry (const dir_entry& d)
         : name (d.name), dir (d.dir), fail (d.fail), errmsg (d.errmsg) { }
 
       dir_entry& operator = (const dir_entry& d)
-        {
-          if (this != &d)
-            {
-              name = d.name;
-              dir = d.dir;
-              fail = d.fail;
-              errmsg = d.errmsg;
-            }
+      {
+        if (this != &d)
+          {
+            name = d.name;
+            dir = d.dir;
+            fail = d.fail;
+            errmsg = d.errmsg;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~dir_entry (void) { close (); }
 
       bool open (const std::string& = "");
 
       string_vector read (void);
 
       bool close (void);
@@ -100,8 +100,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::sys::dir_entry' instead")
 typedef octave::sys::dir_entry dir_entry;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -106,34 +106,38 @@ namespace octave
     // any word separation get desired behavior.
     static const char *default_suffixes[] = { " ", "\n", ":", 0 };
 
     // If non-null, this contains the address of a function that the
     // application wants called before trying the standard tilde
     // expansions.  The function is called with the text sans tilde, and
     // returns a malloc()'ed string which is the expansion, or a NULL
     // pointer if the expansion fails.
-    octave::sys::file_ops::tilde_expansion_hook octave::sys::file_ops::tilde_expansion_preexpansion_hook = 0;
+    octave::sys::file_ops::tilde_expansion_hook
+      octave::sys::file_ops::tilde_expansion_preexpansion_hook = 0;
 
     // If non-null, this contains the address of a function to call if the
     // standard meaning for expanding a tilde fails.  The function is
     // called with the text (sans tilde, as in "foo"), and returns a
     // malloc()'ed string which is the expansion, or a NULL pointer if
     // there is no expansion.
-    octave::sys::file_ops::tilde_expansion_hook octave::sys::file_ops::tilde_expansion_failure_hook = 0;
+    octave::sys::file_ops::tilde_expansion_hook
+      octave::sys::file_ops::tilde_expansion_failure_hook = 0;
 
     // When non-null, this is a NULL terminated array of strings which are
     // duplicates for a tilde prefix.  Bash uses this to expand '=~' and
     // ':~'.
-    string_vector octave::sys::file_ops::tilde_additional_prefixes = default_prefixes;
+    string_vector octave::sys::file_ops::tilde_additional_prefixes =
+      default_prefixes;
 
     // When non-null, this is a NULL terminated array of strings which
     // match the end of a username, instead of just "/".  Bash sets this
     // to ':' and '=~'.
-    string_vector octave::sys::file_ops::tilde_additional_suffixes = default_suffixes;
+    string_vector octave::sys::file_ops::tilde_additional_suffixes =
+      default_suffixes;
 
     // Find the start of a tilde expansion in S, and return the index
     // of the tilde which starts the expansion.  Place the length of the
     // text which identified this tilde starter in LEN, excluding the
     // tilde itself.
 
     static size_t
     tilde_find_prefix (const std::string& s, size_t& len)
@@ -366,20 +370,20 @@ namespace octave
 
       return retval;
     }
 
     std::string
     octave::sys::file_ops::concat (const std::string& dir, const std::string& file)
     {
       return dir.empty ()
-        ? file
-        : (is_dir_sep (dir[dir.length ()-1])
-           ? dir + file
-           : dir + dir_sep_char () + file);
+             ? file
+             : (is_dir_sep (dir[dir.length ()-1])
+                ? dir + file
+                : dir + dir_sep_char () + file);
     }
 
     std::string
     octave::sys::file_ops::native_separator_path (const std::string& path)
     {
       std::string retval;
 
       if (dir_sep_char () == '/')
@@ -466,17 +470,17 @@ namespace octave
     symlink (const std::string& old_name, const std::string& new_name)
     {
       std::string msg;
       return symlink (old_name, new_name, msg);
     }
 
     int
     symlink (const std::string& old_name,
-                    const std::string& new_name, std::string& msg)
+             const std::string& new_name, std::string& msg)
     {
       msg = "";
 
       int status = -1;
 
       status = octave_symlink_wrapper (old_name.c_str (), new_name.c_str ());
 
       if (status < 0)
@@ -666,17 +670,17 @@ namespace octave
     tempnam (const std::string& dir, const std::string& pfx)
     {
       std::string msg;
       return tempnam (dir, pfx, msg);
     }
 
     std::string
     tempnam (const std::string& dir, const std::string& pfx,
-                    std::string& msg)
+             std::string& msg)
     {
       msg = "";
 
       std::string retval;
 
       // get dir path to use for template
       std::string templatename;
       if (dir.empty ())
@@ -740,8 +744,9 @@ namespace octave
 
       if (retval.empty ())
         msg = std::strerror (errno);
 
       return retval;
     }
   }
 }
+
diff --git a/liboctave/system/file-ops.h b/liboctave/system/file-ops.h
--- a/liboctave/system/file-ops.h
+++ b/liboctave/system/file-ops.h
@@ -388,8 +388,9 @@ inline std::string
 octave_canonicalize_file_name (const std::string& nm, std::string& msg)
 {
   return octave::sys::canonicalize_file_name (nm, msg);
 }
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -244,8 +244,9 @@ namespace octave
               m_ctime = octave::sys::time (sys_ctime);
             }
 
           initialized = true;
         }
     }
   }
 }
+
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -51,39 +51,39 @@ namespace octave
         : initialized (fs.initialized), fail (fs.fail), errmsg (fs.errmsg),
           m_mode (fs.m_mode), m_ino (fs.m_ino), m_dev (fs.m_dev),
           m_nlink (fs.m_nlink), m_uid (fs.m_uid), m_gid (fs.m_gid),
           m_size (fs.m_size), m_atime (fs.m_atime), m_mtime (fs.m_mtime),
           m_ctime (fs.m_ctime), m_rdev (fs.m_rdev),
           m_blksize (fs.m_blksize), m_blocks (fs.m_blocks) { }
 
       base_file_stat& operator = (const base_file_stat& fs)
-        {
-          if (this != &fs)
-            {
-              initialized = fs.initialized;
-              fail = fs.fail;
-              errmsg = fs.errmsg;
-              m_mode = fs.m_mode;
-              m_ino = fs.m_ino;
-              m_dev = fs.m_dev;
-              m_nlink = fs.m_nlink;
-              m_uid = fs.m_uid;
-              m_gid = fs.m_gid;
-              m_size = fs.m_size;
-              m_atime = fs.m_atime;
-              m_mtime = fs.m_mtime;
-              m_ctime = fs.m_ctime;
-              m_rdev = fs.m_rdev;
-              m_blksize = fs.m_blksize;
-              m_blocks = fs.m_blocks;
-            }
+      {
+        if (this != &fs)
+          {
+            initialized = fs.initialized;
+            fail = fs.fail;
+            errmsg = fs.errmsg;
+            m_mode = fs.m_mode;
+            m_ino = fs.m_ino;
+            m_dev = fs.m_dev;
+            m_nlink = fs.m_nlink;
+            m_uid = fs.m_uid;
+            m_gid = fs.m_gid;
+            m_size = fs.m_size;
+            m_atime = fs.m_atime;
+            m_mtime = fs.m_mtime;
+            m_ctime = fs.m_ctime;
+            m_rdev = fs.m_rdev;
+            m_blksize = fs.m_blksize;
+            m_blocks = fs.m_blocks;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       // The minimum difference in file time stamp values.
       // FIXME: This value should come from the filesystem itself.
       //        How can we get that info?
       octave::sys::time time_resolution (void) const
       {
         static octave::sys::time resolution (1.0);
         return resolution;
@@ -215,30 +215,30 @@ namespace octave
         : base_file_stat (), file_name (n), follow_links (fl)
       {
         if (! file_name.empty ())
           update_internal ();
       }
 
       file_stat (const file_stat& fs)
         : base_file_stat (fs), file_name (fs.file_name),
-        follow_links (fs.follow_links) { }
+          follow_links (fs.follow_links) { }
 
       file_stat& operator = (const file_stat& fs)
-        {
-          if (this != &fs)
-            {
-              base_file_stat::operator = (fs);
+      {
+        if (this != &fs)
+          {
+            base_file_stat::operator = (fs);
 
-              file_name = fs.file_name;
-              follow_links = fs.follow_links;
-            }
+            file_name = fs.file_name;
+            follow_links = fs.follow_links;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~file_stat (void) { }
 
       void get_stats (bool force = false)
       {
         if (! initialized || force)
           update_internal (force);
       }
@@ -277,26 +277,26 @@ namespace octave
       {
         update_internal ();
       }
 
       file_fstat (const file_fstat& fs)
         : base_file_stat (fs), fid (fs.fid) { }
 
       file_fstat& operator = (const file_fstat& fs)
-        {
-          if (this != &fs)
-            {
-              base_file_stat::operator = (fs);
+      {
+        if (this != &fs)
+          {
+            base_file_stat::operator = (fs);
 
-              fid = fs.fid;
-            }
+            fid = fs.fid;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~file_fstat (void) { }
 
       void get_stats (bool force = false)
       {
         if (! initialized || force)
           update_internal (force);
       }
@@ -332,8 +332,9 @@ OCTAVE_DEPRECATED ("use 'octave::sys::fi
 typedef octave::sys::file_stat file_stat;
 
 OCTAVE_DEPRECATED ("use 'octave::sys::file_fstat' instead")
 typedef octave::sys::file_fstat file_fstat;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -64,8 +64,9 @@ namespace octave
       if (path.length () == 2 && path[1] == ':')
         path += "\\";
 #endif
 
       return octave_chdir_wrapper (path.c_str ());
     }
   }
 }
+
diff --git a/liboctave/system/lo-sysdep.h b/liboctave/system/lo-sysdep.h
--- a/liboctave/system/lo-sysdep.h
+++ b/liboctave/system/lo-sysdep.h
@@ -49,8 +49,9 @@ OCTAVE_DEPRECATED ("use 'octave::sys::ge
 const auto octave_getcwd = octave::sys::getcwd;
 
 OCTAVE_DEPRECATED ("use 'octave::sys::chdir' instead")
 const auto octave_chdir = octave::sys::chdir;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -215,8 +215,9 @@ namespace octave
 
       default:
         break;
       }
 
     return retval;
   }
 }
+
diff --git a/liboctave/system/mach-info.h b/liboctave/system/mach-info.h
--- a/liboctave/system/mach-info.h
+++ b/liboctave/system/mach-info.h
@@ -81,8 +81,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::mach_info' instead")
 typedef octave::mach_info oct_mach_info;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -347,17 +347,18 @@ namespace octave
         return true;
 
       if (len > 1 && s[0] == '.' && octave::sys::file_ops::is_dir_sep (s[1]))
         return true;
 
       if (len == 2 && s[0] == '.' && s[1] == '.')
         return true;
 
-      if (len > 2 && s[0] == '.' && s[1] == '.' && octave::sys::file_ops::is_dir_sep (s[2]))
+      if (len > 2 && s[0] == '.' && s[1] == '.'
+          && octave::sys::file_ops::is_dir_sep (s[2]))
         return true;
 
       return false;
     }
 
     // Return the 'basename' of the pathname in STRING (the stuff after
     // the last directory separator).  If STRING is not a full pathname,
     // simply return it.
@@ -484,30 +485,32 @@ namespace octave
             hd = do_getenv ("HOMEPATH");
           else
             hd = drv + do_getenv ("HOMEPATH");
         }
 #endif
 
       if (hd.empty ())
         {
-          octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
+          octave::sys::password pw = octave::sys::password::getpwuid (
+                                       octave::sys::getuid ());
 
           hd = pw ? pw.dir () : std::string (octave::sys::file_ops::dir_sep_str ());
         }
 
       return hd;
     }
 
     std::string
     env::do_get_user_name (void) const
     {
       if (user_name.empty ())
         {
-          octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
+          octave::sys::password pw = octave::sys::password::getpwuid (
+                                       octave::sys::getuid ());
 
           user_name = pw ? pw.name () : std::string ("unknown");
         }
 
       return user_name;
     }
 
     std::string
@@ -607,8 +610,9 @@ namespace octave
 
     void
     env::error (const std::string& s) const
     {
       (*current_liboctave_error_handler) ("%s", s.c_str ());
     }
   }
 }
+
diff --git a/liboctave/system/oct-env.h b/liboctave/system/oct-env.h
--- a/liboctave/system/oct-env.h
+++ b/liboctave/system/oct-env.h
@@ -45,18 +45,18 @@ namespace octave
 
       static bool absolute_pathname (const std::string& s);
 
       static bool rooted_relative_pathname (const std::string& s);
 
       static std::string base_pathname (const std::string& s);
 
       static std::string
-        make_absolute (const std::string& s,
-                       const std::string& dot_path = get_current_directory ());
+      make_absolute (const std::string& s,
+                     const std::string& dot_path = get_current_directory ());
 
       static std::string get_current_directory (void);
 
       static std::string get_home_directory (void);
 
       static std::string get_temp_directory (void);
 
       static std::string get_program_name (void);
@@ -153,8 +153,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::sys::env' instead")
 typedef octave::sys::env octave_env;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/oct-group.cc b/liboctave/system/oct-group.cc
--- a/liboctave/system/oct-group.cc
+++ b/liboctave/system/oct-group.cc
@@ -221,8 +221,9 @@ namespace octave
           valid = true;
         }
 #else
       msg = NOT_SUPPORTED ("group functions");
 #endif
     }
   }
 }
+
diff --git a/liboctave/system/oct-group.h b/liboctave/system/oct-group.h
--- a/liboctave/system/oct-group.h
+++ b/liboctave/system/oct-group.h
@@ -38,36 +38,36 @@ namespace octave
     class
     OCTAVE_API
     group
     {
     public:
 
       group (void)
         : m_name (), m_passwd (), m_gid (0), m_mem (), valid (false)
-        { }
+      { }
 
       group (const group& gr)
         : m_name (gr.m_name), m_passwd (gr.m_passwd),
-        m_gid (gr.m_gid), m_mem (gr.m_mem), valid (gr.valid)
-        { }
+          m_gid (gr.m_gid), m_mem (gr.m_mem), valid (gr.valid)
+      { }
 
       group& operator = (const group& gr)
-        {
-          if (this != &gr)
-            {
-              m_name = gr.m_name;
-              m_passwd = gr.m_passwd;
-              m_gid = gr.m_gid;
-              m_mem = gr.m_mem;
-              valid = gr.valid;
-            }
+      {
+        if (this != &gr)
+          {
+            m_name = gr.m_name;
+            m_passwd = gr.m_passwd;
+            m_gid = gr.m_gid;
+            m_mem = gr.m_mem;
+            valid = gr.valid;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       std::string name (void) const;
 
       std::string passwd (void) const;
 
       gid_t gid (void) const;
 
       string_vector mem (void) const;
@@ -118,8 +118,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::sys::group' instead")
 typedef octave::sys::group octave_group;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/oct-passwd.cc b/liboctave/system/oct-passwd.cc
--- a/liboctave/system/oct-passwd.cc
+++ b/liboctave/system/oct-passwd.cc
@@ -229,8 +229,9 @@ namespace octave
           valid = true;
         }
 #else
       msg = NOT_SUPPORTED ("password functions");
 #endif
     }
   }
 }
+
diff --git a/liboctave/system/oct-passwd.h b/liboctave/system/oct-passwd.h
--- a/liboctave/system/oct-passwd.h
+++ b/liboctave/system/oct-passwd.h
@@ -37,40 +37,40 @@ namespace octave
     OCTAVE_API
     password
     {
     public:
 
       password (void)
         : m_name (), m_passwd (), m_uid (0), m_gid (0), m_gecos (),
           m_dir (), m_shell (), valid (false)
-        { }
+      { }
 
       password (const password& pw)
         : m_name (pw.m_name), m_passwd (pw.m_passwd),
           m_uid (pw.m_uid), m_gid (pw.m_gid), m_gecos (pw.m_gecos),
           m_dir (pw.m_dir), m_shell (pw.m_shell), valid (pw.valid)
-        { }
+      { }
 
       password& operator = (const password& pw)
-        {
-          if (this != &pw)
-            {
-              m_name = pw.m_name;
-              m_passwd = pw.m_passwd;
-              m_uid = pw.m_uid;
-              m_gid = pw.m_gid;
-              m_gecos = pw.m_gecos;
-              m_dir = pw.m_dir;
-              m_shell = pw.m_shell;
-              valid = pw.valid;
-            }
+      {
+        if (this != &pw)
+          {
+            m_name = pw.m_name;
+            m_passwd = pw.m_passwd;
+            m_uid = pw.m_uid;
+            m_gid = pw.m_gid;
+            m_gecos = pw.m_gecos;
+            m_dir = pw.m_dir;
+            m_shell = pw.m_shell;
+            valid = pw.valid;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~password (void) { }
 
       std::string name (void) const;
 
       std::string passwd (void) const;
 
       uid_t uid (void) const;
@@ -138,8 +138,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::sys::password' instead")
 typedef octave::sys::password octave_passwd;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -360,8 +360,9 @@ namespace octave
 
       if (status < 0)
         msg = std::strerror (errno);
 
       return status;
     }
   }
 }
+
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -325,8 +325,9 @@ namespace octave
                                 &m_majflt, &m_nswap, &m_inblock,
                                 &m_oublock, &m_msgsnd, &m_msgrcv,
                                 &m_nsignals, &m_nvcsw, &m_nivcsw);
 
       m_cpu = cpu_time (usr_sec, sys_sec, usr_usec, sys_usec);
     }
   }
 }
+
diff --git a/liboctave/system/oct-time.h b/liboctave/system/oct-time.h
--- a/liboctave/system/oct-time.h
+++ b/liboctave/system/oct-time.h
@@ -43,53 +43,53 @@ namespace octave
       time (void)
         : ot_unix_time (0), ot_usec (0) { stamp (); }
 
       time (time_t t)
         : ot_unix_time (t), ot_usec (0) { }
 
       time (time_t t, int us)
         : ot_unix_time (t), ot_usec ()
-        {
-          int rem, extra;
+      {
+        int rem, extra;
 
-          if (us >= 0)
-            {
-              rem = us % 1000000;
-              extra = (us - rem) / 1000000;
-            }
-          else
-            {
-              us = -us;
-              rem = us % 1000000;
-              extra = - (1 + (us - rem) / 1000000);
-              rem = 1000000 - us % 1000000;
-            }
+        if (us >= 0)
+          {
+            rem = us % 1000000;
+            extra = (us - rem) / 1000000;
+          }
+        else
+          {
+            us = -us;
+            rem = us % 1000000;
+            extra = - (1 + (us - rem) / 1000000);
+            rem = 1000000 - us % 1000000;
+          }
 
-          ot_usec = rem;
-          ot_unix_time += extra;
-        }
+        ot_usec = rem;
+        ot_unix_time += extra;
+      }
 
       time (double d);
 
       time (const base_tm& tm);
 
       time (const time& ot)
         : ot_unix_time (ot.ot_unix_time), ot_usec (ot.ot_usec) { }
 
       time& operator = (const time& ot)
-        {
-          if (this != &ot)
-            {
-              ot_unix_time = ot.ot_unix_time;
-              ot_usec = ot.ot_usec;
-            }
+      {
+        if (this != &ot)
+          {
+            ot_unix_time = ot.ot_unix_time;
+            ot_usec = ot.ot_usec;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~time (void) { }
 
       void stamp (void);
 
       double double_value (void) const { return ot_unix_time + ot_usec / 1e6; }
 
       time_t unix_time (void) const { return ot_unix_time; }
@@ -156,58 +156,58 @@ namespace octave
     {
       return (t1 > t2 || t1 == t2);
     }
 
     inline time
     operator + (const time& t1, const time& t2)
     {
       return time (t1.unix_time () + t2.unix_time (),
-                          t1.usec () + t2.usec ());
+                   t1.usec () + t2.usec ());
     }
 
     class
     OCTAVE_API
     base_tm
     {
     public:
 
       base_tm (void)
         : m_usec (0), m_sec (0), m_min (0), m_hour (0),
           m_mday (0), m_mon (0), m_year (0), m_wday (0),
           m_yday (0), m_isdst (0), m_gmtoff (0), m_zone ("unknown")
-        { }
+      { }
 
       base_tm (const base_tm& tm)
         : m_usec (tm.m_usec), m_sec (tm.m_sec), m_min (tm.m_min),
           m_hour (tm.m_hour), m_mday (tm.m_mday), m_mon (tm.m_mon),
           m_year (tm.m_year), m_wday (tm.m_wday), m_yday (tm.m_yday),
           m_isdst (tm.m_isdst), m_gmtoff (tm.m_gmtoff), m_zone (tm.m_zone)
-        { }
+      { }
 
       base_tm& operator = (const base_tm& tm)
-        {
-          if (this != &tm)
-            {
-              m_usec = tm.m_usec;
-              m_sec = tm.m_sec;
-              m_min = tm.m_min;
-              m_hour = tm.m_hour;
-              m_mday = tm.m_mday;
-              m_mon = tm.m_mon;
-              m_year = tm.m_year;
-              m_wday = tm.m_wday;
-              m_yday = tm.m_yday;
-              m_isdst = tm.m_isdst;
-              m_gmtoff = tm.m_gmtoff;
-              m_zone = tm.m_zone;
-            }
+      {
+        if (this != &tm)
+          {
+            m_usec = tm.m_usec;
+            m_sec = tm.m_sec;
+            m_min = tm.m_min;
+            m_hour = tm.m_hour;
+            m_mday = tm.m_mday;
+            m_mon = tm.m_mon;
+            m_year = tm.m_year;
+            m_wday = tm.m_wday;
+            m_yday = tm.m_yday;
+            m_isdst = tm.m_isdst;
+            m_gmtoff = tm.m_gmtoff;
+            m_zone = tm.m_zone;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       virtual ~base_tm (void) { }
 
       int usec (void) const { return m_usec; }
       int sec (void) const { return m_sec; }
       int min (void) const { return m_min; }
       int hour (void) const { return m_hour; }
       int mday (void) const { return m_mday; }
@@ -289,20 +289,20 @@ namespace octave
 
       localtime (const time& ot)
         : base_tm () { init (ot); }
 
       localtime (const localtime& t)
         : base_tm (t) { }
 
       localtime& operator = (const localtime& t)
-        {
-          base_tm::operator = (t);
-          return *this;
-        }
+      {
+        base_tm::operator = (t);
+        return *this;
+      }
 
       ~localtime (void) { }
 
     private:
 
       void init (const time& ot);
     };
 
@@ -314,49 +314,49 @@ namespace octave
 
       gmtime (void)
         : base_tm () { init (time ()); }
 
       gmtime (const time& ot)
         : base_tm () { init (ot); }
 
       gmtime& operator = (const gmtime& t)
-        {
-          base_tm::operator = (t);
-          return *this;
-        }
+      {
+        base_tm::operator = (t);
+        return *this;
+      }
 
       ~gmtime (void) { }
 
     private:
 
       void init (const time& ot);
     };
 
     class
     OCTAVE_API
     strptime : public base_tm
     {
     public:
 
       strptime (const std::string& str, const std::string& fmt)
         : base_tm (), nchars (0)
-        {
-          init (str, fmt);
-        }
+      {
+        init (str, fmt);
+      }
 
       strptime (const strptime& s)
         : base_tm (s), nchars (s.nchars) { }
 
       strptime& operator = (const strptime& s)
-        {
-          base_tm::operator = (s);
-          nchars = s.nchars;
-          return *this;
-        }
+      {
+        base_tm::operator = (s);
+        nchars = s.nchars;
+        return *this;
+      }
 
       int characters_converted (void) const { return nchars; }
 
       ~strptime (void) { }
 
     private:
 
       int nchars;
@@ -536,8 +536,9 @@ OCTAVE_DEPRECATED ("use 'octave::sys::gm
 typedef octave::sys::gmtime octave_gmtime;
 
 OCTAVE_DEPRECATED ("use 'octave::sys::strptime' instead")
 typedef octave::sys::strptime octave_strptime;
 
 #endif
 
 #endif
+
diff --git a/liboctave/system/oct-uname.cc b/liboctave/system/oct-uname.cc
--- a/liboctave/system/oct-uname.cc
+++ b/liboctave/system/oct-uname.cc
@@ -50,8 +50,9 @@ namespace octave
           m_nodename = nodename;
           m_release = release;
           m_version = version;
           m_machine = machine;
         }
     }
   }
 }
+
diff --git a/liboctave/system/oct-uname.h b/liboctave/system/oct-uname.h
--- a/liboctave/system/oct-uname.h
+++ b/liboctave/system/oct-uname.h
@@ -37,40 +37,40 @@ namespace octave
     {
     public:
 
       uname (void)
         : m_sysname ("unknown"), m_nodename ("unknown"),
           m_release ("unknown"), m_version ("unknown"),
           m_machine ("unknown"),
           msg ("uname not supported on this system"), err (-1)
-        { init (); }
+      { init (); }
 
       uname (const uname& unm)
         : m_sysname (unm.m_sysname), m_nodename (unm.m_nodename),
           m_release (unm.m_release), m_version (unm.m_version),
           m_machine (unm.m_machine), msg (unm.msg), err (unm.err)
-        { }
+      { }
 
       uname& operator = (const uname& unm)
-        {
-          if (this != &unm)
-            {
-              m_sysname = unm.m_sysname;
-              m_nodename = unm.m_nodename;
-              m_release = unm.m_release;
-              m_version = unm.m_version;
-              m_machine = unm.m_machine;
+      {
+        if (this != &unm)
+          {
+            m_sysname = unm.m_sysname;
+            m_nodename = unm.m_nodename;
+            m_release = unm.m_release;
+            m_version = unm.m_version;
+            m_machine = unm.m_machine;
 
-              msg = unm.msg;
-              err = unm.err;
-            }
+            msg = unm.msg;
+            err = unm.err;
+          }
 
-          return *this;
-        }
+        return *this;
+      }
 
       ~uname (void) { }
 
       std::string sysname (void) const { return m_sysname; }
       std::string nodename (void) const { return m_nodename; }
       std::string release (void) const { return m_release; }
       std::string version (void) const { return m_version; }
       std::string machine (void) const { return m_machine; }
@@ -97,8 +97,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::sys::uname' instead")
 typedef octave::sys::uname octave_uname;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -336,8 +336,9 @@ private:
   // No copying!
 
   action_container (const action_container&);
 
   action_container& operator = (const action_container&);
 };
 
 #endif
+
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -36,17 +36,18 @@ namespace octave
   base_list
   {
   public:
 
     typedef typename std::list<elt_type>::iterator iterator;
     typedef typename std::list<elt_type>::const_iterator const_iterator;
 
     typedef typename std::list<elt_type>::reverse_iterator reverse_iterator;
-    typedef typename std::list<elt_type>::const_reverse_iterator const_reverse_iterator;
+    typedef typename std::list<elt_type>::const_reverse_iterator
+                                                     const_reverse_iterator;
 
     bool empty (void) const { return lst.empty (); }
 
     size_t size (void) const { return lst.size (); }
     size_t length (void) const { return size (); }
 
     iterator erase (iterator pos) { return lst.erase (pos); }
 
@@ -127,8 +128,9 @@ namespace octave
 
   private:
 
     std::list<elt_type> lst;
   };
 }
 
 #endif
+
diff --git a/liboctave/util/byte-swap.h b/liboctave/util/byte-swap.h
--- a/liboctave/util/byte-swap.h
+++ b/liboctave/util/byte-swap.h
@@ -89,8 +89,9 @@ swap_bytes (void *ptr, int len)
 
 template <>
 inline void
 swap_bytes<1> (void *, int)
 {
 }
 
 #endif
+
diff --git a/liboctave/util/caseless-str.h b/liboctave/util/caseless-str.h
--- a/liboctave/util/caseless-str.h
+++ b/liboctave/util/caseless-str.h
@@ -89,8 +89,9 @@ public:
         p2++;
       }
 
     return (limit == std::string::npos) ? size () == s.size () : k == limit;
   }
 };
 
 #endif
+
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -577,17 +577,18 @@ namespace octave
     std::string line = get_line_buffer ();
 
     // For now, assume space or quote delimiter for file names.
     const char *l = line.c_str ();
 
     if (looks_like_filename (l, ' ') || looks_like_filename (l, '\'')
         || looks_like_filename (l, '"'))
       {
-        ::octave_rl_set_completer_quote_characters (completer_quote_characters.c_str ());
+        ::octave_rl_set_completer_quote_characters (
+          completer_quote_characters.c_str ());
 
         return dir_sep;
       }
     else
       {
         ::octave_rl_set_completer_quote_characters ("");
 
         return octave_rl_get_completer_word_break_characters ();
@@ -1935,8 +1936,9 @@ namespace octave
   }
 
   void
   command_editor::error (const std::string& s)
   {
     (*current_liboctave_error_handler) ("%s", s.c_str ());
   }
 }
+
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -299,17 +299,17 @@ namespace octave
 
     virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const
     { return 0; }
 
     virtual user_accept_line_fcn do_get_user_accept_line_function (void) const
     { return 0; }
 
     virtual string_vector
-      do_generate_filename_completions (const std::string& text) = 0;
+    do_generate_filename_completions (const std::string& text) = 0;
 
     virtual std::string do_get_line_buffer (void) const = 0;
 
     virtual std::string do_get_current_line (void) const = 0;
 
     virtual char do_get_prev_char (int) const = 0;
 
     virtual void do_replace_line (const std::string& text, bool clear_undo) = 0;
@@ -370,8 +370,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::command_editor' instead")
 typedef octave::command_editor command_editor;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -1016,8 +1016,9 @@ namespace octave
   }
 
   void
   command_history::error (const std::string& s) const
   {
     (*current_liboctave_error_handler) ("%s", s.c_str ());
   }
 }
+
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -34,17 +34,17 @@ namespace octave
   class
   OCTAVE_API
   command_history
   {
   protected:
 
     command_history (void)
       : initialized (false), ignoring_additions (false), history_control (0),
-      lines_in_file (0), lines_this_session (0), xfile (), xsize (-1) { }
+        lines_in_file (0), lines_this_session (0), xfile (), xsize (-1) { }
 
   public:
 
     virtual ~command_history (void) { }
 
     static void initialize (bool, const std::string&, int, const std::string&);
 
     static bool is_initialized (void);
@@ -236,8 +236,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::command_history' instead")
 typedef octave::command_history command_history;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -976,8 +976,9 @@ write_floats (std::ostream& os, const fl
       break;
 
     default:
       (*current_liboctave_error_handler)
         ("unrecognized data format requested");
       break;
     }
 }
+
diff --git a/liboctave/util/data-conv.h b/liboctave/util/data-conv.h
--- a/liboctave/util/data-conv.h
+++ b/liboctave/util/data-conv.h
@@ -259,8 +259,9 @@ is_equivalent_type<double> (oct_data_con
 template <>
 inline bool
 is_equivalent_type<float> (oct_data_conv::data_type t)
 {
   return t == oct_data_conv::dt_single || t == oct_data_conv::dt_float;
 }
 
 #endif
+
diff --git a/liboctave/util/f2c-main.c b/liboctave/util/f2c-main.c
--- a/liboctave/util/f2c-main.c
+++ b/liboctave/util/f2c-main.c
@@ -31,8 +31,9 @@ along with Octave; see the file COPYING.
    This function should never be called. */
 
 #if defined (F77_DUMMY_MAIN)
 #  if defined (__cplusplus)
 extern "C"
 #  endif
 int F77_DUMMY_MAIN () { assert (0); return 1; }
 #endif
+
diff --git a/liboctave/util/functor.h b/liboctave/util/functor.h
--- a/liboctave/util/functor.h
+++ b/liboctave/util/functor.h
@@ -70,8 +70,9 @@ func_ptr (RT (*f) (PT))
 template <typename CT, typename RT, typename PT>
 functor_with_conversion<CT, RT, PT>
 func_ptr_with_conversion (RT (*f) (PT))
 {
   return functor_with_conversion<CT, RT, PT> (f);
 }
 
 #endif
+
diff --git a/liboctave/util/glob-match.cc b/liboctave/util/glob-match.cc
--- a/liboctave/util/glob-match.cc
+++ b/liboctave/util/glob-match.cc
@@ -51,8 +51,9 @@ glob_match::opts_to_fnmatch_flags (unsig
   if (xopts & noescape)
     retval |= octave_fnm_noescape_wrapper ();
 
   if (xopts & period)
     retval |= octave_fnm_period_wrapper ();
 
   return retval;
 }
+
diff --git a/liboctave/util/glob-match.h b/liboctave/util/glob-match.h
--- a/liboctave/util/glob-match.h
+++ b/liboctave/util/glob-match.h
@@ -96,8 +96,9 @@ private:
 
   // Option flags.
   int fnmatch_flags;
 
   int opts_to_fnmatch_flags (unsigned int xopts) const;
 };
 
 #endif
+
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -1365,8 +1365,9 @@ kpse_var_expand (const std::string& src)
             }
         }
       else
         expansion += src[i];
     }
 
   return expansion;
 }
+
diff --git a/liboctave/util/kpse.h b/liboctave/util/kpse.h
--- a/liboctave/util/kpse.h
+++ b/liboctave/util/kpse.h
@@ -90,8 +90,9 @@ kpse_path_expand (const std::string& pat
 extern std::string
 kpse_path_find_first_of (const std::string& path,
                          const std::list<std::string>& names);
 
 extern std::string
 kpse_path_search (const std::string& path, const std::string& name);
 
 #endif
+
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -31,17 +31,18 @@ along with Octave; see the file COPYING.
 
 // Text constants used to shorten code below.
 static const char *error_id_nonconformant_args = "Octave:nonconformant-args";
 
 static const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
 
 static const char *error_id_invalid_index = "Octave:invalid-index";
 
-static const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
+static const char *warning_id_nearly_singular_matrix =
+  "Octave:nearly-singular-matrix";
 
 static const char *warning_id_singular_matrix = "Octave:singular-matrix";
 
 namespace octave
 {
   void
   err_nan_to_logical_conversion (void)
   {
@@ -323,8 +324,9 @@ namespace octave
         (*current_liboctave_warning_with_id_handler)
           (warning_id_nearly_singular_matrix,
            "matrix singular to machine precision, rcond = %g", rcond);
       }
   }
 }
 
 /* Tests in test/index.tst */
+
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
--- a/liboctave/util/lo-array-errwarn.h
+++ b/liboctave/util/lo-array-errwarn.h
@@ -260,8 +260,9 @@ inline void
 warn_singular_matrix (double rcond = 0.0)
 {
   return octave::warn_singular_matrix (rcond);
 }
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -34,17 +34,18 @@ along with Octave; see the file COPYING.
 
 // Text constants used to shorten code below.
 static const char *error_id_nonconformant_args = "Octave:nonconformant-args";
 
 static const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
 
 static const char *error_id_invalid_index = "Octave:invalid-index";
 
-static const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
+static const char *warning_id_nearly_singular_matrix =
+  "Octave:nearly-singular-matrix";
 
 static const char *warning_id_singular_matrix = "Octave:singular-matrix";
 
 void
 gripe_nan_to_logical_conversion (void)
 {
   (*current_liboctave_error_handler)
     ("invalid conversion from NaN to logical");
@@ -290,8 +291,9 @@ gripe_singular_matrix (double rcond)
     {
       (*current_liboctave_warning_with_id_handler)
         (warning_id_nearly_singular_matrix,
          "matrix singular to machine precision, rcond = %g", rcond);
     }
 }
 
 /* Tests in test/index.tst */
+
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -94,8 +94,9 @@ OCTAVE_DEPRECATED ("use 'octave::err_inv
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_invalid_resize (void);
 
 OCTAVE_DEPRECATED ("use 'octave::err_singular_matrix' instead")
 OCTAVE_API extern void
 gripe_singular_matrix (double rcond = 0.0);
 
 #endif
+
diff --git a/liboctave/util/lo-cutils.c b/liboctave/util/lo-cutils.c
--- a/liboctave/util/lo-cutils.c
+++ b/liboctave/util/lo-cutils.c
@@ -42,8 +42,9 @@ octave_strcasecmp (const char *s1, const
   return strcasecmp (s1, s2);
 }
 
 OCTAVE_API int
 octave_strncasecmp (const char *s1, const char *s2, size_t n)
 {
   return strncasecmp (s1, s2, n);
 }
+
diff --git a/liboctave/util/lo-cutils.h b/liboctave/util/lo-cutils.h
--- a/liboctave/util/lo-cutils.h
+++ b/liboctave/util/lo-cutils.h
@@ -41,8 +41,9 @@ octave_strcasecmp (const char *s1, const
 OCTAVE_API int
 octave_strncasecmp (const char *s1, const char *s2, size_t n);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/liboctave/util/lo-hash.cc b/liboctave/util/lo-hash.cc
--- a/liboctave/util/lo-hash.cc
+++ b/liboctave/util/lo-hash.cc
@@ -135,8 +135,9 @@ namespace octave
       else if (ht == "SHA512")
         return sha512_hash (str);
       else
         (*current_liboctave_error_handler)
           ("hash function '%s' not supported", hash_type.c_str ());
     }
   }
 }
+
diff --git a/liboctave/util/lo-hash.h b/liboctave/util/lo-hash.h
--- a/liboctave/util/lo-hash.h
+++ b/liboctave/util/lo-hash.h
@@ -54,8 +54,9 @@ namespace octave
     std::string sha384_hash (const std::string& str);
     std::string sha512_hash (const std::string& str);
 
     std::string hash (const std::string& hash_type, const std::string& str);
   }
 }
 
 #endif
+
diff --git a/liboctave/util/lo-ieee.cc b/liboctave/util/lo-ieee.cc
--- a/liboctave/util/lo-ieee.cc
+++ b/liboctave/util/lo-ieee.cc
@@ -273,8 +273,9 @@ octave_ieee_init (void)
           (*current_liboctave_error_handler)
             ("lo_ieee_init: floating point format is not IEEE!  Maybe DLAMCH is miscompiled, or you are using some strange system without IEEE floating point math?");
           abort ();
         }
 
       initialized = true;
     }
 }
+
diff --git a/liboctave/util/lo-ieee.h b/liboctave/util/lo-ieee.h
--- a/liboctave/util/lo-ieee.h
+++ b/liboctave/util/lo-ieee.h
@@ -151,8 +151,9 @@ namespace octave
     static float NaN (void) { return octave_Float_NaN; }
     static float Inf (void) { return octave_Float_Inf; }
   };
 }
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/lo-macros.h b/liboctave/util/lo-macros.h
--- a/liboctave/util/lo-macros.h
+++ b/liboctave/util/lo-macros.h
@@ -95,8 +95,9 @@ along with Octave; see the file COPYING.
 #define OCT_MAKE_DECL_LIST(TYPE, PREFIX, NUM)                           \
   OCT_ITERATE_PARAM_MACRO(OCT_MAKE_DECL_LIST_HELPER, TYPE PREFIX, NUM)
 
 // expands to PREFIX0, PREFIX1, ..., PREFIX ## (NUM-1)
 #define OCT_MAKE_ARG_LIST(PREFIX, NUM)                                  \
   OCT_ITERATE_PARAM_MACRO(OCT_MAKE_DECL_LIST_HELPER, PREFIX, NUM)
 
 #endif
+
diff --git a/liboctave/util/lo-math.h b/liboctave/util/lo-math.h
--- a/liboctave/util/lo-math.h
+++ b/liboctave/util/lo-math.h
@@ -35,8 +35,9 @@ along with Octave; see the file COPYING.
 #  include <math.h>
 #endif
 
 #if defined (HAVE_SUNMATH_H)
 #  include <sunmath.h>
 #endif
 
 #endif
+
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -260,17 +260,17 @@ namespace octave
     OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
     OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
 
     for (int i = 0; i < namecount; i++)
       {
         // Index of subpattern in first two bytes MSB first of name.
         // Extract index.
         nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
-          | static_cast<int> (nametable[i*nameentrysize+1]);
+                  | static_cast<int> (nametable[i*nameentrysize+1]);
       }
 
     while (true)
       {
         OCTAVE_QUIT;
 
         int matches = pcre_exec (re, 0, buffer.c_str (),
                                  buffer.length (), idx,
@@ -584,17 +584,17 @@ namespace octave
         // Determine repstr length
         const size_t replen = repstr.size ();
         int delta = 0;
         regexp::match_data::const_iterator p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
             OCTAVE_QUIT;
             delta += static_cast<int> (replen)
-              - static_cast<int> (p->end () - p->start () + 1);
+                     - static_cast<int> (p->end () - p->start () + 1);
             p++;
           }
 
         // Build replacement string
         rep.reserve (buffer.size () + delta);
         size_t from = 0;
         p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
@@ -608,8 +608,9 @@ namespace octave
           }
         rep.append (&buffer[from], buffer.size () - from);
       }
 
     retval = rep;
     return retval;
   }
 }
+
diff --git a/liboctave/util/lo-regexp.h b/liboctave/util/lo-regexp.h
--- a/liboctave/util/lo-regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -45,39 +45,39 @@ namespace octave
 
     class opts;
     class match_data;
 
     regexp (const std::string& pat = "",
             const regexp::opts& opt = regexp::opts (),
             const std::string& w = "regexp")
       : pattern (pat), options (opt), data (0), named_pats (),
-      nnames (0), named_idx (), who (w)
+        nnames (0), named_idx (), who (w)
     {
       compile_internal ();
     }
 
     regexp (const regexp& rx)
       : pattern (rx.pattern), data (rx.data), named_pats (rx.named_pats),
-      nnames (rx.nnames), named_idx (rx.named_idx)
-      { }
+        nnames (rx.nnames), named_idx (rx.named_idx)
+    { }
 
     regexp& operator = (const regexp& rx)
-      {
-        if (this != &rx)
-          {
-            pattern = rx.pattern;
-            data = rx.data;
-            named_pats = rx.named_pats;
-            nnames = rx.nnames;
-            named_idx = rx.named_idx;
-          }
+    {
+      if (this != &rx)
+        {
+          pattern = rx.pattern;
+          data = rx.data;
+          named_pats = rx.named_pats;
+          nnames = rx.nnames;
+          named_idx = rx.named_idx;
+        }
 
-        return *this;
-      }
+      return *this;
+    }
 
     ~regexp (void) { free (); }
 
     void compile (const std::string& pat,
                   const regexp::opts& opt = regexp::opts ())
     {
       pattern = pat;
       options = opt;
@@ -237,17 +237,17 @@ namespace octave
       { }
 
       match_data (const std::list<match_element>& l, const string_vector& np)
         : base_list<match_element> (l), named_pats (np)
       { }
 
       match_data (const match_data& rx_lst)
         : base_list<match_element> (rx_lst),
-        named_pats (rx_lst.named_pats)
+          named_pats (rx_lst.named_pats)
       { }
 
       match_data& operator = (const match_data& rx_lst)
       {
         if (this != &rx_lst)
           {
             base_list<match_element>::operator = (rx_lst);
             named_pats = rx_lst.named_pats;
@@ -331,8 +331,9 @@ regexp_replace (const std::string& pat,
                 const std::string& who = "regexp")
 {
   return octave::regexp::replace (pat, buffer, replacement, opt, who);
 }
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/lo-traits.h b/liboctave/util/lo-traits.h
--- a/liboctave/util/lo-traits.h
+++ b/liboctave/util/lo-traits.h
@@ -148,8 +148,9 @@ public:
 template <template <typename> class TemplatedClass, typename T, typename S>
 class subst_template_param<TemplatedClass, TemplatedClass<T>, S>
 {
 public:
   typedef TemplatedClass<S> type;
 };
 
 #endif
+
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -48,17 +48,18 @@ bool xis_int_or_inf_or_nan (double x)
 bool xis_one_or_zero (double x)
 { return x == 0 || x == 1; }
 
 bool xis_zero (double x)
 { return x == 0; }
 
 bool xtoo_large_for_float (double x)
 {
-  return (octave::math::finite (x) && fabs (x) > std::numeric_limits<float>::max ());
+  return (octave::math::finite (x)
+          && fabs (x) > std::numeric_limits<float>::max ());
 }
 
 bool xtoo_large_for_float (const Complex& x)
 {
   return (xtoo_large_for_float (x.real ())
           || xtoo_large_for_float (x.imag ()));
 }
 
@@ -423,8 +424,9 @@ void
 octave_write_float_complex (std::ostream& os, const FloatComplex& c)
 {
   os << "(";
   octave_write_float (os, real (c));
   os << ",";
   octave_write_float (os, imag (c));
   os << ")";
 }
+
diff --git a/liboctave/util/lo-utils.h b/liboctave/util/lo-utils.h
--- a/liboctave/util/lo-utils.h
+++ b/liboctave/util/lo-utils.h
@@ -133,8 +133,9 @@ octave_write_complex (std::ostream& os, 
 
 extern OCTAVE_API void
 octave_write_float (std::ostream& os, float dval);
 
 extern OCTAVE_API void
 octave_write_float_complex (std::ostream& os, const FloatComplex& cval);
 
 #endif
+
diff --git a/liboctave/util/oct-alloc.h b/liboctave/util/oct-alloc.h
--- a/liboctave/util/oct-alloc.h
+++ b/liboctave/util/oct-alloc.h
@@ -27,8 +27,9 @@ along with Octave; see the file COPYING.
 
 #warning "the octave_allocator class has been deprecated and will be removed in a future release of Octave"
 
 #define DECLARE_OCTAVE_ALLOCATOR 1
 #define DEFINE_OCTAVE_ALLOCATOR(t)
 #define DEFINE_OCTAVE_ALLOCATOR2(t, s)
 
 #endif
+
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
--- a/liboctave/util/oct-base64.cc
+++ b/liboctave/util/oct-base64.cc
@@ -83,8 +83,9 @@ octave_base64_decode (const std::string&
       double *dout = reinterpret_cast<double*> (out);
       std::copy (dout, dout + len, retval.fortran_vec ());
       ::free (out);
     }
 
   return retval;
 }
 
+
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -485,8 +485,9 @@ binmap (const T& x, const Sparse<R>& ya,
 { return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
 template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
 #endif
+
diff --git a/liboctave/util/oct-cmplx.h b/liboctave/util/oct-cmplx.h
--- a/liboctave/util/oct-cmplx.h
+++ b/liboctave/util/oct-cmplx.h
@@ -98,8 +98,9 @@ typedef std::complex<float> FloatComplex
   }
 
 DEF_COMPLEXR_COMP (>, >)
 DEF_COMPLEXR_COMP (<, <)
 DEF_COMPLEXR_COMP (<=, <)
 DEF_COMPLEXR_COMP (>=, >)
 
 #endif
+
diff --git a/liboctave/util/oct-glob.cc b/liboctave/util/oct-glob.cc
--- a/liboctave/util/oct-glob.cc
+++ b/liboctave/util/oct-glob.cc
@@ -169,22 +169,22 @@ namespace octave
               for (size_t j = 0; j < xpat.length (); j++)
                 {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)           \
      && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
                   if (xpat[j] == '\\')
                     escaped += '/';
                   else
 #endif
-                  {
-                    if (xpat[j] == ']' || xpat[j] == '[')
-                      escaped += '\\';
+                    {
+                      if (xpat[j] == ']' || xpat[j] == '[')
+                        escaped += '\\';
 
-                    escaped += xpat[j];
-                  }
+                      escaped += xpat[j];
+                    }
                 }
 
               // Replace trailing "*.*" by "*".
               int len = escaped.length ();
               if (len >= 3 && escaped.substr (len - 3) == "*.*")
                 escaped = escaped.substr (0, len - 2);
 
               int err = octave_glob_wrapper (escaped.c_str (),
@@ -219,30 +219,31 @@ namespace octave
                           for (size_t m = 0; m < tmp.length (); m++)
                             {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)           \
      && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
                               if (tmp[m] == '/')
                                 unescaped += '\\';
                               else
 #endif
-                              {
-                                if (tmp[m] == '\\'
-                                    && ++m == tmp.length ())
-                                  break;
+                                {
+                                  if (tmp[m] == '\\'
+                                      && ++m == tmp.length ())
+                                    break;
 
-                                unescaped += tmp[m];
-                              }
+                                  unescaped += tmp[m];
+                                }
                             }
 
                           retval[k++] = unescaped;
                         }
                     }
 
                   octave_globfree_wrapper (glob_info);
                 }
             }
         }
 
       return retval.sort ();
     }
   }
 }
+
diff --git a/liboctave/util/oct-glob.h b/liboctave/util/oct-glob.h
--- a/liboctave/util/oct-glob.h
+++ b/liboctave/util/oct-glob.h
@@ -49,8 +49,9 @@ OCTAVE_DEPRECATED ("use 'octave::sys::fn
 const auto octave_fnmatch = octave::sys::fnmatch;
 
 OCTAVE_DEPRECATED ("use 'octave::sys::glob' instead")
 const auto octave_glob = octave::sys::glob;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/oct-inttypes-fwd.h b/liboctave/util/oct-inttypes-fwd.h
--- a/liboctave/util/oct-inttypes-fwd.h
+++ b/liboctave/util/oct-inttypes-fwd.h
@@ -33,8 +33,9 @@ typedef octave_int<int32_t> octave_int32
 typedef octave_int<int64_t> octave_int64;
 
 typedef octave_int<uint8_t> octave_uint8;
 typedef octave_int<uint16_t> octave_uint16;
 typedef octave_int<uint32_t> octave_uint32;
 typedef octave_int<uint64_t> octave_uint64;
 
 #endif
+
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -744,48 +744,51 @@ template <typename T>
 octave_int<T>
 pow (const double& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.double_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const double& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits
+           && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), b)));
 }
 
 template <typename T>
 octave_int<T>
 pow (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const float& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits
+           && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 // FIXME: Do we really need a differently named single-precision
 //        function integer power function here instead of an overloaded
 //        one?
 template <typename T>
 octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
-  return ((b >= 0 && b < std::numeric_limits<T>::digits && b == octave::math::round (b))
+  return ((b >= 0 && b < std::numeric_limits<T>::digits
+           && b == octave::math::round (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 #define INSTANTIATE_INTTYPE(T)                                          \
   template class OCTAVE_API octave_int<T>;                              \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const double&, const octave_int<T>&); \
@@ -841,8 +844,9 @@ INSTANTIATE_INTTYPE (uint64_t);
 %!assert (int32 (char (128)), int32 (128))
 %!assert (int32 (char (255)), int32 (255))
 
 %!assert (uint64 (char (128)), uint64 (128))
 %!assert (uint64 (char (255)), uint64 (255))
 %!assert (int64 (char (128)), int64 (128))
 %!assert (int64 (char (255)), int64 (255))
 */
+
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -834,17 +834,17 @@ template <>
 OCTAVE_API int64_t
 octave_int_arith_base<int64_t, true>::mul_internal (int64_t, int64_t);
 
 #endif
 
 // This class simply selects the proper arithmetics.
 template <typename T>
 class octave_int_arith
- : public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
+: public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
 { };
 
 template <typename T>
 class
 octave_int : public octave_int_base<T>
 {
 public:
   typedef T val_type;
@@ -1356,8 +1356,9 @@ octave_int<T>
 xmin (const octave_int<T>& x, const octave_int<T>& y)
 {
   const T xv = x.value ();
   const T yv = y.value ();
   return octave_int<T> (xv <= yv ? xv : yv);
 }
 
 #endif
+
diff --git a/liboctave/util/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
--- a/liboctave/util/oct-locbuf.cc
+++ b/liboctave/util/oct-locbuf.cc
@@ -144,8 +144,9 @@ octave_chunk_buffer::clear (void)
       // some kind?  If so, maybe this should be a fatal error?
 
       (*current_liboctave_warning_with_id_handler)
         ("Octave:local-buffer-inconsistency",
          "octave_chunk_buffer::clear: %d active allocations remain!",
          active);
     }
 }
+
diff --git a/liboctave/util/oct-mutex.cc b/liboctave/util/oct-mutex.cc
--- a/liboctave/util/oct-mutex.cc
+++ b/liboctave/util/oct-mutex.cc
@@ -168,8 +168,9 @@ init_rep (void)
 #elif defined (HAVE_PTHREAD_H)
   return new octave_pthread_mutex ();
 #else
   return new octave_base_mutex ();
 #endif
 }
 
 octave_mutex::octave_mutex (void) : rep (init_rep ()) { }
+
diff --git a/liboctave/util/oct-mutex.h b/liboctave/util/oct-mutex.h
--- a/liboctave/util/oct-mutex.h
+++ b/liboctave/util/oct-mutex.h
@@ -145,8 +145,9 @@ octave_thread
 {
 public:
   static void init (void);
 
   static bool is_octave_thread (void);
 };
 
 #endif
+
diff --git a/liboctave/util/oct-refcount.h b/liboctave/util/oct-refcount.h
--- a/liboctave/util/oct-refcount.h
+++ b/liboctave/util/oct-refcount.h
@@ -110,8 +110,9 @@ public:
   }
 
 private:
 
   count_type count;
 };
 
 #endif
+
diff --git a/liboctave/util/oct-rl-edit.c b/liboctave/util/oct-rl-edit.c
--- a/liboctave/util/oct-rl-edit.c
+++ b/liboctave/util/oct-rl-edit.c
@@ -467,8 +467,9 @@ octave_rl_ctrl (char c)
 
 int
 octave_rl_meta (char c)
 {
   return META (c);
 }
 
 #endif
+
diff --git a/liboctave/util/oct-rl-edit.h b/liboctave/util/oct-rl-edit.h
--- a/liboctave/util/oct-rl-edit.h
+++ b/liboctave/util/oct-rl-edit.h
@@ -178,8 +178,9 @@ extern int octave_rl_ctrl (char);
 
 extern int octave_rl_meta (char);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/liboctave/util/oct-rl-hist.c b/liboctave/util/oct-rl-hist.c
--- a/liboctave/util/oct-rl-hist.c
+++ b/liboctave/util/oct-rl-hist.c
@@ -313,8 +313,9 @@ octave_replace_history_entry (int which,
       if (discard->line)
         free (discard->line);
 
       free (discard);
     }
 }
 
 #endif
+
diff --git a/liboctave/util/oct-rl-hist.h b/liboctave/util/oct-rl-hist.h
--- a/liboctave/util/oct-rl-hist.h
+++ b/liboctave/util/oct-rl-hist.h
@@ -25,17 +25,18 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #if defined (__cplusplus)
 extern "C"
 {
 #endif
 
-enum {
+enum
+{
   HC_IGNSPACE = 0x01,
   HC_IGNDUPS = 0x02,
   HC_ERASEDUPS = 0x04
 };
 
 extern int octave_add_history (const char *, int);
 
 extern int octave_where_history (void);
@@ -78,8 +79,9 @@ extern char **octave_history_list (int, 
 
 extern void octave_replace_history_entry (int, const char *);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
+
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -145,17 +145,18 @@ namespace octave
   dynamic_library::dynlib_rep::do_close_hook (dynamic_library::close_hook cl_hook)
   {
     for (auto& fcn_sz_p : fcn_names)
       cl_hook (fcn_sz_p.first);
 
     fcn_names.clear ();
   }
 
-  std::map<std::string, dynamic_library::dynlib_rep *> dynamic_library::dynlib_rep::instances;
+  std::map<std::string, dynamic_library::dynlib_rep *>
+    dynamic_library::dynlib_rep::instances;
 
   dynamic_library::dynlib_rep dynamic_library::nil_rep;
 
 #if defined (HAVE_DLOPEN_API)
 
   class
   octave_dlopen_shlib : public dynamic_library::dynlib_rep
   {
@@ -165,17 +166,17 @@ namespace octave
 
     ~octave_dlopen_shlib (void);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     // FIXME: this is possibly redundant because failure to open a library will
     // normally throw an exception, avoiding the construction of an invalid
-  // library.  Leave it here for possible future use.
+    // library.  Leave it here for possible future use.
 
     bool is_open (void) const { return (library != 0); }
 
   private:
 
     // No copying!
 
     octave_dlopen_shlib (const octave_dlopen_shlib&);
@@ -524,8 +525,9 @@ namespace octave
 #elif defined (HAVE_DYLD_API)
     return new octave_dyld_shlib (f);
 #else
     (*current_liboctave_error_handler)
       ("support for dynamically loaded libraries was unavailable or disabled when liboctave was built");
 #endif
   }
 }
+
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -115,40 +115,40 @@ namespace octave
   public:
 
     dynamic_library (void) : rep (&nil_rep) { rep->count++; }
 
     dynamic_library (const std::string& f, bool fake = true)
       : rep (dynlib_rep::get_instance (f, fake)) { }
 
     ~dynamic_library (void)
-      {
-        if (--rep->count == 0)
-          delete rep;
-      }
+    {
+      if (--rep->count == 0)
+        delete rep;
+    }
 
     dynamic_library (const dynamic_library& sl)
       : rep (sl.rep)
-      {
-        rep->count++;
-      }
+    {
+      rep->count++;
+    }
 
     dynamic_library& operator = (const dynamic_library& sl)
-      {
-        if (rep != sl.rep)
-          {
-            if (--rep->count == 0)
-              delete rep;
+    {
+      if (rep != sl.rep)
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-            rep = sl.rep;
-            rep->count++;
-          }
+          rep = sl.rep;
+          rep->count++;
+        }
 
-        return *this;
-      }
+      return *this;
+    }
 
     bool operator == (const dynamic_library& sl) const
     { return (rep == sl.rep); }
 
     operator bool () const { return rep->is_open (); }
 
     void open (const std::string& f)
     { *this = dynamic_library (f); }
@@ -197,8 +197,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::dynamic_library' instead")
 typedef octave::dynamic_library octave_shlib;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -1961,8 +1961,9 @@ octave_sort<T>::ascending_compare (typen
 
 template <typename T>
 bool
 octave_sort<T>::descending_compare (typename ref_param<T>::type x,
                                     typename ref_param<T>::type y)
 {
   return x > y;
 }
+
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -340,8 +340,9 @@ template <typename T>
 class
 vec_index
 {
 public:
   T vec;
   octave_idx_type indx;
 };
 #endif
+
diff --git a/liboctave/util/oct-sparse.h b/liboctave/util/oct-sparse.h
--- a/liboctave/util/oct-sparse.h
+++ b/liboctave/util/oct-sparse.h
@@ -125,8 +125,9 @@ along with Octave; see the file COPYING.
 #    define UMFPACK_ZNAME(name) umfpack_zl_ ## name
 #  else
 #    define UMFPACK_DNAME(name) umfpack_di_ ## name
 #    define UMFPACK_ZNAME(name) umfpack_zi_ ## name
 #  endif
 #endif
 
 #endif
+
diff --git a/liboctave/util/oct-string.cc b/liboctave/util/oct-string.cc
--- a/liboctave/util/oct-string.cc
+++ b/liboctave/util/oct-string.cc
@@ -199,8 +199,9 @@ octave::string::strncmpi (const T& str_a
                                              const typename T::size_type);
 
 // We could also instantiate std::vector<char> but would it be
 // useful for anyone?
 INSTANTIATE_OCTAVE_STRING(std::string)
 INSTANTIATE_OCTAVE_STRING(Array<char>)
 
 #undef INSTANTIATE_OCTAVE_STRING
+
diff --git a/liboctave/util/oct-string.h b/liboctave/util/oct-string.h
--- a/liboctave/util/oct-string.h
+++ b/liboctave/util/oct-string.h
@@ -97,17 +97,17 @@ namespace octave
     */
     template <typename T>
     bool strncmp (const T& str_a, const T& str_b,
                   const typename T::size_type n);
 
     //! True if the first N characters are the same.
     template <typename T>
     bool strncmp (const T& str_a, const typename T::value_type* str_b,
-                   const typename T::size_type n);
+                  const typename T::size_type n);
 
     //! True if the first N characters are the same, ignoring case.
     /*!
         ## Specialization for Array<char>
 
         The comparison is done in the first N characters, the actual
         dimensions of the Array are irrelevant.  A row vector and
         a column vector of the same still return true.
@@ -119,8 +119,9 @@ namespace octave
     //! True if the first N characters are the same, ignoring case.
     template <typename T>
     bool strncmpi (const T& str_a, const typename T::value_type* str_b,
                    const typename T::size_type n);
   }
 }
 
 #endif
+
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -137,8 +137,9 @@ namespace octave
                           : kpse_expand_default (m_orig_path, m_default_path));
 
     for (kpse_path_iterator pi (m_expanded_path); pi != std::string::npos; pi++)
       m_path_elements.push_back (*pi);
 
     m_initialized = true;
   }
 }
+
diff --git a/liboctave/util/pathsearch.h b/liboctave/util/pathsearch.h
--- a/liboctave/util/pathsearch.h
+++ b/liboctave/util/pathsearch.h
@@ -34,42 +34,42 @@ namespace octave
   OCTAVE_API
   directory_path
   {
   public:
 
     directory_path (const std::string& s = "", const std::string& d = "")
       : m_orig_path (s), m_default_path (d), m_initialized (false),
         m_expanded_path (), m_path_elements ()
-      {
-        if (! m_orig_path.empty ())
-          init ();
-      }
+    {
+      if (! m_orig_path.empty ())
+        init ();
+    }
 
     directory_path (const directory_path& dp)
       : m_orig_path (dp.m_orig_path),
         m_default_path (dp.m_default_path),
         m_initialized (dp.m_initialized),
         m_expanded_path (dp.m_expanded_path),
         m_path_elements (dp.m_path_elements)
-      { }
+    { }
 
     directory_path& operator = (const directory_path& dp)
-      {
-        if (this != &dp)
-          {
-            m_orig_path = dp.m_orig_path;
-            m_default_path = dp.m_default_path;
-            m_initialized = dp.m_initialized;
-            m_expanded_path = dp.m_expanded_path;
-            m_path_elements = dp.m_path_elements;
-          }
+    {
+      if (this != &dp)
+        {
+          m_orig_path = dp.m_orig_path;
+          m_default_path = dp.m_default_path;
+          m_initialized = dp.m_initialized;
+          m_expanded_path = dp.m_expanded_path;
+          m_path_elements = dp.m_path_elements;
+        }
 
-        return *this;
-      }
+      return *this;
+    }
 
     ~directory_path (void) { }
 
     void set (const std::string& s)
     {
       m_initialized = false;
       m_orig_path = s;
       init ();
@@ -187,8 +187,9 @@ namespace octave
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::directory_path' instead")
 typedef octave::directory_path dir_path;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/singleton-cleanup.cc b/liboctave/util/singleton-cleanup.cc
--- a/liboctave/util/singleton-cleanup.cc
+++ b/liboctave/util/singleton-cleanup.cc
@@ -48,8 +48,9 @@ singleton_cleanup_list::instance_ok (voi
     instance = new singleton_cleanup_list ();
 
   if (! instance)
     (*current_liboctave_error_handler)
       ("unable to create singleton_cleanup_list object!");
 
   return retval;
 }
+
diff --git a/liboctave/util/singleton-cleanup.h b/liboctave/util/singleton-cleanup.h
--- a/liboctave/util/singleton-cleanup.h
+++ b/liboctave/util/singleton-cleanup.h
@@ -45,8 +45,9 @@ private:
   // No copying!
 
   singleton_cleanup_list (const singleton_cleanup_list&);
 
   singleton_cleanup_list& operator = (const singleton_cleanup_list&);
 };
 
 #endif
+
diff --git a/liboctave/util/sparse-sort.cc b/liboctave/util/sparse-sort.cc
--- a/liboctave/util/sparse-sort.cc
+++ b/liboctave/util/sparse-sort.cc
@@ -56,8 +56,9 @@ template class octave_sort<octave_sparse
 bool
 octave_idx_vector_comp (octave_idx_vector_sort* i,
                         octave_idx_vector_sort* j)
 {
   return (i->i < j->i);
 }
 
 template class octave_sort<octave_idx_vector_sort *>;
+
diff --git a/liboctave/util/sparse-sort.h b/liboctave/util/sparse-sort.h
--- a/liboctave/util/sparse-sort.h
+++ b/liboctave/util/sparse-sort.h
@@ -47,8 +47,9 @@ public:
   octave_idx_type i;
   octave_idx_type idx;
 };
 
 bool octave_idx_vector_comp (octave_idx_vector_sort* i,
                              octave_idx_vector_sort* j);
 
 #endif
+
diff --git a/liboctave/util/sparse-util.cc b/liboctave/util/sparse-util.cc
--- a/liboctave/util/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -121,8 +121,9 @@ sparse_indices_ok (octave_idx_type *r, o
 
               jold = c[j];
             }
         }
     }
 
   return true;
 }
+
diff --git a/liboctave/util/sparse-util.h b/liboctave/util/sparse-util.h
--- a/liboctave/util/sparse-util.h
+++ b/liboctave/util/sparse-util.h
@@ -39,8 +39,9 @@ extern OCTAVE_API int
 SparseCholPrint (const char *fmt, ...);
 
 extern OCTAVE_API bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz);
 
 #endif
+
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -260,8 +260,9 @@ string_vector::list_in_columns (std::ost
             os << " ";
           pos += max_name_length;
         }
       os << "\n";
     }
 
   return os;
 }
+
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -123,19 +123,21 @@ public:
 
   std::ostream&
   list_in_columns (std::ostream&, int width = 0,
                    const std::string& prefix = "") const;
 };
 
 
 template<template <typename...> class String_Container, typename... Other>
-string_vector::string_vector (const String_Container<std::string, Other...>& lst)
+string_vector::string_vector (const String_Container<std::string, Other...>&
+                              lst)
   : Array<std::string> ()
 {
   resize (lst.size ());
 
   octave_idx_type i = 0;
   for (const std::string& s : lst)
     elem(i++) = s;
 }
 
 #endif
+
diff --git a/liboctave/util/sun-utils.h b/liboctave/util/sun-utils.h
--- a/liboctave/util/sun-utils.h
+++ b/liboctave/util/sun-utils.h
@@ -57,8 +57,9 @@ assign_double (double *unaligned_ptr, do
   union d2i *p = (union d2i *) unaligned_ptr;
 
   p->i[0] = v->i[0];
   p->i[1] = v->i[1];
 }
 
 #endif
 #endif
+
diff --git a/liboctave/util/unwind-prot.cc b/liboctave/util/unwind-prot.cc
--- a/liboctave/util/unwind-prot.cc
+++ b/liboctave/util/unwind-prot.cc
@@ -34,8 +34,9 @@ namespace octave
   unwind_protect_safe::warn_unhandled_exception (void) const
   {
     (*current_liboctave_warning_handler)
       ("unhandled exception in unwind_protect_safe handler.  "
        "It is a bug in Octave for this to happen.  "
        "Please help improve Octave by reporting it.");
   }
 }
+
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -122,29 +122,29 @@ namespace octave
 
     void warn_unhandled_exception (void) const;
 
   public:
 
     unwind_protect_safe (void) : unwind_protect () { }
 
     ~unwind_protect_safe (void)
-      {
-        while (! empty ())
-          {
-            try
-              {
-                run_first ();
-              }
-            catch (...) // Yes, the black hole.  Remember we're in a destructor.
-              {
-                warn_unhandled_exception ();
-              }
-          }
-      }
+    {
+      while (! empty ())
+        {
+          try
+            {
+              run_first ();
+            }
+          catch (...) // Yes, the black hole.  Remember we're in a destructor.
+            {
+              warn_unhandled_exception ();
+            }
+        }
+    }
 
   private:
 
     // No copying!
 
     unwind_protect_safe (const unwind_protect_safe&);
 
     unwind_protect_safe& operator = (const unwind_protect_safe&);
@@ -157,8 +157,9 @@ OCTAVE_DEPRECATED ("use 'octave::unwind_
 typedef octave::unwind_protect unwind_protect;
 
 OCTAVE_DEPRECATED ("use 'octave::unwind_protect_safe' instead")
 typedef octave::unwind_protect_safe unwind_protect_safe;
 
 #endif
 
 #endif
+
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -64,17 +64,17 @@ namespace octave
       {
         std::string msg;
         int status = octave::sys::mkdir (directory, 0777, msg);
 
         if (status < 0)
           {
             ok = false;
             errmsg = "__ftp_mget__: can not create directory '"
-              + target + sep + directory + "': " + msg;
+                     + target + sep + directory + "': " + msg;
             return;
           }
       }
 
     cwd (directory);
 
     if (good ())
       {
@@ -164,17 +164,17 @@ namespace octave
 
                 std::string realfile = realdir + octave::sys::file_ops::dir_sep_str () + file;
                 octave::sys::file_stat fs (realfile);
 
                 if (! fs.exists ())
                   {
                     ok = false;
                     errmsg = "__ftp__mput: file '" + realfile
-                      + "' does not exist";
+                             + "' does not exist";
                     break;
                   }
 
                 if (fs.is_dir ())
                   {
                     file_list.append (mput_directory (realdir, file));
 
                     if (! good ())
@@ -185,17 +185,17 @@ namespace octave
                     // FIXME: Does ascii mode need to be flagged here?
                     std::ifstream ifile (realfile.c_str (), std::ios::in |
                                          std::ios::binary);
 
                     if (! ifile.is_open ())
                       {
                         ok = false;
                         errmsg = "__ftp_mput__: unable to open file '"
-                          + realfile + "'";
+                                 + realfile + "'";
                         break;
                       }
 
                     put (file, ifile);
 
                     ifile.close ();
 
                     if (! good ())
@@ -204,17 +204,17 @@ namespace octave
                     file_list.append (realfile);
                   }
               }
           }
         else
           {
             ok = false;
             errmsg = "__ftp_mput__: can not read the directory '"
-              + realdir + "'";
+                     + realdir + "'";
           }
       }
 
     return file_list;
   }
 
 #if defined (HAVE_CURL)
 
@@ -787,8 +787,9 @@ namespace octave
 
   url_transfer::url_transfer (const std::string& url, std::ostream& os)
     : rep (new REP_CLASS (url, os))
   { }
 
 #undef REP_CLASS
 
 }
+
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -49,32 +49,31 @@ namespace octave
     }
 
   public:
 
     friend class url_transfer;
 
     base_url_transfer (void)
       : count (1), host_or_url (), valid (false), ftp (false),
-      ascii_mode (false), ok (true), errmsg (),
-      curr_istream (&std::cin), curr_ostream (&std::cout)
-      { }
+        ascii_mode (false), ok (true), errmsg (),
+        curr_istream (&std::cin), curr_ostream (&std::cout) { }
 
     base_url_transfer (const std::string& host,
                        const std::string& /* user_arg */,
                        const std::string& /* passwd */,
                        std::ostream& os)
       : count (1), host_or_url (host), valid (false), ftp (true),
-      ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
-      curr_ostream (&os) { }
+        ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
+        curr_ostream (&os) { }
 
     base_url_transfer (const std::string& url, std::ostream& os)
       : count (1), host_or_url (url), valid (false), ftp (false),
-      ascii_mode (false), ok (true), errmsg (),
-      curr_istream (&std::cin), curr_ostream (&os) { }
+        ascii_mode (false), ok (true), errmsg (),
+        curr_istream (&std::cin), curr_ostream (&os) { }
 
     virtual ~base_url_transfer (void) { }
 
     bool is_valid (void) const { return valid; }
 
     bool good (void) const { return valid && ok; }
 
     virtual void perform (void) { }
@@ -173,39 +172,39 @@ namespace octave
     url_transfer (void);
 
     url_transfer (const std::string& host, const std::string& user,
                   const std::string& passwd, std::ostream& os);
 
     url_transfer (const std::string& url, std::ostream& os);
 
     url_transfer (const url_transfer& h) : rep (h.rep)
-      {
-        rep->count++;
-      }
+    {
+      rep->count++;
+    }
 
     ~url_transfer (void)
-      {
-        if (--rep->count == 0)
-          delete rep;
-      }
+    {
+      if (--rep->count == 0)
+        delete rep;
+    }
 
     url_transfer& operator = (const url_transfer& h)
-      {
-        if (this != &h)
-          {
-            if (--rep->count == 0)
-              delete rep;
+    {
+      if (this != &h)
+        {
+          if (--rep->count == 0)
+            delete rep;
 
-            rep = h.rep;
-            rep->count++;
-          }
+          rep = h.rep;
+          rep->count++;
+        }
 
-        return *this;
-      }
+      return *this;
+    }
 
     bool is_valid (void) const { return rep->is_valid (); }
 
     bool good (void) const { return rep->good (); }
 
     std::string lasterror (void) const { return rep->lasterror (); }
 
     std::ostream& set_ostream (std::ostream& os)
@@ -295,8 +294,9 @@ OCTAVE_DEPRECATED ("use 'octave::base_ur
 typedef octave::base_url_transfer base_url_transfer;
 
 OCTAVE_DEPRECATED ("use 'octave::url_transfer' instead")
 typedef octave::url_transfer url_transfer;
 
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/areadlink-wrapper.c b/liboctave/wrappers/areadlink-wrapper.c
--- a/liboctave/wrappers/areadlink-wrapper.c
+++ b/liboctave/wrappers/areadlink-wrapper.c
@@ -34,8 +34,9 @@ along with Octave; see the file COPYING.
 
 // Returns pointer to allocated storage.
 
 char *
 octave_areadlink_wrapper (const char *name)
 {
   return areadlink (name);
 }
+
diff --git a/liboctave/wrappers/areadlink-wrapper.h b/liboctave/wrappers/areadlink-wrapper.h
--- a/liboctave/wrappers/areadlink-wrapper.h
+++ b/liboctave/wrappers/areadlink-wrapper.h
@@ -30,8 +30,9 @@ extern "C" {
 extern char *
 octave_areadlink_wrapper (const char *name);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/async-system-wrapper.c b/liboctave/wrappers/async-system-wrapper.c
--- a/liboctave/wrappers/async-system-wrapper.c
+++ b/liboctave/wrappers/async-system-wrapper.c
@@ -80,8 +80,9 @@ octave_async_system_wrapper (const char 
     execl (SHELL_PATH, "sh", "-c", cmd, (char *) (0));
   else
     retval = pid;
 
 #endif
 
   return retval;
 }
+
diff --git a/liboctave/wrappers/async-system-wrapper.h b/liboctave/wrappers/async-system-wrapper.h
--- a/liboctave/wrappers/async-system-wrapper.h
+++ b/liboctave/wrappers/async-system-wrapper.h
@@ -31,8 +31,9 @@ extern "C" {
 
 extern pid_t octave_async_system_wrapper (const char *cmd);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/base64-wrappers.c b/liboctave/wrappers/base64-wrappers.c
--- a/liboctave/wrappers/base64-wrappers.c
+++ b/liboctave/wrappers/base64-wrappers.c
@@ -40,8 +40,9 @@ octave_base64_encode_alloc_wrapper (cons
 }
 
 bool
 octave_base64_decode_alloc_wrapper (const char *in, size_t inlen,
                                     char **out, size_t *outlen)
 {
   return base64_decode_alloc (in, inlen, out, outlen);
 }
+
diff --git a/liboctave/wrappers/base64-wrappers.h b/liboctave/wrappers/base64-wrappers.h
--- a/liboctave/wrappers/base64-wrappers.h
+++ b/liboctave/wrappers/base64-wrappers.h
@@ -34,8 +34,9 @@ extern bool
 octave_base64_decode_alloc_wrapper (const char *in, size_t inlen,
                                     char **out, size_t *outlen);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/canonicalize-file-name-wrapper.c b/liboctave/wrappers/canonicalize-file-name-wrapper.c
--- a/liboctave/wrappers/canonicalize-file-name-wrapper.c
+++ b/liboctave/wrappers/canonicalize-file-name-wrapper.c
@@ -33,8 +33,9 @@ along with Octave; see the file COPYING.
 
 #include "canonicalize-file-name-wrapper.h"
 
 char *
 octave_canonicalize_file_name_wrapper (const char *name)
 {
   return canonicalize_file_name (name);
 }
+
diff --git a/liboctave/wrappers/canonicalize-file-name-wrapper.h b/liboctave/wrappers/canonicalize-file-name-wrapper.h
--- a/liboctave/wrappers/canonicalize-file-name-wrapper.h
+++ b/liboctave/wrappers/canonicalize-file-name-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern char *octave_canonicalize_file_name_wrapper (const char *name);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/dirent-wrappers.c b/liboctave/wrappers/dirent-wrappers.c
--- a/liboctave/wrappers/dirent-wrappers.c
+++ b/liboctave/wrappers/dirent-wrappers.c
@@ -76,8 +76,9 @@ octave_closedir_wrapper (void *dir)
 #  define NAME_MAX _POSIX_NAME_MAX
 #endif
 
 unsigned int
 octave_name_max_wrapper (void)
 {
   return NAME_MAX;
 }
+
diff --git a/liboctave/wrappers/dirent-wrappers.h b/liboctave/wrappers/dirent-wrappers.h
--- a/liboctave/wrappers/dirent-wrappers.h
+++ b/liboctave/wrappers/dirent-wrappers.h
@@ -41,8 +41,9 @@ extern int octave_closedir_wrapper (void
 
 extern unsigned int octave_name_max_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/fcntl-wrappers.c b/liboctave/wrappers/fcntl-wrappers.c
--- a/liboctave/wrappers/fcntl-wrappers.c
+++ b/liboctave/wrappers/fcntl-wrappers.c
@@ -189,8 +189,9 @@ int
 octave_o_wronly_wrapper (void)
 {
 #if defined (O_WRONLY)
   return O_WRONLY;
 #else
   return -1;
 #endif
 }
+
diff --git a/liboctave/wrappers/fcntl-wrappers.h b/liboctave/wrappers/fcntl-wrappers.h
--- a/liboctave/wrappers/fcntl-wrappers.h
+++ b/liboctave/wrappers/fcntl-wrappers.h
@@ -63,8 +63,9 @@ extern int octave_o_trunc_wrapper (void)
 
 extern int octave_o_wronly_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/filepos-wrappers.c b/liboctave/wrappers/filepos-wrappers.c
--- a/liboctave/wrappers/filepos-wrappers.c
+++ b/liboctave/wrappers/filepos-wrappers.c
@@ -39,8 +39,9 @@ octave_fseeko_wrapper (FILE *fp, off_t o
   return fseeko (fp, offset, whence);
 }
 
 off_t
 octave_ftello_wrapper (FILE *fp)
 {
   return ftello (fp);
 }
+
diff --git a/liboctave/wrappers/filepos-wrappers.h b/liboctave/wrappers/filepos-wrappers.h
--- a/liboctave/wrappers/filepos-wrappers.h
+++ b/liboctave/wrappers/filepos-wrappers.h
@@ -39,8 +39,9 @@ extern int octave_fseeko_wrapper (FILE *
 
 extern off_t octave_ftello_wrapper (FILE *fp);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/fpucw-wrappers.c b/liboctave/wrappers/fpucw-wrappers.c
--- a/liboctave/wrappers/fpucw-wrappers.c
+++ b/liboctave/wrappers/fpucw-wrappers.c
@@ -66,8 +66,9 @@ octave_begin_long_double_rounding (void)
   return oldcw;
 }
 
 void
 octave_end_long_double_rounding (unsigned int oldcw)
 {
   END_LONG_DOUBLE_ROUNDING ();
 }
+
diff --git a/liboctave/wrappers/fpucw-wrappers.h b/liboctave/wrappers/fpucw-wrappers.h
--- a/liboctave/wrappers/fpucw-wrappers.h
+++ b/liboctave/wrappers/fpucw-wrappers.h
@@ -35,8 +35,9 @@ extern unsigned int octave_begin_long_do
 
 extern void octave_end_long_double_rounding (unsigned int);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/gen-tempname-wrapper.c b/liboctave/wrappers/gen-tempname-wrapper.c
--- a/liboctave/wrappers/gen-tempname-wrapper.c
+++ b/liboctave/wrappers/gen-tempname-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "gen-tempname-wrapper.h"
 
 int
 octave_gen_tempname_wrapper (char *tmpl)
 {
   return gen_tempname (tmpl, 0, 0, GT_NOCREATE);
 }
+
diff --git a/liboctave/wrappers/gen-tempname-wrapper.h b/liboctave/wrappers/gen-tempname-wrapper.h
--- a/liboctave/wrappers/gen-tempname-wrapper.h
+++ b/liboctave/wrappers/gen-tempname-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern int octave_gen_tempname_wrapper (char *tmpl);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/getopt-wrapper.c b/liboctave/wrappers/getopt-wrapper.c
--- a/liboctave/wrappers/getopt-wrapper.c
+++ b/liboctave/wrappers/getopt-wrapper.c
@@ -108,8 +108,9 @@ octave_optarg_wrapper (void)
   return optarg;
 }
 
 int
 octave_optind_wrapper (void)
 {
   return optind;
 }
+
diff --git a/liboctave/wrappers/glob-wrappers.c b/liboctave/wrappers/glob-wrappers.c
--- a/liboctave/wrappers/glob-wrappers.c
+++ b/liboctave/wrappers/glob-wrappers.c
@@ -103,8 +103,9 @@ octave_fnm_noescape_wrapper (void)
   return FNM_NOESCAPE;
 }
 
 int
 octave_fnm_period_wrapper (void)
 {
   return FNM_PERIOD;
 }
+
diff --git a/liboctave/wrappers/hash-wrappers.c b/liboctave/wrappers/hash-wrappers.c
--- a/liboctave/wrappers/hash-wrappers.c
+++ b/liboctave/wrappers/hash-wrappers.c
@@ -89,8 +89,9 @@ octave_sha384_buffer_wrapper (const char
   return sha384_buffer (buf, len, res);
 }
 
 void *
 octave_sha512_buffer_wrapper (const char *buf, size_t len, void *res)
 {
   return sha512_buffer (buf, len, res);
 }
+
diff --git a/liboctave/wrappers/hash-wrappers.h b/liboctave/wrappers/hash-wrappers.h
--- a/liboctave/wrappers/hash-wrappers.h
+++ b/liboctave/wrappers/hash-wrappers.h
@@ -60,8 +60,9 @@ octave_sha384_buffer_wrapper (const char
 extern void *
 octave_sha512_buffer_wrapper (const char *buf, size_t len, void *res);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/math-wrappers.c b/liboctave/wrappers/math-wrappers.c
--- a/liboctave/wrappers/math-wrappers.c
+++ b/liboctave/wrappers/math-wrappers.c
@@ -39,8 +39,9 @@ octave_frexp_wrapper (double x, int *exp
   return frexp (x, expptr);
 }
 
 float
 octave_frexpf_wrapper (float x, int *expptr)
 {
   return frexpf (x, expptr);
 }
+
diff --git a/liboctave/wrappers/math-wrappers.h b/liboctave/wrappers/math-wrappers.h
--- a/liboctave/wrappers/math-wrappers.h
+++ b/liboctave/wrappers/math-wrappers.h
@@ -33,8 +33,9 @@ octave_frexp_wrapper (double x, int *exp
 float
 octave_frexpf_wrapper (float x, int *expptr);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/mkostemp-wrapper.c b/liboctave/wrappers/mkostemp-wrapper.c
--- a/liboctave/wrappers/mkostemp-wrapper.c
+++ b/liboctave/wrappers/mkostemp-wrapper.c
@@ -33,8 +33,9 @@ along with Octave; see the file COPYING.
 
 #include "mkostemp-wrapper.h"
 
 int
 octave_mkostemp_wrapper (char *tmpl)
 {
   return mkostemp (tmpl, O_BINARY);
 }
+
diff --git a/liboctave/wrappers/mkostemp-wrapper.h b/liboctave/wrappers/mkostemp-wrapper.h
--- a/liboctave/wrappers/mkostemp-wrapper.h
+++ b/liboctave/wrappers/mkostemp-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern int octave_mkostemp_wrapper (char *tmpl);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/nanosleep-wrapper.c b/liboctave/wrappers/nanosleep-wrapper.c
--- a/liboctave/wrappers/nanosleep-wrapper.c
+++ b/liboctave/wrappers/nanosleep-wrapper.c
@@ -33,8 +33,9 @@ along with Octave; see the file COPYING.
 #include "nanosleep-wrapper.h"
 
 int
 octave_nanosleep_wrapper (const struct timespec *requested,
                           struct timespec *remaining)
 {
   return nanosleep (requested, remaining);
 }
+
diff --git a/liboctave/wrappers/nanosleep-wrapper.h b/liboctave/wrappers/nanosleep-wrapper.h
--- a/liboctave/wrappers/nanosleep-wrapper.h
+++ b/liboctave/wrappers/nanosleep-wrapper.h
@@ -31,8 +31,9 @@ extern int
 octave_nanosleep_wrapper (const struct timespec *requested,
                           struct timespec *remaining);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/nproc-wrapper.c b/liboctave/wrappers/nproc-wrapper.c
--- a/liboctave/wrappers/nproc-wrapper.c
+++ b/liboctave/wrappers/nproc-wrapper.c
@@ -50,8 +50,9 @@ octave_num_processors_wrapper (enum octa
 
     case OCTAVE_NPROC_CURRENT_OVERRIDABLE:
       query = NPROC_CURRENT_OVERRIDABLE;
       break;
     }
 
   return num_processors (query);
 }
+
diff --git a/liboctave/wrappers/nproc-wrapper.h b/liboctave/wrappers/nproc-wrapper.h
--- a/liboctave/wrappers/nproc-wrapper.h
+++ b/liboctave/wrappers/nproc-wrapper.h
@@ -37,8 +37,9 @@ enum octave_nproc_query
 extern unsigned long int
 octave_num_processors_wrapper (enum octave_nproc_query);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/octave-popen2.c b/liboctave/wrappers/octave-popen2.c
--- a/liboctave/wrappers/octave-popen2.c
+++ b/liboctave/wrappers/octave-popen2.c
@@ -232,8 +232,9 @@ octave_popen2 (const char *cmd, char *co
     }
 
   *errmsg = "foobar!";
   *errmsg = strerror (errno);
   return pid;
 }
 
 #endif
+
diff --git a/liboctave/wrappers/octave-popen2.h b/liboctave/wrappers/octave-popen2.h
--- a/liboctave/wrappers/octave-popen2.h
+++ b/liboctave/wrappers/octave-popen2.h
@@ -31,8 +31,9 @@ extern pid_t
 octave_popen2 (const char *cmd, char *const *args, bool sync_mode,
                int *fildes, const char **errmsg);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/putenv-wrapper.c b/liboctave/wrappers/putenv-wrapper.c
--- a/liboctave/wrappers/putenv-wrapper.c
+++ b/liboctave/wrappers/putenv-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "putenv-wrapper.h"
 
 int
 octave_putenv_wrapper (char *str)
 {
   return putenv (str);
 }
+
diff --git a/liboctave/wrappers/putenv-wrapper.h b/liboctave/wrappers/putenv-wrapper.h
--- a/liboctave/wrappers/putenv-wrapper.h
+++ b/liboctave/wrappers/putenv-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern int octave_putenv_wrapper (char *str);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/set-program-name-wrapper.c b/liboctave/wrappers/set-program-name-wrapper.c
--- a/liboctave/wrappers/set-program-name-wrapper.c
+++ b/liboctave/wrappers/set-program-name-wrapper.c
@@ -35,8 +35,9 @@ along with Octave; see the file COPYING.
 const char *
 octave_set_program_name_wrapper (const char *pname)
 {
   set_program_name (pname);
 
   // Let gnulib strip off things like the "lt-" prefix from libtool.
   return program_name;
 }
+
diff --git a/liboctave/wrappers/set-program-name-wrapper.h b/liboctave/wrappers/set-program-name-wrapper.h
--- a/liboctave/wrappers/set-program-name-wrapper.h
+++ b/liboctave/wrappers/set-program-name-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern const char *octave_set_program_name_wrapper (const char *pname);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/signal-wrappers.c b/liboctave/wrappers/signal-wrappers.c
--- a/liboctave/wrappers/signal-wrappers.c
+++ b/liboctave/wrappers/signal-wrappers.c
@@ -489,8 +489,9 @@ octave_restore_signal_mask (void)
   sigprocmask (SIG_SETMASK, &octave_signal_mask, 0);
 }
 
 int
 octave_raise_wrapper (int signum)
 {
   return raise (signum);
 }
+
diff --git a/liboctave/wrappers/signal-wrappers.h b/liboctave/wrappers/signal-wrappers.h
--- a/liboctave/wrappers/signal-wrappers.h
+++ b/liboctave/wrappers/signal-wrappers.h
@@ -68,8 +68,9 @@ extern void octave_restore_signal_mask (
 
 extern int octave_raise_wrapper (int signum);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/stat-wrappers.c b/liboctave/wrappers/stat-wrappers.c
--- a/liboctave/wrappers/stat-wrappers.c
+++ b/liboctave/wrappers/stat-wrappers.c
@@ -234,8 +234,9 @@ bool
 octave_have_struct_stat_st_blocks (void)
 {
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
   return true;
 #else
   return false;
 #endif
 }
+
diff --git a/liboctave/wrappers/stat-wrappers.h b/liboctave/wrappers/stat-wrappers.h
--- a/liboctave/wrappers/stat-wrappers.h
+++ b/liboctave/wrappers/stat-wrappers.h
@@ -75,8 +75,9 @@ extern bool octave_have_struct_stat_st_r
 extern bool octave_have_struct_stat_st_blksize (void);
 extern bool octave_have_struct_stat_st_blocks (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/strdup-wrapper.c b/liboctave/wrappers/strdup-wrapper.c
--- a/liboctave/wrappers/strdup-wrapper.c
+++ b/liboctave/wrappers/strdup-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "strdup-wrapper.h"
 
 char *
 octave_strdup_wrapper (const char *str)
 {
   return strdup (str);
 }
+
diff --git a/liboctave/wrappers/strdup-wrapper.h b/liboctave/wrappers/strdup-wrapper.h
--- a/liboctave/wrappers/strdup-wrapper.h
+++ b/liboctave/wrappers/strdup-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern char *octave_strdup_wrapper (const char *str);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/strftime-wrapper.c b/liboctave/wrappers/strftime-wrapper.c
--- a/liboctave/wrappers/strftime-wrapper.c
+++ b/liboctave/wrappers/strftime-wrapper.c
@@ -35,8 +35,9 @@ along with Octave; see the file COPYING.
 #include "strftime-wrapper.h"
 
 size_t
 octave_strftime_wrapper (char *buf, size_t len, const char *fmt,
                          const struct tm *t, struct tm_zone *tz, int ns)
 {
   return nstrftime (buf, len, fmt, t, tz, ns);
 }
+
diff --git a/liboctave/wrappers/strftime-wrapper.h b/liboctave/wrappers/strftime-wrapper.h
--- a/liboctave/wrappers/strftime-wrapper.h
+++ b/liboctave/wrappers/strftime-wrapper.h
@@ -37,8 +37,9 @@ extern size_t
 octave_strftime_wrapper (char *buf, size_t len, const char *fmt,
                          const struct tm *t, struct tm_zone *tz, int ns);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/strmode-wrapper.c b/liboctave/wrappers/strmode-wrapper.c
--- a/liboctave/wrappers/strmode-wrapper.c
+++ b/liboctave/wrappers/strmode-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "strmode-wrapper.h"
 
 void
 octave_strmode_wrapper (mode_t mode, char *buffer)
 {
   strmode (mode, buffer);
 }
+
diff --git a/liboctave/wrappers/strmode-wrapper.h b/liboctave/wrappers/strmode-wrapper.h
--- a/liboctave/wrappers/strmode-wrapper.h
+++ b/liboctave/wrappers/strmode-wrapper.h
@@ -31,8 +31,9 @@ extern "C" {
 
 extern void octave_strmode_wrapper (mode_t mode, char *buffer);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/strptime-wrapper.c b/liboctave/wrappers/strptime-wrapper.c
--- a/liboctave/wrappers/strptime-wrapper.c
+++ b/liboctave/wrappers/strptime-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "strptime-wrapper.h"
 
 char *
 octave_strptime_wrapper (const char *p, const char *fmt, struct tm *t)
 {
   return strptime (p, fmt, t);
 }
+
diff --git a/liboctave/wrappers/strptime-wrapper.h b/liboctave/wrappers/strptime-wrapper.h
--- a/liboctave/wrappers/strptime-wrapper.h
+++ b/liboctave/wrappers/strptime-wrapper.h
@@ -30,8 +30,9 @@ extern "C" {
 extern char *
 octave_strptime_wrapper (const char *p, const char *fmt, struct tm *t);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/time-wrappers.c b/liboctave/wrappers/time-wrappers.c
--- a/liboctave/wrappers/time-wrappers.c
+++ b/liboctave/wrappers/time-wrappers.c
@@ -147,8 +147,9 @@ octave_getrusage_wrapper (time_t *usr_se
   return status;
 }
 
 time_t
 octave_mktime_wrapper (struct tm *tp)
 {
   return mktime (tp);
 }
+
diff --git a/liboctave/wrappers/time-wrappers.h b/liboctave/wrappers/time-wrappers.h
--- a/liboctave/wrappers/time-wrappers.h
+++ b/liboctave/wrappers/time-wrappers.h
@@ -52,8 +52,9 @@ extern time_t
 octave_mktime_wrapper (struct tm *tp);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
 
+
diff --git a/liboctave/wrappers/tmpfile-wrapper.c b/liboctave/wrappers/tmpfile-wrapper.c
--- a/liboctave/wrappers/tmpfile-wrapper.c
+++ b/liboctave/wrappers/tmpfile-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "tmpfile-wrapper.h"
 
 FILE *
 octave_tmpfile_wrapper (void)
 {
   return tmpfile ();
 }
+
diff --git a/liboctave/wrappers/tmpfile-wrapper.h b/liboctave/wrappers/tmpfile-wrapper.h
--- a/liboctave/wrappers/tmpfile-wrapper.h
+++ b/liboctave/wrappers/tmpfile-wrapper.h
@@ -38,8 +38,9 @@ extern "C" {
 
 extern FILE *octave_tmpfile_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/uname-wrapper.c b/liboctave/wrappers/uname-wrapper.c
--- a/liboctave/wrappers/uname-wrapper.c
+++ b/liboctave/wrappers/uname-wrapper.c
@@ -56,8 +56,9 @@ octave_uname_wrapper (char **sysname, ch
       *nodename = 0;
       *release = 0;
       *version = 0;
       *machine = 0;
     }
 
   return err;
 }
+
diff --git a/liboctave/wrappers/uname-wrapper.h b/liboctave/wrappers/uname-wrapper.h
--- a/liboctave/wrappers/uname-wrapper.h
+++ b/liboctave/wrappers/uname-wrapper.h
@@ -31,8 +31,9 @@ extern int
 octave_uname_wrapper (char **sysname, char **nodename,
                       char **release, char **version, char **machine);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/unistd-wrappers.c b/liboctave/wrappers/unistd-wrappers.c
--- a/liboctave/wrappers/unistd-wrappers.c
+++ b/liboctave/wrappers/unistd-wrappers.c
@@ -442,8 +442,9 @@ bool
 octave_have_vfork (void)
 {
 #if defined (HAVE_VFORK)
   return true;
 #else
   return false;
 #endif
 }
+
diff --git a/liboctave/wrappers/unistd-wrappers.h b/liboctave/wrappers/unistd-wrappers.h
--- a/liboctave/wrappers/unistd-wrappers.h
+++ b/liboctave/wrappers/unistd-wrappers.h
@@ -101,8 +101,9 @@ extern bool octave_have_fork (void);
 
 extern bool octave_have_vfork (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/unsetenv-wrapper.c b/liboctave/wrappers/unsetenv-wrapper.c
--- a/liboctave/wrappers/unsetenv-wrapper.c
+++ b/liboctave/wrappers/unsetenv-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "unsetenv-wrapper.h"
 
 int
 octave_unsetenv_wrapper (const char *name)
 {
   return unsetenv (name);
 }
+
diff --git a/liboctave/wrappers/unsetenv-wrapper.h b/liboctave/wrappers/unsetenv-wrapper.h
--- a/liboctave/wrappers/unsetenv-wrapper.h
+++ b/liboctave/wrappers/unsetenv-wrapper.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern int octave_unsetenv_wrapper (const char *name);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/vasprintf-wrapper.c b/liboctave/wrappers/vasprintf-wrapper.c
--- a/liboctave/wrappers/vasprintf-wrapper.c
+++ b/liboctave/wrappers/vasprintf-wrapper.c
@@ -32,8 +32,9 @@ along with Octave; see the file COPYING.
 
 #include "vasprintf-wrapper.h"
 
 int
 octave_vasprintf_wrapper (char **buf, const char *fmt, va_list args)
 {
   return vasprintf (buf, fmt, args);
 }
+
diff --git a/liboctave/wrappers/vasprintf-wrapper.h b/liboctave/wrappers/vasprintf-wrapper.h
--- a/liboctave/wrappers/vasprintf-wrapper.h
+++ b/liboctave/wrappers/vasprintf-wrapper.h
@@ -36,8 +36,9 @@ extern "C" {
 extern int
 octave_vasprintf_wrapper (char **buf, const char *fmt, va_list args);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/wait-for-input.c b/liboctave/wrappers/wait-for-input.c
--- a/liboctave/wrappers/wait-for-input.c
+++ b/liboctave/wrappers/wait-for-input.c
@@ -51,8 +51,9 @@ octave_wait_for_input (int fid)
       retval = select (FD_SETSIZE, &set, 0, 0, 0);
     }
 #else
   retval = 1;
 #endif
 
   return retval;
 }
+
diff --git a/liboctave/wrappers/wait-for-input.h b/liboctave/wrappers/wait-for-input.h
--- a/liboctave/wrappers/wait-for-input.h
+++ b/liboctave/wrappers/wait-for-input.h
@@ -29,8 +29,9 @@ extern "C" {
 
 extern int octave_wait_for_input (int fid);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
diff --git a/liboctave/wrappers/wait-wrappers.c b/liboctave/wrappers/wait-wrappers.c
--- a/liboctave/wrappers/wait-wrappers.c
+++ b/liboctave/wrappers/wait-wrappers.c
@@ -116,8 +116,9 @@ octave_wtermsig_wrapper (int status)
   return WTERMSIG (status);
 }
 
 int
 octave_wuntraced_wrapper (void)
 {
   return WUNTRACED;
 }
+
diff --git a/liboctave/wrappers/wait-wrappers.h b/liboctave/wrappers/wait-wrappers.h
--- a/liboctave/wrappers/wait-wrappers.h
+++ b/liboctave/wrappers/wait-wrappers.h
@@ -57,8 +57,9 @@ extern int octave_wtermsig_wrapper (int 
 
 extern int octave_wuntraced_wrapper (void);
 
 #if defined __cplusplus
 }
 #endif
 
 #endif
+
