# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497244449 25200
#      Sun Jun 11 22:14:09 2017 -0700
# Node ID 80c42f4cca13bc4d6c0cdefe1cbffbc9263c7ff2
# Parent  00e518162fda5008a94611152ab31ae1ef2dbbca
maint: Deprecate is_empty and replace with isempty.

* ov.h (is_empty): Use OCTAVE_DEPRECATED macro around function.
* ov.h (isempty): New function.

* Array.h (is_empty): Use OCTAVE_DEPRECATED macro around function.
* Array.h (isempty): New function.

* Range.h (is_empty): Use OCTAVE_DEPRECATED macro around function.
* Range.h (isempty): New function.

* Sparse.h (is_empty): Use OCTAVE_DEPRECATED macro around function.
* Sparse.h (isempty): New function.

* Backend.cc, BaseControl.cc, Canvas.cc, Figure.cc, gl-select.cc,
__magick_read__.cc, __qp__.cc, cellfun.cc, daspk.cc, dasrt.cc, dassl.cc,
data.cc, debug.cc, det.cc, eig.cc, error.cc, fft.cc, filter.cc, find.cc,
ft-text-renderer.cc, gl-render.cc, gl2ps-print.cc, graphics.cc, graphics.in.h,
hess.cc, inv.cc, lsode.cc, lu.cc, max.cc, mex.cc, mxarray.in.h, oct-handle.h,
oct-lvalue.cc, oct-map.cc, oct-map.h, oct-stream.cc, pinv.cc, pr-output.cc,
quadcc.cc, qz.cc, strfind.cc, strfns.cc, sylvester.cc, time.cc, toplev.cc,
tril.cc, urlwrite.cc, utils.cc, utils.h, xnorm.cc, __delaunayn__.cc,
__glpk__.cc, __init_fltk__.cc, __init_gnuplot__.cc, __ode15__.cc,
__voronoi__.cc, chol.cc, convhulln.cc, ov-base-diag.cc, ov-base-mat.cc,
ov-base-sparse.cc, ov-base.cc, ov-base.h, ov-bool-mat.cc, ov-bool-sparse.cc,
ov-cell.cc, ov-class.cc, ov-classdef.cc, ov-cx-sparse.cc, ov-fcn-inline.cc,
ov-flt-re-mat.cc, ov-intx.h, ov-java.cc, ov-perm.cc, ov-range.cc, ov-re-mat.cc,
ov-re-sparse.cc, ov-str-mat.cc, ov-struct.cc, ov-usr-fcn.cc, ov.cc, ov.h,
bp-table.cc, oct-parse.in.yy, pt-eval.cc, pt-tm-const.cc, pt-tm-const.h,
Array.cc, Range.cc, Range.h, Sparse.cc, Sparse.h, chNDArray.cc, dNDArray.cc,
fNDArray.cc, DASPK.cc, DASRT.cc, DASSL.cc, LSODE.cc, bsxfun-defs.cc,
eigs-base.cc, oct-convn.cc, qr.cc:
Replace instances of is_empty with isempty.

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -224,17 +224,17 @@ namespace QtHandles
 
   ObjectProxy*
   Backend::toolkitObjectProxy (const graphics_object& go)
   {
     if (go)
       {
         octave_value ov = go.get (toolkitObjectProperty (go));
 
-        if (ov.is_defined () && ! ov.is_empty ())
+        if (ov.is_defined () && ! ov.isempty ())
           {
             OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
             return reinterpret_cast<ObjectProxy *> (ptr);
           }
       }
 
     return 0;
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -105,17 +105,17 @@ namespace QtHandles
     Matrix bb = up.get_boundingbox (false);
     w->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
                     octave::math::round (bb(2)), octave::math::round (bb(3)));
     w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
     updatePalette (up, w);
     w->setEnabled (up.enable_is ("on"));
     w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
     w->setVisible (up.is_visible ());
-    m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
+    m_keyPressHandlerDefined = ! up.get_keypressfcn ().isempty ();
 
     w->installEventFilter (this);
 
     m_normalizedFont = up.fontunits_is ("normalized");
   }
 
   BaseControl::~BaseControl (void)
   { }
@@ -163,17 +163,17 @@ namespace QtHandles
         w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
         break;
 
       case base_properties::ID_VISIBLE:
         w->setVisible (up.is_visible ());
         break;
 
       case uicontrol::properties::ID_KEYPRESSFCN:
-        m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
+        m_keyPressHandlerDefined = ! up.get_keypressfcn ().isempty ();
         break;
 
       default:
         break;
       }
   }
 
   bool
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -534,17 +534,17 @@ namespace QtHandles
       {
         graphics_object obj = gh_manager::get_object (m_handle);
 
         if (obj.valid_object ())
           {
             graphics_object figObj (obj.get_ancestor ("figure"));
 
             if (figObj.valid_object () &&
-                ! figObj.get ("windowbuttonmotionfcn").is_empty ())
+                ! figObj.get ("windowbuttonmotionfcn").isempty ())
               {
                 updateCurrentPoint (figObj, obj, event);
                 gh_manager::post_callback (figObj.get_handle (),
                                            "windowbuttonmotionfcn");
               }
           }
       }
 
@@ -663,17 +663,17 @@ namespace QtHandles
                                   Utils::figureSelectionType (event, isdblclick), false);
 
             updateCurrentPoint (figObj, obj, event);
 
             gh_manager::post_callback (figObj.get_handle (),
                                        "windowbuttondownfcn",
                                        button_number (event));
 
-            if (currentObj.get ("buttondownfcn").is_empty ())
+            if (currentObj.get ("buttondownfcn").isempty ())
               {
                 graphics_object parentObj =
                   gh_manager::get_object (currentObj.get_parent ());
 
                 if (parentObj.valid_object () && parentObj.isa ("hggroup"))
                   gh_manager::post_callback (parentObj.get_handle (),
                                              "buttondownfcn",
                                              button_number (event));
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -481,24 +481,24 @@ namespace QtHandles
 
       case figure::properties::ID_MENUBAR:
         showMenuBar (fp.menubar_is ("figure"));
         if (fp.toolbar_is ("auto"))
           showFigureToolBar (fp.menubar_is ("figure"));
         break;
 
       case figure::properties::ID_KEYPRESSFCN:
-        if (fp.get_keypressfcn ().is_empty ())
+        if (fp.get_keypressfcn ().isempty ())
           m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
         else
           m_container->canvas (m_handle)->addEventMask (Canvas::KeyPress);
         break;
 
       case figure::properties::ID_KEYRELEASEFCN:
-        if (fp.get_keyreleasefcn ().is_empty ())
+        if (fp.get_keyreleasefcn ().isempty ())
           m_container->canvas (m_handle)->clearEventMask (Canvas::KeyRelease);
         else
           m_container->canvas (m_handle)->addEventMask (Canvas::KeyRelease);
         break;
 
       case figure::properties::ID_WINDOWSTYLE:
         if (fp.windowstyle_is ("modal"))
           {
diff --git a/libgui/graphics/gl-select.cc b/libgui/graphics/gl-select.cc
--- a/libgui/graphics/gl-select.cc
+++ b/libgui/graphics/gl-select.cc
@@ -171,17 +171,17 @@ namespace octave
     glVertex3dv (p3.data ());
     glVertex3dv (p4.data ());
     glEnd ();
   }
 
   void
   opengl_selector::draw_text (const text::properties& props)
   {
-    if (props.get_string ().is_empty ())
+    if (props.get_string ().isempty ())
       return;
 
     Matrix pos = props.get_data_position ();
     const Matrix bbox = props.get_extent_matrix ();
 
     fake_text (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0, bbox);
   }
 
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1120,17 +1120,17 @@ encode_uint_image (std::vector<Magick::I
   typedef typename T::element_type P;
   const octave_idx_type channels = (img.ndims () < 3 ? 1 : img.dims ()(2));
   const octave_idx_type nFrames  = (img.ndims () < 4 ? 1 : img.dims ()(3));
   const octave_idx_type nRows    = img.rows ();
   const octave_idx_type nCols    = img.columns ();
   const octave_idx_type bitdepth = bitdepth_from_class<T> ();
 
   Magick::ImageType type;
-  const bool has_alpha = ! alpha.is_empty ();
+  const bool has_alpha = ! alpha.isempty ();
   switch (channels)
     {
     case 1:
       if (has_alpha)
         type = Magick::GrayscaleMatteType;
       else
         type = Magick::GrayscaleType;
       break;
@@ -1484,17 +1484,17 @@ Use @code{imwrite} instead.
   const octave_scalar_map options
     = args(4).xscalar_map_value ("__magick_write__: OPTIONS must be a struct");
 
   const octave_value img = args(2);
   const Matrix cmap = args(3).xmatrix_value ("__magick_write__: invalid MAP");
 
   std::vector<Magick::Image> imvec;
 
-  if (cmap.is_empty ())
+  if (cmap.isempty ())
     {
       const octave_value alpha = options.getfield ("alpha");
       if (img.is_bool_type ())
         encode_bool_image (imvec, img.bool_array_value ());
       else if (img.is_uint8_type ())
         encode_uint_image<uint8NDArray>  (imvec, img.uint8_array_value (),
                                           alpha.uint8_array_value ());
       else if (img.is_uint16_type ())
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 
 static Matrix
 null (const Matrix& A, octave_idx_type& rank)
 {
   Matrix retval;
 
   rank = 0;
 
-  if (! A.is_empty ())
+  if (! A.isempty ())
     {
       octave::math::svd<Matrix> A_svd (A);
 
       DiagMatrix S = A_svd.singular_values ();
 
       ColumnVector s = S.extract_diag ();
 
       Matrix V = A_svd.right_singular_matrix ();
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -129,17 +129,17 @@ try_cellfun_internal_ops (const octave_v
   const Cell f_args = args(1).cell_value ();
 
   octave_idx_type k = f_args.numel ();
 
   if (name == "isempty")
     {
       BNDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = f_args.elem (count).is_empty ();
+        result(count) = f_args.elem (count).isempty ();
       retval(0) = result;
     }
   else if (name == "islogical")
     {
       BNDA result (f_args.dims ());
       for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
@@ -1646,17 +1646,17 @@ do_num2cell_elem (const NDA& array, octa
 static inline Cell
 do_num2cell_elem (const Cell& array, octave_idx_type i)
 { return Cell (array(i)); }
 
 template <typename NDA>
 static Cell
 do_num2cell (const NDA& array, const Array<int>& dimv)
 {
-  if (dimv.is_empty ())
+  if (dimv.isempty ())
     {
       Cell retval (array.dims ());
       octave_idx_type nel = array.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         retval.xelem (i) = do_num2cell_elem (array, i);
 
       return retval;
     }
@@ -1707,17 +1707,17 @@ static Cell
 do_object2cell (const octave_value& obj, const Array<int>& dimv)
 {
   Cell retval;
 
   // FIXME: this copy is only needed because the octave_value::size
   // method is not const.
   octave_value array = obj;
 
-  if (! dimv.is_empty ())
+  if (! dimv.isempty ())
     error ("num2cell (A, dim) not implemented for class objects");
 
   dim_vector dv = get_object_dims (array);
 
   retval.resize (dv);
 
   octave_value_list idx (1);
 
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -95,17 +95,17 @@ daspk_user_function (const ColumnVector&
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (tlen > 1)
         ires = tmp(1).idx_type_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 Matrix
 daspk_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
@@ -142,17 +142,17 @@ daspk_user_jacobian (const ColumnVector&
       if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
           warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 DEFUN (daspk, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -90,17 +90,17 @@ dasrt_user_f (const ColumnVector& x, con
       if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static ColumnVector
 dasrt_user_cf (const ColumnVector& x, double t)
@@ -131,17 +131,17 @@ dasrt_user_cf (const ColumnVector& x, do
       if (! warned_cf_imaginary && tmp(0).is_complex_type ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
           warned_cf_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static Matrix
 dasrt_user_j (const ColumnVector& x, const ColumnVector& xdot,
@@ -178,17 +178,17 @@ dasrt_user_j (const ColumnVector& x, con
       if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 DEFUN (dasrt, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -95,17 +95,17 @@ dassl_user_function (const ColumnVector&
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (tlen > 1)
         ires = tmp(1).int_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 Matrix
 dassl_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
@@ -142,17 +142,17 @@ dassl_user_jacobian (const ColumnVector&
       if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
           warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 DEFUN (dassl, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1728,17 +1728,17 @@ do_class_concat (const octave_value_list
       for (octave_idx_type k = 0; k < len; k++)
         {
           octave_value elt = ovl(k);
 
           std::string t1_type = elt.class_name ();
 
           if (t1_type == dtype)
             tmp(j++) = elt;
-          else if (elt.is_object () || ! elt.is_empty ())
+          else if (elt.is_object () || ! elt.isempty ())
             tmp(j++) = attempt_type_conversion (elt, dtype);
         }
 
       tmp.resize (j);
 
       octave_map m = do_single_type_concat_map (tmp, dim);
 
       std::string cname = tmp(0).class_name ();
@@ -1815,17 +1815,17 @@ do_cat (const octave_value_list& xargs, 
         {
           int j = 0;
           for (int i = 0; i < n_args; i++)
             {
               if (args(i).iscell ())
                 args(j++) = args(i);
               else
                 {
-                  if (args(i).is_empty ())
+                  if (args(i).isempty ())
                     continue;  // Delete empty non-cell arg
                   else
                     args(j++) = Cell (args(i));
                 }
             }
           n_args = j;
           args.resize (n_args);
         }
@@ -3545,17 +3545,17 @@ DEFUN (isempty, args, ,
 Return true if @var{a} is an empty matrix (any one of its dimensions is
 zero).
 @seealso{isnull, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_empty ());
+  return ovl (args(0).isempty ());
 }
 
 /*
 ## Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
@@ -3855,17 +3855,17 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
@@ -3965,17 +3965,17 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
@@ -4029,17 +4029,17 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
@@ -4094,17 +4094,17 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
@@ -4149,17 +4149,17 @@ fill_matrix (const octave_value_list& ar
       get_dimensions (args(0), fcn, dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("%s: dimension arguments must be scalar integers", fcn));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, fcn);
@@ -5104,17 +5104,17 @@ if fewer than two values are requested.
 
   octave_idx_type npoints = 100;
   if (nargin == 3)
     {
       // Apparently undocumented Matlab.  If the third arg is an empty
       // numeric value, the number of points defaults to 1.
       octave_value arg_3 = args(2);
 
-      if (arg_3.is_numeric_type () && arg_3.is_empty ())
+      if (arg_3.is_numeric_type () && arg_3.isempty ())
         npoints = 1;
       else if (! arg_3.is_scalar_type ())
         error ("linspace: N must be a scalar");
       else
         // Even if third arg is not an integer, it must be cast to int
         npoints = arg_3.idx_type_value ();
     }
 
@@ -5357,17 +5357,17 @@ the unspecified dimension.
     }
   else
     {
       new_dims = dim_vector::alloc (nargin-1);
       int empty_dim = -1;
 
       for (int i = 1; i < nargin; i++)
         {
-          if (args(i).is_empty ())
+          if (args(i).isempty ())
             {
               if (empty_dim > 0)
                 error ("reshape: only a single dimension can be unknown");
 
               empty_dim = i;
               new_dims(i-1) = 1;
             }
           else
@@ -5613,17 +5613,17 @@ compute the norms of each column and ret
         error ("norm: unrecognized option: %s", str.c_str ());
 
       // we've handled the last parameter, so act as if it was removed
       nargin--;
     }
 
   octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
 
-  if (p_arg.is_empty ())
+  if (p_arg.isempty ())
     p_arg = octave_value (2);
   else if (p_arg.is_string ())
     {
       std::string str = p_arg.string_value ();
       std::transform (str.begin (), str.end (), str.begin (), tolower);
       if (strflag != sfcols && strflag != sfrows)
         error ("norm: invalid combination of options");
 
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -200,31 +200,31 @@ all breakpoints within the file are clea
       octave_map mv = args(0).map_value ();
       if (mv.isfield ("bkpt") || mv.isfield ("errs") || mv.isfield ("warn")
           || mv.isfield ("intr"))
         {
           bp_table::dbstop_process_map_args (mv);
 
           // Replace mv by "bkpt", to use the processing below.
           octave_value bkpt = mv.getfield ("bkpt");
-          if (bkpt.is_empty ())
+          if (bkpt.isempty ())
             mv = octave_map ();
           else
             {
               if (bkpt.iscell () && bkpt.cell_value ().numel () > 0
                   && bkpt.cell_value () (0).is_map ())
                 mv = bkpt.cell_value () (0).map_value ();
               else
                 {
                   error ("dbstop: invalid 'bkpt' field");
                   mv = octave_map ();
                 }
             }
         }
-      if (mv.is_empty ())
+      if (mv.isempty ())
         {
           // no changes requested.  Occurs if "errs" non-empty but "bkpt" empty
         }
       else if (! mv.isfield ("name") || ! mv.isfield ("line"))
         {
           error ("dbstop: Cell array must contain fields 'name' and 'line'");
           retval = octave_value (0);
         }
@@ -482,17 +482,17 @@ The @qcode{"warn"} field is set similarl
         }
 
       retmap.assign ("name", names);
       retmap.assign ("file", file);
       retmap.assign ("line", line);
       retmap.assign ("cond", cond);
 
       octave_map ew = bp_table::stop_on_err_warn_status (false);
-      if (ew.is_empty ())
+      if (ew.isempty ())
         {
           retval = octave_value (retmap);
         }
       else
         {
           octave_map outer (dim_vector (3,1));
           outer.assign ("bkpt", Cell (retmap));
           for (octave_map::const_iterator f = ew.begin (); f != ew.end (); f++)
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -64,17 +64,17 @@ For that, use any of the condition numbe
 @seealso{cond, condest, rcond}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
-  if (arg.is_empty ())
+  if (arg.isempty ())
     return ovl (1.0);
 
   if (arg.rows () != arg.columns ())
     err_square_matrix_required ("det", "A");
 
   octave_value_list retval (2);
 
   bool isfloat = arg.is_single_type ();
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -103,33 +103,33 @@ The eigenvalues returned by @code{eig} a
     print_usage ();
 
   octave_value_list retval;
 
   octave_value arg_a, arg_b;
 
   arg_a = args(0);
 
-  if (arg_a.is_empty ())
+  if (arg_a.isempty ())
     return octave_value_list (2, Matrix ());
 
   if (! arg_a.is_float_type ())
     err_wrong_type_arg ("eig", arg_a);
 
   if (arg_a.rows () != arg_a.columns ())
     err_square_matrix_required ("eig", "A");
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   if (! AEPcase)
     {
       arg_b = args(1);
 
-      if (arg_b.is_empty ())
+      if (arg_b.isempty ())
         return octave_value_list (2, Matrix ());
 
       if (! arg_b.is_float_type ())
         err_wrong_type_arg ("eig", arg_b);
 
       if (arg_b.rows () != arg_b.columns ())
         err_square_matrix_required ("eig", "B");
     }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -898,17 +898,17 @@ rethrow_error_1 (const char *id, const c
 
 OCTAVE_NORETURN static
 void
 rethrow_error (const std::string& id, const std::string& msg,
                const octave_map& stack)
 {
   octave::execution_exception e = make_execution_exception ("error");
 
-  if (! stack.is_empty ()
+  if (! stack.isempty ()
       && ! (stack.contains ("file") && stack.contains ("name")
             && stack.contains ("line")))
     error ("rethrow: STACK struct must contain the fields 'file', 'name', and 'line'");
 
   Vlast_error_id = id;
   Vlast_error_message = msg;
   Vlast_error_stack = stack;
 
@@ -919,17 +919,17 @@ rethrow_error (const std::string& id, co
     {
       tmp_msg.erase (len - 1);
 
       rethrow_error_1 (id.c_str (), "%s\n", tmp_msg.c_str ());
     }
   else
     rethrow_error_1 (id.c_str (), "%s", tmp_msg.c_str ());
 
-  if (! stack.is_empty ())
+  if (! stack.isempty ())
     {
       std::ostringstream buf;
 
       pr_where (buf, "error", make_stack_frame_list (stack));
 
       e.set_stack_trace (buf.str ());
     }
 
@@ -992,17 +992,17 @@ handle_message (error_fun f, const char 
           if (arg.is_string ())
             {
               tstr = arg.string_value ();
               msg = tstr.c_str ();
 
               if (! msg)
                 return retval;
             }
-          else if (arg.is_empty ())
+          else if (arg.isempty ())
             return retval;
         }
     }
 
 // Ugh.
 
   size_t len = strlen (msg);
 
@@ -1209,17 +1209,17 @@ disable escape sequence expansion use a 
 
   std::string id;
 
   bool have_fmt = false;
 
   if (nargin == 1 && args(0).is_map ())
     {
       // empty struct is not an error.  return and resume calling function.
-      if (args(0).is_empty ())
+      if (args(0).isempty ())
         return retval;
 
       octave_scalar_map m = args(0).scalar_map_value ();
 
       // empty struct is not an error.  return and resume calling function.
       if (m.nfields () == 0)
         return retval;
 
@@ -1901,17 +1901,17 @@ fields are set to their default values.
             {
               const std::string tmp =
                 new_err.getfield ("identifier").string_value ();
               new_error_id = tmp;
             }
 
           if (new_err.contains ("stack"))
             {
-              if (new_err.getfield ("stack").is_empty ())
+              if (new_err.getfield ("stack").isempty ())
                 initialize_stack = true;
               else
                 {
                   new_err_stack =
                     new_err.getfield ("stack").scalar_map_value ();
 
                   if (new_err_stack.contains ("file"))
                     {
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -51,17 +51,17 @@ do_fft (const octave_value_list& args, c
   octave_value arg = args(0);
   octave_idx_type n_points = -1;
   dim_vector dims = arg.dims ();
   int ndims = dims.ndims ();
   int dim = -1;
 
   if (nargin > 1)
     {
-      if (! args(1).is_empty ())
+      if (! args(1).isempty ())
         {
           double dval = args(1).double_value ();
           if (octave::math::isnan (dval))
             error ("%s: number of points (N) cannot be NaN", fcn);
 
           n_points = octave::math::nint_big (dval);
           if (n_points < 0)
             error ("%s: number of points (N) must be greater than zero", fcn);
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -365,17 +365,17 @@ H(z) = ---------------------
       if (isfloat)
         {
           FloatComplexColumnVector b = args(0).xfloat_complex_vector_value (a_b_errmsg);
           FloatComplexColumnVector a = args(1).xfloat_complex_vector_value (a_b_errmsg);
           FloatComplexNDArray x = args(2).xfloat_complex_array_value (x_si_errmsg);
 
           FloatComplexNDArray si;
 
-          if (nargin == 3 || args(3).is_empty ())
+          if (nargin == 3 || args(3).isempty ())
             {
               octave_idx_type a_len = a.numel ();
               octave_idx_type b_len = b.numel ();
 
               octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
               dim_vector si_dims = x.dims ();
               for (int i = dim; i > 0; i--)
@@ -400,17 +400,17 @@ H(z) = ---------------------
         {
           ComplexColumnVector b = args(0).xcomplex_vector_value (a_b_errmsg);
           ComplexColumnVector a = args(1).xcomplex_vector_value (a_b_errmsg);
 
           ComplexNDArray x = args(2).xcomplex_array_value (x_si_errmsg);
 
           ComplexNDArray si;
 
-          if (nargin == 3 || args(3).is_empty ())
+          if (nargin == 3 || args(3).isempty ())
             {
               octave_idx_type a_len = a.numel ();
               octave_idx_type b_len = b.numel ();
 
               octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
               dim_vector si_dims = x.dims ();
               for (int i = dim; i > 0; i--)
@@ -438,17 +438,17 @@ H(z) = ---------------------
         {
           FloatColumnVector b = args(0).xfloat_vector_value (a_b_errmsg);
           FloatColumnVector a = args(1).xfloat_vector_value (a_b_errmsg);
 
           FloatNDArray x = args(2).xfloat_array_value (x_si_errmsg);
 
           FloatNDArray si;
 
-          if (nargin == 3 || args(3).is_empty ())
+          if (nargin == 3 || args(3).isempty ())
             {
               octave_idx_type a_len = a.numel ();
               octave_idx_type b_len = b.numel ();
 
               octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
               dim_vector si_dims = x.dims ();
               for (int i = dim; i > 0; i--)
@@ -473,17 +473,17 @@ H(z) = ---------------------
         {
           ColumnVector b = args(0).xvector_value (a_b_errmsg);
           ColumnVector a = args(1).xvector_value (a_b_errmsg);
 
           NDArray x = args(2).xarray_value (x_si_errmsg);
 
           NDArray si;
 
-          if (nargin == 3 || args(3).is_empty ())
+          if (nargin == 3 || args(3).isempty ())
             {
               octave_idx_type a_len = a.numel ();
               octave_idx_type b_len = b.numel ();
 
               octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
 
               dim_vector si_dims = x.dims ();
               for (int i = dim; i > 0; i--)
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -44,17 +44,17 @@ find_nonzero_elem_idx (const Array<T>& n
 
   Array<octave_idx_type> idx;
   if (n_to_find >= 0)
     idx = nda.find (n_to_find, direction == -1);
   else
     idx = nda.find ();
 
   // The maximum element is always at the end.
-  octave_idx_type iext = (idx.is_empty () ? 0 : idx.xelem (idx.numel () - 1) + 1);
+  octave_idx_type iext = (idx.isempty () ? 0 : idx.xelem (idx.numel () - 1) + 1);
 
   switch (nargout)
     {
     default:
     case 3:
       retval(2) = Array<T> (nda.index (idx_vector (idx)));
       // Fall through!
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -568,17 +568,17 @@ namespace octave
         }
         break;
       }
   }
 
   int
   ft_text_renderer::compute_line_xoffset (const Matrix& lb) const
   {
-    if (! bbox.is_empty ())
+    if (! bbox.isempty ())
       {
         switch (halign)
           {
           case 0:
             return 0;
           case 1:
             return (bbox(2) - lb(2)) / 2;
           case 2:
@@ -604,17 +604,17 @@ namespace octave
 
       case 1:
         bbox = line_bbox.front ().extract (0, 0, 0, 3);
         break;
 
       default:
         for (const auto& lbox : line_bbox)
           {
-            if (bbox.is_empty ())
+            if (bbox.isempty ())
               bbox = lbox.extract (0, 0, 0, 3);
             else
               {
                 bbox(1) -= lbox(3);
                 bbox(3) += lbox(3);
                 bbox(2) = octave::math::max (bbox(2), lbox(2));
               }
           }
@@ -1251,17 +1251,17 @@ namespace octave
     int rot_mode = rotation_to_mode (rotation);
 
     halign = _halign;
 
     text_element *elt = text_parser::parse (txt, interpreter);
     pxls = render (elt, box, rot_mode);
     delete elt;
 
-    if (pxls.is_empty ())
+    if (pxls.isempty ())
       return;  // nothing to render
 
     switch (halign)
       {
       case 1:
         box(0) = -box(2)/2;
         break;
 
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1178,17 +1178,17 @@ namespace octave
   }
 
   void
   opengl_renderer::draw_axes_planes (const axes::properties& props)
   {
 #if defined (HAVE_OPENGL)
 
     Matrix axe_color = props.get_color_rgb ();
-    if (axe_color.is_empty () || ! props.is_visible ())
+    if (axe_color.isempty () || ! props.is_visible ())
       return;
 
     double xPlane = props.get_xPlane ();
     double yPlane = props.get_yPlane ();
     double zPlane = props.get_zPlane ();
     double xPlaneN = props.get_xPlaneN ();
     double yPlaneN = props.get_yPlaneN ();
     double zPlaneN = props.get_zPlaneN ();
@@ -2825,29 +2825,29 @@ namespace octave
 
         bool do_edge = ! props.markeredgecolor_is ("none");
         bool do_face = ! props.markerfacecolor_is ("none");
 
         Matrix mecolor = props.get_markeredgecolor_rgb ();
         Matrix mfcolor = props.get_markerfacecolor_rgb ();
         Matrix cc (1, 3, 0.0);
 
-        if (mecolor.is_empty () && props.markeredgecolor_is ("auto"))
+        if (mecolor.isempty () && props.markeredgecolor_is ("auto"))
           {
             mecolor = props.get_edgecolor_rgb ();
             do_edge = ! props.edgecolor_is ("none");
           }
 
-        if (mfcolor.is_empty () && props.markerfacecolor_is ("auto"))
+        if (mfcolor.isempty () && props.markerfacecolor_is ("auto"))
           {
             mfcolor = props.get_facecolor_rgb ();
             do_face = ! props.facecolor_is ("none");
           }
 
-        if ((mecolor.is_empty () || mfcolor.is_empty ()) && c.is_empty ())
+        if ((mecolor.isempty () || mfcolor.isempty ()) && c.isempty ())
           c = props.get_color_data ().array_value ();
 
         init_marker (props.get_marker (), props.get_markersize (),
                      props.get_linewidth ());
 
         for (int i = 0; i < zc; i++)
           {
             if (y_mat)
@@ -2856,29 +2856,29 @@ namespace octave
             for (int j = 0; j < zr; j++)
               {
                 if (clip(j,i))
                   continue;
 
                 if (x_mat)
                   j1 = j;
 
-                if ((do_edge && mecolor.is_empty ())
-                    || (do_face && mfcolor.is_empty ()))
+                if ((do_edge && mecolor.isempty ())
+                    || (do_face && mfcolor.isempty ()))
                   {
                     if (! octave::math::isfinite (c(j,i)))
                       continue;  // Skip NaNs in color data
 
                     for (int k = 0; k < 3; k++)
                       cc(k) = c(j,i,k);
                   }
 
-                Matrix lc = (do_edge ? (mecolor.is_empty () ? cc : mecolor)
+                Matrix lc = (do_edge ? (mecolor.isempty () ? cc : mecolor)
                                      : Matrix ());
-                Matrix fc = (do_face ? (mfcolor.is_empty () ? cc : mfcolor)
+                Matrix fc = (do_face ? (mfcolor.isempty () ? cc : mfcolor)
                                      : Matrix ());
 
                 draw_marker (x(j1,i), y(j,i1), z(j,i), lc, fc);
               }
           }
 
         end_marker ();
       }
@@ -3295,33 +3295,33 @@ namespace octave
         bool do_edge = ! props.markeredgecolor_is ("none");
         bool do_face = ! props.markerfacecolor_is ("none");
 
         Matrix mecolor = props.get_markeredgecolor_rgb ();
         Matrix mfcolor = props.get_markerfacecolor_rgb ();
 
         bool has_markerfacecolor = false;
 
-        if ((mecolor.is_empty () && ! props.markeredgecolor_is ("none"))
-            || (mfcolor.is_empty () && ! props.markerfacecolor_is ("none")))
+        if ((mecolor.isempty () && ! props.markeredgecolor_is ("none"))
+            || (mfcolor.isempty () && ! props.markerfacecolor_is ("none")))
           {
             Matrix mc = props.get_color_data ().matrix_value ();
 
             if (mc.rows () == 1)
               {
                 // Single color specifications, we can simplify a little bit
-                if (mfcolor.is_empty () && ! props.markerfacecolor_is ("none"))
+                if (mfcolor.isempty () && ! props.markerfacecolor_is ("none"))
                   mfcolor = mc;
 
-                if (mecolor.is_empty () && ! props.markeredgecolor_is ("none"))
+                if (mecolor.isempty () && ! props.markeredgecolor_is ("none"))
                   mecolor = mc;
               }
             else
               {
-                if (c.is_empty ())
+                if (c.isempty ())
                   c = props.get_color_data ().matrix_value ();
                 has_markerfacecolor = ((c.numel () > 0)
                                        && (c.rows () == f.rows ()));
               }
           }
 
         init_marker (props.get_marker (), props.get_markersize (),
                      props.get_linewidth ());
@@ -3339,19 +3339,19 @@ namespace octave
                 {
                   cc.resize (1, 3);
                   if (has_markerfacecolor)
                     cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
                   else
                     cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
                 }
 
-              Matrix lc = (do_edge ? (mecolor.is_empty () ? cc : mecolor)
+              Matrix lc = (do_edge ? (mecolor.isempty () ? cc : mecolor)
                                    : Matrix ());
-              Matrix fc = (do_face ? (mfcolor.is_empty () ? cc : mfcolor)
+              Matrix fc = (do_face ? (mfcolor.isempty () ? cc : mfcolor)
                                    : Matrix ());
 
               draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
             }
 
         end_marker ();
       }
 
@@ -3410,17 +3410,17 @@ namespace octave
     draw (props.get_children ());
   }
 
   void
   opengl_renderer::draw_text (const text::properties& props)
   {
 #if defined (HAVE_OPENGL)
 
-    if (props.get_string ().is_empty ())
+    if (props.get_string ().isempty ())
       return;
 
     set_font (props);
 
     Matrix pos = xform.scale (props.get_data_position ());
     const Matrix bbox = props.get_extent_matrix ();
 
     // FIXME: handle margin and surrounding box
@@ -3457,17 +3457,17 @@ namespace octave
     dim_vector dv (cdata.dims ());
     int h = dv(0);
     int w = dv(1);
 
     Matrix x = props.get_xdata ().matrix_value ();
     Matrix y = props.get_ydata ().matrix_value ();
 
     // Someone wants us to draw an empty image?  No way.
-    if (x.is_empty () || y.is_empty ())
+    if (x.isempty () || y.isempty ())
       return;
 
     if (w > 1 && x(1) == x(0))
       x(1) = x(1) + (w-1);
 
     if (h > 1 && y(1) == y(0))
       y(1) = y(1) + (h-1);
 
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -768,17 +768,17 @@ namespace octave
       tmp_data[i] = data[i] / maxval;
 
     draw_pixels (w, h, tmp_data);
   }
 
   void
   gl2ps_renderer::draw_text (const text::properties& props)
   {
-    if (props.get_string ().is_empty ())
+    if (props.get_string ().isempty ())
       return;
 
     // First set font properties: freetype will use them to compute
     // coordinates and gl2ps will retrieve the color directly from the
     // feedback buffer
     set_font (props);
     set_color (props.get_color_rgb ());
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1447,17 +1447,17 @@ array_property::validate (const octave_v
 
               for (int i = 0; xok && i < vlen; i++)
                 {
                   if (itdims(i) > 0)
                     {
                       if (itdims(i) != vdims(i))
                         xok = false;
                     }
-                  else if (v.is_empty ())
+                  else if (v.isempty ())
                     break;
                 }
             }
         }
     }
 
   if (xok)
     {
@@ -1570,17 +1570,17 @@ array_property::is_equal (const octave_v
 }
 
 void
 array_property::get_data_limits (void)
 {
   xmin = xminp = octave::numeric_limits<double>::Inf ();
   xmax = xmaxp = -octave::numeric_limits<double>::Inf ();
 
-  if (! data.is_empty ())
+  if (! data.isempty ())
     {
       if (data.is_integer_type ())
         {
           if (data.is_int8_type ())
             get_array_limits (data.int8_array_value (),
                               xmin, xmax, xminp, xmaxp);
           else if (data.is_uint8_type ())
             get_array_limits (data.uint8_array_value (),
@@ -1608,19 +1608,19 @@ array_property::get_data_limits (void)
         get_array_limits (data.array_value (), xmin, xmax, xminp, xmaxp);
     }
 }
 
 bool
 handle_property::do_set (const octave_value& v)
 {
   // Users may want to use empty matrix to reset a handle property
-  if (v.is_empty ())
-    {
-      if (! get ().is_empty ())
+  if (v.isempty ())
+    {
+      if (! get ().isempty ())
         {
           current_val = graphics_handle ();
           return true;
         }
       else
         return false;
     }
 
@@ -1737,17 +1737,17 @@ bool
 callback_property::validate (const octave_value& v) const
 {
   // case 1: empty matrix
   // case 2: function handle
   // case 3: string corresponding to known function name
   // case 4: string that can be eval()'ed
   // case 5: cell array with first element being a function handle
 
-  if (v.is_empty ())
+  if (v.isempty ())
     return true;
   else if (v.is_function_handle ())
     return true;
   else if (v.is_string ())
     // complete validation will be done at execution-time
     return true;
   else if (v.iscell () && (v.rows () == 1 || v.columns () == 1)
            && v.cell_value ()(0).is_function_handle ())
@@ -1774,17 +1774,17 @@ callback_property::execute (const octave
   // their handlevisibility property set to "callback" to be visible.
   frame.protect_var (executing_callback);
 
   if (! executing)
     {
       executing = true;
       executing_callback = true;
 
-      if (callback.is_defined () && ! callback.is_empty ())
+      if (callback.is_defined () && ! callback.isempty ())
         gh_manager::execute_callback (get_parent (), callback, data);
     }
 }
 
 // Used to cache dummy graphics objects from which dynamic properties can be
 // cloned.
 static std::map<caseless_str, graphics_object> dprop_obj_map;
 
@@ -1857,17 +1857,17 @@ property::create (const std::string& nam
       color_values cv (0, 0, 0);
       radio_values rv;
 
       if (args.length () > 1)
         rv = radio_values (args(1).string_value ());
 
       retval = property (new color_property (name, h, cv, rv));
 
-      if (args.length () > 0 && ! args(0).is_empty ())
+      if (args.length () > 0 && ! args(0).isempty ())
         retval.set (args(0));
       else
         retval.set (rv.default_value ());
     }
   else
     {
       caseless_str go_name, go_rest;
 
@@ -2712,27 +2712,27 @@ reparent (const octave_value& ov, const 
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
   octave_value val = xget (0, "currentfigure");
 
-  return val.is_empty () ? octave::numeric_limits<double>::NaN ()
+  return val.isempty () ? octave::numeric_limits<double>::NaN ()
                          : val.double_value ();
 }
 
 // This function is NOT equivalent to the scripting language function gca.
 graphics_handle
 gca (void)
 {
   octave_value val = xget (gcf (), "currentaxes");
 
-  return val.is_empty () ? octave::numeric_limits<double>::NaN ()
+  return val.isempty () ? octave::numeric_limits<double>::NaN ()
                          : val.double_value ();
 }
 
 static void
 delete_graphics_object (const graphics_handle& h)
 {
   if (h.ok ())
     {
@@ -3202,17 +3202,17 @@ base_properties::update_axis_limits (con
 
   if (go)
     go.update_axis_limits (axis_type, h);
 }
 
 void
 base_properties::update_uicontextmenu (void) const
 {
-  if (uicontextmenu.get ().is_empty ())
+  if (uicontextmenu.get ().isempty ())
     return;
 
   graphics_object go = gh_manager::get_object (uicontextmenu.get ());
   if (go && go.isa ("uicontextmenu"))
     {
       uicontextmenu::properties& props =
         reinterpret_cast<uicontextmenu::properties&> (go.get_properties ());
       props.add_dependent_obj (__myhandle__);
@@ -5188,17 +5188,17 @@ axes::properties::set_defaults (base_gra
   update_transform ();
   sync_positions ();
   override_defaults (bgo);
 }
 
 octave_value
 axes::properties::get_colormap (void) const
 {
-  if (__colormap__.get ().is_empty ())
+  if (__colormap__.get ().isempty ())
     {
       graphics_object go (gh_manager::get_object (get___myhandle__ ()));
       graphics_object go_f (go.get_ancestor ("figure"));
       figure::properties& figure_props
         = reinterpret_cast<figure::properties&> (go_f.get_properties ());
       return figure_props.get_colormap ();
     }
 
@@ -5906,23 +5906,23 @@ axes::properties::update_xlabel_position
   graphics_object go = gh_manager::get_object (get_xlabel ());
 
   if (! go.valid_object ())
     return;
 
   text::properties& xlabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
-  bool is_empty = xlabel_props.get_string ().is_empty ();
+  bool isempty = xlabel_props.get_string ().isempty ();
 
   octave::unwind_protect frame;
   frame.protect_var (updating_xlabel_position);
   updating_xlabel_position = true;
 
-  if (! is_empty)
+  if (! isempty)
     {
       if (xlabel_props.horizontalalignmentmode_is ("auto"))
         {
           xlabel_props.set_horizontalalignment
             (xstate > AXE_DEPTH_DIR ? "center" : (xyzSym ? "left" : "right"));
 
           xlabel_props.set_horizontalalignmentmode ("auto");
         }
@@ -5983,17 +5983,17 @@ axes::properties::update_xlabel_position
 
           p = convert_label_position (p, xlabel_props, xform,
                                       get_extent (false));
 
           xlabel_props.set_position (p.extract_n (0, 3).transpose ());
           xlabel_props.set_positionmode ("auto");
         }
 
-      if (! is_empty && xlabel_props.rotationmode_is ("auto"))
+      if (! isempty && xlabel_props.rotationmode_is ("auto"))
         {
           xlabel_props.set_rotation (angle);
           xlabel_props.set_rotationmode ("auto");
         }
     }
 }
 
 static bool updating_ylabel_position = false;
@@ -6007,23 +6007,23 @@ axes::properties::update_ylabel_position
   graphics_object go = gh_manager::get_object (get_ylabel ());
 
   if (! go.valid_object ())
     return;
 
   text::properties& ylabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
-  bool is_empty = ylabel_props.get_string ().is_empty ();
+  bool isempty = ylabel_props.get_string ().isempty ();
 
   octave::unwind_protect frame;
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
-  if (! is_empty)
+  if (! isempty)
     {
       if (ylabel_props.horizontalalignmentmode_is ("auto"))
         {
           ylabel_props.set_horizontalalignment
             (ystate > AXE_DEPTH_DIR ? "center" : (! xyzSym ? "left" : "right"));
 
           ylabel_props.set_horizontalalignmentmode ("auto");
         }
@@ -6093,17 +6093,17 @@ axes::properties::update_ylabel_position
 
           p = convert_label_position (p, ylabel_props, xform,
                                       get_extent (false));
 
           ylabel_props.set_position (p.extract_n (0, 3).transpose ());
           ylabel_props.set_positionmode ("auto");
         }
 
-      if (! is_empty && ylabel_props.rotationmode_is ("auto"))
+      if (! isempty && ylabel_props.rotationmode_is ("auto"))
         {
           ylabel_props.set_rotation (angle);
           ylabel_props.set_rotationmode ("auto");
         }
     }
 }
 
 static bool updating_zlabel_position = false;
@@ -6118,23 +6118,23 @@ axes::properties::update_zlabel_position
 
   if (! go.valid_object ())
     return;
 
   text::properties& zlabel_props
     = reinterpret_cast<text::properties&> (go.get_properties ());
 
   bool camAuto = cameraupvectormode_is ("auto");
-  bool is_empty = zlabel_props.get_string ().is_empty ();
+  bool isempty = zlabel_props.get_string ().isempty ();
 
   octave::unwind_protect frame;
   frame.protect_var (updating_zlabel_position);
   updating_zlabel_position = true;
 
-  if (! is_empty)
+  if (! isempty)
     {
       if (zlabel_props.horizontalalignmentmode_is ("auto"))
         {
           zlabel_props.set_horizontalalignment
             ((zstate > AXE_DEPTH_DIR || camAuto) ? "center" : "right");
 
           zlabel_props.set_horizontalalignmentmode ("auto");
         }
@@ -6217,17 +6217,17 @@ axes::properties::update_zlabel_position
 
           p = convert_label_position (p, zlabel_props, xform,
                                       get_extent (false));
 
           zlabel_props.set_position (p.extract_n (0, 3).transpose ());
           zlabel_props.set_positionmode ("auto");
         }
 
-      if (! is_empty && zlabel_props.rotationmode_is ("auto"))
+      if (! isempty && zlabel_props.rotationmode_is ("auto"))
         {
           zlabel_props.set_rotation (angle);
           zlabel_props.set_rotationmode ("auto");
         }
     }
 }
 
 static bool updating_title_position = false;
@@ -6489,17 +6489,17 @@ axes::properties::update_font (std::stri
 Matrix
 axes::properties::get_boundingbox (bool internal,
                                    const Matrix& parent_pix_size) const
 {
   Matrix pos = (internal ? get_position ().matrix_value ()
                          : get_outerposition ().matrix_value ());
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.is_empty ())
+  if (parent_size.isempty ())
     {
       graphics_object go = gh_manager::get_object (get_parent ());
 
       if (go.valid_object ())
         parent_size =
           go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
       else
         parent_size = default_figure_position ();
@@ -6550,17 +6550,17 @@ axes::properties::get_extent (bool with_
             htext = get_zlabel ();
 
           text::properties& text_props
             = reinterpret_cast<text::properties&>
                 (gh_manager::get_object (htext).get_properties ());
 
           Matrix text_pos = text_props.get_data_position ();
           text_pos = xform.transform (text_pos(0), text_pos(1), text_pos(2));
-          if (text_props.get_string ().is_empty ())
+          if (text_props.get_string ().isempty ())
             {
               ext(0) = std::min (ext(0), text_pos(0));
               ext(1) = std::min (ext(1), text_pos(1));
               ext(2) = std::max (ext(2), text_pos(0));
               ext(3) = std::max (ext(3), text_pos(1));
             }
           else
             {
@@ -7086,17 +7086,17 @@ axes::properties::calc_ticks_and_lims (a
                                        array_property& ticks,
                                        array_property& mticks,
                                        bool limmode_is_auto,
                                        bool tickmode_is_auto,
                                        bool is_logscale)
 {
   // FIXME: add log ticks and lims
 
-  if (lims.get ().is_empty ())
+  if (lims.get ().isempty ())
     return;
 
   double lo = (lims.get ().matrix_value ())(0);
   double hi = (lims.get ().matrix_value ())(1);
   bool is_negative = lo < 0 && hi < 0;
 
   // FIXME: should this be checked for somewhere else? (i.e., set{x,y,z}lim)
   if (hi < lo)
@@ -8464,17 +8464,17 @@ image::properties::get_color_data (void)
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 patch::properties::get_color_data (void) const
 {
   octave_value fvc = get_facevertexcdata ();
-  if (fvc.is_undefined () || fvc.is_empty ())
+  if (fvc.is_undefined () || fvc.isempty ())
     return Matrix ();
   else
     return convert_cdata (*this, fvc, cdatamapping_is ("scaled"), 2);
 }
 
 static bool updating_patch_data = false;
 
 void
@@ -8485,17 +8485,17 @@ patch::properties::update_fvc (void)
 
   Matrix xd = get_xdata ().matrix_value ();
   Matrix yd = get_ydata ().matrix_value ();
   Matrix zd = get_zdata ().matrix_value ();
   NDArray cd = get_cdata ().array_value ();
 
   bad_data_msg = "";
   if (xd.dims () != yd.dims ()
-      || (xd.dims () != zd.dims () && ! zd.is_empty ()))
+      || (xd.dims () != zd.dims () && ! zd.isempty ()))
     {
       bad_data_msg = "x/y/zdata must have the same dimensions";
       return;
     }
 
   // Faces and Vertices
   dim_vector dv;
   bool is3D = false;
@@ -8506,17 +8506,17 @@ patch::properties::update_fvc (void)
       nr = nc;
       nc = 1;
       xd = xd.as_column ();
       yd = yd.as_column ();
       zd = zd.as_column ();
     }
 
   dv(0) = nr * nc;
-  if (zd.is_empty ())
+  if (zd.isempty ())
     dv(1) = 2;
   else
     {
       dv(1) = 3;
       is3D = true;
     }
 
   Matrix vert (dv);
@@ -8610,17 +8610,17 @@ patch::properties::update_data (void)
     {
       dv(0) = 1;
       dv(1) = fvc.rows ();
       dv(2) = fvc.columns ();
       cd = fvc.reshape (dv);
     }
   else
     {
-      if (! fvc.is_empty ())
+      if (! fvc.isempty ())
         {
           dv(0) = idx.rows ();
           dv(1) = nfaces;
           dv(2) = fvc.columns ();
           cd.resize (dv);
           pervertex = true;
         }
     }
@@ -9109,17 +9109,17 @@ uicontrol::properties::update_units (voi
   set_position (pos);
 
   cached_units = get_units ();
 }
 
 void
 uicontrol::properties::set_style (const octave_value& st)
 {
-  if (! get___object__ ().is_empty ())
+  if (! get___object__ ().isempty ())
     error ("set: cannot change the style of a uicontrol object after creation.");
 
   style = st;
 
   // if we know know what we are, can override value for listbox and popupmenu
   if (style_is ("listbox") || style_is ("popupmenu"))
     {
       Matrix v = value.get ().matrix_value ();
@@ -9130,17 +9130,17 @@ uicontrol::properties::set_style (const 
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.is_empty ())
+  if (parent_size.isempty ())
     {
       graphics_object go = gh_manager::get_object (get_parent ());
 
       if (go.valid_object ())
         parent_size =
           go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
       else
         parent_size = default_figure_position ();
@@ -9195,17 +9195,17 @@ uicontrol::properties::get___fontsize_po
 
 Matrix
 uibuttongroup::properties::get_boundingbox (bool internal,
                                             const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.is_empty ())
+  if (parent_size.isempty ())
     {
       graphics_object go = gh_manager::get_object (get_parent ());
 
       parent_size =
         go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
@@ -9323,17 +9323,17 @@ uibuttongroup::properties::get___fontsiz
   return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 void
 uibuttongroup::properties::set_selectedobject (const octave_value& v)
 {
   graphics_handle current_selectedobject = get_selectedobject();
   selectedobject = current_selectedobject;
-  if (v.is_empty ())
+  if (v.isempty ())
     {
       if (current_selectedobject.ok ())
         {
           selectedobject = graphics_handle ();
           mark_modified ();
         }
       return;
     }
@@ -9366,17 +9366,17 @@ uibuttongroup::properties::set_selectedo
 
 Matrix
 uipanel::properties::get_boundingbox (bool internal,
                                       const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
-  if (parent_size.is_empty ())
+  if (parent_size.isempty ())
     {
       graphics_object go = gh_manager::get_object (get_parent ());
 
       parent_size =
         go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
@@ -9847,17 +9847,17 @@ gh_manager::do_execute_listener (const g
     }
 }
 
 void
 gh_manager::do_execute_callback (const graphics_handle& h,
                                  const octave_value& cb_arg,
                                  const octave_value& data)
 {
-  if (cb_arg.is_defined () && ! cb_arg.is_empty ())
+  if (cb_arg.is_defined () && ! cb_arg.isempty ())
     {
       octave_value_list args;
       octave_function *fcn = nullptr;
 
       args(0) = h.as_octave_value ();
       if (data.is_defined ())
         args(1) = data;
       else
@@ -10529,17 +10529,17 @@ lists respectively.
 {
   gh_manager::auto_lock guard;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  if (args(0).is_empty ())
+  if (args(0).isempty ())
     return ovl (Matrix ());
 
   ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
   octave_idx_type hcv_len = hcv.numel ();
 
   if (nargin == 1 && hcv_len > 1)
     {
@@ -10844,17 +10844,17 @@ Undocumented internal function.
 int
 calc_dimensions (const graphics_object& go)
 {
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
   else if ((go.isa ("line") || go.isa ("patch"))
-           && ! go.get ("zdata").is_empty ())
+           && ! go.get ("zdata").isempty ())
     nd = 3;
   else
     {
       Matrix kids = go.get_properties ().get_children ();
 
       for (octave_idx_type i = 0; i < kids.numel (); i++)
         {
           graphics_handle hkid = gh_manager::lookup (kids(i));
@@ -11843,17 +11843,17 @@ To define a condition on a property name
 In all cases, typing CTRL-C stops program execution immediately.
 @seealso{waitforbuttonpress, isequal}
 @end deftypefn */)
 {
   if (args.length () == 0)
     print_usage ();
 
   // return immediately if the graphics handle is invalid
-  if (args(0).is_empty ())
+  if (args(0).isempty ())
     return ovl ();
 
   double h = args(0).xdouble_value ("waitfor: invalid handle value");
 
   caseless_str pname;
 
   octave::unwind_protect frame;
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -716,17 +716,17 @@ public:
 
   text_label_property (const text_label_property& p)
     : base_property (p), value (p.value), stored_type (p.stored_type)
   { }
 
   bool empty (void) const
   {
     octave_value tmp = get ();
-    return tmp.is_empty ();
+    return tmp.isempty ();
   }
 
   octave_value get (void) const
   {
     if (stored_type == char_t)
       return octave_value (char_value ());
     else
       return octave_value (cell_value ());
@@ -1897,17 +1897,17 @@ public:
     : base_property (p), callback (p.callback), executing (false) { }
 
   octave_value get (void) const { return callback; }
 
   OCTINTERP_API void execute (const octave_value& data = octave_value ()) const;
 
   bool is_defined (void) const
   {
-    return (callback.is_defined () && ! callback.is_empty ());
+    return (callback.is_defined () && ! callback.isempty ());
   }
 
   callback_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
@@ -4424,17 +4424,17 @@ public:
                           const int other_axislocation,
                           const array_property& axis_lims);
     Matrix get_ticklabel_extents (const Matrix& ticks,
                                   const string_vector& ticklabels,
                                   const Matrix& limits);
 
     void fix_limits (array_property& lims)
     {
-      if (lims.get ().is_empty ())
+      if (lims.get ().isempty ())
         return;
 
       Matrix l = lims.get ().matrix_value ();
       if (l(0) > l(1))
         {
           l(0) = 0;
           l(1) = 1;
           lims = l;
@@ -4974,17 +4974,17 @@ public:
         update_xdata ();
 
       if (ydatamode.is ("auto"))
         update_ydata ();
     }
 
     void update_xdata (void)
     {
-      if (xdata.get ().is_empty ())
+      if (xdata.get ().isempty ())
         set_xdatamode ("auto");
 
       if (xdatamode.is ("auto"))
         {
           set_xdata (get_auto_xdata ());
           set_xdatamode ("auto");
         }
 
@@ -4993,17 +4993,17 @@ public:
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
       set_xlim (limits);
     }
 
     void update_ydata (void)
     {
-      if (ydata.get ().is_empty ())
+      if (ydata.get ().isempty ())
         set_ydatamode ("auto");
 
       if (ydatamode.is ("auto"))
         {
           set_ydata (get_auto_ydata ());
           set_ydatamode ("auto");
         }
 
@@ -5268,17 +5268,17 @@ public:
     void update_vertices (void)  { update_data ();}
 
     void update_facevertexcdata (void) { update_data ();}
 
     void update_fvc (void);
 
     void update_xdata (void)
     {
-      if (get_xdata ().is_empty ())
+      if (get_xdata ().isempty ())
         {
           // For compatibility with matlab behavior,
           // if x/ydata are set empty, silently empty other *data and
           // faces properties while vertices remain unchanged.
           set_ydata (Matrix ());
           set_zdata (Matrix ());
           set_cdata (Matrix ());
           set_faces (Matrix ());
@@ -5286,17 +5286,17 @@ public:
       else
         update_fvc ();
 
       set_xlim (xdata.get_limits ());
     }
 
     void update_ydata (void)
     {
-      if (get_ydata ().is_empty ())
+      if (get_ydata ().isempty ())
         {
           set_xdata (Matrix ());
           set_zdata (Matrix ());
           set_cdata (Matrix ());
           set_faces (Matrix ());
         }
       else
         update_fvc ();
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -60,17 +60,17 @@ IEEE Transactions on Automatic Control, 
 @seealso{eig, chol, lu, qr, qz, schur, svd}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
-  if (arg.is_empty ())
+  if (arg.isempty ())
     return octave_value_list (2, Matrix ());
 
   if (arg.rows () != arg.columns ())
     err_square_matrix_required ("hess", "A");
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -57,17 +57,17 @@ sparse matrix if possible.
 @seealso{ldivide, rdivide}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
-  if (arg.is_empty ())
+  if (arg.isempty ())
     return ovl (Matrix ());
 
   if (arg.rows () != arg.columns ())
     err_square_matrix_required ("inverse", "A");
 
   octave_value result;
   octave_idx_type info;
   double rcond = 0.0;
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -88,17 +88,17 @@ lsode_user_function (const ColumnVector&
       if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
         {
           warning ("lsode: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).xvector_value ("lsode: expecting user supplied function to return numeric vector");
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 Matrix
 lsode_user_jacobian (const ColumnVector& x, double t)
@@ -128,17 +128,17 @@ lsode_user_jacobian (const ColumnVector&
       if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
           warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).xmatrix_value ("lsode: expecting user supplied jacobian function to return numeric array");
 
-      if (retval.is_empty ())
+      if (retval.isempty ())
         err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 DEFUN (lsode, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -182,17 +182,17 @@ permutation information.
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (issparse)
     {
-      if (arg.is_empty ())
+      if (arg.isempty ())
         return octave_value_list (5, SparseMatrix ());
 
       if (arg.is_real_type ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
           if (nargout < 4)
             {
@@ -322,17 +322,17 @@ permutation information.
             }
 
         }
       else
         err_wrong_type_arg ("lu", arg);
     }
   else
     {
-      if (arg.is_empty ())
+      if (arg.isempty ())
         return octave_value_list (3, Matrix ());
 
       if (arg.is_real_type ())
         {
           if (arg.is_single_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -117,17 +117,17 @@ do_minmax_red_op<boolNDArray> (const oct
 
   if (! arg.is_sparse_type ())
     {
       if (nargout <= 1)
         {
           // This case can be handled using any/all.
           boolNDArray array = arg.bool_array_value ();
 
-          if (array.is_empty ())
+          if (array.isempty ())
             retval(0) = array;
           else if (ismin)
             retval(0) = array.all (dim);
           else
             retval(0) = array.any (dim);
         }
       else
         {
@@ -251,17 +251,17 @@ do_minmax_body (const octave_value_list&
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
 
           if (dim < 0)
             error ("%s: DIM must be a valid dimension", func);
 
-          if (! args(1).is_empty ())
+          if (! args(1).isempty ())
             warning ("%s: second argument is ignored", func);
         }
 
       switch (arg.builtin_type ())
         {
         case btyp_double:
           {
             if (arg.is_range () && (dim == -1 || dim == 1))
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -308,17 +308,17 @@ public:
   {
     request_mutation ();
 
     return 0;
   }
 
   mwSize get_number_of_elements (void) const { return val.numel (); }
 
-  int is_empty (void) const { return val.is_empty (); }
+  int isempty (void) const { return val.isempty (); }
 
   bool is_scalar (void) const
   {
     // Force dims and ndims to be cached.
     get_dimensions ();
 
     return ndims == 2 && dims[0] == 1 && dims[1] == 1;
   }
@@ -814,17 +814,17 @@ public:
     mwSize retval = dims[0];
 
     for (mwIndex i = 1; i < ndims; i++)
       retval *= dims[i];
 
     return retval;
   }
 
-  int is_empty (void) const { return get_number_of_elements () == 0; }
+  int isempty (void) const { return get_number_of_elements () == 0; }
 
   bool is_scalar (void) const
   {
     return ndims == 2 && dims[0] == 1 && dims[1] == 1;
   }
 
   mxClassID get_class_id (void) const { return id; }
 
@@ -2784,17 +2784,17 @@ mxIsLogicalScalarTrue (const mxArray *pt
 {
   return ptr->is_logical_scalar_true ();
 }
 
 // Size predicate.
 bool
 mxIsEmpty (const mxArray *ptr)
 {
-  return ptr->is_empty ();
+  return ptr->isempty ();
 }
 
 bool
 mxIsScalar (const mxArray *ptr)
 {
   return ptr->is_scalar ();
 }
 
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -209,17 +209,17 @@ public:
   virtual void set_m (mwSize m) = 0;
 
   virtual void set_n (mwSize n) = 0;
 
   virtual int set_dimensions (mwSize *dims_arg, mwSize ndims_arg) = 0;
 
   virtual mwSize get_number_of_elements (void) const = 0;
 
-  virtual int is_empty (void) const = 0;
+  virtual int isempty (void) const = 0;
 
   virtual bool is_scalar (void) const = 0;
 
   virtual mxClassID get_class_id (void) const = 0;
 
   virtual const char * get_class_name (void) const = 0;
 
   virtual void set_class_name (const char *name_arg) = 0;
@@ -425,17 +425,17 @@ public:
   void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
 
   int set_dimensions (mwSize *dims_arg, mwSize ndims_arg)
   { DO_MUTABLE_METHOD (int, set_dimensions (dims_arg, ndims_arg)); }
 
   mwSize get_number_of_elements (void) const
   { return rep->get_number_of_elements (); }
 
-  int is_empty (void) const { return get_number_of_elements () == 0; }
+  int isempty (void) const { return get_number_of_elements () == 0; }
 
   bool is_scalar (void) const { return rep->is_scalar (); }
 
   const char * get_name (void) const { return name; }
 
   void set_name (const char *name_arg);
 
   mxClassID get_class_id (void) const { return rep->get_class_id (); }
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 class octave_handle
 {
 public:
   octave_handle (void) : val (octave::numeric_limits<double>::NaN ()) { }
 
   octave_handle (const octave_value& a)
     : val (octave::numeric_limits<double>::NaN ())
   {
-    if (a.is_empty ())
+    if (a.isempty ())
       ; // do nothing
     else
       {
         try
           {
             val = a.double_value ();
           }
         catch (octave::execution_exception& e)
diff --git a/libinterp/corefcn/oct-lvalue.cc b/libinterp/corefcn/oct-lvalue.cc
--- a/libinterp/corefcn/oct-lvalue.cc
+++ b/libinterp/corefcn/oct-lvalue.cc
@@ -56,17 +56,17 @@ bool
 octave_lvalue::index_is_empty (void) const
 {
   bool retval = false;
 
   if (idx.size () == 1)
     {
       octave_value_list tmp = idx.front ();
 
-      retval = (tmp.length () == 1 && tmp(0).is_empty ());
+      retval = (tmp.length () == 1 && tmp(0).isempty ());
     }
 
   return retval;
 }
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -619,17 +619,17 @@ void permute_to_correct_order1 (const oc
 {
   dest = src.orderfields (ref, perm);
 }
 
 // In non-scalar case, we also promote empty structs without fields.
 void permute_to_correct_order1 (const octave_map& ref, const octave_map& src,
                                 octave_map& dest, Array<octave_idx_type>& perm)
 {
-  if (src.nfields () == 0 && src.is_empty ())
+  if (src.nfields () == 0 && src.isempty ())
     dest = octave_map (src.dims (), ref.keys ());
   else
     dest = src.orderfields (ref, perm);
 }
 
 template <typename map>
 static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -365,17 +365,17 @@ public:
   {
     xkeys.clear ();
     xvals.clear ();
   }
 
   // The Array-like methods.
   octave_idx_type numel (void) const { return dimensions.numel (); }
   octave_idx_type length (void) const { return numel (); }
-  bool is_empty (void) const { return dimensions.any_zero (); }
+  bool isempty (void) const { return dimensions.any_zero (); }
 
   octave_idx_type rows (void) const { return dimensions(0); }
   octave_idx_type cols (void) const { return dimensions(1); }
   octave_idx_type columns (void) const { return dimensions(1); }
 
   // Extract a scalar substructure.
   // FIXME: actually check something.
   octave_scalar_map checkelem (octave_idx_type n) const
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3156,17 +3156,17 @@ namespace octave
   // Read stream until either fmt.width chars have been read, or
   // options.delimiter has been found.  Does *not* rely on fmt being 's'.
   // Used by formats like %6f to limit to 6.
 
   void
   textscan::scan_string (delimited_stream& is, const textscan_format_elt& fmt,
                          std::string& val) const
   {
-    if (delim_list.is_empty ())
+    if (delim_list.isempty ())
       {
         unsigned int i = 0;
         unsigned int width = fmt.width;
 
         for (i = 0; i < width; i++)
           {
             if (i+1 > val.length ())
               val = val + val + ' ';      // grow even if empty
@@ -5808,17 +5808,17 @@ namespace octave
                   break;
               }
             else
               {
                 octave_value val = val_cache.get_next_value ();
 
                 if (val_cache)
                   {
-                    if (! val.is_empty ())
+                    if (! val.isempty ())
                       retval += do_numeric_printf_conv (os, elt, nsa, sa_1,
                                                         sa_2, val, who);
                   }
                 else
                   break;
               }
 
             if (! os)
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -55,17 +55,17 @@ where @code{sigma_max (@var{x})} is the 
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
-  if (arg.is_empty ())
+  if (arg.isempty ())
     return ovl (Matrix ());
 
   octave_value retval;
 
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2000,17 +2000,17 @@ octave_print_internal (std::ostream& os,
     }
 }
 
 template <typename NDA_T, typename ELT_T, typename MAT_T>
 void print_nd_array (std::ostream& os, const NDA_T& nda,
                      bool pr_as_read_syntax)
 {
 
-  if (nda.is_empty ())
+  if (nda.isempty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else
     {
 
       int ndims = nda.ndims ();
 
       dim_vector dims = nda.dims ();
 
@@ -2860,17 +2860,17 @@ octave_print_internal (std::ostream& os,
 
 void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
                        bool pr_as_read_syntax, int /* extra_indent */)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function.  Can fix this with std::is_same from C++11.
 
-  if (nda.is_empty ())
+  if (nda.isempty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.numel () == 1)
     {
       os << nda(0);
     }
   else
     {
       int ndims = nda.ndims ();
@@ -3129,17 +3129,17 @@ PRINT_INT_SCALAR_INTERNAL (uint64_t)
 template <typename T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function.  Can fix this with std::is_same from C++11.
 
-  if (nda.is_empty ())
+  if (nda.isempty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.numel () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
 
       Array<octave_idx_type> ra_idx (dim_vector (ndims, 1), 0);
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1597,17 +1597,17 @@ Mathematical Software, Vol. 37, Issue 3,
   else
     a = args(1).double_value ();
 
   if (! args(2).is_real_scalar ())
     error ("quadcc: upper limit of integration (B) must be a single real scalar");
   else
     b = args(2).double_value ();
 
-  if (nargin < 4 || args(3).is_empty ())
+  if (nargin < 4 || args(3).isempty ())
     tol = 1.0e-6;
   else if (! args(3).is_real_scalar () || args(3).double_value () <= 0)
     error ("quadcc: tolerance (TOL) must be a single real scalar > 0");
   else
     tol = args(3).double_value ();
 
   if (nargin < 5)
     nivals = 1;
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -308,17 +308,17 @@ Note: @code{qz} performs permutation bal
   // Matrix A: check dimensions.
   F77_INT nn = octave::to_f77_int (args(0).rows ());
   F77_INT nc = octave::to_f77_int (args(0).columns ());
 
 #if defined (DEBUG)
   std::cout << "Matrix A dimensions: (" << nn << "," << nc << ")" << std::endl;
 #endif
 
-  if (args(0).is_empty ())
+  if (args(0).isempty ())
     {
       warn_empty_arg ("qz: A");
       return octave_value_list (2, Matrix ());
     }
   else if (nc != nn)
     err_square_matrix_required ("qz", "A");
 
   // Matrix A: get value.
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -215,17 +215,17 @@ strfind (@{"abababa", "bebebe", "ab"@}, 
 
   if (argpat.is_string ())
     {
       Array<char> needle = argpat.char_array_value ();
       OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
       qs_preprocess (needle, table);
 
       if (argstr.is_string ())
-        if (argpat.is_empty ())
+        if (argpat.isempty ())
           // Return a null matrix for null pattern for MW compatibility
           retval = Matrix ();
         else
           retval = octave_value (qs_search (needle,
                                             argstr.char_array_value (),
                                             table, overlaps),
                                  true, true);
       else if (argstr.iscell ())
@@ -235,17 +235,17 @@ strfind (@{"abababa", "bebebe", "ab"@}, 
           octave_idx_type ns = argsc.numel ();
 
           for (octave_idx_type i = 0; i < ns; i++)
             {
               octave_value argse = argsc(i);
               if (! argse.is_string ())
                 error ("strfind: each element of CELLSTR must be a string");
 
-              if (argpat.is_empty ())
+              if (argpat.isempty ())
                 retc(i) = Matrix ();
               else
                 retc(i) = octave_value (qs_search (needle,
                                                    argse.char_array_value (),
                                                    table, overlaps),
                                         true, true);
             }
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -866,17 +866,17 @@ whos ans
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   string_vector s = args(0).xstring_vector_value ("list_in_columns: ARG must be a cellstr or char array");
 
   int width = -1;
 
-  if (nargin > 1 && ! args(1).is_empty ())
+  if (nargin > 1 && ! args(1).isempty ())
     width = args(1).xint_value ("list_in_columns: WIDTH must be an integer");
 
   std::string prefix;
 
   if (nargin > 2)
     prefix = args(2).xstring_value ("list_in_columns: PREFIX must be a string");
 
   std::ostringstream buf;
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -76,17 +76,17 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
 
   octave_idx_type c_nr = arg_c.rows ();
   octave_idx_type c_nc = arg_c.columns ();
 
   bool isfloat = arg_a.is_single_type ()
                  || arg_b.is_single_type ()
                  || arg_c.is_single_type ();
 
-  if (arg_a.is_empty () || arg_b.is_empty () || arg_c.is_empty ())
+  if (arg_a.isempty () || arg_b.isempty () || arg_c.isempty ())
     {
       if (isfloat)
         return ovl (FloatMatrix ());
       else
         return ovl (Matrix ());
     }
 
   // Arguments are not empty, so check for correct dimensions.
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -58,30 +58,30 @@ mk_tm_map (const octave::sys::base_tm& t
 
 static inline int
 intfield (const octave_scalar_map& m, const std::string& k, const char *who)
 {
   int retval = 0;
 
   octave_value v = m.getfield (k);
 
-  if (! v.is_empty ())
+  if (! v.isempty ())
     retval = v.xint_value ("%s: invalid TM_STRUCT argument", who);
 
   return retval;
 }
 
 static inline std::string
 stringfield (const octave_scalar_map& m, const std::string& k, const char *who)
 {
   std::string retval;
 
   octave_value v = m.getfield (k);
 
-  if (! v.is_empty ())
+  if (! v.isempty ())
     retval = v.xstring_value ("%s: invalid TM_STRUCT argument", who);
 
   return retval;
 }
 
 static octave::sys::base_tm
 extract_tm (const octave_scalar_map& m, const char *who)
 {
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -282,17 +282,17 @@ command shell that is started to run the
 
 static octave_value
 find_config_info (const octave_scalar_map& m, const std::string& key)
 {
   if (m.isfield (key))
     {
       Cell c = m.contents (key);
 
-      if (! c.is_empty ())
+      if (! c.isempty ())
         return c(0);
     }
 
   return octave_value ();
 }
 
 DEFUN (__octave_config_info__, args, ,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -260,17 +260,17 @@ do_trilu (const std::string& name,
       {
         // Generic code that works on octave-values, that is slow
         // but will also work on arbitrary user types
         if (pack) // FIXME
           error ("%s: \"pack\" not implemented for class %s",
                  name.c_str (), arg.class_name ().c_str ());
 
         octave_value tmp = arg;
-        if (arg.is_empty ())
+        if (arg.isempty ())
           return arg;
 
         octave_idx_type nr = dims(0);
         octave_idx_type nc = dims(1);
 
         // The sole purpose of this code is to force the correct matrix size.
         // This would not be necessary if the octave_value resize function
         // allowed a fill_value.  It also allows odd attributes in some user
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -863,17 +863,17 @@ Undocumented internal function
 
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
 
   std::string file = args(1).xstring_value ("__ftp_mget__: PATTERN must be a string");
 
   std::string target;
 
-  if (nargin == 3 && ! args(2).is_empty ())
+  if (nargin == 3 && ! args(2).isempty ())
     target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + octave::sys::file_ops::dir_sep_str ();
 
   octave::url_transfer curl = ch_manager::get_object (args(0));
 
   if (! curl.is_valid ())
     error ("__ftp_mget__: invalid ftp handle");
 
   string_vector sv = curl.list ();
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1194,19 +1194,19 @@ get_dimensions (const octave_value& a, c
 
   check_dimensions (nr, nc, warn_for);
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
-  nr = a.is_empty ()
+  nr = a.isempty ()
        ? 0 : a.idx_type_value ("%s: row dimension must be a scalar", warn_for);
-  nc = b.is_empty ()
+  nc = b.isempty ()
        ? 0 : b.idx_type_value ("%s: column dimension must be a scalar", warn_for);
 
   check_dimensions (nr, nc, warn_for);
 }
 
 octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx_arg)
 {
diff --git a/libinterp/corefcn/utils.h b/libinterp/corefcn/utils.h
--- a/libinterp/corefcn/utils.h
+++ b/libinterp/corefcn/utils.h
@@ -49,17 +49,17 @@ extern OCTINTERP_API int almost_match (c
                                        int min_match_len = 1,
                                        int case_sens = 1);
 
 extern OCTINTERP_API int
 keyword_almost_match (const char * const *std, int *min_len,
                       const std::string& s, int min_toks_to_match,
                       int max_toks);
 
-OCTAVE_DEPRECATED ("use 'octave_value::is_empty' instead")
+OCTAVE_DEPRECATED ("use 'octave_value::isempty' instead")
 extern OCTINTERP_API int empty_arg (const char *name, octave_idx_type nr,
                                     octave_idx_type nc);
 
 extern OCTINTERP_API std::string
 search_path_for_file (const std::string&, const string_vector&);
 
 extern OCTINTERP_API string_vector
 search_path_for_all_files (const std::string&, const string_vector&);
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -39,17 +39,17 @@ octave_value xnorm (const octave_value& 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xnorm", x);
 
-  if (x.is_empty ())
+  if (x.isempty ())
     retval = octave_value (0);
   else if (isvector)
     {
       if (isfloat & iscomplex)
         retval = xnorm (x.float_complex_column_vector_value (),
                         p.float_value ());
       else if (isfloat)
         retval = xnorm (x.float_column_vector_value (),
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -120,17 +120,17 @@ Undocumented internal function.
     options = "Qt Qbb Qc Qz";
   else
     options = "Qt Qbb Qc Qx";
 
   if (nargin == 2)
     {
       if (args(1).is_string ())
         options = args(1).string_value ();
-      else if (args(1).is_empty ())
+      else if (args(1).isempty ())
         ;  // Use default options
       else if (args(1).iscellstr ())
         {
           options = "";
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
             options += tmp(i) + " ";
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -304,32 +304,32 @@ glpk (int sense, int n, int m, double *c
 
 #define OCTAVE_GLPK_GET_REAL_PARAM(NAME, VAL)                           \
   do                                                                    \
     {                                                                   \
       octave_value tmp = PARAM.getfield (NAME);                         \
                                                                         \
       if (tmp.is_defined ())                                            \
         {                                                               \
-          if (! tmp.is_empty ())                                        \
+          if (! tmp.isempty ())                                        \
             VAL = tmp.xscalar_value ("glpk: invalid value in PARAM" NAME); \
           else                                                          \
             error ("glpk: invalid value in PARAM" NAME);                \
         }                                                               \
     }                                                                   \
   while (0)
 
 #define OCTAVE_GLPK_GET_INT_PARAM(NAME, VAL)                            \
   do                                                                    \
     {                                                                   \
       octave_value tmp = PARAM.getfield (NAME);                         \
                                                                         \
       if (tmp.is_defined ())                                            \
         {                                                               \
-          if (! tmp.is_empty ())                                        \
+          if (! tmp.isempty ())                                        \
             VAL = tmp.xint_value ("glpk: invalid value in PARAM" NAME); \
           else                                                          \
             error ("glpk: invalid value in PARAM" NAME);                \
         }                                                               \
     }                                                                   \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -476,17 +476,17 @@ public:
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
-            if (! uimenup.get_callback ().is_empty ())
+            if (! uimenup.get_callback ().isempty ())
               item->callback (static_cast<Fl_Callback *> (script_cb),
                               static_cast<void *> (&uimenup));
             else
               item->callback (0, static_cast<void *> (0));
           }
       }
   }
 
@@ -1514,17 +1514,17 @@ private:
             {
               int e_key = Fl::event_key ();
               const char *e_text = Fl::event_text ();
               int e_state = Fl::event_state ();
               octave_scalar_map evt = format_key_event (e_key, e_text, e_state);
 
               m_fp.set_currentcharacter (std::string (e_text));
 
-              if (! m_fp.get_keypressfcn ().is_empty ()
+              if (! m_fp.get_keypressfcn ().isempty ()
                   && (evt.contents ("Key").length () > 0))
                 {
                   // Update CurrentPoint before callback
                   if (Fl::event_inside (m_canvas))
                     {
                       m_pos_x = Fl::event_x ();
                       m_pos_y = Fl::event_y () - menu_dy ();
 
@@ -1588,17 +1588,17 @@ private:
                   evt = format_key_event (e_key, tmp_e_text, e_state);
                 }
               else
                 {
                   const char *e_text = Fl::event_text ();
                   evt = format_key_event (e_key, e_text, e_state);
                 }
 
-              if (! m_fp.get_keyreleasefcn ().is_empty ()
+              if (! m_fp.get_keyreleasefcn ().isempty ()
                   && (evt.contents ("Key").length () > 0))
                 m_fp.execute_keyreleasefcn (evt);
               return 1;
             }
             break;
           }
 
         // Events we only handle if they are in the canvas area.
@@ -1635,43 +1635,43 @@ private:
               if (gh.ok ())
                 {
                   m_ax_obj = gh_manager::get_object (gh);
                   set_axes_currentpoint (m_ax_obj, m_pos_x, m_pos_y);
                 }
 
               // Ensure windowbuttondownfcn is called after currentpoint
               // is updated but before calling buttondownfcn.
-              if (! m_fp.get_windowbuttondownfcn ().is_empty ())
+              if (! m_fp.get_windowbuttondownfcn ().isempty ())
                 m_fp.execute_windowbuttondownfcn (Fl::event_button ());
 
               if (gh.ok ())
                 {
                   int ndim = calc_dimensions (m_ax_obj);
 
                   if (ndim == 3)
                     m_rotate->activate ();
                   else // ndim == 2
                     m_rotate->deactivate ();
 
                   m_fp.set_currentobject (m_ax_obj.get_handle ().value ());
 
                   base_properties& props = m_ax_obj.get_properties ();
-                  if (! props.get_buttondownfcn ().is_empty ())
+                  if (! props.get_buttondownfcn ().isempty ())
                     props.execute_buttondownfcn (Fl::event_button ());
 
                   return 1;
                 }
-              else if (! m_fp.get_buttondownfcn ().is_empty ())
+              else if (! m_fp.get_buttondownfcn ().isempty ())
                 m_fp.execute_buttondownfcn (Fl::event_button ());
 
               break;
 
             case FL_DRAG:
-              if (! m_fp.get_windowbuttonmotionfcn ().is_empty ())
+              if (! m_fp.get_windowbuttonmotionfcn ().isempty ())
                 {
                   set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                   m_fp.execute_windowbuttonmotionfcn ();
                 }
 
               if (Fl::event_button () == 1)
                 {
                   if (m_ax_obj && m_ax_obj.isa ("axes"))
@@ -1774,17 +1774,17 @@ private:
 
                     ap.zoom_about_point ("both", x1, y1, factor, false);
                     mark_modified ();
                     return 1;
                   }
               }
 
             case FL_RELEASE:
-              if (! m_fp.get_windowbuttonupfcn ().is_empty ())
+              if (! m_fp.get_windowbuttonupfcn ().isempty ())
                 {
                   set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                   m_fp.execute_windowbuttonupfcn ();
                 }
 
               if ((Fl::event_button () == 1) && Fl::event_clicks ())
                 {
                   // Double click
@@ -2274,17 +2274,17 @@ public:
   }
 
   void finalize (const graphics_object& go)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
-        if (! ov.is_empty ())
+        if (! ov.isempty ())
           figure_manager::delete_window (ov.string_value ());
       }
   }
 
   void uimenu_set___fltk_label__ (graphics_object uimenu_obj)
   {
     if (uimenu_obj.valid_object ())
       {
@@ -2307,17 +2307,17 @@ public:
   }
 
   void update (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
-        if (! ov.is_empty ())
+        if (! ov.isempty ())
           {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
 
             switch (id)
               {
               case base_properties::ID_VISIBLE:
                 figure_manager::toggle_window_visibility (ov.string_value (),
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -146,17 +146,17 @@ public:
         toolkit_loaded = false;
       }
   }
 
 private:
 
   void send_quit (const octave_value& pstream) const
   {
-    if (! pstream.is_empty ())
+    if (! pstream.isempty ())
       {
         octave_value_list args;
         Matrix fids = pstream.matrix_value ();
 
         Ffputs (ovl (fids(0), "\nquit;\n"));
 
         Ffflush (ovl (fids(0)));
         Fpclose (ovl (fids(0)));
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -1043,17 +1043,17 @@ namespace octave
       }
 
     //Set max step
     realtype maxstep = options.getfield("MaxStep").double_value ();
 
     dae.set_maxstep (maxstep);
 
     //Set initial step
-    if (! options.getfield("InitialStep").is_empty ())
+    if (! options.getfield("InitialStep").isempty ())
       {
         realtype initialstep = options.getfield("InitialStep").double_value ();
 
         dae.set_initialstep (initialstep);
       }
 
     //Set max order FIXME: it doesn't work
     int maxorder = options.getfield("MaxOrder").int_value ();
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -119,17 +119,17 @@ Undocumented internal function.
     options = " Qbb Qx";
 
   if (nargin == 3)
     {
       octave_value opt_arg = args(2);
 
       if (opt_arg.is_string ())
         options = " " + opt_arg.string_value ();
-      else if (opt_arg.is_empty ())
+      else if (opt_arg.isempty ())
         ; // Use default options.
       else if (opt_arg.iscellstr ())
         {
           options = "";
 
           Array<std::string> tmp = opt_arg.cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -171,17 +171,17 @@ sparse matrices.
         LLt = false;
       else
         error ("chol: optional argument must be one of \"vector\", \"lower\", or \"upper\"");
     }
 
   octave_value_list retval;
   octave_value arg = args(0);
 
-  if (arg.is_empty ())
+  if (arg.isempty ())
     return ovl (Matrix ());
 
   if (arg.is_sparse_type ())
     {
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -136,17 +136,17 @@ convex hull is calculated.
     options = " Qt";
   else
     options = " Qt Qx";
 
   if (nargin == 2)
     {
       if (args(1).is_string ())
         options = " " + args(1).string_value ();
-      else if (args(1).is_empty ())
+      else if (args(1).isempty ())
         ; // Use default options.
       else if (args(1).iscellstr ())
         {
           options = "";
 
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -231,17 +231,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
         if (! retval.is_defined ())
           retval = numeric_assign (type, idx, rhs);
       }
       break;
 
     case '{':
     case '.':
       {
-        if (! is_empty ())
+        if (! isempty ())
           {
             std::string nm = type_name ();
             error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
           }
 
         octave_value tmp = octave_value::empty_conv (type, rhs);
 
         retval = tmp.subsasgn (type, idx, rhs);
@@ -301,17 +301,17 @@ double
 octave_base_diag<DMT, MT>::double_value (bool force_conversion) const
 {
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion (type_name (), "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "real scalar");
 
   return helper_getreal (el_type (matrix (0, 0)));
 }
 
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -75,17 +75,17 @@ octave_base_matrix<MT>::subsasgn (const 
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
         if (type.length () == 1)
           retval = numeric_assign (type, idx, rhs);
-        else if (is_empty ())
+        else if (isempty ())
           {
             // Allow conversion of empty matrix to some other type in
             // cases like
             //
             //  x = []; x(i).f = rhs
 
             if (type[1] != '.')
               error ("invalid assignment expression");
@@ -101,17 +101,17 @@ octave_base_matrix<MT>::subsasgn (const 
                    nm.c_str ());
           }
       }
       break;
 
     case '{':
     case '.':
       {
-        if (! is_empty ())
+        if (! isempty ())
           {
             std::string nm = type_name ();
             error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
           }
 
         octave_value tmp = octave_value::empty_conv (type, rhs);
 
         retval = tmp.subsasgn (type, idx, rhs);
@@ -453,17 +453,17 @@ octave_base_matrix<MT>::print_info (std:
 {
   matrix.print_info (os, prefix);
 }
 
 template <typename MT>
 void
 octave_base_matrix<MT>::short_disp (std::ostream& os) const
 {
-  if (matrix.is_empty ())
+  if (matrix.isempty ())
     os << "[]";
   else if (matrix.ndims () == 2)
     {
       // FIXME: should this be configurable?
       octave_idx_type max_elts = 10;
       octave_idx_type elts = 0;
 
       octave_idx_type nel = matrix.numel ();
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -152,17 +152,17 @@ octave_base_sparse<T>::subsasgn (const s
 
         retval = numeric_assign (type, idx, rhs);
       }
       break;
 
     case '{':
     case '.':
       {
-        if (! is_empty ())
+        if (! isempty ())
           {
             std::string nm = type_name ();
             error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
           }
 
         octave_value tmp = octave_value::empty_conv (type, rhs);
 
         retval = tmp.subsasgn (type, idx, rhs);
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -91,17 +91,17 @@ std::string btyp_class_name[btyp_num_typ
   "struct", "cell", "function_handle"
 };
 
 string_vector
 get_builtin_classes (void)
 {
   static string_vector retval;
 
-  if (retval.is_empty ())
+  if (retval.isempty ())
     {
       int n = btyp_num_types - 2;
       retval = string_vector (n);
       int j = 0;
       for (int i = 0; i < btyp_num_types; i++)
         {
           builtin_type_t ityp = static_cast<builtin_type_t> (i);
           if (ityp != btyp_complex && ityp != btyp_float_complex)
@@ -269,17 +269,17 @@ octave_base_value::subsasgn (const std::
         }
 
       switch (type[0])
         {
         case '(':
           {
             if (type.length () == 1)
               retval = numeric_assign (type, idx, rhs);
-            else if (is_empty ())
+            else if (isempty ())
               {
                 // Allow conversion of empty matrix to some other
                 // type in cases like
                 //
                 //  x = []; x(i).f = rhs
 
                 octave_value tmp = octave_value::empty_conv (type, rhs);
 
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -332,17 +332,17 @@ public:
   virtual octave_value resize (const dim_vector&, bool fill = false) const;
 
   virtual MatrixType matrix_type (void) const;
 
   virtual MatrixType matrix_type (const MatrixType& typ) const;
 
   virtual bool is_defined (void) const { return false; }
 
-  bool is_empty (void) const { return (dims ().any_zero ()); }
+  bool isempty (void) const { return (dims ().any_zero ()); }
 
   virtual bool iscell (void) const { return false; }
 
   virtual bool iscellstr (void) const { return false; }
 
   virtual bool is_real_scalar (void) const { return false; }
 
   virtual bool is_real_matrix (void) const { return false; }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -287,17 +287,17 @@ octave_bool_matrix::load_ascii (std::ist
       for (int i = 0; i < mdims; i++)
         is >> dv(i);
 
       if (! is)
         error ("load: failed to extract dimensions");
 
       boolNDArray btmp (dv);
 
-      if (btmp.is_empty ())
+      if (btmp.isempty ())
         matrix = btmp;
       else
         {
           NDArray tmp(dv);
           is >> tmp;
 
           if (! is)
             error ("load: failed to load matrix constant");
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -95,17 +95,17 @@ octave_sparse_bool_matrix::try_narrowing
     }
 
   return retval;
 }
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("bool sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "bool sparse matrix", "real scalar");
 
   return matrix(0, 0);
 }
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -245,17 +245,17 @@ octave_cell::subsasgn (const std::string
     error ("missing index in indexed assignment");
 
   if (n > 1)
     {
       switch (type[0])
         {
         case '(':
           {
-            if (is_empty () && type[1] == '.')
+            if (isempty () && type[1] == '.')
               {
                 // Allow conversion of empty cell array to some other
                 // type in cases like
                 //
                 //  x = {}; x(i).f = rhs
 
                 octave_value tmp = octave_value::empty_conv (type, rhs);
 
@@ -306,17 +306,17 @@ octave_cell::subsasgn (const std::string
               tmp.make_unique (1);
 
             t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
           }
           break;
 
         case '.':
           {
-            if (! is_empty ())
+            if (! isempty ())
               {
                 std::string nm = type_name ();
                 error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
               }
 
             // Do nothing; the next branch will handle it.
           }
           break;
@@ -373,17 +373,17 @@ octave_cell::subsasgn (const std::string
 
         count++;
         retval = octave_value (this);
       }
       break;
 
     case '.':
       {
-        if (! is_empty ())
+        if (! isempty ())
           {
             std::string nm = type_name ();
             error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
           }
 
         // Allow conversion of empty cell array to some other
         // type in cases like
         //
@@ -610,17 +610,17 @@ octave_cell::string_vector_value (bool p
 Array<std::string>
 octave_cell::cellstr_value (void) const
 {
   Array<std::string> retval;
 
   if (! iscellstr ())
     error ("invalid conversion from cell array to array of strings");
 
-  if (cellstr_cache->is_empty ())
+  if (cellstr_cache->isempty ())
     *cellstr_cache = matrix.cellstr_value ();
 
   return *cellstr_cache;
 
   return retval;
 }
 
 bool
@@ -694,32 +694,32 @@ octave_cell::print_raw (std::ostream& os
 
 bool
 octave_cell::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
 
-  if (is_empty () || ndims () > 2)
+  if (isempty () || ndims () > 2)
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
       retval = true;
     }
 
   return retval;
 }
 
 void
 octave_cell::short_disp (std::ostream& os) const
 {
-  os << (matrix.is_empty () ? "{}" : "...");
+  os << (matrix.isempty () ? "{}" : "...");
 }
 
 #define CELL_ELT_TAG "<cell-element>"
 
 bool
 octave_cell::save_ascii (std::ostream& os)
 {
   dim_vector dv = dims ();
@@ -1240,17 +1240,17 @@ dimensions.
       get_dimensions (args(0), "cell", dims);
       break;
 
     default:
       {
         dims.resize (nargin);
 
         for (int i = 0; i < nargin; i++)
-          dims(i) = (args(i).is_empty ()
+          dims(i) = (args(i).isempty ()
                      ? 0 : args(i).xidx_type_value ("cell: dimension must be a scalar integer"));
       }
       break;
     }
 
   dims.chop_trailing_singletons ();
 
   check_dimensions (dims, "cell");
@@ -1297,17 +1297,17 @@ To convert back from a cellstr to a char
   octave_value_list tmp = Fiscellstr (args, 1);
 
   if (tmp(0).is_true ())
     return ovl (args(0));
   else
     {
       string_vector s = args(0).xstring_vector_value ("cellstr: argument STRING must be a 2-D character array");
 
-      return ovl (s.is_empty () ? Cell (octave_value (""))
+      return ovl (s.isempty () ? Cell (octave_value (""))
                                 : Cell (s, true));
     }
 }
 
 DEFUN (struct2cell, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{c} =} struct2cell (@var{s})
 Create a new cell array from the objects stored in the struct object.
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -735,17 +735,17 @@ octave_class::subsasgn_common (const oct
 
                 map.assign (idx.front (), rhs_map);
 
                 count++;
                 retval = octave_value (this);
               }
             else
               {
-                if (! t_rhs.is_empty ())
+                if (! t_rhs.isempty ())
                   error ("invalid class assignment");
 
                 map.delete_elements (idx.front ());
 
                 count++;
                 retval = octave_value (this);
               }
           }
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -736,19 +736,19 @@ make_property (const cdef_class& cls, co
   prop.put ("GetMethod", get_method);
   prop.put ("SetMethod", set_method);
   prop.put ("DefiningClass", to_ov (cls));
   prop.put ("DefaultValue", octave_value ());
   prop.put ("HasDefault", false);
 
   std::string class_name = cls.get_name ();
 
-  if (! get_method.is_empty ())
+  if (! get_method.isempty ())
     make_function_of_class (class_name, get_method);
-  if (! set_method.is_empty ())
+  if (! set_method.isempty ())
     make_function_of_class (class_name, set_method);
 
   return prop;
 }
 
 inline cdef_property
 make_attribute (const cdef_class& cls, const std::string& name)
 {
@@ -2823,17 +2823,17 @@ cdef_property::cdef_property_rep::get_va
         error ("cannot reference properties of class `%s' for non-constructed object",
                cls.get_name ().c_str ());
     }
 
   octave_value get_fcn = get ("GetMethod");
 
   // FIXME: should check whether we're already in get accessor method
 
-  if (get_fcn.is_empty () || is_method_executing (get_fcn, obj))
+  if (get_fcn.isempty () || is_method_executing (get_fcn, obj))
     retval = obj.get (get ("Name").string_value ());
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
 
       args = octave::feval (get_fcn, args, 1);
@@ -2876,17 +2876,17 @@ cdef_property::cdef_property_rep::set_va
 
       if (! obj.is_partially_constructed_for (cls))
         error ("cannot reference properties of class `%s' for non-constructed object",
                cls.get_name ().c_str ());
     }
 
   octave_value set_fcn = get ("SetMethod");
 
-  if (set_fcn.is_empty () || is_method_executing (set_fcn, obj))
+  if (set_fcn.isempty () || is_method_executing (set_fcn, obj))
     obj.put (get ("Name").string_value (), val);
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
       args(1) = val;
 
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -106,17 +106,17 @@ octave_sparse_complex_matrix::try_narrow
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex sparse matrix", "real scalar");
 
   // FIXME: maybe this should be a function, valid_as_scalar()
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "complex sparse matrix", "real scalar");
 
   return octave::math::real (matrix(0, 0));
 }
@@ -134,17 +134,17 @@ octave_sparse_complex_matrix::matrix_val
 
   return retval;
 }
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
 {
   // FIXME: maybe this should be a function, valid_as_scalar()
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "complex sparse matrix", "real scalar");
 
   return matrix(0, 0);
 }
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -783,17 +783,17 @@ functions from strings is through the us
               tmp_arg = "";
               is_arg = false;
             }
         }
 
       // Sort the arguments into ascii order.
       fargs.sort ();
 
-      if (fargs.is_empty ())
+      if (fargs.isempty ())
         fargs.append (std::string ("x"));
 
     }
   else if (nargin == 2 && args(1).is_numeric_type ())
     {
       if (! args(1).is_scalar_type ())
         error ("inline: N must be an integer");
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -94,29 +94,29 @@ octave_float_matrix::try_narrowing_conve
     retval = new octave_float_scalar (matrix (0));
 
   return retval;
 }
 
 double
 octave_float_matrix::double_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("real matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "real matrix", "real scalar");
 
   return matrix(0, 0);
 }
 
 float
 octave_float_matrix::float_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("real matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "real matrix", "real scalar");
 
   return matrix(0, 0);
 }
 
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -104,33 +104,33 @@ public:
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double
   double_value (bool = false) const
   {
     double retval = lo_ieee_nan_value ();
 
-    if (is_empty ())
+    if (isempty ())
       err_invalid_conversion (type_name (), "real scalar");
 
     warn_implicit_conversion ("Octave:array-to-scalar",
                               type_name (), "real scalar");
 
     retval = matrix(0).double_value ();
 
     return retval;
   }
 
   float
   float_value (bool = false) const
   {
     float retval = lo_ieee_float_nan_value ();
 
-    if (is_empty ())
+    if (isempty ())
       err_invalid_conversion (type_name (), "real scalar");
 
     warn_implicit_conversion ("Octave:array-to-scalar",
                               type_name (), "real scalar");
 
     retval = matrix(0).float_value ();
 
     return retval;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1432,17 +1432,17 @@ box_more (JNIEnv *jni_env, void *jobj_ar
 
                   for (int r = 0; r < rows; r++)
                     {
                       jdoubleArray_ref row (jni_env,
                                             reinterpret_cast<jdoubleArray>
                                             (jni_env->GetObjectArrayElement
                                              (jarr, r)));
 
-                      if (m.is_empty ())
+                      if (m.isempty ())
                         {
                           cols = jni_env->GetArrayLength (row);
                           m.resize (cols, rows);
                         }
                       jni_env->GetDoubleArrayRegion
                         (row, 0, cols, m.fortran_vec () + r * cols);
                     }
                   retval = m.transpose ();
@@ -1603,17 +1603,17 @@ unbox (JNIEnv *jni_env, const octave_val
         UNBOX_PRIMITIVE_SCALAR (uint32_t, uint32_scalar, "java/lang/Integer", "(I)V");
       else if (val.is_int64_type ())
         UNBOX_PRIMITIVE_SCALAR (int64_t, int64_scalar, "java/lang/Long", "(J)V");
       else if (val.is_uint64_type ())
         UNBOX_PRIMITIVE_SCALAR (uint64_t, uint64_scalar, "java/lang/Long", "(J)V");
 
 #undef UNBOX_PRIMITIVE_SCALAR
     }
-  else if (val.is_empty ())
+  else if (val.isempty ())
     {
       jobj = 0;
       jcls = 0;
       //jcls = jni_env->FindClass ("java/lang/Object");
     }
   else if (! Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
                 && (val.rows () == 1 || val.columns () == 1))
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -143,29 +143,29 @@ octave_perm_matrix::is_true (void) const
     }
   else
     return dims ().numel ();    // 1x1 is [1] == true, 0x0 == false.
 }
 
 double
 octave_perm_matrix::double_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion (type_name (), "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "real scalar");
 
   return matrix(0, 0);
 }
 
 float
 octave_perm_matrix::float_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion (type_name (), "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "real scalar");
 
   return matrix(0, 0);
 }
 
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -264,17 +264,17 @@ octave_range::diag (octave_idx_type m, o
 
 // Return true if this range has all true elements (non-zero, not NaN/NA).
 // A range cannot have NaN/NA.
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
-  if (! range.is_empty ())
+  if (! range.isempty ())
     {
       if (dims ().numel () > 1)
         warn_array_as_logical (dims ());
 
       Range r = range_value ();
       double base = r.base ();
       double limit = r.limit ();
 
@@ -288,17 +288,17 @@ octave_range::is_true (void) const
           double steps_to_zero = base / r.inc ();
 
           retval = (steps_to_zero != floor (steps_to_zero));
           */
 
           // FIXME: this is a waste of memory.
           Matrix m ((range.matrix_value ().all ()).all ());
 
-          retval = ! m.is_empty () && m(0, 0) != 0.0;
+          retval = ! m.isempty () && m(0, 0) != 0.0;
         }
     }
 
   return retval;
 }
 
 Complex
 octave_range::complex_value (bool) const
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -109,29 +109,29 @@ octave_matrix::try_narrowing_conversion 
     retval = new octave_scalar (matrix (0));
 
   return retval;
 }
 
 double
 octave_matrix::double_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("real matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "real matrix", "real scalar");
 
   return matrix(0, 0);
 }
 
 float
 octave_matrix::float_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("real matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "real matrix", "real scalar");
 
   return matrix(0, 0);
 }
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -90,17 +90,17 @@ octave_sparse_matrix::try_narrowing_conv
     }
 
   return retval;
 }
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
-  if (is_empty ())
+  if (isempty ())
     err_invalid_conversion ("real sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "real sparse matrix", "real scalar");
 
   return matrix(0, 0);
 }
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -342,17 +342,17 @@ octave_char_matrix_str::load_ascii (std:
       for (int i = 0; i < mdims; i++)
         is >> dv(i);
 
       if (! is)
         error ("load: failed to read dimensions");
 
       charNDArray tmp(dv);
 
-      if (tmp.is_empty ())
+      if (tmp.isempty ())
         matrix = tmp;
       else
         {
           char *ftmp = tmp.fortran_vec ();
 
           skip_preceeding_newline (is);
 
           if (! is.read (ftmp, dv.numel ()) || ! is)
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -79,17 +79,17 @@ octave_struct::dotref (const octave_valu
 
   std::string nm = idx(0).string_value ();
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
-    retval = (is_empty ()) ? Cell (dim_vector (1, 1)) : Cell (dims ());
+    retval = (isempty ()) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
     error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 static void
@@ -1703,17 +1703,17 @@ produces a struct @strong{array}.
 
   if (nargin == 1 && args(0).is_map ())
     return ovl (args(0));
 
   if (nargin == 1 && args(0).is_object ())
     return ovl (args(0).map_value ());
 
   if ((nargin == 1 || nargin == 2)
-      && args(0).is_empty () && args(0).is_real_matrix ())
+      && args(0).isempty () && args(0).is_real_matrix ())
     {
       if (nargin == 2)
         {
           Array<std::string> cstr = args(1).xcellstr_value ("struct: second argument should be a cell array of field names");
 
           return ovl (octave_map (args(0).dims (), cstr));
         }
       else
@@ -1838,17 +1838,17 @@ Implements @code{fieldnames()} for struc
 
   // Input validation has already been done in fieldnames.m.
   octave_value arg = args(0);
 
   octave_map m = arg.map_value ();
 
   string_vector keys = m.fieldnames ();
 
-  if (keys.is_empty ())
+  if (keys.isempty ())
     retval = Cell (0, 1);
   else
     retval = Cell (keys);
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -940,17 +940,17 @@ The original variable value is restored 
 @seealso{subsasgn}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
 
 static bool val_in_table (const Matrix& table, double val)
 {
-  if (table.is_empty ())
+  if (table.isempty ())
     return false;
 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1610,17 +1610,17 @@ octave_value::is_equal (const octave_val
 
   if (rows () == test.rows () && columns () == test.columns ())
     {
       octave_value tmp = do_binary_op (octave_value::op_eq, *this, test);
 
       // Empty array also means a match.
       if (tmp.is_defined ())
         {
-          if (tmp.is_empty ())
+          if (tmp.isempty ())
             retval = true;
           else
             {
               // Reshape into a vector and call all() explicitly,
               // to avoid Octave:array-as-logical warning.
               tmp = tmp.reshape (dim_vector (tmp.numel (), 1));
               retval = tmp.all ().is_true ();
             }
@@ -2550,19 +2550,19 @@ do_colon_op (const octave_value& base, c
                          ? increment.matrix_value (true)
                          : Matrix (1, 1, 1.0));
         }
       catch (octave::execution_exception& e)
         {
           error (e, "invalid increment value in colon expression");
         }
 
-      bool base_empty = m_base.is_empty ();
-      bool limit_empty = m_limit.is_empty ();
-      bool increment_empty = m_increment.is_empty ();
+      bool base_empty = m_base.isempty ();
+      bool limit_empty = m_limit.isempty ();
+      bool increment_empty = m_increment.isempty ();
 
       if (base_empty || limit_empty || increment_empty)
         retval = Range ();
       else
         {
           Range r (m_base(0), m_limit(0), m_increment(0));
 
           // For compatibility with Matlab, don't allow the range used in
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -520,18 +520,22 @@ public:
   // sometimes more natural to write is_undefined() instead of ! is_defined().
 
   bool is_defined (void) const
   { return rep->is_defined (); }
 
   bool is_undefined (void) const
   { return ! is_defined (); }
 
+  bool isempty (void) const
+  { return rep->isempty (); }
+
+  OCTAVE_DEPRECATED ("use 'isempty' instead")
   bool is_empty (void) const
-  { return rep->is_empty (); }
+  { return rep->isempty (); }
 
   bool iscell (void) const
   { return rep->iscell (); }
 
   OCTAVE_DEPRECATED ("use 'iscell' instead")
   bool is_cell (void) const
   { return rep->iscell (); }
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -248,17 +248,17 @@ bp_table::dbstop_process_map_args (const
   // why so many levels of indirection needed?
   bool fail = false;
   Cell U = mv.contents ("errs");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
-      if (W.is_empty () || W(0).is_empty ())
+      if (W.isempty () || W(0).isempty ())
         Vdebug_on_error = 1;    // like "dbstop if error" with no identifier
       else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
@@ -274,17 +274,17 @@ bp_table::dbstop_process_map_args (const
   // why so many levels of indirection needed?
   fail = false;
   U = mv.contents ("caught");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
-      if (W.is_empty () || W(0).is_empty ())
+      if (W.isempty () || W(0).isempty ())
         Vdebug_on_caught = 1;    // like "dbstop if caught error" with no ID
       else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
@@ -300,17 +300,17 @@ bp_table::dbstop_process_map_args (const
   // why so many levels of indirection needed?
   fail = false;
   U = mv.contents ("warn");
   if (U.numel () != 1)
     fail = (U.numel () > 1);
   else
     {
       Array<octave_value> W = U.index (static_cast<octave_idx_type> (0));
-      if (W.is_empty () || W(0).is_empty ())
+      if (W.isempty () || W(0).isempty ())
         Vdebug_on_warning = 1;    // like "dbstop if warning" with no identifier
       else if (! W(0).iscell ())
         fail = true;
       else
         {
           Cell V = W(0).cell_value ();
           for (int i = 0; i < V.numel (); i++)
             {
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3926,17 +3926,17 @@ namespace octave
       {
         octave::tree_evaluator& tw
           = __get_evaluator__ ("validate_matrix_for_assignment");
 
         octave_value ov = tw.evaluate (e);
 
         delete e;
 
-        if (ov.is_empty ())
+        if (ov.isempty ())
           bison_error ("invalid empty left hand side of assignment");
         else
           bison_error ("invalid constant left hand side of assignment");
       }
     else
       {
         bool is_simple_assign = true;
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -1518,17 +1518,17 @@ namespace octave
             for (tm_row_const& row : tmp)
               {
                 octave_quit ();
 
                 for (auto& elt : row)
                   {
                     octave_quit ();
 
-                    if (elt.is_empty ())
+                    if (elt.isempty ())
                       continue;
 
                     ctmp = do_cat_op (ctmp, elt, ra_idx);
 
                     ra_idx (1) += elt.columns ();
                   }
 
                 ra_idx (0) += row.rows ();
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -198,17 +198,17 @@ namespace octave
     for (auto& elt : *this)
       {
         octave_quit ();
 
         if (! elt.iscell ())
           {
             elt_changed = true;
 
-            if (elt.is_empty ())
+            if (elt.isempty ())
               elt = Cell ();
             else
               elt = Cell (elt);
           }
       }
 
     if (elt_changed)
       {
diff --git a/libinterp/parse-tree/pt-tm-const.h b/libinterp/parse-tree/pt-tm-const.h
--- a/libinterp/parse-tree/pt-tm-const.h
+++ b/libinterp/parse-tree/pt-tm-const.h
@@ -273,17 +273,17 @@ namespace octave
         for (auto& elt : row)
           {
             octave_quit ();
 
             TYPE ra = octave_value_extract<TYPE> (elt);
 
             // Skip empty arrays to allow looser rules.
 
-            if (! ra.is_empty ())
+            if (! ra.isempty ())
               {
                 result.insert (ra, r, c);
 
                 c += ra.columns ();
               }
           }
 
         r += row.rows ();
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2290,17 +2290,17 @@ Array<T>::find (octave_idx_type n, bool 
   // find (zeros (0,0)) -> zeros (0,0)
   // find (zeros (1,0)) -> zeros (1,0)
   // find (zeros (0,1)) -> zeros (0,1)
   // find (zeros (0,X)) -> zeros (0,1)
   // find (zeros (1,1)) -> zeros (0,0) !!!! WHY?
   // find (zeros (0,1,0)) -> zeros (0,0)
   // find (zeros (0,1,0,1)) -> zeros (0,0) etc
 
-  if ((numel () == 1 && retval.is_empty ())
+  if ((numel () == 1 && retval.isempty ())
       || (rows () == 0 && dims ().numel (1) == 0))
     retval.dimensions = dim_vector ();
   else if (rows () == 1 && ndims () == 2)
     retval.dimensions = dim_vector (1, retval.numel ());
 
   return retval;
 }
 
@@ -2320,17 +2320,17 @@ Array<T>::nth_element (const idx_vector&
   octave_idx_type nn = n.length (ns);
 
   dv(dim) = std::min (nn, ns);
   dv.chop_trailing_singletons ();
   dim = std::min (dv.ndims (), static_cast<octave_idx_type> (dim));
 
   Array<T> m (dv);
 
-  if (m.is_empty ())
+  if (m.isempty ())
     return m;
 
   sortmode mode = UNSORTED;
   octave_idx_type lo = 0;
 
   switch (n.idx_class ())
     {
     case idx_vector::class_scalar:
@@ -2670,32 +2670,32 @@ Array<T>::cat (int dim, octave_idx_type 
   dim_vector dv = array_list[istart++].dims ();
 
   for (octave_idx_type i = istart; i < n; i++)
     if (! (dv.*concat_rule) (array_list[i].dims (), dim))
       (*current_liboctave_error_handler) ("cat: dimension mismatch");
 
   Array<T> retval (dv);
 
-  if (retval.is_empty ())
+  if (retval.isempty ())
     return retval;
 
   int nidx = std::max (dv.ndims (), static_cast<octave_idx_type> (dim + 1));
   Array<idx_vector> idxa (dim_vector (nidx, 1), idx_vector::colon);
   octave_idx_type l = 0;
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       // NOTE: This takes some thinking, but no matter what the above rules
       // are, an empty array can always be skipped at this point, because
       // the result dimensions are already determined, and there is no way
       // an empty array may contribute a nonzero piece along the dimension
       // at this point, unless an empty array can be promoted to a non-empty
       // one (which makes no sense).  I repeat, *no way*, think about it.
-      if (array_list[i].is_empty ())
+      if (array_list[i].isempty ())
         continue;
 
       octave_quit ();
 
       octave_idx_type u;
       if (dim < array_list[i].ndims ())
         u = l + array_list[i].dims ()(dim);
       else
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -553,17 +553,21 @@ public:
   { return Array<T> (*this, new_dims); }
 
   Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
   Array<T> ipermute (const Array<octave_idx_type>& vec) const
   { return permute (vec, true); }
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
-  bool is_empty (void) const { return numel () == 0; }
+  bool isempty (void) const { return numel () == 0; }
+
+  OCTAVE_DEPRECATED ("use 'isempty' instead")
+  bool is_empty (void) const
+  { return isempty (); }
 
   bool is_vector (void) const { return dimensions.is_vector (); }
 
   bool is_nd_vector (void) const { return dimensions.is_nd_vector (); }
 
   Array<T> transpose (void) const;
   Array<T> hermitian (T (*fcn) (const T&) = 0) const;
 
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -46,17 +46,17 @@ Range::all_elements_are_ints (void) cons
   return (! (octave::math::isnan (rng_base) || octave::math::isnan (rng_inc))
           && (octave::math::nint_big (rng_base) == rng_base || rng_numel < 1)
           && (octave::math::nint_big (rng_inc) == rng_inc || rng_numel <= 1));
 }
 
 Matrix
 Range::matrix_value (void) const
 {
-  if (rng_numel > 0 && cache.is_empty ())
+  if (rng_numel > 0 && cache.isempty ())
     {
       cache.resize (1, rng_numel);
 
       // The first element must always be *exactly* the base.
       // E.g, -0 would otherwise become +0 in the loop (-0 + 0*increment).
       cache(0) = rng_base;
 
       double b = rng_base;
diff --git a/liboctave/array/Range.h b/liboctave/array/Range.h
--- a/liboctave/array/Range.h
+++ b/liboctave/array/Range.h
@@ -79,17 +79,21 @@ public:
   double limit (void) const { return rng_limit; }
   double inc (void) const { return rng_inc; }
 
   OCTAVE_DEPRECATED ("use 'numel' instead")
   octave_idx_type nelem (void) const { return numel (); }
 
   octave_idx_type numel (void) const { return rng_numel; }
 
-  bool is_empty (void) const { return numel () == 0; }
+  bool isempty (void) const { return numel () == 0; }
+
+  OCTAVE_DEPRECATED ("use 'isempty' instead")
+  bool is_empty (void) const
+  { return isempty (); }
 
   bool all_elements_are_ints (void) const;
 
   Matrix matrix_value (void) const;
 
   double min (void) const;
   double max (void) const;
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2598,17 +2598,17 @@ Sparse<T>::cat (int dim, octave_idx_type
       if (! (dv.*concat_rule) (sparse_list[i].dims (), dim))
         (*current_liboctave_error_handler) ("cat: dimension mismatch");
 
       total_nz += sparse_list[i].nnz ();
     }
 
   Sparse<T> retval (dv, total_nz);
 
-  if (retval.is_empty ())
+  if (retval.isempty ())
     return retval;
 
   switch (dim)
     {
     case 0:
       {
         // sparse vertcat.  This is not efficiently handled by assignment,
         // so we'll do it directly.
@@ -2617,17 +2617,17 @@ Sparse<T>::cat (int dim, octave_idx_type
           {
             octave_quit ();
 
             octave_idx_type rcum = 0;
             for (octave_idx_type i = 0; i < n; i++)
               {
                 const Sparse<T>& spi = sparse_list[i];
                 // Skipping empty matrices.  See the comment in Array.cc.
-                if (spi.is_empty ())
+                if (spi.isempty ())
                   continue;
 
                 octave_idx_type kl = spi.cidx (j);
                 octave_idx_type ku = spi.cidx (j+1);
                 for (octave_idx_type k = kl; k < ku; k++, l++)
                   {
                     retval.xridx (l) = spi.ridx (k) + rcum;
                     retval.xdata (l) = spi.data (k);
@@ -2644,17 +2644,17 @@ Sparse<T>::cat (int dim, octave_idx_type
     case 1:
       {
         octave_idx_type l = 0;
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_quit ();
 
             // Skipping empty matrices.  See the comment in Array.cc.
-            if (sparse_list[i].is_empty ())
+            if (sparse_list[i].isempty ())
               continue;
 
             octave_idx_type u = l + sparse_list[i].columns ();
             retval.assign (idx_vector::colon, idx_vector (l, u),
                            sparse_list[i]);
             l = u;
           }
 
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -464,17 +464,21 @@ public:
     rep->change_length (nz);
   }
 
   Sparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c);
   Sparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
-  bool is_empty (void) const { return (rows () < 1 && cols () < 1); }
+  bool isempty (void) const { return (rows () < 1 && cols () < 1); }
+
+  OCTAVE_DEPRECATED ("use 'isempty' instead")
+  bool is_empty (void) const
+  { return isempty (); }
 
   Sparse<T> transpose (void) const;
 
   T * data (void) { make_unique (); return rep->d; }
   T& data (octave_idx_type i) { make_unique (); return rep->data (i); }
   T * xdata (void) { return rep->d; }
   T& xdata (octave_idx_type i) { return rep->data (i); }
 
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -106,17 +106,17 @@ charNDArray::concat (const charNDArray& 
 }
 
 charNDArray
 charNDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   charNDArray tmp (rb.dims ());
   octave_idx_type nel = rb.numel ();
 
-  if (rb.is_empty ())
+  if (rb.isempty ())
     return *this;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double d = rb.elem (i);
 
       if (octave::math::isnan (d))
         (*current_liboctave_error_handler)
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -763,17 +763,17 @@ NDArray::concat (const charNDArray& rb, 
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do? Should we warn the user?
         ival = 0;
 
       retval.elem (i) = static_cast<char>(ival);
     }
 
-  if (rb.is_empty ())
+  if (rb.isempty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
 
 NDArray
 real (const ComplexNDArray& a)
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -724,17 +724,17 @@ FloatNDArray::concat (const charNDArray&
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do?  Should we warn the user?
         ival = 0;
 
       retval.elem (i) = static_cast<char>(ival);
     }
 
-  if (rb.is_empty ())
+  if (rb.isempty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
 
 FloatNDArray
 real (const FloatComplexNDArray& a)
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -80,17 +80,17 @@ ddaspk_f (const double& time, const doub
   octave_idx_type tmp_ires = ires;
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
 
   ires = octave::to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
-      if (tmp_delta.is_empty ())
+      if (tmp_delta.isempty ())
         ires = -2;
       else
         {
           for (F77_INT i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -75,17 +75,17 @@ ddasrt_f (const double& t, const double 
     }
 
   octave_idx_type tmp_ires = ires;
 
   ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, tmp_ires);
 
   ires = octave::to_f77_int (tmp_ires);
 
-  if (tmp_fval.is_empty ())
+  if (tmp_fval.isempty ())
     ires = -2;
   else
     {
       for (F77_INT i = 0; i < nn; i++)
         delta[i] = tmp_fval(i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -77,17 +77,17 @@ ddassl_f (const double& time, const doub
   octave_idx_type tmp_ires = ires;
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
 
   ires = octave::to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
-      if (tmp_delta.is_empty ())
+      if (tmp_delta.isempty ())
         ires = -2;
       else
         {
           for (F77_INT i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -61,17 +61,17 @@ lsode_f (const F77_INT& neq, const doubl
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
-  if (tmp_deriv.is_empty ())
+  if (tmp_deriv.isempty ())
     ierr = -1;
   else
     {
       for (F77_INT i = 0; i < neq; i++)
         deriv[i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -72,17 +72,17 @@ do_bsxfun_op (const Array<X>& x, const A
   octave_idx_type start, ldr = 1;
   for (start = 0; start < nd; start++)
     {
       if (dvx(start) != dvy(start))
         break;
       ldr *= dvr(start);
     }
 
-  if (retval.is_empty ())
+  if (retval.isempty ())
     ; // do nothing
   else if (start == nd)
     op_vv (retval.numel (), rvec, xvec, yvec);
   else
     {
       // Determine the type of the low-level loop.
       bool xsing = false;
       bool ysing = false;
@@ -153,17 +153,17 @@ do_inplace_bsxfun_op (Array<R>& r, const
   octave_idx_type start, ldr = 1;
   for (start = 0; start < nd; start++)
     {
       if (dvr(start) != dvx(start))
         break;
       ldr *= dvr(start);
     }
 
-  if (r.is_empty ())
+  if (r.isempty ())
     ; // do nothing
   else if (start == nd)
     op_vv (r.numel (), rvec, xvec);
   else
     {
       // Determine the type of the low-level loop.
       bool xsing = false;
       if (ldr == 1)
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -265,17 +265,17 @@ make_cholb (SparseComplexMatrix& b, Spar
 }
 
 static bool
 LuAminusSigmaB (const SparseMatrix& m, const SparseMatrix& b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 SparseMatrix& L, SparseMatrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
@@ -357,17 +357,17 @@ LuAminusSigmaB (const SparseMatrix& m, c
 }
 
 static bool
 LuAminusSigmaB (const Matrix& m, const Matrix& b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 Matrix& L, Matrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
@@ -429,17 +429,17 @@ LuAminusSigmaB (const Matrix& m, const M
 }
 
 static bool
 LuAminusSigmaB (const SparseComplexMatrix& m, const SparseComplexMatrix& b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 SparseComplexMatrix& L, SparseComplexMatrix& U,
                 octave_idx_type *P, octave_idx_type *Q)
 {
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
@@ -521,17 +521,17 @@ LuAminusSigmaB (const SparseComplexMatri
 }
 
 static bool
 LuAminusSigmaB (const ComplexMatrix& m, const ComplexMatrix& b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 ComplexMatrix& L, ComplexMatrix& U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
@@ -602,29 +602,29 @@ EigsRealSymmetricMatrix (const M& m, con
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -646,17 +646,17 @@ EigsRealSymmetricMatrix (const M& m, con
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -680,17 +680,17 @@ EigsRealSymmetricMatrix (const M& m, con
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
-          if (permB.is_empty ())
+          if (permB.isempty ())
             {
               permB = ColumnVector (n);
               for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -880,32 +880,32 @@ EigsRealSymmetricMatrixShift (const M& m
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -927,17 +927,17 @@ EigsRealSymmetricMatrixShift (const M& m
       if (p > n - 1)
         p = n - 1;
     }
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -1179,17 +1179,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -1419,30 +1419,30 @@ EigsRealNonSymmetricMatrix (const M& m, 
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -1464,17 +1464,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -1498,17 +1498,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
-          if (permB.is_empty ())
+          if (permB.isempty ())
             {
               permB = ColumnVector (n);
               for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -1746,33 +1746,33 @@ EigsRealNonSymmetricMatrixShift (const M
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -1794,17 +1794,17 @@ EigsRealNonSymmetricMatrixShift (const M
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -2100,17 +2100,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   F77_INT mode = 1;
   int err = 0;
 
-  if (resid.is_empty ())
+  if (resid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       resid = ColumnVector (octave_rand::vector (n));
       octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
@@ -2388,29 +2388,29 @@ EigsComplexNonSymmetricMatrix (const M& 
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
-  if (cresid.is_empty ())
+  if (cresid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
@@ -2436,17 +2436,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check the we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -2470,17 +2470,17 @@ EigsComplexNonSymmetricMatrix (const M& 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.hermitian ();
-          if (permB.is_empty ())
+          if (permB.isempty ())
             {
               permB = ColumnVector (n);
               for (F77_INT i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -2674,32 +2674,32 @@ EigsComplexNonSymmetricMatrixShift (cons
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
   F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
-  bool have_b = ! b.is_empty ();
+  bool have_b = ! b.isempty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
-  if (cresid.is_empty ())
+  if (cresid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
@@ -2725,17 +2725,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       ("eigs: Invalid number of eigenvalues to extract"
        " (must be 0 < k < n-1).\n"
        "      Use 'eig (full (A))' instead");
 
   if (p <= k || p >= n)
     (*current_liboctave_error_handler)
       ("eigs: opts.p must be greater than k and less than n");
 
-  if (have_b && cholB && ! permB.is_empty ())
+  if (have_b && cholB && ! permB.isempty ())
     {
       // Check that we really have a permutation vector
       if (permB.numel () != n)
         (*current_liboctave_error_handler) ("eigs: permB vector invalid");
 
       Array<bool> checked (dim_vector (n, 1), false);
       for (F77_INT i = 0; i < n; i++)
         {
@@ -2989,17 +2989,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
   F77_INT k = octave::to_f77_int (k_arg);
   F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
-  if (cresid.is_empty ())
+  if (cresid.isempty ())
     {
       std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution ("uniform");
       Array<double> rr (octave_rand::vector (n));
       Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -127,17 +127,17 @@ void convolve_nd (const T *a, const dim_
 
 // Arbitrary convolutor.
 // The 2nd array is assumed to be the smaller one.
 template <typename T, typename R>
 static MArray<T>
 convolve (const MArray<T>& a, const MArray<R>& b,
           convn_type ct)
 {
-  if (a.is_empty () || b.is_empty ())
+  if (a.isempty () || b.isempty ())
     return MArray<T> ();
 
   int nd = std::max (a.ndims (), b.ndims ());
   const dim_vector adims = a.dims ().redim (nd);
   const dim_vector bdims = b.dims ().redim (nd);
   dim_vector cdims = dim_vector::alloc (nd);
 
   for (int i = 0; i < nd; i++)
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -68,17 +68,17 @@ namespace octave
     }
 
     template <typename T>
     typename qr<T>::type
     qr<T>::get_type (void) const
     {
       type retval;
 
-      if (! q.is_empty () && q.is_square ())
+      if (! q.isempty () && q.is_square ())
         retval = qr<T>::std;
       else if (q.rows () > q.cols () && r.is_square ())
         retval = qr<T>::economy;
       else
         retval = qr<T>::raw;
 
       return retval;
     }
