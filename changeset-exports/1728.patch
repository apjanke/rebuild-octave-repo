# HG changeset patch
# User jwe
# Date 821187703 0
#      Tue Jan 09 11:41:43 1996 +0000
# Node ID 42b4f904f1af4678cb6abab64ff8e68c158f20e6
# Parent  ba9b08842dbe657893b2275a0786d55b8cfd7d17
[project @ 1996-01-09 11:36:01 by jwe]

diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdio>
 #include <cstring>
 
+#include <string>
+
 #include <iostream.h>
 
 // #include <sys/types.h>  // XXX FIXME XXX
 
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 
@@ -86,30 +88,28 @@ charMatrix::insert (const char *s, int r
 
 charMatrix&
 charMatrix::insert (const charMatrix& a, int r, int c)
 {
   Array2<char>::insert (a, r, c);
   return *this;
 }
 
-char *
+string
 charMatrix::row_as_string (int r) const
 {
   if (r < 0 || r >= rows ())
     {
       (*current_liboctave_error_handler) ("range error for row_as_string");
       return 0;
     }
 
   int nc = cols ();
 
-  char *retval = new char [nc + 1];
-
-  retval[nc] = '\0';
+  string retval (nc, '\0');
 
   for (int i = 0; i < nc; i++)
     retval[i] = elem (r, i);
 
   return retval;
 }
 
 #if 0
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -26,21 +26,24 @@ Software Foundation, 59 Temple Place - S
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 // For FILE...
 #include <cstdio>
 
+#include <string>
+
 #include "MArray.h"
 
 #include "mx-defs.h"
 
-class charMatrix : public MArray2<char>
+class
+charMatrix : public MArray2<char>
 {
 friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : MArray2<char> () { }
   charMatrix (int r, int c) : MArray2<char> (r, c) { }
   charMatrix (int r, int c, char val) : MArray2<char> (r, c, val) { }
@@ -57,17 +60,17 @@ public:
   int operator == (const charMatrix& a) const;
   int operator != (const charMatrix& a) const;
 
   // destructive insert/delete/reorder operations
 
   charMatrix& insert (const char *s, int r, int c);
   charMatrix& insert (const charMatrix& a, int r, int c);
 
-  char *row_as_string (int r) const;
+  string row_as_string (int r) const;
 
 #if 0
   Matrix& insert (const RowVector& a, int r, int c);
   Matrix& insert (const ColumnVector& a, int r, int c);
   Matrix& insert (const DiagMatrix& a, int r, int c);
 
   Matrix& fill (char val);
   Matrix& fill (char val, int r1, int c1, int r2, int c2);
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -22,16 +22,18 @@ Software Foundation, 59 Temple Place - S
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include "CMatrix.h"
 #include "CmplxAEPBAL.h"
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "dbleAEPBAL.h"
 #include "dbleAEPBAL.h"
 #include "dbleGEPBAL.h"
 
@@ -68,24 +70,26 @@ where OPT is an optional single characte
 
   if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
     {
       print_usage ("balance");
       return retval;
     }
 
   const char *bal_job;
+  string tstr;
   int my_nargin;		// # args w/o optional string arg
 
   // Determine if balancing option is listed.  Set my_nargin to the
   // number of matrix inputs.
 
   if (args(nargin-1).is_string ())
     {
-      bal_job = args(nargin-1).string_value ();
+      tstr = args(nargin-1).string_value ();
+      bal_job = tstr.c_str ();
       my_nargin = nargin-1;
     }
   else
     {
       bal_job = "B";
       my_nargin = nargin;
     }
 
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include "CollocWt.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "tree-const.h"
 #include "utils.h"
 
@@ -79,17 +81,18 @@ DEFUN_DLD_BUILTIN ("colloc", Fcolloc, Sc
       if (args(i).is_defined ())
 	{
 	  if (! args(i).is_string ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
 
-	  const char *s = args(i).string_value ();
+	  string tstr = args(i).string_value ();
+	  const char *s = tstr.c_str ();
 
 	  if (s && (((*s == 'R' || *s == 'r') && strlen (s) == 1)
 		    || strcmp (s, "right") == 0))
 	    {
 	      right = 1;
 	    }
 	  else if (s && (((*s == 'L' || *s == 'l') && strlen (s) == 1)
 			 || strcmp (s, "left") == 0))
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "DAE.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -328,17 +330,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_dassl_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_dassl_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -28,16 +28,18 @@ Bash, the Bourne Again SHell, copyright 
 Software Foundation, Inc.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-map.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
@@ -799,17 +801,18 @@ return nonzero if S is a structure with 
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = 0.0;
       if (args(0).is_map () && args(1).is_string ())
 	{
-	  const char *s = args(1).string_value ();
+	  string tstr = args(1).string_value ();
+	  const char *s = tstr.c_str ();
 	  tree_constant tmp = args(0).lookup_map_element (s, 0, 1);
 	  retval = (double) tmp.is_defined ();
 	}
     }
   else
     print_usage ("struct_contains");
 
   return retval;
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -39,16 +39,18 @@ Free Software Foundation, Inc.
 #endif
 
 #include <cerrno>
 #include <cstdio>
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
 
+#include <string>
+
 #include <strstream.h>
 
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
@@ -496,17 +498,18 @@ named directory.  If sucessful, returns 
 is printed.")
 {
   Octave_object retval;
   charMatrix dirlist;
   int status = 0;
 
   if (args.length () == 1)
     {
-      const char *dirname = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *dirname = tstr.c_str ();
 
       if (error_state)
 	{
 	  status = -1;
 	  gripe_wrong_type_arg ("readdir", args(0));
 	}
       else
 	{
@@ -585,17 +588,18 @@ Create the directory named by NAME.  If 
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      const char *dirname = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *dirname = tstr.c_str ();
 
       if (error_state)
 	gripe_wrong_type_arg ("mkdir", args(0));
       else
 	{
 	  char *tmp = tilde_expand (dirname);
 
 	  int mkdir_retval = mkdir (tmp, 0777);
@@ -625,17 +629,18 @@ Remove the directory named by NAME.  If 
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      const char *dirname = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *dirname = tstr.c_str ();
 
       if (error_state)
 	gripe_wrong_type_arg ("rmdir", args(0));
       else
 	{
 	  char *tmp = tilde_expand (dirname);
 
 	  int rmdir_retval = rmdir (tmp);
@@ -665,22 +670,26 @@ Rename a file.  If successful, returns 0
 otherwise prints an error message and returns -1.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 2)
     {
-      const char *from = args(0).string_value ();
+      string tstr1 = args(0).string_value ();
+      const char *from = tstr1.c_str ();
+
       if (error_state)
 	gripe_wrong_type_arg ("rename", args(0));
       else
 	{
-	  const char *to = args(1).string_value ();
+	  string tstr2 = args(1).string_value ();
+	  const char *to = tstr2.c_str ();
+
 	  if (error_state)
 	    gripe_wrong_type_arg ("rename", args(1));
 	  else if (rename (from, to) < 0)
 	    {
 	      status = -1;
 	      error ("%s", strerror (errno));
 	    }
 	}
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdarg>
 #include <cstring>
 
+#include <string>
+
 #include <strstream.h>
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "tree-const.h"
 #include "user-prefs.h"
@@ -197,25 +199,28 @@ typedef void (*error_fun)(const char *, 
 
 extern Octave_object Fsprintf (const Octave_object&, int);
 
 static Octave_object
 handle_message (error_fun f, const char *msg, const Octave_object& args)
 {
   Octave_object retval;
 
+  string tstr;
+
   int nargin = args.length ();
 
   tree_constant arg = ((nargin > 1) ? Fsprintf (args, 1) : args) (0);
 
   if (arg.is_defined ())
     {
       if (arg.is_string ())
 	{
-	  msg = arg.string_value ();
+	  tstr = arg.string_value ();
+	  msg = tstr.c_str ();
 
 	  if (! msg)
 	    return retval;
 	}
       else if (arg.is_empty ())
 	return retval;
     }
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -34,16 +34,18 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <cstring>
 #include <cstdio>
 #include <cerrno>
 #include <cstdlib>
 #include <cctype>
 
+#include <string>
+
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include <fcntl.h>
@@ -110,17 +112,18 @@ return_valid_file (const tree_constant& 
 {
   if (arg.is_string ())
     {
       Pix p = file_list.first ();
       file_info file;
       int file_count = file_list.length ();
       for (int i = 0; i < file_count; i++)
 	{
-	  const char *file_name = arg.string_value ();
+	  string tstr = arg.string_value ();
+	  const char *file_name = tstr.c_str ();
 	  file = file_list (p);
 	  if (file.name () == file_name)
 	    return p;
 	  file_list.next (p);
 	}
     }
   else
     {
@@ -186,17 +189,18 @@ file_io_get_file (const tree_constant& a
 		  const char *warn_for)
 {
   Pix p = return_valid_file (arg);
 
   if (! p)
     {
       if (arg.is_string ())
 	{
-	  const char *name = arg.string_value ();
+	  string tstr = arg.string_value ();
+	  const char *name = tstr.c_str ();
 
 	  struct stat buffer;
 	  int status = stat (name, &buffer);
 
 	  if (status == 0)
 	    {
 	      if ((buffer.st_mode & S_IFREG) == S_IFREG)
 		p = fopen_file_for_user (name, mode, warn_for);
@@ -476,18 +480,20 @@ fopen_internal (const Octave_object& arg
     }
 
   if (! args(1).is_string ())
     {
       error ("fopen: file mode must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
-  const char *mode = args(1).string_value ();
+  string tstr1 = args(0).string_value ();
+  const char *name = tstr1.c_str ();
+  string tstr2 = args(1).string_value ();
+  const char *mode = tstr2.c_str ();
 
   if (! valid_mode (mode))
     {
       error ("fopen: invalid mode");
       return retval;
     }
 
   struct stat buffer;
@@ -930,34 +936,36 @@ process_printf_format (const char *s, co
 	    sb.form (tmp_fmt, val);
 	    delete [] tmp_fmt;
 	    return chars_from_fmt_str;
 	  }
       }
 
     case 's':
       {
-	const char *val = args(fmt_arg_count++).string_value ();
+	string tstr = args(fmt_arg_count++).string_value ();
+	const char *val = tstr.c_str ();
 
 	if (error_state)
 	  goto invalid_conversion;
 	else
 	  {
 	    chars_from_fmt_str++;
 	    fmt << *s << ends;
 	    char *tmp_fmt = fmt.str ();
 	    sb.form (tmp_fmt, val);
 	    delete [] tmp_fmt;
 	    return chars_from_fmt_str;
 	  }
       }
 
     case 'c':
       {
-	const char *val = args(fmt_arg_count++).string_value ();
+	string tstr = args(fmt_arg_count++).string_value ();
+	const char *val = tstr.c_str ();
 
 	if (error_state || strlen (val) != 1)
 	  goto invalid_conversion;
 	else
 	  {
 	    chars_from_fmt_str++;
 	    fmt << *s << ends;
 	    char *tmp_fmt = fmt.str ();
@@ -983,16 +991,17 @@ process_printf_format (const char *s, co
 // Formatted printing to a file.
 
 static Octave_object
 do_printf (const char *type, const Octave_object& args)
 {
   Octave_object retval;
   fmt_arg_count = 0;
   const char *fmt;
+  string fmt_str;
   file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
       Pix p = file_io_get_file (args(0), "a+", type);
 
       if (! p)
 	return retval;
@@ -1000,29 +1009,31 @@ do_printf (const char *type, const Octav
       file = file_list (p);
 
       if (file.mode () == "r")
 	{
 	  error ("%s: file is read only", type);
 	  return retval;
 	}
 
-      fmt = args(1).string_value ();
+      fmt_str = args(1).string_value ();
+      fmt = fmt_str.c_str ();
 
       if (error_state)
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
 
       fmt_arg_count += 2;
     }
   else
     {
-      fmt = args(0).string_value ();
+      fmt_str = args(0).string_value ();
+      fmt = fmt_str.c_str ();
 
       if (error_state)
 	{
 	  error ("%s: invalid format string", type);
 	  return retval;
 	}
 
       fmt_arg_count++;
@@ -1303,26 +1314,28 @@ process_scanf_format (const char *s, ost
 
 // Formatted reading from a file.
 
 static Octave_object
 do_scanf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
   const char *scanf_fmt = 0;
+  string scanf_fmt_str;
   char *tmp_file = 0;
   int tmp_file_open = 0;
   FILE *fptr = 0;
   file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
-      scanf_fmt = args(1).string_value ();
+      scanf_fmt_str = args(1).string_value (); 
+      scanf_fmt = scanf_fmt_str.c_str ();
 
       if (error_state)
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
     }
 
@@ -1344,57 +1357,64 @@ do_scanf (const char *type, const Octave
 	}
 
       fptr = file.fptr ();
     }
 
   if ((! fptr && args(0).is_string ())
       || (doing_fscanf && file.number () == 0))
     {
-      const char *string;
+      string xstring_str;
+      const char *xstring;
 
       if (strcmp (type, "scanf") == 0)
-	scanf_fmt = args(0).string_value ();
+	{
+	  scanf_fmt_str = args(0).string_value ();
+	  scanf_fmt = scanf_fmt_str.c_str ();
+	}
 
       if (strcmp (type, "scanf") == 0
 	  || (doing_fscanf && file.number () == 0))
 	{
 	  // XXX FIXME XXX -- this should probably be possible for
 	  // more than just stdin/stdout pairs, using a list of output
 	  // streams to flush.  The list could be created with a
 	  // function like iostream's tie().
 
 	  flush_output_to_pager ();
 
-	  string = gnu_readline ("");
-
-	  if (string && *string)
-	    maybe_save_history (string);
+	  xstring = gnu_readline ("");
+
+	  if (xstring && *xstring)
+	    maybe_save_history (xstring);
 	}
       else
-	string = args(0).string_value ();
+	{
+	  xstring_str = args(0).string_value ();
+	  xstring = xstring_str.c_str ();
+	}
 
       tmp_file = octave_tmp_file_name ();
 
       fptr = fopen (tmp_file, "w+");
       if (! fptr)
 	{
 	  error ("%s: error opening temporary file", type);
 	  return retval;
 	}
       tmp_file_open = 1;
       unlink (tmp_file);
 
-      if (! string)
+      if (! xstring)
 	{
 	  error ("%s: no string to scan", type); 
 	  return retval;
 	}
 
-      int success = fputs (string, fptr);
+      int success = fputs (xstring, fptr);
       fflush (fptr);
       rewind (fptr);
 
       if (success < 0)
 	{
 	  error ("%s: trouble writing temporary file", type);
 	  fclose (fptr);
 	  return retval;
@@ -1574,19 +1594,21 @@ fread_internal (const Octave_object& arg
   Pix p = file_io_get_file (args(0), "r", "fread");
 
   if (! p)
     return retval;
 
   // Get type and number of bytes per element to read.
 
   const char *prec = "uchar";
+  string tstr;
   if (nargin > 2)
     {
-      prec = args(2).string_value ();
+      tstr = args(2).string_value ();
+      prec = tstr.c_str ();
 
       if (error_state)
 	{
 	  error ("fread: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
@@ -1761,19 +1783,21 @@ fwrite_internal (const Octave_object& ar
   Pix p = file_io_get_file (args(0), "a+", "fwrite");
 
   if (! p)
     return retval;
 
   // Get type and number of bytes per element to read.
 
   const char *prec = "uchar";
+  string tstr;
   if (nargin > 2)
     {
-      prec = args(2).string_value ();
+      tstr = args(2).string_value ();
+      prec = tstr.c_str ();
 
       if (error_state)
 	{
 	  error ("fwrite: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
@@ -1930,18 +1954,20 @@ popen_internal (const Octave_object& arg
     }
 
   if (! args(1).is_string ())
     {
       error ("popen: file mode must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
-  const char *mode = args(1).string_value ();
+  string tstr1 = args(0).string_value ();
+  const char *name = tstr1.c_str ();
+  string tstr2 = args(1).string_value ();
+  const char *mode = tstr2.c_str ();
 
   if (mode[1] || (mode[0] != 'w' && mode[0] != 'r'))
     {
       error ("popen: invalid mode, must be either \"r\" or \"w\".");
       return retval;
     }
 
   struct stat buffer;
@@ -2053,17 +2079,18 @@ execute_internal (const Octave_object& a
   int new_stdout;
 
   if (! args(0).is_string ())
     {
       error ("execute: file name must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   if (pipe (stdin_pipe) || pipe (stdout_pipe)) 
     {
       error ("execute: pipe creation failed");
       return retval;
     }
 
   pid = fork ();
@@ -2145,17 +2172,18 @@ sync_system_internal (const Octave_objec
   Octave_object retval (1, tree_constant (-1.0));
 
   if (! args(0).is_string ())
     {
       error ("sync_system: file name must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   retval (0) = (double) system (name);
   return retval;
 }
 
 DEFUN ("sync_system", Fsync_system, Ssync_system, 10,
   "RETCODE = sync_system (FILENAME)\n\
 \n\
@@ -2180,17 +2208,18 @@ async_system_internal (const Octave_obje
   pid_t pid;
 
   if (! args(0).is_string ())
     {
       error ("async_system: file name must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   pid = fork ();
 
   if (pid < 0) 
     {
       error ("async_system: fork failed -- can't create child process");
       return retval;
     }
@@ -2313,17 +2342,18 @@ mkfifo_internal (const Octave_object& ar
   Octave_object retval (1, tree_constant (-1.0));
 
   if (! args(0).is_string ())
     {
       error ("mkfifo: file name must be a string");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   if (! args(1).is_scalar_type ())
     {
       error ("mkfifo:  MODE must be an integer");
       return retval;
     }
 
   long mode = (long) args(1).double_value ();
@@ -2362,17 +2392,18 @@ unlink_internal (const Octave_object& ar
 
   if (! args(0).is_string ())
     {
       error ("unlink: file name must be a string");
       retval (0) = -1.0;
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   retval (0) = (double) unlink (name);
 
   return retval;
 }
 
 DEFUN ("unlink", Funlink, Sunlink, 10,
   "STATUS = unlink (NAME)\n\
@@ -2449,17 +2480,18 @@ DEFUN ("stat", Fstat, Sstat, 10,
     blocks  : number of blocks allocated for file\n\
 \n\
   If the file does not exist, -1 is returned.")
 {
   Octave_object retval;
 
   if (args.length () == 1)
     {
-      const char *name = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *name = tstr.c_str ();
 
       static char *fname = 0;
 
       if (fname)
 	free (fname);
 
       fname = tilde_expand (name);
 
@@ -2484,17 +2516,18 @@ DEFUN ("lstat", Flstat, Slstat, 10,
 \n\
   Like stat (NAME), but if NAME refers to a symbolic link, returns\n\
   information about the link itself, not the file that it points to.")
 {
   Octave_object retval;
 
   if (args.length () == 1)
     {
-      const char *name = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *name = tstr.c_str ();
 
       static char *fname = 0;
 
       if (fname)
 	free (fname);
 
       fname = tilde_expand (name);
 
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "NLEqn.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -294,17 +296,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_fsolve_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_fsolve_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -39,16 +39,18 @@ Free Software Foundation, Inc.
 
 #include <ctime>
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
 #include <cassert>
 #include <csignal>
 
+#include <string>
+
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
@@ -1003,19 +1005,21 @@ get_user_input (const Octave_object& arg
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
     read_as_string++;
 
   const char *prompt = "debug> ";
+  string tstr;
   if (nargin > 0)
    {
-     prompt = args(0).string_value ();
+     tstr = args(0).string_value ();
+     prompt = tstr.c_str ();
 
      if (error_state)
        {
 	 error ("input: unrecognized argument");
 	 return retval;
        }
     }
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -25,16 +25,18 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <climits>
 #include <cstring>
 #include <cctype>
 
+#include <string>
+
 #include <iostream.h>
 #include <fstream.h>
 #include <strstream.h>
 
 #include "fnmatch.h"
 
 #include "defun.h"
 #include "error.h"
@@ -2507,19 +2509,19 @@ save_binary_data (ostream& os, const tre
       os.write (&tmp, 1);
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (&nr, 4);
       charMatrix chm = tc.all_strings ();
       for (int i = 0; i < nr; i++)
 	{
 	  FOUR_BYTE_INT len = chm.cols ();
 	  os.write (&len, 4);
-	  const char *tmp = chm.row_as_string (i);
+	  string tstr = chm.row_as_string (i);
+	  const char *tmp = tstr.data ();
 	  os.write (tmp, len);
-	  delete [] tmp;
 	}
     }
   else if (tc.is_range ())
     {
       tmp = 6;
       os.write (&tmp, 1);
       tmp = (char) LS_DOUBLE;
       os.write (&tmp, 1);
@@ -2814,19 +2816,19 @@ save_ascii_data (ostream& os, const tree
       ascii_save_type (os, "string array", mark_as_global);
       charMatrix chm = tc.all_strings ();
       int elements = chm.rows ();
       os << "# elements: " << elements << "\n";
       for (int i = 0; i < elements; i++)
 	{
 	  int len = chm.cols ();
 	  os << "# length: " << len << "\n";
-	  char *tmp = chm.row_as_string (i);
+	  string tstr = chm.row_as_string (i);
+	  char *tmp = tstr.data ();
 	  os.write (tmp, len);
-	  delete [] tmp;
 	  os << "\n";
 	}
     }
   else if (tc.is_range ())
     {
       ascii_save_type (os, "range", mark_as_global);
       Range tmp = tc.range_value ();
       os << "# base, limit, increment\n"
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "ODE.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -309,17 +311,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_lsode_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_lsode_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "NPSOL.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -796,17 +798,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_npsol_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_npsol_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -24,16 +24,18 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cmath>
 #include <cstring>
 
+#include <string>
+
 #include <iostream.h>
 #include <strstream.h>
 
 #include "CMatrix.h"
 #include "Range.h"
 #include "dMatrix.h"
 #include "oct-cmplx.h"
 
@@ -1510,17 +1512,18 @@ octave_print_internal (ostream& os, cons
     {
       int nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       for (int i = 0; i < nstr; i++)
 	{
-	  char *row = chm.row_as_string (i);
+	  string tstr = chm.row_as_string (i);
+	  const char *row = tstr.c_str ();
 
 	  if (pr_as_read_syntax)
 	    {
 	      char *tmp = undo_string_escapes (row);
 
 	      os << "\"" << tmp << "\"";
 
 	      delete [] tmp;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstring>
 
+#include <string>
+
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #include "mx-base.h"
 #include "Range.h"
 
 #include "arith-ops.h"
@@ -1443,26 +1445,27 @@ TC_REP::all_strings (void) const
     return *char_matrix;
   else
     {
       gripe_invalid_conversion (type_as_string (), "string");
       return 0;
     }
 }
 
-const char *
+string
 TC_REP::string_value (void) const
 {
+  string retval;
+
   if (type_tag == char_matrix_constant_str)
-    return char_matrix->row_as_string (0);  // XXX FIXME??? XXX
+    retval = char_matrix->row_as_string (0);  // XXX FIXME??? XXX
   else
-    {
-      gripe_invalid_conversion (type_as_string (), "string");
-      return 0;
-    }
+    gripe_invalid_conversion (type_as_string (), "string");
+
+  return retval;
 }
 
 Range
 TC_REP::range_value (void) const
 {
   assert (type_tag == range_constant);
   return *range;
 }
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -25,16 +25,18 @@ Software Foundation, 59 Temple Place - S
 #define octave_tree_const_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <cstdlib>
 
+#include <string>
+
 #include <iostream.h>
 
 #include "Range.h"
 #include "mx-base.h"
 
 #include "oct-obj.h"
 #include "tree-base.h"
 #include "tree-expr.h"
@@ -210,17 +212,17 @@ private:
 	  }
 
 	double double_value (int frc_str_conv = 0) const;
 	Matrix matrix_value (int frc_str_conv = 0) const;
 	Complex complex_value (int frc_str_conv = 0) const;
 	ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const;
 	charMatrix char_matrix_value (int frc_str_conv = 0) const;
 	charMatrix all_strings (void) const;
-	const char *string_value (void) const;
+        string string_value (void) const;
 	Range range_value (void) const;
 	Octave_map map_value (void) const;
 
 	tree_constant& lookup_map_element (const char *name, int insert = 0,
 					   int silent = 0);
 
 	ColumnVector vector_value (int frc_str_conv = 0,
 				   int frc_vec_conv = 0) const;
@@ -541,17 +543,17 @@ public:
     { return rep->complex_matrix_value (frc_str_conv); }
 
   charMatrix char_matrix_value (int frc_str_conv = 0) const
     { return rep->char_matrix_value (frc_str_conv); }
 
   charMatrix all_strings (void) const
     { return rep->all_strings (); }
 
-  const char *string_value (void) const
+  string string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
   Octave_map map_value (void) const;
 
   tree_constant lookup_map_element (const char *ref, int insert = 0,
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -26,16 +26,18 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstring>
 
+#include <string>
+
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
@@ -726,17 +728,19 @@ subplot::handle_plot_data (int ndim, ost
 	  if (data.is_string ())
 	    {
 	      // Should really try to look at data file to determine
 	      // n_max.  Can't do much about other arbitrary gnuplot
 	      // commands though...
 
 	      int n_max = 0;
 
-	      file = tilde_expand (data.string_value ());
+	      string tstr = data.string_value ();
+
+	      file = tilde_expand (tstr.c_str ());
 	      ifstream ftmp (file);
 	      if (ftmp)
 		{
 		  plot_buf << " \"" << file << '"';
 		  free (file);
 		}
 	      else
 		{
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "QPSOL.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -411,17 +413,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_qpsol_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_qpsol_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include <strstream.h>
 
 #include "Quad.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
@@ -366,17 +368,18 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_quad_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      const char *keyword = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *keyword = tstr.c_str ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_quad_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -22,16 +22,18 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <ctime>
 
+#include <string>
+
 #include "f77-uscore.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "unwind-prot.h"
@@ -164,17 +166,18 @@ do_rand (const Octave_object& args, int 
       goto gen_matrix;
     }
   else if (nargin == 1)
     {
       tree_constant tmp = args(0);
 
       if (tmp.is_string ())
 	{
-	  const char *s_arg = tmp.string_value ();
+	  string tstr = tmp.string_value ();
+	  const char *s_arg = tstr.c_str ();
 
 	  if (strcmp (s_arg, "dist") == 0)
 	    {
 	      char *s = curr_rand_dist ();
 	      retval(0) = s;
 	    }
 	  else if (strcmp (s_arg, "seed") == 0)
 	    {
@@ -250,23 +253,27 @@ do_rand (const Octave_object& args, int 
       else
 	{
 	  gripe_wrong_type_arg ("rand", tmp);
 	  return retval;
 	}
     }
   else if (nargin == 2)
     {
-      if (args(0).is_string ()
-	  && strcmp (args(0).string_value (), "seed") == 0)
+      if (args(0).is_string ())
 	{
-	  double d = args(1).double_value ();
+	  string tstr = args(0).string_value ();
 
-	  if (! error_state)
-	    set_rand_seed (d);
+	  if (strcmp (tstr.c_str (), "seed") == 0)
+	    {
+	      double d = args(1).double_value ();
+
+	      if (! error_state)
+		set_rand_seed (d);
+	    }
 	}
       else
 	{
 	  double dval = args(0).double_value ();
 
 	  if (xisnan (dval))
 	    {
 	      error ("rand: NaN is invalid as a matrix dimension");
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include "CmplxSCHUR.h"
 #include "dbleSCHUR.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
@@ -57,19 +59,22 @@ characters:\n\
     {
       print_usage ("schur");
       return retval;
     }
 
   tree_constant arg = args(0);
 
   const char *ord = "U";
+  string tstr;
+
   if (nargin == 2)
     {
-      ord = args(1).string_value ();
+      tstr = args(1).string_value (); 
+      ord = tstr.c_str ();
 
       if (error_state)
 	{
 	  error ("schur: expecting string as second argument");
 	  return retval;
 	}
     }
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -35,16 +35,18 @@ Software Foundation, Inc.
 
 #include <cfloat>
 #include <cmath>
 #include <cstddef>
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
 
+#include <string>
+
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #if defined (HAVE_TERMIOS_H)
 #include <termios.h>
 #elif defined (HAVE_TERMIO_H)
@@ -536,17 +538,18 @@ DEFUN ("getenv", Fgetenv, Sgetenv, 10,
   "getenv (STRING): get environment variable values")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      const char *name = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *name = tstr.c_str ();
 
       if (! error_state)
 	{
 	  char *value = getenv (name);
 	  if (value)
 	    retval = value;
 	  else
 	    retval = "";
@@ -562,21 +565,23 @@ DEFUN ("putenv", Fputenv, Sputenv, 10,
   "putenv (VAR, VALUE): define environment variable VAR=VALUE")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      const char *var = args(0).string_value (); 
+      string tstr1 = args(0).string_value (); 
+      const char *var = tstr1.c_str ();
 
       if (! error_state)
 	{
-	  const char *val = args(1).string_value (); 
+	  string tstr2 = args(1).string_value (); 
+	  const char *val = tstr2.c_str ();
 
 	  if (! error_state)
 	    oct_putenv (var, val);
 	  else
 	    error ("putenv: second argument should be a string");
 	}
       else
 	error ("putenv: first argument should be a string");
diff --git a/src/timefns.cc b/src/timefns.cc
--- a/src/timefns.cc
+++ b/src/timefns.cc
@@ -20,16 +20,18 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <string>
+
 #include "defun.h"
 #include "help.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "systime.h"
 #include "tree-const.h"
 #include "utils.h"
 
@@ -75,17 +77,18 @@ extract_tm (Octave_map &m, double& fract
   tm.tm_hour = NINT (m ["hour"] . double_value ());
   tm.tm_mday = NINT (m ["mday"] . double_value ());
   tm.tm_mon = NINT (m ["mon"] . double_value ());
   tm.tm_year = NINT (m ["year"] . double_value ());
   tm.tm_wday = NINT (m ["wday"] . double_value ());
   tm.tm_yday = NINT (m ["yday"] . double_value ());
   tm.tm_isdst = NINT (m ["isdst"] . double_value ());
 #ifdef HAVE_TMZONE
-  tm.tm_zone = (m ["zone"] . string_value ());
+  string tstr = m ["zone"] . string_value ();
+  tm.tm_zone = tstr.c_str ();
 #endif
 
   return &tm;
 }
 
 DEFUN ("time", Ftime, Stime, 00,
   "time ()\n\
 \n\
@@ -267,17 +270,18 @@ DEFUN ("strftime", Fstrftime, Sstrftime,
     %x	locale's date representation (mm/dd/yy)\n\
     %y	last two digits of year (00..99)\n\
     %Y	year (1970...)")
 {
   Octave_object retval;
 
   if (args.length () == 2 && args(0).is_string () && args(1).is_map ()) 
     {
-      const char *fmt = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *fmt = tstr.c_str ();
       Octave_map map = args(1).map_value ();
 
       double fraction;
 
       struct tm *tm = extract_tm (map, fraction);
 
       if (! error_state)
 	{
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 
 #include <cassert>
 #include <csetjmp>
 #include <csignal>
 #include <cstdlib>
 #include <cstring>
 #include <ctime>
 
+#include <string>
+
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
@@ -226,17 +228,18 @@ Parse and execute the contents of FILE. 
 script file but without requiring the file to be named `FILE.m'.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      const char *file = args(0).string_value ();
+      string tstr = args(0).string_value ();
+      const char *file = tstr.c_str ();
 
       if (! error_state)
 	{
 	  file = tilde_expand (file);
 
 	  parse_and_execute (file, 1, 0, "source");
 
 	  if (error_state)
@@ -486,17 +489,18 @@ eval_string (const char *string, int pri
   retval = tmp(0);
 
   return retval;
 }
 
 static Octave_object
 eval_string (const tree_constant& arg, int& parse_status, int nargout)
 {
-  const char *string = arg.string_value ();
+  string tstr = arg.string_value ();
+  const char *string = tstr.c_str ();
 
   if (error_state)
     {
       error ("eval: expecting string argument");
       return -1.0;
     }
 
   // Yes Virginia, we always print here...
@@ -564,17 +568,18 @@ DEFUN ("system", Fsystem, Ssystem, 11,
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("system");
       return retval;
     }
 
   tree_constant tc_command = args(0);
 
-  const char *tmp_str = tc_command.string_value ();
+  string tstr = tc_command.string_value ();
+  const char *tmp_str = tstr.c_str ();
 
   if (error_state)
     {
       error ("system: expecting string as first argument");
     }
   else
     {
       iprocstream *cmd = new iprocstream (tmp_str);
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -24,16 +24,18 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <climits>
 #include <csetjmp>
 #include <cstring>
 
+#include <string>
+
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
@@ -517,17 +519,20 @@ make_argv (const Octave_object& args, co
 {
   char **argv = 0;
   if (all_strings (args))
     {
       int n = args.length ();
       argv = new char * [n + 1];
       argv[0] = strsave (fcn_name);
       for (int i = 0; i < n; i++)
-	argv[i+1] = strsave (args(i).string_value ());
+	{
+	  string tstr = args(i).string_value ();
+	  argv[i+1] = strsave (tstr.c_str ());
+	}
     }
   else
     error ("%s: expecting all arguments to be strings", fcn_name);
 
   return argv;
 }
 
 // Return non-zero if either NR or NC is zero.  Return -1 if this
@@ -793,17 +798,18 @@ DEFUN ("undo_string_escapes", Fundo_stri
   "undo_string_escapes (STRING)")
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     {
-      char *str = undo_string_escapes (args(0).string_value ());
+      string tstr = args(0).string_value ();
+      char *str = undo_string_escapes (tstr.c_str ());
       retval = str;
       delete [] str;
     }
   else
     print_usage ("undo_string_escapes");
 
   return retval;
 }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -24,16 +24,18 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cstdio>
 #include <cstring>
 
+#include <string>
+
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include <readline/readline.h>
@@ -124,18 +126,23 @@ is_globally_visible (const char *name)
 
 tree_fvc *
 is_valid_function (const tree_constant& arg, char *warn_for, int warn)
 {
   tree_fvc *ans = 0;
 
   const char *fcn_name = 0;
 
+  string tstr;
+
   if (arg.is_string ())
-    fcn_name = arg.string_value ();
+    {
+      tstr = arg.string_value ();
+      fcn_name = tstr.c_str ();
+    }
 
   if (! fcn_name || error_state)
     {
       if (warn)
 	error ("%s: expecting function name as argument", warn_for);
       return ans;
     }
 
@@ -166,17 +173,18 @@ otherwise, return 0.")
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("is_global");
       return retval;
     }
 
-  const char *name = args(0).string_value ();
+  string tstr = args(0).string_value ();
+  const char *name = tstr.c_str ();
 
   if (error_state)
     {
       error ("is_global: expecting string argument");
       return retval;
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
@@ -202,17 +210,18 @@ returns:\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
 
-  char *name = strsave (args(0).string_value ());
+  string tstr = args(0).string_value ();
+  char *name = strsave (tstr.c_str ());
 
   if (error_state)
     {
       error ("exist: expecting string argument");
       delete [] name;
       return retval;
     }
 
@@ -923,17 +932,18 @@ builtin_string_variable (const char *nam
   tree_fvc *defn = sr->def ();
 
   if (defn)
     {
       tree_constant val = defn->eval (0);
 
       if (! error_state && val.is_string ())
 	{
-	  const char *s = val.string_value ();
+	  string tstr = val.string_value ();
+	  const char *s = tstr.c_str ();
 
 	  if (s)
 	    retval = strsave (s);
 	}
     }
 
   return retval;
 }
