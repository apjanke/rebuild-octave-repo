# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449253019 18000
#      Fri Dec 04 13:16:59 2015 -0500
# Node ID a6eaedd8bd7548d4a495019f85c4337153d8ef8c
# Parent  c22206c1a88fbf11bdb6c9dfbfb2840a1ff09247
eliminate return statements after calls to print_usage

* bitfcns.cc, cellfun.cc, debug.cc, dirfns.cc, strfns.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -151,219 +151,215 @@ bitop_arg_is_float (const octave_value& 
   return arg.class_name () == octave_float_scalar::static_class_name ();
 }
 
 octave_value
 bitop (const std::string& fname, const octave_value_list& args)
 {
   octave_value retval;
 
-  int nargin = args.length ();
+  if (args.length () != 2)
+    print_usage ();
 
-  if (nargin == 2)
+  if (args(0).class_name () == octave_scalar::static_class_name ()
+      || args(0).class_name () == octave_float_scalar::static_class_name ()
+      || args(0).class_name () == octave_bool::static_class_name ()
+      || args(1).class_name () == octave_scalar::static_class_name ()
+      || args(1).class_name () == octave_float_scalar::static_class_name ()
+      || args(1).class_name () == octave_bool::static_class_name ())
     {
-      if (args(0).class_name () == octave_scalar::static_class_name ()
-          || args(0).class_name () == octave_float_scalar::static_class_name ()
-          || args(0).class_name () == octave_bool::static_class_name ()
-          || args(1).class_name () == octave_scalar::static_class_name ()
-          || args(1).class_name () == octave_float_scalar::static_class_name ()
-          || args(1).class_name () == octave_bool::static_class_name ())
-        {
-          bool arg0_is_int = bitop_arg_is_int (args(0));
-          bool arg1_is_int = bitop_arg_is_int (args(1));
+      bool arg0_is_int = bitop_arg_is_int (args(0));
+      bool arg1_is_int = bitop_arg_is_int (args(1));
 
-          bool arg0_is_bool = bitop_arg_is_bool (args(0));
-          bool arg1_is_bool = bitop_arg_is_bool (args(1));
-
-          bool arg0_is_float = bitop_arg_is_float (args(0));
-          bool arg1_is_float = bitop_arg_is_float (args(1));
+      bool arg0_is_bool = bitop_arg_is_bool (args(0));
+      bool arg1_is_bool = bitop_arg_is_bool (args(1));
 
-          if (! (arg0_is_int || arg1_is_int))
-            {
-              if (arg0_is_bool && arg1_is_bool)
-                {
-                  boolNDArray x (args(0).bool_array_value ());
-                  boolNDArray y (args(1).bool_array_value ());
+      bool arg0_is_float = bitop_arg_is_float (args(0));
+      bool arg1_is_float = bitop_arg_is_float (args(1));
 
-                  retval = bitopx (fname, x, y).bool_array_value ();
-                }
-              else if (arg0_is_float && arg1_is_float)
-                {
-                  uint64NDArray x (args(0).float_array_value ());
-                  uint64NDArray y (args(1).float_array_value ());
+      if (! (arg0_is_int || arg1_is_int))
+        {
+          if (arg0_is_bool && arg1_is_bool)
+            {
+              boolNDArray x (args(0).bool_array_value ());
+              boolNDArray y (args(1).bool_array_value ());
 
-                  retval = bitopx (fname, x, y).float_array_value ();
-                }
-              else if (! (arg0_is_float || arg1_is_float))
-                {
-                  uint64NDArray x (args(0).array_value ());
-                  uint64NDArray y (args(1).array_value ());
+              retval = bitopx (fname, x, y).bool_array_value ();
+            }
+          else if (arg0_is_float && arg1_is_float)
+            {
+              uint64NDArray x (args(0).float_array_value ());
+              uint64NDArray y (args(1).float_array_value ());
 
-                  retval = bitopx (fname, x, y).array_value ();
-                }
-              else
-                {
-                  int p = (arg0_is_float ? 1 : 0);
-                  int q = (arg0_is_float ? 0 : 1);
+              retval = bitopx (fname, x, y).float_array_value ();
+            }
+          else if (! (arg0_is_float || arg1_is_float))
+            {
+              uint64NDArray x (args(0).array_value ());
+              uint64NDArray y (args(1).array_value ());
 
-                  uint64NDArray x (args(p).array_value ());
-                  uint64NDArray y (args(q).float_array_value ());
-
-                  retval = bitopx (fname, x, y).float_array_value ();
-                }
+              retval = bitopx (fname, x, y).array_value ();
             }
           else
             {
-              int p = (arg0_is_int ? 1 : 0);
-              int q = (arg0_is_int ? 0 : 1);
-
-              NDArray dx = args(p).array_value ();
-
-              if (args(q).type_id () == octave_uint64_matrix::static_type_id ()
-                  || args(q).type_id () == octave_uint64_scalar::static_type_id ())
-                {
-                  uint64NDArray x (dx);
-                  uint64NDArray y = args(q).uint64_array_value ();
-
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_uint32_matrix::static_type_id ()
-                       || args(q).type_id () == octave_uint32_scalar::static_type_id ())
-                {
-                  uint32NDArray x (dx);
-                  uint32NDArray y = args(q).uint32_array_value ();
-
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_uint16_matrix::static_type_id ()
-                       || args(q).type_id () == octave_uint16_scalar::static_type_id ())
-                {
-                  uint16NDArray x (dx);
-                  uint16NDArray y = args(q).uint16_array_value ();
-
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_uint8_matrix::static_type_id ()
-                       || args(q).type_id () == octave_uint8_scalar::static_type_id ())
-                {
-                  uint8NDArray x (dx);
-                  uint8NDArray y = args(q).uint8_array_value ();
+              int p = (arg0_is_float ? 1 : 0);
+              int q = (arg0_is_float ? 0 : 1);
 
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_int64_matrix::static_type_id ()
-                       || args(q).type_id () == octave_int64_scalar::static_type_id ())
-                {
-                  int64NDArray x (dx);
-                  int64NDArray y = args(q).int64_array_value ();
-
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_int32_matrix::static_type_id ()
-                       || args(q).type_id () == octave_int32_scalar::static_type_id ())
-                {
-                  int32NDArray x (dx);
-                  int32NDArray y = args(q).int32_array_value ();
+              uint64NDArray x (args(p).array_value ());
+              uint64NDArray y (args(q).float_array_value ());
 
-                  retval = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_int16_matrix::static_type_id ()
-                       || args(q).type_id () == octave_int16_scalar::static_type_id ())
-                {
-                  int16NDArray x (dx);
-                  int16NDArray y = args(q).int16_array_value ();
-
-                  retval  = bitopx (fname, x, y);
-                }
-              else if (args(q).type_id () == octave_int8_matrix::static_type_id ()
-                       || args(q).type_id () == octave_int8_scalar::static_type_id ())
-                {
-                  int8NDArray x (dx);
-                  int8NDArray y = args(q).int8_array_value ();
-
-                  retval = bitopx (fname, x, y);
-                }
-              else
-                error ("%s: invalid operand type", fname.c_str ());
+              retval = bitopx (fname, x, y).float_array_value ();
             }
         }
-      else if (args(0).class_name () == args(1).class_name ())
+      else
         {
-          if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
-              || args(0).type_id () == octave_uint64_scalar::static_type_id ())
+          int p = (arg0_is_int ? 1 : 0);
+          int q = (arg0_is_int ? 0 : 1);
+
+          NDArray dx = args(p).array_value ();
+
+          if (args(q).type_id () == octave_uint64_matrix::static_type_id ()
+              || args(q).type_id () == octave_uint64_scalar::static_type_id ())
             {
-              uint64NDArray x = args(0).uint64_array_value ();
-              uint64NDArray y = args(1).uint64_array_value ();
+              uint64NDArray x (dx);
+              uint64NDArray y = args(q).uint64_array_value ();
+
+              retval = bitopx (fname, x, y);
+            }
+          else if (args(q).type_id () == octave_uint32_matrix::static_type_id ()
+                   || args(q).type_id () == octave_uint32_scalar::static_type_id ())
+            {
+              uint32NDArray x (dx);
+              uint32NDArray y = args(q).uint32_array_value ();
 
               retval = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_uint32_matrix::static_type_id ()
-                   || args(0).type_id () == octave_uint32_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_uint16_matrix::static_type_id ()
+                   || args(q).type_id () == octave_uint16_scalar::static_type_id ())
             {
-              uint32NDArray x = args(0).uint32_array_value ();
-              uint32NDArray y = args(1).uint32_array_value ();
+              uint16NDArray x (dx);
+              uint16NDArray y = args(q).uint16_array_value ();
 
               retval = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_uint16_matrix::static_type_id ()
-                   || args(0).type_id () == octave_uint16_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_uint8_matrix::static_type_id ()
+                   || args(q).type_id () == octave_uint8_scalar::static_type_id ())
             {
-              uint16NDArray x = args(0).uint16_array_value ();
-              uint16NDArray y = args(1).uint16_array_value ();
-
-              retval = bitopx (fname, x, y);
-            }
-          else if (args(0).type_id () == octave_uint8_matrix::static_type_id ()
-                   || args(0).type_id () == octave_uint8_scalar::static_type_id ())
-            {
-              uint8NDArray x = args(0).uint8_array_value ();
-              uint8NDArray y = args(1).uint8_array_value ();
+              uint8NDArray x (dx);
+              uint8NDArray y = args(q).uint8_array_value ();
 
               retval = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_int64_matrix::static_type_id ()
-                   || args(0).type_id () == octave_int64_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_int64_matrix::static_type_id ()
+                   || args(q).type_id () == octave_int64_scalar::static_type_id ())
             {
-              int64NDArray x = args(0).int64_array_value ();
-              int64NDArray y = args(1).int64_array_value ();
+              int64NDArray x (dx);
+              int64NDArray y = args(q).int64_array_value ();
 
               retval = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_int32_matrix::static_type_id ()
-                   || args(0).type_id () == octave_int32_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_int32_matrix::static_type_id ()
+                   || args(q).type_id () == octave_int32_scalar::static_type_id ())
             {
-              int32NDArray x = args(0).int32_array_value ();
-              int32NDArray y = args(1).int32_array_value ();
+              int32NDArray x (dx);
+              int32NDArray y = args(q).int32_array_value ();
 
               retval = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_int16_matrix::static_type_id ()
-                   || args(0).type_id () == octave_int16_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_int16_matrix::static_type_id ()
+                   || args(q).type_id () == octave_int16_scalar::static_type_id ())
             {
-              int16NDArray x = args(0).int16_array_value ();
-              int16NDArray y = args(1).int16_array_value ();
+              int16NDArray x (dx);
+              int16NDArray y = args(q).int16_array_value ();
 
-              retval = bitopx (fname, x, y);
+              retval  = bitopx (fname, x, y);
             }
-          else if (args(0).type_id () == octave_int8_matrix::static_type_id ()
-                   || args(0).type_id () == octave_int8_scalar::static_type_id ())
+          else if (args(q).type_id () == octave_int8_matrix::static_type_id ()
+                   || args(q).type_id () == octave_int8_scalar::static_type_id ())
             {
-              int8NDArray x = args(0).int8_array_value ();
-              int8NDArray y = args(1).int8_array_value ();
+              int8NDArray x (dx);
+              int8NDArray y = args(q).int8_array_value ();
 
               retval = bitopx (fname, x, y);
             }
           else
             error ("%s: invalid operand type", fname.c_str ());
         }
+    }
+  else if (args(0).class_name () == args(1).class_name ())
+    {
+      if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
+          || args(0).type_id () == octave_uint64_scalar::static_type_id ())
+        {
+          uint64NDArray x = args(0).uint64_array_value ();
+          uint64NDArray y = args(1).uint64_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_uint32_matrix::static_type_id ()
+               || args(0).type_id () == octave_uint32_scalar::static_type_id ())
+        {
+          uint32NDArray x = args(0).uint32_array_value ();
+          uint32NDArray y = args(1).uint32_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_uint16_matrix::static_type_id ()
+               || args(0).type_id () == octave_uint16_scalar::static_type_id ())
+        {
+          uint16NDArray x = args(0).uint16_array_value ();
+          uint16NDArray y = args(1).uint16_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_uint8_matrix::static_type_id ()
+               || args(0).type_id () == octave_uint8_scalar::static_type_id ())
+        {
+          uint8NDArray x = args(0).uint8_array_value ();
+          uint8NDArray y = args(1).uint8_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_int64_matrix::static_type_id ()
+               || args(0).type_id () == octave_int64_scalar::static_type_id ())
+        {
+          int64NDArray x = args(0).int64_array_value ();
+          int64NDArray y = args(1).int64_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_int32_matrix::static_type_id ()
+               || args(0).type_id () == octave_int32_scalar::static_type_id ())
+        {
+          int32NDArray x = args(0).int32_array_value ();
+          int32NDArray y = args(1).int32_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_int16_matrix::static_type_id ()
+               || args(0).type_id () == octave_int16_scalar::static_type_id ())
+        {
+          int16NDArray x = args(0).int16_array_value ();
+          int16NDArray y = args(1).int16_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
+      else if (args(0).type_id () == octave_int8_matrix::static_type_id ()
+               || args(0).type_id () == octave_int8_scalar::static_type_id ())
+        {
+          int8NDArray x = args(0).int8_array_value ();
+          int8NDArray y = args(1).int8_array_value ();
+
+          retval = bitopx (fname, x, y);
+        }
       else
-        error ("%s: must have matching operand types", fname.c_str ());
+        error ("%s: invalid operand type", fname.c_str ());
     }
   else
-    print_usage ();
+    error ("%s: must have matching operand types", fname.c_str ());
 
   return retval;
 }
 
 DEFUN (bitand, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of non-negative integers.\n\
@@ -565,92 +561,90 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 @end example\n\
 @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, intmax, flintmax}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
-    {
-      int nbits = 64;
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  int nbits = 64;
+
+  NDArray n = args(1).xarray_value ("bitshift: K must be a scalar or array of integers");
 
-      NDArray n = args(1).xarray_value ("bitshift: K must be a scalar or array of integers");
-
-      if (nargin == 3)
+  if (nargin == 3)
+    {
+      // FIXME: for compatibility, we should accept an array
+      // or a scalar as the third argument.
+      if (args(2).numel () > 1)
+        error ("bitshift: N must be a scalar integer");
+      else
         {
-          // FIXME: for compatibility, we should accept an array
-          // or a scalar as the third argument.
-          if (args(2).numel () > 1)
-            error ("bitshift: N must be a scalar integer");
-          else
-            {
-              nbits = args(2).xint_value ("bitshift: N must be an integer");
+          nbits = args(2).xint_value ("bitshift: N must be an integer");
 
-              if (nbits < 0)
-                error ("bitshift: N must be positive");
-            }
+          if (nbits < 0)
+            error ("bitshift: N must be positive");
         }
+    }
 
-      octave_value m_arg = args(0);
-      std::string cname = m_arg.class_name ();
+  octave_value m_arg = args(0);
+  std::string cname = m_arg.class_name ();
 
-      if (cname == "uint8")
-        DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
-      else if (cname == "uint16")
-        DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
-      else if (cname == "uint32")
-        DO_UBITSHIFT (uint32, nbits < 32 ? nbits : 32);
-      else if (cname == "uint64")
-        DO_UBITSHIFT (uint64, nbits < 64 ? nbits : 64);
-      else if (cname == "int8")
-        DO_SBITSHIFT (int8, nbits < 8 ? nbits : 8);
-      else if (cname == "int16")
-        DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
-      else if (cname == "int32")
-        DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
-      else if (cname == "int64")
-        DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
-      else if (cname == "double")
-        {
-          static const int bits_in_mantissa
-            = std::numeric_limits<double>::digits;
+  if (cname == "uint8")
+    DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
+  else if (cname == "uint16")
+    DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
+  else if (cname == "uint32")
+    DO_UBITSHIFT (uint32, nbits < 32 ? nbits : 32);
+  else if (cname == "uint64")
+    DO_UBITSHIFT (uint64, nbits < 64 ? nbits : 64);
+  else if (cname == "int8")
+    DO_SBITSHIFT (int8, nbits < 8 ? nbits : 8);
+  else if (cname == "int16")
+    DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
+  else if (cname == "int32")
+    DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
+  else if (cname == "int64")
+    DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
+  else if (cname == "double")
+    {
+      static const int bits_in_mantissa
+        = std::numeric_limits<double>::digits;
 
-          nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
-          int64_t mask = max_mantissa_value<double> ();
-          if (nbits < bits_in_mantissa)
-            mask = mask >> (bits_in_mantissa - nbits);
-          else if (nbits < 1)
-            mask = 0;
-          int bits_in_type = sizeof (double)
-                             * std::numeric_limits<unsigned char>::digits;
-          NDArray m = m_arg.array_value ();
-          DO_BITSHIFT ();
-        }
-      else if (cname == "single")
-        {
-          static const int bits_in_mantissa
-            = std::numeric_limits<float>::digits;
-          nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
-          int64_t mask = max_mantissa_value<float> ();
-          if (nbits < bits_in_mantissa)
-            mask = mask >> (bits_in_mantissa - nbits);
-          else if (nbits < 1)
-            mask = 0;
-          int bits_in_type = sizeof (float)
-                             * std::numeric_limits<unsigned char>::digits;
-          FloatNDArray m = m_arg.float_array_value ();
-          DO_BITSHIFT (Float);
-        }
-      else
-        error ("bitshift: not defined for %s objects", cname.c_str ());
+      nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
+      int64_t mask = max_mantissa_value<double> ();
+      if (nbits < bits_in_mantissa)
+        mask = mask >> (bits_in_mantissa - nbits);
+      else if (nbits < 1)
+        mask = 0;
+      int bits_in_type = sizeof (double)
+        * std::numeric_limits<unsigned char>::digits;
+      NDArray m = m_arg.array_value ();
+      DO_BITSHIFT ();
+    }
+  else if (cname == "single")
+    {
+      static const int bits_in_mantissa
+        = std::numeric_limits<float>::digits;
+      nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
+      int64_t mask = max_mantissa_value<float> ();
+      if (nbits < bits_in_mantissa)
+        mask = mask >> (bits_in_mantissa - nbits);
+      else if (nbits < 1)
+        mask = 0;
+      int bits_in_type = sizeof (float)
+        * std::numeric_limits<unsigned char>::digits;
+      FloatNDArray m = m_arg.float_array_value ();
+      DO_BITSHIFT (Float);
     }
   else
-    print_usage ();
+    error ("bitshift: not defined for %s objects", cname.c_str ());
 
   return retval;
 }
 
 /*
 %!assert (bitshift (uint8  (16), 1),  uint8 ( 32))
 %!assert (bitshift (uint16 (16), 2), uint16 ( 64))
 %!assert (bitshift (uint32 (16), 3), uint32 (128))
@@ -673,26 +667,26 @@ floating point value.\n\
 \n\
 The default class is @qcode{\"double\"}, but @qcode{\"single\"} is a valid\n\
 option.  On IEEE 754 compatible systems, @code{flintmax} is @w{@math{2^{53}}}\n\
 for @qcode{\"double\"} and @w{@math{2^{24}}} for @qcode{\"single\"}.\n\
 @seealso{intmax, realmax, realmin}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   std::string cname = "double";
+
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_string ())
-    cname = args(0).string_value ();
-  else if (nargin != 0)
-    {
-      print_usage ();
-      return retval;
-    }
+  if (nargin > 1)
+    print_usage ();
+
+  if (nargin == 1)
+    cname = args(0).xstring_value ("flintmax: argument must be a string");
 
   if (cname == "double")
     retval = (static_cast<double> (max_mantissa_value<double> () + 1));
   else if (cname == "single")
     retval = (static_cast<float> (max_mantissa_value<float> () + 1));
   else
     error ("flintmax: not defined for class '%s'", cname.c_str ());
 
@@ -732,26 +726,26 @@ unsigned 32-bit integer.\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{int32}.\n\
 @seealso{intmin, flintmax}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   std::string cname = "int32";
+
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_string ())
-    cname = args(0).string_value ();
-  else if (nargin != 0)
-    {
-      print_usage ();
-      return retval;
-    }
+  if (nargin > 1)
+    print_usage ();
+
+  if (nargin == 1)
+    cname = args(0).xstring_value ("intmax: argument must be a string");
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::max ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<uint16_t>::max ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::max ());
   else if (cname == "uint64")
@@ -803,26 +797,26 @@ unsigned 32-bit integer.\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{int32}.\n\
 @seealso{intmax, flintmax}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   std::string cname = "int32";
+
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_string ())
-    cname = args(0).string_value ();
-  else if (nargin != 0)
-    {
-      print_usage ();
-      return retval;
-    }
+  if (nargin > 1)
+    print_usage ();
+
+  if (nargin == 1)
+    cname = args(0).xstring_value ("intmin: argument must be a string");
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::min ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<uint16_t>::min ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::min ());
   else if (cname == "uint64")
@@ -848,17 +842,13 @@ Return the largest value allowed for the
 \n\
 If Octave is compiled with 64-bit indexing, the result is of class int64,\n\
 otherwise it is of class int32.  The maximum array size is slightly\n\
 smaller than the maximum value allowable for the relevant class as reported\n\
 by @code{intmax}.\n\
 @seealso{intmax}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    retval = octave_int<octave_idx_type> (dim_vector::dim_max ());
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_int<octave_idx_type> (dim_vector::dim_max ()));
 }
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -411,30 +411,22 @@ v = cellfun (@@det, a); # faster\n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
-    {
-      error ("cellfun: function requires at least 2 arguments");
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value func = args(0);
 
   if (! args(1).is_cell ())
-    {
-      error ("cellfun: C must be a cell array");
-
-      return retval;
-    }
+    error ("cellfun: C must be a cell array");
 
   if (func.is_string ())
     {
       retval = try_cellfun_internal_ops<boolNDArray,NDArray>(args, nargin);
 
       if (! retval.empty ())
         return retval;
 
@@ -1162,22 +1154,17 @@ arrayfun (@@str2num, [1234],\n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
-    {
-      error_with_id ("Octave:invalid-fun-call",
-                     "arrayfun: function requires at least 2 arguments");
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value func = args(0);
   bool symbol_table_lookup = false;
 
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
 
@@ -1850,77 +1837,78 @@ num2cell ([1,2;3,4],1)\n\
            4\n\
       @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   int nargin =  args.length ();
-  octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  else
+
+  octave_value array = args(0);
+
+  Array<int> dimv;
+
+  if (nargin > 1)
+    dimv = args(1).int_vector_value (true);
+
+  if (array.is_bool_type ())
+    retval = do_num2cell (array.bool_array_value (), dimv);
+  else if (array.is_char_matrix ())
+    retval = do_num2cell (array.char_array_value (), dimv);
+  else if (array.is_numeric_type ())
     {
-      octave_value array = args(0);
-      Array<int> dimv;
-      if (nargin > 1)
-        dimv = args(1).int_vector_value (true);
-
-      if (array.is_bool_type ())
-        retval = do_num2cell (array.bool_array_value (), dimv);
-      else if (array.is_char_matrix ())
-        retval = do_num2cell (array.char_array_value (), dimv);
-      else if (array.is_numeric_type ())
+      if (array.is_integer_type ())
         {
-          if (array.is_integer_type ())
-            {
-              if (array.is_int8_type ())
-                retval = do_num2cell (array.int8_array_value (), dimv);
-              else if (array.is_int16_type ())
-                retval = do_num2cell (array.int16_array_value (), dimv);
-              else if (array.is_int32_type ())
-                retval = do_num2cell (array.int32_array_value (), dimv);
-              else if (array.is_int64_type ())
-                retval = do_num2cell (array.int64_array_value (), dimv);
-              else if (array.is_uint8_type ())
-                retval = do_num2cell (array.uint8_array_value (), dimv);
-              else if (array.is_uint16_type ())
-                retval = do_num2cell (array.uint16_array_value (), dimv);
-              else if (array.is_uint32_type ())
-                retval = do_num2cell (array.uint32_array_value (), dimv);
-              else if (array.is_uint64_type ())
-                retval = do_num2cell (array.uint64_array_value (), dimv);
-            }
-          else if (array.is_complex_type ())
-            {
-              if (array.is_single_type ())
-                retval = do_num2cell (array.float_complex_array_value (), dimv);
-              else
-                retval = do_num2cell (array.complex_array_value (), dimv);
-            }
+          if (array.is_int8_type ())
+            retval = do_num2cell (array.int8_array_value (), dimv);
+          else if (array.is_int16_type ())
+            retval = do_num2cell (array.int16_array_value (), dimv);
+          else if (array.is_int32_type ())
+            retval = do_num2cell (array.int32_array_value (), dimv);
+          else if (array.is_int64_type ())
+            retval = do_num2cell (array.int64_array_value (), dimv);
+          else if (array.is_uint8_type ())
+            retval = do_num2cell (array.uint8_array_value (), dimv);
+          else if (array.is_uint16_type ())
+            retval = do_num2cell (array.uint16_array_value (), dimv);
+          else if (array.is_uint32_type ())
+            retval = do_num2cell (array.uint32_array_value (), dimv);
+          else if (array.is_uint64_type ())
+            retval = do_num2cell (array.uint64_array_value (), dimv);
+        }
+      else if (array.is_complex_type ())
+        {
+          if (array.is_single_type ())
+            retval = do_num2cell (array.float_complex_array_value (), dimv);
           else
-            {
-              if (array.is_single_type ())
-                retval = do_num2cell (array.float_array_value (), dimv);
-              else
-                retval = do_num2cell (array.array_value (), dimv);
-            }
+            retval = do_num2cell (array.complex_array_value (), dimv);
+        }
+      else
+        {
+          if (array.is_single_type ())
+            retval = do_num2cell (array.float_array_value (), dimv);
+          else
+            retval = do_num2cell (array.array_value (), dimv);
         }
-      else if (array.is_object ())
-        retval = do_object2cell (array, dimv);
-      else if (array.is_map ())
-        retval = do_num2cell (array.map_value (), dimv);
-      else if (array.is_cell ())
-        retval = do_num2cell (array.cell_value (), dimv);
-      else
-        gripe_wrong_type_arg ("num2cell", array);
     }
+  else if (array.is_object ())
+    retval = do_object2cell (array, dimv);
+  else if (array.is_map ())
+    retval = do_num2cell (array.map_value (), dimv);
+  else if (array.is_cell ())
+    retval = do_num2cell (array.cell_value (), dimv);
+  else
+    gripe_wrong_type_arg ("num2cell", array);
 
   return retval;
 }
 
 /*
 %!assert (num2cell ([1,2;3,4]), {1,2;3,4})
 %!assert (num2cell ([1,2;3,4], 1), {[1;3],[2;4]})
 %!assert (num2cell ([1,2;3,4], 2), {[1,2];[3,4]})
@@ -2184,85 +2172,89 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
      15\n\
 \n\
    [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
   int nargin = args.length ();
-  octave_value retval;
 
   if (nargin < 2)
     print_usage ();
-  else
-    {
-      // Prepare indices.
-      OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
 
-      for (int i = 1; i < nargin; i++)
-        d[i-1] = args(i).octave_idx_type_vector_value (true);
+  // Prepare indices.
+  OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
+
+  for (int i = 1; i < nargin; i++)
+    d[i-1] = args(i).octave_idx_type_vector_value (true);
 
-      octave_value a = args(0);
-      bool sparse = a.is_sparse_type ();
-      if (sparse && nargin > 3)
-        {
-          error ("mat2cell: sparse arguments only support 2-D indexing");
-          return retval;
-        }
+  octave_value a = args(0);
+  bool sparse = a.is_sparse_type ();
+  if (sparse && nargin > 3)
+    {
+      error ("mat2cell: sparse arguments only support 2-D indexing");
+      return retval;
+    }
+
+  switch (a.builtin_type ())
+    {
+    case btyp_double:
+      {
+        if (sparse)
+          retval = do_mat2cell_2d (a.sparse_matrix_value (), d, nargin-1);
+        else
+          retval = do_mat2cell (a.array_value (), d, nargin - 1);
+      }
+      break;
 
-      switch (a.builtin_type ())
-        {
-        case btyp_double:
-          {
-            if (sparse)
-              retval = do_mat2cell_2d (a.sparse_matrix_value (), d, nargin-1);
-            else
-              retval = do_mat2cell (a.array_value (), d, nargin - 1);
-            break;
-          }
-        case btyp_complex:
-          {
-            if (sparse)
-              retval = do_mat2cell_2d (a.sparse_complex_matrix_value (), d,
-                                       nargin-1);
-            else
-              retval = do_mat2cell (a.complex_array_value (), d, nargin - 1);
-            break;
-          }
-#define BTYP_BRANCH(X,Y) \
-        case btyp_ ## X: \
-            retval = do_mat2cell (a.Y ## _value (), d, nargin - 1); \
-          break
+    case btyp_complex:
+      {
+        if (sparse)
+          retval = do_mat2cell_2d (a.sparse_complex_matrix_value (), d,
+                                   nargin-1);
+        else
+          retval = do_mat2cell (a.complex_array_value (), d, nargin - 1);
+      }
+      break;
+
+#define BTYP_BRANCH(X, Y) \
+  case btyp_ ## X: \
+    retval = do_mat2cell (a.Y ## _value (), d, nargin - 1); \
+    break
 
-        BTYP_BRANCH (float, float_array);
-        BTYP_BRANCH (float_complex, float_complex_array);
-        BTYP_BRANCH (bool, bool_array);
-        BTYP_BRANCH (char, char_array);
+      BTYP_BRANCH (float, float_array);
+      BTYP_BRANCH (float_complex, float_complex_array);
+      BTYP_BRANCH (bool, bool_array);
+      BTYP_BRANCH (char, char_array);
 
-        BTYP_BRANCH (int8,  int8_array);
-        BTYP_BRANCH (int16, int16_array);
-        BTYP_BRANCH (int32, int32_array);
-        BTYP_BRANCH (int64, int64_array);
-        BTYP_BRANCH (uint8,  uint8_array);
-        BTYP_BRANCH (uint16, uint16_array);
-        BTYP_BRANCH (uint32, uint32_array);
-        BTYP_BRANCH (uint64, uint64_array);
+      BTYP_BRANCH (int8,  int8_array);
+      BTYP_BRANCH (int16, int16_array);
+      BTYP_BRANCH (int32, int32_array);
+      BTYP_BRANCH (int64, int64_array);
+      BTYP_BRANCH (uint8,  uint8_array);
+      BTYP_BRANCH (uint16, uint16_array);
+      BTYP_BRANCH (uint32, uint32_array);
+      BTYP_BRANCH (uint64, uint64_array);
 
-        BTYP_BRANCH (cell, cell);
-        BTYP_BRANCH (struct, map);
+      BTYP_BRANCH (cell, cell);
+      BTYP_BRANCH (struct, map);
+
 #undef BTYP_BRANCH
 
-        case btyp_func_handle:
-          gripe_wrong_type_arg ("mat2cell", a);
-          break;
-        default:
-          retval = do_mat2cell (a, d, nargin-1);
-        }
+    case btyp_func_handle:
+      gripe_wrong_type_arg ("mat2cell", a);
+      break;
+
+    default:
+      retval = do_mat2cell (a, d, nargin-1);
+      break;
     }
 
   return retval;
 }
 
 /*
 %!test
 %! x = reshape (1:20, 5, 4);
@@ -2333,113 +2325,113 @@ endfor\n\
 @end example\n\
 \n\
 The position of the index is determined by @var{dim}.  If not specified,\n\
 slicing is done along the first non-singleton dimension.\n\
 @seealso{cell2mat, cellindexmat, cellfun}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
-  if (nargin == 3 || nargin == 4)
+
+  if (nargin < 3 || nargin > 4)
+    print_usage ();
+
+  octave_value x = args(0);
+  Array<octave_idx_type> lb = args(1).octave_idx_type_vector_value ();
+  Array<octave_idx_type> ub = args(2).octave_idx_type_vector_value ();
+  int dim = -1;
+  if (nargin == 4)
     {
-      octave_value x = args(0);
-      Array<octave_idx_type> lb = args(1).octave_idx_type_vector_value ();
-      Array<octave_idx_type> ub = args(2).octave_idx_type_vector_value ();
-      int dim = -1;
-      if (nargin == 4)
-        {
-          dim = args(3).int_value () - 1;
-          if (dim < 0)
-            error ("cellslices: DIM must be a valid dimension");
-        }
+      dim = args(3).int_value () - 1;
+      if (dim < 0)
+        error ("cellslices: DIM must be a valid dimension");
+    }
 
-      if (lb.numel () != ub.numel ())
-        error ("cellslices: the lengths of LB and UB must match");
-      else
+  if (lb.numel () != ub.numel ())
+    error ("cellslices: the lengths of LB and UB must match");
+  else
+    {
+      Cell retcell;
+      if (! x.is_sparse_type () && x.is_matrix_type ())
         {
-          Cell retcell;
-          if (! x.is_sparse_type () && x.is_matrix_type ())
+          // specialize for some dense arrays.
+          if (x.is_bool_type ())
+            retcell = do_cellslices_nda (x.bool_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_char_matrix ())
+            retcell = do_cellslices_nda (x.char_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_integer_type ())
             {
-              // specialize for some dense arrays.
-              if (x.is_bool_type ())
-                retcell = do_cellslices_nda (x.bool_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_char_matrix ())
-                retcell = do_cellslices_nda (x.char_array_value (),
+              if (x.is_int8_type ())
+                retcell = do_cellslices_nda (x.int8_array_value (),
                                              lb, ub, dim);
-              else if (x.is_integer_type ())
-                {
-                  if (x.is_int8_type ())
-                    retcell = do_cellslices_nda (x.int8_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_int16_type ())
-                    retcell = do_cellslices_nda (x.int16_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_int32_type ())
-                    retcell = do_cellslices_nda (x.int32_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_int64_type ())
-                    retcell = do_cellslices_nda (x.int64_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_uint8_type ())
-                    retcell = do_cellslices_nda (x.uint8_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_uint16_type ())
-                    retcell = do_cellslices_nda (x.uint16_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_uint32_type ())
-                    retcell = do_cellslices_nda (x.uint32_array_value (),
-                                                 lb, ub, dim);
-                  else if (x.is_uint64_type ())
-                    retcell = do_cellslices_nda (x.uint64_array_value (),
-                                                 lb, ub, dim);
-                }
-              else if (x.is_complex_type ())
-                {
-                  if (x.is_single_type ())
-                    retcell = do_cellslices_nda (x.float_complex_array_value (),
-                                                 lb, ub, dim);
-                  else
-                    retcell = do_cellslices_nda (x.complex_array_value (),
-                                                 lb, ub, dim);
-                }
+              else if (x.is_int16_type ())
+                retcell = do_cellslices_nda (x.int16_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_int32_type ())
+                retcell = do_cellslices_nda (x.int32_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_int64_type ())
+                retcell = do_cellslices_nda (x.int64_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_uint8_type ())
+                retcell = do_cellslices_nda (x.uint8_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_uint16_type ())
+                retcell = do_cellslices_nda (x.uint16_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_uint32_type ())
+                retcell = do_cellslices_nda (x.uint32_array_value (),
+                                             lb, ub, dim);
+              else if (x.is_uint64_type ())
+                retcell = do_cellslices_nda (x.uint64_array_value (),
+                                             lb, ub, dim);
+            }
+          else if (x.is_complex_type ())
+            {
+              if (x.is_single_type ())
+                retcell = do_cellslices_nda (x.float_complex_array_value (),
+                                             lb, ub, dim);
               else
-                {
-                  if (x.is_single_type ())
-                    retcell = do_cellslices_nda (x.float_array_value (),
-                                                 lb, ub, dim);
-                  else
-                    retcell = do_cellslices_nda (x.array_value (),
-                                                 lb, ub, dim);
-                }
+                retcell = do_cellslices_nda (x.complex_array_value (),
+                                             lb, ub, dim);
             }
           else
             {
-              // generic code.
-              octave_idx_type n = lb.numel ();
-              retcell = Cell (1, n);
-              const dim_vector dv = x.dims ();
-              int ndims = dv.length ();
-              if (dim < 0)
-                dim = dv.first_non_singleton ();
-              ndims = std::max (ndims, dim + 1);
-              octave_value_list idx (ndims, octave_value::magic_colon_t);
-              for (octave_idx_type i = 0; i < n; i++)
-                {
-                  idx(dim) = Range (lb(i), ub(i));
-                  retcell(i) = x.do_index_op (idx);
-                }
+              if (x.is_single_type ())
+                retcell = do_cellslices_nda (x.float_array_value (),
+                                             lb, ub, dim);
+              else
+                retcell = do_cellslices_nda (x.array_value (),
+                                             lb, ub, dim);
             }
-
-          retval = retcell;
         }
+      else
+        {
+          // generic code.
+          octave_idx_type n = lb.numel ();
+          retcell = Cell (1, n);
+          const dim_vector dv = x.dims ();
+          int ndims = dv.length ();
+          if (dim < 0)
+            dim = dv.first_non_singleton ();
+          ndims = std::max (ndims, dim + 1);
+          octave_value_list idx (ndims, octave_value::magic_colon_t);
+          for (octave_idx_type i = 0; i < n; i++)
+            {
+              idx(dim) = Range (lb(i), ub(i));
+              retcell(i) = x.do_index_op (idx);
+            }
+        }
+
+      retval = retcell;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
@@ -2459,33 +2451,27 @@ Y = cell (size (X));\n\
 for i = 1:numel (X)\n\
   Y@{i@} = X@{i@}(varargin@{:@});\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () >= 1)
-    {
-      const Cell x = args(0).xcell_value ("cellindexmat: X must be a cell");
-      NoAlias<Cell> y(x.dims ());
-      octave_idx_type nel = x.numel ();
-      octave_value_list idx = args.slice (1, args.length () - 1);
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          octave_quit ();
-
-          octave_value tmp = x(i);
-
-          y(i) = tmp.do_index_op (idx);
-        }
-
-      retval = y;
-    }
-  else
+  if (args.length () == 0)
     print_usage ();
 
-  return retval;
+  const Cell x = args(0).xcell_value ("cellindexmat: X must be a cell");
+  NoAlias<Cell> y(x.dims ());
+  octave_idx_type nel = x.numel ();
+  octave_value_list idx = args.slice (1, args.length () - 1);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      octave_quit ();
+
+      octave_value tmp = x(i);
+
+      y(i) = tmp.do_index_op (idx);
+    }
+
+  return octave_value (y);
 }
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1144,16 +1144,19 @@ do_dbstack (const octave_value_list& arg
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
   octave_idx_type len = args.length ();
 
   // dbstack accepts up to 2 arguments.
 
+  if (len > 2)
+    print_usage ();
+
   if (len == 1 || len == 2)
     {
       int n = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_value arg = args(i);
 
@@ -1173,18 +1176,16 @@ do_dbstack (const octave_value_list& arg
 
           if (n <= 0)
             error ("dbstack: N must be a non-negative integer");
         }
 
       if (n > 0)
         nskip = n;
     }
-  else if (len)
-    print_usage ();
 
   if (nargout == 0)
     {
       octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
       octave_idx_type nframes_to_display = stk.numel ();
 
       if (nframes_to_display > 0)
         {
@@ -1382,17 +1383,18 @@ function returns.\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       int nargin = args.length ();
 
       if (nargin > 1)
         print_usage ();
-      else if (nargin == 1)
+
+      if (nargin == 1)
         {
           std::string arg = args(0).xstring_value ("dbstep: input argument must be a string");
 
           if (arg == "in")
             {
               Vdebugging = false;
 
               tree_evaluator::dbstep_flag = -1;
@@ -1436,24 +1438,22 @@ DEFUN (dbcont, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont\n\
 Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
-      if (args.length () == 0)
-        {
-          Vdebugging = false;
+      if (args.length () != 0)
+        print_usage ();
 
-          tree_evaluator::reset_debug_state ();
-        }
-      else
-        print_usage ();
+      Vdebugging = false;
+
+      tree_evaluator::reset_debug_state ();
     }
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
@@ -1461,69 +1461,61 @@ DEFUN (dbquit, args, ,
 @deftypefn {Command} {} dbquit\n\
 Quit debugging mode immediately without further code execution and return to\n\
 the Octave prompt.\n\
 @seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
-      if (args.length () == 0)
-        {
-          Vdebugging = false;
+      if (args.length () != 0)
+        print_usage ();
 
-          tree_evaluator::reset_debug_state ();
+      Vdebugging = false;
 
-          octave_throw_interrupt_exception ();
-        }
-      else
-        print_usage ();
+      tree_evaluator::reset_debug_state ();
+
+      octave_throw_interrupt_exception ();
     }
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    retval = Vdebugging;
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (Vdebugging);
 }
 
 DEFUN (__db_next_breakpoint_quiet__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __db_next_breakpoint_quiet__ ()\n\
 @deftypefnx {Built-in Function} {} __db_next_breakpoint_quiet__ (@var{flag})\n\
 Disable line info printing at the next breakpoint.\n\
 \n\
 With a logical argument @var{flag}, set the state on or off.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 0 || nargin == 1)
-    {
-      bool state = true;
+  if (nargin > 1)
+    print_usage ();
+
+  bool state = true;
 
-      if (nargin == 1)
-        state = args(0).bool_value ();
+  if (nargin == 1)
+    state = args(0).bool_value ();
 
-      tree_evaluator::quiet_breakpoint_flag = state;
-    }
-  else
-    print_usage ();
+  tree_evaluator::quiet_breakpoint_flag = state;
 
   return retval;
 }
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -173,39 +173,35 @@ If an error occurs, return an empty cell
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{ls, dir, glob, what}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 1)
+    print_usage ();
+
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Cell ();
 
-  if (args.length () == 1)
-    {
-      std::string dirname = args(0).xstring_value ("readdir: DIR must be a string");
+  std::string dirname = args(0).xstring_value ("readdir: DIR must be a string");
 
-      dir_entry dir (dirname);
+  dir_entry dir (dirname);
 
-      if (dir)
-        {
-          string_vector dirlist = dir.read ();
-          retval(1) = 0.0;
-          retval(0) = Cell (dirlist.sort ());
-        }
-      else
-        {
-          retval(2) = dir.error ();
-        }
+  if (dir)
+    {
+      string_vector dirlist = dir.read ();
+      retval(1) = 0.0;
+      retval(0) = Cell (dirlist.sort ());
     }
   else
-    print_usage ();
+    retval(2) = dir.error ();
 
   return retval;
 }
 
 // FIXME: should maybe also allow second arg to specify mode?
 //        OTOH, that might cause trouble with compatibility later...
 
 DEFUNX ("mkdir", Fmkdir, args, ,
@@ -225,66 +221,64 @@ identifier.\n\
 \n\
 When creating a directory permissions will be set to\n\
 @code{0777 - @var{umask}}.\n\
 @seealso{rmdir, pwd, cd, umask}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
-  int nargin = args.length ();
-
   std::string dirname;
 
   if (nargin == 2)
     {
       std::string parent = args(0).xstring_value ("mkdir: PARENT must be a string");
       std::string dir = args(1).xstring_value ("mkdir: DIR must be a string");
 
       dirname = file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
     dirname = args(0).xstring_value ("mkdir: DIR must be a string");
 
-  if (nargin == 1 || nargin == 2)
-    {
-      std::string msg;
+  std::string msg;
+
+  dirname = file_ops::tilde_expand (dirname);
 
-      dirname = file_ops::tilde_expand (dirname);
+  file_stat fs (dirname);
 
-      file_stat fs (dirname);
+  if (fs && fs.is_dir ())
+    {
+      // For compatibility with Matlab, we return true when the
+      // directory already exists.
 
-      if (fs && fs.is_dir ())
+      retval(2) = "mkdir";
+      retval(1) = "directory exists";
+      retval(0) = true;
+    }
+  else
+    {
+      int status = octave_mkdir (dirname, 0777, msg);
+
+      if (status < 0)
         {
-          // For compatibility with Matlab, we return true when the
-          // directory already exists.
-
           retval(2) = "mkdir";
-          retval(1) = "directory exists";
-          retval(0) = true;
+          retval(1) = msg;
         }
       else
-        {
-          int status = octave_mkdir (dirname, 0777, msg);
-
-          if (status < 0)
-            {
-              retval(2) = "mkdir";
-              retval(1) = msg;
-            }
-          else
-            retval(0) = true;
-        }
+        retval(0) = true;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rmdir @var{dir}\n\
 @deftypefnx {Built-in Function} {} rmdir (@var{dir}, \"s\")\n\
@@ -299,64 +293,62 @@ character strings ("").  Otherwise, @var
 system-dependent error message, and @var{msgid} contains a unique message\n\
 identifier.\n\
 \n\
 @seealso{mkdir, confirm_recursive_rmdir, pwd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = false;
 
-  int nargin = args.length ();
+  std::string dirname = args(0).xstring_value ("rmdir: DIR must be a string");
 
-  if (nargin == 1 || nargin == 2)
-    {
-      std::string dirname = args(0).xstring_value ("rmdir: DIR must be a string");
+  std::string fulldir = file_ops::tilde_expand (dirname);
+  int status = -1;
+  std::string msg;
 
-      std::string fulldir = file_ops::tilde_expand (dirname);
-      int status = -1;
-      std::string msg;
+  if (nargin == 2)
+    {
+      if (args(1).string_value () == "s")
+        {
+          bool doit = true;
 
-      if (nargin == 2)
-        {
-          if (args(1).string_value () == "s")
+          if (interactive && ! forced_interactive
+              && Vconfirm_recursive_rmdir)
             {
-              bool doit = true;
-
-              if (interactive && ! forced_interactive
-                  && Vconfirm_recursive_rmdir)
-                {
-                  std::string prompt
-                    = "remove entire contents of " + fulldir + "? ";
+              std::string prompt
+                = "remove entire contents of " + fulldir + "? ";
 
-                  doit = octave_yes_or_no (prompt);
-                }
+              doit = octave_yes_or_no (prompt);
+            }
 
-              if (doit)
-                status = octave_recursive_rmdir (fulldir, msg);
-            }
-          else
-            error ("rmdir: second argument must be \"s\" for recursive removal");
+          if (doit)
+            status = octave_recursive_rmdir (fulldir, msg);
         }
       else
-        status = octave_rmdir (fulldir, msg);
-
-      if (status < 0)
-        {
-          retval(2) = "rmdir";
-          retval(1) = msg;
-        }
-      else
-        retval(0) = true;
+        error ("rmdir: second argument must be \"s\" for recursive removal");
     }
   else
-    print_usage ();
+    status = octave_rmdir (fulldir, msg);
+
+  if (status < 0)
+    {
+      retval(2) = "rmdir";
+      retval(1) = msg;
+    }
+  else
+    retval(0) = true;
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} link @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
@@ -365,35 +357,33 @@ Create a new link (also known as a hard 
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{symlink, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 2)
+    print_usage ();
+
   retval(1) = std::string ();
   retval(0) = -1.0;
 
-  if (args.length () == 2)
-    {
-      std::string from = args(0).xstring_value ("link: OLD must be a string");
-      std::string to = args(1).xstring_value ("link: NEW must be a string");
+  std::string from = args(0).xstring_value ("link: OLD must be a string");
+  std::string to = args(1).xstring_value ("link: NEW must be a string");
 
-      std::string msg;
+  std::string msg;
 
-      int status = octave_link (from, to, msg);
-
-      if (status < 0)
-        retval(1) = msg;
+  int status = octave_link (from, to, msg);
 
-      retval(0) = status;
-    }
-  else
-    print_usage ();
+  if (status < 0)
+    retval(1) = msg;
+
+  retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} symlink @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
@@ -402,35 +392,33 @@ Create a symbolic link @var{new} which c
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{link, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 2)
+    print_usage ();
+
   retval(1) = std::string ();
   retval(0) = -1.0;
 
-  if (args.length () == 2)
-    {
-      std::string from = args(0).xstring_value ("symlink: OLD must be a string");
-      std::string to = args(1).xstring_value ("symlink: NEW must be a string");
+  std::string from = args(0).xstring_value ("symlink: OLD must be a string");
+  std::string to = args(1).xstring_value ("symlink: NEW must be a string");
 
-      std::string msg;
+  std::string msg;
 
-      int status = octave_symlink (from, to, msg);
-
-      if (status < 0)
-        retval(1) = msg;
+  int status = octave_symlink (from, to, msg);
 
-      retval(0) = status;
-    }
-  else
-    print_usage ();
+  if (status < 0)
+    retval(1) = msg;
+
+  retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} readlink @var{symlink}\n\
 @deftypefnx {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
@@ -440,37 +428,35 @@ If successful, @var{result} contains the
 @var{symlink}, @var{err} is 0, and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{lstat, symlink, link, unlink, delete}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 1)
+    print_usage ();
+
   retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = std::string ();
 
-  if (args.length () == 1)
-    {
-      std::string symlink = args(0).xstring_value ("readlink: SYMLINK must be a string");
+  std::string symlink = args(0).xstring_value ("readlink: SYMLINK must be a string");
 
-      std::string result;
-      std::string msg;
-
-      int status = octave_readlink (symlink, result, msg);
+  std::string result;
+  std::string msg;
 
-      if (status < 0)
-        retval(2) = msg;
+  int status = octave_readlink (symlink, result, msg);
 
-      retval(1) = status;
-      retval(0) = result;
-    }
-  else
-    print_usage ();
+  if (status < 0)
+    retval(2) = msg;
+
+  retval(1) = status;
+  retval(0) = result;
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rename @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
@@ -479,35 +465,33 @@ Change the name of file @var{old} to @va
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{movefile, copyfile, ls, dir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 2)
+    print_usage ();
+
   retval(1) = std::string ();
   retval(0) = -1.0;
 
-  if (args.length () == 2)
-    {
-      std::string from = args(0).xstring_value ("rename: OLD must be a string");
-      std::string to = args(1).xstring_value ("rename: NEW must be a string");
+  std::string from = args(0).xstring_value ("rename: OLD must be a string");
+  std::string to = args(1).xstring_value ("rename: NEW must be a string");
 
-      std::string msg;
+  std::string msg;
 
-      int status = octave_rename (from, to, msg);
-
-      if (status < 0)
-        retval(1) = msg;
+  int status = octave_rename (from, to, msg);
 
-      retval(0) = status;
-    }
-  else
-    print_usage ();
+  if (status < 0)
+    retval(1) = msg;
+
+  retval(0) = status;
 
   return retval;
 }
 
 DEFUN (glob, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
@@ -553,30 +537,24 @@ glob (\"file[12]\")\n\
       @{\n\
         [1,1] = file1\n\
         [2,1] = file2\n\
       @}\n\
 @end example\n\
 @seealso{ls, dir, readdir, what}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      string_vector pat = args(0).xall_strings ("glob: PATTERN must be a string");
-
-      glob_match pattern (file_ops::tilde_expand (pat));
-
-      retval = Cell (pattern.glob ());
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  string_vector pat = args(0).xall_strings ("glob: PATTERN must be a string");
+
+  glob_match pattern (file_ops::tilde_expand (pat));
+
+  return octave_value (Cell (pattern.glob ()));
 }
 
 /*
 %!test
 %! tmpdir = tempname;
 %! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
 %! if (mkdir (tmpdir))
 %!   cwd = pwd;
@@ -620,29 +598,25 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
      @result{} [ 1; 1; 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{glob, regexp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 2)
-    {
-      string_vector pat = args(0).all_strings ();
-      string_vector str = args(1).all_strings ();
-
-      glob_match pattern (file_ops::tilde_expand (pat));
-
-      retval = pattern.match (str);
-    }
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  string_vector pat = args(0).all_strings ();
+  string_vector str = args(1).all_strings ();
+
+  glob_match pattern (file_ops::tilde_expand (pat));
+
+  return octave_value (pattern.match (str));
 }
 
 DEFUN (filesep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} filesep ()\n\
 @deftypefnx {Built-in Function} {} filesep (\"all\")\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
@@ -650,44 +624,49 @@ If @qcode{\"all\"} is given, the functio
 in the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
 @seealso{pathsep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 0)
+  int nargin = args.length ();
+  if (nargin > 1)
+    print_usage ();
+
+  if (nargin == 0)
     retval = file_ops::dir_sep_str ();
-  else if (args.length () == 1)
+  else
     {
       std::string s = args(0).xstring_value ("filesep: argument must be a string");
       if (s == "all")
         retval = file_ops::dir_sep_chars ();
       else
         error ("filesep: argument must be \"all\"");
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} pathsep ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} pathsep (@var{new_val})\n\
 Query or set the character used to separate directories in a path.\n\
 @seealso{filesep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargout > 0 || nargin == 0)
     retval = dir_path::path_sep_str ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("pathsep: argument must be a single character");
 
       switch (sval.length ())
@@ -700,18 +679,16 @@ Query or set the character used to separ
           dir_path::path_sep_char ('\0');
           break;
 
         default:
           error ("pathsep: argument must be a single character");
           break;
         }
     }
-  else if (nargin > 1)
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -284,26 +284,20 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
 
 DEFUN (ischar, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 1 && args(0).is_defined ())
-    retval = args(0).is_string ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_string ());
 }
 
 /*
 %!assert (ischar ("a"), true)
 %!assert (ischar (["ab";"cd"]), true)
 %!assert (ischar ({"ab"}), false)
 %!assert (ischar (1), false)
 %!assert (ischar ([1, 2]), false)
@@ -556,27 +550,21 @@ array of strings (of the same size or wi
 or character string.\n\
 \n\
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strcmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strcmpi, strncmp, strncmpi}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 2)
-    {
-      retval = do_strcmp_fun (args(0), args(1), 0,
-                              "strcmp", strcmp_array_op, strcmp_str_op);
-    }
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  return octave_value (do_strcmp_fun (args(0), args(1), 0, "strcmp",
+                                      strcmp_array_op, strcmp_str_op));
 }
 
 /*
 %!shared x
 %! x = char (zeros (0, 2));
 %!assert (strcmp ("", x), false)
 %!assert (strcmp (x, ""), false)
 %!assert (strcmp (x, x), true)
@@ -674,30 +662,26 @@ strncmp (\"abce\", @{\"abcd\", \"bca\", 
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmp\n\
 function returns 1 if the character strings are equal, and 0 otherwise.\n\
 This is just the opposite of the corresponding C library function.\n\
 @seealso{strncmpi, strcmp, strcmpi}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 3)
-    {
-      octave_idx_type n = args(2).idx_type_value ();
+  if (args.length () != 3)
+    print_usage ();
+
+  octave_idx_type n = args(2).idx_type_value ();
 
-      if (n > 0)
-        {
-          retval = do_strcmp_fun (args(0), args(1), n, "strncmp",
-                                  strncmp_array_op, strncmp_str_op);
-        }
-      else
-        error ("strncmp: N must be greater than 0");
-    }
+  if (n > 0)
+    retval = do_strcmp_fun (args(0), args(1), n, "strncmp",
+                            strncmp_array_op, strncmp_str_op);
   else
-    print_usage ();
+    error ("strncmp: N must be greater than 0");
 
   return retval;
 }
 
 /*
 %!assert (strncmp ("abce", "abc", 3), true)
 %!assert (strncmp (100, 100, 1), false)
 %!assert (strncmp ("abce", {"abcd", "bca", "abc"}, 3), logical ([1, 0, 1]))
@@ -709,17 +693,19 @@ This is just the opposite of the corresp
 %!error strncmp ()
 %!error strncmp ("abc", "def")
 */
 
 // case-insensitive character equality functor
 struct icmp_char_eq : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
-  { return std::toupper (x) == std::toupper (y); }
+  {
+    return std::toupper (x) == std::toupper (y);
+  }
 };
 
 // strcmpi is equivalent to strcmp in that it checks all dims.
 static bool
 strcmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type)
 {
   return (s1.dims () == s2.dims ()
           && std::equal (s1.data (), s1.data () + s1.numel (), s2.data (),
@@ -753,25 +739,21 @@ function returns 1 if the character stri
 This is just the opposite of the corresponding C library function.\n\
 \n\
 @strong{Caution:} National alphabets are not supported.\n\
 @seealso{strcmp, strncmp, strncmpi}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 2)
-    {
-      retval = do_strcmp_fun (args(0), args(1), 0,
-                              "strcmpi", strcmpi_array_op, strcmpi_str_op);
-    }
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  return octave_value (do_strcmp_fun (args(0), args(1), 0, "strcmpi",
+                                      strcmpi_array_op, strcmpi_str_op));
 }
 
 /*
 %!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
@@ -814,30 +796,26 @@ function returns 1 if the character stri
 This is just the opposite of the corresponding C library function.\n\
 \n\
 @strong{Caution:} National alphabets are not supported.\n\
 @seealso{strncmp, strcmp, strcmpi}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 3)
-    {
-      octave_idx_type n = args(2).idx_type_value ();
+  if (args.length () != 3)
+    print_usage ();
+
+  octave_idx_type n = args(2).idx_type_value ();
 
-      if (n > 0)
-        {
-          retval = do_strcmp_fun (args(0), args(1), n, "strncmpi",
-                                  strncmpi_array_op, strncmpi_str_op);
-        }
-      else
-        error ("strncmpi: N must be greater than 0");
-    }
+  if (n > 0)
+    retval = do_strcmp_fun (args(0), args(1), n, "strncmpi",
+                            strncmpi_array_op, strncmpi_str_op);
   else
-    print_usage ();
+    error ("strncmpi: N must be greater than 0");
 
   return retval;
 }
 
 /*
 %!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
@@ -877,20 +855,17 @@ whos ans\n\
 @seealso{terminal_size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   string_vector s = args(0).xall_strings ("list_in_columns: ARG must be a cellstr or char array");
 
   int width = -1;
 
   if (nargin > 1 && ! args(1).is_empty ())
     width = args(1).xint_value ("list_in_columns: WIDTH must be an integer");
 
