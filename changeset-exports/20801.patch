# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449188574 18000
#      Thu Dec 03 19:22:54 2015 -0500
# Node ID a542a9bf177e0b174628c340def6f4a9eb7c762a
# Parent  fb128aafc32239b971e2cef5d3e1441e8b7dc1ec
eliminate return statements after calls to print_usage

* graphics.cc, hess.cc, input.cc, kron.cc, load-save.cc, lsode.cc,
luinc.cc, matrix_type.cc, md5sum.cc, nproc.cc, pager.cc, pr-output.cc,
psi.cc, quadcc.cc, rand.cc, regexp.cc, sighandlers.cc, sqrtm.cc,
strfind.cc, sub2ind.cc, sylvester.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9583,24 +9583,20 @@ Return true if @var{h} is a graphics han
 @var{h} may also be a matrix of handles in which case a logical array is\n\
 returned that is true where the elements of @var{h} are graphics handles and\n\
 false where they are not.\n\
 @seealso{isaxes, isfigure}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = is_handle (args(0));
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (is_handle (args(0)));
 }
 
 static bool
 is_handle_visible (const graphics_handle& h)
 {
   return h.ok () && gh_manager::is_handle_visible (h);
 }
 
@@ -9633,24 +9629,20 @@ is_handle_visible (const octave_value& v
 }
 
 DEFUN (__is_handle_visible__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __is_handle_visible__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = is_handle_visible (args(0));
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (is_handle_visible (args(0)));
 }
 
 DEFUN (reset, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} reset (@var{h})\n\
 Reset the properties of the graphic object @var{h} to their default values.\n\
 \n\
 For figures, the properties @qcode{\"position\"}, @qcode{\"units\"},\n\
@@ -9662,27 +9654,25 @@ The input @var{h} may also be a vector o
 each individual object will be reset.\n\
 @seealso{cla, clf, newplot}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
-  else
-    {
-      // get vector of graphics handles
-      ColumnVector hcv = args(0).xvector_value ("reset: H must be a graphics handle");
-
-      // loop over graphics objects
-      for (octave_idx_type n = 0; n < hcv.numel (); n++)
-        gh_manager::get_object (hcv(n)).reset_default_properties ();
-
-      Fdrawnow ();
-    }
+
+  // get vector of graphics handles
+  ColumnVector hcv = args(0).xvector_value ("reset: H must be a graphics handle");
+
+  // loop over graphics objects
+  for (octave_idx_type n = 0; n < hcv.numel (); n++)
+    gh_manager::get_object (hcv(n)).reset_default_properties ();
+
+  Fdrawnow ();
 
   return octave_value ();
 }
 
 /*
 
 %!test  # line object
 %! hf = figure ("visible", "off");
@@ -9871,115 +9861,113 @@ being @qcode{\"portrait\"}.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0)
-    {
-      // get vector of graphics handles
-      ColumnVector hcv = args(0).xvector_value ("set: H must be a graphics handle");
-
-      bool request_drawnow = false;
-
-      // loop over graphics objects
-      for (octave_idx_type n = 0; n < hcv.numel (); n++)
-        {
-          graphics_object go = gh_manager::get_object (hcv(n));
-
-          if (go)
-            {
-              if (nargin == 3
-                  && args(1).is_cellstr () && args(2).is_cell ())
+  if (nargin == 0)
+    print_usage ();
+
+  // get vector of graphics handles
+  ColumnVector hcv = args(0).xvector_value ("set: H must be a graphics handle");
+
+  bool request_drawnow = false;
+
+  // loop over graphics objects
+  for (octave_idx_type n = 0; n < hcv.numel (); n++)
+    {
+      graphics_object go = gh_manager::get_object (hcv(n));
+
+      if (go)
+        {
+          if (nargin == 3
+              && args(1).is_cellstr () && args(2).is_cell ())
+            {
+              if (args(2).cell_value ().rows () == 1)
+                {
+                  go.set (args(1).cellstr_value (),
+                          args(2).cell_value (), 0);
+                }
+              else if (hcv.numel () == args(2).cell_value ().rows ())
                 {
-                  if (args(2).cell_value ().rows () == 1)
-                    {
-                      go.set (args(1).cellstr_value (),
-                              args(2).cell_value (), 0);
-                    }
-                  else if (hcv.numel () == args(2).cell_value ().rows ())
-                    {
-                      go.set (args(1).cellstr_value (),
-                              args(2).cell_value (), n);
-                    }
+                  go.set (args(1).cellstr_value (),
+                          args(2).cell_value (), n);
+                }
+              else
+                {
+                  error ("set: number of graphics handles must match number of value rows (%d != %d)",
+                         hcv.numel (), args(2).cell_value ().rows ());
+                  break;
+
+                }
+            }
+          else if (nargin == 2 && args(1).is_map ())
+            {
+              go.set (args(1).map_value ());
+            }
+          else if (nargin == 2 && args(1).is_string ())
+            {
+              std::string property = args(1).string_value ();
+
+              octave_map pmap = go.values_as_struct ();
+
+              if (go.has_readonly_property (property))
+                if (nargout != 0)
+                  retval = Matrix ();
+                else
+                  octave_stdout << "set: " << property
+                                <<" is read-only" << std::endl;
+              else if (pmap.isfield (property))
+                {
+                  if (nargout != 0)
+                    retval = pmap.getfield (property)(0);
                   else
                     {
-                      error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                             hcv.numel (), args(2).cell_value ().rows ());
-                      break;
-
-                    }
-                }
-              else if (nargin == 2 && args(1).is_map ())
-                {
-                  go.set (args(1).map_value ());
-                }
-              else if (nargin == 2 && args(1).is_string ())
-                {
-                  std::string property = args(1).string_value ();
-
-                  octave_map pmap = go.values_as_struct ();
-
-                  if (go.has_readonly_property (property))
-                    if (nargout != 0)
-                      retval = Matrix ();
-                    else
-                      octave_stdout << "set: " << property
-                                    <<" is read-only" << std::endl;
-                  else if (pmap.isfield (property))
-                    {
-                      if (nargout != 0)
-                        retval = pmap.getfield (property)(0);
-                      else
-                        {
-                          std::string s = go.value_as_string (property);
-
-                          octave_stdout << s;
-                        }
-                    }
-                  else
-                    {
-                      error ("set: unknown property");
-                      break;
-                    }
-                }
-              else if (nargin == 1)
-                {
-                  if (nargout != 0)
-                    retval = go.values_as_struct ();
-                  else
-                    {
-                      std::string s = go.values_as_string ();
+                      std::string s = go.value_as_string (property);
 
                       octave_stdout << s;
                     }
                 }
               else
                 {
-                  go.set (args.splice (0, 1));
-                  request_drawnow = true;
+                  error ("set: unknown property");
+                  break;
+                }
+            }
+          else if (nargin == 1)
+            {
+              if (nargout != 0)
+                retval = go.values_as_struct ();
+              else
+                {
+                  std::string s = go.values_as_string ();
+
+                  octave_stdout << s;
                 }
             }
           else
             {
-              error ("set: invalid handle (= %g)", hcv(n));
-              break;
-            }
-
-          request_drawnow = true;
-        }
-
-      if (request_drawnow)
-        Vdrawnow_requested = true;
-    }
-  else
-    print_usage ();
+              go.set (args.splice (0, 1));
+              request_drawnow = true;
+            }
+        }
+      else
+        {
+          error ("set: invalid handle (= %g)", hcv(n));
+          break;
+        }
+
+      request_drawnow = true;
+    }
+
+  if (request_drawnow)
+    Vdrawnow_requested = true;
 
   return retval;
 }
 
 static std::string
 get_graphics_object_type (double val)
 {
   std::string retval;
@@ -10013,123 +10001,121 @@ lists respectively.\n\
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   bool use_cell_format = false;
 
-  if (nargin == 1 || nargin == 2)
-    {
-      if (args(0).is_empty ())
-        {
-          retval = Matrix ();
-          return retval;
-        }
-
-      ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
-
-      octave_idx_type len = hcv.numel ();
-
-      if (nargin == 1 && len > 1)
-        {
-          std::string typ0 = get_graphics_object_type (hcv(0));
-
-          for (octave_idx_type n = 1; n < len; n++)
-            {
-              std::string typ = get_graphics_object_type (hcv(n));
-
-              if (typ != typ0)
-                {
-                  error ("get: vector of handles must all have the same type");
-                  break;
-                }
-            }
-        }
-
-      if (nargin > 1 && args(1).is_cellstr ())
-        {
-          Array<std::string> plist = args(1).cellstr_value ();
-
-          octave_idx_type plen = plist.numel ();
-
-          use_cell_format = true;
-
-          vals.resize (dim_vector (len, plen));
-
-          for (octave_idx_type n = 0; n < len; n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  if (args(0).is_empty ())
+    {
+      retval = Matrix ();
+      return retval;
+    }
+
+  ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
+
+  octave_idx_type hcv_len = hcv.numel ();
+
+  if (nargin == 1 && hcv_len > 1)
+    {
+      std::string typ0 = get_graphics_object_type (hcv(0));
+
+      for (octave_idx_type n = 1; n < hcv_len; n++)
+        {
+          std::string typ = get_graphics_object_type (hcv(n));
+
+          if (typ != typ0)
+            {
+              error ("get: vector of handles must all have the same type");
+              break;
+            }
+        }
+    }
+
+  if (nargin > 1 && args(1).is_cellstr ())
+    {
+      Array<std::string> plist = args(1).cellstr_value ();
+
+      octave_idx_type plen = plist.numel ();
+
+      use_cell_format = true;
+
+      vals.resize (dim_vector (hcv_len, plen));
+
+      for (octave_idx_type n = 0; n < hcv_len; n++)
+        {
+          graphics_object go = gh_manager::get_object (hcv(n));
+
+          if (go)
+            {
+              for (octave_idx_type m = 0; m < plen; m++)
                 {
-                  for (octave_idx_type m = 0; m < plen; m++)
-                    {
-                      caseless_str property = plist(m);
-
-                      vals(n, m) = go.get (property);
-                    }
-                }
-              else
-                {
-                  error ("get: invalid handle (= %g)", hcv(n));
-                  break;
+                  caseless_str property = plist(m);
+
+                  vals(n, m) = go.get (property);
                 }
             }
-        }
-      else
-        {
-          caseless_str property;
-
-          if (nargin > 1)
-            property = args(1).xstring_value ("get: second argument must be property name or cell array of property names");
-
-          vals.resize (dim_vector (len, 1));
-
-          for (octave_idx_type n = 0; n < len; n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
-                {
-                  if (nargin == 1)
-                    vals(n) = go.get ();
-                  else
-                    vals(n) = go.get (property);
-                }
+          else
+            {
+              error ("get: invalid handle (= %g)", hcv(n));
+              break;
+            }
+        }
+    }
+  else
+    {
+      caseless_str property;
+
+      if (nargin > 1)
+        property = args(1).xstring_value ("get: second argument must be property name or cell array of property names");
+
+      vals.resize (dim_vector (hcv_len, 1));
+
+      for (octave_idx_type n = 0; n < hcv_len; n++)
+        {
+          graphics_object go = gh_manager::get_object (hcv(n));
+
+          if (go)
+            {
+              if (nargin == 1)
+                vals(n) = go.get ();
               else
-                {
-                  error ("get: invalid handle (= %g)", hcv(n));
-                  break;
-                }
-            }
-        }
-    }
-  else
-    print_usage ();
+                vals(n) = go.get (property);
+            }
+          else
+            {
+              error ("get: invalid handle (= %g)", hcv(n));
+              break;
+            }
+        }
+    }
 
   if (use_cell_format)
     retval = vals;
   else
     {
-      octave_idx_type len = vals.numel ();
-
-      if (len == 0)
+      octave_idx_type vals_len = vals.numel ();
+
+      if (vals_len == 0)
         retval = Matrix ();
-      else if (len == 1)
+      else if (vals_len == 1)
         retval = vals(0);
-      else if (len > 1 && nargin == 1)
-        {
-          OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, len);
-
-          for (octave_idx_type n = 0; n < len; n++)
+      else if (vals_len > 1 && nargin == 1)
+        {
+          OCTAVE_LOCAL_BUFFER (octave_scalar_map, tmp, vals_len);
+
+          for (octave_idx_type n = 0; n < vals_len; n++)
             tmp[n] = vals(n).scalar_map_value ();
 
-          retval = octave_map::cat (0, len, tmp);
+          retval = octave_map::cat (0, vals_len, tmp);
         }
       else
         retval = vals;
     }
 
   return retval;
 }
 
@@ -10150,45 +10136,43 @@ Undocumented internal function.\n\
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
-
-      octave_idx_type len = hcv.numel ();
-
-      vals.resize (dim_vector (len, 1));
-
-      for (octave_idx_type n = 0; n < len; n++)
-        {
-          graphics_object go = gh_manager::get_object (hcv(n));
-
-          if (go)
-            vals(n) = go.get (true);
-          else
-            {
-              error ("get: invalid handle (= %g)", hcv(n));
-              break;
-            }
-        }
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
-  octave_idx_type len = vals.numel ();
-
-  if (len > 1)
+  ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
+
+  octave_idx_type hcv_len = hcv.numel ();
+
+  vals.resize (dim_vector (hcv_len, 1));
+
+  for (octave_idx_type n = 0; n < hcv_len; n++)
+    {
+      graphics_object go = gh_manager::get_object (hcv(n));
+
+      if (go)
+        vals(n) = go.get (true);
+      else
+        {
+          error ("get: invalid handle (= %g)", hcv(n));
+          break;
+        }
+    }
+
+  octave_idx_type vals_len = vals.numel ();
+
+  if (vals_len > 1)
     retval = vals;
-  else if (len == 1)
+  else if (vals_len == 1)
     retval = vals(0);
 
   return retval;
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
                       bool integer_figure_handle,
@@ -10261,108 +10245,102 @@ DEFUN (__go_figure__, args, ,
 @deftypefn {Built-in Function} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
-  if (args.length () > 0)
-    {
-      double val = args(0).xdouble_value ("__go_figure__: figure number must be a double value");
-
-      if (is_figure (val))
-        {
-          graphics_handle h = gh_manager::lookup (val);
-
-          xset (h, args.splice (0, 1));
+  if (args.length () == 0)
+    print_usage ();
+
+  double val = args(0).xdouble_value ("__go_figure__: figure number must be a double value");
+
+  if (is_figure (val))
+    {
+      graphics_handle h = gh_manager::lookup (val);
+
+      xset (h, args.splice (0, 1));
+
+      retval = h.value ();
+    }
+  else
+    {
+      bool int_fig_handle = true;
+
+      octave_value_list xargs = args.splice (0, 1);
+
+      graphics_handle h = octave_NaN;
+
+      if (xisnan (val))
+        {
+          caseless_str pname ("integerhandle");
+
+          for (int i = 0; i < xargs.length (); i++)
+            {
+              if (xargs(i).is_string ()
+                  && pname.compare (xargs(i).string_value ()))
+                {
+                  if (i < (xargs.length () - 1))
+                    {
+                      std::string pval = xargs(i+1).string_value ();
+
+                      caseless_str on ("on");
+                      int_fig_handle = on.compare (pval);
+                      xargs = xargs.splice (i, 2);
+
+                      break;
+                    }
+                }
+            }
+
+          h = gh_manager::make_graphics_handle ("figure", 0,
+                                                int_fig_handle,
+                                                false, false);
+
+          if (! int_fig_handle)
+            {
+              // We need to initialize the integerhandle property
+              // without calling the set_integerhandle method,
+              // because doing that will generate a new handle value...
+
+              graphics_object go = gh_manager::get_object (h);
+              go.get_properties ().init_integerhandle ("off");
+            }
+        }
+      else if (val > 0 && D_NINT (val) == val)
+        h = gh_manager::make_figure_handle (val, false);
+
+      if (h.ok ())
+        {
+          adopt (0, h);
+
+          gh_manager::push_figure (h);
+
+          xset (h, xargs);
+          xcreatefcn (h);
+          xinitialize (h);
 
           retval = h.value ();
         }
       else
-        {
-          bool int_fig_handle = true;
-
-          octave_value_list xargs = args.splice (0, 1);
-
-          graphics_handle h = octave_NaN;
-
-          if (xisnan (val))
-            {
-              caseless_str pname ("integerhandle");
-
-              for (int i = 0; i < xargs.length (); i++)
-                {
-                  if (xargs(i).is_string ()
-                      && pname.compare (xargs(i).string_value ()))
-                    {
-                      if (i < (xargs.length () - 1))
-                        {
-                          std::string pval = xargs(i+1).string_value ();
-
-                          caseless_str on ("on");
-                          int_fig_handle = on.compare (pval);
-                          xargs = xargs.splice (i, 2);
-
-                          break;
-                        }
-                    }
-                }
-
-              h = gh_manager::make_graphics_handle ("figure", 0,
-                                                    int_fig_handle,
-                                                    false, false);
-
-              if (! int_fig_handle)
-                {
-                  // We need to initialize the integerhandle property
-                  // without calling the set_integerhandle method,
-                  // because doing that will generate a new handle value...
-
-                  graphics_object go = gh_manager::get_object (h);
-                  go.get_properties ().init_integerhandle ("off");
-                }
-            }
-          else if (val > 0 && D_NINT (val) == val)
-            h = gh_manager::make_figure_handle (val, false);
-
-          if (h.ok ())
-            {
-              adopt (0, h);
-
-              gh_manager::push_figure (h);
-
-              xset (h, xargs);
-              xcreatefcn (h);
-              xinitialize (h);
-
-              retval = h.value ();
-            }
-          else
-            error ("__go_figure__: failed to create figure handle");
-        }
-    }
-  else
-    print_usage ();
+        error ("__go_figure__: failed to create figure handle");
+    }
 
   return retval;
 }
 
 #define GO_BODY(TYPE) \
   gh_manager::auto_lock guard; \
  \
-  octave_value retval; \
- \
-  if (args.length () > 0) \
-    retval = make_graphics_object (#TYPE, false, args);  \
-  else \
+  if (args.length () == 0) \
     print_usage (); \
  \
-  return retval
+  return octave_value (make_graphics_object (#TYPE, false, args)); \
 
 int
 calc_dimensions (const graphics_object& go)
 {
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
@@ -10398,30 +10376,24 @@ DEFUN (__calc_dimensions__, args, ,
 @deftypefn {Built-in Function} {} __calc_dimensions__ (@var{axes})\n\
 Internal function.\n\
 \n\
 Determine the number of dimensions in a graphics object, either 2 or 3.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
-
-      retval = calc_dimensions (gh_manager::get_object (h));
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
+
+  return octave_value (calc_dimensions (gh_manager::get_object (h)));
 }
 
 DEFUN (__go_axes__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -10550,40 +10522,38 @@ DEFUN (__go_delete__, args, ,
 @deftypefn {Built-in Function} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      graphics_handle h = octave_NaN;
-
-      const NDArray vals = args(0).xarray_value ("delete: invalid graphics object");
-
-      // Check all the handles to delete are valid first, as callbacks
-      // might delete one of the handles we later want to delete
-      for (octave_idx_type i = 0; i < vals.numel (); i++)
-        {
-          h = gh_manager::lookup (vals(i));
-
-          if (! h.ok ())
-            {
-              error ("delete: invalid graphics object (= %g)", vals(i));
-              break;
-            }
-        }
-
-      delete_graphics_objects (vals);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
+  graphics_handle h = octave_NaN;
+
+  const NDArray vals = args(0).xarray_value ("delete: invalid graphics object");
+
+  // Check all the handles to delete are valid first, as callbacks
+  // might delete one of the handles we later want to delete
+  for (octave_idx_type i = 0; i < vals.numel (); i++)
+    {
+      h = gh_manager::lookup (vals(i));
+
+      if (! h.ok ())
+        {
+          error ("delete: invalid graphics object (= %g)", vals(i));
+          break;
+        }
+    }
+
+  delete_graphics_objects (vals);
+
   return retval;
 }
 
 DEFUN (__go_axes_init__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes_init__ (@var{h}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn")
@@ -10594,40 +10564,38 @@ Undocumented internal function.\n\
 
   int nargin = args.length ();
 
   std::string mode = "";
 
   if (nargin == 2)
     mode = args(1).string_value ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      graphics_handle h = octave_NaN;
-
-      double val = args(0).xdouble_value ("__go_axes_init__: invalid graphics object");
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  graphics_handle h = octave_NaN;
+
+  double val = args(0).xdouble_value ("__go_axes_init__: invalid graphics object");
+
+  h = gh_manager::lookup (val);
+
+  if (h.ok ())
+    {
+      graphics_object go = gh_manager::get_object (h);
+
+      go.set_defaults (mode);
 
       h = gh_manager::lookup (val);
-
-      if (h.ok ())
-        {
-          graphics_object go = gh_manager::get_object (h);
-
-          go.set_defaults (mode);
-
-          h = gh_manager::lookup (val);
-          if (! h.ok ())
-            error ("__go_axes_init__: axis deleted during initialization (= %g)",
-                   val);
-        }
-      else
-        error ("__go_axes_init__: invalid graphics object (= %g)", val);
-    }
-  else
-    print_usage ();
+      if (! h.ok ())
+        error ("__go_axes_init__: axis deleted during initialization (= %g)",
+               val);
+    }
+  else
+    error ("__go_axes_init__: invalid graphics object (= %g)", val);
 
   return retval;
 }
 
 DEFUN (__go_handles__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
@@ -10665,72 +10633,67 @@ DEFUN (__go_execute_callback__, args, ,
 @deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
-    {
-      double val = args(0).xdouble_value ("__go_execute_callback__: invalid graphics object");
-
-      graphics_handle h = gh_manager::lookup (val);
-
-      if (h.ok ())
-        {
-          std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
-
-          if (nargin == 2)
-            gh_manager::execute_callback (h, name);
-          else
-            gh_manager::execute_callback (h, name, args(2));
-        }
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  double val = args(0).xdouble_value ("__go_execute_callback__: invalid graphics object");
+
+  graphics_handle h = gh_manager::lookup (val);
+
+  if (h.ok ())
+    {
+      std::string name = args(1).xstring_value ("__go_execute_callback__: invalid callback name");
+
+      if (nargin == 2)
+        gh_manager::execute_callback (h, name);
       else
-        error ("__go_execute_callback__: invalid graphics object (= %g)",
-               val);
-    }
-  else
-    print_usage ();
+        gh_manager::execute_callback (h, name, args(2));
+    }
+  else
+    error ("__go_execute_callback__: invalid graphics object (= %g)", val);
 
   return retval;
 }
 
 DEFUN (__image_pixel_size__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
 Internal function: returns the pixel size of the image in normalized units.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      double h = args(0).xdouble_value ("__image_pixel_size__: argument is not a handle");
-
-      graphics_object go = gh_manager::get_object (h);
-      if (go && go.isa ("image"))
-        {
-          image::properties& ip =
-            dynamic_cast<image::properties&> (go.get_properties ());
-
-          Matrix dp = Matrix (1, 2);
-          dp(0) = ip.pixel_xsize ();
-          dp(1) = ip.pixel_ysize ();
-          retval = dp;
-        }
-      else
-        error ("__image_pixel_size__: object is not an image");
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
+  double h = args(0).xdouble_value ("__image_pixel_size__: argument is not a handle");
+
+  graphics_object go = gh_manager::get_object (h);
+  if (go && go.isa ("image"))
+    {
+      image::properties& ip =
+        dynamic_cast<image::properties&> (go.get_properties ());
+
+      Matrix dp = Matrix (1, 2);
+      dp(0) = ip.pixel_xsize ();
+      dp(1) = ip.pixel_ysize ();
+      retval = dp;
+    }
+  else
+    error ("__image_pixel_size__: object is not an image");
+
   return retval;
 }
 
 gtk_manager *gtk_manager::instance = 0;
 
 void
 gtk_manager::create_instance (void)
 {
@@ -10837,25 +10800,23 @@ DEFUN (register_graphics_toolkit, args, 
 List @var{toolkit} as an available graphics toolkit.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
 
-  if (args.length () == 1)
-    {
-      std::string name = args(0).xstring_value ("register_graphics_toolkit: TOOLKIT must be a string");
-
-      gtk_manager::register_toolkit (name);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
+  std::string name = args(0).xstring_value ("register_graphics_toolkit: TOOLKIT must be a string");
+
+  gtk_manager::register_toolkit (name);
+
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
 @seealso{available_graphics_toolkits}\n\
@@ -10882,21 +10843,24 @@ The third calling form of @code{drawnow}
 undocumented.\n\
 @seealso{refresh}\n\
 @end deftypefn")
 {
   static int drawnow_executing = 0;
 
   octave_value retval;
 
+  if (args.length () > 4)
+    print_usage ();
+
   gh_manager::lock ();
 
   unwind_protect frame;
+
   frame.protect_var (Vdrawnow_requested, false);
-
   frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (args.length () == 0 || args.length () == 1)
         {
           Matrix hlist = gh_manager::figure_handle_list (true);
 
@@ -11032,18 +10996,16 @@ undocumented.\n\
 
               Fsleep (octave_value (0.05));
 
               gh_manager::lock ();
             }
           else
             error ("drawnow: nothing to draw");
         }
-      else
-        print_usage ();
     }
 
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
@@ -11080,43 +11042,41 @@ addlistener (gcf, \"position\", @{@@my_l
 \n\
 @seealso{addproperty, hggroup}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
-  if (args.length () >= 3 && args.length () <= 4)
-    {
-      double h = args(0).xdouble_value ("addlistener: invalid handle H");
-
-      std::string pname = args(1).xstring_value ("addlistener: PROP must be a string");
-
-      graphics_handle gh = gh_manager::lookup (h);
-
-      if (gh.ok ())
-        {
-          graphics_object go = gh_manager::get_object (gh);
-
-          go.add_property_listener (pname, args(2), POSTSET);
-
-          if (args.length () == 4)
-            {
-              caseless_str persistent = args(3).string_value ();
-              if (persistent.compare ("persistent"))
-                go.add_property_listener (pname, args(2), PERSISTENT);
-            }
-        }
-      else
-        error ("addlistener: invalid graphics object (= %g)", h);
-    }
-  else
+  if (args.length () < 3 || args.length () > 4)
     print_usage ();
 
+  double h = args(0).xdouble_value ("addlistener: invalid handle H");
+
+  std::string pname = args(1).xstring_value ("addlistener: PROP must be a string");
+
+  graphics_handle gh = gh_manager::lookup (h);
+
+  if (gh.ok ())
+    {
+      graphics_object go = gh_manager::get_object (gh);
+
+      go.add_property_listener (pname, args(2), POSTSET);
+
+      if (args.length () == 4)
+        {
+          caseless_str persistent = args(3).string_value ();
+          if (persistent.compare ("persistent"))
+            go.add_property_listener (pname, args(2), PERSISTENT);
+        }
+    }
+  else
+    error ("addlistener: invalid graphics object (= %g)", h);
+
   return retval;
 }
 
 DEFUN (dellistener, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} dellistener (@var{h}, @var{prop}, @var{fcn})\n\
 Remove the registration of @var{fcn} as a listener for the property\n\
 @var{prop} of the graphics object @var{h}.\n\
@@ -11142,49 +11102,47 @@ dellistener (gcf, \"position\", c);\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
-  if (args.length () == 3 || args.length () == 2)
-    {
-      double h = args(0).xdouble_value ("dellistener: invalid handle");
-
-      std::string pname = args(1).xstring_value ("dellistener: PROP must be a string");
-
-      graphics_handle gh = gh_manager::lookup (h);
-
-      if (gh.ok ())
-        {
-          graphics_object go = gh_manager::get_object (gh);
-
-          if (args.length () == 2)
-            go.delete_property_listener (pname, octave_value (), POSTSET);
+  if (args.length () < 2 || args.length () > 3)
+    print_usage ();
+
+  double h = args(0).xdouble_value ("dellistener: invalid handle");
+
+  std::string pname = args(1).xstring_value ("dellistener: PROP must be a string");
+
+  graphics_handle gh = gh_manager::lookup (h);
+
+  if (gh.ok ())
+    {
+      graphics_object go = gh_manager::get_object (gh);
+
+      if (args.length () == 2)
+        go.delete_property_listener (pname, octave_value (), POSTSET);
+      else
+        {
+          if (args(2).is_string ()
+              && args(2).string_value () == "persistent")
+            {
+              go.delete_property_listener (pname, octave_value (),
+                                           PERSISTENT);
+              go.delete_property_listener (pname, octave_value (),
+                                           POSTSET);
+            }
           else
-            {
-              if (args(2).is_string ()
-                  && args(2).string_value () == "persistent")
-                {
-                  go.delete_property_listener (pname, octave_value (),
-                                               PERSISTENT);
-                  go.delete_property_listener (pname, octave_value (),
-                                               POSTSET);
-                }
-              else
-                go.delete_property_listener (pname, args(2), POSTSET);
-            }
-        }
-      else
-        error ("dellistener: invalid graphics object (= %g)", h);
-    }
-  else
-    print_usage ();
+            go.delete_property_listener (pname, args(2), POSTSET);
+        }
+    }
+  else
+    error ("dellistener: invalid graphics object (= %g)", h);
 
   return retval;
 }
 
 DEFUN (addproperty, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type})\n\
 @deftypefnx {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type}, @var{arg}, @dots{})\n\
@@ -11255,46 +11213,44 @@ addproperty (\"my_style\", gcf, \"lineli
 \n\
 @seealso{addlistener, hggroup}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
-  if (args.length () >= 3)
-    {
-      std::string name = args(0).xstring_value ("addproperty: NAME must be a string");
-
-      double h = args(1).xdouble_value ("addproperty: invalid handle H");
-
-      graphics_handle gh = gh_manager::lookup (h);
-
-      if (gh.ok ())
-        {
-          graphics_object go = gh_manager::get_object (gh);
-
-          std::string type = args(2).xstring_value ("addproperty: TYPE must be a string");
-
-          if (! go.get_properties ().has_property (name))
-            {
-              property p = property::create (name, gh, type,
-                                             args.splice (0, 3));
-
-              go.get_properties ().insert_property (name, p);
-            }
-          else
-            error ("addproperty: a '%s' property already exists in the graphics object",
-                   name.c_str ());
+  if (args.length () < 3)
+    print_usage ();
+
+  std::string name = args(0).xstring_value ("addproperty: NAME must be a string");
+
+  double h = args(1).xdouble_value ("addproperty: invalid handle H");
+
+  graphics_handle gh = gh_manager::lookup (h);
+
+  if (gh.ok ())
+    {
+      graphics_object go = gh_manager::get_object (gh);
+
+      std::string type = args(2).xstring_value ("addproperty: TYPE must be a string");
+
+      if (! go.get_properties ().has_property (name))
+        {
+          property p = property::create (name, gh, type,
+                                         args.splice (0, 3));
+
+          go.get_properties ().insert_property (name, p);
         }
       else
-        error ("addproperty: invalid graphics object (= %g)", h);
-    }
-  else
-    print_usage ();
+        error ("addproperty: a '%s' property already exists in the graphics object",
+               name.c_str ());
+    }
+  else
+    error ("addproperty: invalid graphics object (= %g)", h);
 
   return retval;
 }
 
 octave_value
 get_property_from_handle (double handle, const std::string& property,
                           const std::string& func)
 {
@@ -11479,213 +11435,211 @@ not an integer, it is truncated towards 
 \n\
 To define a condition on a property named @code{timeout}, use the string\n\
 @code{\\timeout} instead.\n\
 \n\
 In all cases, typing CTRL-C stops program execution immediately.\n\
 @seealso{waitforbuttonpress, isequal}\n\
 @end deftypefn")
 {
-  if (args.length () > 0)
-    {
-      double h = args(0).xdouble_value ("waitfor: invalid handle value");
-
-      caseless_str pname;
-
-      unwind_protect frame;
-
-      static uint32_t id_counter = 0;
-      uint32_t id = 0;
-
-      int max_arg_index = 0;
-      int timeout_index = -1;
-
-      int timeout = 0;
-
-      if (args.length () > 1)
-        {
-          pname = args(1).xstring_value ("waitfor: PROP must be a string");
-
-          if (! pname.empty () && ! pname.compare ("timeout"))
-            {
-              if (pname.compare ("\\timeout"))
-                pname = "timeout";
-
-              static octave_value wf_listener;
-
-              if (! wf_listener.is_defined ())
-                wf_listener =
-                  octave_value (new octave_builtin (waitfor_listener,
-                                                    "waitfor_listener"));
-
-              max_arg_index++;
-              if (args.length () > 2)
+  if (args.length () == 0)
+    print_usage ();
+
+  double h = args(0).xdouble_value ("waitfor: invalid handle value");
+
+  caseless_str pname;
+
+  unwind_protect frame;
+
+  static uint32_t id_counter = 0;
+  uint32_t id = 0;
+
+  int max_arg_index = 0;
+  int timeout_index = -1;
+
+  int timeout = 0;
+
+  if (args.length () > 1)
+    {
+      pname = args(1).xstring_value ("waitfor: PROP must be a string");
+
+      if (! pname.empty () && ! pname.compare ("timeout"))
+        {
+          if (pname.compare ("\\timeout"))
+            pname = "timeout";
+
+          static octave_value wf_listener;
+
+          if (! wf_listener.is_defined ())
+            wf_listener =
+              octave_value (new octave_builtin (waitfor_listener,
+                                                "waitfor_listener"));
+
+          max_arg_index++;
+          if (args.length () > 2)
+            {
+              if (args(2).is_string ())
                 {
-                  if (args(2).is_string ())
-                    {
-                      caseless_str s = args(2).string_value ();
-
-                      if (s.compare ("timeout"))
-                        timeout_index = 2;
-                      else
-                        max_arg_index++;
-                    }
+                  caseless_str s = args(2).string_value ();
+
+                  if (s.compare ("timeout"))
+                    timeout_index = 2;
                   else
                     max_arg_index++;
                 }
-
-              Cell listener (1, max_arg_index >= 2 ? 5 : 4);
-
-              id = id_counter++;
-              frame.add_fcn (cleanup_waitfor_id, id);
-              waitfor_results[id] = false;
-
-              listener(0) = wf_listener;
-              listener(1) = octave_uint32 (id);
-              listener(2) = h;
-              listener(3) = pname;
-
-              if (max_arg_index >= 2)
-                listener(4) = args(2);
-
-              octave_value ov_listener (listener);
-
-              gh_manager::auto_lock guard;
-
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
+              else
+                max_arg_index++;
+            }
+
+          Cell listener (1, max_arg_index >= 2 ? 5 : 4);
+
+          id = id_counter++;
+          frame.add_fcn (cleanup_waitfor_id, id);
+          waitfor_results[id] = false;
+
+          listener(0) = wf_listener;
+          listener(1) = octave_uint32 (id);
+          listener(2) = h;
+          listener(3) = pname;
+
+          if (max_arg_index >= 2)
+            listener(4) = args(2);
+
+          octave_value ov_listener (listener);
+
+          gh_manager::auto_lock guard;
+
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              graphics_object go = gh_manager::get_object (gh);
+
+              if (max_arg_index >= 2
+                  && compare_property_values (go.get (pname),
+                                              args(2)))
+                waitfor_results[id] = true;
+              else
                 {
-                  graphics_object go = gh_manager::get_object (gh);
-
-                  if (max_arg_index >= 2
-                      && compare_property_values (go.get (pname),
-                                                  args(2)))
-                    waitfor_results[id] = true;
-                  else
+
+                  frame.add_fcn (cleanup_waitfor_postset_listener,
+                                 ov_listener);
+                  go.add_property_listener (pname, ov_listener,
+                                            POSTSET);
+                  go.add_property_listener (pname, ov_listener,
+                                            PERSISTENT);
+
+                  if (go.get_properties ()
+                      .has_dynamic_property (pname))
                     {
-
-                      frame.add_fcn (cleanup_waitfor_postset_listener,
-                                     ov_listener);
-                      go.add_property_listener (pname, ov_listener,
-                                                POSTSET);
-                      go.add_property_listener (pname, ov_listener,
-                                                PERSISTENT);
-
-                      if (go.get_properties ()
-                          .has_dynamic_property (pname))
-                        {
-                          static octave_value wf_del_listener;
-
-                          if (! wf_del_listener.is_defined ())
-                            wf_del_listener =
-                              octave_value (new octave_builtin
-                                            (waitfor_del_listener,
-                                             "waitfor_del_listener"));
-
-                          Cell del_listener (1, 4);
-
-                          del_listener(0) = wf_del_listener;
-                          del_listener(1) = octave_uint32 (id);
-                          del_listener(2) = h;
-                          del_listener(3) = pname;
-
-                          octave_value ov_del_listener (del_listener);
-
-                          frame.add_fcn (cleanup_waitfor_predelete_listener,
-                                         ov_del_listener);
-                          go.add_property_listener (pname, ov_del_listener,
-                                                    PREDELETE);
-                        }
+                      static octave_value wf_del_listener;
+
+                      if (! wf_del_listener.is_defined ())
+                        wf_del_listener =
+                          octave_value (new octave_builtin
+                                        (waitfor_del_listener,
+                                         "waitfor_del_listener"));
+
+                      Cell del_listener (1, 4);
+
+                      del_listener(0) = wf_del_listener;
+                      del_listener(1) = octave_uint32 (id);
+                      del_listener(2) = h;
+                      del_listener(3) = pname;
+
+                      octave_value ov_del_listener (del_listener);
+
+                      frame.add_fcn (cleanup_waitfor_predelete_listener,
+                                     ov_del_listener);
+                      go.add_property_listener (pname, ov_del_listener,
+                                                PREDELETE);
                     }
                 }
             }
-          else if (pname.empty ())
-            error ("waitfor: PROP must be a non-empty string");
-        }
-
-      if (timeout_index < 0 && args.length () > (max_arg_index + 1))
-        {
-          caseless_str s = args(max_arg_index + 1).xstring_value ("waitfor: invalid parameter, expected 'timeout'");
-
-          if (s.compare ("timeout"))
-            timeout_index = max_arg_index + 1;
-          else
-            error ("waitfor: invalid parameter '%s'", s.c_str ());
-        }
-
-      if (timeout_index >= 0)
-        {
-          if (args.length () > (timeout_index + 1))
-            {
-              timeout = static_cast<int>
-                (args(timeout_index + 1).xscalar_value ("waitfor: TIMEOUT must be a scalar >= 1"));
-
-              if (timeout < 1)
-                {
-                  warning ("waitfor: TIMEOUT value must be >= 1, using 1 instead");
-                  timeout = 1;
-                }
+        }
+      else if (pname.empty ())
+        error ("waitfor: PROP must be a non-empty string");
+    }
+
+  if (timeout_index < 0 && args.length () > (max_arg_index + 1))
+    {
+      caseless_str s = args(max_arg_index + 1).xstring_value ("waitfor: invalid parameter, expected 'timeout'");
+
+      if (s.compare ("timeout"))
+        timeout_index = max_arg_index + 1;
+      else
+        error ("waitfor: invalid parameter '%s'", s.c_str ());
+    }
+
+  if (timeout_index >= 0)
+    {
+      if (args.length () > (timeout_index + 1))
+        {
+          timeout = static_cast<int>
+            (args(timeout_index + 1).xscalar_value ("waitfor: TIMEOUT must be a scalar >= 1"));
+
+          if (timeout < 1)
+            {
+              warning ("waitfor: TIMEOUT value must be >= 1, using 1 instead");
+              timeout = 1;
+            }
+        }
+      else
+        error ("waitfor: missing TIMEOUT value");
+    }
+
+  // FIXME: There is still a "hole" in the following loop. The code
+  //        assumes that an object handle is unique, which is a fair
+  //        assumption, except for figures.  If a figure is destroyed
+  //        then recreated with the same figure ID, within the same
+  //        run of event hooks, then the figure destruction won't be
+  //        caught and the loop will not stop.  This is an unlikely
+  //        possibility in practice, though.
+  //
+  //        Using deletefcn callback is also unreliable as it could be
+  //        modified during a callback execution and the waitfor loop
+  //        would not stop.
+  //
+  //        The only "good" implementation would require object
+  //        listeners, similar to property listeners.
+
+  time_t start = 0;
+
+  if (timeout > 0)
+    start = time (0);
+
+  while (true)
+    {
+      if (true)
+        {
+          gh_manager::auto_lock guard;
+
+          graphics_handle gh = gh_manager::lookup (h);
+
+          if (gh.ok ())
+            {
+              if (! pname.empty () && waitfor_results[id])
+                break;
             }
           else
-            error ("waitfor: missing TIMEOUT value");
-        }
-
-      // FIXME: There is still a "hole" in the following loop. The code
-      //        assumes that an object handle is unique, which is a fair
-      //        assumption, except for figures.  If a figure is destroyed
-      //        then recreated with the same figure ID, within the same
-      //        run of event hooks, then the figure destruction won't be
-      //        caught and the loop will not stop.  This is an unlikely
-      //        possibility in practice, though.
-      //
-      //        Using deletefcn callback is also unreliable as it could be
-      //        modified during a callback execution and the waitfor loop
-      //        would not stop.
-      //
-      //        The only "good" implementation would require object
-      //        listeners, similar to property listeners.
-
-      time_t start = 0;
+            break;
+        }
+
+      octave_usleep (100000);
+
+      OCTAVE_QUIT;
+
+      command_editor::run_event_hooks ();
 
       if (timeout > 0)
-        start = time (0);
-
-      while (true)
-        {
-          if (true)
-            {
-              gh_manager::auto_lock guard;
-
-              graphics_handle gh = gh_manager::lookup (h);
-
-              if (gh.ok ())
-                {
-                  if (! pname.empty () && waitfor_results[id])
-                    break;
-                }
-              else
-                break;
-            }
-
-          octave_usleep (100000);
-
-          OCTAVE_QUIT;
-
-          command_editor::run_event_hooks ();
-
-          if (timeout > 0)
-            {
-              if (start + timeout < time (0))
-                break;
-            }
-        }
-    }
-  else
-    print_usage ();
+        {
+          if (start + timeout < time (0))
+            break;
+        }
+    }
 
   return octave_value ();
 }
 
 DEFUN (__zoom__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __zoom__ (@var{axes}, @var{mode}, @var{factor})\n\
 @deftypefnx {Built-in Function} {} __zoom__ (@var{axes}, \"out\")\n\
@@ -11693,20 +11647,17 @@ DEFUN (__zoom__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   double h = args(0).double_value ();
 
   gh_manager::auto_lock guard;
 
   graphics_handle handle = gh_manager::lookup (h);
 
   if (! handle.ok ())
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -64,20 +64,17 @@ IEEE Transactions on Automatic Control, 
 @seealso{eig, chol, lu, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -799,26 +799,22 @@ evaluating it first.\n\
 \n\
 Because there may be output waiting to be displayed by the pager, it is a\n\
 good idea to always call @code{fflush (stdout)} before calling @code{input}.\n\
  This will ensure that all pending output is written to the screen before\n\
 your prompt.\n\
 @seealso{yes_or_no, kbhit, pause, menu, listdlg}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    retval = get_user_input (args, std::max (nargout, 1));
-  else
+  if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  return retval;
+  return get_user_input (args, std::max (nargout, 1));
 }
 
 bool
 octave_yes_or_no (const std::string& prompt)
 {
   std::string prompt_string = prompt + "(yes or no) ";
 
   while (1)
@@ -845,33 +841,27 @@ Return logical true if the answer is yes
 \n\
 Takes one argument, @var{prompt}, which is the string to display when asking\n\
 the question.  @var{prompt} should end in a space; @code{yes-or-no} adds the\n\
 string @samp{(yes or no) } to it.  The user must confirm the answer with\n\
 @key{RET} and can edit it until it has been confirmed.\n\
 @seealso{input}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 0 || nargin == 1)
-    {
-      std::string prompt;
-
-      if (nargin == 1)
-        prompt = args(0).xstring_value ("yes_or_no: PROMPT must be a string");
-
-      retval = octave_yes_or_no (prompt);
-    }
-  else
+  if (nargin > 1)
     print_usage ();
 
-  return retval;
+  std::string prompt;
+
+  if (nargin == 1)
+    prompt = args(0).xstring_value ("yes_or_no: PROMPT must be a string");
+
+  return octave_value (octave_yes_or_no (prompt));
 }
 
 octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -924,35 +914,33 @@ If @code{keyboard} is invoked without ar
 @samp{debug> } is used.\n\
 @seealso{dbstop, dbcont, dbquit}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 0 || nargin == 1)
-    {
-      unwind_protect frame;
+  if (nargin > 1)
+    print_usage ();
 
-      frame.add_fcn (octave_call_stack::restore_frame,
-                     octave_call_stack::current_frame ());
+  unwind_protect frame;
 
-      // Skip the frame assigned to the keyboard function.
-      octave_call_stack::goto_frame_relative (0);
+  frame.add_fcn (octave_call_stack::restore_frame,
+                 octave_call_stack::current_frame ());
 
-      tree_evaluator::debug_mode = true;
-      tree_evaluator::quiet_breakpoint_flag = false;
-
-      tree_evaluator::current_frame = octave_call_stack::current_frame ();
+  // Skip the frame assigned to the keyboard function.
+  octave_call_stack::goto_frame_relative (0);
 
-      do_keyboard (args);
-    }
-  else
-    print_usage ();
+  tree_evaluator::debug_mode = true;
+  tree_evaluator::quiet_breakpoint_flag = false;
+
+  tree_evaluator::current_frame = octave_call_stack::current_frame ();
+
+  do_keyboard (args);
 
   return retval;
 }
 
 DEFUN (echo, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Command} {} echo\n\
 @deftypefnx {Command} {} echo on\n\
@@ -1104,70 +1092,68 @@ might be controlling Octave and handling
 command number is not incremented when this function is called.  This is\n\
 a feature, not a bug.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      std::string hint = args(0).string_value ();
+  if (nargin != 1)
+    print_usage ();
 
-      int n = 32;
+  std::string hint = args(0).string_value ();
 
-      string_vector list (n);
+  int n = 32;
+
+  string_vector list (n);
 
-      int k = 0;
+  int k = 0;
 
-      for (;;)
+  for (;;)
+    {
+      std::string cmd = generate_completion (hint, k);
+
+      if (! cmd.empty ())
         {
-          std::string cmd = generate_completion (hint, k);
-
-          if (! cmd.empty ())
+          if (k == n)
             {
-              if (k == n)
-                {
-                  n *= 2;
-                  list.resize (n);
-                }
-
-              list[k++] = cmd;
+              n *= 2;
+              list.resize (n);
             }
-          else
-            {
-              list.resize (k);
-              break;
-            }
-        }
 
-      if (nargout > 0)
-        {
-          if (! list.empty ())
-            retval = list;
-          else
-            retval = "";
+          list[k++] = cmd;
         }
       else
         {
-          // We don't use string_vector::list_in_columns here
-          // because it will be easier for Emacs if the names
-          // appear in a single column.
-
-          int len = list.numel ();
+          list.resize (k);
+          break;
+        }
+    }
 
-          for (int i = 0; i < len; i++)
-            octave_stdout << list[i] << "\n";
-        }
-
-      octave_completion_matches_called = true;
+  if (nargout > 0)
+    {
+      if (! list.empty ())
+        retval = list;
+      else
+        retval = "";
     }
   else
-    print_usage ();
+    {
+      // We don't use string_vector::list_in_columns here
+      // because it will be easier for Emacs if the names
+      // appear in a single column.
+
+      int len = list.numel ();
+
+      for (int i = 0; i < len; i++)
+        octave_stdout << list[i] << "\n";
+    }
+
+  octave_completion_matches_called = true;
 
   return retval;
 }
 
 /*
 %!assert (ischar (completion_matches ("")))
 %!assert (ischar (completion_matches ("a")))
 %!assert (ischar (completion_matches (" ")))
@@ -1194,47 +1180,48 @@ If @var{file} is omitted, read the defau
 for details.\n\
 @seealso{readline_re_read_init_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 0)
     command_editor::read_init_file ();
-  else if (nargin == 1)
+  else
     {
       std::string file = args(0).string_value ();
 
       command_editor::read_init_file (file);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (readline_re_read_init_file, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} readline_re_read_init_file ()\n\
 Re-read the last readline library initialization file that was read.\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_read_init_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 0)
-    command_editor::re_read_init_file ();
-  else
+  if (args.length () != 0)
     print_usage ();
 
+  command_editor::re_read_init_file ();
+
   return retval;
 }
 
 static int
 internal_input_event_hook_fcn (void)
 {
   input_event_hook_functions.run ();
 
@@ -1259,76 +1246,68 @@ The function should have the form\n\
 \n\
 If @var{data} is omitted, Octave calls the function without any arguments.\n\
 \n\
 The returned identifier may be used to remove the function handle from the\n\
 list of input hook functions.\n\
 @seealso{remove_input_event_hook}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_value user_data;
-
-      if (nargin == 2)
-        user_data = args(1);
-
-      hook_function hook_fcn (args(0), user_data);
-
-      if (input_event_hook_functions.empty ())
-        command_editor::add_event_hook (internal_input_event_hook_fcn);
-
-      input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
-
-      retval = hook_fcn.id ();
-    }
-  else
+  if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  return retval;
+  octave_value user_data;
+
+  if (nargin == 2)
+    user_data = args(1);
+
+  hook_function hook_fcn (args(0), user_data);
+
+  if (input_event_hook_functions.empty ())
+    command_editor::add_event_hook (internal_input_event_hook_fcn);
+
+  input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
+
+  return octave_value (hook_fcn.id ());
 }
 
 DEFUN (remove_input_event_hook, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} remove_input_event_hook (@var{name})\n\
 @deftypefnx {Built-in Function} {} remove_input_event_hook (@var{fcn_id})\n\
 Remove the named function or function handle with the given identifier\n\
 from the list of functions to call periodically when Octave is waiting\n\
 for input.\n\
 @seealso{add_input_event_hook}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      std::string hook_fcn_id = args(0).string_value ("remove_input_event_hook: argument not valid as a hook function name or id");
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-      bool warn = (nargin < 2);
+  std::string hook_fcn_id = args(0).string_value ("remove_input_event_hook: argument not valid as a hook function name or id");
 
-      hook_function_list::iterator p
-        = input_event_hook_functions.find (hook_fcn_id);
+  bool warn = (nargin < 2);
 
-      if (p != input_event_hook_functions.end ())
-        input_event_hook_functions.erase (p);
-      else if (warn)
-        warning ("remove_input_event_hook: %s not found in list",
-                 hook_fcn_id.c_str ());
+  hook_function_list::iterator p
+    = input_event_hook_functions.find (hook_fcn_id);
 
-      if (input_event_hook_functions.empty ())
-        command_editor::remove_event_hook (internal_input_event_hook_fcn);
-    }
-  else
-    print_usage ();
+  if (p != input_event_hook_functions.end ())
+    input_event_hook_functions.erase (p);
+  else if (warn)
+    warning ("remove_input_event_hook: %s not found in list",
+             hook_fcn_id.c_str ());
+
+  if (input_event_hook_functions.empty ())
+    command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
@@ -1470,42 +1449,44 @@ DEFUN (__request_drawnow__, args, ,
 @deftypefnx {Built-in Function} {} __request_drawnow__ (@var{flag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 0)
     Vdrawnow_requested = true;
-  else if (nargin == 1)
+  else
     Vdrawnow_requested = args(0).bool_value ();
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (__gud_mode__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __gud_mode__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 0)
     retval = Vgud_mode;
-  else if (nargin == 1)
+  else
     Vgud_mode = args(0).bool_value ();
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} filemarker ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} filemarker (@var{new_val})\n\
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -263,27 +263,27 @@ kron (kron (@var{A1}, @var{A2}), @dots{}
 @noindent\n\
 Since the Kronecker product is associative, this is well-defined.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin >= 2)
-    {
-      octave_value a = args(0);
-      octave_value b = args(1);
-      retval = dispatch_kron (a, b);
-      for (octave_idx_type i = 2; i < nargin; i++)
-        retval = dispatch_kron (retval, args(i));
-    }
-  else
+  if (nargin < 2)
     print_usage ();
 
+  octave_value a = args(0);
+  octave_value b = args(1);
+
+  retval = dispatch_kron (a, b);
+
+  for (octave_idx_type i = 2; i < nargin; i++)
+    retval = dispatch_kron (retval, args(i));
+
   return retval;
 }
 
 
 /*
 %!test
 %! x = ones (2);
 %! assert (kron (x, x), ones (4));
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -710,22 +710,19 @@ Force Octave to assume the file is in Oc
         }
       else
         break;
     }
 
   if (orig_fname == "")
     {
       if (i == argc)
-        {
-          print_usage ();
-          return retval;
-        }
-      else
-        orig_fname = argv[i];
+        print_usage ();
+
+      orig_fname = argv[i];
     }
   else
     i--;
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
 
   bool swap = false;
 
@@ -1615,20 +1612,17 @@ the file @file{data} in Octave's binary 
 
   // override from command line
   argv = parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
   int argc = argv.numel ();
   int i = 0;
 
   if (i == argc)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (save_as_floats && format == LS_TEXT)
     {
       error ("save: cannot specify both -text and -float-binary");
       return retval;
     }
 
   if (argv[i] == "-")
@@ -1655,20 +1649,17 @@ the file @file{data} in Octave's binary 
               retval = octave_value (output_buf.str());
             }
         }
     }
 
   // Guard against things like 'save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
   else
     {
       std::string fname = file_ops::tilde_expand (argv[i]);
 
       i++;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -271,181 +271,179 @@ parameters for @code{lsode}.\n\
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("lsode: invalid recursive call");
 
   int nargin = args.length ();
 
-  if (nargin > 2 && nargin < 5 && nargout < 4)
+  if (nargin < 3 || nargin > 4 || nargout > 3)
+    print_usage ();
+
+  std::string fcn_name, fname, jac_name, jname;
+  lsode_fcn = 0;
+  lsode_jac = 0;
+
+  octave_value f_arg = args(0);
+
+  if (f_arg.is_cell ())
     {
-      std::string fcn_name, fname, jac_name, jname;
-      lsode_fcn = 0;
-      lsode_jac = 0;
-
-      octave_value f_arg = args(0);
+      Cell c = f_arg.cell_value ();
+      if (c.numel () == 1)
+        f_arg = c(0);
+      else if (c.numel () == 2)
+        {
+          if (c(0).is_function_handle () || c(0).is_inline_function ())
+            lsode_fcn = c(0).function_value ();
+          else
+            {
+              fcn_name = unique_symbol_name ("__lsode_fcn__");
+              fname = "function y = ";
+              fname.append (fcn_name);
+              fname.append (" (x, t) y = ");
+              lsode_fcn = extract_function (c(0), "lsode", fcn_name, fname,
+                                            "; endfunction");
+            }
 
-      if (f_arg.is_cell ())
+          if (lsode_fcn)
+            {
+              if (c(1).is_function_handle () || c(1).is_inline_function ())
+                lsode_jac = c(1).function_value ();
+              else
+                {
+                  jac_name = unique_symbol_name ("__lsode_jac__");
+                  jname = "function jac = ";
+                  jname.append (jac_name);
+                  jname.append (" (x, t) jac = ");
+                  lsode_jac = extract_function (c(1), "lsode", jac_name,
+                                                jname, "; endfunction");
+
+                  if (!lsode_jac)
+                    {
+                      if (fcn_name.length ())
+                        clear_function (fcn_name);
+                      lsode_fcn = 0;
+                    }
+                }
+            }
+        }
+      else
+        error ("lsode: incorrect number of elements in cell array");
+    }
+
+  if (!lsode_fcn && ! f_arg.is_cell ())
+    {
+      if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+        lsode_fcn = f_arg.function_value ();
+      else
         {
-          Cell c = f_arg.cell_value ();
-          if (c.numel () == 1)
-            f_arg = c(0);
-          else if (c.numel () == 2)
+          switch (f_arg.rows ())
             {
-              if (c(0).is_function_handle () || c(0).is_inline_function ())
-                lsode_fcn = c(0).function_value ();
-              else
+            case 1:
+              do
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, t) y = ");
-                  lsode_fcn = extract_function (c(0), "lsode", fcn_name, fname,
-                                                "; endfunction");
+                  lsode_fcn = extract_function (f_arg, "lsode", fcn_name,
+                                                fname, "; endfunction");
                 }
+              while (0);
+              break;
 
-              if (lsode_fcn)
-                {
-                  if (c(1).is_function_handle () || c(1).is_inline_function ())
-                    lsode_jac = c(1).function_value ();
-                  else
-                    {
-                      jac_name = unique_symbol_name ("__lsode_jac__");
-                      jname = "function jac = ";
-                      jname.append (jac_name);
-                      jname.append (" (x, t) jac = ");
-                      lsode_jac = extract_function (c(1), "lsode", jac_name,
-                                                    jname, "; endfunction");
-
-                      if (!lsode_jac)
-                        {
-                          if (fcn_name.length ())
-                            clear_function (fcn_name);
-                          lsode_fcn = 0;
-                        }
-                    }
-                }
-            }
-          else
-            error ("lsode: incorrect number of elements in cell array");
-        }
+            case 2:
+              {
+                string_vector tmp = f_arg.all_strings ();
 
-      if (!lsode_fcn && ! f_arg.is_cell ())
-        {
-          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-            lsode_fcn = f_arg.function_value ();
-          else
-            {
-              switch (f_arg.rows ())
-                {
-                case 1:
-                  do
-                    {
-                      fcn_name = unique_symbol_name ("__lsode_fcn__");
-                      fname = "function y = ";
-                      fname.append (fcn_name);
-                      fname.append (" (x, t) y = ");
-                      lsode_fcn = extract_function (f_arg, "lsode", fcn_name,
-                                                    fname, "; endfunction");
-                    }
-                  while (0);
-                  break;
+                fcn_name = unique_symbol_name ("__lsode_fcn__");
+                fname = "function y = ";
+                fname.append (fcn_name);
+                fname.append (" (x, t) y = ");
+                lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
+                                              fname, "; endfunction");
 
-                case 2:
+                if (lsode_fcn)
                   {
-                    string_vector tmp = f_arg.all_strings ();
+                    jac_name = unique_symbol_name ("__lsode_jac__");
+                    jname = "function jac = ";
+                    jname.append (jac_name);
+                    jname.append (" (x, t) jac = ");
+                    lsode_jac = extract_function (tmp(1), "lsode",
+                                                  jac_name, jname,
+                                                  "; endfunction");
 
-                    fcn_name = unique_symbol_name ("__lsode_fcn__");
-                    fname = "function y = ";
-                    fname.append (fcn_name);
-                    fname.append (" (x, t) y = ");
-                    lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
-                                                  fname, "; endfunction");
-
-                    if (lsode_fcn)
+                    if (!lsode_jac)
                       {
-                        jac_name = unique_symbol_name ("__lsode_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, t) jac = ");
-                        lsode_jac = extract_function (tmp(1), "lsode",
-                                                      jac_name, jname,
-                                                      "; endfunction");
-
-                        if (!lsode_jac)
-                          {
-                            if (fcn_name.length ())
-                              clear_function (fcn_name);
-                            lsode_fcn = 0;
-                          }
+                        if (fcn_name.length ())
+                          clear_function (fcn_name);
+                        lsode_fcn = 0;
                       }
                   }
-                  break;
+              }
+              break;
 
-                default:
-                  error ("lsode: first arg should be a string or 2-element string array");
-                }
+            default:
+              error ("lsode: first arg should be a string or 2-element string array");
             }
         }
+    }
 
-      if (! lsode_fcn)
-        error ("lsode: FCN argument is not a valid function name or handle");
+  if (! lsode_fcn)
+    error ("lsode: FCN argument is not a valid function name or handle");
 
-      ColumnVector state = args(1).xvector_value ("lsode: initial state X_0 must be a vector");
-      ColumnVector out_times = args(2).xvector_value ("lsode: output time variable T must be a vector");
+  ColumnVector state = args(1).xvector_value ("lsode: initial state X_0 must be a vector");
+  ColumnVector out_times = args(2).xvector_value ("lsode: output time variable T must be a vector");
 
-      ColumnVector crit_times;
+  ColumnVector crit_times;
 
-      int crit_times_set = 0;
-      if (nargin > 3)
-        {
-          crit_times = args(3).xvector_value ("lsode: list of critical times T_CRIT must be a vector");
+  int crit_times_set = 0;
+  if (nargin > 3)
+    {
+      crit_times = args(3).xvector_value ("lsode: list of critical times T_CRIT must be a vector");
 
-          crit_times_set = 1;
-        }
+      crit_times_set = 1;
+    }
 
-      double tzero = out_times (0);
+  double tzero = out_times (0);
 
-      ODEFunc func (lsode_user_function);
-      if (lsode_jac)
-        func.set_jacobian_function (lsode_user_jacobian);
+  ODEFunc func (lsode_user_function);
+  if (lsode_jac)
+    func.set_jacobian_function (lsode_user_jacobian);
 
-      LSODE ode (state, tzero, func);
-
-      ode.set_options (lsode_opts);
+  LSODE ode (state, tzero, func);
 
-      Matrix output;
-      if (crit_times_set)
-        output = ode.integrate (out_times, crit_times);
-      else
-        output = ode.integrate (out_times);
+  ode.set_options (lsode_opts);
 
-      if (fcn_name.length ())
-        clear_function (fcn_name);
-      if (jac_name.length ())
-        clear_function (jac_name);
+  Matrix output;
+  if (crit_times_set)
+    output = ode.integrate (out_times, crit_times);
+  else
+    output = ode.integrate (out_times);
 
-      std::string msg = ode.error_message ();
+  if (fcn_name.length ())
+    clear_function (fcn_name);
+  if (jac_name.length ())
+    clear_function (jac_name);
 
-      retval(2) = msg;
-      retval(1) = static_cast<double> (ode.integration_state ());
+  std::string msg = ode.error_message ();
+
+  retval(2) = msg;
+  retval(1) = static_cast<double> (ode.integration_state ());
 
-      if (ode.integration_ok ())
-        retval(0) = output;
-      else
-        {
-          retval(0) = Matrix ();
+  if (ode.integration_ok ())
+    retval(0) = output;
+  else
+    {
+      retval(0) = Matrix ();
 
-          if (nargout < 2)
-            error ("lsode: %s", msg.c_str ());
-        }
+      if (nargout < 2)
+        error ("lsode: %s", msg.c_str ());
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 
 ## dassl-1.m
 ##
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -96,251 +96,247 @@ are the same as for @code{lu}.\n\
 Given the string argument @qcode{\"vector\"}, @code{luinc} returns the\n\
 values of @var{p} @var{q} as vector values.\n\
 @seealso{sparse, lu, ilu, ichol}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
-  if (nargin == 0)
+  if (nargin < 2 || nargin > 3)
     print_usage ();
-  else if (nargin < 2 || nargin > 3)
-    error ("luinc: incorrect number of arguments");
-  else
-    {
-      bool zero_level = false;
-      bool milu = false;
-      bool udiag = false;
-      Matrix thresh;
-      double droptol = -1.;
-      bool vecout = false;
+
+  bool zero_level = false;
+  bool milu = false;
+  bool udiag = false;
+  Matrix thresh;
+  double droptol = -1.;
+  bool vecout = false;
 
-      if (args(1).is_string ())
-        {
-          if (args(1).string_value () == "0")
-            zero_level = true;
-          else
-            error ("luinc: unrecognized string argument");
-        }
-      else if (args(1).is_map ())
-        {
-          octave_scalar_map map = args(1).xscalar_map_value ("luinc: OPTS must be a scalar structure");
-
-          octave_value tmp;
-
-          tmp = map.getfield ("droptol");
-          if (tmp.is_defined ())
-            droptol = tmp.double_value ();
-
-          tmp = map.getfield ("milu");
-          if (tmp.is_defined ())
-            {
-              double val = tmp.double_value ();
+  if (args(1).is_string ())
+    {
+      if (args(1).string_value () == "0")
+        zero_level = true;
+      else
+        error ("luinc: unrecognized string argument");
+    }
+  else if (args(1).is_map ())
+    {
+      octave_scalar_map map = args(1).xscalar_map_value ("luinc: OPTS must be a scalar structure");
 
-              milu = (val == 0. ? false : true);
-            }
-
-          tmp = map.getfield ("udiag");
-          if (tmp.is_defined ())
-            {
-              double val = tmp.double_value ();
+      octave_value tmp;
 
-              udiag = (val == 0. ? false : true);
-            }
-
-          tmp = map.getfield ("thresh");
-          if (tmp.is_defined ())
-            {
-              thresh = tmp.matrix_value ();
+      tmp = map.getfield ("droptol");
+      if (tmp.is_defined ())
+        droptol = tmp.double_value ();
 
-              if (thresh.numel () == 1)
-                {
-                  thresh.resize (1,2);
-                  thresh(1) = thresh(0);
-                }
-              else if (thresh.numel () != 2)
-                {
-                  error ("luinc: THRESH must be a 1 or 2-element vector");
-                  return retval;
-                }
-            }
+      tmp = map.getfield ("milu");
+      if (tmp.is_defined ())
+        {
+          double val = tmp.double_value ();
+
+          milu = (val == 0. ? false : true);
         }
-      else
-        droptol = args(1).double_value ();
 
-      if (nargin == 3)
+      tmp = map.getfield ("udiag");
+      if (tmp.is_defined ())
         {
-          std::string tmp = args(2).string_value ();
+          double val = tmp.double_value ();
 
-          if (tmp.compare ("vector") == 0)
-            vecout = true;
-          else
-            error ("luinc: unrecognized string argument");
+          udiag = (val == 0. ? false : true);
         }
 
-      // FIXME: Add code for zero-level factorization
-      if (zero_level)
-        error ("luinc: zero-level factorization not implemented");
-
-      if (args(0).type_name () == "sparse matrix")
+      tmp = map.getfield ("thresh");
+      if (tmp.is_defined ())
         {
-          SparseMatrix sm = args(0).sparse_matrix_value ();
-          octave_idx_type sm_nr = sm.rows ();
-          octave_idx_type sm_nc = sm.cols ();
-          ColumnVector Qinit (sm_nc);
-
-          for (octave_idx_type i = 0; i < sm_nc; i++)
-            Qinit (i) = i;
-
-          switch (nargout)
-            {
-            case 0:
-            case 1:
-            case 2:
-              {
-                SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-                               milu, udiag);
-
-                SparseMatrix P = fact.Pr ();
-                SparseMatrix L = P.transpose () * fact.L ();
-
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
-
-                retval(0)
-                  = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
-                                                 sm_nr, fact.row_perm ()));
-              }
-              break;
+          thresh = tmp.matrix_value ();
 
-            case 3:
-              {
-                SparseLU fact (sm, Qinit, thresh, false, true, droptol,
-                               milu, udiag);
-
-                if (vecout)
-                  retval(2) = fact.Pr_vec ();
-                else
-                  retval(2) = fact.Pr_mat ();
-
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
-
-                retval(0)
-                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
-              }
-              break;
-
-            case 4:
-            default:
-              {
-                SparseLU fact (sm, Qinit, thresh, false, false, droptol,
-                               milu, udiag);
-
-                if (vecout)
-                  {
-                    retval(3) = fact.Pc_vec ();
-                    retval(2) = fact.Pr_vec ();
-                  }
-                else
-                  {
-                    retval(3) = fact.Pc_mat ();
-                    retval(2) = fact.Pr_mat ();
-                  }
-
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
-
-                retval(0)
-                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
-              }
-              break;
+          if (thresh.numel () == 1)
+            {
+              thresh.resize (1,2);
+              thresh(1) = thresh(0);
+            }
+          else if (thresh.numel () != 2)
+            {
+              error ("luinc: THRESH must be a 1 or 2-element vector");
+              return retval;
             }
         }
-      else if (args(0).type_name () == "sparse complex matrix")
+    }
+  else
+    droptol = args(1).double_value ();
+
+  if (nargin == 3)
+    {
+      std::string tmp = args(2).string_value ();
+
+      if (tmp.compare ("vector") == 0)
+        vecout = true;
+      else
+        error ("luinc: unrecognized string argument");
+    }
+
+  // FIXME: Add code for zero-level factorization
+  if (zero_level)
+    error ("luinc: zero-level factorization not implemented");
+
+  if (args(0).type_name () == "sparse matrix")
+    {
+      SparseMatrix sm = args(0).sparse_matrix_value ();
+      octave_idx_type sm_nr = sm.rows ();
+      octave_idx_type sm_nc = sm.cols ();
+      ColumnVector Qinit (sm_nc);
+
+      for (octave_idx_type i = 0; i < sm_nc; i++)
+        Qinit (i) = i;
+
+      switch (nargout)
         {
-          SparseComplexMatrix sm =
-            args(0).sparse_complex_matrix_value ();
-          octave_idx_type sm_nr = sm.rows ();
-          octave_idx_type sm_nc = sm.cols ();
-          ColumnVector Qinit (sm_nc);
+        case 0:
+        case 1:
+        case 2:
+          {
+            SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                           milu, udiag);
+
+            SparseMatrix P = fact.Pr ();
+            SparseMatrix L = P.transpose () * fact.L ();
+
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+            retval(0)
+              = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                             sm_nr, fact.row_perm ()));
+          }
+          break;
+
+        case 3:
+          {
+            SparseLU fact (sm, Qinit, thresh, false, true, droptol,
+                           milu, udiag);
 
-          for (octave_idx_type i = 0; i < sm_nc; i++)
-            Qinit (i) = i;
+            if (vecout)
+              retval(2) = fact.Pr_vec ();
+            else
+              retval(2) = fact.Pr_mat ();
+
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+            retval(0)
+              = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+          }
+          break;
+
+        case 4:
+        default:
+          {
+            SparseLU fact (sm, Qinit, thresh, false, false, droptol,
+                           milu, udiag);
 
-          switch (nargout)
-            {
-            case 0:
-            case 1:
-            case 2:
+            if (vecout)
+              {
+                retval(3) = fact.Pc_vec ();
+                retval(2) = fact.Pr_vec ();
+              }
+            else
               {
-                SparseComplexLU fact (sm, Qinit, thresh, false, true,
-                                      droptol, milu, udiag);
+                retval(3) = fact.Pc_mat ();
+                retval(2) = fact.Pr_mat ();
+              }
+
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+
+            retval(0)
+              = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+          }
+          break;
+        }
+    }
+  else if (args(0).type_name () == "sparse complex matrix")
+    {
+      SparseComplexMatrix sm =
+        args(0).sparse_complex_matrix_value ();
+      octave_idx_type sm_nr = sm.rows ();
+      octave_idx_type sm_nc = sm.cols ();
+      ColumnVector Qinit (sm_nc);
+
+      for (octave_idx_type i = 0; i < sm_nc; i++)
+        Qinit (i) = i;
+
+      switch (nargout)
+        {
+        case 0:
+        case 1:
+        case 2:
+          {
+            SparseComplexLU fact (sm, Qinit, thresh, false, true,
+                                  droptol, milu, udiag);
 
 
-                SparseMatrix P = fact.Pr ();
-                SparseComplexMatrix L = P.transpose () * fact.L ();
+            SparseMatrix P = fact.Pr ();
+            SparseComplexMatrix L = P.transpose () * fact.L ();
 
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-                retval(0)
-                  = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
-                                                 sm_nr, fact.row_perm ()));
-              }
-              break;
+            retval(0)
+              = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                             sm_nr, fact.row_perm ()));
+          }
+          break;
 
-            case 3:
-              {
-                SparseComplexLU fact (sm, Qinit, thresh, false, true,
-                                      droptol, milu, udiag);
+        case 3:
+          {
+            SparseComplexLU fact (sm, Qinit, thresh, false, true,
+                                  droptol, milu, udiag);
 
-                if (vecout)
-                  retval(2) = fact.Pr_vec ();
-                else
-                  retval(2) = fact.Pr_mat ();
+            if (vecout)
+              retval(2) = fact.Pr_vec ();
+            else
+              retval(2) = fact.Pr_mat ();
 
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
-
-                retval(0)
-                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
-              }
-              break;
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-            case 4:
-            default:
-              {
-                SparseComplexLU fact (sm, Qinit, thresh, false, false,
-                                      droptol, milu, udiag);
+            retval(0)
+              = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+          }
+          break;
+
+        case 4:
+        default:
+          {
+            SparseComplexLU fact (sm, Qinit, thresh, false, false,
+                                  droptol, milu, udiag);
 
-                if (vecout)
-                  {
-                    retval(3) = fact.Pc_vec ();
-                    retval(2) = fact.Pr_vec ();
-                  }
-                else
-                  {
-                    retval(3) = fact.Pc_mat ();
-                    retval(2) = fact.Pr_mat ();
-                  }
+            if (vecout)
+              {
+                retval(3) = fact.Pc_vec ();
+                retval(2) = fact.Pr_vec ();
+              }
+            else
+              {
+                retval(3) = fact.Pc_mat ();
+                retval(2) = fact.Pr_mat ();
+              }
 
-                retval(1)
-                  = octave_value (fact.U (), MatrixType (MatrixType::Upper));
+            retval(1)
+              = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
-                retval(0)
-                  = octave_value (fact.L (), MatrixType (MatrixType::Lower));
-              }
-              break;
-            }
+            retval(0)
+              = octave_value (fact.L (), MatrixType (MatrixType::Lower));
+          }
+          break;
         }
-      else
-        error ("luinc: matrix A must be sparse");
     }
+  else
+    error ("luinc: matrix A must be sparse");
 
   return retval;
 }
 
 /*
 %!testif HAVE_UMFPACK
 %! a = sparse ([1,2,0,0;0,1,2,0;1e-14,0,3,0;0,0,0,1]);
 %! [l,u] = luinc (a, 1e-10);
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -117,343 +117,339 @@ such a matrix is factorized, a Cholesky@
 attempted, and if that fails the matrix is then treated with an\n\
 LU@tie{}factorization.  Once the matrix has been factorized,\n\
 @code{matrix_type} will return the correct classification of the matrix.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
-  if (nargin == 0)
+  if (nargin == 0 || nargin > 4)
     print_usage ();
-  else if (nargin > 4)
-    error ("matrix_type: incorrect number of arguments");
+
+  bool autocomp = true;
+  if (nargin == 2 && args(1).is_string ()
+      && args(1).string_value () == "nocompute")
+    {
+      nargin = 1;
+      autocomp = false;
+    }
+
+  if (args(0).is_scalar_type ())
+    {
+      if (nargin == 1)
+        retval = octave_value ("Diagonal");
+      else
+        retval = args(0);
+    }
+  else if (args(0).is_sparse_type ())
+    {
+      if (nargin == 1)
+        {
+          MatrixType mattyp;
+
+          if (args(0).is_complex_type ())
+            {
+              mattyp = args(0).matrix_type ();
+
+              if (mattyp.is_unknown () && autocomp)
+                {
+                  SparseComplexMatrix m =
+                    args(0).sparse_complex_matrix_value ();
+
+                  mattyp = MatrixType (m);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+          else
+            {
+              mattyp = args(0).matrix_type ();
+
+              if (mattyp.is_unknown () && autocomp)
+                {
+                  SparseMatrix m = args(0).sparse_matrix_value ();
+
+                  mattyp = MatrixType (m);
+                  args(0).matrix_type (mattyp);
+                }
+            }
+
+          int typ = mattyp.type ();
+
+          if (typ == MatrixType::Diagonal)
+            retval = octave_value ("Diagonal");
+          else if (typ == MatrixType::Permuted_Diagonal)
+            retval = octave_value ("Permuted Diagonal");
+          else if (typ == MatrixType::Upper)
+            retval = octave_value ("Upper");
+          else if (typ == MatrixType::Permuted_Upper)
+            retval = octave_value ("Permuted Upper");
+          else if (typ == MatrixType::Lower)
+            retval = octave_value ("Lower");
+          else if (typ == MatrixType::Permuted_Lower)
+            retval = octave_value ("Permuted Lower");
+          else if (typ == MatrixType::Banded)
+            retval = octave_value ("Banded");
+          else if (typ == MatrixType::Banded_Hermitian)
+            retval = octave_value ("Banded Positive Definite");
+          else if (typ == MatrixType::Tridiagonal)
+            retval = octave_value ("Tridiagonal");
+          else if (typ == MatrixType::Tridiagonal_Hermitian)
+            retval = octave_value ("Tridiagonal Positive Definite");
+          else if (typ == MatrixType::Hermitian)
+            retval = octave_value ("Positive Definite");
+          else if (typ == MatrixType::Rectangular)
+            {
+              if (args(0).rows () == args(0).columns ())
+                retval = octave_value ("Singular");
+              else
+                retval = octave_value ("Rectangular");
+            }
+          else if (typ == MatrixType::Full)
+            retval = octave_value ("Full");
+          else
+            retval = octave_value ("Unknown");
+        }
+      else
+        {
+          // Ok, we're changing the matrix type
+
+          std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
+
+          // FIXME: why do I have to explicitly call the constructor?
+          MatrixType mattyp = MatrixType ();
+
+          octave_idx_type nl = 0;
+          octave_idx_type nu = 0;
+
+          // Use STL function to convert to lower case
+          std::transform (str_typ.begin (), str_typ.end (),
+                          str_typ.begin (), tolower);
+
+          if (str_typ == "diagonal")
+            mattyp.mark_as_diagonal ();
+          if (str_typ == "permuted diagonal")
+            mattyp.mark_as_permuted_diagonal ();
+          else if (str_typ == "upper")
+            mattyp.mark_as_upper_triangular ();
+          else if (str_typ == "lower")
+            mattyp.mark_as_lower_triangular ();
+          else if (str_typ == "banded"
+                   || str_typ == "banded positive definite")
+            {
+              if (nargin != 4)
+                error ("matrix_type: banded matrix type requires 4 arguments");
+              else
+                {
+                  nl = args(2).xnint_value ("matrix_type: band size NL, NU must be integers");
+                  nu = args(3).xnint_value ("matrix_type: band size NL, NU must be integers");
+
+                  if (nl == 1 && nu == 1)
+                    mattyp.mark_as_tridiagonal ();
+                  else
+                    mattyp.mark_as_banded (nu, nl);
+
+                  if (str_typ == "banded positive definite")
+                    mattyp.mark_as_symmetric ();
+                }
+            }
+          else if (str_typ == "positive definite")
+            {
+              mattyp.mark_as_full ();
+              mattyp.mark_as_symmetric ();
+            }
+          else if (str_typ == "singular")
+            mattyp.mark_as_rectangular ();
+          else if (str_typ == "full")
+            mattyp.mark_as_full ();
+          else if (str_typ == "unknown")
+            mattyp.invalidate_type ();
+          else
+            error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
+
+          if (nargin == 3
+              && (str_typ == "upper" || str_typ == "lower"))
+            {
+              const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
+
+              octave_idx_type len = perm.numel ();
+              dim_vector dv = args(0).dims ();
+
+              if (len != dv(0))
+                error ("matrix_type: Invalid permutation vector PERM");
+              else
+                {
+                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+
+                  for (octave_idx_type i = 0; i < len; i++)
+                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+
+                  mattyp.mark_as_permuted (len, p);
+                }
+            }
+          else if (nargin != 2
+                   && str_typ != "banded positive definite"
+                   && str_typ != "banded")
+            error ("matrix_type: Invalid number of arguments");
+
+          // Set the matrix type
+          if (args(0).is_complex_type ())
+            retval = octave_value (args(0).sparse_complex_matrix_value (),
+                                   mattyp);
+          else
+            retval = octave_value (args(0).sparse_matrix_value (),
+                                   mattyp);
+        }
+    }
   else
     {
-      bool autocomp = true;
-      if (nargin == 2 && args(1).is_string ()
-          && args(1).string_value () == "nocompute")
-        {
-          nargin = 1;
-          autocomp = false;
-        }
-
-      if (args(0).is_scalar_type ())
+      if (nargin == 1)
         {
-          if (nargin == 1)
-            retval = octave_value ("Diagonal");
-          else
-            retval = args(0);
-        }
-      else if (args(0).is_sparse_type ())
-        {
-          if (nargin == 1)
+          MatrixType mattyp;
+
+          if (args(0).is_complex_type ())
             {
-              MatrixType mattyp;
+              mattyp = args(0).matrix_type ();
 
-              if (args(0).is_complex_type ())
+              if (mattyp.is_unknown () && autocomp)
                 {
-                  mattyp = args(0).matrix_type ();
-
-                  if (mattyp.is_unknown () && autocomp)
+                  if (args(0).is_single_type ())
                     {
-                      SparseComplexMatrix m =
-                        args(0).sparse_complex_matrix_value ();
+                      FloatComplexMatrix m;
+                      m = args(0).float_complex_matrix_value ();
 
                       mattyp = MatrixType (m);
                       args(0).matrix_type (mattyp);
                     }
-                }
-              else
-                {
-                  mattyp = args(0).matrix_type ();
-
-                  if (mattyp.is_unknown () && autocomp)
+                  else
                     {
-                      SparseMatrix m = args(0).sparse_matrix_value ();
+                      ComplexMatrix m = args(0).complex_matrix_value ();
 
                       mattyp = MatrixType (m);
                       args(0).matrix_type (mattyp);
                     }
                 }
-
-              int typ = mattyp.type ();
-
-              if (typ == MatrixType::Diagonal)
-                retval = octave_value ("Diagonal");
-              else if (typ == MatrixType::Permuted_Diagonal)
-                retval = octave_value ("Permuted Diagonal");
-              else if (typ == MatrixType::Upper)
-                retval = octave_value ("Upper");
-              else if (typ == MatrixType::Permuted_Upper)
-                retval = octave_value ("Permuted Upper");
-              else if (typ == MatrixType::Lower)
-                retval = octave_value ("Lower");
-              else if (typ == MatrixType::Permuted_Lower)
-                retval = octave_value ("Permuted Lower");
-              else if (typ == MatrixType::Banded)
-                retval = octave_value ("Banded");
-              else if (typ == MatrixType::Banded_Hermitian)
-                retval = octave_value ("Banded Positive Definite");
-              else if (typ == MatrixType::Tridiagonal)
-                retval = octave_value ("Tridiagonal");
-              else if (typ == MatrixType::Tridiagonal_Hermitian)
-                retval = octave_value ("Tridiagonal Positive Definite");
-              else if (typ == MatrixType::Hermitian)
-                retval = octave_value ("Positive Definite");
-              else if (typ == MatrixType::Rectangular)
-                {
-                  if (args(0).rows () == args(0).columns ())
-                    retval = octave_value ("Singular");
-                  else
-                    retval = octave_value ("Rectangular");
-                }
-              else if (typ == MatrixType::Full)
-                retval = octave_value ("Full");
-              else
-                retval = octave_value ("Unknown");
             }
           else
             {
-              // Ok, we're changing the matrix type
-
-              std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
-
-              // FIXME: why do I have to explicitly call the constructor?
-              MatrixType mattyp = MatrixType ();
-
-              octave_idx_type nl = 0;
-              octave_idx_type nu = 0;
-
-              // Use STL function to convert to lower case
-              std::transform (str_typ.begin (), str_typ.end (),
-                              str_typ.begin (), tolower);
+              mattyp = args(0).matrix_type ();
 
-              if (str_typ == "diagonal")
-                mattyp.mark_as_diagonal ();
-              if (str_typ == "permuted diagonal")
-                mattyp.mark_as_permuted_diagonal ();
-              else if (str_typ == "upper")
-                mattyp.mark_as_upper_triangular ();
-              else if (str_typ == "lower")
-                mattyp.mark_as_lower_triangular ();
-              else if (str_typ == "banded"
-                       || str_typ == "banded positive definite")
+              if (mattyp.is_unknown () && autocomp)
                 {
-                  if (nargin != 4)
-                    error ("matrix_type: banded matrix type requires 4 arguments");
+                  if (args(0).is_single_type ())
+                    {
+                      FloatMatrix m = args(0).float_matrix_value ();
+
+                      mattyp = MatrixType (m);
+                      args(0).matrix_type (mattyp);
+                    }
                   else
                     {
-                      nl = args(2).xnint_value ("matrix_type: band size NL, NU must be integers");
-                      nu = args(3).xnint_value ("matrix_type: band size NL, NU must be integers");
+                      Matrix m = args(0).matrix_value ();
 
-                      if (nl == 1 && nu == 1)
-                        mattyp.mark_as_tridiagonal ();
-                      else
-                        mattyp.mark_as_banded (nu, nl);
-
-                      if (str_typ == "banded positive definite")
-                        mattyp.mark_as_symmetric ();
+                      mattyp = MatrixType (m);
+                      args(0).matrix_type (mattyp);
                     }
                 }
-              else if (str_typ == "positive definite")
-                {
-                  mattyp.mark_as_full ();
-                  mattyp.mark_as_symmetric ();
-                }
-              else if (str_typ == "singular")
-                mattyp.mark_as_rectangular ();
-              else if (str_typ == "full")
-                mattyp.mark_as_full ();
-              else if (str_typ == "unknown")
-                mattyp.invalidate_type ();
-              else
-                error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
+            }
 
-              if (nargin == 3
-                  && (str_typ == "upper" || str_typ == "lower"))
-                {
-                  const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
-
-                  octave_idx_type len = perm.numel ();
-                  dim_vector dv = args(0).dims ();
+          int typ = mattyp.type ();
 
-                  if (len != dv(0))
-                    error ("matrix_type: Invalid permutation vector PERM");
-                  else
-                    {
-                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
-
-                      for (octave_idx_type i = 0; i < len; i++)
-                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
-
-                      mattyp.mark_as_permuted (len, p);
-                    }
-                }
-              else if (nargin != 2
-                       && str_typ != "banded positive definite"
-                       && str_typ != "banded")
-                error ("matrix_type: Invalid number of arguments");
-
-              // Set the matrix type
-              if (args(0).is_complex_type ())
-                retval = octave_value (args(0).sparse_complex_matrix_value (),
-                                       mattyp);
+          if (typ == MatrixType::Upper)
+            retval = octave_value ("Upper");
+          else if (typ == MatrixType::Permuted_Upper)
+            retval = octave_value ("Permuted Upper");
+          else if (typ == MatrixType::Lower)
+            retval = octave_value ("Lower");
+          else if (typ == MatrixType::Permuted_Lower)
+            retval = octave_value ("Permuted Lower");
+          else if (typ == MatrixType::Hermitian)
+            retval = octave_value ("Positive Definite");
+          else if (typ == MatrixType::Rectangular)
+            {
+              if (args(0).rows () == args(0).columns ())
+                retval = octave_value ("Singular");
               else
-                retval = octave_value (args(0).sparse_matrix_value (),
-                                       mattyp);
+                retval = octave_value ("Rectangular");
             }
+          else if (typ == MatrixType::Full)
+            retval = octave_value ("Full");
+          else
+            retval = octave_value ("Unknown");
         }
       else
         {
-          if (nargin == 1)
-            {
-              MatrixType mattyp;
+          // Ok, we're changing the matrix type
+
+          std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
 
-              if (args(0).is_complex_type ())
-                {
-                  mattyp = args(0).matrix_type ();
+          // FIXME: why do I have to explicitly call the constructor?
+          MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
+
+          // Use STL function to convert to lower case
+          std::transform (str_typ.begin (), str_typ.end (),
+                          str_typ.begin (), tolower);
 
-                  if (mattyp.is_unknown () && autocomp)
-                    {
-                      if (args(0).is_single_type ())
-                        {
-                          FloatComplexMatrix m;
-                          m = args(0).float_complex_matrix_value ();
+          if (str_typ == "upper")
+            mattyp.mark_as_upper_triangular ();
+          else if (str_typ == "lower")
+            mattyp.mark_as_lower_triangular ();
+          else if (str_typ == "positive definite")
+            {
+              mattyp.mark_as_full ();
+              mattyp.mark_as_symmetric ();
+            }
+          else if (str_typ == "singular")
+            mattyp.mark_as_rectangular ();
+          else if (str_typ == "full")
+            mattyp.mark_as_full ();
+          else if (str_typ == "unknown")
+            mattyp.invalidate_type ();
+          else
+            error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
-                      else
-                        {
-                          ComplexMatrix m = args(0).complex_matrix_value ();
+          if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
+            {
+              const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
 
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
-                    }
-                }
+              octave_idx_type len = perm.numel ();
+              dim_vector dv = args(0).dims ();
+
+              if (len != dv(0))
+                error ("matrix_type: Invalid permutation vector PERM");
               else
                 {
-                  mattyp = args(0).matrix_type ();
-
-                  if (mattyp.is_unknown () && autocomp)
-                    {
-                      if (args(0).is_single_type ())
-                        {
-                          FloatMatrix m = args(0).float_matrix_value ();
+                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
-                      else
-                        {
-                          Matrix m = args(0).matrix_value ();
-
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
-                    }
-                }
+                  for (octave_idx_type i = 0; i < len; i++)
+                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-              int typ = mattyp.type ();
+                  mattyp.mark_as_permuted (len, p);
+                }
+            }
+          else if (nargin != 2)
+            error ("matrix_type: Invalid number of arguments");
 
-              if (typ == MatrixType::Upper)
-                retval = octave_value ("Upper");
-              else if (typ == MatrixType::Permuted_Upper)
-                retval = octave_value ("Permuted Upper");
-              else if (typ == MatrixType::Lower)
-                retval = octave_value ("Lower");
-              else if (typ == MatrixType::Permuted_Lower)
-                retval = octave_value ("Permuted Lower");
-              else if (typ == MatrixType::Hermitian)
-                retval = octave_value ("Positive Definite");
-              else if (typ == MatrixType::Rectangular)
-                {
-                  if (args(0).rows () == args(0).columns ())
-                    retval = octave_value ("Singular");
-                  else
-                    retval = octave_value ("Rectangular");
-                }
-              else if (typ == MatrixType::Full)
-                retval = octave_value ("Full");
+          // Set the matrix type
+          if (args(0).is_single_type ())
+            {
+              if (args(0).is_complex_type ())
+                retval = octave_value (args(0).float_complex_matrix_value (),
+                                       mattyp);
               else
-                retval = octave_value ("Unknown");
+                retval = octave_value (args(0).float_matrix_value (),
+                                       mattyp);
             }
           else
             {
-              // Ok, we're changing the matrix type
-
-              std::string str_typ = args(1).xstring_value ("matrix_type: TYPE must be a string");
-
-              // FIXME: why do I have to explicitly call the constructor?
-              MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
-
-              // Use STL function to convert to lower case
-              std::transform (str_typ.begin (), str_typ.end (),
-                              str_typ.begin (), tolower);
-
-              if (str_typ == "upper")
-                mattyp.mark_as_upper_triangular ();
-              else if (str_typ == "lower")
-                mattyp.mark_as_lower_triangular ();
-              else if (str_typ == "positive definite")
-                {
-                  mattyp.mark_as_full ();
-                  mattyp.mark_as_symmetric ();
-                }
-              else if (str_typ == "singular")
-                mattyp.mark_as_rectangular ();
-              else if (str_typ == "full")
-                mattyp.mark_as_full ();
-              else if (str_typ == "unknown")
-                mattyp.invalidate_type ();
+              if (args(0).is_complex_type ())
+                retval = octave_value (args(0).complex_matrix_value (),
+                                       mattyp);
               else
-                error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
-
-              if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
-                {
-                  const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
-
-                  octave_idx_type len = perm.numel ();
-                  dim_vector dv = args(0).dims ();
-
-                  if (len != dv(0))
-                    error ("matrix_type: Invalid permutation vector PERM");
-                  else
-                    {
-                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
-
-                      for (octave_idx_type i = 0; i < len; i++)
-                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
-
-                      mattyp.mark_as_permuted (len, p);
-                    }
-                }
-              else if (nargin != 2)
-                error ("matrix_type: Invalid number of arguments");
-
-              // Set the matrix type
-              if (args(0).is_single_type ())
-                {
-                  if (args(0).is_complex_type ())
-                    retval = octave_value (args(0).float_complex_matrix_value (),
-                                           mattyp);
-                  else
-                    retval = octave_value (args(0).float_matrix_value (),
-                                           mattyp);
-                }
-              else
-                {
-                  if (args(0).is_complex_type ())
-                    retval = octave_value (args(0).complex_matrix_value (),
-                                           mattyp);
-                  else
-                    retval = octave_value (args(0).matrix_value (), mattyp);
-                }
+                retval = octave_value (args(0).matrix_value (), mattyp);
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/md5sum.cc b/libinterp/corefcn/md5sum.cc
--- a/libinterp/corefcn/md5sum.cc
+++ b/libinterp/corefcn/md5sum.cc
@@ -46,34 +46,32 @@ If the second parameter @var{opt} exists
 sum of the string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
+
+  bool have_str = false;
+  std::string str = args(0).string_value ();
+
+  if (nargin == 2)
+    have_str = args(1).bool_value ();
+
+  if (have_str)
+    retval = oct_md5 (str);
   else
     {
-      bool have_str = false;
-      std::string str = args(0).string_value ();
-
-      if (nargin == 2)
-        have_str = args(1).bool_value ();
+      std::string fname = file_ops::tilde_expand (str);
 
-      if (have_str)
-        retval = oct_md5 (str);
-      else
-        {
-          std::string fname = file_ops::tilde_expand (str);
+      fname = find_data_file_in_load_path ("md5sum", fname);
 
-          fname = find_data_file_in_load_path ("md5sum", fname);
-
-          retval = oct_md5_file (fname);
-        }
+      retval = oct_md5_file (fname);
     }
 
   return retval;
 }
 
 /*
 %!assert (md5sum ("abc\0", true), "147a664a2ca9410911e61986d3f0d52a");
 
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -49,20 +49,17 @@ environment variable.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if ((nargin != 0 && nargin != 1) || (nargout != 0 && nargout != 1))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   nproc_query query = NPROC_CURRENT;
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       std::transform (arg.begin (), arg.end (), arg.begin (), tolower);
 
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -538,54 +538,49 @@ Record the session in the file named @va
 With no arguments, @code{diary} toggles the current diary state.\n\
 @seealso{history}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
+  if (argc < 1 || argc > 2)
+    print_usage ();
+
   string_vector argv = args.make_argv ("diary");
 
   if (diary_file.empty ())
     diary_file = "diary";
 
-  switch (argc)
+  if (argc == 1)
     {
-    case 1:
       write_to_diary_file = ! write_to_diary_file;
       open_diary_file ();
-      break;
-
-    case 2:
-      {
-        std::string arg = argv[1];
+    }
+  else
+    {
+      std::string arg = argv[1];
 
-        if (arg == "on")
-          {
-            write_to_diary_file = true;
-            open_diary_file ();
-          }
-        else if (arg == "off")
-          {
-            close_diary_file ();
-            write_to_diary_file = false;
-          }
-        else
-          {
-            diary_file = arg;
-            write_to_diary_file = true;
-            open_diary_file ();
-          }
-      }
-      break;
-
-    default:
-      print_usage ();
-      break;
+      if (arg == "on")
+        {
+          write_to_diary_file = true;
+          open_diary_file ();
+        }
+      else if (arg == "off")
+        {
+          close_diary_file ();
+          write_to_diary_file = false;
+        }
+      else
+        {
+          diary_file = arg;
+          write_to_diary_file = true;
+          open_diary_file ();
+        }
     }
 
   return retval;
 }
 
 DEFUN (__diaryfile__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fname} =} __diaryfile__ ()\n\
@@ -616,33 +611,34 @@ Without an argument, @code{more} toggles
 The current state can be determined via @code{page_screen_output}.\n\
 @seealso{page_screen_output, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
+  if (argc < 1 || argc > 2)
+    print_usage ();
+
   string_vector argv = args.make_argv ("more");
 
   if (argc == 2)
     {
       std::string arg = argv[1];
 
       if (arg == "on")
         Vpage_screen_output = true;
       else if (arg == "off")
         Vpage_screen_output = false;
       else
         error ("more: unrecognized argument '%s'", arg.c_str ());
     }
-  else if (argc == 1)
+  else
     Vpage_screen_output = ! Vpage_screen_output;
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (terminal_size, , ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} terminal_size ()\n\
 Return a two-element row vector containing the current size of the terminal\n\
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3426,65 +3426,63 @@ If the length of the smallest possible r
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 1)
     print_usage ();
-  else
+
+  unwind_protect frame;
+
+  frame.protect_var (rat_string_len);
+
+  rat_string_len = 9;
+
+  if (nargin == 2)
+    rat_string_len = args(1).nint_value ();
+
+  octave_value arg = args(0);
+
+  if (arg.is_numeric_type ())
     {
-      unwind_protect frame;
-
-      frame.protect_var (rat_string_len);
-
-      rat_string_len = 9;
-
-      if (nargin == 2)
-        rat_string_len = args(1).nint_value ();
-
-      octave_value arg = args(0);
-
-      if (arg.is_numeric_type ())
+      frame.protect_var (rat_format);
+
+      rat_format = true;
+
+      std::ostringstream buf;
+      arg.print (buf);
+      std::string s = buf.str ();
+
+      std::list<std::string> lst;
+
+      size_t n = 0;
+      size_t s_len = s.length ();
+
+      while (n < s_len)
         {
-          frame.protect_var (rat_format);
-
-          rat_format = true;
-
-          std::ostringstream buf;
-          arg.print (buf);
-          std::string s = buf.str ();
-
-          std::list<std::string> lst;
-
-          size_t n = 0;
-          size_t s_len = s.length ();
-
-          while (n < s_len)
+          size_t m = s.find ('\n',  n);
+
+          if (m == std::string::npos)
+            {
+              lst.push_back (s.substr (n));
+              break;
+            }
+          else
             {
-              size_t m = s.find ('\n',  n);
-
-              if (m == std::string::npos)
-                {
-                  lst.push_back (s.substr (n));
-                  break;
-                }
-              else
-                {
-                  lst.push_back (s.substr (n, m - n));
-                  n = m + 1;
-                }
+              lst.push_back (s.substr (n, m - n));
+              n = m + 1;
             }
-
-          retval = string_vector (lst);
         }
-      else
-        error ("rats: X must be numeric");
+
+      retval = string_vector (lst);
     }
+  else
+    error ("rats: X must be numeric");
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
 Display the value of @var{x}.\n\
@@ -3507,31 +3505,29 @@ If an output value is requested, @code{d
 formatted output in a string.\n\
 @seealso{fdisp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 && nargout < 2)
+  if (nargin != 1 || nargout > 1)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  if (nargout == 0)
+    arg.print (octave_stdout);
+  else
     {
-      octave_value arg = args(0);
-
-      if (nargout == 0)
-        arg.print (octave_stdout);
-      else
-        {
-          std::ostringstream buf;
-          arg.print (buf);
-          retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
-        }
+      std::ostringstream buf;
+      arg.print (buf);
+      retval = octave_value (buf.str (), arg.is_dq_string () ? '"' : '\'');
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
 Display the value of @var{x} on the stream @var{fid}.\n\
@@ -3551,33 +3547,31 @@ fdisp (stdout, \"The value of pi is:\"),
 Note that the output from @code{fdisp} always ends with a newline.\n\
 @seealso{disp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
-    {
-      int fid = octave_stream_list::get_file_number (args(0));
-
-      octave_stream os = octave_stream_list::lookup (fid, "fdisp");
-
-      std::ostream *osp = os.output_stream ();
-
-      octave_value arg = args(1);
-
-      if (osp)
-        arg.print (*osp);
-      else
-        error ("fdisp: stream FID not open for writing");
-    }
+  if (nargin != 2)
+    print_usage ();
+
+  int fid = octave_stream_list::get_file_number (args(0));
+
+  octave_stream os = octave_stream_list::lookup (fid, "fdisp");
+
+  std::ostream *osp = os.output_stream ();
+
+  octave_value arg = args(1);
+
+  if (osp)
+    arg.print (*osp);
   else
-    print_usage ();
+    error ("fdisp: stream FID not open for writing");
 
   return retval;
 }
 
 /*
 %!test
 %! format short
 %! fd = tmpfile ();
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -64,20 +64,17 @@ can have any value real or complex value
 \n\
 @seealso{gamma, gammainc, gammaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   const octave_idx_type nargin = args.length ();
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   const octave_value oct_z = (nargin == 1) ? args(0) : args(1);
   const octave_idx_type k = (nargin == 1) ? 0 : args(0).idx_type_value ("psi: K must be an integer");
   if (k < 0)
     {
       error ("psi: K must be non-negative");
       return retval;
     }
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1583,20 +1583,17 @@ Mathematical Software, Vol. 37, Issue 3,
   int i, j, d, split, t;
   int nnans, nans[33];
   cquad_ival *iv, *ivl, *ivr;
   double nc, ncdiff;
 
 
   /* Parse the input arguments. */
   if (nargin < 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (args(0).is_function_handle () || args(0).is_inline_function ())
     fcn = args(0).function_value ();
   else
     {
       std::string fcn_name = unique_symbol_name ("__quadcc_fcn__");
       std::string fname = "function y = ";
       fname.append (fcn_name);
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1125,123 +1125,113 @@ replacement from @code{1:@var{n}}.\n\
 \n\
 The complexity is O(@var{n}) in memory and O(@var{m}) in time, unless\n\
 @var{m} < @var{n}/5, in which case O(@var{m}) memory is used as well.  The\n\
 randomization is performed using rand().  All permutations are equally\n\
 likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
+  octave_value retval;
 
 #ifdef USE_UNORDERED_MAP_WITH_TR1
 using std::tr1::unordered_map;
 #else
 using std::unordered_map;
 #endif
 
   int nargin = args.length ();
-  octave_value retval;
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_idx_type n, m;
+  octave_idx_type n = args(0).idx_type_value (true);
+  octave_idx_type m = (nargin == 2) ? args(1).idx_type_value (true) : n;
 
-      n = args(0).idx_type_value (true);
+  if (m < 0 || n < 0)
+    error ("randperm: M and N must be non-negative");
 
-      if (nargin == 2)
-        m = args(1).idx_type_value (true);
-      else
-        m = n;
+  if (m > n)
+    error ("randperm: M must be less than or equal to N");
 
-      if (m < 0 || n < 0)
-        error ("randperm: M and N must be non-negative");
+  // Quick and dirty heuristic to decide if we allocate or not the
+  // whole vector for tracking the truncated shuffle.
+  bool short_shuffle = m < n/5;
+
+  // Generate random numbers.
+  NDArray r = octave_rand::nd_array (dim_vector (1, m));
+  double *rvec = r.fortran_vec ();
 
-      if (m > n)
-        error ("randperm: M must be less than or equal to N");
-
-      // Quick and dirty heuristic to decide if we allocate or not the
-      // whole vector for tracking the truncated shuffle.
-      bool short_shuffle = m < n/5;
+  octave_idx_type idx_len = short_shuffle ? m : n;
+  Array<octave_idx_type> idx;
+  try
+    {
+      idx = Array<octave_idx_type> (dim_vector (1, idx_len));
+    }
+  catch (const std::bad_alloc&)
+    {
+      // Looks like n is too big and short_shuffle is false.
+      // Let's try again, but this time with the alternative.
+      idx_len = m;
+      short_shuffle = true;
+      idx = Array<octave_idx_type> (dim_vector (1, idx_len));
+    }
 
-      // Generate random numbers.
-      NDArray r = octave_rand::nd_array (dim_vector (1, m));
-      double *rvec = r.fortran_vec ();
+  octave_idx_type *ivec = idx.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < idx_len; i++)
+    ivec[i] = i;
 
-      octave_idx_type idx_len = short_shuffle ? m : n;
-      Array<octave_idx_type> idx;
-      try
-        {
-          idx = Array<octave_idx_type> (dim_vector (1, idx_len));
-        }
-      catch (const std::bad_alloc&)
+  if (short_shuffle)
+    {
+      unordered_map<octave_idx_type, octave_idx_type> map (m);
+
+      // Perform the Knuth shuffle only keeping track of moved
+      // entries in the map
+      for (octave_idx_type i = 0; i < m; i++)
         {
-          // Looks like n is too big and short_shuffle is false.
-          // Let's try again, but this time with the alternative.
-          idx_len = m;
-          short_shuffle = true;
-          idx = Array<octave_idx_type> (dim_vector (1, idx_len));
-        }
-
-      octave_idx_type *ivec = idx.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < idx_len; i++)
-        ivec[i] = i;
-
-      if (short_shuffle)
-        {
-          unordered_map<octave_idx_type, octave_idx_type> map (m);
+          octave_idx_type k = i +
+            gnulib::floor (rvec[i] * (n - i));
 
-          // Perform the Knuth shuffle only keeping track of moved
-          // entries in the map
-          for (octave_idx_type i = 0; i < m; i++)
+          // For shuffling first m entries, no need to use extra
+          // storage
+          if (k < m)
             {
-              octave_idx_type k = i +
-                gnulib::floor (rvec[i] * (n - i));
+              std::swap (ivec[i], ivec[k]);
+            }
+          else
+            {
+              if (map.find (k) == map.end ())
+                map[k] = k;
 
-              // For shuffling first m entries, no need to use extra
-              // storage
-              if (k < m)
-                {
-                  std::swap (ivec[i], ivec[k]);
-                }
-              else
-                {
-                  if (map.find (k) == map.end ())
-                    map[k] = k;
-
-                  std::swap (ivec[i], map[k]);
-                }
+              std::swap (ivec[i], map[k]);
             }
         }
-      else
-        {
-
-          // Perform the Knuth shuffle of the first m entries
-          for (octave_idx_type i = 0; i < m; i++)
-            {
-              octave_idx_type k = i +
-                gnulib::floor (rvec[i] * (n - i));
-              std::swap (ivec[i], ivec[k]);
-            }
-        }
-
-      // Convert to doubles, reusing r.
-      for (octave_idx_type i = 0; i < m; i++)
-        rvec[i] = ivec[i] + 1;
-
-      if (m < n)
-        idx.resize (dim_vector (1, m));
-
-      // Now create an array object with a cached idx_vector.
-      retval = new octave_matrix (r, idx_vector (idx));
     }
   else
-    print_usage ();
+    {
 
-  return retval;
+      // Perform the Knuth shuffle of the first m entries
+      for (octave_idx_type i = 0; i < m; i++)
+        {
+          octave_idx_type k = i +
+            gnulib::floor (rvec[i] * (n - i));
+          std::swap (ivec[i], ivec[k]);
+        }
+    }
+
+  // Convert to doubles, reusing r.
+  for (octave_idx_type i = 0; i < m; i++)
+    rvec[i] = ivec[i] + 1;
+
+  if (m < n)
+    idx.resize (dim_vector (1, m));
+
+  // Now create an array object with a cached idx_vector.
+  return octave_value (new octave_matrix (r, idx_vector (idx)));
 }
 
 /*
 %!assert (sort (randperm (20)), 1:20)
 %!assert (length (randperm (20,10)), 10)
 
 ## Test biggish N (bug #39378)
 %!assert (length (randperm (30000^2, 100000)), 100000)
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -856,17 +856,18 @@ are zero or more @qcode{'b'} characters 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
-  else if (args(0).is_cell () || args(1).is_cell ())
+
+  if (args(0).is_cell () || args(1).is_cell ())
     retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp");
   else
     retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
@@ -1151,17 +1152,18 @@ for details on the syntax of the search 
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
-  else if (args(0).is_cell () || args(1).is_cell ())
+
+  if (args(0).is_cell () || args(1).is_cell ())
     retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
   else
     retval = octregexp (args, nargout, "regexpi", true);
 
   return retval;
 }
 
 /*
@@ -1383,20 +1385,17 @@ expansion use a second backslash before 
 function.\n\
 @seealso{regexp, regexpi, strrep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin < 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (args(0).is_cell () || args(1).is_cell () || args(2).is_cell ())
     {
       Cell str;
       Cell pat;
       Cell rep;
       dim_vector dv0;
       dim_vector dv1 (1, 1);
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -1047,28 +1047,22 @@ OCL_REP::wait (void)
 }
 
 DEFUN (SIG, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SIG ()\n\
 Return a structure containing Unix signal names and their defined values.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    {
-      static octave_scalar_map m = make_sig_struct ();
-
-      retval = m;
-    }
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  static octave_scalar_map m = make_sig_struct ();
+
+  return octave_value (m);
 }
 
 /*
 %!assert (isstruct (SIG ()))
 %!assert (! isempty (SIG ()))
 
 %!error SIG (1)
 */
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -212,31 +212,25 @@ Mathematics, Manchester, England, Januar
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type n = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (n != nc || arg.ndims () > 2)
-    {
-      gripe_square_matrix_required ("sqrtm");
-      return retval;
-    }
+    gripe_square_matrix_required ("sqrtm");
 
   if (nargout > 1)
     {
       retval.resize (1, 2);
       retval(2) = -1.0;
     }
 
   if (arg.is_diag_matrix ())
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -188,91 +188,92 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
           [1,3] = [](1x0)\n\
         @}\n\
 @end group\n\
 @end example\n\
 @seealso{findstr, strmatch, regexp, regexpi, find}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
+
+  if (nargin != 4 && nargin != 2)
+    print_usage ();
+
   bool overlaps = true;
 
-  if (nargin == 4 && args(2).is_string () && args(3).is_scalar_type ())
+  if (nargin == 4)
     {
-      std::string opt = args(2).string_value ();
-      if (opt == "overlaps")
+      if (args(2).is_string () && args(3).is_scalar_type ())
         {
-          overlaps = args(3).bool_value ();
-          nargin = 2;
+          std::string opt = args(2).string_value ();
+
+          if (opt == "overlaps")
+            overlaps = args(3).bool_value ();
+          else
+            error ("strfind: unknown option: %s", opt.c_str ());
         }
       else
-        {
-          error ("strfind: unknown option: %s", opt.c_str ());
-          return retval;
-        }
+        error ("strfind: invalid optional arguments");
     }
 
-  if (nargin == 2)
+  octave_value argstr = args(0);
+  octave_value argpat = args(1);
+
+  if (argpat.is_string ())
     {
-      octave_value argstr = args(0);
-      octave_value argpat = args(1);
-      if (argpat.is_string ())
-        {
-          Array<char> needle = argpat.char_array_value ();
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
-          qs_preprocess (needle, table);
+      Array<char> needle = argpat.char_array_value ();
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
+      qs_preprocess (needle, table);
 
-          if (argstr.is_string ())
-            if (argpat.is_empty ())
-              // Return a null matrix for null pattern for MW compatibility
-              retval = Matrix ();
-            else
-              retval = octave_value (qs_search (needle,
-                                                argstr.char_array_value (),
-                                                table, overlaps),
-                                     true, true);
-          else if (argstr.is_cell ())
+      if (argstr.is_string ())
+        if (argpat.is_empty ())
+          // Return a null matrix for null pattern for MW compatibility
+          retval = Matrix ();
+        else
+          retval = octave_value (qs_search (needle,
+                                            argstr.char_array_value (),
+                                            table, overlaps),
+                                 true, true);
+      else if (argstr.is_cell ())
+        {
+          const Cell argsc = argstr.cell_value ();
+          Cell retc (argsc.dims ());
+          octave_idx_type ns = argsc.numel ();
+
+          for (octave_idx_type i = 0; i < ns; i++)
             {
-              const Cell argsc = argstr.cell_value ();
-              Cell retc (argsc.dims ());
-              octave_idx_type ns = argsc.numel ();
-
-              for (octave_idx_type i = 0; i < ns; i++)
+              octave_value argse = argsc(i);
+              if (argse.is_string ())
                 {
-                  octave_value argse = argsc(i);
-                  if (argse.is_string ())
-                    {
-                      if (argpat.is_empty ())
-                        retc(i) = Matrix ();
-                      else
-                        retc(i) = octave_value (qs_search (needle,
-                                                     argse.char_array_value (),
-                                                     table, overlaps),
-                                                true, true);
-                    }
+                  if (argpat.is_empty ())
+                    retc(i) = Matrix ();
                   else
-                    {
-                      error ("strfind: each element of CELLSTR must be a string");
-                      break;
-                    }
+                    retc(i) = octave_value (qs_search (needle,
+                                                       argse.char_array_value (),
+                                                       table, overlaps),
+                                            true, true);
                 }
-
-              retval = retc;
+              else
+                {
+                  error ("strfind: each element of CELLSTR must be a string");
+                  break;
+                }
             }
-          else
-            error ("strfind: first argument must be a string or cell array of strings");
+
+          retval = retc;
         }
-      else if (argpat.is_cell ())
-        retval = do_simple_cellfun (Fstrfind, "strfind", args);
       else
-        error ("strfind: PATTERN must be a string or cell array of strings");
+        error ("strfind: first argument must be a string or cell array of strings");
     }
+  else if (argpat.is_cell ())
+    retval = do_simple_cellfun (Fstrfind, "strfind", args);
   else
-    print_usage ();
+    error ("strfind: PATTERN must be a string or cell array of strings");
 
   return retval;
 }
 
 /*
 %!assert (strfind ("abababa", "aba"), [1, 3, 5])
 %!assert (strfind ("abababa", "aba", "overlaps", false), [1, 5])
 %!assert (strfind ({"abababa", "bla", "bla"}, "a"), {[1, 3, 5, 7], 3, 3})
@@ -381,81 +382,81 @@ strrep (\"This is a test string\", \"is\
     @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{regexprep, strfind, findstr}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length ();
+
   bool overlaps = true;
 
-  if (nargin == 5 && args(3).is_string () && args(4).is_scalar_type ())
+  int nargin = args.length ();
+
+  if (nargin != 3 && nargin != 5)
+    print_usage ();
+
+  if (nargin == 5)
     {
-      std::string opt = args(3).string_value ();
-      if (opt == "overlaps")
+      if (args(3).is_string () && args(4).is_scalar_type ())
         {
-          overlaps = args(4).bool_value ();
-          nargin = 3;
+          std::string opt = args(3).string_value ();
+          if (opt == "overlaps")
+            overlaps = args(4).bool_value ();
+          else
+            error ("strrep: unknown option: %s", opt.c_str ());
         }
       else
-        {
-          error ("strrep: unknown option: %s", opt.c_str ());
-          return retval;
-        }
+        error ("strrep: invalid optional arguments");
     }
 
-  if (nargin == 3)
+  octave_value argstr = args(0);
+  octave_value argpat = args(1);
+  octave_value argrep = args(2);
+
+  if (argpat.is_string () && argrep.is_string ())
     {
-      octave_value argstr = args(0);
-      octave_value argpat = args(1);
-      octave_value argrep = args(2);
-      if (argpat.is_string () && argrep.is_string ())
-        {
-          const Array<char> pat = argpat.char_array_value ();
-          const Array<char> rep = argrep.char_array_value ();
+      const Array<char> pat = argpat.char_array_value ();
+      const Array<char> rep = argrep.char_array_value ();
+
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
+      qs_preprocess (pat, table);
 
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
-          qs_preprocess (pat, table);
+      if (argstr.is_string ())
+        retval = qs_replace (argstr.char_array_value (), pat, rep,
+                             table, overlaps);
+      else if (argstr.is_cell ())
+        {
+          const Cell argsc = argstr.cell_value ();
+          Cell retc (argsc.dims ());
+          octave_idx_type ns = argsc.numel ();
 
-          if (argstr.is_string ())
-            retval = qs_replace (argstr.char_array_value (), pat, rep,
-                                 table, overlaps);
-          else if (argstr.is_cell ())
+          for (octave_idx_type i = 0; i < ns; i++)
             {
-              const Cell argsc = argstr.cell_value ();
-              Cell retc (argsc.dims ());
-              octave_idx_type ns = argsc.numel ();
-
-              for (octave_idx_type i = 0; i < ns; i++)
+              octave_value argse = argsc(i);
+              if (argse.is_string ())
+                retc(i) = qs_replace (argse.char_array_value (), pat, rep,
+                                      table, overlaps);
+              else
                 {
-                  octave_value argse = argsc(i);
-                  if (argse.is_string ())
-                    retc(i) = qs_replace (argse.char_array_value (), pat, rep,
-                                          table, overlaps);
-                  else
-                    {
-                      error ("strrep: each element of S must be a string");
-                      break;
-                    }
+                  error ("strrep: each element of S must be a string");
+                  break;
                 }
+            }
 
-              retval = retc;
-            }
-          else
-            error ("strrep: S must be a string or cell array of strings");
+          retval = retc;
         }
-      else if (argpat.is_cell () || argrep.is_cell ())
-        retval = do_simple_cellfun (Fstrrep, "strrep", args);
       else
-        error ("strrep: PTN and REP arguments must be strings or cell arrays of strings");
+        error ("strrep: S must be a string or cell array of strings");
     }
+  else if (argpat.is_cell () || argrep.is_cell ())
+    retval = do_simple_cellfun (Fstrrep, "strrep", args);
   else
-    print_usage ();
+    error ("strrep: PTN and REP arguments must be strings or cell arrays of strings");
 
   return retval;
 }
 
 /*
 %!assert (strrep ("This is a test string", "is", "&%$"),
 %!                "Th&%$ &%$ a test string")
 %!assert (strrep ("abababc", "abab", "xyz"), "xyzxyzc")
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -78,53 +78,48 @@ indexed moving from one column to next, 
 linear_index = sub2ind ([3, 3], 2, 3)\n\
 @result{} 8\n\
 @end group\n\
 @end example\n\
 @seealso{ind2sub}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
-  octave_value retval;
 
   if (nargin < 2)
     print_usage ();
-  else
-    {
-      dim_vector dv = get_dim_vector (args(0), "sub2ind");
-      Array<idx_vector> idxa (dim_vector (nargin-1, 1));
+
+  dim_vector dv = get_dim_vector (args(0), "sub2ind");
+  Array<idx_vector> idxa (dim_vector (nargin-1, 1));
 
-      dv = dv.redim (nargin - 1);
-      for (int j = 0; j < nargin - 1; j++)
+  dv = dv.redim (nargin - 1);
+  for (int j = 0; j < nargin - 1; j++)
+    {
+      if (args(j+1).is_numeric_type ())
         {
-          if (args(j+1).is_numeric_type ())
+          try
             {
-              try
-                {
-                  idxa(j) = args(j+1).index_vector ();
+              idxa(j) = args(j+1).index_vector ();
 
-                  if (j > 0 && args(j+1).dims () != args(1).dims ())
-                    error ("sub2ind: all subscripts must be of the same size");
-                }
-              catch (index_exception& e)
-                {
-                  e.set_pos_if_unset (nargin-1, j+1);
-                  e.set_var ();
-                  std::string msg = e.message ();
-                  error_with_id (e.err_id (), msg.c_str ());
-                }
+              if (j > 0 && args(j+1).dims () != args(1).dims ())
+                error ("sub2ind: all subscripts must be of the same size");
             }
-          else
-            error ("sub2ind: subscripts must be numeric");
+          catch (index_exception& e)
+            {
+              e.set_pos_if_unset (nargin-1, j+1);
+              e.set_var ();
+              std::string msg = e.message ();
+              error_with_id (e.err_id (), msg.c_str ());
+            }
         }
-
-      retval = sub2ind (dv, idxa);
+      else
+        error ("sub2ind: subscripts must be numeric");
     }
 
-  return retval;
+  return octave_value (sub2ind (dv, idxa));
 }
 
 /*
 ## Test evaluation
 %!test
 %! s1 = [ 1   1   1   1 ; 2   2   2   2 ];
 %! s2 = [ 1   1   2   2 ; 1   1   2   2 ];
 %! s3 = [ 1   2   1   2 ; 1   2   1   2 ];
@@ -181,36 +176,35 @@ moving from one column to next, filling 
 [r, c] = ind2sub ([3, 3], 8)\n\
     @result{} r =  2\n\
     @result{} c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
+  octave_value_list retval;
+
   int nargin = args.length ();
-  octave_value_list retval;
 
   if (nargin != 2)
     print_usage ();
-  else
-    {
-      dim_vector dv = get_dim_vector (args(0), "ind2sub");
+
+  dim_vector dv = get_dim_vector (args(0), "ind2sub");
 
-      try
-        {
-          idx_vector idx = args(1).index_vector ();
+  try
+    {
+      idx_vector idx = args(1).index_vector ();
 
-          if (nargout > dv.length ())
-            dv = dv.redim (nargout);
+      if (nargout > dv.length ())
+        dv = dv.redim (nargout);
 
-          retval = Array<octave_value> (ind2sub (dv, idx));
-        }
-      catch (const index_exception& e)
-        {
-          std::string idx = e.idx ();
-          std::string msg = e.details ();
-          error ("ind2sub: Invalid index %s. %s", idx.c_str (), msg.c_str ());
-        }
+      retval = Array<octave_value> (ind2sub (dv, idx));
+    }
+  catch (const index_exception& e)
+    {
+      std::string idx = e.idx ();
+      std::string msg = e.details ();
+      error ("ind2sub: Invalid index %s. %s", idx.c_str (), msg.c_str ());
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -60,20 +60,17 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg_a = args(0);
   octave_value arg_b = args(1);
   octave_value arg_c = args(2);
 
   octave_idx_type a_nr = arg_a.rows ();
   octave_idx_type a_nc = arg_a.columns ();
 
