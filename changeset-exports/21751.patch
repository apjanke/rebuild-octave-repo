# HG changeset patch
# User Rik <rik@octave.org>
# Date 1463708932 25200
#      Thu May 19 18:48:52 2016 -0700
# Node ID b571fc85953f2f5a6013641bd1fca68d2d27bf48
# Parent  6720e5a220baca9b78e7c8478debbb3560ff8b19
maint: Use two spaces after period to indicate sentence break.

diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -245,17 +245,17 @@ lin_interpn (int n, M *X, const M V, M *
 
   retval = Vi;
 
   return retval;
 }
 
 // Perform @var{n}-dimensional interpolation.  Each element of then
 // @var{n}-dimensional array @var{v} represents a value at a location
-// given by the parameters @var{x1}, @var{x2},...,@var{xn}. The parameters
+// given by the parameters @var{x1}, @var{x2},...,@var{xn}.  The parameters
 // @var{x1}, @var{x2}, @dots{}, @var{xn} are either @var{n}-dimensional
 // arrays of the same size as the array @var{v} in the \"ndgrid\" format
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -45,79 +45,79 @@ along with Octave; see the file COPYING.
 // In theory, it should be enough to check the class:
 // Magick::ClassType
 // PseudoClass:
 // Image is composed of pixels which specify an index in a color palette.
 // DirectClass:
 // Image is composed of pixels which represent literal color values.
 //
 //  GraphicsMagick does not really distinguishes between indexed and
-//  normal images. After reading a file, it decides itself the optimal
+//  normal images.  After reading a file, it decides itself the optimal
 //  way to store the image in memory, independently of the how the
-//  image was stored in the file. That's what ClassType returns. While
+//  image was stored in the file.  That's what ClassType returns.  While
 //  it seems to match the original file most of the times, this is
-//  not necessarily true all the times. See
+//  not necessarily true all the times.  See
 //    https://sourceforge.net/mailarchive/message.php?msg_id=31180507
 //  In addition to the ClassType, there is also ImageType which has a
-//  type for indexed images (PaletteType and PaletteMatteType). However,
-//  they also don't represent the original image. Not only does DirectClass
+//  type for indexed images (PaletteType and PaletteMatteType).  However,
+//  they also don't represent the original image.  Not only does DirectClass
 //  can have a PaletteType, but also does a PseudoClass have non Palette
 //  types.
 //
 //        We can't do better without having format specific code which is
-//        what we are trying to avoid by using a library such as GM. We at
+//        what we are trying to avoid by using a library such as GM.  We at
 //        least create workarounds for the most common problems.
 //
 // 1) A grayscale jpeg image can report being indexed even though the
-//    JPEG format has no support for indexed images. We can at least
+//    JPEG format has no support for indexed images.  We can at least
 //    fix this one.
 // 2) A PNG file is only an indexed image if color type orig is 3 (value comes
 //    from libpng)
 static bool
 is_indexed (const Magick::Image& img)
 {
   bool indexed = (img.classType () == Magick::PseudoClass);
   // Our problem until now is non-indexed images, being represented as indexed
-  // by GM. The following attempts educated guesses to undo this optimization.
+  // by GM.  The following attempts educated guesses to undo this optimization.
   if (indexed)
     {
       const std::string fmt = img.magick ();
       if (fmt == "JPEG")
         // The JPEG format does not support indexed images, but GM sometimes
-        // reports grayscale JPEG as indexed. Always false for JPEG.
+        // reports grayscale JPEG as indexed.  Always false for JPEG.
         indexed = false;
       else if (fmt == "PNG")
         {
           // Newer versions of GM (at least does not happens with 1.3.16) will
-          // store values from the underlying library as image attributes. In
+          // store values from the underlying library as image attributes.  In
           // the case of PNG files, this is libpng where an indexed image will
-          // always have a value of 3 for "color-type-orig". This property
+          // always have a value of 3 for "color-type-orig".  This property
           // always has a value in libpng so if we get nothing, we assume this
           // GM version does not store them and we have to go with whatever
           // GM PseudoClass says.
           const std::string color_type =
             const_cast<Magick::Image&> (img).attribute ("PNG:IHDR.color-type-orig");
           if (! color_type.empty() && color_type != "3")
             indexed = false;
         }
     }
   return indexed;
 }
 
 //  The depth from depth() is not always correct for us but seems to be the
-//  best value we can get. For example, a grayscale png image with 1 bit
+//  best value we can get.  For example, a grayscale png image with 1 bit
 //  per channel should return a depth of 1 but instead we get 8.
 //  We could check channelDepth() but then, which channel has the data
-//  is not straightforward. So we'd have to check all
-//  the channels and select the highest value. But then, I also
+//  is not straightforward.  So we'd have to check all
+//  the channels and select the highest value.  But then, I also
 //  have a 16bit TIFF whose depth returns 16 (correct), but all of the
-//  channels gives 8 (wrong). No idea why, maybe a bug in GM?
+//  channels gives 8 (wrong).  No idea why, maybe a bug in GM?
 //  Anyway, using depth() seems that only causes problems for binary
 //  images, and the problem with channelDepth() is not making set them
-//  all to 1. So we will guess that if all channels have depth of 1,
+//  all to 1.  So we will guess that if all channels have depth of 1,
 //  then we must have a binary image.
 //  Note that we can't use AllChannels it doesn't work for this.
 //  We also can't check only one from RGB, one from CMYK, and grayscale
 // and transparency, we really need to check all of the channels (bug #41584).
 static octave_idx_type
 get_depth (Magick::Image& img)
 {
   octave_idx_type depth = img.depth ();
@@ -132,17 +132,17 @@ get_depth (Magick::Image& img)
       && img.channelDepth (Magick::OpacityChannel) == 1
       && img.channelDepth (Magick::GrayChannel)    == 1)
     depth = 1;
 
   return depth;
 }
 
 // We need this in case one of the sides of the image being read has
-// width 1. In those cases, the type will come as scalar instead of range
+// width 1.  In those cases, the type will come as scalar instead of range
 // since that's the behavior of the colon operator (1:1:1 will be a scalar,
 // not a range).
 static Range
 get_region_range (const octave_value& region)
 {
   Range output;
   if (region.is_range ())
     output = region.range_value ();
@@ -221,32 +221,32 @@ read_indexed_images (const std::vector<M
   octave_value_list retval (1);
 
   std::map<std::string, octave_idx_type> region = calculate_region (options);
   const octave_idx_type nFrames = frameidx.numel ();
   const octave_idx_type nRows = region["row_out"];
   const octave_idx_type nCols = region["col_out"];
 
   // imvec has all of the pages of a file, even the ones we are not
-  // interested in. We will use the first image that we will be actually
+  // interested in.  We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
   T img       = T (dim_vector (nRows, nCols, 1, nFrames));
   P* img_fvec = img.fortran_vec ();
 
   const octave_idx_type row_start = region["row_start"];
   const octave_idx_type col_start = region["col_start"];
   const octave_idx_type row_shift = region["row_shift"];
   const octave_idx_type col_shift = region["col_shift"];
   const octave_idx_type row_cache = region["row_cache"];
   const octave_idx_type col_cache = region["col_cache"];
 
   // When reading PixelPackets from the Image Pixel Cache, they come in
-  // row major order. So we keep moving back and forth there so we can
+  // row major order.  So we keep moving back and forth there so we can
   // write the image in column major order.
   octave_idx_type idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       OCTAVE_QUIT;
       imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                              col_cache, row_cache);
 
@@ -296,17 +296,17 @@ read_indexed_images (const std::vector<M
           retval(2) = alpha;
         }
     }
 
   return retval;
 }
 
 // This function is highly repetitive, a bunch of for loops that are
-// very similar to account for different image types. They are different
+// very similar to account for different image types.  They are different
 // enough that trying to reduce the copy and paste would decrease its
 // readability too much.
 template <typename T>
 octave_value_list
 read_images (std::vector<Magick::Image>& imvec,
              const Array<octave_idx_type>& frameidx,
              const octave_idx_type& nargout,
              const octave_scalar_map& options)
@@ -317,68 +317,68 @@ read_images (std::vector<Magick::Image>&
 
   std::map<std::string, octave_idx_type> region = calculate_region (options);
   const octave_idx_type nFrames = frameidx.numel ();
   const octave_idx_type nRows = region["row_out"];
   const octave_idx_type nCols = region["col_out"];
   T img;
 
   // imvec has all of the pages of a file, even the ones we are not
-  // interested in. We will use the first image that we will be actually
+  // interested in.  We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
   const octave_idx_type row_start = region["row_start"];
   const octave_idx_type col_start = region["col_start"];
   const octave_idx_type row_shift = region["row_shift"];
   const octave_idx_type col_shift = region["col_shift"];
   const octave_idx_type row_cache = region["row_cache"];
   const octave_idx_type col_cache = region["col_cache"];
 
   // GraphicsMagick (GM) keeps the image values in memory using whatever
   // QuantumDepth it was built with independently of the original image
-  // bitdepth. Basically this means that if GM was built with quantum 16
-  // all values are scaled in the uint16 range. If the original image
+  // bitdepth.  Basically this means that if GM was built with quantum 16
+  // all values are scaled in the uint16 range.  If the original image
   // had an 8 bit depth, we need to rescale it for that range.
   // However, if the image had a bitdepth of 32, then we will be returning
-  // a floating point image. In this case, the values need to be rescaled
+  // a floating point image.  In this case, the values need to be rescaled
   // for the range [0 1] (this is what Matlab has documented on the page
   // about image types but in some cases seems to be doing something else.
   // See bug #39249).
   // Finally, we must do the division ourselves (set a divisor) instead of
   // using quantumOperator for the cases where we will be returning floating
-  // point and want things in the range [0 1]. This is the same reason why
+  // point and want things in the range [0 1].  This is the same reason why
   // the divisor is of type double.
   // uint64_t is used in expression because default 32-bit value overflows
   // when depth() is 32.
   // FIXME: in the next release of GraphicsMagick, MaxRGB should be replaced
   //        with QuantumRange since MaxRGB is already deprecated in ImageMagick.
   double divisor;
   if (imvec[def_elem].depth () == 32)
     divisor = std::numeric_limits<uint32_t>::max ();
   else
     divisor = MaxRGB / ((uint64_t (1) << imvec[def_elem].depth ()) - 1);
 
   // FIXME: this workaround should probably be fixed in GM by creating a
   //        new ImageType BilevelMatteType
   // Despite what GM documentation claims, opacity is not only on the types
-  // with Matte on the name. It is possible that an image is completely
+  // with Matte on the name.  It is possible that an image is completely
   // black (1 color), and have a second channel set for transparency (2nd
-  // color). Its type will be bilevel since there is no BilevelMatte. The
+  // color).  Its type will be bilevel since there is no BilevelMatte.  The
   // only way to check for this seems to be by checking matte ().
   Magick::ImageType type = imvec[def_elem].type ();
   if (type == Magick::BilevelType && imvec[def_elem].matte ())
     type = Magick::GrayscaleMatteType;
 
   // FIXME: ImageType is the type being used to represent the image in memory
-  // by GM. The real type may be different (see among others bug #36820). For
+  // by GM.  The real type may be different (see among others bug #36820).  For
   // example, a png file where all channels are equal may report being
-  // grayscale or even bilevel. But we must always return the real image in
-  // file. In some cases, the original image attributes are stored in the
-  // attributes but this is undocumented. This should be fixed in GM so that
+  // grayscale or even bilevel.  But we must always return the real image in
+  // file.  In some cases, the original image attributes are stored in the
+  // attributes but this is undocumented.  This should be fixed in GM so that
   // a method such as original_type returns an actual Magick::ImageType
   if (imvec[0].magick () == "PNG")
     {
       // These values come from libpng, not GM:
       //      Grayscale         = 0
       //      Palette           = 2 + 1
       //      RGB               = 2
       //      RGB + Alpha       = 2 + 4
@@ -394,17 +394,17 @@ read_images (std::vector<Magick::Image>&
         type = Magick::TrueColorType;
       else if (type_str == "6")
         type = Magick::TrueColorMatteType;
       else if (type_str == "4")
         type = Magick::GrayscaleMatteType;
       // Color types 0, 2, and 3 can also have alpha channel, conveyed
       // via the "tRNS" chunk.  For 0 and 2, it's limited to GIF-style
       // binary transparency, while 3 can have any level of alpha per
-      // palette entry. We thus must check matte() to see if the image
+      // palette entry.  We thus must check matte() to see if the image
       // really doesn't have an alpha channel.
       if (imvec[0].matte ())
         {
           if (type == Magick::GrayscaleType)
             type = Magick::GrayscaleMatteType;
           else if (type == Magick::TrueColorType)
             type = Magick::TrueColorMatteType;
         }
@@ -723,17 +723,17 @@ maybe_initialize_magick (void)
       // Why we warn if < 16 instead of < 32 ?
       // The reasons for < 32 is simply that it's the maximum quantum
       // depth they support.  However, very few people would actually
       // need such support while being a major inconvenience to anyone
       // else (8 bit images suddenly taking 4x more space will be
       // critical for multi page images).  It would also suggests that
       // it covers all images which does not (it still does not support
       // float point and signed integer images).
-      // On the other hand, 16bit images are much more common. If quantum
+      // On the other hand, 16bit images are much more common.  If quantum
       // depth is 8, there's a good chance that we will be limited.  It
       // is also the GraphicsMagick recommended setting and the default
       // for ImageMagick.
       if (QuantumDepth < 16)
         warning_with_id ("Octave:GraphicsMagic-Quantum-Depth",
                          "your version of %s limits images to %d bits per pixel\n",
                          MagickPackageName, QuantumDepth);
 
@@ -793,17 +793,17 @@ Use @code{imread} instead.\n\
               // We do this check inside the loop because frameidx does not
               // need to be ordered (this is a feature and even allows for
               // some frames to be read multiple times).
               error ("imread: index/frames specified are outside the number of images");
             }
         }
     }
 
-  // Check that all frames have the same size. We don't do this at the same
+  // Check that all frames have the same size.  We don't do this at the same
   // time we decode the image because that's done in many different places,
   // to cover the different types of images which would lead to a lot of
   // copy and paste.
   {
     const unsigned int nRows = imvec[frameidx(0)].rows ();
     const unsigned int nCols = imvec[frameidx(0)].columns ();
     const octave_idx_type n = frameidx.numel ();
     for (octave_idx_type frame = 0; frame < n; frame++)
@@ -937,17 +937,17 @@ encode_indexed_images (std::vector<Magic
   typedef typename T::element_type P;
   const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
   const octave_idx_type nRows     = img.rows ();
   const octave_idx_type nCols     = img.columns ();
   const octave_idx_type cmap_size = cmap.rows ();
   const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
 
   // There is no colormap object, we need to build a new one for each frame,
-  // even if it's always the same. We can least get a vector for the Colors.
+  // even if it's always the same.  We can least get a vector for the Colors.
   std::vector<Magick::ColorRGB> colormap;
   {
     const double* cmap_fvec = cmap.fortran_vec ();
     const octave_idx_type G_offset = cmap_size;
     const octave_idx_type B_offset = cmap_size * 2;
     for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
       colormap.push_back (Magick::ColorRGB (cmap_fvec[map_idx],
                                             cmap_fvec[map_idx + G_offset],
@@ -963,23 +963,23 @@ encode_indexed_images (std::vector<Magic
 
       // Insert colormap.
       m_img.colorMapSize (cmap_size);
       for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
         m_img.colorMap (map_idx, colormap[map_idx]);
 
       // Why are we also setting the pixel values instead of only the
       // index values? We don't know if a file format supports indexed
-      // images. If we only set the indexes and then try to save the
+      // images.  If we only set the indexes and then try to save the
       // image as JPEG for example, the indexed values get discarded,
       // there is no conversion from the indexes, it's the initial values
-      // that get used. An alternative would be to only set the pixel
+      // that get used.  An alternative would be to only set the pixel
       // values (no indexes), then set the image as PseudoClass and GM
-      // would create a colormap for us. However, we wouldn't have control
-      // over the order of that colormap. And that's why we set both.
+      // would create a colormap for us.  However, we wouldn't have control
+      // over the order of that colormap.  And that's why we set both.
       Magick::PixelPacket* pix = m_img.getPixels (0, 0, nCols, nRows);
       Magick::IndexPacket* ind = m_img.getIndexes ();
       const P* img_fvec        = img.fortran_vec ();
 
       octave_idx_type GM_idx = 0;
       for (octave_idx_type column = 0; column < nCols; column++)
         {
           for (octave_idx_type row = 0; row < nRows; row++)
@@ -1082,18 +1082,18 @@ encode_uint_image (std::vector<Magick::I
       break;
 
     default:
       // __imwrite should have already filtered this cases
       error ("__magick_write__: wrong size on 3rd dimension");
     }
 
   // We will be passing the values as integers with depth as specified
-  // by QuantumDepth (maximum value specified by MaxRGB). This is independent
-  // of the actual depth of the image. GM will then convert the values but
+  // by QuantumDepth (maximum value specified by MaxRGB).  This is independent
+  // of the actual depth of the image.  GM will then convert the values but
   // while in memory, it always keeps the values as specified by QuantumDepth.
   // From GM documentation:
   //  Color arguments are must be scaled to fit the Quantum size according to
   //  the range of MaxRGB
   const double divisor = static_cast<double>((uint64_t (1) << bitdepth) - 1)
                          / MaxRGB;
 
   const P *img_fvec = img.fortran_vec ();
@@ -1322,23 +1322,23 @@ encode_uint_image (std::vector<Magick::I
 static std::map<octave_idx_type, std::string>
 init_disposal_methods ()
 {
   //  GIF Specifications:
   //
   // Disposal Method - Indicates the way in which the graphic is to
   //                    be treated after being displayed.
   //
-  //  0 -   No disposal specified. The decoder is
+  //  0 -   No disposal specified.  The decoder is
   //        not required to take any action.
-  //  1 -   Do not dispose. The graphic is to be left
+  //  1 -   Do not dispose.  The graphic is to be left
   //        in place.
-  //  2 -   Restore to background color. The area used by the
+  //  2 -   Restore to background color.  The area used by the
   //        graphic must be restored to the background color.
-  //  3 -   Restore to previous. The decoder is required to
+  //  3 -   Restore to previous.  The decoder is required to
   //        restore the area overwritten by the graphic with
   //        what was there prior to rendering the graphic.
   //  4-7 - To be defined.
   static std::map<octave_idx_type, std::string> methods;
   if (methods.empty ())
     {
       methods[0] = "doNotSpecify";
       methods[1] = "leaveInPlace";
@@ -1426,17 +1426,17 @@ Use @code{imwrite} instead.\n\
         encode_uint_image<uint16NDArray> (imvec, img.uint16_array_value (),
                                           alpha.uint16_array_value ());
       else if (img.is_uint32_type ())
         encode_uint_image<uint32NDArray> (imvec, img.uint32_array_value (),
                                           alpha.uint32_array_value ());
       else if (img.is_float_type ())
         {
           // For image formats that support floating point values, we write
-          // the actual values. For those who don't, we only use the values
+          // the actual values.  For those who don't, we only use the values
           // on the range [0 1] and save integer values.
           // But here, even for formats that would support floating point
           // values, GM seems unable to do that so we at least make them uint32.
           uint32NDArray clip_img;
           uint32NDArray clip_alpha;
           if (img.is_single_type ())
             {
               clip_img   = img_float2uint<FloatNDArray>
@@ -1452,17 +1452,17 @@ Use @code{imwrite} instead.\n\
           encode_uint_image<uint32NDArray> (imvec, clip_img, clip_alpha);
         }
       else
         error ("__magick_write__: image type not supported");
     }
   else
     {
       // We should not get floating point indexed images here because we
-      // converted them in __imwrite__.m. We should probably do it here
+      // converted them in __imwrite__.m.  We should probably do it here
       // but it would look much messier.
       if (img.is_uint8_type ())
         encode_indexed_images<uint8NDArray>  (imvec, img.uint8_array_value (),
                                               cmap);
       else if (img.is_uint16_type ())
         encode_indexed_images<uint16NDArray> (imvec, img.uint16_array_value (),
                                               cmap);
       else
@@ -1480,17 +1480,17 @@ Use @code{imwrite} instead.\n\
     options.getfield ("disposalmethod").cellstr_value ();
   for (octave_idx_type i = 0; i < nFrames; i++)
     {
       imvec[i].quality (quality);
       imvec[i].animationDelay (delaytime(i));
       imvec[i].gifDisposeMethod (disposal_methods[disposalmethod(i)]);
     }
 
-  // If writemode is set to append, read the image and append to it. Even
+  // If writemode is set to append, read the image and append to it.  Even
   // if set to append, make sure that something was read at all.
   const std::string writemode = options.getfield ("writemode").string_value ();
   if (writemode == "append" && octave::sys::file_stat (filename).exists ())
     {
       std::vector<Magick::Image> ini_imvec;
       read_file (filename, ini_imvec);
 
       if (ini_imvec.size () > 0)
@@ -1498,22 +1498,22 @@ Use @code{imwrite} instead.\n\
           ini_imvec.insert (ini_imvec.end (), imvec.begin (), imvec.end ());
           ini_imvec.swap (imvec);
         }
     }
 
   // FIXME: LoopCount or animationIterations
   //  How it should work:
   //
-  // This value is only set for the first image in the sequence. Trying
+  // This value is only set for the first image in the sequence.  Trying
   // to set this value with the append mode should have no effect, the
   // value used with the first image is the one that counts (that would
-  // also be Matlab compatible). Thus, the right way to do this would be
+  // also be Matlab compatible).  Thus, the right way to do this would be
   // to have an else block on the condition above, and set this only
-  // when creating a new file. Since Matlab does not interpret a 4D
+  // when creating a new file.  Since Matlab does not interpret a 4D
   // matrix as sequence of images to write, its users need to use a for
   // loop and set LoopCount only on the first iteration (it actually
   // throws warnings otherwise)
   //
   //  Why is this not done the right way:
   //
   // When GM saves a single image, it discards the value if there is only
   // a single image and sets it to "no loop".  Since our default is an
@@ -1556,18 +1556,18 @@ Use @code{imwrite} instead.\n\
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
-// Gets the minimum information from images such as its size and format. Much
-// faster than using imfinfo, which slows down a lot since. Note than without
+// Gets the minimum information from images such as its size and format.  Much
+// faster than using imfinfo, which slows down a lot since.  Note than without
 // this, we need to read the image once for imfinfo to set defaults (which is
 // done in Octave language), and then again for the actual reading.
 DEFUN (__magick_ping__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __magick_ping__ (@var{fname}, @var{idx})\n\
 Ping image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
@@ -1646,17 +1646,17 @@ magick_to_octave_value (const Magick::Co
       // This is named "rle" for the HDF, but the same thing is named
       // "ccitt" and "PackBits" for binary and non-binary images in TIFF.
       return octave_value ("rle");
     case Magick::ZipCompression:
       return octave_value ("deflate");
 
       // The following are present only in recent versions of GraphicsMagick.
       // At the moment the only use of this would be to have imfinfo report
-      // the compression method. In the future, someone could implement
+      // the compression method.  In the future, someone could implement
       // the Compression option for imwrite in which case a macro in
       // configure.ac will have to check for their presence of this.
       // See bug #39913
       //      case Magick::LZMACompression:
       //        return octave_value ("lzma");
       //      case Magick::JPEG2000Compression:
       //        return octave_value ("jpeg2000");
       //      case Magick::JBIG1Compression:
@@ -1811,24 +1811,24 @@ Use @code{imfinfo} instead.\n\
   const std::string filename = args(0).string_value ();
 
   std::vector<Magick::Image> imvec;
   read_file (filename, imvec);
 
   const octave_idx_type nFrames = imvec.size ();
   const std::string format = imvec[0].magick ();
 
-  // Here's how this function works. We need to return a struct array, one
+  // Here's how this function works.  We need to return a struct array, one
   // struct for each image in the file (remember, there are image
-  // that allow for multiple images in the same file). Now, Matlab seems
+  // that allow for multiple images in the same file).  Now, Matlab seems
   // to have format specific code so the fields on the struct are different
-  // for each format. It only has a small subset that is common to all
-  // of them, the others are undocumented. Because we try to abstract from
+  // for each format.  It only has a small subset that is common to all
+  // of them, the others are undocumented.  Because we try to abstract from
   // the formats we always return the same list of fields (note that with
-  // GM we support more than 88 formats. That's way more than Matlab, and
+  // GM we support more than 88 formats.  That's way more than Matlab, and
   // I don't want to write specific code for each of them).
   //
   // So what we do is we create an octave_scalar_map, fill it with the
   // information for that image, and then insert it into an octave_map.
   // Because in the same file, different images may have values for
   // different fields, we can't create a field only if there's a value.
   // Bad things happen if we merge octave_scalar_maps with different
   // fields from the others (suppose for example a TIFF file with 4 images,
@@ -1842,17 +1842,17 @@ Use @code{imfinfo} instead.\n\
     "FileSize",
     "Format",
     "FormatVersion",
     "Width",
     "Height",
     "BitDepth",
     "ColorType",
 
-    // These are format specific or not existent in Matlab. The most
+    // These are format specific or not existent in Matlab.  The most
     // annoying thing is that Matlab may have different names for the
     // same thing in different formats.
     "DelayTime",
     "DisposalMethod",
     "LoopCount",
     "ByteOrder",
     "Gamma",
     "Chromaticities",
@@ -1870,31 +1870,31 @@ Use @code{imfinfo} instead.\n\
     "DateTime",           // actually an Exif tag
     "ImageDescription",   // actually an Exif tag
     "Artist",             // actually an Exif tag
     "Copyright",          // actually an Exif tag
     "DigitalCamera",
     "GPSInfo",
     // Notes for the future: GM allows one to get many attributes, and even has
     // attribute() to obtain arbitrary ones, that may exist in only some
-    // cases. The following is a list of some methods and into what possible
+    // cases.  The following is a list of some methods and into what possible
     // Matlab compatible values they may be converted.
     //
     //  colorSpace()      -> PhotometricInterpretation
     //  backgroundColor() -> BackgroundColor
     //  interlaceType()   -> Interlaced, InterlaceType, and PlanarConfiguration
     //  label()           -> Title
     0
   };
 
   // The one we will return at the end
   octave_map info (dim_vector (nFrames, 1), string_vector (fields));
 
   // Some of the fields in the struct are about file information and will be
-  // the same for all images in the file. So we create a template, fill in
+  // the same for all images in the file.  So we create a template, fill in
   // those values, and make a copy of the template for each image.
   octave_scalar_map template_info = (string_vector (fields));
 
   template_info.setfield ("Format", octave_value (format));
   // We can't actually get FormatVersion but even Matlab sometimes can't.
   template_info.setfield ("FormatVersion", octave_value (""));
 
   const octave::sys::file_stat fs (filename);
@@ -1915,17 +1915,17 @@ Use @code{imfinfo} instead.\n\
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
       info_frame.setfield ("Height", octave_value (img.rows ()));
       info_frame.setfield ("BitDepth",
                            octave_value (get_depth (const_cast<Magick::Image&> (img))));
 
       // Stuff related to colormap, image class and type
-      // Because GM is too smart for us... Read the comments in is_indexed()
+      // Because GM is too smart for us...  Read the comments in is_indexed()
       {
         std::string color_type;
         Matrix cmap;
         if (is_indexed (img))
           {
             color_type = "indexed";
             cmap =
               read_maps (const_cast<Magick::Image&> (img))(0).matrix_value ();
@@ -1960,18 +1960,18 @@ Use @code{imfinfo} instead.\n\
                 color_type = "undefined";
               }
           }
         info_frame.setfield ("ColorType", octave_value (color_type));
         info_frame.setfield ("Colormap",  octave_value (cmap));
       }
 
       {
-        // Not all images have chroma values. In such cases, they'll
-        // be all zeros. So rather than send a matrix of zeros, we will
+        // Not all images have chroma values.  In such cases, they'll
+        // be all zeros.  So rather than send a matrix of zeros, we will
         // check for that, and send an empty vector instead.
         RowVector chromaticities (8);
         double* chroma_fvec = chromaticities.fortran_vec ();
         img.chromaWhitePoint    (&chroma_fvec[0], &chroma_fvec[1]);
         img.chromaRedPrimary    (&chroma_fvec[2], &chroma_fvec[3]);
         img.chromaGreenPrimary  (&chroma_fvec[4], &chroma_fvec[5]);
         img.chromaBluePrimary   (&chroma_fvec[6], &chroma_fvec[7]);
         if (chromaticities.nnz () == 0)
@@ -1993,25 +1993,25 @@ Use @code{imfinfo} instead.\n\
       info_frame.setfield ("Orientation",
                            magick_to_octave_value (img.orientation ()));
       info_frame.setfield ("ResolutionUnit",
                            magick_to_octave_value (img.resolutionUnits ()));
       info_frame.setfield ("ByteOrder",
                            magick_to_octave_value (img.endian ()));
 
       // It is not possible to know if there's an Exif field so we just
-      // check for the Exif Version value. If it does exists, then we
+      // check for the Exif Version value.  If it does exists, then we
       // bother about looking for specific fields.
       {
         Magick::Image& cimg = const_cast<Magick::Image&> (img);
 
         // These will be in Exif tags but must appear as fields in the
         // base struct array, not as another struct in one of its fields.
         // This is likely because they belong to the Baseline TIFF specs
-        // and may appear out of the Exif tag. So first we check if it
+        // and may appear out of the Exif tag.  So first we check if it
         // exists outside the Exif tag.
         // See Section 4.6.4, table 4, page 28 of Exif specs version 2.3
         // (CIPA DC- 008-Translation- 2010)
         static const char *base_exif_str_fields[] =
         {
           "DateTime",
           "ImageDescription",
           "Make",
@@ -2050,17 +2050,17 @@ Use @code{imfinfo} instead.\n\
               "ImageUniqueID",
               "CameraOwnerName",
               "BodySerialNumber",
               "LensMake",
               "LensModel",
               "LensSerialNumber",
               "SpectralSensitivity",
               // These last two are of type undefined but most likely will
-              // be strings. Even if they're not GM returns a string anyway.
+              // be strings.  Even if they're not GM returns a string anyway.
               "UserComment",
               "MakerComment",
               0
             };
             static const string_vector exif_str (exif_str_fields);
             static const octave_idx_type n_exif_str = exif_str.numel ();
             for (octave_idx_type field = 0; field < n_exif_str; field++)
               fill_exif (camera, cimg, exif_str[field]);
@@ -2133,17 +2133,17 @@ Use @code{imfinfo} instead.\n\
               0
             };
             static const string_vector exif_float (exif_float_fields);
             static const octave_idx_type n_exif_float = exif_float.numel ();
             for (octave_idx_type field = 0; field < n_exif_float; field++)
               fill_exif_floats (camera, cimg, exif_float[field]);
 
             // Inside a Exif field, it is possible that there is also a
-            // GPS field. This is not the same as ExifVersion but seems
+            // GPS field.  This is not the same as ExifVersion but seems
             // to be how we have to check for it.
             if (cimg.attribute ("EXIF:GPSInfo") != "unknown")
               {
                 // The story here is the same as with Exif.
                 // See Section 4.6.6, table 15 on page 68 of Exif specs
                 // version 2.3 (CIPA DC- 008-Translation- 2010)
 
                 static const char *gps_str_fields[] =
@@ -2262,27 +2262,27 @@ Fill formats info with GraphicsMagick Co
     {
       try
         {
           octave_scalar_map fmt = formats.checkelem (idx);
           Magick::CoderInfo coder (fmt.getfield ("coder").string_value ());
 
           fmt.setfield ("description", octave_value (coder.description ()));
           fmt.setfield ("multipage", coder.isMultiFrame () ? true : false);
-          // default for read and write is a function handle. If we can't
+          // default for read and write is a function handle.  If we can't
           // read or write them, them set it to an empty value
           if (! coder.isReadable ())
             fmt.setfield ("read",  Matrix ());
           if (! coder.isWritable ())
             fmt.setfield ("write", Matrix ());
           formats.fast_elem_insert (idx, fmt);
         }
       catch (Magick::Exception& e)
         {
-          // Exception here are missing formats. So we remove the format
+          // Exception here are missing formats.  So we remove the format
           // from the structure and reduce idx.
           formats.delete_elements (idx);
           idx--;
         }
     }
 
 #else
 
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -848,37 +848,37 @@ FIXME: Function airy does not yet have B
 %!assert (besselh (-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 
 
 Tests contributed by Robert T. Short.
 Tests are based on the properties and tables in A&S:
  Abramowitz and Stegun, "Handbook of Mathematical Functions",
  1972.
 
-For regular Bessel functions, there are 3 tests. These compare octave
+For regular Bessel functions, there are 3 tests.  These compare octave
 results against Tables 9.1, 9.2, and 9.4 in A&S. Tables 9.1 and 9.2
 are good to only a few decimal places, so any failures should be
-considered a broken implementation. Table 9.4 is an extended table
-for larger orders and arguments. There are some differences between
+considered a broken implementation.  Table 9.4 is an extended table
+for larger orders and arguments.  There are some differences between
 Octave and Table 9.4, mostly in the last decimal place but in a very
-few instances the errors are in the last two places. The comparison
+few instances the errors are in the last two places.  The comparison
 tolerance has been changed to reflect this.
 
-Similarly for modifed Bessel functions, there are 3 tests. These
+Similarly for modified Bessel functions, there are 3 tests.  These
 compare octave results against Tables 9.8, 9.9, and 9.11 in A&S.
 Tables 9.8 and 9.9 are good to only a few decimal places, so any
-failures should be considered a broken implementation. Table 9.11 is
-an extended table for larger orders and arguments. There are some
+failures should be considered a broken implementation.  Table 9.11 is
+an extended table for larger orders and arguments.  There are some
 differences between octave and Table 9.11, mostly in the last decimal
 place but in a very few instances the errors are in the last two
-places. The comparison tolerance has been changed to reflect this.
+places.  The comparison tolerance has been changed to reflect this.
 
 For spherical Bessel functions, there are also three tests, comparing
-octave results to Tables 10.1, 10.2, and 10.4 in A&S. Very similar
-comments may be made here as in the previous lines. At this time,
+octave results to Tables 10.1, 10.2, and 10.4 in A&S.  Very similar
+comments may be made here as in the previous lines.  At this time,
 modified spherical Bessel function tests are not included.
 
 % Table 9.1 - J and Y for integer orders 0, 1, 2.
 % Compare against excerpts of Table 9.1, Abramowitz and Stegun.
 %!test
 %! n = 0:2;
 %! z = (0:2.5:17.5)';
 %!
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -105,17 +105,17 @@ bitopxx (const OP& op, const std::string
         result(i+k) = op (x(i), y(k));
     else
       result(i) = op (x(i), y(i));
 
   return result;
 }
 
 // Trampoline function, instantiates the proper template above, with
-// reflective information hardwired. We can't hardwire this information
+// reflective information hardwired.  We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
 template <typename T>
 octave_value
 bitopx (const std::string& fname, const Array<T>& x, const Array<T>& y)
 {
   if (fname == "bitand")
     return bitopxx (std::bit_and<T>(), fname, x, y);
diff --git a/libinterp/corefcn/cdisplay.c b/libinterp/corefcn/cdisplay.c
--- a/libinterp/corefcn/cdisplay.c
+++ b/libinterp/corefcn/cdisplay.c
@@ -84,17 +84,17 @@ octave_get_display_info (int *ht, int *w
   if (display)
     {
 #if defined (HAVE_CARBON_CGDISPLAYBITSPERPIXEL)
 
       *dp = CGDisplayBitsPerPixel (display);
 
 #else
 
-      /* FIXME: This will only work for MacOS > 10.5. For earlier versions
+      /* FIXME: This will only work for MacOS > 10.5.  For earlier versions
          this code is not needed (use CGDisplayBitsPerPixel instead).  */
 
       CGDisplayModeRef mode = CGDisplayCopyDisplayMode (display);
       CFStringRef pixelEncoding = CGDisplayModeCopyPixelEncoding (mode);
 
       if (CFStringCompare (pixelEncoding, CFSTR (IO32BitDirectPixels), 0) == 0)
         *dp = 32;
       else if (CFStringCompare (pixelEncoding,
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1902,29 +1902,29 @@ do_mat2cell_2d (const Array2D& a, const 
   int ivec = -1;
   if (a.rows () > 1 && a.cols () == 1 && ncidx == 1)
     ivec = 0;
   else if (a.rows () == 1 && nridx == 1 && nd == 2)
     ivec = 1;
 
   if (ivec >= 0)
     {
-      // Vector split. Use 1D indexing.
+      // Vector split.  Use 1D indexing.
       octave_idx_type l = 0;
       octave_idx_type nidx = (ivec == 0 ? nridx : ncidx);
       for (octave_idx_type i = 0; i < nidx; i++)
         {
           octave_idx_type u = l + d[ivec](i);
           retval(i) = a.index (idx_vector (l, u));
           l = u;
         }
     }
   else
     {
-      // General 2D case. Use 2D indexing.
+      // General 2D case.  Use 2D indexing.
       OCTAVE_LOCAL_BUFFER (idx_vector, ridx, nridx);
       prepare_idx (ridx, 0, nd, d);
 
       OCTAVE_LOCAL_BUFFER (idx_vector, cidx, ncidx);
       prepare_idx (cidx, 1, nd, d);
 
       for (octave_idx_type j = 0; j < ncidx; j++)
         for (octave_idx_type i = 0; i < nridx; i++)
@@ -1933,17 +1933,17 @@ do_mat2cell_2d (const Array2D& a, const 
 
             retval(i,j) = a.index (ridx[i], cidx[j]);
           }
     }
 
   return retval;
 }
 
-// Nd case. Works for Arrays and octave_map.
+// Nd case.  Works for Arrays and octave_map.
 // Uses Nd indexing.
 
 template <typename ArrayND>
 Cell
 do_mat2cell_nd (const ArrayND& a, const Array<octave_idx_type> *d, int nd)
 {
   NoAlias<Cell> retval;
   assert (nd >= 1);
@@ -1998,17 +1998,17 @@ Cell
 do_mat2cell (const ArrayND& a, const Array<octave_idx_type> *d, int nd)
 {
   if (a.ndims () == 2 && nd <= 2)
     return do_mat2cell_2d (a, d, nd);
   else
     return do_mat2cell_nd (a, d, nd);
 }
 
-// General case. Works for any class supporting do_index_op.
+// General case.  Works for any class supporting do_index_op.
 // Uses Nd indexing.
 
 Cell
 do_mat2cell (octave_value& a, const Array<octave_idx_type> *d, int nd)
 {
   NoAlias<Cell> retval;
   assert (nd >= 1);
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2075,26 +2075,26 @@ do_cat (const octave_value_list& xargs, 
           for (int i = 1; i < args.length (); i++)
             {
               if (! (dv.*concat_rule) (args(i).dims (), dim))
                 error ("cat: dimension mismatch");
             }
 
           // The lines below might seem crazy, since we take a copy
           // of the first argument, resize it to be empty and then resize
-          // it to be full. This is done since it means that there is no
+          // it to be full.  This is done since it means that there is no
           // recopying of data, as would happen if we used a single resize.
           // It should be noted that resize operation is also significantly
           // slower than the do_cat_op function, so it makes sense to have
           // an empty matrix and copy all data.
           //
           // We might also start with a empty octave_value using
           //   tmp = octave_value_typeinfo::lookup_type
           //                                (args(1).type_name());
-          // and then directly resize. However, for some types there might
+          // and then directly resize.  However, for some types there might
           // be some additional setup needed, and so this should be avoided.
 
           octave_value tmp = args(0);
           tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
           int dv_len = dv.ndims ();
           Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
@@ -7492,17 +7492,17 @@ do_diff (const octave_value& array, octa
 {
   octave_value retval;
 
   const dim_vector& dv = array.dims ();
   if (dim == -1)
     {
       dim = array.dims ().first_non_singleton ();
 
-      // Bother Matlab. This behavior is really wicked.
+      // Bother Matlab.  This behavior is really wicked.
       if (dv(dim) <= order)
         {
           if (dv(dim) == 1)
             retval = array.resize (dim_vector (0, 0));
           else
             {
               retval = array;
               while (order > 0)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -292,17 +292,17 @@ parse_dbfunction_params (const char *who
               error ("%s: Only one 'at' clause is allowed -- %s",
                      who, args(pos).string_value ().c_str ());
             else if (seen_if)
                 error ("%s: line number must come before 'if' clause\n");
             seen_at = true;
 
             if (! seen_in)
               {
-                // It was a line number. Get function name from debugger.
+                // It was a line number.  Get function name from debugger.
                 if (Vdebugging)
                   symbol_name = get_user_code ()->profiler_name ();
                 else
                   error ("%s: function name must come before line number "
                          "and 'if'", who);
                 seen_in = true;
               }
             else if (seen_if)
diff --git a/libinterp/corefcn/defun-int.h b/libinterp/corefcn/defun-int.h
--- a/libinterp/corefcn/defun-int.h
+++ b/libinterp/corefcn/defun-int.h
@@ -57,17 +57,17 @@ install_mex_function (void *fptr, bool f
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 // Gets the shlib of the currently executing DLD function, if any.
 extern OCTINTERP_API octave::dynamic_library
 get_current_shlib (void);
 
 // This is a convenience class that calls the above function automatically at
-// construction time. When deriving new classes, you can either use it as a
+// construction time.  When deriving new classes, you can either use it as a
 // field or as a parent (with multiple inheritance).
 
 class octave_auto_shlib : public octave::dynamic_library
 {
 public:
   octave_auto_shlib (void)
     : octave::dynamic_library (get_current_shlib ()) { }
   octave_auto_shlib (const octave::dynamic_library& shl)
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -175,17 +175,17 @@ verror (bool save_last_error, std::ostre
     {
       if (in_try_catch && ! strcmp (name, "error"))
         msg_string += "caught error: ";
       else
         msg_string += std::string (name) + ": ";
     }
 
   // If with_fcn is specified, we'll attempt to prefix the message with the name
-  // of the current executing function. But we'll do so only if:
+  // of the current executing function.  But we'll do so only if:
   // 1. the name is not empty (anonymous function)
   // 2. it is not already there (including the following colon)
   if (with_cfn)
     {
       octave_function *curfcn = octave_call_stack::current ();
       if (curfcn)
         {
           std::string cfn = curfcn->name ();
diff --git a/libinterp/corefcn/event-queue.h b/libinterp/corefcn/event-queue.h
--- a/libinterp/corefcn/event-queue.h
+++ b/libinterp/corefcn/event-queue.h
@@ -80,19 +80,18 @@ private:
   // No copying!
 
   event_queue (const event_queue&);
 
   event_queue& operator = (const event_queue&);
 };
 
 // Like event_queue, but this one will guard against the
-// possibility of seeing an exception (or interrupt) in the cleanup
-// actions. Not that we can do much about it, but at least we won't
-// crash.
+// possibility of seeing an exception (or interrupt) in the cleanup actions.
+// Not that we can do much about it, but at least we won't crash.
 
 class
 event_queue_safe : public event_queue
 {
 private:
 
   void warn_unhandled_exception (void) const;
 
@@ -103,17 +102,17 @@ public:
   ~event_queue_safe (void)
   {
     while (! empty ())
       {
         try
           {
             run_first ();
           }
-        catch (...) // Yes, the black hole. Remember we're in a dtor.
+        catch (...) // Yes, the black hole.  Remember we're in a dtor.
           {
             warn_unhandled_exception ();
           }
       }
   }
 
 private:
 
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -426,17 +426,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
         {
           SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
-          // matrix. Try to reuse the possibly cached index vector.
+          // matrix.  Try to reuse the possibly cached index vector.
 
           // No need to catch index_exception, since arg is bool.
           // Out-of-range errors have already set pos, and will be caught later.
           retval(0) = arg.index_vector ().unmask ();
         }
       else
         {
           boolNDArray v = arg.bool_array_value ();
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -127,17 +127,17 @@ public:
 
 private:
 
   static ft_manager *instance;
 
   typedef std::pair<std::string, double> ft_key;
   typedef std::map<ft_key, FT_Face> ft_cache;
 
-  // Cache the fonts loaded by FreeType. This cache only contains
+  // Cache the fonts loaded by FreeType.  This cache only contains
   // weak references to the fonts, strong references are only present
   // in class text_renderer.
   ft_cache cache;
 
 private:
 
   // No copying!
 
@@ -178,17 +178,17 @@ private:
 
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
                        const std::string& angle, double size)
   {
     FT_Face retval = 0;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
-    // Look first into the font cache, then use fontconfig. If the font
+    // Look first into the font cache, then use fontconfig.  If the font
     // is present in the cache, simply add a reference and return it.
 
     ft_key key (name + ":" + weight + ":" + angle, size);
     ft_cache::const_iterator it = cache.find (key);
 
     if (it != cache.end ())
       {
         FT_Reference_Face (it->second);
@@ -271,17 +271,17 @@ private:
     if (! file.empty ())
       {
         if (FT_New_Face (library, file.c_str (), 0, &retval))
           ::warning ("ft_manager: unable to load font: %s", file.c_str ());
 #if defined (HAVE_FT_REFERENCE_FACE)
         else
           {
             // Install a finalizer to notify ft_manager that the font is
-            // being destroyed. The class ft_manager only keeps weak
+            // being destroyed.  The class ft_manager only keeps weak
             // references to font objects.
 
             retval->generic.data = new ft_key (key);
             retval->generic.finalizer = ft_face_destroyed;
 
             // Insert loaded font into the cache.
 
             cache[key] = retval;
@@ -458,39 +458,39 @@ public:
 private:
 
   // The current font used by the renderer.
   ft_font font;
 
   // Used to stored the bounding box corresponding to the rendered text.
   // The bounding box has the form [x, y, w, h] where x and y represent the
   // coordinates of the bottom left corner relative to the anchor point of
-  // the text (== start of text on the baseline). Due to font descent or
+  // the text (== start of text on the baseline).  Due to font descent or
   // multiple lines, the value y is usually negative.
   Matrix bbox;
 
-  // Used to stored the rendered text. It's a 3D matrix with size MxNx4
+  // Used to stored the rendered text.  It's a 3D matrix with size MxNx4
   // where M and N are the width and height of the bounding box.
   uint8NDArray pixels;
 
-  // Used to store the bounding box of each line. This is used to layout
+  // Used to store the bounding box of each line.  This is used to layout
   // multiline text properly.
   std::list<Matrix> line_bbox;
 
-  // The current horizontal alignment. This is used to align multi-line text.
+  // The current horizontal alignment.  This is used to align multi-line text.
   int halign;
 
   // The X offset for the next glyph.
   int xoffset;
 
   // The Y offset of the baseline for the current line.
   int line_yoffset;
 
-  // The Y offset of the baseline for the next glyph. The offset is relative
-  // to line_yoffset. The total Y offset is computed with:
+  // The Y offset of the baseline for the next glyph.  The offset is relative
+  // to line_yoffset.  The total Y offset is computed with:
   // line_yoffset + yoffset.
   int yoffset;
 
   // The current mode of the rendering process (box computing or rendering).
   int mode;
 
   // The base color of the rendered text.
   uint8NDArray color;
@@ -611,17 +611,17 @@ ft_text_renderer::compute_bbox (void)
       break;
     }
 }
 
 void
 ft_text_renderer::update_line_bbox (void)
 {
   // Called after a font change, when in MODE_BBOX mode, to update the
-  // current line bbox with the new font metrics. This also includes the
+  // current line bbox with the new font metrics.  This also includes the
   // current yoffset, that is the offset of the current glyph's baseline
   // the line's baseline.
 
   if (mode == MODE_BBOX)
     {
       int asc = font.get_face ()->size->metrics.ascender >> 6;
       int desc = font.get_face ()->size->metrics.descender >> 6;
 
@@ -786,29 +786,29 @@ ft_text_renderer::process_character (FT_
                     push_new_line ();
                 }
               else
                 {
                   Matrix& bb = line_bbox.back ();
 
                   // If we have a previous glyph, use kerning information.
                   // This usually means moving a bit backward before adding
-                  // the next glyph. That is, "delta.x" is usually < 0.
+                  // the next glyph.  That is, "delta.x" is usually < 0.
                   if (previous)
                     {
                       FT_Vector delta;
 
                       FT_Get_Kerning (face, previous, glyph_index,
                                       FT_KERNING_DEFAULT, &delta);
 
                       xoffset += (delta.x >> 6);
                     }
 
                   // Extend current X offset box by the width of the current
-                  // glyph. Then extend the line bounding box if necessary.
+                  // glyph.  Then extend the line bounding box if necessary.
 
                   xoffset += (face->glyph->advance.x >> 6);
                   bb(2) = xmax (bb(2), xoffset);
                 }
               break;
             }
         }
     }
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -65,17 +65,17 @@ enum
 enum
 {
   NONE,
   //FLAT,  // Already declared in anonymous enum for color mode
   GOURAUD = 2
 };
 
 // Win32 API requires the CALLBACK attributes for
-// GLU callback functions. Define it to empty on
+// GLU callback functions.  Define it to empty on
 // other platforms.
 #if ! defined (CALLBACK)
 #  define CALLBACK
 #endif
 
 class
 opengl_texture
 {
@@ -2482,17 +2482,17 @@ void
 opengl_renderer::draw_patch (const patch::properties &props)
 {
 #if defined (HAVE_OPENGL)
 
   // Do not render if the patch has incoherent data
   std::string msg;
   if (props.has_bad_data (msg))
     {
-      warning ("opengl_renderer: %s. Not rendering.", msg.c_str ());
+      warning ("opengl_renderer: %s.  Not rendering.", msg.c_str ());
       return;
     }
 
   const Matrix f = props.get_faces ().matrix_value ();
   const Matrix v = xform.scale (props.get_vertices ().matrix_value ());
   Matrix c;
   const Matrix n = props.get_vertexnormals ().matrix_value ();
   Matrix a;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -5315,17 +5315,17 @@ axes::properties::update_camera (void)
 
   double v_angle;
 
   if (cameraviewanglemode_is ("auto"))
     {
       double af;
 
       // FIXME: was this really needed?  When compared to Matlab, it
-      // does not seem to be required. Need investigation with concrete
+      // does not seem to be required.  Need investigation with concrete
       // graphics toolkit to see results visually.
       if (false && dowarp)
         af = 1.0 / (xM > yM ? xM : yM);
       else
         {
           if ((bb(2)/bb(3)) > (xM/yM))
             af = 1.0 / yM;
           else
@@ -6799,17 +6799,17 @@ axes::properties::calc_ticks_and_lims (a
 
   if (lims.get ().is_empty ())
     return;
 
   double lo = (lims.get ().matrix_value ())(0);
   double hi = (lims.get ().matrix_value ())(1);
   bool is_negative = lo < 0 && hi < 0;
   double tmp;
-  // FIXME: should this be checked for somewhere else? (i.e. set{x,y,z}lim)
+  // FIXME: should this be checked for somewhere else? (i.e., set{x,y,z}lim)
   if (hi < lo)
     std::swap (hi, lo);
 
   if (is_logscale)
     {
       if (is_negative)
         {
           tmp = hi;
@@ -11240,17 +11240,17 @@ immediately.\n\
 In the third form, execution is suspended until the graphics object is\n\
 destroyed or the property named @var{prop} is set to @var{value}.  The\n\
 function @code{isequal} is used to compare property values.  If the graphics\n\
 handle is invalid, the property does not exist or the property is already\n\
 set to @var{value}, the function returns immediately.\n\
 \n\
 An optional timeout can be specified using the property @code{timeout}.\n\
 This timeout value is the number of seconds to wait for the condition to be\n\
-true.  @var{timeout} must be at least 1. If a smaller value is specified, a\n\
+true.  @var{timeout} must be at least 1.  If a smaller value is specified, a\n\
 warning is issued and a value of 1 is used instead.  If the timeout value is\n\
 not an integer, it is truncated towards 0.\n\
 \n\
 To define a condition on a property named @code{timeout}, use the string\n\
 @code{\\timeout} instead.\n\
 \n\
 In all cases, typing CTRL-C stops program execution immediately.\n\
 @seealso{waitforbuttonpress, isequal}\n\
@@ -11391,17 +11391,17 @@ In all cases, typing CTRL-C stops progra
 
       if (timeout < 1)
         {
           warning ("waitfor: TIMEOUT value must be >= 1, using 1 instead");
           timeout = 1;
         }
     }
 
-  // FIXME: There is still a "hole" in the following loop. The code
+  // FIXME: There is still a "hole" in the following loop.  The code
   //        assumes that an object handle is unique, which is a fair
   //        assumption, except for figures.  If a figure is destroyed
   //        then recreated with the same figure ID, within the same
   //        run of event hooks, then the figure destruction won't be
   //        caught and the loop will not stop.  This is an unlikely
   //        possibility in practice, though.
   //
   //        Using deletefcn callback is also unreliable as it could be
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2228,18 +2228,18 @@ public:
   // Notifies graphics toolkit that new object was created.
   bool initialize (const graphics_object& go)
   { return rep->initialize (go); }
 
   bool initialize (const graphics_handle& h)
   { return rep->initialize (h); }
 
   // Notifies graphics toolkit that object was destroyed.
-  // This is called only for explicitly deleted object. Children are
-  // deleted implicitly and graphics toolkit isn't notified.
+  // This is called only for explicitly deleted object.
+  // Children are deleted implicitly and graphics toolkit isn't notified.
   void finalize (const graphics_object& go)
   { rep->finalize (go); }
 
   void finalize (const graphics_handle& h)
   { rep->finalize (h); }
 
   // Close the graphics toolkit.
   void close (void) { rep->close (); }
@@ -4979,25 +4979,25 @@ public:
     }
 
     void update_data (void);
 
     void set_normalmode (const octave_value& val)
     {
       warning_with_id ("Octave:deprecated-property",
         "patch: Property 'normalmode' is deprecated and will be removed "
-        "from a future version of Octave. Use 'vertexnormalsmode' instead.");
+        "from a future version of Octave.  Use 'vertexnormalsmode' instead.");
       set_vertexnormalsmode (val);
     }
 
     std::string get_normalmode (void) const
     {
       warning_with_id ("Octave:deprecated-property",
         "patch: Property 'normalmode' is deprecated and will be removed "
-        "from a future version of Octave. Use 'vertexnormalsmode' instead.");
+        "from a future version of Octave.  Use 'vertexnormalsmode' instead.");
       return vertexnormalsmode.current_value ();
     }
   };
 
 private:
   properties xproperties;
 
 public:
@@ -5159,25 +5159,25 @@ public:
 
     void update_vertexnormalsmode (void)
     { update_vertex_normals (); }
 
     void set_normalmode (const octave_value& val)
     {
       warning_with_id ("Octave:deprecated-property",
         "surface: Property 'normalmode' is deprecated and will be removed "
-        "from a future version of Octave. Use 'vertexnormalsmode' instead.");
+        "from a future version of Octave.  Use 'vertexnormalsmode' instead.");
       set_vertexnormalsmode (val);
     }
 
     std::string get_normalmode (void) const
     {
       warning_with_id ("Octave:deprecated-property",
         "surface: Property 'normalmode' is deprecated and will be removed "
-        "from a future version of Octave. Use 'vertexnormalsmode' instead.");
+        "from a future version of Octave.  Use 'vertexnormalsmode' instead.");
       return vertexnormalsmode.current_value ();
     }
   };
 
 private:
   properties xproperties;
 
 public:
diff --git a/libinterp/corefcn/hash.cc b/libinterp/corefcn/hash.cc
--- a/libinterp/corefcn/hash.cc
+++ b/libinterp/corefcn/hash.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 /*
 Implementation note (Dec, 2015): All supported cryptographic hash
 functions are calling "low-level" inplementations of the GNULIB.
 
 The GNULIB, contains even more HMAC based algorithms, c.f.
 https://www.gnu.org/software/gnulib/MODULES.html#module=crypto/hmac-md5
 so a future project might be including these algorithms as well, adding
 a third key input parameter.  There is also a GNULIB "high-level"
-interface to Libcrypt. It might be easier to use, but it introduces
+interface to Libcrypt.  It might be easier to use, but it introduces
 a new build dependency, so better stick to the "low-level" functions
 for now.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
diff --git a/libinterp/corefcn/jit-ir.h b/libinterp/corefcn/jit-ir.h
--- a/libinterp/corefcn/jit-ir.h
+++ b/libinterp/corefcn/jit-ir.h
@@ -727,18 +727,18 @@ public:
   { return mlocation; }
 
   void stash_location (std::list<jit_block *>::iterator alocation)
   { mlocation = alocation; }
 
   // used to prevent visiting the same node twice in the graph
   size_t visit_count (void) const { return mvisit_count; }
 
-  // check if this node has been visited yet at the given visit count. If we
-  // have not been visited yet, mark us as visited.
+  // check if this node has been visited yet at the given visit count.
+  // If we have not been visited yet, mark us as visited.
   bool visited (size_t avisit_count)
   {
     if (mvisit_count <= avisit_count)
       {
         mvisit_count = avisit_count + 1;
         return false;
       }
 
@@ -914,17 +914,17 @@ public:
   }
 
   jit_value *src (void) const
   {
     return argument (1);
   }
 
   // variables don't get modified in an SSA, but COW requires we modify
-  // variables. An artificial assign is for when a variable gets modified. We
+  // variables.  An artificial assign is for when a variable gets modified.  We
   // need an assign in the SSA, but the reference counts shouldn't be updated.
   bool artificial (void) const { return martificial; }
 
   void mark_artificial (void) { martificial = true; }
 
   virtual bool infer (void)
   {
     jit_type *stype = src ()->type ();
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -707,19 +707,19 @@ jit_function::call (llvm::IRBuilderD& bu
   return ret;
 }
 
 llvm::Value *
 jit_function::argument (llvm::IRBuilderD& builder, size_t idx) const
 {
   assert (idx < args.size ());
 
-  // FIXME: We should be treating arguments like a list, not a vector. Shouldn't
-  // matter much for now, as the number of arguments shouldn't be much bigger
-  // than 4
+  // FIXME: We should be treating arguments like a list, not a vector.
+  // Shouldn't matter much for now, as the number of arguments shouldn't
+  // be much bigger than 4
   llvm::Function::arg_iterator iter = llvm_function->arg_begin ();
   if (sret ())
     ++iter;
 
   for (size_t i = 0; i < idx; ++i, ++iter);
 
   if (args[idx]->pointer_arg (call_conv))
     return builder.CreateLoad (iter);
@@ -1262,19 +1262,19 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   binary_ops[octave_value::op_div].add_overload (fn);
   binary_ops[octave_value::op_el_div].add_overload (fn);
 
   // ldiv is the same as div with the operators reversed
   fn = mirror_binary (fn);
   binary_ops[octave_value::op_ldiv].add_overload (fn);
   binary_ops[octave_value::op_el_ldiv].add_overload (fn);
 
-  // In general, the result of scalar ^ scalar is a complex number. We might be
-  // able to improve on this if we keep track of the range of values varaibles
-  // can take on.
+  // In general, the result of scalar ^ scalar is a complex number.  We might
+  // be able to improve on this if we keep track of the range of values
+  // variables can take on.
   fn = create_external (JIT_FN (octave_jit_pow_scalar_scalar), complex, scalar,
                         scalar);
   binary_ops[octave_value::op_pow].add_overload (fn);
   binary_ops[octave_value::op_el_pow].add_overload (fn);
 
   // now for unary scalar operations
   // FIXME: Impelment not
   fn = create_internal ("octave_jit_++", scalar, scalar);
@@ -2232,17 +2232,17 @@ jit_typeinfo::do_type_of (const octave_v
         return get_matrix ();
     }
 
   if (ov.is_complex_scalar ())
     {
       Complex cv = ov.complex_value ();
 
       // We don't really represent complex values, instead we represent
-      // complex_or_scalar. If the imag value is zero, we assume a scalar.
+      // complex_or_scalar.  If the imag value is zero, we assume a scalar.
       if (cv.imag () != 0)
         return get_complex ();
     }
 
   return get_any ();
 }
 
 #endif
diff --git a/libinterp/corefcn/jit-typeinfo.h b/libinterp/corefcn/jit-typeinfo.h
--- a/libinterp/corefcn/jit-typeinfo.h
+++ b/libinterp/corefcn/jit-typeinfo.h
@@ -120,20 +120,20 @@ namespace jit_convention
 
     // an external C call
     external,
 
     length
   };
 }
 
-// Used to keep track of estimated (infered) types during JIT. This is a
+// Used to keep track of estimated (infered) types during JIT.  This is a
 // hierarchical type system which includes both concrete and abstract types.
 //
-// The types form a lattice. Currently we only allow for one parent type, but
+// The types form a lattice.  Currently we only allow for one parent type, but
 // eventually we may allow for multiple predecessors.
 class
 jit_type
 {
 public:
   typedef llvm::Value *(*convert_fn) (llvm::IRBuilderD&, llvm::Value *);
 
   jit_type (const std::string& aname, jit_type *aparent, llvm::Type *allvm_type,
@@ -157,32 +157,32 @@ public:
   size_t depth (void) const { return mdepth; }
 
   bool skip_paren (void) const { return mskip_paren; }
 
   // -------------------- Calling Convention information --------------------
 
   // A function declared like: mytype foo (int arg0, int arg1);
   // Will be converted to: void foo (mytype *retval, int arg0, int arg1)
-  // if mytype is sret. The caller is responsible for allocating space for
+  // if mytype is sret.  The caller is responsible for allocating space for
   // retval. (on the stack)
   bool sret (jit_convention::type cc) const { return msret[cc]; }
 
   void mark_sret (jit_convention::type cc)
   { msret[cc] = true; }
 
   // A function like: void foo (mytype arg0)
   // Will be converted to: void foo (mytype *arg0)
   // Basically just pass by reference.
   bool pointer_arg (jit_convention::type cc) const { return mpointer_arg[cc]; }
 
   void mark_pointer_arg (jit_convention::type cc)
   { mpointer_arg[cc] = true; }
 
-  // Convert into an equivalent form before calling. For example, complex is
+  // Convert into an equivalent form before calling.  For example, complex is
   // represented as two values llvm vector, but we need to pass it as a two
   // valued llvm structure to C functions.
   convert_fn pack (jit_convention::type cc) { return mpack[cc]; }
 
   void set_pack (jit_convention::type cc, convert_fn fn) { mpack[cc] = fn; }
 
   // The inverse operation of pack.
   convert_fn unpack (jit_convention::type cc) { return munpack[cc]; }
@@ -227,24 +227,24 @@ jit_function
 public:
   // create a function in an invalid state
   jit_function ();
 
   jit_function (llvm::Module *amodule, jit_convention::type acall_conv,
                 const llvm::Twine& aname, jit_type *aresult,
                 const std::vector<jit_type *>& aargs);
 
-  // Use an existing function, but change the argument types. The new argument
+  // Use an existing function, but change the argument types.  The new argument
   // types must behave the same for the current calling convention.
   jit_function (const jit_function& fn, jit_type *aresult,
                 const std::vector<jit_type *>& aargs);
 
   jit_function (const jit_function& fn);
 
-  // erase the interal LLVM function (if it exists). Will become invalid.
+  // erase the interal LLVM function (if it exists).  Will become invalid.
   void erase (void);
 
   template <typename T>
   void add_mapping (llvm::ExecutionEngine *engine, T fn)
   {
     do_add_mapping (engine, reinterpret_cast<void *> (fn));
   }
 
diff --git a/libinterp/corefcn/jit-util.h b/libinterp/corefcn/jit-util.h
--- a/libinterp/corefcn/jit-util.h
+++ b/libinterp/corefcn/jit-util.h
@@ -98,18 +98,18 @@ private:
 
 // llvm doesn't provide this, and it's really useful for debugging
 std::ostream& operator<< (std::ostream& os, const llvm::Value& v);
 
 template <typename HOLDER_T, typename SUB_T>
 class jit_internal_node;
 
 // jit_internal_list and jit_internal_node implement generic embedded doubly
-// linked lists. List items extend from jit_internal_list, and can be placed
-// in nodes of type jit_internal_node. We use CRTP twice.
+// linked lists.  List items extend from jit_internal_list, and can be placed
+// in nodes of type jit_internal_node.  We use CRTP twice.
 template <typename LIST_T, typename NODE_T>
 class
 jit_internal_list
 {
   friend class jit_internal_node<LIST_T, NODE_T>;
 public:
   jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) { }
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -422,17 +422,17 @@ do_load (std::istream& stream, const std
                     {
                       if (count == 1)
                         output_buf
                           << "type               rows   cols   name\n"
                           << "====               ====   ====   ====\n";
 
                       output_buf
                         << std::setiosflags (std::ios::left)
-                        << std::setw (16) << tc.type_name () . c_str ()
+                        << std::setw (16) << tc.type_name ().c_str ()
                         << std::setiosflags (std::ios::right)
                         << std::setw (7) << tc.rows ()
                         << std::setw (7) << tc.columns ()
                         << "   " << name << "\n";
                     }
                   else
                     symbol_names.push_back (name);
                 }
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -93,17 +93,17 @@ get_sort_mode (const Array<T>& array,
   if (n > 1 && desc_comp (array (0), array (n-1)))
     return DESCENDING;
   else
     return ASCENDING;
 }
 
 // FIXME: perhaps there should be octave_value::lookup?
 // The question is, how should it behave w.r.t. the second argument's type.
-// We'd need a dispatch on two arguments. Hmmm...
+// We'd need a dispatch on two arguments.  Hmmm...
 
 #define INT_ARRAY_LOOKUP(TYPE) \
   (table.is_ ## TYPE ## _type () && y.is_ ## TYPE ## _type ()) \
     retval = do_numeric_lookup (table.TYPE ## _array_value (), \
                                 y.TYPE ## _array_value (), \
                                 left_inf, right_inf, \
                                 match_idx, match_bool);
 template <typename ArrayT>
@@ -141,29 +141,29 @@ do_numeric_lookup (const ArrayT& array, 
               octave_idx_type j = idx.xelem (i);
               ridx.xelem (i) = (j != 0 && values(i) == array(j-1)) ? j : 0;
             }
 
           retval = ridx;
         }
       else if (left_inf && right_inf)
         {
-          // Results in valid indices. Optimize using lazy index.
+          // Results in valid indices.  Optimize using lazy index.
           octave_idx_type zero = 0;
           for (octave_idx_type i = 0; i < nval; i++)
             {
               octave_idx_type j = idx.xelem (i) - 1;
               idx.xelem (i) = std::max (zero, std::min (j, n-2));
             }
 
           retval = idx_vector (idx);
         }
       else if (left_inf)
         {
-          // Results in valid indices. Optimize using lazy index.
+          // Results in valid indices.  Optimize using lazy index.
           octave_idx_type zero = 0;
           for (octave_idx_type i = 0; i < nval; i++)
             {
               octave_idx_type j = idx.xelem (i) - 1;
               idx.xelem (i) = std::max (zero, j);
             }
 
           retval = idx_vector (idx);
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -302,17 +302,17 @@ hdf5_get_scalar_attr (octave_hdf5_id loc
 #else
   err_disabled_feature ("hdf5_get_scalar_attr", "HDF5");
 #endif
 }
 
 // The following subroutines creates an HDF5 representations of the way
 // we will store Octave complex types (pairs of floating-point numbers).
 // NUM_TYPE is the HDF5 numeric type to use for storage (e.g.
-// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary
+// H5T_NATIVE_DOUBLE to save as 'double').  Note that any necessary
 // conversions are handled automatically by HDF5.
 
 octave_hdf5_id
 hdf5_make_complex_type (octave_hdf5_id num_type)
 {
 #if defined (HAVE_HDF5)
 
   hid_t type_id = H5Tcreate (H5T_COMPOUND, sizeof (double) * 2);
@@ -330,17 +330,17 @@ hdf5_make_complex_type (octave_hdf5_id n
 // This function is designed to be passed to H5Giterate, which calls it
 // on each data item in an HDF5 file.  For the item whose name is NAME in
 // the group GROUP_ID, this function sets dv->tc to an Octave representation
 // of that item.  (dv must be a pointer to hdf5_callback_data.)  (It also
 // sets the other fields of dv).
 //
 // It returns 1 on success (in which case H5Giterate stops and returns),
 // -1 on error, and 0 to tell H5Giterate to continue on to the next item
-// (e.g. if NAME was a data type we don't recognize).
+// (e.g., if NAME was a data type we don't recognize).
 
 octave_hdf5_err
 hdf5_read_next_data (octave_hdf5_id group_id, const char *name, void *dv)
 {
 #if defined (HAVE_HDF5)
 
   hdf5_callback_data *d = static_cast<hdf5_callback_data *> (dv);
   hid_t type_id = -1;
@@ -608,18 +608,18 @@ hdf5_read_next_data (octave_hdf5_id grou
               if (rank == 0)
                 d->tc = octave_value_typeinfo::lookup_type ("complex scalar");
               else
                 d->tc = octave_value_typeinfo::lookup_type ("complex matrix");
 
               H5Sclose (space_id);
             }
           else
-            // Assume that if its not complex its a range. If its not
-            // it'll be rejected later in the range code
+            // Assume that if its not complex its a range.
+            // If its not, it'll be rejected later in the range code.
             d->tc = octave_value_typeinfo::lookup_type ("range");
 
           H5Tclose (complex_type);
         }
       else
         {
           warning ("load: can't read '%s' (unknown datatype)", name);
           retval = 0; // unknown datatype; skip
@@ -843,17 +843,17 @@ hdf5_add_scalar_attr (octave_hdf5_id loc
 
   return retval;
 
 #else
   err_disabled_feature ("hdf5_add_scalar_attr", "HDF5");
 #endif
 }
 
-// Save an empty matrix, if needed. Returns
+// Save an empty matrix, if needed.  Returns
 //    > 0  Saved empty matrix
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
 save_hdf5_empty (octave_hdf5_id loc_id, const char *name, const dim_vector d)
 {
 #if defined (HAVE_HDF5)
 
@@ -899,17 +899,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
 
   return (retval == 0 ? 1 : retval);
 
 #else
   err_disabled_feature ("save_hdf5_empty", "HDF5");
 #endif
 }
 
-// Load an empty matrix, if needed. Returns
+// Load an empty matrix, if needed.  Returns
 //    > 0  loaded empty matrix, dimensions returned
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
 load_hdf5_empty (octave_hdf5_id loc_id, const char *name, dim_vector &d)
 {
 #if defined (HAVE_HDF5)
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -838,17 +838,17 @@ read_mat5_binary_element (std::istream& 
         octave_value tc2;
         std::string nm
           = read_mat5_binary_element (is, filename, swap, global, tc2);
 
         if (! is)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directory seperator
-        // and so can ignore the separator field of m0. I think the
+        // and so can ignore the separator field of m0.  I think the
         // sentinel field is also save to ignore.
         octave_scalar_map m0 = tc2.scalar_map_value ();
         octave_scalar_map m1
           = m0.contents ("function_handle").scalar_map_value ();
         std::string ftype = m1.contents ("type").string_value ();
         std::string fname = m1.contents ("function").string_value ();
         std::string fpath = m1.contents ("file").string_value ();
 
@@ -864,17 +864,17 @@ read_mat5_binary_element (std::istream& 
 
                 if ((fpath.length () >= mroot.length ())
                     && fpath.substr (0, mroot.length ()) == mroot
                     && OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal __octave_config_info__ ("exec_prefix")
                     // then the function points to a version of Octave
-                    // or Matlab other than the running version. In that
+                    // or Matlab other than the running version.  In that
                     // case we replace with the same function in the
                     // running version of Octave?
 
                     // First check if just replacing matlabroot is enough
                     std::string str = OCTAVE_EXEC_PREFIX +
                                       fpath.substr (mroot.length ());
                     octave::sys::file_stat fs (str);
 
@@ -1180,17 +1180,17 @@ read_mat5_binary_element (std::istream& 
               }
           }
 
         if (isclass)
           {
             if (classname == "inline")
               {
                 // inline is not an object in Octave but rather an
-                // overload of a function handle. Special case.
+                // overload of a function handle.  Special case.
                 tc =
                   new octave_fcn_inline (m.contents ("expr")(0).string_value (),
                                          m.contents ("args")(0).string_value ());
               }
             else
               {
                 octave_class* cls
                   = new octave_class (m, classname,
@@ -1416,17 +1416,17 @@ read_mat5_binary_element (std::istream& 
                       }
 
                     if (found_big_char)
                       warning ("load: can not read non-ASCII portions of UTF characters; replacing unreadable characters with '?'");
                   }
                 else if (type == miUTF8)
                   {
                     // Search for multi-byte encoded UTF8 characters and
-                    // replace with 0x3F for '?'... Give the user a warning
+                    // replace with 0x3F for '?'...  Give the user a warning
 
                     bool utf8_multi_byte = false;
                     for (octave_idx_type i = 0; i < n; i++)
                       {
                         unsigned char a = static_cast<unsigned char> (re(i));
                         if (a > 0x7f)
                           utf8_multi_byte = true;
                       }
@@ -1992,20 +1992,20 @@ save_mat5_array_length (const float* /* 
       //     else if (max_val < 4294967295UL && min_val > -1)
       //       size = 4;
       //     else if (max_val < 128 && min_val >= -128)
       //       size = 1;
       //     else if (max_val < 32768 && min_val >= -32768)
       //       size = 2;
       //     else if (max_val <= 2147483647L && min_val >= -2147483647L)
       //       size = 4;
-      //   }
-
-      // Round nel up to nearest even number of elements. Take into account
-      // Short tags for 4 byte elements.
+      //   
+
+      // Round nel up to nearest even number of elements.
+      // Take into account short tags for 4 byte elements.
       return PAD ((nel > 0 && nel * size <= 4 ? 4 : 8) + nel * size);
     }
   else
     return 8;
 }
 
 int
 save_mat5_array_length (const Complex* val, octave_idx_type nel,
@@ -2169,17 +2169,17 @@ save_mat5_element_length (const octave_v
       const octave_map m = tc.map_value ();
       octave_idx_type nel = m.numel ();
 
       if (tc.is_inline_function ())
         // length of "inline" is 6
         ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
       else if (tc.is_object ())
         {
-          size_t classlen = tc.class_name (). length ();
+          size_t classlen = tc.class_name ().length ();
 
           ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
         }
 
       for (octave_map::const_iterator i = m.begin (); i != m.end (); i++)
         fieldcnt++;
 
       ret += 16 + fieldcnt * (max_namelen + 1);
@@ -2289,25 +2289,25 @@ save_mat5_binary_element (std::ostream& 
 #if defined (HAVE_ZLIB)
 
   if (mat7_format && ! compressing)
     {
       bool ret = false;
 
       std::ostringstream buf;
 
-      // The code seeks backwards in the stream to fix the header. Can't
-      // do this with zlib, so use a stringstream.
+      // The code seeks backwards in the stream to fix the header.
+      // Can't do this with zlib, so use a stringstream.
       ret = save_mat5_binary_element (buf, tc, name, mark_as_global, true,
                                       save_as_floats, true);
 
       if (ret)
         {
           // destLen must be at least 0.1% larger than source buffer
-          // + 12 bytes. Reality is it must be larger again than that.
+          // + 12 bytes.  Reality is it must be larger again than that.
           std::string buf_str = buf.str ();
           uLongf srcLen = buf_str.length ();
           uLongf destLen = srcLen * 101 / 100 + 12;
           OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
           if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen,
                         reinterpret_cast<const Bytef *> (buf_str.c_str ()),
                                                          srcLen)
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -105,17 +105,17 @@ along with Octave; see the file COPYING.
 //
 //   object               type            bytes
 //   ------               ----            -----
 //   type_length          integer             4
 //
 //   type                 string    type_length
 //
 // The string "type" is then used with octave_value_typeinfo::lookup_type
-// to create an octave_value of the correct type. The specific load/save
+// to create an octave_value of the correct type.  The specific load/save
 // function is then called.
 //
 // For backward compatibility "data type" can also be a value between 1
 // and 7, where this defines a hardcoded octave_value of the type
 //
 //   data type                  octave_value
 //   ---------                  ------------
 //   1                          scalar
@@ -123,17 +123,17 @@ along with Octave; see the file COPYING.
 //   3                          complex scalar
 //   4                          complex matrix
 //   5                          string   (old style storage)
 //   6                          range
 //   7                          string
 //
 // Except for "data type" equal 5 that requires special treatment, these
 // old style "data type" value also cause the specific load/save functions
-// to be called. FILENAME is used for error messages.
+// to be called.  FILENAME is used for error messages.
 
 std::string
 read_binary_data (std::istream& is, bool swap,
                   octave::mach_info::float_format fmt,
                   const std::string& filename, bool& global,
                   octave_value& tc, std::string& doc)
 {
   std::string retval;
@@ -201,18 +201,18 @@ read_binary_data (std::istream& is, bool
 
     case 4:
       tc = octave_value_typeinfo::lookup_type ("complex matrix");
       break;
 
     case 5:
       {
         // FIXME:
-        // This is cruft, since its for a save type that is old. Maybe
-        // this is taking backward compatibility too far!!
+        // This is cruft, since its for a save type that is old.
+        // Maybe this is taking backward compatibility too far!
         int32_t len;
         if (! is.read (reinterpret_cast<char *> (&len), 4))
           error ("load: trouble reading binary file '%s'", filename.c_str ());
         if (swap)
           swap_bytes<4> (&len);
         OCTAVE_LOCAL_BUFFER (char, s, len+1);
         if (! is.read (reinterpret_cast<char *> (s), len))
           error ("load: trouble reading binary file '%s'", filename.c_str ());
@@ -289,16 +289,16 @@ save_binary_data (std::ostream& os, cons
 
   // Write the string corresponding to the octave_value type
   std::string typ = tc.type_name ();
   int32_t len = typ.length ();
   os.write (reinterpret_cast<char *> (&len), 4);
   const char *btmp = typ.data ();
   os.write (btmp, len);
 
-  // The octave_value of tc is const. Make a copy...
+  // The octave_value of tc is const.  Make a copy...
   octave_value val = tc;
 
   // Call specific save function
   bool success = val.save_binary (os, save_as_floats);
 
   return (os && success);
 }
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -186,18 +186,18 @@ extract_keyword (std::istream& is, const
 //         | <string info>
 //
 //  <matrix info> : # rows: <integer>
 //                : # columns: <integer>
 //
 //  <string info> : # elements: <integer>
 //                : # length: <integer> (once before each string)
 //
-//  For backward compatibility the type "string array" is treated as a
-// "string" type. Also "string" can have a single element with no elements
+// For backward compatibility the type "string array" is treated as a
+// "string" type.  Also "string" can have a single element with no elements
 // line such that
 //
 //  <string info> : # length: <integer>
 //
 // Formatted ASCII data follows the header.
 //
 // Example:
 //
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -2072,19 +2072,19 @@ public:
   {
     void *ptr = calloc_unmarked (n, t);
 
     mark (ptr);
 
     return ptr;
   }
 
-  // Reallocate a pointer obtained from malloc or calloc. If the
-  // pointer is NULL, allocate using malloc.  We don't need an
-  // "unmarked" version of this.
+  // Reallocate a pointer obtained from malloc or calloc.
+  // If the pointer is NULL, allocate using malloc.
+  // We don't need an "unmarked" version of this.
   void *realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
         v = gnulib::realloc (ptr, n);
 
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -456,17 +456,17 @@ octave_map::permute (const Array<int>& v
   octave_idx_type nf = nfields ();
 
   for (octave_idx_type i = 0; i < nf; i++)
     retval.xvals[i] = xvals[i].permute (vec, inv);
 
   // FIXME:
   // There is no dim_vector::permute for technical reasons.
   // We pick the dim vector from results if possible, otherwise use a dummy
-  // array to get it. Need (?) a better solution to this problem.
+  // array to get it.  Need (?) a better solution to this problem.
   if (nf > 0)
     retval.dimensions = retval.xvals[0].dims ();
   else
     {
       Array<char> dummy (dimensions);
       dummy = dummy.permute (vec, inv);
       retval.dimensions = dummy.dims ();
     }
@@ -824,17 +824,17 @@ octave_map::index (const idx_vector& i, 
 
   for (octave_idx_type k = 0; k < nf; k++)
     retval.xvals[k] = xvals[k].index (i, resize_ok);
 
   if (nf > 0)
     retval.dimensions = retval.xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy = dummy.index (i, resize_ok);
       retval.dimensions = dummy.dims ();
     }
 
   retval.optimize_dimensions ();
 
   return retval;
@@ -849,17 +849,17 @@ octave_map::index (const idx_vector& i, 
 
   for (octave_idx_type k = 0; k < nf; k++)
     retval.xvals[k] = xvals[k].index (i, j, resize_ok);
 
   if (nf > 0)
     retval.dimensions = retval.xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy = dummy.index (i, j, resize_ok);
       retval.dimensions = dummy.dims ();
     }
 
   retval.optimize_dimensions ();
 
   return retval;
@@ -873,17 +873,17 @@ octave_map::index (const Array<idx_vecto
 
   for (octave_idx_type k = 0; k < nf; k++)
     retval.xvals[k] = xvals[k].index (ia, resize_ok);
 
   if (nf > 0)
     retval.dimensions = retval.xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy = dummy.index (ia, resize_ok);
       retval.dimensions = dummy.dims ();
     }
 
   retval.optimize_dimensions ();
 
   return retval;
@@ -941,17 +941,17 @@ octave_map::index (const octave_value_li
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
 
-// Perhaps one day these will be optimized. Right now, they just call index.
+// Perhaps one day these will be optimized.  Right now, they just call index.
 octave_map
 octave_map::column (octave_idx_type k) const
 {
   return index (idx_vector::colon, k);
 }
 
 octave_map
 octave_map::page (octave_idx_type k) const
@@ -971,17 +971,17 @@ octave_map::assign (const idx_vector& i,
 
       for (octave_idx_type k = 0; k < nf; k++)
         xvals[k].assign (i, rhs.xvals[k], Matrix ());
 
       if (nf > 0)
         dimensions = xvals[0].dims ();
       else
         {
-          // Use dummy array. FIXME: Need(?) a better solution.
+          // Use dummy array.  FIXME: Need(?) a better solution.
           Array<char> dummy (dimensions), rhs_dummy (rhs.dimensions);
           dummy.assign (i, rhs_dummy);;
           dimensions = dummy.dims ();
         }
 
       optimize_dimensions ();
     }
   else if (nfields () == 0)
@@ -1019,17 +1019,17 @@ octave_map::assign (const idx_vector& i,
 
       for (octave_idx_type k = 0; k < nf; k++)
         xvals[k].assign (i, j, rhs.xvals[k], Matrix ());
 
       if (nf > 0)
         dimensions = xvals[0].dims ();
       else
         {
-          // Use dummy array. FIXME: Need(?) a better solution.
+          // Use dummy array.  FIXME: Need(?) a better solution.
           Array<char> dummy (dimensions), rhs_dummy (rhs.dimensions);
           dummy.assign (i, j, rhs_dummy);;
           dimensions = dummy.dims ();
         }
 
       optimize_dimensions ();
     }
   else if (nfields () == 0)
@@ -1067,17 +1067,17 @@ octave_map::assign (const Array<idx_vect
 
       for (octave_idx_type k = 0; k < nf; k++)
         xvals[k].assign (ia, rhs.xvals[k], Matrix ());
 
       if (nf > 0)
         dimensions = xvals[0].dims ();
       else
         {
-          // Use dummy array. FIXME: Need(?) a better solution.
+          // Use dummy array.  FIXME: Need(?) a better solution.
           Array<char> dummy (dimensions), rhs_dummy (rhs.dimensions);
           dummy.assign (ia, rhs_dummy);;
           dimensions = dummy.dims ();
         }
 
       optimize_dimensions ();
     }
   else if (nfields () == 0)
@@ -1203,17 +1203,17 @@ octave_map::delete_elements (const idx_v
   octave_idx_type nf = nfields ();
   for (octave_idx_type k = 0; k < nf; k++)
     xvals[k].delete_elements (i);
 
   if (nf > 0)
     dimensions = xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy.delete_elements (i);
       dimensions = dummy.dims ();
     }
 
   optimize_dimensions ();
 }
 
@@ -1223,17 +1223,17 @@ octave_map::delete_elements (int dim, co
   octave_idx_type nf = nfields ();
   for (octave_idx_type k = 0; k < nf; k++)
     xvals[k].delete_elements (dim, i);
 
   if (nf > 0)
     dimensions = xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy.delete_elements (dim, i);
       dimensions = dummy.dims ();
     }
 
   optimize_dimensions ();
 }
 
@@ -1243,17 +1243,17 @@ octave_map::delete_elements (const Array
   octave_idx_type nf = nfields ();
   for (octave_idx_type k = 0; k < nf; k++)
     xvals[k].delete_elements (ia);
 
   if (nf > 0)
     dimensions = xvals[0].dims ();
   else
     {
-      // Use dummy array. FIXME: Need(?) a better solution.
+      // Use dummy array.  FIXME: Need(?) a better solution.
       Array<char> dummy (dimensions);
       dummy.delete_elements (ia);
       dimensions = dummy.dims ();
     }
 
   optimize_dimensions ();
 }
 
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 #include <map>
 
 #include "Cell.h"
 #include "ovl.h"
 
 class string_vector;
 
-// A class holding a map field->index. Supports reference-counting.
+// A class holding a map field->index.  Supports reference-counting.
 class OCTINTERP_API
 octave_fields
 {
   class fields_rep : public std::map<std::string, octave_idx_type>
   {
   public:
     fields_rep (void) : std::map<std::string, octave_idx_type> (), count (1) { }
     fields_rep (const fields_rep& other)
@@ -110,25 +110,25 @@ public:
   // high-level methods.
 
   // number of fields.
   octave_idx_type nfields (void) const { return rep->size (); }
 
   // check whether a field exists.
   bool isfield (const std::string& name) const;
 
-  // get index of field. return -1 if not exist
+  // get index of field.  return -1 if not exist
   octave_idx_type getfield (const std::string& name) const;
-  // get index of field. add if not exist
+  // get index of field.  add if not exist
   octave_idx_type getfield (const std::string& name);
   // remove field and return the index. -1 if didn't exist.
   octave_idx_type rmfield (const std::string& name);
 
-  // order the fields of this map. creates a permutation
-  // used to order the fields.
+  // order the fields of this map.
+  // creates a permutation used to order the fields.
   void orderfields (Array<octave_idx_type>& perm);
 
   // compares two instances for equality up to order of fields.
   // returns a permutation needed to bring the fields of *other*
   // into the order of *this*.
   bool equal_up_to_order (const octave_fields& other,
                           octave_idx_type* perm) const;
 
@@ -167,18 +167,19 @@ public:
   octave_scalar_map& operator = (const octave_scalar_map& m)
   {
     xkeys = m.xkeys;
     xvals = m.xvals;
 
     return *this;
   }
 
-  // iteration support. note that both const and non-const iterators are the
-  // same. The const/non-const distinction is made by the key & contents method.
+  // iteration support.
+  // note that both const and non-const iterators are the same.
+  // The const/non-const distinction is made by the key & contents method.
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
@@ -210,25 +211,25 @@ public:
   { return isfield (name); }
 
   string_vector fieldnames (void) const
   { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
   { return fieldnames (); }
 
-  // get contents of a given field. empty value if not exist.
+  // get contents of a given field.  empty value if not exist.
   octave_value getfield (const std::string& key) const;
 
-  // set contents of a given field. add if not exist.
+  // set contents of a given field.  add if not exist.
   void setfield (const std::string& key, const octave_value& val);
   void assign (const std::string& k, const octave_value& val)
   { setfield (k, val); }
 
-  // remove a given field. do nothing if not exist.
+  // remove a given field.  do nothing if not exist.
   void rmfield (const std::string& key);
   void del (const std::string& k) { rmfield (k); }
 
   // return a copy with fields ordered, optionally along with permutation.
   octave_scalar_map orderfields (void) const;
   octave_scalar_map orderfields (Array<octave_idx_type>& perm) const;
   octave_scalar_map orderfields (const octave_scalar_map& other,
                                  Array<octave_idx_type>& perm) const;
@@ -289,18 +290,19 @@ public:
   {
     xkeys = m.xkeys;
     xvals = m.xvals;
     dimensions = m.dimensions;
 
     return *this;
   }
 
-  // iteration support. note that both const and non-const iterators are the
-  // same. The const/non-const distinction is made by the key & contents method.
+  // iteration support.
+  // note that both const and non-const iterators are the same.
+  // The const/non-const distinction is made by the key & contents method.
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
@@ -332,20 +334,20 @@ public:
   { return isfield (name); }
 
   string_vector fieldnames (void) const
   { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
   { return fieldnames (); }
 
-  // get contents of a given field. empty value if not exist.
+  // get contents of a given field.  empty value if not exist.
   Cell getfield (const std::string& key) const;
 
-  // set contents of a given field. add if not exist. checks for
+  // set contents of a given field.  add if not exist.  checks for
   // correct dimensions.
   void setfield (const std::string& key, const Cell& val);
   void assign (const std::string& k, const Cell& val)
   { setfield (k, val); }
 
   // remove a given field. do nothing if not exist.
   void rmfield (const std::string& key);
   void del (const std::string& k) { rmfield (k); }
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -1258,17 +1258,17 @@ public:
 
   void clear (std::ios_base::iostate m
               = (std::ios_base::eofbit & ~std::ios_base::eofbit))
   {
     flags = flags & m;
   }
 
   // Report if any characters have been consumed.
-  // (get, read etc. not cancelled by putback or seekg)
+  // (get, read, etc. not cancelled by putback or seekg)
 
   void progress_benchmark (void) { progress_marker = idx; }
 
   bool no_progress (void) { return progress_marker == idx; }
 
 private:
 
   // Number of characters to read from the file at once.
@@ -4220,17 +4220,17 @@ octave_scan_1 (std::istream& is, const s
       break;
 
     default:
       is >> value;
       break;
     }
 
   // If conversion produces an integer that overflows, failbit is set but
-  // value is non-zero. We want to treat this case as success, so clear
+  // value is non-zero.  We want to treat this case as success, so clear
   // failbit from the stream state to keep going.
   // FIXME: Maybe set error state on octave stream as above? Matlab does
   // *not* indicate an error message on overflow.
   if ((is.rdstate () & std::ios::failbit) && value != T ())
     is.clear (is.rdstate () & ~std::ios::failbit);
 
   // Only copy the converted value if the stream is in a state where we
   // want to continue reading.
@@ -4259,17 +4259,17 @@ octave_scan (std::istream& is, const sca
     }
   else
     octave_scan_1 (is, fmt, valptr);
 
   return is;
 }
 
 // Note that this specialization is only used for reading characters, not
-// character strings. See BEGIN_S_CONVERSION for details.
+// character strings.  See BEGIN_S_CONVERSION for details.
 
 template <>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
                char* valptr)
 {
   return is >> valptr;
 }
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -1977,17 +1977,17 @@ octave_print_internal (std::ostream& os,
           octave_preserve_stream_state stream_state (os);
 
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
 
           pr_scale_header (os, scale);
 
-          // kluge. Get the true width of a number.
+          // kluge.  Get the true width of a number.
           int zero_fw;
 
           {
             std::ostringstream tmp_oss;
             pr_float (tmp_oss, 0.0, fw, scale);
             zero_fw = tmp_oss.str ().length ();
           }
 
@@ -2397,17 +2397,17 @@ octave_print_internal (std::ostream& os,
           octave_preserve_stream_state stream_state (os);
 
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
 
           pr_scale_header (os, scale);
 
-          // kluge. Get the true width of a number.
+          // kluge.  Get the true width of a number.
           int zero_fw;
 
           {
             std::ostringstream tmp_oss;
             pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
             zero_fw = tmp_oss.str ().length ();
           }
 
@@ -2881,17 +2881,17 @@ octave_print_internal (std::ostream& os,
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
                        bool pr_as_read_syntax, int /* extra_indent */)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
-  // function. Can fix this with std::is_same from C++11.
+  // function.  Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.numel () == 1)
     {
       os << nda(0);
     }
   else
@@ -3150,17 +3150,17 @@ PRINT_INT_SCALAR_INTERNAL (int64_t)
 PRINT_INT_SCALAR_INTERNAL (uint64_t)
 
 template <typename T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
-  // function. Can fix this with std::is_same from C++11.
+  // function.  Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.numel () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       int ndims = nda.ndims ();
@@ -3924,17 +3924,17 @@ ans =\n\
   9.0032e+07\n\
   8.1058e+15\n\
 @end group\n\
 @end example\n\
 \n\
 @item  short eng\n\
 @itemx long eng\n\
 Identical to @samp{short e} or @samp{long e} but displays the value\n\
-using an engineering format, where the exponent is divisible by 3. For\n\
+using an engineering format, where the exponent is divisible by 3.  For\n\
 example, with the @samp{short eng} format, @code{10 * pi} is displayed as\n\
 @code{31.4159e+00}.\n\
 \n\
 @item  long G\n\
 @itemx short G\n\
 Identical to @samp{short g} or @samp{long g} but displays an uppercase\n\
 @samp{E} to indicate the exponent.\n\
 \n\
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -100,17 +100,18 @@ static int Vjit_failcnt = 0;
 
 static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
 // -------------------- jit_break_exception --------------------
 
 // jit_break is thrown whenever a branch we are converting has only breaks or
-// continues. This is because all code that follows a break or continue is dead.
+// continues.  This is because all code that follows a break or continue
+// is dead.
 class jit_break_exception : public std::exception {};
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree &tee, jit_type *for_bounds)
   : converting_function (false)
 {
   initialize (symbol_table::current_scope ());
 
@@ -372,17 +373,17 @@ jit_convert::visit_decl_init_list (tree_
   throw jit_fail_exception ("No visit_decl_init_list implementation");
 }
 
 void
 jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   // Note we do an initial check to see if the loop will run atleast once.
   // This allows us to get better type inference bounds on variables defined
-  // and used only inside the for loop (e.g. the index variable)
+  // and used only inside the for loop (e.g., the index variable)
 
   // If we are a nested for loop we need to store the previous breaks
   octave::unwind_protect frame;
   frame.protect_var (breaks);
   frame.protect_var (continues);
   breaks.clear ();
   continues.clear ();
 
@@ -545,22 +546,22 @@ jit_convert::visit_if_command (tree_if_c
 
 void
 jit_convert::visit_if_command_list (tree_if_command_list& lst)
 {
   tree_if_clause *last = lst.back ();
   size_t last_else = static_cast<size_t> (last->is_else_clause ());
 
   // entry_blocks represents the block you need to enter in order to execute
-  // the condition check for the ith clause. For the else, it is simple the
-  // else body. If there is no else body, then it is padded with the tail
+  // the condition check for the ith clause.  For the else, it is simple the
+  // else body.  If there is no else body, then it is padded with the tail.
   std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
   entry_blocks[0] = block;
 
-  // we need to construct blocks first, because they have jumps to eachother
+  // we need to construct blocks first, because they have jumps to each other.
   tree_if_command_list::iterator iter = lst.begin ();
   ++iter;
   for (size_t i = 1; iter != lst.end (); ++iter, ++i)
     {
       tree_if_clause *tic = *iter;
       if (tic->is_else_clause ())
         entry_blocks[i] = factory.create<jit_block> ("else");
       else
@@ -753,18 +754,18 @@ void
 jit_convert::visit_simple_assignment (tree_simple_assignment& tsa)
 {
   tree_expression *rhs = tsa.right_hand_side ();
   jit_value *rhsv = visit (rhs);
   octave_value::assign_op op = tsa.op_type ();
 
   if (op != octave_value::op_asn_eq)
     {
-      // do the equivlent binary operation, then assign. This is always correct,
-      // but isn't always optimal.
+      // Do the equivalent binary operation, then assign.
+      // This is always correct, but it isn't always optimal.
       tree_expression *lhs = tsa.left_hand_side ();
       jit_value *lhsv = visit (lhs);
       octave_value::binary_op bop = octave_value::assign_op_to_binary_op (op);
       const jit_operation& fn = jit_typeinfo::binary_op (bop);
       rhsv = create_checked (fn, lhsv, rhsv);
     }
 
   result = do_assign (tsa.left_hand_side (), rhsv);
@@ -852,17 +853,17 @@ jit_convert::visit_switch_command (tree_
   // check for otherwise, it's interpreted as last 'else' condition
   size_t has_otherwise = 0;
   tree_switch_case *last = lst->back ();
   if (last->is_default_case ())
     has_otherwise = 1;
 
   std::vector<jit_block *> entry_blocks (case_blocks_num + 1 - has_otherwise);
 
-  // the first entry point is always the actual block. afterward new blocks
+  // the first entry point is always the actual block.  Afterward, new blocks
   // are created for every case and the otherwise branch
   entry_blocks[0] = block;
   for (size_t i = 1; i < case_blocks_num; ++i)
     entry_blocks[i] = factory.create<jit_block> ("case_cond");
 
   jit_block *tail = factory.create<jit_block> ("switch_tail");
 
   // if there's no otherwise branch, the the 'else' of the last branch
@@ -2153,19 +2154,19 @@ tree_jit::do_execute (octave_user_functi
     }
 
   return info->execute (args, retval);
 }
 
 bool
 tree_jit::enabled (void)
 {
-  // Ideally, we should only disable JIT if there is a breakpoint in the code we
-  // are about to run. However, we can't figure this out in O(1) time, so we
-  // conservatively check for the existence of any breakpoints.
+  // Ideally, we should only disable JIT if there is a breakpoint in the code
+  // we are about to run. However, we can't figure this out in O(1) time, so
+  // we conservatively check for the existence of any breakpoints.
   return Vjit_enable && ! bp_table::have_breakpoints ()
          && ! Vdebug_on_interrupt && ! Vdebug_on_error;
 }
 
 size_t
 tree_jit::trip_count (const octave_value& bounds) const
 {
   if (bounds.is_range ())
diff --git a/libinterp/corefcn/pt-jit.h b/libinterp/corefcn/pt-jit.h
--- a/libinterp/corefcn/pt-jit.h
+++ b/libinterp/corefcn/pt-jit.h
@@ -193,31 +193,31 @@ private:
   size_t short_count;
 
   variable_map vmap;
 
   void initialize (symbol_table::scope_id s);
 
   jit_call *create_checked_impl (jit_call *ret);
 
-  // get an existing vairable. If the variable does not exist, it will not be
+  // get an existing vairable.  If the variable does not exist, it will not be
   // created
   jit_variable *find_variable (const std::string& vname) const;
 
-  // get a variable, create it if it does not exist. The type will default to
+  // get a variable, create it if it does not exist.  The type will default to
   // the variable's current type in the symbol table.
   jit_variable *get_variable (const std::string& vname);
 
-  // create a variable of the given name and given type. Will also insert an
+  // create a variable of the given name and given type.  Will also insert an
   // extract statement
   jit_variable *create_variable (const std::string& vname, jit_type *type,
                                  bool isarg = true);
 
-  // The name of the next for loop iterator. If inc is false, then the iterator
-  // counter will not be incremented.
+  // The name of the next for loop iterator.  If inc is false, then the
+  // iterator counter will not be incremented.
   std::string next_iterator (bool inc = true)
   { return next_name ("#iter", iterator_count, inc); }
 
   std::string next_for_bounds (bool inc = true)
   { return next_name ("#for_bounds", for_bounds_count, inc); }
 
   std::string next_shortcircut_result (bool inc = true)
   { return next_name ("#shortcircut_result", short_count, inc); }
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1391,17 +1391,17 @@ static const double Tright[33 * 33] =
   0., 0., 0., 0., 0., 0., 0., 0., .46566128730773925781e-9,
   .14899342093408253335e-7, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
   0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
   0., 0., .23283064365386962891e-9
 };
 
 // Allocates a workspace for the given maximum number of intervals.
 // Note that if the workspace gets filled, the intervals with the lowest
-// error estimates are dropped. The maximum number of intervals is
+// error estimates are dropped.  The maximum number of intervals is
 // therefore not the maximum number of intervals that will be computed,
 // but merely the size of the buffer.
 
 // Compute the product of the fx with one of the inverse
 // Vandermonde-like matrices.
 
 void
 Vinvfx (const double *fx, double *c, const int d)
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -438,17 +438,17 @@ compatibility with @sc{matlab}.\n\
 #endif
         }
     }
 
 #if defined (DEBUG)
   std::cout << "qz: check argument 1" << std::endl;
 #endif
 
-  // Argument 1: check if it's o.k. dimensioned.
+  // Argument 1: check if it's okay dimensioned.
   octave_idx_type nn = args(0).rows ();
 
 #if defined (DEBUG)
   std::cout << "argument 1 dimensions: ("
             << nn << "," << args(0).columns () << ")"
             << std::endl;
 #endif
 
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -47,29 +47,29 @@ static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
 }
 
 
-// Safer pow functions. Only two make sense for sparse matrices, the
+// Safer pow functions.  Only two make sense for sparse matrices, the
 // others should all promote to full matrices.
 
 octave_value
 xpow (const SparseMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+    error ("for A^b, A must be a square matrix.  Use .^ for elementwise power.");
 
   if (static_cast<int> (b) != b)
     error ("use full(a) ^ full(b)");
 
   int btmp = static_cast<int> (b);
   if (btmp == 0)
     {
       SparseMatrix tmp = SparseMatrix (nr, nr, nr);
@@ -128,17 +128,17 @@ octave_value
 xpow (const SparseComplexMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+    error ("for A^b, A must be a square matrix.  Use .^ for elementwise power.");
 
   if (static_cast<int> (b) != b)
     error ("use full(a) ^ full(b)");
 
   int btmp = static_cast<int> (b);
   if (btmp == 0)
     {
       SparseMatrix tmp = SparseMatrix (nr, nr, nr);
@@ -314,17 +314,17 @@ elem_xpow (double a, const SparseComplex
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, double b)
 {
   // FIXME: What should a .^ 0 give?  Matlab gives a
   // sparse matrix with same structure as a, which is strictly
-  // incorrect. Keep compatibility.
+  // incorrect.  Keep compatibility.
 
   octave_value retval;
 
   octave_idx_type nz = a.nnz ();
 
   if (b <= 0.0)
     {
       octave_idx_type nr = a.rows ();
@@ -434,19 +434,19 @@ elem_xpow (const SparseMatrix& a, const 
                 goto done;
               }
           }
       }
 
 done:
 
   // This is a dumb operator for sparse matrices anyway, and there is
-  // no sensible way to handle the 0.^0 versus the 0.^x cases. Therefore
+  // no sensible way to handle the 0.^0 versus the 0.^x cases.  Therefore
   // allocate a full matrix filled for the 0.^0 case and shrink it later
-  // as needed
+  // as needed.
 
   if (convert_to_complex)
     {
       SparseComplexMatrix complex_result (nr, nc, Complex (1.0, 0.0));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -302,17 +302,17 @@ qs_replace (const Array<char>& str, cons
 
       if (nidx)
         {
           // Compute result size.
           octave_idx_type retsiz;
           if (overlaps)
             {
               retsiz = 0;
-              // OMG. Is this the "right answer" MW always looks for, or
+              // OMG.  Is this the "right answer" MW always looks for, or
               // someone was just lazy?
               octave_idx_type k = 0;
               for (octave_idx_type i = 0; i < nidx; i++)
                 {
                   octave_idx_type j = idx(i);
                   if (j >= k)
                     retsiz += j - k;
                   retsiz += rsiz;
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -599,28 +599,28 @@ This is just the opposite of the corresp
 %!assert (strcmp (y, {"foo"}), [false; false])
 %!assert (strcmp ("foobar", "foobar"), true)
 %!assert (strcmp ("fooba", "foobar"), false)
 
 %!error strcmp ()
 %!error strcmp ("foo", "bar", 3)
 */
 
-// Apparently, Matlab ignores the dims with strncmp. It also
+// Apparently, Matlab ignores the dims with strncmp.
 static bool
 strncmp_array_op (const charNDArray& s1, const charNDArray& s2,
                   octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel ();
   octave_idx_type l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
-// Otherwise, just use strings. Note that we neither extract substrings (which
+// Otherwise, just use strings.  Note that we neither extract substrings (which
 // would mean a copy, at least in GCC), nor use string::compare (which is a
 // 3-way compare).
 static bool
 strncmp_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.length ();
   octave_idx_type l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -86,19 +86,19 @@ symbol_table::scope_id_cache::create_ins
 }
 
 symbol_table::context_id
 symbol_table::symbol_record::symbol_record_rep::active_context (void) const
 {
   octave_user_function *fcn = curr_fcn;
 
   // FIXME: If active_context () == -1, then it does not make much
-  // sense to use this symbol_record. This means an attempt at accessing
+  // sense to use this symbol_record.  This means an attempt at accessing
   // a variable from a function that has not been called yet is
-  // happening. This should be cleared up when an implementing closures.
+  // happening.  This should be cleared up when an implementing closures.
 
   return fcn && fcn->active_context () != static_cast<context_id> (-1)
          ? fcn->active_context () : xcurrent_context;
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
@@ -439,17 +439,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
 
           class_constructors[name] = retval;
           class_methods[name] = retval;
         }
     }
   else
     {
       // Classdef constructors can be defined anywhere in the path, not
-      // necessarily in @-folders. Look for a normal function and load it.
+      // necessarily in @-folders.  Look for a normal function and load it.
       // If the loaded function is a classdef constructor, store it as such
       // and restore function_on_path to its previous value.
 
       octave_value old_function_on_path = function_on_path;
 
       octave_value maybe_cdef_ctor = find_user_function ();
 
       if (maybe_cdef_ctor.is_defined ())
@@ -581,18 +581,18 @@ symbol_table::fcn_info::fcn_info_rep::he
            p != dispatch_map.end (); p++)
         retval += "  " + p->second + " (" + p->first + ", ...)\n\n";
     }
 
   return retval;
 }
 
 // :-) JWE, can you parse this? Returns a 2D array with second dimension equal
-// to btyp_num_types (static constant). Only the leftmost dimension can be
-// variable in C/C++. Typedefs are boring.
+// to btyp_num_types (static constant).  Only the leftmost dimension can be
+// variable in C/C++.  Typedefs are boring.
 
 static builtin_type_t (*build_sup_table (void))[btyp_num_types]
 {
   static builtin_type_t sup_table[btyp_num_types][btyp_num_types];
   for (int i = 0; i < btyp_num_types; i++)
     for (int j = 0; j < btyp_num_types; j++)
       {
         builtin_type_t ityp = static_cast<builtin_type_t> (i);
@@ -1628,17 +1628,17 @@ void symbol_table::cleanup (void)
   // Delete all possibly remaining scopes.
   for (all_instances_iterator iter = all_instances.begin ();
        iter != all_instances.end (); iter++)
     {
       // First zero the table entry to avoid possible duplicate delete.
       symbol_table *inst = iter->second;
       iter->second = 0;
 
-      // Now delete the scope. Note that there may be side effects, such as
+      // Now delete the scope.  Note that there may be side effects, such as
       // deleting other scopes.
       delete inst;
     }
 
   global_table.clear ();
   fcn_table.clear ();
   class_precedence_table.clear ();
   parent_map.clear ();
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -1776,17 +1776,17 @@ public:
 
         finfo.clear_user_function ();
       }
     // FIXME: is this necessary, or even useful?
     // else
     //   error ("clear: no such function '%s'", name.c_str ());
   }
 
-  // This clears oct and mex files, incl. autoloads.
+  // This clears oct and mex files, including autoloads.
   static void clear_dld_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
@@ -2287,17 +2287,17 @@ public:
 
   static void set_curr_fcn (octave_user_function *curr_fcn,
                             scope_id scope = xcurrent_scope)
   {
     assert (scope != xtop_scope && scope != xglobal_scope);
     symbol_table *inst = get_instance (scope);
     // FIXME: normally, functions should not usurp each other's scope.
     // If for any incredible reason this is needed, call
-    // set_user_function (0, scope) first. This may cause problems with
+    // set_user_function (0, scope) first.  This may cause problems with
     // nested functions, as the curr_fcn of symbol_records must be updated.
     assert (inst->curr_fcn == 0 || curr_fcn == 0);
     inst->curr_fcn = curr_fcn;
   }
 
   static void cleanup (void);
 
 private:
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -467,17 +467,17 @@ Year (1970-).\n\
 
 DEFUN (strptime, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
-position of last matched character plus 1. Always check for this unless\n\
+position of last matched character plus 1.  Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   std::string str = args(0).xstring_value ("strptime: argument STR must be a string");
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -50,17 +50,17 @@ template <typename ArrayType>
 static void
 get_data_and_bytesize (const ArrayType& array,
                        const void *& data,
                        octave_idx_type& byte_size,
                        dim_vector& old_dims,
                        octave::unwind_protect& frame)
 {
   // The array given may be a temporary, constructed from a scalar or sparse
-  // array. This will ensure the data will be deallocated after we exit.
+  // array.  This will ensure the data will be deallocated after we exit.
   frame.add_delete (new ArrayType (array));
 
   data = reinterpret_cast<const void *> (array.data ());
   byte_size = array.byte_size ();
 
   old_dims = array.dims ();
 }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1086,17 +1086,17 @@ print_descriptor (std::ostream& os, std:
           if (param.command == 's' && param.modifier == 'c')
             {
               int a, b;
 
               if (param.modifier == 'c')
                 {
                   a = param.first_parameter_length - param.balance;
                   a = (a < 0 ? 0 : a);
-                  b = param.parameter_length - a - param.text . length ();
+                  b = param.parameter_length - a - param.text.length ();
                   b = (b < 0 ? 0 : b);
                   os << std::setiosflags (std::ios::left) << std::setw (a)
                      << "" << std::resetiosflags (std::ios::left) << param.text
                      << std::setiosflags (std::ios::left)
                      << std::setw (b) << ""
                      << std::resetiosflags (std::ios::left);
                   param_buf << std::setiosflags (std::ios::left)
                             << std::setw (a)
@@ -1551,17 +1551,17 @@ public:
             if (param.command == 's' && param.modifier == 'c' && b > 0)
               param.first_parameter_length = b;
 
             if (param.command == 's')
               {
                 // Have to calculate space needed for printing
                 // matrix dimensions Space needed for Size column is
                 // hard to determine in prior, because it depends on
-                // dimensions to be shown. That is why it is
+                // dimensions to be shown.  That is why it is
                 // recalculated for each Size-command int first,
                 // rest = 0, total;
                 int rest = 0;
                 int first = param.first_parameter_length;
                 int total = param.parameter_length;
 
                 for (std::list<symbol_info>::const_iterator p = lst.begin ();
                      p != lst.end (); p++)
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -59,17 +59,17 @@ static void
 err_failed_diagonalization (void)
 {
   error ("Failed to diagonalize matrix while calculating matrix exponential");
 }
 
 static void
 err_nonsquare_matrix (void)
 {
-  error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
+  error ("for x^A, A must be a square matrix.  Use .^ for elementwise power.");
 }
 
 static inline int
 xisint (double x)
 {
   return (D_NINT (x) == x
           && ((x >= 0 && x < std::numeric_limits<int>::max ())
               || (x <= 0 && x > std::numeric_limits<int>::min ())));
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -59,17 +59,17 @@ gzfilebuf::gzfilebuf ()
   // No buffers to start with
   this->disable_buffer ();
 }
 
 // Destructor
 gzfilebuf::~gzfilebuf ()
 {
   // Sync output buffer and close only if responsible for file
-  // (i.e. attached streams should be left open at this stage)
+  // (i.e., attached streams should be left open at this stage)
   this->sync ();
   if (own_fd)
     this->close ();
   // Make sure internal buffer is deallocated
   this->disable_buffer ();
 }
 
 // Set compression level and strategy
@@ -205,19 +205,19 @@ gzfilebuf::showmanyc ()
     return -1;
   // Make sure get area is in use
   if (this->gptr () && (this->gptr () < this->egptr ()))
     return std::streamsize (this->egptr () - this->gptr ());
   else
     return 0;
 }
 
-// Puts back a character to the stream in two cases. Firstly, when there
+// Puts back a character to the stream in two cases.  Firstly, when there
 // is no putback position available, and secondly when the character putback
-// differs from the one in the file. We can only support the first case
+// differs from the one in the file.  We can only support the first case
 // with gzipped files.
 gzfilebuf::int_type
 gzfilebuf::pbackfail (gzfilebuf::int_type c)
 {
   if (this->is_open ())
     {
       if (gzseek (file, this->gptr () - this->egptr () - 1, SEEK_CUR) < 0)
         return traits_type::eof ();
@@ -374,17 +374,17 @@ gzfilebuf::setbuf (char_type* p, std::st
       buffer = p;
       buffer_size = n;
       own_buffer = false;
       this->enable_buffer ();
     }
   return this;
 }
 
-// Write put area to gzipped file (i.e. ensures that put area is empty)
+// Write put area to gzipped file (i.e., ensures that put area is empty)
 int
 gzfilebuf::sync ()
 {
   return traits_type::eq_int_type (this->overflow (),
                                    traits_type::eof ()) ? -1 : 0;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -39,19 +39,19 @@ along with Octave; see the file COPYING.
 
 #include <iosfwd>
 
 #include "zlib.h"
 
 /**
  *  @brief  Gzipped file stream buffer class.
  *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet
+ *  This class implements basic_filebuf for gzipped files.  It doesn't yet
  *  support seeking (allowed by zlib but slow/limited), putback and read/write
- *  access *  (tricky). Otherwise, it attempts to be a drop-in replacement for
+ *  access *  (tricky).  Otherwise, it attempts to be a drop-in replacement for
  *  the standard file streambuf.
 */
 class gzfilebuf : public std::streambuf
 {
 public:
   //  Default constructor.
   gzfilebuf ();
 
@@ -61,17 +61,17 @@ public:
 
   /**
    *  @brief  Set compression level and strategy on the fly.
    *  @param  comp_level  Compression level (see zlib.h for allowed values)
    *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
    *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
    *
    *  Unfortunately, these parameters cannot be modified separately, as the
-   *  previous zfstream version assumed. Since the strategy is seldom changed,
+   *  previous zfstream version assumed.  Since the strategy is seldom changed,
    *  it can default and setcompression(level) then becomes like the old
    *  setcompressionlevel(level).
   */
   int
   setcompression (int comp_level,
                   int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
@@ -127,28 +127,28 @@ protected:
   virtual std::streamsize
   showmanyc ();
 
   /**
    *  @brief  Fill get area from gzipped file.
    *  @return  First character in get area on success, EOF on error.
    *
    *  This actually reads characters from gzipped file to stream
-   *  buffer. Always buffered.
+   *  buffer.  Always buffered.
   */
   virtual int_type
   underflow ();
 
   /**
    *  @brief  Write put area to gzipped file.
    *  @param  c  Extra character to add to buffer contents.
    *  @return  Non-EOF on success, EOF on error.
    *
    *  This actually writes characters in stream buffer to
-   *  gzipped file. With unbuffered output this is done one
+   *  gzipped file.  With unbuffered output this is done one
    *  character at a time.
   */
   virtual int_type
   overflow (int_type c = traits_type::eof ());
 
   /**
    *  @brief  Installs external stream buffer.
    *  @param  p  Pointer to char buffer.
@@ -204,29 +204,29 @@ private:
 
   gzfilebuf (const gzfilebuf&);
 
   gzfilebuf& operator = (const gzfilebuf&);
 
   /**
    *  @brief  Allocate internal buffer.
    *
-   *  This function is safe to call multiple times. It will ensure
-   *  that a proper internal buffer exists if it is required. If the
+   *  This function is safe to call multiple times.  It will ensure
+   *  that a proper internal buffer exists if it is required.  If the
    *  buffer already exists or is external, the buffer pointers will be
    *  reset to their original state.
   */
   void
   enable_buffer ();
 
   /**
    *  @brief  Destroy internal buffer.
    *
-   *  This function is safe to call multiple times. It will ensure
-   *  that the internal buffer is deallocated if it exists. In any
+   *  This function is safe to call multiple times.  It will ensure
+   *  that the internal buffer is deallocated if it exists.  In any
    *  case, it will also reset the buffer pointers.
   */
   void
   disable_buffer ();
 
   /**
    *  Underlying file pointer.
   */
@@ -268,17 +268,17 @@ private:
    *  upon destruction.
   */
   bool own_buffer;
 };
 
 /**
  *  @brief  Gzipped file input stream class.
  *
- *  This class implements ifstream for gzipped files. Seeking and putback
+ *  This class implements ifstream for gzipped files.  Seeking and putback
  *  is not supported yet.
 */
 class gzifstream : public std::istream
 {
 public:
   //  Default constructor
   gzifstream ();
 
@@ -315,20 +315,20 @@ public:
   is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
+   *  otherwise in state fail().  This differs from the behavior of
    *  ifstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
+   *  you manually clear() the state.  The choice is a matter of
    *  convenience.
   */
   void
   open (const char* name,
         std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Attach to already open gzipped file.
@@ -355,17 +355,17 @@ private:
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
 /**
  *  @brief  Gzipped file output stream class.
  *
- *  This class implements ofstream for gzipped files. Seeking and putback
+ *  This class implements ofstream for gzipped files.  Seeking and putback
  *  is not supported yet.
 */
 class gzofstream : public std::ostream
 {
 public:
   //  Default constructor
   gzofstream ();
 
@@ -402,20 +402,20 @@ public:
   is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
+   *  otherwise in state fail().  This differs from the behavior of
    *  ofstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
+   *  you manually clear() the state.  The choice is a matter of
    *  convenience.
   */
   void
   open (const char* name,
         std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Attach to already open gzipped file.
@@ -442,17 +442,17 @@ private:
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
 /**
  *  @brief  Gzipped file output stream manipulator class.
  *
- *  This class defines a two-argument manipulator for gzofstream. It is used
+ *  This class defines a two-argument manipulator for gzofstream.  It is used
  *  as base for the setcompression(int,int) manipulator.
 */
 template <typename T1, typename T2>
 class gzomanip2
 {
 public:
   // Allows insertor to peek at internals
   template <typename Ta, typename Tb>
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -111,17 +111,17 @@ glpk (int sense, int n, int m, double *c
               if (freeLB[i] && ! freeUB[i])
                 glp_set_col_bnds (lp, i+1, GLP_UP, lb[i], ub[i]);
               else
                 glp_set_col_bnds (lp, i+1, GLP_FR, lb[i], ub[i]);
             }
         }
 
       // -- Set the objective coefficient of the corresponding
-      // -- structural variable. No constant term is assumed.
+      // -- structural variable.  No constant term is assumed.
       glp_set_obj_coef(lp,i+1,c[i]);
 
       if (isMIP)
         glp_set_col_kind (lp, i+1, vartype[i]);
     }
 
   glp_add_rows (lp, m);
 
@@ -395,24 +395,24 @@ Undocumented internal function.\n\
                   cn(nz) = j + 1;
                   a(nz) = A(i,j);
                 }
             }
         }
 
     }
 
-  // 3rd Input. A column array containing the right-hand side value
-  //               for each constraint in the constraint matrix.
+  // 3rd Input.  A column array containing the right-hand side value
+  //             for each constraint in the constraint matrix.
   Matrix B = args(2).xmatrix_value ("__glpk__: invalid value of B");
 
   double *b = B.fortran_vec ();
 
-  // 4th Input. An array of length mrowsc containing the lower
-  //            bound on each of the variables.
+  // 4th Input.  An array of length mrowsc containing the lower
+  //             bound on each of the variables.
   Matrix LB = args(3).xmatrix_value ("__glpk__: invalid value of LB");
 
   if (LB.numel () < mrowsc)
     error ("__glpk__: invalid dimensions for LB");
 
   double *lb = LB.fortran_vec ();
 
   // LB argument, default: Free
@@ -423,18 +423,18 @@ Undocumented internal function.\n\
         {
           freeLB(i) = 1;
           lb[i] = -octave::numeric_limits<double>::Inf ();
         }
       else
         freeLB(i) = 0;
     }
 
-  // 5th Input. An array of at least length numcols containing the upper
-  //            bound on each of the variables.
+  // 5th Input.  An array of at least length numcols containing the upper
+  //             bound on each of the variables.
   Matrix UB = args(4).xmatrix_value ("__glpk__: invalid value of UB");
 
   if (UB.numel () < mrowsc)
     error ("__glpk__: invalid dimensions for UB");
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
@@ -444,48 +444,48 @@ Undocumented internal function.\n\
         {
           freeUB(i) = 1;
           ub[i] = octave::numeric_limits<double>::Inf ();
         }
       else
         freeUB(i) = 0;
     }
 
-  // 6th Input. A column array containing the sense of each constraint
-  //            in the constraint matrix.
+  // 6th Input.  A column array containing the sense of each constraint
+  //             in the constraint matrix.
   charMatrix CTYPE = args(5).xchar_matrix_value ("__glpk__: invalid value of CTYPE");
 
   char *ctype = CTYPE.fortran_vec ();
 
-  // 7th Input. A column array containing the types of the variables.
+  // 7th Input.  A column array containing the types of the variables.
   charMatrix VTYPE = args(6).xchar_matrix_value ("__glpk__: invalid value of VARTYPE");
 
   Array<int> vartype (dim_vector (mrowsc, 1));
   int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
         {
           isMIP = 1;
           vartype(i) = GLP_IV;
         }
       else
         vartype(i) = GLP_CV;
     }
 
-  // 8th Input. Sense of optimization.
+  // 8th Input.  Sense of optimization.
   int sense;
   double SENSE = args(7).xscalar_value ("__glpk__: invalid value of SENSE");
 
   if (SENSE >= 0)
     sense = 1;
   else
     sense = -1;
 
-  // 9th Input. A structure containing the control parameters.
+  // 9th Input.  A structure containing the control parameters.
   octave_scalar_map PARAM = args(8).xscalar_map_value ("__glpk__: invalid value of PARAM");
 
   control_params par;
 
   // Integer parameters
 
   // Level of messages output by the solver
   par.msglev = 1;
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -503,17 +503,17 @@ public:
             item->labelcolor (fl_rgb_color (r, g, b));
           }
       }
   }
 
   void update_seperator (const uimenu::properties& uimenup)
   {
     // Matlab places the separator before the current
-    // menu entry, while fltk places it after. So we need to find
+    // menu entry, while fltk places it after.  So we need to find
     // the previous item in this menu/submenu. (Kai)
     std::string fltk_label = uimenup.get_fltk_label ();
     if (! fltk_label.empty ())
       {
         int itemflags = 0, idx;
         int curr_idx = find_index_by_name (fltk_label.c_str ());
 
         for (idx = curr_idx - 1; idx >= 0; idx--)
@@ -965,17 +965,17 @@ public:
 
   void hide_canvas (void)
   {
     canvas->hide ();
   }
 
   // Move the toolbar at the bottom of the plot_window.
   // The only reason for moving the toolbar is hiding and
-  // showing the menubar. All other resizing is done by fltk.
+  // showing the menubar.  All other resizing is done by fltk.
 
   void update_toolbar_position ()
   {
     int old_canvas_h = canvas->h ();
 
     // keep position fix, change outerposition accordingly
     update_boundingbox (true);
     canvas->resize (0, menu_dy (), w (), old_canvas_h);
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -183,17 +183,17 @@ instead.\n\
       Array<idx_vector> idx (dim_vector (3, 1));
 
       // Flip Y
       idx(0) = idx_vector::make_range (Height - 1, -1, Height);
       idx(1) = idx_vector::colon;
 
       // Remove alpha channel
       idx(2) = idx_vector (0, 3);
-      retval = octave_value (img.permute (perm). index(idx));
+      retval = octave_value (img.permute (perm).index(idx));
     }
 
   OSMesaDestroyContext (ctx);
 
   return retval;
 
 #else
 
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -221,17 +221,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).is_complex_type ())
         {
-          scm = args(0). sparse_complex_matrix_value ();
+          scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
       else
         {
@@ -368,17 +368,17 @@ last in the output permutation (subject 
 @item @var{knobs}(2)\n\
 If nonzero, aggressive absorption is performed.\n\
 \n\
 @item @var{knobs}(3)\n\
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
-@var{cmember} is an optional vector of length n. It defines the constraints\n\
+@var{cmember} is an optional vector of length n.  It defines the constraints\n\
 on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
 by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones (1,n)}\n\
 if not present or empty.  @code{csymamd (@var{S},[],1:n)} returns\n\
 @code{1:n}.\n\
 \n\
 @code{@var{p} = csymamd (@var{S})} is about the same as\n\
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -341,17 +341,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).is_complex_type ())
         {
-          scm = args(0). sparse_complex_matrix_value ();
+          scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
       else
         {
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -74,17 +74,17 @@ struct CMK_Node
   // the node's degree
   octave_idx_type deg;
   // minimal distance to the root of the spanning tree
   octave_idx_type dist;
 };
 
 // A simple queue.
 // Queues Q have a fixed maximum size N (rows,cols of the matrix) and are
-// stored in an array. qh and qt point to queue head and tail.
+// stored in an array.  qh and qt point to queue head and tail.
 
 // Enqueue operation (adds a node "o" at the tail)
 
 inline static void
 Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qt, const CMK_Node& o)
 {
   Q[qt] = o;
   qt = (qt + 1) % (N + 1);
@@ -107,17 +107,17 @@ Q_deq (CMK_Node * Q, octave_idx_type N, 
 
 // the left descendant of entry i
 #define LEFT(i)         (((i) << 1) + 1)        // = (2*(i)+1)
 // the right descendant of entry i
 #define RIGHT(i)        (((i) << 1) + 2)        // = (2*(i)+2)
 // the parent of entry i
 #define PARENT(i)       (((i) - 1) >> 1)        // = floor(((i)-1)/2)
 
-// Builds a min-heap (the root contains the smallest element). A is an array
+// Builds a min-heap (the root contains the smallest element).  A is an array
 // with the graph's nodes, i is a starting position, size is the length of A.
 
 static void
 H_heapify_min (CMK_Node *A, octave_idx_type i, octave_idx_type size)
 {
   octave_idx_type j = i;
   for (;;)
     {
@@ -138,17 +138,17 @@ H_heapify_min (CMK_Node *A, octave_idx_t
           std::swap (A[j], A[smallest]);
           j = smallest;
         }
       else
         break;
     }
 }
 
-// Heap operation insert. Running time is O(log(n))
+// Heap operation insert.  Running time is O(log(n))
 
 static void
 H_insert (CMK_Node *H, octave_idx_type& h, const CMK_Node& o)
 {
   octave_idx_type i = h++;
 
   H[i] = o;
 
@@ -164,33 +164,33 @@ H_insert (CMK_Node *H, octave_idx_type& 
           i = p;
         }
       else
         break;
     }
   while (i > 0);
 }
 
-// Heap operation remove-min. Removes the smalles element in O(1) and
+// Heap operation remove-min.  Removes the smalles element in O(1) and
 // reorganizes the heap optionally in O(log(n))
 
 inline static CMK_Node
 H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
 {
   CMK_Node r = H[0];
   H[0] = H[--h];
   if (reorg)
     H_heapify_min (H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
 #define H_empty(H, h)   ((h) == 0)
 
-// Helper function for the Cuthill-McKee algorithm. Tries to determine a
+// Helper function for the Cuthill-McKee algorithm.  Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
 
 static octave_idx_type
 find_starting_node (octave_idx_type N, const octave_idx_type *ridx,
                     const octave_idx_type *cidx, const octave_idx_type *ridx2,
                     const octave_idx_type *cidx2, octave_idx_type *D,
                     octave_idx_type start)
 {
@@ -317,18 +317,18 @@ find_starting_node (octave_idx_type N, c
           Q_enq (Q, N, qt, x);
         }
       else
         break;
     }
   return x.id;
 }
 
-// Calculates the node's degrees. This means counting the nonzero elements
-// in the symmetric matrix' rows. This works for non-symmetric matrices
+// Calculates the node's degrees.  This means counting the nonzero elements
+// in the symmetric matrix' rows.  This works for non-symmetric matrices
 // as well.
 
 static octave_idx_type
 calc_degrees (octave_idx_type N, const octave_idx_type *ridx,
               const octave_idx_type *cidx, octave_idx_type *D)
 {
   octave_idx_type max_deg = 0;
 
@@ -498,29 +498,29 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   if (max_deg == 0)
     {
       for (octave_idx_type i = 0; i < N; i++)
         P(i) = i;
 
       return ovl (P);
     }
 
-  // a heap for the a node's neighbors. The number of neighbors is
+  // a heap for the a node's neighbors.  The number of neighbors is
   // limited by the maximum degree max_deg:
   OCTAVE_LOCAL_BUFFER (CMK_Node, S, max_deg);
 
-  // a queue for the BFS. The array is always one element larger than
+  // a queue for the BFS.  The array is always one element larger than
   // the number of entries that are stored.
   OCTAVE_LOCAL_BUFFER (CMK_Node, Q, N+1);
 
   // a counter (for building the permutation)
   octave_idx_type c = -1;
 
   // upper bound for the bandwidth (=quality of solution)
-  // initialize the bandwidth of the graph with 0. B contains the
+  // initialize the bandwidth of the graph with 0.  B contains the
   // the maximum of the theoretical lower limits of the subgraphs
   // bandwidths.
   octave_idx_type B = 0;
 
   // mark all nodes as unvisited; with the exception of the nodes
   // that have degree==0 and build a CC of the graph.
 
   boolNDArray btmp (dim_vector (1, N), false);
@@ -533,17 +533,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       for (i = 0; i < N; i++)
         if (! visit[i])
           break;
 
       // locate a probably better starting node
       v.id = find_starting_node (N, ridx, cidx, ridx2, cidx2, D, i);
 
       // mark the node as visited and enqueue it (a starting node
-      // for the BFS). Since the node will be a root of a spanning
+      // for the BFS).  Since the node will be a root of a spanning
       // tree, its dist is 0.
       v.deg = D[v.id];
       v.dist = 0;
       visit[v.id] = true;
       Q_enq (Q, N, qt, v);
 
       // lower bound for the bandwidth of a subgraph
       // keep a "level" in the spanning tree (= min. distance to the
@@ -669,19 +669,19 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
               // enqueue v in O(1)
               Q_enq (Q, N, qt, v);
             }
 
           // synchronize the bandwidth with level_N once again:
           if (Bsub < level_N)
             Bsub = level_N;
         }
-      // finish of BFS. If there are still unvisited nodes in the graph
-      // then it is split into CCs. The computed bandwidth is the maximum
-      // of all subgraphs. Update:
+      // finish of BFS.  If there are still unvisited nodes in the graph
+      // then it is split into CCs.  The computed bandwidth is the maximum
+      // of all subgraphs.  Update:
       if (Bsub > B)
         B = Bsub;
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -72,17 +72,17 @@ octave_base_diag<DMT, MT>::subsref (cons
 
 template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT,MT>::diag (octave_idx_type k) const
 {
   octave_value retval;
   if (matrix.rows () == 1 || matrix.cols () == 1)
     {
-      // Rather odd special case. This is a row or column vector
+      // Rather odd special case.  This is a row or column vector
       // represented as a diagonal matrix with a single nonzero entry, but
       // Fdiag semantics are to product a diagonal matrix for vector
       // inputs.
       if (k == 0)
         // Returns Diag2Array<T> with nnz <= 1.
         retval = matrix.build_diag_matrix ();
       else
         // Returns Array<T> matrix
@@ -498,23 +498,23 @@ octave_base_diag<DMT, MT>::load_ascii (s
   octave_idx_type l = r < c ? r : c;
   MT tmp (l, 1);
   is >> tmp;
 
   if (! is)
     error ("load: failed to load diagonal matrix constant");
 
   // This is a little tricky, as we have the Matrix type, but
-  // not ColumnVector type. We need to help the compiler get
+  // not ColumnVector type.  We need to help the compiler get
   // through the inheritance tree.
   typedef typename DMT::element_type el_type;
   matrix = DMT (MDiagArray2<el_type> (MArray<el_type> (tmp)));
   matrix.resize (r, c);
 
-  // Invalidate cache. Probably not necessary, but safe.
+  // Invalidate cache.  Probably not necessary, but safe.
   dense_cache = octave_value ();
 
   return true;
 }
 
 template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print_raw (std::ostream& os,
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -341,17 +341,17 @@ octave_base_matrix<MT>::assign (const oc
                 idx_vec(k) = idx(k).index_vector ();
 
                 scalar_opt = (scalar_opt && idx_vec(k).is_scalar ()
                               && idx_vec(k)(0) < dv(k));
               }
 
             if (scalar_opt)
               {
-                // optimize all scalar indices. Don't construct
+                // optimize all scalar indices.  Don't construct
                 // an index array, but rather calc a scalar index directly.
                 octave_idx_type n = 1;
                 octave_idx_type j = 0;
                 for (octave_idx_type i = 0; i < n_idx; i++)
                   {
                     j += idx_vec(i)(0) * n;
                     n *= dv (i);
                   }
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -210,25 +210,25 @@ public:
   friend class octave_value;
 
   octave_base_value (void) : count (1) { }
 
   octave_base_value (const octave_base_value&) : count (1) { }
 
   virtual ~octave_base_value (void) { }
 
-  // Unconditional clone. Always clones.
+  // Unconditional clone.  Always clones.
   virtual octave_base_value *
   clone (void) const { return new octave_base_value (*this); }
 
   // Empty clone.
   virtual octave_base_value *
   empty_clone (void) const;
 
-  // Unique clone. Usually clones, but may be overridden to fake the
+  // Unique clone.  Usually clones, but may be overridden to fake the
   // cloning when sharing copies is to be controlled from within an
   // instance (see octave_class).
   virtual octave_base_value *
   unique_clone (void) { return clone (); }
 
   virtual type_conv_info
   numeric_conversion_function (void) const
   { return type_conv_info (); }
@@ -686,17 +686,17 @@ public:
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
   virtual void dump (std::ostream& os) const;
 
-  // Standard mappers. Register new ones here.
+  // Standard mappers.  Register new ones here.
   enum unary_mapper_t
   {
     umap_abs,
     umap_acos,
     umap_acosh,
     umap_angle,
     umap_arg,
     umap_asin,
@@ -759,41 +759,41 @@ public:
     num_unary_mappers = umap_unknown
   };
 
   virtual octave_value map (unary_mapper_t) const;
 
   // These are fast indexing & assignment shortcuts for extracting
   // or inserting a single scalar from/to an array.
 
-  // Extract the n-th element, aka val(n). Result is undefined if val is not an
-  // array type or n is out of range. Never error.
+  // Extract the n-th element, aka val(n).  Result is undefined if val is not
+  // an array type or n is out of range.  Never error.
   virtual octave_value
   fast_elem_extract (octave_idx_type n) const;
 
-  // Assign the n-th element, aka val(n) = x. Returns false if val is not an
+  // Assign the n-th element, aka val(n) = x.  Returns false if val is not an
   // array type, x is not a matching scalar type, or n is out of range.
   // Never error.
   virtual bool
   fast_elem_insert (octave_idx_type n, const octave_value& x);
 
   // This is a helper for the above, to be overridden in scalar types.  The
   // whole point is to handle the insertion efficiently with just *two* VM
   // calls, which is basically the theoretical minimum.
   virtual bool
   fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
-  // Grab the reference count. For use by jit.
+  // Grab the reference count.  For use by jit.
   void
   grab (void)
   {
     ++count;
   }
 
-  // Release the reference count. For use by jit.
+  // Release the reference count.  For use by jit.
   void
   release (void)
   {
     if (--count == 0)
       delete this;
   }
 
 protected:
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -198,17 +198,17 @@ octave_class::octave_class (const octave
   symbol_table::add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
 {
   if (count == obsolete_copies)
     {
-      // All remaining copies are obsolete. We don't actually need to clone.
+      // All remaining copies are obsolete.  We don't actually need to clone.
       count++;
       return this;
     }
   else
     {
       // In theory, this shouldn't be happening, but it's here just in case.
       if (count < obsolete_copies)
         obsolete_copies = 0;
@@ -534,27 +534,27 @@ octave_class::subsasgn_common (const oct
                 args(2+i) = lrhs(i);
             }
           else
             args(2) = rhs;
 
           args(1) = make_idx_args (type, idx, "subsasgn");
           args(0) = obj;
 
-          // Now comes the magic. Count copies with me:
+          // Now comes the magic.  Count copies with me:
           // 1. myself (obsolete)
           // 2. the copy inside args (obsolete)
           // 3. the copy in method's symbol table (working)
           // ... possibly more (not obsolete).
           //
           // So we mark 2 copies as obsolete and hold our fingers crossed.
           // But prior to doing that, check whether the routine is amenable
           // to the optimization.
           // It is essential that the handling function doesn't store extra
-          // copies anywhere. If it does, things will not break but the
+          // copies anywhere.  If it does, things will not break but the
           // optimization won't work.
 
           octave_value_list tmp;
 
           if (obsolete_copies == 0 && meth.is_user_function ()
               && meth.user_function_value ()->subsasgn_optimization_ok ())
             {
               octave::unwind_protect frame;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -435,17 +435,17 @@ is_method_executing (const octave_value&
       // We can only check the context object for user-function (not builtin),
       // where we have access to the parameters (arguments and return values).
       // That's ok as there's no need to call this function for builtin
       // methods.
 
       if (uf)
         {
           // At this point, the method is executing, but we still need to
-          // check the context object for which the method is executing. For
+          // check the context object for which the method is executing.  For
           // methods, it's the first argument of the function; for ctors, it
           // is the first return value.
 
           tree_parameter_list* pl = uf->is_classdef_constructor ()
             ? uf->return_list () : uf->parameter_list ();
 
           if (pl && pl->size () > 0)
             {
@@ -868,17 +868,17 @@ octave_value
 octave_classdef::subsref (const std::string& type,
                           const std::list<octave_value_list>& idx,
                           bool auto_add)
 {
   size_t skip = 0;
   octave_value_list retval;
 
   // This variant of subsref is used to create temporary values when doing
-  // assignment with multi-level indexing. AFAIK this is only used for internal
+  // assignment with multi-level indexing.  AFAIK this is only used for internal
   // purpose (not sure we should even implement this) and any overload subsref
   // should not be called.
 
   retval = object.subsref (type, idx, 1, skip, cdef_class (), auto_add);
 
   if (type.length () > skip && idx.size () > skip)
     retval = retval(0).next_subsref (1, type, idx, skip);
 
@@ -1685,17 +1685,17 @@ cdef_object_array::subsasgn (const std::
           int ignore_copies = 0;
 
           // If the object in 'a' is not valid, this means the index
           // was out-of-bound and we need to create a new object.
 
           if (! obj.ok ())
             obj = get_class ().construct_object (octave_value_list ());
           else
-            // Optimize the subsasgn call to come. There are 2 copies
+            // Optimize the subsasgn call to come.  There are 2 copies
             // that we can safely ignore:
             // - 1 in "array"
             // - 1 in "a"
             ignore_copies = 2;
 
           std::list<octave_value_list> next_idx (idx);
 
           next_idx.erase (next_idx.begin ());
@@ -2652,17 +2652,17 @@ cdef_class::make_meta_class (tree_classd
           retval.put (aname, avalue);
         }
     }
 
   tree_classdef_body* b = t->body ();
 
   if (b)
     {
-      // Keep track of the get/set accessor methods. They will be used
+      // Keep track of the get/set accessor methods.  They will be used
       // later on when creating properties.
 
       std::map<std::string, octave_value> get_methods;
       std::map<std::string, octave_value> set_methods;
 
       // Method blocks
 
       std::list<tree_classdef_methods_block *> mb_list = b->methods_list ();
@@ -2736,17 +2736,17 @@ cdef_class::make_meta_class (tree_classd
 
       if (is_at_folder)
         {
           // Look for all external methods visible on octave path at the
           // time of loading of the class.
           //
           // FIXME: This is an "extension" to Matlab behavior, which only
           // looks in the @-folder containing the original classdef
-          // file. However, this is easier to implement it that way at
+          // file.  However, this is easier to implement it that way at
           // the moment.
 
           std::list<std::string> external_methods =
             load_path::methods (full_class_name);
 
           for (std::list<std::string>::const_iterator
                it = external_methods.begin ();
                it != external_methods.end ();
@@ -2771,17 +2771,17 @@ cdef_class::make_meta_class (tree_classd
                   retval.install_method (meth);
                 }
             }
         }
 
       // Property blocks
 
       // FIXME: default property expression should be able to call static
-      //        methods of the class being constructed. A restricted CLASSNAME
+      //        methods of the class being constructed.  A restricted CLASSNAME
       //        symbol should be added to the scope before evaluating default
       //        value expressions.
 
       std::list<tree_classdef_properties_block *> pb_list
         = b->properties_list ();
 
       for (tree_classdef_body::properties_list_iterator it = pb_list.begin ();
            it != pb_list.end (); ++it)
@@ -2852,17 +2852,17 @@ cdef_class::make_meta_class (tree_classd
                   // Install property attributes.  This is done before assigning
                   // the property accessors so we can do validationby using
                   // cdef_property methods.
 
                   for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
                        ait != amap.end (); ++ait)
                     prop.put (ait->first, ait->second);
 
-                  // Install property access methods, if any. Remove the
+                  // Install property access methods, if any.  Remove the
                   // accessor methods from the temporary storage map, so we can
                   // detect which ones are invalid and do not correspond to a
                   // defined property.
 
                   std::map<std::string, octave_value>::iterator git =
                     get_methods.find (prop_name);
 
                   if (git != get_methods.end ())
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -725,22 +725,22 @@ private:
     std::map<std::string,cdef_method> method_map;
 
     // The properties defined by this class.
     std::map<std::string,cdef_property> property_map;
 
     // The number of members in this class (methods, properties...)
     octave_idx_type member_count;
 
-    // TRUE if this class is a handle class. A class is a handle
+    // TRUE if this class is a handle class.  A class is a handle
     // class when the abstract "handle" class is one of its superclasses.
     bool handle_class;
 
     // The list of super-class constructors that are called implicitly by the
-    // the classdef engine when creating an object. These constructors are not
+    // the classdef engine when creating an object.  These constructors are not
     // called explicitly by the class constructor.
     std::list<cdef_class> implicit_ctor_list;
 
     // The number of objects of this class.
     octave_refcount<octave_idx_type> object_count;
 
     // TRUE if this class is a built-in meta class.
     bool meta;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1567,17 +1567,17 @@ make_fcn_handle (const std::string& nm, 
           || fptr->is_class_constructor ()
           || fptr->is_classdef_constructor ()))
     {
       // Locally visible function.
       retval = octave_value (new octave_fcn_handle (f, tnm));
     }
   else
     {
-      // Globally visible (or no match yet). Query overloads.
+      // Globally visible (or no match yet).  Query overloads.
       std::list<std::string> classes = load_path::overloads (tnm);
       bool any_match = fptr != 0 || classes.size () > 0;
       if (! any_match)
         {
           // No match found, try updating load_path and query classes again.
           load_path::update ();
           classes = load_path::overloads (tnm);
           any_match = classes.size () > 0;
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -172,17 +172,17 @@ protected:
   octave_value fcn;
 
   // The name of the handle, including the "@".
   std::string nm;
 
   // Whether the function is overloaded at all.
   bool has_overloads;
 
-  // Overloads for builtin types. We use array to make lookup faster.
+  // Overloads for builtin types.  We use array to make lookup faster.
   octave_value builtin_overloads[btyp_num_types];
 
   // Overloads for other classes.
   str_ov_map overloads;
 
   friend octave_value make_fcn_handle (const std::string &, bool);
 };
 
diff --git a/libinterp/octave-value/ov-null-mat.h b/libinterp/octave-value/ov-null-mat.h
--- a/libinterp/octave-value/ov-null-mat.h
+++ b/libinterp/octave-value/ov-null-mat.h
@@ -27,18 +27,18 @@ along with Octave; see the file COPYING.
 
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 
 // Design rationale:
 // The constructors are hidden.  There is only one null matrix (or null string)
 // object, that can have shallow copies.  Cloning the object returns just a
-// normal empty matrix, so all the shallow copies are, in fact, read-only. This
-// conveniently ensures that any attempt to fiddle with the null matrix
+// normal empty matrix, so all the shallow copies are, in fact, read-only.
+// This conveniently ensures that any attempt to fiddle with the null matrix
 // destroys its special status.
 
 // The special [] value.
 
 class
 OCTINTERP_API
 octave_null_matrix : public octave_matrix
 {
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -86,17 +86,17 @@ octave_oncleanup::~octave_oncleanup (voi
       recover_from_exception ();
 
       warning ("onCleanup: interrupt occurred in cleanup action");
     }
   catch (const octave_execution_exception&)
     {
       throw;
     }
-  catch (...) // Yes, the black hole. We're in a d-tor.
+  catch (...) // Yes, the black hole.  We're in a d-tor.
     {
       // This shouldn't happen, in theory.
       error ("onCleanup: internal error: unhandled exception in cleanup action");
     }
 }
 
 octave_scalar_map
 octave_oncleanup::scalar_map_value (void) const
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -286,17 +286,17 @@ octave_perm_matrix::load_ascii (std::ist
   is >> tmp;
   if (! is)
     error ("load: failed to load permutation matrix constant");
 
   Array<octave_idx_type> pvec (dim_vector (n, 1));
   for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
   matrix = PermMatrix (pvec, colp);
 
-  // Invalidate cache. Probably not necessary, but safe.
+  // Invalidate cache.  Probably not necessary, but safe.
   dense_cache = octave_value ();
 
   return true;
 }
 
 bool
 octave_perm_matrix::save_binary (std::ostream& os, bool&)
 {
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -267,18 +267,17 @@ octave_range::diag (octave_idx_type m, o
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
   if (! range.is_empty ())
     {
       // FIXME: this is a potential waste of memory.
-
-      Matrix m ((range.matrix_value () . all ()) . all ());
+      Matrix m ((range.matrix_value ().all ()).all ());
 
       retval = (m.rows () == 1 && m.columns () == 1 && m (0, 0) != 0.0);
     }
 
   return retval;
 }
 
 Complex
@@ -522,17 +521,17 @@ octave_range::load_binary (std::istream&
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 // The following subroutines creates an HDF5 representation of the way
 // we will store Octave range types (triplets of floating-point numbers).
 // NUM_TYPE is the HDF5 numeric type to use for storage (e.g.
-// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary
+// H5T_NATIVE_DOUBLE to save as 'double').  Note that any necessary
 // conversions are handled automatically by HDF5.
 
 static hid_t
 hdf5_make_range_type (hid_t num_type)
 {
   hid_t type_id = H5Tcreate (H5T_COMPOUND, sizeof (double) * 3);
 
   H5Tinsert (type_id, "base", 0 * sizeof (double), num_type);
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -312,17 +312,17 @@ public:
     return anonymous_function
            ? (cname.empty ()
               ? (! dispatch_class ().empty ())
               : cname == dispatch_class ())
            : false;
   }
 
   // If we are a special expression, then the function body consists of exactly
-  // one expression. The expression's result is the return value of the
+  // one expression.  The expression's result is the return value of the
   // function.
   bool is_special_expr (void) const
   {
     return is_inline_function () || is_anonymous_function ();
   }
 
   bool is_nested_function (void) const { return nested_function; }
 
@@ -381,17 +381,17 @@ public:
 
   tree_statement_list *body (void) { return cmd_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   // If is_special_expr is true, retrieve the sigular expression that forms the
-  // body. May be null (even if is_special_expr is true).
+  // body.  May be null (even if is_special_expr is true).
   tree_expression *special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
   void accept (tree_walker& tw);
 
   template <typename T>
   bool local_protect (T& variable)
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1174,17 +1174,17 @@ public:
   { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
 
   octave_value storable_value (void) const;
 
-  // Ditto, but in place, i.e. equivalent to *this = this->storable_value (),
+  // Ditto, but in place, i.e., equivalent to *this = this->storable_value (),
   // but possibly more efficient.
 
   void make_storable_value (void);
 
   // FIXME: These should probably be private.
   // Conversions.  If a user of this class wants a certain kind of constant,
   // he should simply ask for it, and we should convert it if possible.
 
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -126,17 +126,17 @@ DEFBINOP_FN (el_and, sparse_complex_matr
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
-         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -133,17 +133,17 @@ DEFBINOP_FN (el_and, sparse_complex_matr
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
 
 DEFCATOP (scm_cs, sparse_complex_matrix, complex)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
-         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -124,17 +124,17 @@ DEFBINOP_FN (el_and, sparse_complex_matr
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
 
 DEFCATOP (scm_m, sparse_complex_matrix, matrix)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value
-         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, matrix)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -140,17 +140,17 @@ DEFBINOP_FN (el_and, sparse_complex_matr
 DEFBINOP_FN (el_or,  sparse_complex_matrix, scalar, mx_el_or)
 
 DEFCATOP (scm_s, sparse_complex_matrix, scalar)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
-         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value ().concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, scalar)
 {
   octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -402,45 +402,45 @@ public:
 
   // TRUE means we are in the process of autoloading a function.
   bool autoloading;
 
   // TRUE means the current function file was found in a relative path
   // element.
   bool fcn_file_from_relative_lookup;
 
-  // FALSE if we are still at the primary function. Subfunctions can
+  // FALSE if we are still at the primary function.  Subfunctions can
   // only be declared inside function files.
   bool parsing_subfunctions;
 
   // Maximum function depth detected.  Used to determine whether
   // we have nested functions or just implicitly ended subfunctions.
   int max_fcn_depth;
 
   // = 0 currently outside any function.
   // = 1 inside the primary function or a subfunction.
   // > 1 means we are looking at a function definition that seems to be
-  //     inside a function. Note that the function still might not be a
+  //     inside a function.  Note that the function still might not be a
   //     nested function.
   int curr_fcn_depth;
 
-  // Scope where we install all subfunctions and nested functions. Only
+  // Scope where we install all subfunctions and nested functions.  Only
   // used while reading function files.
   symbol_table::scope_id primary_fcn_scope;
 
   // Name of the current class when we are parsing class methods or
   // constructors.
   std::string curr_class_name;
 
   // Name of the current package when we are parsing an element contained
   // in a package directory (+-directory).
   std::string curr_package_name;
 
   // A stack holding the nested function scopes being parsed.
-  // We don't use std::stack, because we want the clear method. Also, we
+  // We don't use std::stack, because we want the clear method.  Also, we
   // must access one from the top
   std::vector<symbol_table::scope_id> function_scopes;
 
   // Pointer to the primary user function or user script function.
   octave_function *primary_fcn_ptr;
 
   // List of subfunction names, initially in the order they are
   // installed in the symbol table, then ordered as they appear in the
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -120,17 +120,17 @@ tree_binary_expression::rvalue1 (int)
           octave_value b = op_rhs->rvalue1 ();
 
           if (b.is_defined ())
             {
               BEGIN_PROFILER_BLOCK (tree_binary_expression)
 
               // Note: The profiler does not catch the braindead
               // short-circuit evaluation code above, but that should be
-              // ok. The evaluation of operands and the operator itself
+              // ok.  The evaluation of operands and the operator itself
               // is entangled and it's not clear where to start/stop
               // timing the operator to make it reasonable.
 
               retval = ::do_binary_op (etype, a, b);
 
               END_PROFILER_BLOCK
             }
         }
@@ -184,17 +184,17 @@ tree_boolean_expression::rvalue (int nar
 octave_value
 tree_boolean_expression::rvalue1 (int)
 {
   octave_value retval;
 
   bool result = false;
 
   // This evaluation is not caught by the profiler, since we can't find
-  // a reasonable place where to time. Note that we don't want to
+  // a reasonable place where to time.  Note that we don't want to
   // include evaluation of LHS or RHS into the timing, but this is
   // entangled together with short-circuit evaluation here.
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
       bool a_true = a.is_true ();
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -140,17 +140,17 @@ protected:
   // A count of the number of times this expression appears directly
   // inside a set of parentheses.
   //
   //   (((e1)) + e2)  ==> 2 for expression e1
   //                  ==> 1 for expression ((e1)) + e2
   //                  ==> 0 for expression e2
   int num_parens;
 
-  // The first index type associated with this expression. This field
+  // The first index type associated with this expression.  This field
   // is 0 (character '\0') if the expression has no associated index.
   // See the code in tree_identifier::rvalue for the rationale.
   char postfix_index_type;
 
   // TRUE if this expression is the EXPR in for loop:
   // FOR i = EXPR ... END
   bool for_cmd_expr;
 
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -85,18 +85,18 @@ octave_value_list
 tree_funcall::rvalue (int nargout)
 {
   octave_value_list retval;
 
   retval = feval (fcn.function_value (), args, nargout);
 
   if (retval.length () == 1 && retval(0).is_function ())
     {
-      // The return object is a function. We may need to re-index it using the
-      // same logic as for identifier. This is primarily used for superclass
+      // The return object is a function.  We may need to re-index it using the
+      // same logic as for identifier.  This is primarily used for superclass
       // references in classdef.
 
       octave_value val = retval(0);
       octave_function *f = val.function_value (true);
 
       if (f && ! (is_postfix_indexed ()
                   && f->is_postfix_index_handled (postfix_index ())))
         {
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -333,19 +333,19 @@ tree_index_expression::rvalue (int nargo
   std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
   for (int i = 0; i < n; i++)
     {
       if (i > 0)
         {
           tree_argument_list *al = *p_args;
 
-          // In Matlab, () can only be followed by . In Octave, we do not
+          // In Matlab, () can only be followed by '.'.  In Octave, we do not
           // enforce this for rvalue expressions, but we'll split the
-          // evaluation at this point. This will, hopefully, allow Octave's
+          // evaluation at this point.  This will, hopefully, allow Octave's
           // looser rules apply smoothly for Matlab overloaded subsref
           // codes.
           bool force_split = type[i-1] == '(' && type[i] != '.';
 
           if (force_split || (al && al->has_magic_end ()))
             {
               // (we have force_split, or) we have an expression like
               //
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -632,18 +632,18 @@ tm_const::init (const tree_matrix& tm)
         {
           first_elem = false;
 
           dv = this_elt_dv;
         }
       else if (all_str && dv.ndims () == 2
                && this_elt_dv.ndims () == 2)
         {
-          // FIXME: this is Octave's specialty. Character matrices allow
-          // rows of unequal length.
+          // FIXME: this is Octave's specialty.
+          // Character matrices allow rows of unequal length.
           if (this_elt_nc > cols ())
             dv(1) = this_elt_nc;
           dv(0) += this_elt_nr;
         }
       else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
         eval_error ("vertical dimensions mismatch", dv, this_elt_dv);
     }
 
@@ -1000,28 +1000,28 @@ tree_matrix::rvalue1 (int)
       else if (result_type == "cell")
         retval = do_single_type_concat<Cell> (dv, tmp);
       else if (result_type == "struct")
         retval = do_single_type_concat<octave_map> (dv, tmp);
       else
         {
           // The line below might seem crazy, since we take a copy of
           // the first argument, resize it to be empty and then resize
-          // it to be full. This is done since it means that there is
+          // it to be full.  This is done since it means that there is
           // no recopying of data, as would happen if we used a single
           // resize.  It should be noted that resize operation is also
           // significantly slower than the do_cat_op function, so it
           // makes sense to have an empty matrix and copy all data.
           //
           // We might also start with a empty octave_value using
           //
           //    ctmp = octave_value_typeinfo::lookup_type
           //          (tmp.begin() -> begin() -> type_name());
           //
-          // and then directly resize. However, for some types there
+          // and then directly resize.  However, for some types there
           // might be some additional setup needed, and so this should
           // be avoided.
 
           octave_value ctmp;
 
           // Find the first non-empty object
 
           if (any_sparse_p)
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -234,17 +234,17 @@ tree_parameter_list::variable_names (voi
 
 octave_value_list
 tree_parameter_list::convert_to_const_vector (int nargout,
                                               const Cell& varargout)
 {
   octave_idx_type vlen = varargout.numel ();
   int len = length ();
 
-  // Special case. Will do a shallow copy.
+  // Special case.  Will do a shallow copy.
   if (len == 0)
     return varargout;
   else if (nargout <= len)
     {
       octave_value_list retval (nargout);
 
       int i = 0;
 
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -564,18 +564,18 @@ sub2ind (const dim_vector& dv, const Arr
         {
           e.set_pos_if_unset (len, i+1);
           e.set_var ();
           std::string msg = e.message ();
           (*current_liboctave_error_with_id_handler)
             (e.err_id (), msg.c_str ());
         }
     }
-  // idxa known to be valid. Shouldn't need to catch index_exception below here.
-
+  // idxa known to be valid.
+  // Shouldn't need to catch index_exception below here.
 
   if (len == 1)
     retval = idxa(0);
   else if (clen == 1)
     {
       // All scalars case - the result is a scalar.
       octave_idx_type idx = idxa(len-1)(0);
       for (octave_idx_type i = len - 2; i >= 0; i--)
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2248,29 +2248,29 @@ Array<T>::find (octave_idx_type n, bool 
 {
   Array<octave_idx_type> retval;
   const T *src = data ();
   octave_idx_type nel = numel ();
   const T zero = T ();
   if (n < 0 || n >= nel)
     {
       // We want all elements, which means we'll almost surely need
-      // to resize. So count first, then allocate array of exact size.
+      // to resize.  So count first, then allocate array of exact size.
       octave_idx_type cnt = 0;
       for (octave_idx_type i = 0; i < nel; i++)
         cnt += src[i] != zero;
 
       retval.clear (cnt, 1);
       octave_idx_type *dest = retval.fortran_vec ();
       for (octave_idx_type i = 0; i < nel; i++)
         if (src[i] != zero) *dest++ = i;
     }
   else
     {
-      // We want a fixed max number of elements, usually small. So be
+      // We want a fixed max number of elements, usually small.  So be
       // optimistic, alloc the array in advance, and then resize if
       // needed.
       retval.clear (n, 1);
       if (backward)
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0;
           octave_idx_type l = nel - 1;
@@ -2689,17 +2689,17 @@ Array<T>::cat (int dim, octave_idx_type 
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       // NOTE: This takes some thinking, but no matter what the above rules
       // are, an empty array can always be skipped at this point, because
       // the result dimensions are already determined, and there is no way
       // an empty array may contribute a nonzero piece along the dimension
       // at this point, unless an empty array can be promoted to a non-empty
-      // one (which makes no sense). I repeat, *no way*, think about it.
+      // one (which makes no sense).  I repeat, *no way*, think about it.
       if (array_list[i].is_empty ())
         continue;
 
       octave_quit ();
 
       octave_idx_type u;
       if (dim < array_list[i].ndims ())
         u = l + array_list[i].dims ()(dim);
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -127,20 +127,20 @@ public:
 protected:
 
   dim_vector dimensions;
 
   typename Array<T>::ArrayRep *rep;
 
   // Rationale:
   // slice_data is a pointer to rep->data, denoting together with slice_len the
-  // actual portion of the data referenced by this Array<T> object. This allows
-  // to make shallow copies not only of a whole array, but also of contiguous
-  // subranges. Every time rep is directly manipulated, slice_data and slice_len
-  // need to be properly updated.
+  // actual portion of the data referenced by this Array<T> object.  This
+  // allows to make shallow copies not only of a whole array, but also of
+  // contiguous subranges.  Every time rep is directly manipulated, slice_data
+  // and slice_len need to be properly updated.
 
   T* slice_data;
   octave_idx_type slice_len;
 
   //! slice constructor
   Array (const Array<T>& a, const dim_vector& dv,
          octave_idx_type l, octave_idx_type u)
     : dimensions (dv), rep(a.rep), slice_data (a.slice_data+l), slice_len (u-l)
@@ -238,17 +238,17 @@ public:
   void fill (const T& val);
 
   void clear (void);
   void clear (const dim_vector& dv);
 
   void clear (octave_idx_type r, octave_idx_type c)
   { clear (dim_vector (r, c)); }
 
-  // Number of elements in the array. These are all synonyms.
+  // Number of elements in the array.  These are all synonyms.
   //@{
   //! Number of elements in the array.
   //! Synonymous with numel().
   //! @note This method is deprecated in favour of numel().
   OCTAVE_DEPRECATED ("use 'numel' instead")
   octave_idx_type capacity (void) const { return numel (); }
 
   //! Number of elements in the array.
@@ -439,27 +439,27 @@ public:
   { return elem (i, j); }
   crefT operator () (octave_idx_type i, octave_idx_type j,
                      octave_idx_type k) const
   { return elem (i, j, k); }
   crefT operator () (const Array<octave_idx_type>& ra_idx) const
   { return elem (ra_idx); }
 #endif
 
-  // Fast extractors. All of these produce shallow copies.
+  // Fast extractors.  All of these produce shallow copies.
   // Warning: none of these do check bounds, unless
   // OCTAVE_ENABLE_BOUNDS_CHECK is defined!
 
   //! Extract column: A(:,k+1).
   Array<T> column (octave_idx_type k) const;
   //! Extract page: A(:,:,k+1).
   Array<T> page (octave_idx_type k) const;
 
   //! Extract a slice from this array as a column vector: A(:)(lo+1:up).
-  //! Must be 0 <= lo && up <= numel. May be up < lo.
+  //! Must be 0 <= lo && up <= numel.  May be up < lo.
   Array<T> linear_slice (octave_idx_type lo, octave_idx_type up) const;
 
   Array<T> reshape (octave_idx_type nr, octave_idx_type nc) const
   { return Array<T> (*this, dim_vector (nr, nc)); }
 
   Array<T> reshape (const dim_vector& new_dims) const
   { return Array<T> (*this, new_dims); }
 
@@ -572,17 +572,17 @@ public:
 
   //! A(:,...,I,...,:) = [] (>= 2 subscripts, one of them is non-colon)
   void delete_elements (int dim, const idx_vector& i);
 
   //! Dispatcher to the above two.
   void delete_elements (const Array<idx_vector>& ia);
   //@}
 
-  //! Insert an array into another at a specified position. If
+  //! Insert an array into another at a specified position.  If
   //! size (a) is [d1 d2 ... dN] and idx is [i1 i2 ... iN], this
   //! method is equivalent to x(i1:i1+d1-1, i2:i2+d2-1, ... ,
   //! iN:iN+dN-1) = a.
   Array<T>& insert (const Array<T>& a, const Array<octave_idx_type>& idx);
 
   //! This is just a special case for idx = [r c 0 ...]
   Array<T>& insert (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
@@ -594,70 +594,70 @@ public:
         delete rep;
         rep = new_rep;
         slice_data = rep->data;
       }
   }
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
-  //! Give a pointer to the data in mex format. Unsafe. This function
-  //! exists to support the MEX interface. You should not use it
+  //! Give a pointer to the data in mex format.  Unsafe.  This function
+  //! exists to support the MEX interface.  You should not use it
   //! anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (int dim = 0, sortmode mode = ASCENDING) const;
   Array<T> sort (Array<octave_idx_type> &sidx, int dim = 0,
                  sortmode mode = ASCENDING) const;
 
   //! Ordering is auto-detected or can be specified.
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   //! Sort by rows returns only indices.
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   //! Ordering is auto-detected or can be specified.
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
-  //! @brief Do a binary lookup in a sorted array. Must not contain NaNs.
+  //! @brief Do a binary lookup in a sorted array.  Must not contain NaNs.
   //! Mode can be specified or is auto-detected by comparing 1st and last element.
   octave_idx_type lookup (const T& value, sortmode mode = UNSORTED) const;
 
   //! Ditto, but for an array of values, specializing on the case when values
-  //! are sorted. NaNs get the value N.
+  //! are sorted.  NaNs get the value N.
   Array<octave_idx_type> lookup (const Array<T>& values,
                                  sortmode mode = UNSORTED) const;
 
   //! Count nonzero elements.
   octave_idx_type nnz (void) const;
 
-  //! Find indices of (at most n) nonzero elements. If n is specified,
+  //! Find indices of (at most n) nonzero elements.  If n is specified,
   //! backward specifies search from backward.
   Array<octave_idx_type> find (octave_idx_type n = -1,
                                bool backward = false) const;
 
   //! Returns the n-th element in increasing order, using the same
-  //! ordering as used for sort. n can either be a scalar index or a
+  //! ordering as used for sort.  n can either be a scalar index or a
   //! contiguous range.
   Array<T> nth_element (const idx_vector& n, int dim = 0) const;
 
-  //! Get the kth super or subdiagonal. The zeroth diagonal is the
+  //! Get the kth super or subdiagonal.  The zeroth diagonal is the
   //! ordinary diagonal.
   Array<T> diag (octave_idx_type k = 0) const;
 
   Array<T> diag (octave_idx_type m, octave_idx_type n) const;
 
   //! Concatenation along a specified (0-based) dimension, equivalent
-  //! to cat(). dim = -1 corresponds to dim = 0 and dim = -2
+  //! to cat().  dim = -1 corresponds to dim = 0 and dim = -2
   //! corresponds to dim = 1, but apply the looser matching rules of
   //! vertcat/horzcat.
   static Array<T>
   cat (int dim, octave_idx_type n, const Array<T> *array_list);
 
-  //! Apply function fcn to each element of the Array<T>. This function
+  //! Apply function fcn to each element of the Array<T>.  This function
   //! is optimized with a manually unrolled loop.
   template <typename U, typename F>
   Array<U>
   map (F fcn) const
   {
     octave_idx_type len = numel ();
 
     const T *m = data ();
@@ -728,18 +728,18 @@ public:
 
   bool test_all (bool (&fcn) (const T&)) const
   { return test<bool (&) (const T&), true> (fcn); }
   //@}
 
   template <typename U> friend class Array;
 
   //! Returns true if this->dims () == dv, and if so, replaces this->dimensions
-  //! by a shallow copy of dv. This is useful for maintaining several arrays with
-  //! supposedly equal dimensions (e.g. structs in the interpreter).
+  //! by a shallow copy of dv.  This is useful for maintaining several arrays
+  //! with supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
   //@{
   //! WARNING: Only call these functions from jit
 
   int *jit_ref_count (void) { return rep->count.get (); }
 
   T *jit_slice_data (void) const { return slice_data; }
@@ -750,17 +750,17 @@ public:
   //@}
 
 private:
   static void instantiation_guard ();
 };
 
 //! This is a simple wrapper template that will subclass an Array<T>
 //! type or any later type derived from it and override the default
-//! non-const operator() to not check for the array's uniqueness. It
+//! non-const operator() to not check for the array's uniqueness.  It
 //! is, however, the user's responsibility to ensure the array is
 //! actually unaliased whenever elements are accessed.
 template <typename ArrayClass>
 class NoAlias : public ArrayClass
 {
   typedef typename ArrayClass::element_type T;
 public:
   NoAlias () : ArrayClass () { }
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1160,17 +1160,17 @@ ComplexMatrix::pseudo_inverse (double to
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     retval = ComplexMatrix (nc, nr, 0.0);
   else
     {
       ComplexMatrix Ur = U.extract (0, 0, nr-1, r);
-      DiagMatrix D = DiagMatrix (sigma.extract (0, r)) . inverse ();
+      DiagMatrix D = DiagMatrix (sigma.extract (0, r)).inverse ();
       ComplexMatrix Vr = V.extract (0, 0, nc-1, r);
       retval = Vr * D * Ur.hermitian ();
     }
 
   return retval;
 }
 
 #if defined (HAVE_FFTW)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -5652,17 +5652,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -5912,17 +5912,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -6200,17 +6200,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -6439,17 +6439,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -7301,17 +7301,17 @@ SparseComplexMatrix::cumsum (int dim) co
 {
   SPARSE_CUMSUM (SparseComplexMatrix, Complex, cumsum);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose ();
+    return transpose ().prod (0).transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
                            (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
diff --git a/liboctave/array/MArray-i.cc b/liboctave/array/MArray-i.cc
--- a/liboctave/array/MArray-i.cc
+++ b/liboctave/array/MArray-i.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "MArray.cc"
 
 template class OCTAVE_API MArray<int>;
 #if defined (OCTAVE_ENABLE_64)
 template class OCTAVE_API MArray<int64_t>;
 #endif
 
 // Explicit instantiation, as this seems to be required by weird compilers
-// like MSVC. This should be harmless on other compilers.
+// like MSVC.  This should be harmless on other compilers.
 template int xmin<int> (int, int);
 template int xmax<int> (int, int);
 template long xmin<long> (long, long);
 template long xmax<long> (long, long);
 
 INSTANTIATE_MARRAY_FRIENDS (int, OCTAVE_API)
 #if defined (OCTAVE_ENABLE_64)
 INSTANTIATE_MARRAY_FRIENDS (int64_t, OCTAVE_API)
diff --git a/liboctave/array/MArray-s.cc b/liboctave/array/MArray-s.cc
--- a/liboctave/array/MArray-s.cc
+++ b/liboctave/array/MArray-s.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 // Instantiate MArrays of short int values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template class OCTAVE_API MArray<short>;
 
 // Explicit instantiation, as this seems to be required by weird compilers
-// like MSVC. This should be harmless on other compilers.
+// like MSVC.  This should be harmless on other compilers.
 template short xmin<short> (short, short);
 template short xmax<short> (short, short);
 
 INSTANTIATE_MARRAY_FRIENDS (short, OCTAVE_API)
 
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -192,17 +192,17 @@ PermMatrix::pos_power (octave_idx_type m
       if (ic == ics)
         {
           // reduce power.
           octave_idx_type mm = m % j;
           // go forward mm steps.
           for (j = 0, ic = ics; j != mm; j++, ic = p[ic]) ;
         }
 
-      // now ic = p^m[ics]. Loop through the whole cycle.
+      // now ic = p^m[ics].  Loop through the whole cycle.
       octave_idx_type jcs = ics;
       do
         {
           q[jcs] = ic;
           jcs = p[jcs]; ic = p[ic];
         }
       while (jcs != ics);
 
diff --git a/liboctave/array/PermMatrix.h b/liboctave/array/PermMatrix.h
--- a/liboctave/array/PermMatrix.h
+++ b/liboctave/array/PermMatrix.h
@@ -97,17 +97,17 @@ public:
     return elem (i, j);
 #endif
   }
 
   // These are, in fact, super-fast.
   PermMatrix transpose (void) const;
   PermMatrix inverse (void) const;
 
-  // Determinant, i.e. the sign of permutation.
+  // Determinant, i.e., the sign of permutation.
   octave_idx_type determinant (void) const;
 
   // Efficient integer power of a permutation.
   PermMatrix power (octave_idx_type n) const;
 
   bool is_col_perm (void) const { return true; }
   bool is_row_perm (void) const { return false; }
 
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "lo-math.h"
 #include "lo-utils.h"
 #include "Array-util.h"
 
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
-  // will also be an integer, even if the limit is not. If there is one
+  // will also be an integer, even if the limit is not.  If there is one
   // or fewer elements only the base needs to be an integer
 
   return (! (xisnan (rng_base) || xisnan (rng_inc))
           && (NINTbig (rng_base) == rng_base || rng_numel < 1)
           && (NINTbig (rng_inc) == rng_inc || rng_numel <= 1));
 }
 
 Matrix
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -89,18 +89,18 @@ Sparse<T>::SparseRep::elem (octave_idx_t
       ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
 
   for (i = c[_c]; i < c[_c + 1]; i++)
     if (r[i] == _r)
       return d[i];
     else if (r[i] > _r)
       break;
 
-  // Ok, If we've gotten here, we're in trouble.. Have to create a
-  // new element in the sparse array. This' gonna be slow!!!
+  // Ok, If we've gotten here, we're in trouble.  Have to create a
+  // new element in the sparse array.  This' gonna be slow!!!
   if (c[ncols] == nzmx)
     (*current_liboctave_error_handler)
       ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
 
   octave_idx_type to_move = c[ncols] - i;
   if (to_move != 0)
     {
       for (octave_idx_type j = c[ncols]; j > i; j--)
@@ -330,17 +330,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
       if (a0 == T ())
         {
           // Do nothing, it's an empty matrix.
         }
       else if (cl == 1)
         {
-          // Sparse column vector. Sort row indices.
+          // Sparse column vector.  Sort row indices.
           idx_vector rs = r.sorted ();
 
           octave_quit ();
 
           const octave_idx_type *rd = rs.raw ();
           // Count unique indices.
           octave_idx_type new_nz = 1;
           for (octave_idx_type i = 1; i < n; i++)
@@ -411,17 +411,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
           // Bucket sort.
           OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, n);
           for (octave_idx_type i = 0; i < n; i++)
             if (rl == 1)
               sidx[ci[cd[i]+1]++] = rd[0];
             else
               sidx[ci[cd[i]+1]++] = rd[i];
 
-          // Subsorts. We don't need a stable sort, all values are equal.
+          // Subsorts.  We don't need a stable sort, all values are equal.
           xcidx (0) = 0;
           for (octave_idx_type j = 0; j < nc; j++)
             {
               std::sort (sidx + ci[j], sidx + ci[j+1]);
               octave_idx_type l = -1;
               octave_idx_type nzj = 0;
               // Count.
               for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
@@ -476,17 +476,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
                         }
                     }
                 }
             }
         }
     }
   else if (cl == 1)
     {
-      // Sparse column vector. Sort row indices.
+      // Sparse column vector.  Sort row indices.
       Array<octave_idx_type> rsi;
       idx_vector rs = r.sorted (rsi);
 
       octave_quit ();
 
       const octave_idx_type *rd = rs.raw ();
       const octave_idx_type *rdi = rsi.data ();
       // Count unique indices.
@@ -562,17 +562,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
           idx_pair& p = spairs[ci[cd[i]+1]++];
           if (rl == 1)
             p.first = rd[0];
           else
             p.first = rd[i];
           p.second = i;
         }
 
-      // Subsorts. We don't need a stable sort, the second index stabilizes it.
+      // Subsorts.  We don't need a stable sort, the second index stabilizes it.
       xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           std::sort (spairs + ci[j], spairs + ci[j+1]);
           octave_idx_type l = -1;
           octave_idx_type nzj = 0;
           // Count.
           for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
@@ -936,17 +936,17 @@ Sparse<T>::resize (octave_idx_type r, oc
 {
   if (r < 0 || c < 0)
     (*current_liboctave_error_handler) ("can't resize to negative dimension");
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   // This wouldn't be necessary for r >= rows () if nrows wasn't part of the
-  // Sparse rep. It is not good for anything in there.
+  // Sparse rep.  It is not good for anything in there.
   make_unique ();
 
   if (r < rows ())
     {
       octave_idx_type i = 0;
       octave_idx_type k = 0;
       for (octave_idx_type j = 1; j <= rep->ncols; j++)
         {
@@ -1104,19 +1104,19 @@ Sparse<T>::transpose (void) const
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
 
   return retval;
 }
 
-// Lower bound lookup. Could also use octave_sort, but that has upper bound
-// semantics, so requires some manipulation to set right. Uses a plain loop for
-// small columns.
+// Lower bound lookup.  Could also use octave_sort, but that has upper bound
+// semantics, so requires some manipulation to set right.  Uses a plain loop
+// for small columns.
 static octave_idx_type
 lblookup (const octave_idx_type *ridx, octave_idx_type nr,
           octave_idx_type ri)
 {
   if (nr <= 8)
     {
       octave_idx_type l;
       for (l = 0; l < nr; l++)
@@ -1408,19 +1408,18 @@ Sparse<T>::index (const idx_vector& idx,
       Sparse<T> tmp = *this;
       tmp.resize1 (ext);
       retval = tmp.index (idx);
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
-      // then want to make a dense matrix with sparse
-      // representation. Ok, we'll do it, but you deserve what
-      // you get!!
+      // then want to make a dense matrix with sparse representation.
+      // Ok, we'll do it, but you deserve what you get!!
       retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data (0) : T ());
     }
   else if (nc == 1)
     {
       // Sparse column vector.
       octave_idx_type lb, ub;
 
       if (idx.is_scalar ())
@@ -1599,17 +1598,17 @@ Sparse<T>::index (const idx_vector& idx_
       // Scalars stored as sparse matrices occupy more memory than
       // a scalar, so let's just convert the matrix to full, index,
       // and sparsify the result.
 
       retval = Sparse<T> (array_value ().index (idx_i, idx_j));
     }
   else if (idx_i.is_colon ())
     {
-      // Great, we're just manipulating columns. This is going to be quite
+      // Great, we're just manipulating columns.  This is going to be quite
       // efficient, because the columns can stay compressed as they are.
       if (idx_j.is_colon ())
         retval = *this; // Shallow copy.
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           // Special-case a contiguous range.
           octave_idx_type lbi = cidx (lb);
           octave_idx_type ubi = cidx (ub);
@@ -1640,17 +1639,17 @@ Sparse<T>::index (const idx_vector& idx_
 
               std::copy (data () + ljj, data () + ljj + nzj, retval.data () + lj);
               std::copy (ridx () + ljj, ridx () + ljj + nzj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
-      // It's actually vector indexing. The 1D index is specialized for that.
+      // It's actually vector indexing.  The 1D index is specialized for that.
       retval = index (idx_i);
 
       // If nr == 1 then the vector indexing will return a column vector!!
       if (nr == 1)
         retval.transpose ();
     }
   else if (idx_i.is_scalar ())
     {
@@ -1732,17 +1731,17 @@ Sparse<T>::index (const idx_vector& idx_
         }
 
       retval.change_capacity (retval.xcidx (m));
 
       octave_quit ();
 
       if (idx_i.is_range () && idx_i.increment () == -1)
         {
-          // It's nr:-1:1. Just flip all columns.
+          // It's nr:-1:1.  Just flip all columns.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
               octave_idx_type jj = idx_j(j);
               octave_idx_type lj = cidx (jj);
               octave_idx_type nzj = cidx (jj+1) - cidx (jj);
               octave_idx_type li = retval.xcidx (j);
               octave_idx_type uj = lj + nzj - 1;
@@ -1893,17 +1892,17 @@ Sparse<T>::assign (const idx_vector& idx
                   std::copy (tmp.ridx () + ui, tmp.ridx () + nz,
                              ridx () + li + rnz);
                 }
 
               cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
-              // It's s(u:-1:l) = r. Reverse the assignment.
+              // It's s(u:-1:l) = r.  Reverse the assignment.
               assign (idx.sorted (), rhs.index (idx_vector (rhl - 1, 0, -1)));
             }
           else if (idx.is_permutation (n))
             {
               *this = rhs.index (idx.inverse_permutation (n));
             }
           else if (rhs.nnz () == 0)
             {
@@ -2021,17 +2020,17 @@ Sparse<T>::assign (const idx_vector& idx
         }
 
       if (n == 0 || m == 0)
         return;
 
       if (idx_i.is_colon ())
         {
           octave_idx_type lb, ub;
-          // Great, we're just manipulating columns. This is going to be quite
+          // Great, we're just manipulating columns.  This is going to be quite
           // efficient, because the columns can stay compressed as they are.
           if (idx_j.is_colon ())
             *this = rhs; // Shallow copy.
           else if (idx_j.is_cont_range (nc, lb, ub))
             {
               // Special-case a contiguous range.
               octave_idx_type li = cidx (lb);
               octave_idx_type ui = cidx (ub);
@@ -2086,17 +2085,17 @@ Sparse<T>::assign (const idx_vector& idx
                   mx_inline_add (nc - ub, cidx () + ub + 1,
                                  tmp.cidx () + ub + 1, new_nz - nz);
 
                   assert (nnz () == new_nz);
                 }
             }
           else if (idx_j.is_range () && idx_j.increment () == -1)
             {
-              // It's s(:,u:-1:l) = r. Reverse the assignment.
+              // It's s(:,u:-1:l) = r.  Reverse the assignment.
               assign (idx_i, idx_j.sorted (),
                       rhs.index (idx_i, idx_vector (m - 1, 0, -1)));
             }
           else if (idx_j.is_permutation (nc))
             {
               *this = rhs.index (idx_i, idx_j.inverse_permutation (nc));
             }
           else
@@ -2160,17 +2159,17 @@ Sparse<T>::assign (const idx_vector& idx
           if (idx_i.is_permutation (nr))
             {
               *this = rhs.index (idx_i.inverse_permutation (nr), idx_j);
             }
           else
             {
               // FIXME: optimize more special cases?
               // In general this requires unpacking the columns, which is slow,
-              // especially for many small columns. OTOH, transpose is an
+              // especially for many small columns.  OTOH, transpose is an
               // efficient O(nr+nc+nnz) operation.
               *this = transpose ();
               assign (idx_vector::colon, idx_i, rhs.transpose ());
               *this = transpose ();
             }
         }
       else
         {
@@ -2606,17 +2605,17 @@ Sparse<T>::cat (int dim, octave_idx_type
         for (octave_idx_type j = 0; j < dv(1); j++)
           {
             octave_quit ();
 
             octave_idx_type rcum = 0;
             for (octave_idx_type i = 0; i < n; i++)
               {
                 const Sparse<T>& spi = sparse_list[i];
-                // Skipping empty matrices. See the comment in Array.cc.
+                // Skipping empty matrices.  See the comment in Array.cc.
                 if (spi.is_empty ())
                   continue;
 
                 octave_idx_type kl = spi.cidx (j);
                 octave_idx_type ku = spi.cidx (j+1);
                 for (octave_idx_type k = kl; k < ku; k++, l++)
                   {
                     retval.xridx (l) = spi.ridx (k) + rcum;
@@ -2633,17 +2632,17 @@ Sparse<T>::cat (int dim, octave_idx_type
       }
     case 1:
       {
         octave_idx_type l = 0;
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_quit ();
 
-            // Skipping empty matrices. See the comment in Array.cc.
+            // Skipping empty matrices.  See the comment in Array.cc.
             if (sparse_list[i].is_empty ())
               continue;
 
             octave_idx_type u = l + sparse_list[i].columns ();
             retval.assign (idx_vector::colon, idx_vector (l, u),
                            sparse_list[i]);
             l = u;
           }
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -196,17 +196,17 @@ public:
   Sparse (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)) { }
 
   // Both SparseMatrix and SparseBoolMatrix need this ctor, and this
   // is their only common ancestor.
   explicit Sparse (const PermMatrix& a);
 
-  // Type conversion case. Preserves capacity ().
+  // Type conversion case.  Preserves capacity ().
   template <typename U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols,
            a.rep->nzmx)),
     dimensions (a.dimensions)
   {
     octave_idx_type nz = a.nnz ();
     std::copy (a.rep->d, a.rep->d + nz, rep->d);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -848,17 +848,17 @@ Matrix::pseudo_inverse (double tol) cons
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     return Matrix (nc, nr, 0.0);
   else
     {
       Matrix Ur = U.extract (0, 0, nr-1, r);
-      DiagMatrix D = DiagMatrix (sigma.extract (0, r)) . inverse ();
+      DiagMatrix D = DiagMatrix (sigma.extract (0, r)).inverse ();
       Matrix Vr = V.extract (0, 0, nc-1, r);
       return Vr * D * Ur.transpose ();
     }
 }
 
 #if defined (HAVE_FFTW)
 
 ComplexMatrix
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -5845,17 +5845,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.0;
 
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -6078,17 +6078,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -6337,17 +6337,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.0;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -6588,17 +6588,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
             rcond = 1.0;
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           if (rcond == 0.0)
             {
-              // Either its indefinite or singular. Try UMFPACK
+              // Either its indefinite or singular.  Try UMFPACK
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
           else
             {
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (rcond_plus_one == 1.0 || xisnan (rcond))
@@ -7455,17 +7455,17 @@ SparseMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseMatrix, double, cumsum);
 }
 
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose ();
+    return transpose ().prod (0).transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
                            (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 octave_idx_type *
 dim_vector::nil_rep (void)
 {
   static dim_vector zv (0, 0);
   return zv.rep;
 }
 
-// The maximum allowed value for a dimension extent. This will normally be a
+// The maximum allowed value for a dimension extent.  This will normally be a
 // tiny bit off the maximum value of octave_idx_type.
 // Currently 1 is subtracted to allow safe conversion of any 2D Array into
 // Sparse, but this offset may change in the future.
 octave_idx_type
 dim_vector::dim_max (void)
 {
   return std::numeric_limits<octave_idx_type>::max () - 1;
 }
@@ -165,17 +165,17 @@ dim_vector::squeeze (void) const
         }
       else
         new_dims.resize (k);
     }
 
   return new_dims;
 }
 
-// This is the rule for cat(). cat (dim, A, B) works if one
+// This is the rule for cat().  cat (dim, A, B) works if one
 // of the following holds, in this order:
 //
 // 1. size (A, k) == size (B, k) for all k != dim.
 // In this case, size (C, dim) = size (A, dim) + size (B, dim) and
 // other sizes remain intact.
 //
 // 2. A is 0x0, in which case B is the result
 // 3. B is 0x0, in which case A is the result
@@ -212,18 +212,17 @@ dim_vector::concat (const dim_vector& dv
           break;
         }
     }
 
   if (match)
     rep[dim] += (dim < ndb ? dvb(dim) : 1);
   else
     {
-      // Dimensions don't match. The only allowed fix is
-      // to omit 0x0.
+      // Dimensions don't match.  The only allowed fix is to omit 0x0.
       if (ndb == 2 && dvb(0) == 0 && dvb(1) == 0)
         match = true;
       else if (orig_nd == 2 && rep[0] == 0 && rep[1] == 0)
         {
           *this = dvb;
           match = true;
         }
     }
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -421,17 +421,17 @@ public:
       retval *= elem (i);
 
     return retval;
   }
 
   /*!
      The following function will throw a std::bad_alloc ()
      exception if the requested size is larger than can be indexed by
-     octave_idx_type. This may be smaller than the actual amount of
+     octave_idx_type.  This may be smaller than the actual amount of
      memory that can be safely allocated on a system.  However, if we
      don't fail here, we can end up with a mysterious crash inside a
      function that is iterating over an array using octave_idx_type
      indices.
   */
 
   octave_idx_type safe_numel (void) const;
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1164,17 +1164,17 @@ FloatComplexMatrix::pseudo_inverse (floa
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     retval = FloatComplexMatrix (nc, nr, 0.0);
   else
     {
       FloatComplexMatrix Ur = U.extract (0, 0, nr-1, r);
-      FloatDiagMatrix D = FloatDiagMatrix (sigma.extract (0, r)) . inverse ();
+      FloatDiagMatrix D = FloatDiagMatrix (sigma.extract (0, r)).inverse ();
       FloatComplexMatrix Vr = V.extract (0, 0, nc-1, r);
       retval = Vr * D * Ur.hermitian ();
     }
 
   return retval;
 }
 
 #if defined (HAVE_FFTW)
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -855,17 +855,17 @@ FloatMatrix::pseudo_inverse (float tol) 
   while (r >= 0 && sigma.elem (r) < tol)
     r--;
 
   if (r < 0)
     return FloatMatrix (nc, nr, 0.0);
   else
     {
       FloatMatrix Ur = U.extract (0, 0, nr-1, r);
-      FloatDiagMatrix D = FloatDiagMatrix (sigma.extract (0, r)) . inverse ();
+      FloatDiagMatrix D = FloatDiagMatrix (sigma.extract (0, r)).inverse ();
       FloatMatrix Vr = V.extract (0, 0, nc-1, r);
       return Vr * D * Ur.transpose ();
     }
 }
 
 #if defined (HAVE_FFTW)
 
 FloatComplexMatrix
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -648,17 +648,17 @@ idx_vector::idx_mask_rep::idx_mask_rep (
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
   : data (0), len (nnz), ext (bnda.numel ()), lsti (-1), lste (-1),
     aowner (0), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
-  // We truncate the extent as much as possible. For Matlab
+  // We truncate the extent as much as possible.  For Matlab
   // compatibility, but maybe it's not a bad idea anyway.
   while (ext > 0 && ! bnda(ext-1))
     ext--;
 
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
     orig_dims = ((dv.ndims () == 2 && dv(0) == 1)
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 template <typename T> class Array;
 template <typename T> class Sparse;
 class Range;
 
 // Design rationale:
 // idx_vector is a reference-counting, polymorphic pointer, that can contain
 // 4 types of index objects: a magic colon, a range, a scalar, or an index vector.
 // Polymorphic methods for single element access are provided, as well as
-// templates implementing "early dispatch", i.e. hoisting the checks for index
+// templates implementing "early dispatch", i.e., hoisting the checks for index
 // type out of loops.
 
 class
 OCTAVE_API
 idx_vector
 {
 public:
 
@@ -80,17 +80,17 @@ private:
     virtual octave_idx_type xelem (octave_idx_type i) const = 0;
 
     // Range-checking element query.
     virtual octave_idx_type checkelem (octave_idx_type i) const = 0;
 
     // Length of the index vector.
     virtual octave_idx_type length (octave_idx_type n) const = 0;
 
-    // The maximum index + 1. The actual dimension is passed in.
+    // The maximum index + 1.  The actual dimension is passed in.
     virtual octave_idx_type extent (octave_idx_type n) const = 0;
 
     // Index class.
     virtual idx_class_type idx_class (void) const { return class_invalid; }
 
     // Sorts, maybe uniqifies, and returns a clone object pointer.
     virtual idx_base_rep *sort_uniq_clone (bool uniq = false) = 0;
     // Sorts, and returns a sorting permutation (aka Array::sort).
@@ -407,17 +407,17 @@ private:
     // No copying!
     idx_mask_rep (const idx_mask_rep& idx);
     idx_mask_rep& operator = (const idx_mask_rep& idx);
 
     const bool *data;
     octave_idx_type len;
     octave_idx_type ext;
 
-    // FIXME: I'm not sure if this is a good design. Maybe it would be
+    // FIXME: I'm not sure if this is a good design.  Maybe it would be
     // better to employ some sort of generalized iteration scheme.
     mutable octave_idx_type lsti;
     mutable octave_idx_type lste;
 
     // This is a trick to allow user-given mask arrays to be used as
     // indices without copying.  If the following pointer is nonzero, we
     // do not own the data, but rather have an Array<bool> object that
     // provides us the data.  Note that we need a pointer because we
@@ -596,17 +596,17 @@ public:
 
   // i/o
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
   { return a.print (os); }
 
-  // Slice with specializations. No checking of bounds!
+  // Slice with specializations.  No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[i] = src[idx(i)];
   // return i;
   //
   template <typename T>
@@ -670,17 +670,17 @@ public:
       default:
         assert (false);
         break;
       }
 
     return len;
   }
 
-  // Slice assignment with specializations. No checking of bounds!
+  // Slice assignment with specializations.  No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = src[i];
   // return i;
   //
   template <typename T>
@@ -742,17 +742,17 @@ public:
       default:
         assert (false);
         break;
       }
 
     return len;
   }
 
-  // Slice fill with specializations. No checking of bounds!
+  // Slice fill with specializations.  No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = val;
   // return i;
   //
   template <typename T>
@@ -814,17 +814,17 @@ public:
       default:
         assert (false);
         break;
       }
 
     return len;
   }
 
-  // Generic non-breakable indexed loop. The loop body should be
+  // Generic non-breakable indexed loop.  The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++) body (idx(i));
 
   template <typename Functor>
   void
   loop (octave_idx_type n, Functor body) const
@@ -879,17 +879,17 @@ public:
 
       default:
         assert (false);
         break;
       }
 
   }
 
-  // Generic breakable indexed loop. The loop body should be
+  // Generic breakable indexed loop.  The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   if (body (idx(i))) break;
   // return i;
   //
 
@@ -967,17 +967,17 @@ public:
         assert (false);
         break;
       }
 
     return ret;
   }
 
   // Rationale:
-  // This method is the key to "smart indexing". When indexing cartesian
+  // This method is the key to "smart indexing".  When indexing cartesian
   // arrays, sometimes consecutive index vectors can be reduced into a
   // single index.  If rows (A) = k and i.maybe_reduce (j) gives k, then
   // A(i,j)(:) is equal to A(k)(:).
 
   // If the next index can be reduced, returns true and updates this.
   bool maybe_reduce (octave_idx_type n, const idx_vector& j,
                      octave_idx_type nj);
 
@@ -988,21 +988,21 @@ public:
   // vectors, 1st difference otherwise.
   octave_idx_type increment (void) const;
 
   idx_vector
   complement (octave_idx_type n) const;
 
   bool is_permutation (octave_idx_type n) const;
 
-  // Returns the inverse permutation. If this is not a permutation on 1:n, the
+  // Returns the inverse permutation.  If this is not a permutation on 1:n, the
   // result is undefined (but no error unless extent () != n).
   idx_vector inverse_permutation (octave_idx_type n) const;
 
-  // Copies all the indices to a given array. Not allowed for colons.
+  // Copies all the indices to a given array.  Not allowed for colons.
   void copy_data (octave_idx_type *data) const;
 
   // If the index is a mask, convert it to index vector.
   idx_vector unmask (void) const;
 
   // Unconverts the index to a scalar, Range, double array or a mask.
   void unconvert (idx_class_type& iclass,
                   double& scalar, Range& range,
diff --git a/liboctave/cruft/Faddeeva/Faddeeva.cc b/liboctave/cruft/Faddeeva/Faddeeva.cc
--- a/liboctave/cruft/Faddeeva/Faddeeva.cc
+++ b/liboctave/cruft/Faddeeva/Faddeeva.cc
@@ -30,17 +30,17 @@
 
    Computes various error functions (erf, erfc, erfi, erfcx), 
    including the Dawson integral, in the complex plane, based
    on algorithms for the computation of the Faddeeva function 
               w(z) = exp(-z^2) * erfc(-i*z).
    Given w(z), the error functions are mostly straightforward
    to compute, except for certain regions where we have to
    switch to Taylor expansions to avoid cancellation errors
-   [e.g. near the origin for erf(z)].
+   [e.g., near the origin for erf(z)].
 
    To compute the Faddeeva function, we use a combination of two
    algorithms:
 
    For sufficiently large |z|, we use a continued-fraction expansion
    for w(z) similar to those described in:
 
       Walter Gautschi, "Efficient computation of the complex error
@@ -56,17 +56,17 @@
       Mofreh R. Zaghloul and Ahmed N. Ali, "Algorithm 916: Computing the
       Faddeyeva and Voigt Functions," ACM Trans. Math. Soft. 38(2), 15
       (2011).
 
    (I initially used this algorithm for all z, but it turned out to be
     significantly slower than the continued-fraction expansion for
     larger |z|.  On the other hand, it is competitive for smaller |z|, 
     and is significantly more accurate than the Poppe & Wijers code
-    in some regions, e.g. in the vicinity of z=1+1i.)
+    in some regions, e.g., in the vicinity of z=1+1i.)
 
    Note that this is an INDEPENDENT RE-IMPLEMENTATION of these algorithms,
    based on the description in the papers ONLY.  In particular, I did
    not refer to the authors' Fortran or Matlab implementations, respectively,
    (which are under restrictive ACM copyright terms and therefore unusable
     in free/open-source software).
 
    Steven G. Johnson, Massachusetts Institute of Technology
@@ -83,19 +83,19 @@
        I implemented a similar algorithm for Im[w(x)] of real x,
        since this comes up frequently in the other error functions.
 
    A small test program is included the end, which checks
    the w(z) etc. results against several known values.  To compile
    the test function, compile with -DTEST_FADDEEVA (that is,
    #define TEST_FADDEEVA).
 
-   If HAVE_CONFIG_H is #defined (e.g. by compiling with -DHAVE_CONFIG_H),
+   If HAVE_CONFIG_H is #defined (e.g., by compiling with -DHAVE_CONFIG_H),
    then we #include "config.h", which is assumed to be a GNU autoconf-style
-   header defining HAVE_* macros to indicate the presence of features. In
+   header defining HAVE_* macros to indicate the presence of features.  In
    particular, if HAVE_ISNAN and HAVE_ISINF are #defined, we use those
    functions in math.h instead of defining our own, and if HAVE_ERF and/or
    HAVE_ERFC are defined we use those functions from <cmath> for erf and
    erfc of real arguments, respectively, instead of defining our own.
 
    REVISION HISTORY:
        4 October 2012: Initial public release (SGJ)
        5 October 2012: Revised (SGJ) to fix spelling error,
@@ -202,28 +202,28 @@ static inline bool my_isinf(double x) { 
 #    define copysign _copysign // of course MS had to be different
 #  elif defined(GNULIB_NAMESPACE) // we are using using gnulib <cmath>
 #    define copysign GNULIB_NAMESPACE::copysign
 #  elif (__cplusplus < 201103L) && !defined(HAVE_COPYSIGN) && !defined(__linux__) && !(defined(__APPLE__) && defined(__MACH__)) && !defined(_AIX)
 static inline double my_copysign(double x, double y) { return y<0 ? -x : x; }
 #    define copysign my_copysign
 #  endif
 
-// If we are using the gnulib <cmath> (e.g. in the GNU Octave sources),
+// If we are using the gnulib <cmath> (e.g., in the GNU Octave sources),
 // gnulib generates a link warning if we use ::floor instead of gnulib::floor.
 // This warning is completely innocuous because the only difference between
 // gnulib::floor and the system ::floor (and only on ancient OSF systems)
 // has to do with floor(-0), which doesn't occur in the usage below, but
 // the Octave developers prefer that we silence the warning.
 #  if defined (GNULIB_NAMESPACE)
 #    define floor GNULIB_NAMESPACE::floor
 #    define log GNULIB_NAMESPACE::log
 #  endif
 
-#else // !__cplusplus, i.e. pure C (requires C99 features)
+#else // !__cplusplus, i.e., pure C (requires C99 features)
 
 #  include "Faddeeva.h"
 
 #  define _GNU_SOURCE // enable GNU libc NAN extension if possible
 
 #  include <float.h>
 #  include <math.h>
 
@@ -264,17 +264,17 @@ typedef double complex cmplx;
 static inline cmplx cpolar(double r, double t)
 {
   if (r == 0.0 && !isnan(t))
     return 0.0;
   else
     return C(r * cos(t), r * sin(t));
 }
 
-#endif // !__cplusplus, i.e. pure C (requires C99 features)
+#endif // !__cplusplus, i.e., pure C (requires C99 features)
 
 /////////////////////////////////////////////////////////////////////////
 // Auxiliary routines to compute other special functions based on w(z)
 
 // compute erfcx(z) = exp(z^2) erfz(z)
 cmplx FADDEEVA(erfcx)(cmplx z, double relerr)
 {
   return FADDEEVA(w)(C(-cimag(z), creal(z)), relerr);
@@ -991,17 +991,17 @@ cmplx FADDEEVA(w)(cmplx z, double relerr
       a) It maps x to y = 4 / (4+x) in [0,1].  This simple transformation,
          inspired by a similar transformation in the octave-forge/specfun
          erfcx by Soren Hauberg, results in much faster Chebyshev convergence
          than other simple transformations I have examined.
 
       b) Instead of using a single Chebyshev polynomial for the entire
          [0,1] y interval, we break the interval up into 100 equal
          subintervals, with a switch/lookup table, and use much lower
-         degree Chebyshev polynomials in each subinterval. This greatly
+         degree Chebyshev polynomials in each subinterval.  This greatly
          improves performance in my tests.
 
    For x < 0, we use the relationship erfcx(-x) = 2 exp(x^2) - erfc(x),
    with the usual checks for overflow etcetera.
 
    Performance-wise, it seems to be substantially faster than either
    the SLATEC DERFC function [or an erfcx function derived therefrom]
    or Cody's CALERF function (from netlib.org/specfun), while
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -96,17 +96,17 @@ dif (octave_idx_type nt, double *root, d
 // at the interpolation points.
 //
 // See Villadsen and Michelsen, pages 131-132 and 418.
 //
 // Input parameters:
 //
 //   nd     : the dimension of the vectors dif1, dif2, dif3, and root
 //
-//   n      : the degree of the jacobi polynomial, (i.e. the number
+//   n      : the degree of the jacobi polynomial, (i.e., the number
 //            of interior interpolation points)
 //
 //   n0     : determines whether x = 0 is included as an
 //            interpolation point
 //
 //              n0 = 0  ==>  x = 0 is not included
 //              n0 = 1  ==>  x = 0 is included
 //
@@ -259,17 +259,17 @@ jcobi (octave_idx_type n, octave_idx_typ
 // Compute derivative weights for orthogonal collocation.
 //
 // See Villadsen and Michelsen, pages 133-134, 419.
 //
 // Input parameters:
 //
 //   nd     : the dimension of the vectors dif1, dif2, dif3, and root
 //
-//   n      : the degree of the jacobi polynomial, (i.e. the number
+//   n      : the degree of the jacobi polynomial, (i.e., the number
 //            of interior interpolation points)
 //
 //   n0     : determines whether x = 0 is included as an
 //            interpolation point
 //
 //              n0 = 0  ==>  x = 0 is not included
 //              n0 = 1  ==>  x = 0 is included
 //
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -478,17 +478,17 @@ DASPK::do_integrate (double tout)
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddaspk_j,
                              ddaspk_psol));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-            // mode. The code has not yet reached TOUT.
+            // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
             // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
             // interpolation.  YPRIME(*) is obtained by interpolation.
     case 4: // The initial condition calculation, with
             // INFO(11) > 0, was successful, and INFO(14) = 1.
             // No integration steps were taken, and the solution
@@ -517,17 +517,17 @@ DASPK::do_integrate (double tout)
     case -12: // DDASPK failed to compute the initial YPRIME.
     case -13: // Unrecoverable error encountered inside user's
               // PSOL routine, and control is being returned to
               // the calling program.
     case -14: // The Krylov linear system solver could not
               // achieve convergence.
     case -33: // The code has encountered trouble from which it cannot
               // recover. A message is printed explaining the trouble
-              // and control is returned to the calling program. For
+              // and control is returned to the calling program.  For
               // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
         ("unrecognized value of istate (= %d) returned from ddaspk", istate);
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -330,17 +330,17 @@ DASRT::integrate (double tout)
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddasrt_j,
                              ddasrt_g, ng, pjroot));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-            // mode. The code has not yet reached TOUT.
+            // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping exactly to TOUT.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
             // interpolation.  YPRIME(*) is obtained by interpolation.
       t = tout;
       break;
 
@@ -362,18 +362,18 @@ DASRT::integrate (double tout)
     case -9: // The corrector could not converge.  There were repeated
              // error test failures in this step.
     case -10: // The corrector could not converge because IRES was
               // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
               // returned to the calling program.
     case -12: // DASSL failed to compute the initial YPRIME.
     case -33: // The code has encountered trouble from which it cannot
-              // recover. A message is printed explaining the trouble
-              // and control is returned to the calling program. For
+              // recover.  A message is printed explaining the trouble
+              // and control is returned to the calling program.  For
               // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
         ("unrecognized value of istate (= %d) returned from ddasrt",
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -290,17 +290,17 @@ DASSL::do_integrate (double tout)
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddassl_j));
 
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
-            // mode. The code has not yet reached TOUT.
+            // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
             // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
             // interpolation.  YPRIME(*) is obtained by interpolation.
       retval = x;
       t = tout;
       break;
@@ -319,18 +319,18 @@ DASSL::do_integrate (double tout)
     case -9: // The corrector could not converge.  There were repeated
              // error test failures in this step.
     case -10: // The corrector could not converge because IRES was
               // equal to minus one.
     case -11: // IRES equal to -2 was encountered and control is being
               // returned to the calling program.
     case -12: // DDASSL failed to compute the initial YPRIME.
     case -33: // The code has encountered trouble from which it cannot
-              // recover. A message is printed explaining the trouble
-              // and control is returned to the calling program. For
+              // recover.  A message is printed explaining the trouble
+              // and control is returned to the calling program.  For
               // example, this occurs when invalid input is detected.
       integration_error = true;
       break;
 
     default:
       integration_error = true;
       (*current_liboctave_error_handler)
         ("unrecognized value of istate (= %d) returned from ddassl",
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -854,17 +854,17 @@ EigsRealSymmetricMatrix (const M& m, con
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -893,19 +893,19 @@ EigsRealSymmetricMatrix (const M& m, con
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
@@ -1107,17 +1107,17 @@ EigsRealSymmetricMatrixShift (const M& m
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -1190,19 +1190,19 @@ EigsRealSymmetricMatrixShift (const M& m
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
@@ -1380,17 +1380,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
 
@@ -1420,19 +1420,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
@@ -1649,17 +1649,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -1688,19 +1688,19 @@ EigsRealNonSymmetricMatrix (const M& m, 
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
@@ -1951,17 +1951,17 @@ EigsRealNonSymmetricMatrixShift (const M
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -2034,19 +2034,19 @@ EigsRealNonSymmetricMatrixShift (const M
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
@@ -2279,17 +2279,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -2318,19 +2318,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
@@ -2599,17 +2599,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -2637,19 +2637,19 @@ EigsComplexNonSymmetricMatrix (const M& 
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
@@ -2855,17 +2855,17 @@ EigsComplexNonSymmetricMatrixShift (cons
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -2939,19 +2939,19 @@ EigsComplexNonSymmetricMatrixShift (cons
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
@@ -3140,17 +3140,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
               os << "Iteration " << iter - 1 <<
                  ": a few Ritz values of the " << p << "-by-" <<
                  p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
-          // iteration pointer. But as workl[iptr(5)-1] is
+          // iteration pointer.  But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
             workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
@@ -3179,19 +3179,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
           break;
         }
     }
   while (1);
 
   octave_idx_type info2;
 
   // We have a problem in that the size of the C++ bool
-  // type relative to the fortran logical type. It appears
+  // type relative to the fortran logical type.  It appears
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
-  // per bool, though this might be system dependent. As
+  // per bool, though this might be system dependent.  As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -69,17 +69,17 @@ inline T xmin (T x, T y)
 }
 
 template <typename T>
 inline T xmax (T x, T y)
 {
   return x >= y ? x : y;
 }
 
-// This form is favorable. GCC will translate (x <= y ? x : y) without a
+// This form is favorable.  GCC will translate (x <= y ? x : y) without a
 // jump, hence the only conditional jump involved will be the first
 // (xisnan), infrequent and hence friendly to branch prediction.
 inline double
 xmin (double x, double y)
 {
   return xisnan (y) ? x : (x <= y ? x : y);
 }
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -2788,17 +2788,17 @@ gammainc (const NDArray& x, const NDArra
 
   if (dv != a.dims ())
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-         x_str.c_str (), a_str. c_str ());
+         x_str.c_str (), a_str.c_str ());
     }
 
   NDArray retval (dv);
 
   bool err;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -43,22 +43,22 @@ along with Octave; see the file COPYING.
 #  include "nproc.h"
 #endif
 
 #if defined (HAVE_FFTW)
 
 octave_fftw_planner *octave_fftw_planner::instance = 0;
 
 // Helper class to create and cache FFTW plans for both 1D and
-// 2D. This implementation defaults to using FFTW_ESTIMATE to create
+// 2D.  This implementation defaults to using FFTW_ESTIMATE to create
 // the plans, which in theory is suboptimal, but provides quite
 // reasonable performance in practice.
 
 // Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
-// will destroy the input and output arrays. We must, therefore, create a
+// will destroy the input and output arrays.  We must, therefore, create a
 // temporary input array with the same size and 16-byte alignment as
 // the original array when using a different planner strategy.
 // Note that we also use any wisdom that is available, either in a
 // FFTW3 system wide file or as supplied by the user.
 
 // FIXME: if we can ensure 16 byte alignment in Array<T>
 // (<T> *data) the FFTW3 can use SIMD instructions for further
 // acceleration.
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -57,17 +57,17 @@ along with Octave; see the file COPYING.
 #include "mx-fcm-fs.h"
 #include "mx-fs-fcm.h"
 #include "mx-s-cm.h"
 #include "oct-cmplx.h"
 #include "svd.h"
 
 // Theory: norm accumulator is an object that has an accum method able
 // to handle both real and complex element, and a cast operator
-// returning the intermediate norm. Reference: Higham, N. "Estimating
+// returning the intermediate norm.  Reference: Higham, N. "Estimating
 // the Matrix p-Norm." Numer. Math. 62, 539-555, 1992.
 
 // norm accumulator for the p-norm
 template <typename R>
 class norm_accumulator_p
 {
   R p,scl,sum;
 public:
@@ -319,19 +319,19 @@ RES_TYPE FUNC_NAME (const ARG_TYPE& v, R
 }
 
 DEFINE_DISPATCHER (vector_norm, MArray<T>, R)
 DEFINE_DISPATCHER (column_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (column_norms, MSparse<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MSparse<T>, MArray<R>)
 
-// The approximate subproblem in Higham's method. Find lambda and mu such that
+// The approximate subproblem in Higham's method.  Find lambda and mu such that
 // norm ([lambda, mu], p) == 1 and norm (y*lambda + col*mu, p) is maximized.
-// Real version. As in Higham's paper.
+// Real version.  As in Higham's paper.
 template <typename ColVectorT, typename R>
 static void
 higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p, R& lambda, R& mu)
 {
   R nrm = 0;
   for (octave_idx_type i = 0; i < nsamp; i++)
     {
@@ -347,19 +347,19 @@ higham_subp (const ColVectorT& y, const 
         {
           lambda = lambda1;
           mu = mu1;
           nrm = nrm1;
         }
     }
 }
 
-// Complex version. Higham's paper does not deal with complex case, so we use a
-// simple extension. First, guess the magnitudes as in real version, then try
-// to rotate lambda to improve further.
+// Complex version.  Higham's paper does not deal with complex case, so we use
+// a simple extension.  First, guess the magnitudes as in real version, then
+// try to rotate lambda to improve further.
 template <typename ColVectorT, typename R>
 static void
 higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p,
              std::complex<R>& lambda, std::complex<R>& mu)
 {
   typedef std::complex<R> CR;
   R nrm = 0;
@@ -402,17 +402,17 @@ higham_subp (const ColVectorT& y, const 
 // the p-dual element (should work for both real and complex)
 template <typename T, typename R>
 inline T elem_dual_p (T x, R p)
 {
   return signum (x) * std::pow (std::abs (x), p-1);
 }
 
 // the VectorT is used for vectors, but actually it has to be
-// a Matrix type to allow all the operations. For instance SparseMatrix
+// a Matrix type to allow all the operations.  For instance SparseMatrix
 // does not support multiplication with column/row vectors.
 // the dual vector
 template <typename VectorT, typename R>
 VectorT dual_p (const VectorT& x, R p, R q)
 {
   VectorT res (x.dims ());
   for (octave_idx_type i = 0; i < x.numel (); i++)
     res.xelem (i) = elem_dual_p (x(i), p);
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -56,17 +56,17 @@ dmsolve_extract (const MSparse<T> &A, co
     nz = nr*nc;
   else
     nz = maxnz;
 
   MSparse<T> B (nr, nc, (nz < maxnz ? nz : maxnz));
 
   // Some sparse functions can support lazy indexing (where elements
   // in the row are in no particular order), even though octave in
-  // general can't. For those functions that can using it is a big
+  // general can't.  For those functions that can using it is a big
   // win here in terms of speed.
 
   if (lazy)
     {
       nz = 0;
 
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1780,17 +1780,17 @@ along with Octave; see the file COPYING.
             w[i] = 0; \
           \
           OCTAVE_LOCAL_BUFFER (RET_EL_TYPE, Xcol, nr); \
           \
           retval.change_capacity (nel); \
           /* The optimal break-point as estimated from simulations */ \
           /* Note that Mergesort is O(nz log(nz)) while searching all */ \
           /* values is O(nr), where nz here is nonzero per row of */ \
-          /* length nr. The test itself was then derived from the */ \
+          /* length nr.  The test itself was then derived from the */ \
           /* simulation with random square matrices and the observation */ \
           /* of the number of nonzero elements in the output matrix */ \
           /* it was found that the breakpoints were */ \
           /*   nr: 500  1000  2000  5000 10000 */ \
           /*   nz:   6    25    97   585  2202 */ \
           /* The below is a simplication of the 'polyfit'-ed parameters */ \
           /* to these breakpoints */ \
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -309,27 +309,27 @@ template <typename R, typename X, typena
 inline void F (size_t n, R *r, X x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
 // Let the compiler decide which pow to use, whichever best matches the
 // arguments provided.
 using std::pow;
 DEFMXMAPPER2X (mx_inline_pow, pow)
 
-// Arbitrary function appliers. The function is a template parameter to enable
-// inlining.
+// Arbitrary function appliers.
+// The function is a template parameter to enable inlining.
 template <typename R, typename X, R fun (X x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
 template <typename R, typename X, R fun (const X& x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
-// Appliers. Since these call the operation just once, we pass it as
+// Appliers.  Since these call the operation just once, we pass it as
 // a pointer, to allow the compiler reduce number of instances.
 
 template <typename R, typename X>
 inline Array<R>
 do_mx_unary_op (const Array<X>& x,
                 void (*op) (size_t, R *, const X *) throw ())
 {
   Array<R> r (x.dims ());
@@ -453,17 +453,17 @@ do_mx_check (const Array<T>& a,
 }
 
 // NOTE: we don't use std::norm because it typically does some heavyweight
 // magic to avoid underflows, which we don't need here.
 template <typename T>
 inline T cabsq (const std::complex<T>& c)
 { return c.real () * c.real () + c.imag () * c.imag (); }
 
-// default. works for integers and bool.
+// default.  works for integers and bool.
 template <typename T>
 inline bool xis_true (T x) { return x; }
 template <typename T>
 inline bool xis_false (T x) { return ! x; }
 // for octave_ints
 template <typename T>
 inline bool xis_true (const octave_int<T>& x) { return x.value (); }
 template <typename T>
@@ -553,18 +553,19 @@ OP_RED_FCN2 (mx_inline_sumsq, std::compl
 
 #define OP_RED_ANYR(ac, el) ac |= xis_true (el)
 #define OP_RED_ALLR(ac, el) ac &= xis_true (el)
 
 OP_RED_FCN2 (mx_inline_any_r, T, bool, OP_RED_ANYR, false)
 OP_RED_FCN2 (mx_inline_all_r, T, bool, OP_RED_ALLR, true)
 
 // Using the general code for any/all would sacrifice short-circuiting.
-// OTOH, going by rows would sacrifice cache-coherence. The following algorithm
-// will achieve both, at the cost of a temporary octave_idx_type array.
+// OTOH, going by rows would sacrifice cache-coherence.  The following
+// algorithm will achieve both, at the cost of a temporary octave_idx_type
+// array.
 
 #define OP_ROW_SHORT_CIRCUIT(F, PRED, ZERO) \
 template <typename T> \
 inline void \
 F (const T* v, bool *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (n <= 8) \
     return F ## _r (v, r, m, n); \
@@ -1334,17 +1335,17 @@ do_mx_diff_op (const Array<R>& src, int 
     }
 
   Array<R> ret (dims);
   mx_diff_op (src.data (), ret.fortran_vec (), l, n, u, order);
 
   return ret;
 }
 
-// Fast extra-precise summation. According to
+// Fast extra-precise summation.  According to
 // T. Ogita, S. M. Rump, S. Oishi:
 // Accurate Sum And Dot Product,
 // SIAM J. Sci. Computing, Vol. 26, 2005
 
 template <typename T>
 inline void twosum_accum (T& s, T& e,
                           const T& x)
 {
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -83,17 +83,17 @@ namespace octave
 #endif
 
       ot_usec = tm.usec ();
     }
 
     std::string
     time::ctime (void) const
     {
-      return localtime (*this) . asctime ();
+      return localtime (*this).asctime ();
     }
 
     void
     time::stamp (void)
     {
       struct ::timeval tp;
 
       gnulib::gettimeofday (&tp, 0);
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 
 // FIXME: is there a better name for this class?
 
 class
 action_container
 {
 public:
 
-  // A generic unwind_protect element. Knows how to run itself and
+  // A generic unwind_protect element.  Knows how to run itself and
   // discard itself.  Also, contains a pointer to the next element.
   class elem
   {
   public:
     elem (void) { }
 
     virtual void run (void) { }
 
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -1,10 +1,10 @@
-// This file is not compiled to a separate object file.  It is
-// included in pathsearch.cc.
+// This file is not compiled to a separate object file.
+// It is included in pathsearch.cc.
 
 /* Look up a filename in a path.
 
 Copyright (C) 2003-2015 John W. Eaton
 Copyright (C) 1993, 94, 95, 96, 97, 98 Karl Berry.
 Copyright (C) 1993, 94, 95, 96, 97 Karl Berry & O. Weber.
 Copyright (C) 1992, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
 
@@ -922,17 +922,17 @@ search (const std::string& path, const s
    tilde and variable expansion on elements in PATH), using a prebuilt
    db (see db.h) if it's relevant for a given path element.
 
    If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
    isn't found in the prebuilt db, look on the filesystem.  (I.e., if
    MUST_EXIST is false, and NAME isn't found in the db, do *not* look on
    the filesystem.)
 
-   The caller must expand PATH. This is because it makes more sense to
+   The caller must expand PATH.  This is because it makes more sense to
    do this once, in advance, instead of for every search using it.
 
    In any case, return the complete filename if found, otherwise NULL.  */
 
 static std::string
 kpse_path_search (const std::string& path, const std::string& name,
                   bool must_exist)
 {
@@ -1473,17 +1473,17 @@ kpse_path_expand (const std::string& pat
     }
 
   if (len > 0)
     ret.resize (len-1);
 
   return ret;
 }
 
-/* braces.c -- code for doing word expansion in curly braces. Taken from
+/* braces.c -- code for doing word expansion in curly braces.  Taken from
    bash 1.14.5.  [And subsequently modified for kpatshea.]
 
    Copyright (C) 1987,1991 Free Software Foundation, Inc.  */
 
 #define brace_whitespace(c) (! (c) || (c) == ' ' || (c) == '\t' || (c) == '\n')
 
 /* Basic idea:
 
@@ -1600,17 +1600,17 @@ expand_amble (const std::string& text)
         result = partial;
       else
         result.append (partial);
     }
 
   return result;
 }
 
-/* Start at INDEX, and skip characters in TEXT. Set INDEX to the
+/* Start at INDEX, and skip characters in TEXT.  Set INDEX to the
    index of the character matching SATISFY.  This understands about
    quoting.  Return the character that caused us to stop searching;
    this is either the same as SATISFY, or 0. */
 static int
 brace_gobbler (const std::string& text, int& indx, int satisfy)
 {
   int c = 0;
   int level = 0;
@@ -1675,18 +1675,18 @@ brace_gobbler (const std::string& text, 
     }
 
   indx = i;
   return c;
 }
 
 /* For each file format, we record the following information.  The main
    thing that is not part of this structure is the environment variable
-   lists. They are used directly in tex-file.c. We could incorporate
-   them here, but it would complicate the code a bit. We could also do
+   lists.  They are used directly in tex-file.c.  We could incorporate
+   them here, but it would complicate the code a bit.  We could also do
    it via variable expansion, but not now, maybe not ever:
    ${PKFONTS-${TEXFONTS-/usr/local/lib/texmf/fonts//}}.  */
 
 struct kpse_format_info_type
 {
   kpse_format_info_type (void)
     : type (), path (), raw_path (), path_source (), override_path (),
       client_path (), cnf_path (), default_path (), suffix ()
@@ -1750,17 +1750,17 @@ match (const std::string& filename_arg, 
       else if (IS_DIR_SEP (*path_elt)  /* at // */
                && original_filename < filename && IS_DIR_SEP (path_elt[-1]))
         {
           while (IS_DIR_SEP (*path_elt))
             path_elt++; /* get past second and any subsequent /'s */
 
           if (*path_elt == 0)
             {
-              /* Trailing //, matches anything. We could make this
+              /* Trailing //, matches anything.  We could make this
                  part of the other case, but it seems pointless to do
                  the extra work.  */
               matched = true;
               break;
             }
           else
             {
               /* Intermediate //, have to match rest of PATH_ELT.  */
@@ -1801,17 +1801,17 @@ match (const std::string& filename_arg, 
       matched = *filename == 0;
     }
 
   return matched;
 }
 
 /* If DB_DIR is a prefix of PATH_ELT, return true; otherwise false.
    That is, the question is whether to try the db for a file looked up
-   in PATH_ELT.  If PATH_ELT == ".", for example, the answer is no. If
+   in PATH_ELT.  If PATH_ELT == ".", for example, the answer is no.  If
    PATH_ELT == "/usr/local/lib/texmf/fonts//tfm", the answer is yes.
 
    In practice, ls-R is only needed for lengthy subdirectory
    comparisons, but there's no gain to checking PATH_ELT to see if it is
    a subdir match, since the only way to do that is to do a string
    search in it, which is all we do anyway.  */
 
 static bool
@@ -2457,17 +2457,17 @@ str_llist_add (str_llist_type *l, const 
     ;
 
   if (! e)
     *l = new_elt;
   else
     STR_LLIST_NEXT (*e) = new_elt;
 }
 
-/* Move an element towards the top. The idea is that when a file is
+/* Move an element towards the top.  The idea is that when a file is
    found in a given directory, later files will likely be in that same
    directory, and looking for the file in all the directories in between
    is thus a waste.  */
 
 static void
 str_llist_float (str_llist_type *l, str_llist_elt_type *mover)
 {
   str_llist_elt_type *last_moved, *unmoved;
diff --git a/liboctave/util/lo-macros.h b/liboctave/util/lo-macros.h
--- a/liboctave/util/lo-macros.h
+++ b/liboctave/util/lo-macros.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_lo_macros_h)
 #define octave_lo_macros_h 1
 
 #include "octave-config.h"
 
-// Core macros. Iteration is supported up to count 10.
+// Core macros.  Iteration is supported up to count 10.
 
 #define OCT_ITERATE_PARAM_MACRO0(MACRO, PARAM)
 #define OCT_ITERATE_PARAM_MACRO1(MACRO, PARAM) \
 MACRO(0, PARAM)
 #define OCT_ITERATE_PARAM_MACRO2(MACRO, PARAM) \
 MACRO(0, PARAM) MACRO(1, PARAM)
 #define OCT_ITERATE_PARAM_MACRO3(MACRO, PARAM) \
 MACRO(0, PARAM) MACRO(1, PARAM) MACRO(2, PARAM)
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -79,21 +79,21 @@ regexp::compile_internal (void)
 
   while ((new_pos = pattern.find ("(?", pos)) != std::string::npos)
     {
       if (pattern.at (new_pos + 2) == '<'
           && !(pattern.at (new_pos + 3) == '='
                || pattern.at (new_pos + 3) == '!'))
         {
           // The syntax of named tokens in pcre is "(?P<name>...)" while
-          // we need a syntax "(?<name>...)", so fix that here. Also an
+          // we need a syntax "(?<name>...)", so fix that here.  Also an
           // expression like
           // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
           // should be perfectly legal, while pcre does not allow the same
-          // named token name on both sides of the alternative. Also fix
+          // named token name on both sides of the alternative.  Also fix
           // that here by replacing name tokens by dummy names, and dealing
           // with the dummy names later.
 
           size_t tmp_pos = pattern.find_first_of ('>', new_pos);
 
           if (tmp_pos == std::string::npos)
             (*current_liboctave_error_handler)
               ("regexp: syntax error in pattern");
@@ -133,17 +133,17 @@ regexp::compile_internal (void)
 
           pos = tmp_pos;
         }
       else if (pattern.at (new_pos + 2) == '<')
         {
           // Find lookbehind operators of arbitrary length (ie like
           // "(?<=[a-z]*)") and replace with a maximum length operator
           // as PCRE can not yet handle arbitrary length lookahead
-          // operators. Use the string length as the maximum length to
+          // operators.  Use the string length as the maximum length to
           // avoid issues.
 
           int brackets = 1;
           size_t tmp_pos1 = new_pos + 2;
           size_t tmp_pos2 = tmp_pos1;
 
           while (tmp_pos1 < pattern.length () && brackets > 0)
             {
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -26,33 +26,33 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include "Array.h"
 #include "Sparse.h"
 #include "Array-util.h"
 
 #include "bsxfun.h"
 
-// This source file implements a general binary maping function for
-// arrays. The syntax is binmap<type> (a, b, f,[name]). type denotes
-// the expected return type of the operation. a, b, should be one of
-// the 6 combinations:
+// This source file implements a general binary maping function for arrays.
+// The syntax is binmap<type> (a, b, f,[name]).
+// type denotes the expected return type of the operation.
+// a, b, should be one of the 6 combinations:
 //
 // Array-Array
 // Array-scalar
 // scalar-Array
 // Sparse-Sparse
 // Sparse-scalar
 // scalar-Sparse
 //
-// If both operands are nonscalar, name must be supplied. It is used
+// If both operands are nonscalar, name must be supplied.  It is used
 // as the base for error message when operands are nonconforming.
 //
-// The operation needs not be homogeneous, i.e. a, b and the result
-// may be of distinct types. f can have any of the four signatures:
+// The operation needs not be homogeneous, i.e., a, b and the result
+// may be of distinct types.  f can have any of the four signatures:
 //
 // U f (T, R)
 // U f (const T&, R)
 // U f (T, const R&)
 // U f (const T&, const R&)
 //
 // Additionally, f can be an arbitrary functor object.
 //
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -240,17 +240,17 @@ OCTAVE_LONG_DOUBLE_OPS(octave_uint64);
 
 // Define comparison operators
 
 template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (uint64_t x, double y)
 {
   static const double xxup = std::numeric_limits<uint64_t>::max ();
-  // This converts to the nearest double. Unless there's an equality, the
+  // This converts to the nearest double.  Unless there's an equality, the
   // result is clear.
   double xx = x;
   if (xx != y)
     return xop::op (xx, y);
   else
     {
       // If equality occurred we compare as integers.
       if (xx == xxup)
@@ -261,17 +261,17 @@ octave_int_cmp_op::emulate_mop (uint64_t
 }
 
 template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (int64_t x, double y)
 {
   static const double xxup = std::numeric_limits<int64_t>::max ();
   static const double xxlo = std::numeric_limits<int64_t>::min ();
-  // This converts to the nearest double. Unless there's an equality, the
+  // This converts to the nearest double.  Unless there's an equality, the
   // result is clear.
   double xx = x;
   if (xx != y)
     return xop::op (xx, y);
   else
     {
       // If equality occurred we compare as integers.
       if (xx == xxup)
@@ -373,19 +373,19 @@ octave_int_arith_base<uint64_t, false>::
 overflow:
   return max_val ();
 }
 
 template <>
 int64_t
 octave_int_arith_base<int64_t, true>::mul_internal (int64_t x, int64_t y)
 {
-  // The signed case is far worse. The problem is that
+  // The signed case is far worse.  The problem is that
   // even if neither integer fits into signed 32-bit range, the result may
-  // still be OK. Uh oh.
+  // still be OK.  Uh oh.
 
   // Essentially, what we do is compute sign, multiply absolute values
   // (as above) and impose the sign.
   // FIXME: can we do something faster if we OCTAVE_HAVE_FAST_INT_OPS?
 
   uint64_t usx = octave_int_abs (x);
   uint64_t usy = octave_int_abs (y);
   bool positive = (x < 0) == (y < 0);
@@ -477,23 +477,23 @@ DOUBLE_INT_BINOP_DECL (+, uint64)
 
 INT_DOUBLE_BINOP_DECL (+, int64)
 {
   if (fabs (y) < static_cast<double> (octave_int64::max ()))
     return x + octave_int64 (y);
   else
     {
       // If the number is within the int64 range (the most common case,
-      // probably), the above will work as expected. If not, it's more
+      // probably), the above will work as expected.  If not, it's more
       // complicated - as long as y is within _twice_ the signed range, the
-      // result may still be an integer. An instance of such an operation is
-      // 3*2**62 + (1+intmin ('int64')) that should yield int64 (2**62) + 1.  So
-      // what we do is to try to convert y/2 and add it twice. Note that if y/2
-      // overflows, the result must overflow as well, and that y/2 cannot be a
-      // fractional number.
+      // result may still be an integer.  An instance of such an operation is
+      // 3*2**62 + (1+intmin ('int64')) that should yield int64 (2**62) + 1.
+      // So what we do is to try to convert y/2 and add it twice.  Note that
+      // if y/2 overflows, the result must overflow as well, and that y/2
+      // cannot be a fractional number.
       octave_int64 y2 (y / 2);
       return (x + y2) + y2;
     }
 }
 
 DOUBLE_INT_BINOP_DECL (+, int64)
 {
   return y + x;
@@ -505,17 +505,17 @@ INT_DOUBLE_BINOP_DECL (-, uint64)
 }
 
 DOUBLE_INT_BINOP_DECL (-, uint64)
 {
   if (x <= static_cast<double> (octave_uint64::max ()))
     return octave_uint64 (x) - y;
   else
     {
-      // Again a trick to get the corner cases right. Things like
+      // Again a trick to get the corner cases right.  Things like
       // 3**2**63 - intmax ('uint64') should produce the correct result, i.e.
       // int64 (2**63) + 1.
       const double p2_64 = std::pow (2.0, 64);
       if (y.bool_value ())
         {
           const uint64_t p2_64my = (~y.value ()) + 1; // Equals 2**64 - y
           return octave_uint64 (x - p2_64) + octave_uint64 (p2_64my);
         }
@@ -544,19 +544,19 @@ DOUBLE_INT_BINOP_DECL (-, int64)
 }
 
 // NOTE:
 // Emulated mixed multiplications are tricky due to possible precision loss.
 // Here, after sorting out common cases for speed, we follow the strategy
 // of converting the double number into the form sign * 64-bit integer *
 // 2**exponent, multiply the 64-bit integers to get a 128-bit number, split that
 // number into 32-bit words and form 4 double-valued summands (none of which
-// loses precision), then convert these into integers and sum them. Though it is
-// not immediately obvious, this should work even w.r.t. rounding (none of the
-// summands lose precision).
+// loses precision), then convert these into integers and sum them.  Though it
+// is not immediately obvious, this should work even w.r.t. rounding (none of
+// the summands lose precision).
 
 // Multiplies two unsigned 64-bit ints to get a 128-bit number represented
 // as four 32-bit words.
 static void
 umul128 (uint64_t x, uint64_t y, uint32_t w[4])
 {
   uint64_t lx = static_cast<uint32_t> (x);
   uint64_t ux = x >> 32;
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -72,17 +72,17 @@ REGISTER_INT_TYPE (uint8_t);
 REGISTER_INT_TYPE (int16_t);
 REGISTER_INT_TYPE (uint16_t);
 REGISTER_INT_TYPE (int32_t);
 REGISTER_INT_TYPE (uint32_t);
 REGISTER_INT_TYPE (int64_t);
 REGISTER_INT_TYPE (uint64_t);
 
 // Rationale: Comparators have a single static method, rel(), that returns the
-// result of the binary relation. They also have two static boolean fields:
+// result of the binary relation.  They also have two static boolean fields:
 // ltval, gtval determine the value of x OP y if x < y, x > y, respectively.
 #define REGISTER_OCTAVE_CMP_OP(NM,OP) \
   class NM \
     { \
     public: \
       static const bool ltval = (0 OP 1); \
       static const bool gtval = (1 OP 0); \
       template <typename T> \
@@ -96,22 +96,23 @@ REGISTER_INT_TYPE (uint64_t);
     { \
     public: \
       static const bool ltval = value; \
       static const bool gtval = value; \
       template <typename T> \
       static bool op (T, T) { return value; } \
     }
 
-// Handles non-homogeneous integer comparisons. Avoids doing useless tests.
+// Handles non-homogeneous integer comparisons.  Avoids doing useless tests.
 class octave_int_cmp_op
 {
   // This determines a suitable promotion type for T1 when meeting T2 in a
-  // binary relation. If promotion to int or T2 is safe, it is used. Otherwise,
-  // the signedness of T1 is preserved and it is widened if T2 is wider.
+  // binary relation.  If promotion to int or T2 is safe, it is used.
+  // Otherwise, the signedness of T1 is preserved and it is widened if T2 is
+  // wider.
   // Notice that if this is applied to both types, they must end up with equal
   // size.
   template <typename T1, typename T2>
   class prom
   {
     // Promote to int?
     static const bool pint = (sizeof (T1) < sizeof (int)
                               && sizeof (T2) < sizeof (int));
@@ -250,17 +251,17 @@ public:
 #endif
 
   DEFINE_LONG_DOUBLE_CMP_OP(int64_t)
   DEFINE_LONG_DOUBLE_CMP_OP(uint64_t)
 
 #undef DEFINE_LONG_DOUBLE_CMP_OP
 };
 
-// Base integer class. No data, just conversion methods and exception flags.
+// Base integer class.  No data, just conversion methods and exception flags.
 template <typename T>
 class octave_int_base
 {
 public:
 
   static T min_val () { return std::numeric_limits<T>:: min (); }
   static T max_val () { return std::numeric_limits<T>:: max (); }
 
@@ -319,26 +320,26 @@ private:
 public:
 
   // Convert a real number (check NaN and non-int).
   template <typename S>
   static T
   convert_real (const S& value);
 };
 
-// Saturated (homogeneous) integer arithmetics. The signed and unsigned
+// Saturated (homogeneous) integer arithmetics.  The signed and unsigned
 // implementations are significantly different, so we implement another layer
-// and completely specialize. Arithmetics inherits from octave_int_base so that
-// it can use its exceptions and truncation functions.
+// and completely specialize.  Arithmetics inherits from octave_int_base so
+// that it can use its exceptions and truncation functions.
 
 template <typename T, bool is_signed>
 class octave_int_arith_base
 { };
 
-// Unsigned arithmetics. C++ standard requires it to be modular, so the
+// Unsigned arithmetics.  C++ standard requires it to be modular, so the
 // overflows can be handled efficiently and reliably.
 template <typename T>
 class octave_int_arith_base<T, false> : octave_int_base<T>
 {
 public:
 
   static T
   abs (T x) { return x; }
@@ -378,30 +379,30 @@ public:
     T u = x - y;
     if (u > x)
       {
         u = 0;
       }
     return u;
   }
 
-  // Multiplication is done using promotion to wider integer type. If there is
+  // Multiplication is done using promotion to wider integer type.  If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T mul (T x, T y) { return mul_internal (x, y); }
 
   static T
   mul_internal (T x, T y)
   {
     // Promotion type for multiplication (if exists).
     typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
     return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
            * static_cast<mptype> (y));
   }
 
-  // Division with rounding to nearest. Note that / and % are probably
+  // Division with rounding to nearest.  Note that / and % are probably
   // computed by a single instruction.
   static T
   div (T x, T y)
   {
     if (y != 0)
       {
         T z = x / y;
         T w = x % y;
@@ -416,17 +417,17 @@ public:
 
   // Remainder.
   static T
   rem (T x, T y)
   {
     return y != 0 ? x % y : 0;
   }
 
-  // Modulus. Note the weird y = 0 case for Matlab compatibility.
+  // Modulus.  Note the weird y = 0 case for Matlab compatibility.
   static T
   mod (T x, T y)
   {
     return y != 0 ? x % y : x;
   }
 };
 
 #if defined (OCTAVE_INT_USE_LONG_DOUBLE)
@@ -488,19 +489,19 @@ octave_int_arith_base<uint64_t, false>::
 //      interpreting the signed bit pattern as unsigned (and is thus
 //      zero-cost).
 //
 //   3. Signed addition and subtraction yield the same bit results as
 //      unsigned.  (We use casts to prevent optimization interference,
 //      so there is no need for things like -ftrapv).
 //
 //   4. Bit operations on signed integers work like on unsigned
-//      integers, except for the shifts. Shifts are arithmetic.
+//      integers, except for the shifts.  Shifts are arithmetic.
 //
-// The above conditions are satisfied by most modern platforms. If
+// The above conditions are satisfied by most modern platforms.  If
 // OCTAVE_HAVE_FAST_INT_OPS is defined, bit tricks and wraparound
 // arithmetics are used to avoid conditional jumps as much as
 // possible, thus being friendly to modern pipeline processor
 // architectures.  Otherwise, we fall back to a bullet-proof code that
 // only uses assumptions guaranteed by the standard.
 
 template <typename T>
 class octave_int_arith_base<T, true> : octave_int_base<T>
@@ -554,17 +555,17 @@ public:
   static T
   signum (T x)
   {
     // With modest optimizations, this will compile without a jump.
     return ((x > 0) ? 1 : 0) - __signbit (x);
   }
 
   // FIXME: we do not have an authority what signed shifts should
-  // exactly do, so we define them the easy way. Note that Matlab does
+  // exactly do, so we define them the easy way.  Note that Matlab does
   // not define signed shifts.
 
   static T
   rshift (T x, int n) { return x >> n; }
 
   static T
   lshift (T x, int n) { return x << n; }
 
@@ -592,17 +593,17 @@ public:
 #endif
   }
 
   static T
   add (T x, T y)
   {
 #if defined (OCTAVE_HAVE_FAST_INT_OPS)
     // The typecasts do nothing, but they are here to prevent an optimizing
-    // compiler from interfering. Also, the signed operations on small types
+    // compiler from interfering.  Also, the signed operations on small types
     // actually return int.
     T u = static_cast<UT> (x) + static_cast<UT> (y);
     T ux = u ^ x;
     T uy = u ^ y;
     if ((ux & uy) < 0)
       {
         u = octave_int_base<T>::max_val () + __signbit (~u);
       }
@@ -634,17 +635,17 @@ public:
   }
 
   // This is very similar to addition.
   static T
   sub (T x, T y)
   {
 #if defined (OCTAVE_HAVE_FAST_INT_OPS)
     // The typecasts do nothing, but they are here to prevent an optimizing
-    // compiler from interfering. Also, the signed operations on small types
+    // compiler from interfering.  Also, the signed operations on small types
     // actually return int.
     T u = static_cast<UT> (x) - static_cast<UT> (y);
     T ux = u ^ x;
     T uy = u ^ ~y;
     if ((ux & uy) < 0)
       {
         u = octave_int_base<T>::max_val () + __signbit (~u);
       }
@@ -670,17 +671,17 @@ public:
         else
           u = x - y;
       }
 
     return u;
 #endif
   }
 
-  // Multiplication is done using promotion to wider integer type. If there is
+  // Multiplication is done using promotion to wider integer type.  If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T mul (T x, T y) { return mul_internal (x, y); }
 
   static T
   mul_internal (T x, T y)
   {
     // Promotion type for multiplication (if exists).
     typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
@@ -734,17 +735,17 @@ public:
 
   // Remainder.
   static T
   rem (T x, T y)
   {
     return y != 0 ? x % y : 0;
   }
 
-  // Modulus. Note the weird y = 0 case for Matlab compatibility.
+  // Modulus.  Note the weird y = 0 case for Matlab compatibility.
   static T
   mod (T x, T y)
   {
     if (y != 0)
       {
         T r = x % y;
         return ((r < 0) != (y < 0)) ? r + y : r;
       }
@@ -1020,17 +1021,17 @@ operator >> (std::istream& is, octave_in
   is >> tmp;
   ival = tmp;
   return is;
 }
 
 // We need to specialise for char and unsigned char because
 // std::operator<< and std::operator>> are overloaded to input and
 // output the ASCII character values instead of a representation of
-// their numerical value (e.g. os << char(10) outputs a space instead
+// their numerical value (e.g., os << char(10) outputs a space instead
 // of outputting the characters '1' and '0')
 
 template <>
 inline std::ostream&
 operator << (std::ostream& os, const octave_int<int8_t>& ival)
 {
   os << static_cast<int> (ival.value ());
   return os;
diff --git a/liboctave/util/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
--- a/liboctave/util/oct-locbuf.cc
+++ b/liboctave/util/oct-locbuf.cc
@@ -42,30 +42,30 @@ const size_t octave_chunk_buffer::chunk_
 
 char *octave_chunk_buffer::top = 0;
 char *octave_chunk_buffer::chunk = 0;
 size_t octave_chunk_buffer::left = 0;
 size_t octave_chunk_buffer::active = 0;
 
 octave_chunk_buffer::octave_chunk_buffer (size_t size) : cnk (0), dat (0)
 {
-  // Alignment mask. The size of double or long int, whichever is
+  // Alignment mask.  The size of double or long int, whichever is
   // greater.  All data will be aligned to this size.  If it's not
   // enough for a type, that type should not be declared as POD.
 
   static const size_t align_mask = (sizeof (long) < sizeof (double)
                                     ? sizeof (double)
                                     : sizeof (long)) - 1;
 
   active++;
 
   if (! size)
     return;
 
-  // Align size. Note that size_t is unsigned, so size-1 must correctly
+  // Align size.  Note that size_t is unsigned, so size-1 must correctly
   // wrap around.
 
   size = ((size - 1) | align_mask) + 1;
 
   if (size > left)
     {
       // Big buffers (> 1/8 chunk) will be allocated as stand-alone and
       // won't disrupt the chain.
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -162,17 +162,17 @@ public:
 
   operator const T **() const
   {
     return reinterpret_cast<const T **> (this->data ());
   }
 };
 
 // If the compiler supports dynamic stack arrays, we can use the
-// attached hack to place small buffer arrays on the stack. It may be
+// attached hack to place small buffer arrays on the stack.  It may be
 // even faster than our obstack-like optimization, but is dangerous
 // because stack is a very limited resource, so we disable it.
 
 #if 0 // defined (HAVE_DYNAMIC_AUTO_ARRAYS)
 
 // Maximum buffer size (in bytes) to be placed on the stack.
 
 #define OCTAVE_LOCAL_BUFFER_MAX_STACK_SIZE 8192
diff --git a/liboctave/util/oct-refcount.h b/liboctave/util/oct-refcount.h
--- a/liboctave/util/oct-refcount.h
+++ b/liboctave/util/oct-refcount.h
@@ -52,17 +52,17 @@ along with Octave; see the file COPYING.
 template <typename T>
 class octave_refcount
 {
 public:
   typedef T count_type;
 
   octave_refcount(count_type initial_count) : count(initial_count) { }
 
-  // Increment/Decrement. int is postfix.
+  // Increment/Decrement.  int is postfix.
   count_type operator++(void)
   {
     return OCTREFCOUNT_ATOMIC_INCREMENT (&count);
   }
 
   count_type operator++(int)
   {
     return OCTREFCOUNT_ATOMIC_INCREMENT_POST (&count);
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -164,17 +164,17 @@ namespace octave
 
     ~octave_dlopen_shlib (void);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     // FIXME: this is possibly redundant because failure to open a library will
     // normally throw an exception, avoiding the construction of an invalid
-    // library. Leave it here for possible future use.
+  // library.  Leave it here for possible future use.
 
     bool is_open (void) const { return (library != 0); }
 
   private:
 
     // No copying!
 
     octave_dlopen_shlib (const octave_dlopen_shlib&);
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -16,42 +16,42 @@ ANY WARRANTY; without even the implied w
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 Code stolen in large part from Python's, listobject.c, which itself had
-no license header. However, thanks to Tim Peters for the parts of the
+no license header.  However, thanks to Tim Peters for the parts of the
 code I ripped-off.
 
 As required in the Python license the short description of the changes
 made are
 
 * convert the sorting code in listobject.cc into a generic class,
   replacing PyObject* with the type of the class T.
 
 * replaced usages of malloc, free, memcpy and memmove by standard C++
-  new [], delete [] and std::copy and std::copy_backward. Note that replacing
+  new [], delete [] and std::copy and std::copy_backward.  Note that replacing
   memmove by std::copy is possible if the destination starts before the source.
   If not, std::copy_backward needs to be used.
 
 * templatize comparison operator in most methods, provide possible dispatch
 
 * duplicate methods to avoid by-the-way indexed sorting
 
 * add methods for verifying sortedness of array
 
 * row sorting via breadth-first tree subsorting
 
 * binary lookup and sequential binary lookup optimized for dense downsampling.
 
 * NOTE: the memory management routines rely on the fact that delete [] silently
-  ignores null pointers. Don't gripe about the missing checks - they're there.
+  ignores null pointers.  Don't gripe about the missing checks - they're there.
 
 
 The Python license is
 
   PSF LICENSE AGREEMENT FOR PYTHON 2.3
   --------------------------------------
 
   1. This LICENSE AGREEMENT is between the Python Software Foundation
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -14,17 +14,17 @@ ANY WARRANTY; without even the implied w
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 Code stolen in large part from Python's, listobject.c, which itself had
-no license header. However, thanks to Tim Peters for the parts of the
+no license header.  However, thanks to Tim Peters for the parts of the
 code I ripped-off.
 
 As required in the Python license the short description of the changes
 made are
 
 * convert the sorting code in listobject.cc into a generic class,
   replacing PyObject* with the type of the class T.
 
@@ -145,17 +145,17 @@ public:
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value);
 
   // Ditto, but for an array.
   void lookup (const T *data, octave_idx_type nel,
                const T* values, octave_idx_type nvalues,
                octave_idx_type *idx);
 
-  // A linear merge of two sorted tables. rev indicates the second table is
+  // A linear merge of two sorted tables.  rev indicates the second table is
   // in reverse order.
   void lookup_sorted (const T *data, octave_idx_type nel,
                       const T* values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev = false);
 
   // Rearranges the array so that the elements with indices
   // lo..up-1 are in their correct place.
   void nth_element (T *data, octave_idx_type nel,
diff --git a/liboctave/util/sparse-sort.cc b/liboctave/util/sparse-sort.cc
--- a/liboctave/util/sparse-sort.cc
+++ b/liboctave/util/sparse-sort.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cstring>
 
 #include "oct-sort.cc"
 #include "quit.h"
 
 #include "sparse-sort.h"
 
 // A simple class and instantiation of the octave merge sort class
-// to sort sparse data before matrix creation. This is significantly
+// to sort sparse data before matrix creation.  This is significantly
 // faster than using octave_qsort.
 
 bool
 octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
                           octave_sparse_sort_idxl* j)
 {
   octave_idx_type tmp = i->c - j->c;
   if (tmp < 0)
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -105,20 +105,19 @@ namespace octave
 
     // No copying!
 
     unwind_protect (const unwind_protect&);
 
     unwind_protect& operator = (const unwind_protect&);
   };
 
-  // Like unwind_protect, but this one will guard against the
-  // possibility of seeing an exception (or interrupt) in the cleanup
-  // actions. Not that we can do much about it, but at least we won't
-  // crash.
+  // Like unwind_protect, but this one will guard against the possibility
+  // of seeing an exception (or interrupt) in the cleanup actions.
+  // Not that we can do much about it, but at least we won't crash.
 
   class
   OCTAVE_API
   unwind_protect_safe : public unwind_protect
   {
   private:
 
     void warn_unhandled_exception (void) const;
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -533,17 +533,17 @@ namespace octave
       url = "ftp://" + host_or_url + "/" + path + "/" + filename;
       SETOPT (CURLOPT_URL, url.c_str ());
       SETOPT (CURLOPT_FILETIME, 1);
       SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
       SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
-      // so this is a means of testing for directories. It also means
+      // so this is a means of testing for directories.  It also means
       // I can't get the date of directories!
 
       perform ();
       if (! good ())
         {
           fileisdir = true;
           filetime = -1;
           filesize = 0;
@@ -561,17 +561,17 @@ namespace octave
 
       SETOPT (CURLOPT_WRITEFUNCTION, write_data);
       SETOPT (CURLOPT_HEADERFUNCTION, 0);
       SETOPT (CURLOPT_FILETIME, 0);
       url = "ftp://" + host_or_url;
       SETOPT (CURLOPT_URL, url.c_str ());
 
       // The MDTM command seems to reset the path to the root with the
-      // servers I tested with, so cd again into the correct path. Make
+      // servers I tested with, so cd again into the correct path.  Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
     }
 
     std::string pwd (void)
     {
       std::string retval;
@@ -648,26 +648,26 @@ namespace octave
 
     // Pointer to cURL object.
     CURL *curl;
 
     // cURL error code.
     CURLcode errnum;
 
     // The cURL library changed the curl_easy_setopt call to make an
-    // internal copy of string parameters in version 7.17.0. Prior
+    // internal copy of string parameters in version 7.17.0.  Prior
     // versions only held a pointer to a string provided by the caller
     // that must persist for the lifetime of the CURL handle.
     //
     // The associated API did not change, only the behavior of the library
     // implementing the function call.
     //
     // To be compatible with any version of cURL, the caller must keep a
     // copy of all string parameters associated with a CURL handle until
-    // the handle is released. The curl_handle::curl_handle_rep class
+    // the handle is released.  The curl_handle::curl_handle_rep class
     // contains the pointer to the CURL handle and so is the best
     // candidate for storing the strings as well. (bug #36717)
     std::string url;
     std::string userpwd;
 
     // No copying!
 
     curl_transfer (const curl_transfer&);
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -159,18 +159,18 @@ function A = accumarray (subs, vals, sz 
   endif
 
   if (isempty (issparse))
     issparse = false;
   endif
 
   if (issparse)
 
-    ## Sparse case. Avoid linearizing the subscripts, because it could
-    ## overflow.
+    ## Sparse case.
+    ## Avoid linearizing the subscripts, because it could overflow.
 
     if (fillval != 0)
       error ("accumarray: FILLVAL must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
     if (iscell (subs))
       subs = [subs{:}];
@@ -186,17 +186,17 @@ function A = accumarray (subs, vals, sz 
     if (isnumeric (vals) || islogical (vals))
       vals = double (vals);
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
-      ## Reduce values. This is not needed if we're about to sum them,
+      ## Reduce values.  This is not needed if we're about to sum them,
       ## because "sparse" can do that.
 
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
@@ -319,33 +319,33 @@ function A = accumarray (subs, vals, sz 
 
       if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
         mask = true (size (A));
         mask(subs) = false;
         A(mask) = fillval;
       endif
     else
 
-      ## The general case. Reduce values.
+      ## The general case.  Reduce values.
       n = rows (subs);
       if (numel (vals) == 1)
         vals = vals(ones (1, n), 1);
       else
         vals = vals(:);
       endif
 
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       if (n != 0) # bug #47287
         jdx = [jdx; n];
       endif
       vals = mat2cell (vals(idx), diff ([0; jdx]));
-      ## Optimize the case when function is @(x) {x}, i.e. we just want
+      ## Optimize the case when function is @(x) {x}, i.e., we just want
       ## to collect the values to cells.
       persistent simple_cell_str = func2str (@(x) {x});
       if (! strcmp (func2str (func), simple_cell_str))
         vals = cellfun (func, vals);
       endif
 
       subs = subs(jdx);
 
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -120,17 +120,17 @@ function A = accumdim (subs, vals, dim, 
   jdx = find (subs(1:ns-1) != subs(2:ns));
   jdx = [jdx; ns];
   ## Collect common slices.
   szc = num2cell (sz);
   szc{dim} = diff ([0; jdx]);
   subsc = {':'}(ones (1, length (sz)));
   subsc{dim} = idx;
   vals = mat2cell (vals(subsc{:}), szc{:});
-  ## Apply reductions. Special case min, max.
+  ## Apply reductions.  Special case min, max.
   if (func == @min || func == @max)
     vals = cellfun (func, vals, {[]}, {dim}, "uniformoutput", false);
   else
     vals = cellfun (func, vals, {dim}, "uniformoutput", false);
   endif
   subs = subs(jdx);
 
   ## Concatenate reduced slices.
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -4,17 +4,17 @@
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{p} =} inputParser ()
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -42,18 +42,18 @@
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 ## Author: Carn Draug <carandraug+dev@gmail.com>
 
 function msg = nargoutchk (minargs, maxargs, nargs, outtype)
 
   ## before matlab's 2011b, nargoutchk would return an error message (just the
-  ## message in a string). With 2011b, it no longer returns anything, it simply
-  ## gives an error if the args number is incorrect.
+  ## message in a string).  With 2011b, it no longer returns anything, it
+  ## simply gives an error if the args number is incorrect.
   ## To try to keep compatibility with both versions, check nargout and nargin
   ## to guess if the caller is expecting a value (old syntax)
   ## or none (new syntax).
 
   if (nargout == 1 && (nargin == 3 || nargin == 4))
 
     if (minargs > maxargs)
       error ("nargoutchk: MINARGS must be <= MAXARGS");
diff --git a/scripts/general/validateattributes.m b/scripts/general/validateattributes.m
--- a/scripts/general/validateattributes.m
+++ b/scripts/general/validateattributes.m
@@ -4,17 +4,17 @@
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} validateattributes (@var{A}, @var{classes}, @var{attributes})
@@ -164,16 +164,17 @@
 ## Values are arranged in a single vector (column or vector).
 ##
 ## @end table
 ##
 ## @seealso{isa, validatestring, inputParser}
 ## @end deftypefn
 
 function validateattributes (A, cls, attr, varargin)
+
   if (nargin < 3 || nargin > 6)
     print_usage ();
   elseif (! iscellstr (cls))
     error ("validateattributes: CLASSES must be a cell array of strings");
   elseif (! iscell (attr))
     error ("validateattributes: ATTRIBUTES must be a cell array");
   endif
 
@@ -223,26 +224,26 @@ function validateattributes (A, cls, att
     cls = unique (cls);
 
     classes = sprintf (" %s", cls{:});
     error ("%s must be of class:\n\n %s\n\nbut was of class %s",
            err_ini, classes, class (A));
   endif
 
   ## We use a while loop because some attributes require the following value
-  ## in the cell array. Also, we can't just get the boolean value for the
+  ## in the cell array.  Also, we can't just get the boolean value for the
   ## test and check at the end the error message since some of the tests
   ## require some more complex error message.
 
   ## It may look like that we don't perform enough input check in this
   ## function (e.g., we don't check if there's a value after the size
-  ## attribute). The reasoning is that this will be a function mostly used
+  ## attribute).  The reasoning is that this will be a function mostly used
   ## by developers with fairly static input so any problem would be caught
-  ## immediately during that functino development, it's no dependent on the
-  ## final user input. In addition, it can be called so many times at the
+  ## immediately during that function development, it's no dependent on the
+  ## final user input.  In addition, it can be called so many times at the
   ## start of every function, we want it to run specially fast.
   idx = 1;
   problem = false; # becomes true when one of the tests fails
   while (idx <= numel (attr))
     ## FIXME: once we use this in Octave core, it might be worthy to find
     ## which attributes are checked more often, and place them in that
     ## order inside the switch block.
     switch (tolower (attr{idx++}))
@@ -297,17 +298,17 @@ function validateattributes (A, cls, att
           error ("%s must have %d columns", err_ini, attr{idx-1});
         endif
       case "nrows",
         if (rows (A) != attr{idx++})
           error ("%s must have %d rows", err_ini, attr{idx-1});
         endif
       case "ndims",
         ## Note that a [4 5 1] matrix is not considered to have ndims == 3
-        ## but is ok for "3d". This is not a bug.
+        ## but is ok for "3d".  This is not a bug.
         if (ndims (A) != attr{idx++})
           error ("%s must have %d dimensions", err_ini, attr{idx-1});
         endif
       case ">"
         if (! all (A(:) > attr{idx++}))
           error ("%s must be greater than %f", err_ini, attr{idx-1});
         endif
       case ">="
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -43,35 +43,35 @@ function [idx, p] = tsearchn (x, t, xi)
 
   ni = [1:mi].';
   for i = 1 : nt
     ## Only calculate the Barycentric coordinates for points that have not
     ## already been found in a triangle.
     b = cart2bary (x (t (i, :), :), xi(ni,:));
 
     ## Our points xi are in the current triangle if
-    ## (all (b >= 0) && all (b <= 1)). However as we impose that
-    ## sum (b,2) == 1 we only need to test all(b>=0). Note need to add
+    ## (all (b >= 0) && all (b <= 1)).  However as we impose that
+    ## sum (b,2) == 1 we only need to test all(b>=0).  Note need to add
     ## a small margin for rounding errors
     intri = all (b >= -1e-12, 2);
     idx(ni(intri)) = i;
     p(ni(intri),:) = b(intri, :);
     ni(intri) = [];
   endfor
 endfunction
 
 function Beta = cart2bary (T, P)
   ## Conversion of Cartesian to Barycentric coordinates.
   ## Given a reference simplex in N dimensions represented by a
   ## (N+1)-by-(N) matrix, and arbitrary point P in cartesion coordinates,
   ## represented by a N-by-1 row vector can be written as
   ##
   ## P = Beta * T
   ##
-  ## Where Beta is a N+1 vector of the barycentric coordinates. A criteria
+  ## Where Beta is a N+1 vector of the barycentric coordinates.  A criteria
   ## on Beta is that
   ##
   ## sum (Beta) == 1
   ##
   ## and therefore we can write the above as
   ##
   ## P - T(end, :) = Beta(1:end-1) * (T(1:end-1,:) - ones (N,1) * T(end,:))
   ##
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -109,18 +109,18 @@ function [vx, vy] = voronoi (varargin)
   endif
 
   if (length (x) != length (y))
     error ("voronoi: X and Y must be vectors of the same length");
   elseif (length (x) < 2)
     error ("voronoi: minimum of 2 points needed");
   endif
 
-  ## Add box to approximate rays to infinity. For Voronoi diagrams the
-  ## box can (and should) be close to the points themselves. To make the
+  ## Add box to approximate rays to infinity.  For Voronoi diagrams the
+  ## box can (and should) be close to the points themselves.  To make the
   ## job of finding the exterior edges it should be at least two times the
   ## delta below however
   xmax = max (x(:));
   xmin = min (x(:));
   ymax = max (y(:));
   ymin = min (y(:));
   xdelta = xmax - xmin;
   ydelta = ymax - ymin;
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -20,29 +20,29 @@
 ## @deftypefn  {} {[@var{retval}, @var{status}] =} __makeinfo__ (@var{text}, @var{output_type})
 ## @deftypefnx {} {[@var{retval}, @var{status}] =} __makeinfo__ (@var{text}, @var{output_type}, @var{see_also})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Run @code{makeinfo} on a given text.
 ##
 ## The string @var{text} is run through the @code{__makeinfo__} program
-## to generate output in various formats. This string must contain valid
+## to generate output in various formats.  This string must contain valid
 ## Texinfo formatted text.
 ##
-## The @var{output_type} selects the format of the output. This can be either
-## @t{"html"}, @t{"texinfo"}, or @t{"plain text"}. By default this is
-## @t{"plain text"}. If @var{output_type} is @t{"texinfo"}, the @t{@@seealso}
+## The @var{output_type} selects the format of the output.  This can be either
+## @t{"html"}, @t{"texinfo"}, or @t{"plain text"}.  By default this is
+## @t{"plain text"}.  If @var{output_type} is @t{"texinfo"}, the @t{@@seealso}
 ## macro is expanded, but otherwise the text is unaltered.
 ##
 ## If the optional argument @var{see_also} is present, it is used to expand the
-## Octave specific @t{@@seealso} macro. This argument must be a function handle,
+## Octave specific @t{@@seealso} macro.  This argument must be a function handle,
 ## that accepts a cell array of strings as input argument (each elements of the
 ## array corresponds to the arguments to the @t{@@seealso} macro), and return
-## the expanded string. If this argument is not given, the @t{@@seealso} macro
+## the expanded string.  If this argument is not given, the @t{@@seealso} macro
 ## will be expanded to the text
 ##
 ## @example
 ## See also: arg1, arg2, ...
 ## @end example
 ##
 ## @noindent
 ## for @t{"plain text"} output, and
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -529,17 +529,17 @@ function txt = check_package (fcn, name)
   txt = sprintf ("the '%s' function belongs to the %s package from Octave Forge",
                  fcn, name);
 
   [~, status] = pkg ("describe", name);
   switch (tolower (status{1}))
     case "loaded",
       txt = sprintf ("%s but has not yet been implemented.", txt);
     case "not loaded",
-      txt = sprintf (["%s which you have installed but not loaded. To ", ...
+      txt = sprintf (["%s which you have installed but not loaded.  To ", ...
                       "load the package, run `pkg load %s' from the ", ...
                       "Octave prompt."], txt, name);
     otherwise
       ## this includes "not installed" and anything else if pkg changes
       ## the output of describe
       txt = sprintf ("%s which seems to not be installed in your system.", txt);
   endswitch
 endfunction
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -87,25 +87,25 @@ function [text, status] = first_sentence
   ## ... or a double end-of-line (we subtract 1 because we are not interested
   ## in capturing the first newline).
   line_end_idx = regexp (help_text, "\n\n", "once") - 1;
   text = help_text (1:min ([period_idx; line_end_idx; max_len; length(help_text)]));
   status = 0;
 endfunction
 
 ## This function extracts the first sentence from a Texinfo help text.
-## The function works by removing @def* from the texinfo text. After this, we
+## The function works by removing @def* from the texinfo text.  After this, we
 ## render the text to plain text using makeinfo, and then extract the first
 ## line.
 function [text, status] = first_sentence_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
-  ## Find, and remove, lines that start with @def. This should remove things
+  ## Find, and remove, lines that start with @def.  This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
   if (! isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
       endl = endl_idx(find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -99,17 +99,17 @@ function [retval, status] = get_usage_pl
   status = 0;
 endfunction
 
 function [retval, status] = get_usage_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
 
-  ## Find, and keep, lines that start with @def or @end def. This should
+  ## Find, and keep, lines that start with @def or @end def.  This should
   ## include things such as @deftypefn, @deftypefnx, @defvar, etc. and their
   ## corresponding @end's.
   def_idx = strfind (help_text, "@def");
   if (! isempty (def_idx))
     endf_idx = strfind (help_text, "@end def");
     def_idx = sort ([def_idx, endf_idx]);
     endl_idx = find (help_text == "\n");
     buffer = "";
diff --git a/scripts/image/imformats.m b/scripts/image/imformats.m
--- a/scripts/image/imformats.m
+++ b/scripts/image/imformats.m
@@ -95,17 +95,17 @@ function varargout = imformats (arg1, ar
           arrayfun (@is_valid_format, arg2);
           formats(end + 1: end + numel (arg2)) = arg2;
           varargout{1} = formats;
 
         case {"remove", "update"},
           if (! ischar (arg2))
             error ("imformats: EXT to %s must be a string.", arg1);
           endif
-          ## FIXME: suppose a format with multiple extensions. If one of
+          ## FIXME: suppose a format with multiple extensions.  If one of
           ##        them is requested to be removed, should we remove the
           ##        whole format, or just that extension from the format?
           match = find_ext_idx (formats, arg2);
           if (! any (match))
             error ("imformats: no EXT `%s' found.", arg2);
           endif
           if (strcmpi (arg1, "remove"))
             formats(match) = [];
@@ -120,17 +120,17 @@ function varargout = imformats (arg1, ar
           varargout{1} = formats;
 
         case "factory",
           formats = default_formats ();
         otherwise
           ## then we look for a format with that extension.
           match = find_ext_idx (formats, arg1);
           ## For matlab compatibility, if we don't find any format we must
-          ## return an empty struct with NO fields. We can't use match as mask
+          ## return an empty struct with NO fields.  We can't use match as mask
           if (any (match))
             varargout{1} = formats(match);
           else
             varargout{1} = struct ();
           endif
       endswitch
     else
       error ("imformats: first argument must be either a structure or string.");
@@ -138,28 +138,28 @@ function varargout = imformats (arg1, ar
   else
     varargout{1} = formats;
   endif
 endfunction
 
 function formats = default_formats ()
 
   ## The available formats are dependent on what the user has installed at
-  ## a given time, and how GraphicsMagick was built. Checking for
+  ## a given time, and how GraphicsMagick was built.  Checking for
   ## GraphicsMagick features when building Octave is not enough since it
   ## delegates some of them to external programs which can be removed or
   ## installed at any time.
   ## The recommended method would be to use CoderInfoList() to get a list of
   ## all available coders and try to write and read back a small test image.
   ## But this will not work since some coders are readable or writable only.
   ## It will still fail if we test only the ones marked as readable and
   ## writable because some RW coders are not of image formats (NULL, 8BIM,
   ## or EXIF for example).
   ## So we'd need a blacklist (unacceptable because a `bad' coder may be
-  ## added later) or a whitelist. A whitelist means that even with a
+  ## added later) or a whitelist.  A whitelist means that even with a
   ## super-fancy recent build of GraphicsMagick, some formats won't be listed
   ## by imformats but in truth, we will still be able to read and write them
   ## since imread() and imwrite() will give it a try anyway.
   ##
   ## For more info and comments from the GraphicsMagick main developer, see
   ## http://sourceforge.net/mailarchive/forum.php?thread_name=alpine.GSO.2.01.1304301916050.2267%40freddy.simplesystems.org&forum_name=graphicsmagick-help
 
   persistent formats = struct ( "coder", {},
@@ -176,62 +176,62 @@ function formats = default_formats ()
   ## there's no need to go and calculate it all over again if we are
   ## requested to reset back to factory.
   if (! isempty (formats))
     return;
   endif
 
   ##      Building the formats info
   ##
-  ## As mentioned above we start with a whitelist of coders. Since the
+  ## As mentioned above we start with a whitelist of coders.  Since the
   ## GraphicsMagick build may be missing some coders, we will remove those
-  ## from the list. Some info can be obtained directly from GraphicsMagick
-  ## through the CoderInfo object. However, some will need to be hardcoded.
+  ## from the list.  Some info can be obtained directly from GraphicsMagick
+  ## through the CoderInfo object.  However, some will need to be hardcoded.
   ##
   ## The association between file extensions and coders needs to be done
   ## with a manually coded list (file extensions do not define the image
   ## format and GraphicsMagick will not be fooled by changing the extension).
   ##
   ## We can get the read, write, description and multipage fields from
-  ## CoderInfo in C++. We should do the same for alpha (GraphicsMagick
-  ## calls it matte) but it's not available from CoderInfo. The only way to
+  ## CoderInfo in C++.  We should do the same for alpha (GraphicsMagick
+  ## calls it matte) but it's not available from CoderInfo.  The only way to
   ## check it is to create a sample image with each coder, then try to read
   ## it back with GraphicsMagick and use the matte method on the Image class.
   ## But making such test for each Octave session... meh! While technically
   ## it may be possible that the same coder has different support for alpha
   ## channel in different versions and builds, this doesn't seem to happen.
-  ## So we also hardcode those. In the future, maybe the CoderInfo class will
+  ## So we also hardcode those.  In the future, maybe the CoderInfo class will
   ## have a matte method like it does for multipage.
   ##
-  ## Other notes: some formats have more than one coder that do the same. For
-  ## example, for jpeg images there is both the JPG and JPEG coders. However,
+  ## Other notes: some formats have more than one coder that do the same.  For
+  ## example, for jpeg images there is both the JPG and JPEG coders.  However,
   ## it seems that when reading images, GraphicsMagick only uses one of them
   ## and that's the one we list (it's the one reported by imfinfo and that we
-  ## can use for isa). However, in some cases GraphicsMagick seems to rely
-  ## uniquely on the file extension ((JBIG and JBG at least. Create an image
+  ## can use for isa).  However, in some cases GraphicsMagick seems to rely
+  ## uniquely on the file extension (JBIG and JBG at least.  Create an image
   ## with each of those coders, swap their extension and it will report the
-  ## other coder). We don't have such cases on the whitelist but if we did, we
+  ## other coder).  We don't have such cases on the whitelist but if we did, we
   ## would need two entries for such cases.
 
   ## each row: 1st => Coder, 2nd=> file extensions, 3rd=> alpha
   coders = {"BMP",  {"bmp"},          true;
             "CUR",  {"cur"},          false;
             "GIF",  {"gif"},          true;
             "ICO",  {"ico"},          true;
             "JBG",  {"jbg"},          false;
             "JBIG", {"jbig"},         false;
             "JP2",  {"jp2", "jpx"},   true;
             "JPEG", {"jpg", "jpeg"},  false; # there is also a JPG coder
             "PBM",  {"pbm"},          false;
             "PCX",  {"pcx"},          true;
             "PGM",  {"pgm"},          false;
             "PNG",  {"png"},          true;
             ## PNM is a family of formats supporting portable bitmaps (PBM),
-            ## graymaps (PGM), and pixmaps (PPM). There is no file format
-            ## associated with pnm itself. If PNM is used as the output format
+            ## graymaps (PGM), and pixmaps (PPM).  There is no file format
+            ## associated with pnm itself.  If PNM is used as the output format
             ## specifier, then GraphicsMagick automatically selects the most
             ## appropriate format to represent the image.
             "PNM",  {"pnm"},          true;
             "PPM",  {"ppm"},          false;
             "SUN",  {"ras"},          true; # SUN Rasterfile
             "TGA",  {"tga", "tpic"},  true;
             "TIFF", {"tif", "tiff"},  true;
             "XBM",  {"xbm"},          false;
@@ -252,17 +252,17 @@ function formats = default_formats ()
   [formats.read ] = deal (@__imread__);
   [formats.write] = deal (@__imwrite__);
 
   ## fills rest of format information by checking with GraphicsMagick
   formats = __magick_formats__ (formats);
 endfunction
 
 function is_valid_format (format)
-  ## the minimal list of fields required in the structure. We don't
+  ## the minimal list of fields required in the structure.  We don't
   ## require multipage because it doesn't exist in matlab
   min_fields  = {"ext", "read", "isa", "write", "info", "alpha", "description"};
   fields_mask = isfield (format, min_fields);
   if (! all (fields_mask))
     error ("imformats: structure has missing field `%s'.", min_fields(! fields_mask){1});
   endif
 endfunction
 
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -105,17 +105,17 @@ function imwrite (varargin)
   fmt = imformats (ext);
   ## When there is no match, fmt will be a 1x1 structure with
   ## no fields, so we can't just use `isempty (fmt)'.
   if (numfields (fmt) == 0)
     if (isempty (ext))
       error ("imwrite: no extension found for %s to identify the image format",
              filename);
     endif
-    warning ("imwrite: unlisted image format %s (see imformats). Trying to save anyway.",
+    warning ("imwrite: unlisted image format %s (see imformats).  Trying to save anyway.",
              ext);
     __imwrite__ (varargin{:});
   else
     fmt.write (varargin{:});
   endif
 
 endfunction
 
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -49,17 +49,17 @@ function I = ind2gray (x, map)
 
   ## Convert colormap to luminance intensity values
   map *= [0.29894; 0.58704; 0.11402];
 
   ## Convert colormap to same class as that of input so that reshape
   ## will produce output of the same type as the input.
   cls = class (x);
   if (isinteger (x))
-    ## if we later add support for int16 images, this will not work. Look into
+    ## if we later add support for int16 images, this will not work.  Look into
     ## im2int16 from image package for such case
     map *= intmax (cls);
   elseif (strcmp (cls, "single"))
     map = single (map);
   endif
 
   ## Replace indices in the input matrix with the indexed luminance value.
   I = reshape (map(x(:)), size (x));
diff --git a/scripts/image/private/__imfinfo__.m b/scripts/image/private/__imfinfo__.m
--- a/scripts/image/private/__imfinfo__.m
+++ b/scripts/image/private/__imfinfo__.m
@@ -12,19 +12,19 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## This function does all the work of imfinfo. It exists here as private
+## This function does all the work of imfinfo.  It exists here as private
 ## function so that imfinfo can use other functions if imformats is
-## configured to. It is also needed so that imformats can create a
+## configured to.  It is also needed so that imformats can create a
 ## function handle for it.
 
 ## Author: Soren Hauberg <hauberg@gmail.com>
 
 function info = __imfinfo__ (filename)
 
   if (nargin != 1)
     print_usage ("imfinfo");
diff --git a/scripts/image/private/__imwrite__.m b/scripts/image/private/__imwrite__.m
--- a/scripts/image/private/__imwrite__.m
+++ b/scripts/image/private/__imwrite__.m
@@ -12,19 +12,19 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## This function does all the work of imwrite. It exists here as private
+## This function does all the work of imwrite.  It exists here as private
 ## function so that imwrite can use other functions if imformats is
-## configured to. It is also needed so that imformats can create a
+## configured to.  It is also needed so that imformats can create a
 ## function handle for it.
 
 function __imwrite__ (img, varargin)
 
   if (nargin < 2 || ! (isnumeric (img) || islogical (img)))
     print_usage ("imwrite");
   endif
 
@@ -129,24 +129,24 @@ function __imwrite__ (img, varargin)
       case "loopcount"
         options.loopcount = param_list{idx+1};
         if (! isscalar (options.loopcount) || ! isnumeric (options.loopcount)
             || (! isinf (options.loopcount)
                 && (options.loopcount < 0 || options.loopcount > 65535)))
           error ("imwrite: value for %s must be Inf or between 0 and 65535",
                  param_list{idx});
         endif
-        ## Graphics Magick is a bit weird here. A value of 0 will be an
+        ## Graphics Magick is a bit weird here.  A value of 0 will be an
         ## infinite loop, a value of 1, will really be no loop, while a
         ## value of 2 or more will be that number of loops (checked
-        ## with GNOME image viewer). This means that there is no way
-        ## to make it loop only once. See
+        ## with GNOME image viewer).  This means that there is no way
+        ## to make it loop only once.  See
         ## https://sourceforge.net/p/graphicsmagick/bugs/249/
         ## There is also the problem of setting this when there is only
-        ## a single frame. See
+        ## a single frame.  See
         ## https://sourceforge.net/p/graphicsmagick/bugs/248/
         if (isinf (options.loopcount))
           options.loopcount = 0;
         elseif (options.loopcount == 0 || options.loopcount == 1)
           options.loopcount += 1;
         endif
         options.loopcount = floor (options.loopcount);
 
@@ -184,22 +184,22 @@ function __imwrite__ (img, varargin)
     ## Fill in the colormap as required with rgb (0, 0, 0) (bug #33615)
     nColors = rows (map);
     if (any (strcmp (class (img), {"uint8", "uint16", "logical"})))
       required_colors = max (img(:)) +1;
     else
       required_colors = max (img(:));
     endif
     if (nColors < required_colors)
-      warning ("imwrite: MAP has not enough colors. Filling with black");
+      warning ("imwrite: MAP has not enough colors.  Filling with black");
       map(nColors+1:required_colors,:) = 0;
     endif
 
     ## If the image is floating point, then we convert it to integer (makes
-    ## it easier in __magick_write__ since it only handles integers. Also,
+    ## it easier in __magick_write__ since it only handles integers.  Also,
     ## if it's floating point, it has an offset of 1
     if (isfloat (img))
       if (rows (map) <= 256)
         img = uint8 (img - 1);
       else
         img = uint16 (img - 1);
       endif
     endif
diff --git a/scripts/image/private/colorspace_conversion_input_check.m b/scripts/image/private/colorspace_conversion_input_check.m
--- a/scripts/image/private/colorspace_conversion_input_check.m
+++ b/scripts/image/private/colorspace_conversion_input_check.m
@@ -35,17 +35,17 @@ function [in_arg, sz, is_im, is_nd] ...
     elseif (size (in_arg, 3) != 3)
       error ("%s: %s must be a colormap or %s image", func, arg_name, arg_name);
     elseif (! isreal (in_arg) || ! isnumeric (in_arg))
       error ("%s: %s must be numeric and real", func, arg_name);
     endif
     is_im = true;
 
     ## For floating point values, R, G and B should be in the [0 1] range,
-    ## otherwise they don't make any sense. We accept those values
+    ## otherwise they don't make any sense.  We accept those values
     ## anyways because we must return something for Matlab compatibility.
     ## User case is when a function returns an RGB image just slightly outside
     ## the range due to floating point rounding errors.
 
     ## Allow for ND images, i.e., multiple images on the 4th dimension.
     nd = ndims (in_arg);
     if (nd == 3)
       is_nd = false;
diff --git a/scripts/image/private/imageIO.m b/scripts/image/private/imageIO.m
--- a/scripts/image/private/imageIO.m
+++ b/scripts/image/private/imageIO.m
@@ -29,17 +29,17 @@
 ## Usage:
 ##
 ## func      - Function name to use on error message.
 ## core_func - Function handle for the default function to use if we can't
 ##             find the format in imformats.
 ## fieldname - Name of the field in the struct returned by imformats that
 ##             has the function to use.
 ## filename  - Most likely the first input argument from the function that
-##             called this. May be missing the file extension which can be
+##             called this.  May be missing the file extension which can be
 ##             on varargin.
 ## varargin  - Followed by all the OTHER arguments passed to imread and
 ##             imfinfo.
 
 function varargout = imageIO (func, core_func, fieldname, filename, varargin)
 
   ## First thing: figure out the filename and possibly download it.
   ## The first attempt is to try the filename and see if it exists.  If it
diff --git a/scripts/image/private/imwrite_filename.m b/scripts/image/private/imwrite_filename.m
--- a/scripts/image/private/imwrite_filename.m
+++ b/scripts/image/private/imwrite_filename.m
@@ -40,17 +40,17 @@ function [filename, ext, cmap, options] 
     cmap = varargin{1};
   else
     error ("imwrite: no FILENAME specified");
   endif
   filename = tilde_expand (varargin{filename_idx});
 
   ## Next, we get the file extension.
   ## if we have an odd number of leftover arguments, and the next argument
-  ## is a string, we consider it the file extension. Otherwise we will
+  ## is a string, we consider it the file extension.  Otherwise we will
   ## extract what we can from the previously found filename.
   options_idx = filename_idx + 1;
   if (numel (varargin) > filename_idx
       && rem (length (varargin) - filename_idx, 2) != 0
       && ischar (varargin{filename_idx + 1}))
     ext = varargin{filename_idx + 1};
     options_idx += 1;
   else
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -80,17 +80,17 @@ function [x, map] = rgb2ind (R, G, B)
     case {"uint8", "uint16"}
       map = double (map) / double (intmax (class (R)));
     case "int16"
       map = (double (im) + 32768) / 65535;
     otherwise
       error ("rgb2ind: unsupported image class %s", im_class);
   endswitch
 
-  ## we convert to the smallest class necessary to encode the image. Matlab
+  ## we convert to the smallest class necessary to encode the image.  Matlab
   ## documentation does not mention what it does when uint16 is not enough...
   ## When an indexed image is of integer class, there's a -1 offset to the
   ## colormap, hence the adjustment
   if (rows (map) < 256)
     x = uint8 (x - 1);
   elseif (rows (map) < 65536)
     x = uint16 (x - 1);
   else
@@ -100,17 +100,17 @@ function [x, map] = rgb2ind (R, G, B)
 endfunction
 
 ## Test input validation
 %!error rgb2ind ()
 %!error rgb2ind (1,2,3,4,5,6,7)
 %!error <RGB> rgb2ind (rand (10, 10, 4))
 
 ## FIXME: the following tests simply make sure that rgb2ind and ind2rgb
-##        reverse each other. We should have better tests for this.
+##        reverse each other.  We should have better tests for this.
 
 ## Typical usage
 %!test
 %! rgb = rand (10, 10, 3);
 %! [ind, map] = rgb2ind (rgb);
 %! assert (ind2rgb (ind, map), rgb);
 %!
 %! ## test specifying the RGB channels separated
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -407,17 +407,17 @@ function varargout = strread (str, forma
     endif
   endif
   if (isempty (delimiter_str))
     delimiter_str = " ";
   endif
   if (! isempty (eol_char))
     ## Add eol_char to delimiter collection
     delimiter_str = unique ([delimiter_str eol_char]);
-    ## .. and remove it from whitespace collection
+    ## and remove it from whitespace collection
     white_spaces = strrep (white_spaces, eol_char, '');
   endif
 
   ii = numel (fmt_words);
   while (ii > 0)
     if (ismember (fmt_words{ii}, delimiter_str)(1))
       fmt_words(ii) = [];
       --num_words_per_line;
@@ -446,56 +446,56 @@ function varargout = strread (str, forma
       dlmstr = setdiff (delimiter_str, " ");
       if (! isempty (dlmstr))
         rxp_dlmwsp = sprintf ('( [%s] | [%s]|[%s] )', dlmstr, dlmstr, dlmstr);
         str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
       endif
     endif
     ## Wipe leading and trailing whitespace on each line (it may be
     ## delimiter too)
-    ## FIXME: Double strrep on str is enormously expensive of CPU time.
-    ## Can this be eliminated
+    ## FIXME: Double strrep on str is enormously expensive in CPU time.
+    ## Can this be eliminated?
     if (! isempty (eol_char))
       str = strrep (str, [eol_char " "], eol_char);
       str = strrep (str, [" " eol_char], eol_char);
     endif
   endif
 
   ## Split 'str' into words
   words = split_by (str, delimiter_str, mult_dlms_s1, eol_char);
   if (! isempty (white_spaces))
-    ## Trim leading and trailing 'white_spaces'. All whitespace has
-    ## been converted to space above
+    ## Trim leading and trailing 'white_spaces'.
+    ## All whitespace has been converted to space above
     words = strtrim (words);
   endif
   num_words = numel (words);
   ## First guess at nr. of lines in file (ignoring leading/trailing literals)
   num_lines = ceil (num_words / num_words_per_line);
 
   ## Replace TreatAsEmpty char sequences by empty strings
   if (! isempty (empty_str))
     for ii = 1:numel (empty_str)
       idz = strncmp (empty_str{ii}, words, length (empty_str{ii}));
       words(idz) = {""};
     endfor
   endif
 
   ## fmt_words has been split properly now, but words{} has only been split on
-  ## delimiter positions. As numeric fields can also be separated by
+  ## delimiter positions.  As numeric fields can also be separated by
   ## whitespace, more splits may be needed.
   ## We also don't know the number of lines (as EndOfLine may have been set to
   ## "" (empty) by the caller).
   ##
   ## We also may have to cope with 3 cases as far as literals go:
   ## A: Trailing literals (%f<literal>) w/o delimiter in between.
   ## B: Leading literals (<literal>%f) w/o delimiter in between.
   ## C. Skipping leftover parts of specified skip fields (%*N )
   ## Some words columns may have to be split further to fix these.
   ## To find out, we'll match fmt_words to the words array to see what
-  ## needs to be done. fwptr tracks which {fmt_words}# starts in what {words}#
+  ## needs to be done.  fwptr tracks which {fmt_words} starts in what {words}
 
   ## Find indices and pointers to possible literals in fmt_words
   idf = cellfun ("isempty", strfind (fmt_words, "%"));
   ## Find indices and pointers to conversion specifiers with fixed width
   idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
   idy = find (idf | idg);
   ## Find indices to numeric conversion specifiers
   idn = ! cellfun ("isempty", regexp (fmt_words, '%[dnfu]'));
@@ -527,43 +527,43 @@ function varargout = strread (str, forma
             nxt_wrd = 1;
           else
             ## Found it in current word.  Subtract literal length
             iwrdp += length (fmt_words{ii});
             if (iwrdp > iwrdl)
               ## Parse error.  Literal extends beyond delimiter (word boundary)
               warning ("strread: literal '%s' (fmt spec # %d) does not match data", ...
                 fmt_words{ii}, ii);
-              ## Word assumed to be completely "used up". Next word
+              ## Word assumed to be completely "used up".  Next word
               nxt_wrd = 1;
             elseif (iwrdp == iwrdl)
-              ## Word completely "used up". Next word
+              ## Word completely "used up".  Next word
               nxt_wrd = 1;
             endif
           endif
 
         elseif (idg(ii))
           ## Fixed width specifier (%N or %*N): read just a part of word
           sw = regexp (fmt_words{ii}, '\d', "once");
           ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
           iwrdp += floor (str2double (fmt_words{ii}(sw:ew)));
           if (iwrdp > iwrdl)
-            ## Match error. Field extends beyond word boundary.
+            ## Match error.  Field extends beyond word boundary.
             warning  ...
             ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
                fmt_words{ii}, ii);
             ## Assume word to be completely "used up".  Next word
             nxt_wrd = 1;
           elseif (iwrdp == iwrdl)
             ## Word completely "used up".  Next word
             nxt_wrd = 1;
           endif
 
         else
-          ## A simple format conv. specifier. Either (1) uses rest of word, or
+          ## A simple format conv. specifier.  Either (1) uses rest of word, or
           ## (2) is squeezed between current iwrdp and next literal, or (3) uses
           ## next word. (3) is already taken care of.  So just check (1) & (2)
           if (ii < numel (fmt_words) && idf(ii+1))
             ## Next fmt_word is a literal...
             if (! index (words{iwrd}(iwrdp+1:end), fmt_words{ii+1}))
               ## ...but not found in current word => field uses rest of word
               nxt_wrd = 1;
             else
@@ -633,33 +633,35 @@ function varargout = strread (str, forma
               words(icol+1, jptr) = cellfun (
                 @(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr),
                 "UniformOutput", false);
               words(icol, jptr) = fmt_words{ii};
               fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
 
             else
               if (idg(ii))
-                ## Current field = fixed width. Strip into icol, rest in icol+1
+                ## Current field = fixed width.
+                ## Strip into icol, rest in icol+1
                 sw = regexp (fmt_words{ii}, '\d', "once");
                 ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
                 wdth = floor (str2double (fmt_words{ii}(sw:ew)));
                 words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
                      words(icol,jptr), "UniformOutput", false);
                 if (isempty ([words(icol+1, :){:}]))
                   ## Apparently split wasn't needed as turns out to cover
                   ## entire column. So delete column again
                   words(icol+1, :) = [];
                 else
                   words(icol, jptr) = strtrunc (words(icol, jptr), wdth);
                   fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
                 endif
               else
                 if (! isempty (strfind (fmt_words{ii-1}, "%s")))
-                  ## Trailing literal. Could be ambiguous if preceding format == '%s'
+                  ## Trailing literal.
+                  ## Could be ambiguous if preceding format == '%s'
                   warning ("strread.m:\n  Ambiguous '%%s' specifier immediately before literal in column %d", icol);
                 endif
                 ## FIXME: this assumes char(254)/char(255) won't occur in input!
                 clear wrds;
                 wrds(1:2:2*numel (words(icol, jptr))) = ...
                      strrep (words(icol, jptr), fmt_words{ii}, ...
                      [char(255) char(254)]);
                 wrds(2:2:2*numel (words(icol, jptr))-1) = char (255);
@@ -784,18 +786,19 @@ function varargout = strread (str, forma
           n = find (! cellfun ("isempty", data));
           if (numel (unique (data(n))) > 1
               || ! strcmpi (unique (data), fmt_words{m}))
             error ("strread: FORMAT does not match data");
           endif
       endswitch
     catch
       ## As strread processes columnwise, ML-compatible error processing
-      ## (row after row) is not feasible. In addition Octave sets unrecognizable
-      ## numbers to NaN w/o error.  But maybe Octave is better in this respect.
+      ## (row after row) is not feasible.  In addition Octave sets
+      ## unrecognizable numbers to NaN w/o error.  But maybe Octave is better
+      ## in this respect.
       if (err_action)
         ## Just try the next column where ML bails out
       else
         rethrow (lasterror);
       endif
     end_try_catch
   endfor
 
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -153,17 +153,17 @@ function varargout = textread (filename,
       fskipl (fid, varargin{headerlines + 1});
     elseif (varargin{headerlines + 1} < 0)
       warning ("textread: negative headerline value ignored");
     endif
     varargin(headerlines:headerlines+1) = [];
   endif
   st_pos = ftell (fid);
 
-  ## Read a first file chunk. Rest follows after endofline processing
+  ## Read a first file chunk.  Rest follows after endofline processing
   [str, count] = fscanf (fid, "%c", BUFLENGTH);
   if (isempty (str) || count < 1)
     warning ("textread: empty file");
     varargout = cell (1, nargout);
     return;
   endif
 
   endofline = find (strcmpi (varargin, "endofline"), 1);
@@ -221,17 +221,17 @@ function varargout = textread (filename,
         ++nblks;
       endif
     endwhile
     ## Handle case of missing or incomplete trailing EOL
     if (! strcmp (str(end - length (eol_char) + 1 : end), eol_char))
       eoi = [ eoi (length (str)) ];
       ++n_eoi;
     endif
-    ## Found EOL delimiting last requested line. Compute ptr (incl. EOL)
+    ## Found EOL delimiting last requested line.  Compute ptr (incl. EOL)
     if (isempty (eoi))
       eoi_pos = nblks * BUFLENGTH + count;
     else
       eoi_pos = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi);
     endif
     fseek (fid, st_pos, "bof");
     str = fscanf (fid, "%c", eoi_pos);
   else
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -88,17 +88,17 @@ function [path1, path2] = javaclasspath 
         disp_path_list ("DYNAMIC", dynamic_path_list);
       otherwise
         error ("javaclasspath: invalid value for WHAT");
     endswitch
 
   else
     if (! nargin)
       ## This is to allow retrieval of both paths in separate variables with
-      ## a single call to javaclasspath(). Matlab returns only the -dynamic
+      ## a single call to javaclasspath().  Matlab returns only the -dynamic
       ## path in this case but this won't break compatibility.
       path1 = cellstr (dynamic_path_list);
       path2 = cellstr (static_path_list);
     else
       switch (tolower (which))
         case "-all",     path1 = cellstr ([static_path_list,dynamic_path_list]);
         case "-dynamic", path1 = cellstr (dynamic_path_list);
         case "-static",  path1 = cellstr (static_path_list);
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -4,17 +4,17 @@
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} info ()
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -57,17 +57,17 @@
 ##
 ## @end table
 ##
 ## @seealso{pkg, ver, version}
 ## @end deftypefn
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
-function [retval, errmsg] = license (cmd, feature, toogle)
+function [retval, errmsg] = license (cmd, feature, toggle)
 
   if (nargin > 3)
     print_usage ();
   endif
 
   ## Then only give information about Octave core
   if (nargin == 0)
     retval = "GNU General Public License";
@@ -94,23 +94,23 @@ function [retval, errmsg] = license (cmd
       endif
 
     case "test"
       if (nargin < 2)
         print_usage ();
       endif
 
       if (nargin > 2)
-        ## We ignore the toogle argument because... what's the point?  We
+        ## We ignore the toggle argument because... what's the point?  We
         ## don't need a license management system on Octave.  This function
-        ## will return true, even if anyone tries to disabled a license.
-        switch (tolower (toogle))
+        ## will return true, even if anyone tries to disable a license.
+        switch (tolower (toggle))
           case "enable"   # do nothing
           case "disable"  # do nothing
-          otherwise       error ("license: TOOGLE must be enable or disable");
+          otherwise       error ("license: TOGGLE must be enable or disable");
         endswitch
       endif
 
       retval = any (strcmp (features, feature));
 
     case "checkout"
       ## I guess we could have the checkout command load packages but it's not
       ## really the same thing.  The closest we have is simply to check if
@@ -179,10 +179,10 @@ endfunction
 
 %!test
 %! [s, e] = license ("checkout", "NOT_A_PACKAGE");
 %! assert (e, 'No package named "NOT_A_PACKAGE" installed');
 
 ## Test input validation
 %!error license ("not_inuse")
 %!error license ("not_test", "octave", "enable")
-%!error <TOOGLE must be enable or disable> license ("test", "octave", "invalid_toogle")
+%!error <TOGGLE must be enable or disable> license ("test", "octave", "invalid_toggle")
 
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -4,17 +4,17 @@
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{output} =} perl (@var{scriptfile})
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -18,22 +18,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{filelist} =} __xzip__ (@var{commandname}, @var{extension}, @var{commandtemplate}, @var{files}, @var{outdir})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Compress the list of files and/or directories specified in @var{files}
-## with the external compression command @var{commandname}. The template
-## @var{commandtemplate} is used to actually start the command. Each file
+## with the external compression command @var{commandname}.  The template
+## @var{commandtemplate} is used to actually start the command.  Each file
 ## is compressed separately and a new file with the extension @var{extension}
-## is created and placed into the directory @var{outdir}. The original files
-## are not touched. Existing compressed files are silently overwritten.
-## This is an internal function. Do not use directly.
+## is created and placed into the directory @var{outdir}.  The original files
+## are not touched.  Existing compressed files are silently overwritten.
+## This is an internal function.  Do not use directly.
 
 function filelist = __xzip__ (commandname, extension, commandtemplate,
                               files, outdir)
 
   if (nargin == 5 && ! exist (outdir, "dir"))
     r = mkdir (outdir);
     if (! r)
       error ("%s: Failed to create output directory DIR", commandname);
diff --git a/scripts/miscellaneous/private/display_info_file.m b/scripts/miscellaneous/private/display_info_file.m
--- a/scripts/miscellaneous/private/display_info_file.m
+++ b/scripts/miscellaneous/private/display_info_file.m
@@ -11,18 +11,18 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-## news() and citation() are very much alike. They both do the same thing, just
-## for different files. This function does all the work.
+## news() and citation() are very much alike.  They both do the same thing,
+## just for different files.  This function does all the work.
 
 function display_info_file (func, package, file)
 
   if (! ischar (package))
     error ("%s: PACKAGE must be a string", func);
   endif
 
   if (strcmpi (package, "octave"))
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -5,17 +5,17 @@
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {@var{output} =} python (@var{scriptfile})
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -89,17 +89,17 @@
 ## [@var{t},@var{y}] = ode23 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
 ## @seealso{odeset, odeget}
 ## @end deftypefn
 
 ## ChangeLog:
 ##   20010703 the function file "ode23.m" was written by Marc Compere
-##     under the GPL for the use with this software. This function has been
+##     under the GPL for the use with this software.  This function has been
 ##     taken as a base for the following implementation.
 ##   20060810, Thomas Treichl
 ##     This function was adapted to the new syntax that is used by the
 ##     new OdePkg for Octave and is compatible to Matlab's ode23.
 
 function varargout = ode23 (fun, trange, init, varargin)
 
   if (nargin < 3)
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -34,17 +34,17 @@ function names = __all_opts__ (varargin)
   ## guard against recursive calls.
   persistent recursive = false;
 
   if (recursive)
     names = {};
   elseif (nargin == 0)
     names = saved_names;
   else
-    ## query all options from all known functions. These will call optimset,
+    ## query all options from all known functions.  These will call optimset,
     ## which will in turn call us, but we won't answer.
     recursive = true;
     names = saved_names;
     for i = 1:nargin
       try
         opts = optimset (varargin{i});
         fn = fieldnames (opts).';
         names = [names, fn];
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -157,17 +157,17 @@ function [x, fval, info, output] = fminb
       endif
     else
       dogs = true;
     endif
     if (dogs)
       ## Default to golden section step.
 
       ## WARNING: This is also the "initial" procedure following
-      ## MATLAB nomenclature. After the loop we'll fix the string
+      ## MATLAB nomenclature.  After the loop we'll fix the string
       ## for the first step.
       iter(niter+1).procedure = "golden";
 
       e = ifelse (x >= xm, a - x, b - x);
       d = c * e;
     endif
 
     ## f must not be evaluated too close to x.
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -95,17 +95,17 @@ endfunction
 ##               - STOPIT(2) function evaluations have been performed
 ##                 (default inf, i.e., no limit), or
 ##               - a function value equals or exceeds STOPIT(3)
 ##                 (default inf, i.e., no test on function values).
 ##        The form of the initial simplex is determined by STOPIT(4):
 ##           STOPIT(4) = 0: regular simplex (sides of equal length, the default)
 ##           STOPIT(4) = 1: right-angled simplex.
 ##        Progress of the iteration is not shown if STOPIT(5) = 0 (default 1).
-##           STOPIT(6) indicates the direction (ie. minimization or
+##           STOPIT(6) indicates the direction (i.e., minimization or
 ##                   maximization.) Default is 1, maximization.
 ##                   set STOPIT(6)=-1 for minimization
 ##        If a non-empty fourth parameter string SAVIT is present, then
 ##        'SAVE SAVIT x fmax nf' is executed after each inner iteration.
 ##        NB: x0 can be a matrix.  In the output argument, in SAVIT saves,
 ##            and in function calls, x has the same shape as x0.
 ##        NMSMAX(fun, x0, STOPIT, SAVIT, P1, P2,...) allows additional
 ##        arguments to be passed to fun, via feval(fun,x,P1,P2,...).
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -231,17 +231,17 @@ function [x, fval, info, output, grad, h
 
     if (niter == 1)
       xn = norm (dg .* x);
       ## FIXME: something better?
       delta = factor * max (xn, 1);
     endif
 
     ## FIXME: why tolf*n*xn?  If abs (e) ~ abs(x) * eps is a vector
-    ## of perturbations of x, then norm (hesr*e) <= eps*xn, i.e. by
+    ## of perturbations of x, then norm (hesr*e) <= eps*xn, i.e., by
     ## tolf ~ eps we demand as much accuracy as we can expect.
     if (norm (grad) <= tolf*n*xn)
       info = 1;
       break;
     endif
 
     suc = false;
     decfac = 0.5;
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -162,17 +162,17 @@ function [x, fvec, info, output, fjac] =
   has_jac = strcmpi (optimget (options, "Jacobian", "off"), "on");
   cdif = strcmpi (optimget (options, "FinDiffType", "central"), "central");
   maxiter = optimget (options, "MaxIter", 400);
   maxfev = optimget (options, "MaxFunEvals", Inf);
   outfcn = optimget (options, "OutputFcn");
   updating = strcmpi (optimget (options, "Updating", "on"), "on");
   complexeqn = strcmpi (optimget (options, "ComplexEqn", "off"), "on");
 
-  ## Get scaling matrix using the TypicalX option. If set to "auto", the
+  ## Get scaling matrix using the TypicalX option.  If set to "auto", the
   ## scaling matrix is estimated using the Jacobian.
   typicalx = optimget (options, "TypicalX");
   if (isempty (typicalx))
     typicalx = ones (n, 1);
   endif
   autoscale = strcmpi (optimget (options, "AutoScaling", "off"), "on");
   if (! autoscale)
     dg = 1 ./ typicalx;
@@ -243,56 +243,56 @@ function [x, fvec, info, output, fjac] =
       nfev += 1;
     else
       fjac = __fdjac__ (fcn, reshape (x, xsiz), fvec, typicalx, cdif);
       nfev += (1 + cdif) * length (x);
     endif
 
     ## For square and overdetermined systems, we update a QR
     ## factorization of the Jacobian to avoid solving a full system in each
-    ## step. In this case, we pass a triangular matrix to __dogleg__.
+    ## step.  In this case, we pass a triangular matrix to __dogleg__.
     useqr = updating && m >= n && n > 10;
 
     if (useqr)
       ## FIXME: Currently, pivoting is mostly useless because the \ operator
       ## cannot exploit the resulting props of the triangular factor.
       ## Unpivoted QR is significantly faster so it doesn't seem right to pivot
-      ## just to get invariance. Original MINPACK didn't pivot either, at least
-      ## when qr updating was used.
+      ## just to get invariance.  Original MINPACK didn't pivot either, 
+      ## at least when qr updating was used.
       [q, r] = qr (fjac, 0);
     endif
 
     if (autoscale)
       ## Get column norms, use them as scaling factors.
       jcn = norm (fjac, 'columns').';
       if (niter == 1)
         dg = jcn;
         dg(dg == 0) = 1;
       else
         ## Rescale adaptively.
         ## FIXME: the original minpack used the following rescaling strategy:
         ##   dg = max (dg, jcn);
         ## but it seems not good if we start with a bad guess yielding Jacobian
         ## columns with large norms that later decrease, because the
-        ## corresponding variable will still be overscaled. So instead, we only
+        ## corresponding variable will still be overscaled.  Instead, we only
         ## give the old scaling a small momentum, but do not honor it.
 
         dg = max (0.1*dg, jcn);
       endif
     endif
 
     if (niter == 1)
       xn = norm (dg .* x);
       ## FIXME: something better?
       delta = factor * max (xn, 1);
     endif
 
     ## It also seems that in the case of fast (and inhomogeneously) changing
     ## Jacobian, the Broyden updates are of little use, so maybe we could
-    ## skip them if a big disproportional change is expected. The question is,
+    ## skip them if a big disproportional change is expected.  The question is,
     ## of course, how to define the above terms :)
 
     lastratio = 0;
     nfail = 0;
     nsuc = 0;
     decfac = 0.5;
 
     ## Inner loop.
@@ -377,37 +377,37 @@ function [x, fvec, info, output, fjac] =
         state = 'iter';
         stop = outfcn (x, optimvalues, state);
         if (stop)
           info = -1;
           break;
         endif
       endif
 
-      ## Tests for termination conditions. A mysterious place, anything
+      ## Tests for termination conditions.  A mysterious place, anything
       ## can happen if you change something here...
 
       ## The rule of thumb (which I'm not sure M*b is quite following)
       ## is that for a tolerance that depends on scaling, only 0 makes
-      ## sense as a default value. But 0 usually means uselessly long
+      ## sense as a default value.  But 0 usually means uselessly long
       ## iterations, so we need scaling-independent tolerances wherever
       ## possible.
 
       ## FIXME: Why tolf*n*xn? If abs (e) ~ abs(x) * eps is a vector
-      ## of perturbations of x, then norm (fjac*e) <= eps*n*xn, i.e. by
+      ## of perturbations of x, then norm (fjac*e) <= eps*n*xn, i.e., by
       ## tolf ~ eps we demand as much accuracy as we can expect.
       if (fn <= tolf*n*xn)
         info = 1;
         ## The following tests done only after successful step.
       elseif (ratio >= 1e-4)
-        ## This one is classic. Note that we use scaled variables again,
+        ## This one is classic.  Note that we use scaled variables again,
         ## but compare to scaled step, so nothing bad.
         if (sn <= tolx*xn)
           info = 2;
-          ## Again a classic one. It seems weird to use the same tolf
+          ## Again a classic one.  It seems weird to use the same tolf
           ## for two different tests, but that's what M*b manual appears
           ## to say.
         elseif (actred < tolf)
           info = 3;
         endif
       endif
 
       ## Criterion for recalculating Jacobian.
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -89,18 +89,18 @@
 ## This is essentially the ACM algorithm 748: Enclosing Zeros of
 ## Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions
 ## on Mathematical Software, Vol. 21, No. 3, September 1995. Although
 ## the workflow should be the same, the structure of the algorithm has
 ## been transformed non-trivially; instead of the authors' approach of
 ## sequentially calling building blocks subprograms we implement here a
 ## FSM version using one interior point determination and one bracketing
 ## per iteration, thus reducing the number of temporary variables and
-## simplifying the algorithm structure. Further, this approach reduces
-## the need for external functions and error handling. The algorithm has
+## simplifying the algorithm structure.  Further, this approach reduces
+## the need for external functions and error handling.  The algorithm has
 ## also been slightly modified.
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fzero");
 
 function [x, fval, info, output] = fzero (fun, x0, options = struct ())
 
   ## Get default options if requested.
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -173,17 +173,17 @@ function [x, resnorm, residual, exitflag
 
     ## find the maximum gradient.
     idx = find (w == max (w));
     if (numel (idx) > 1)
       warning ("lsqnonneg:nonunique",
                "a non-unique solution may be returned due to equal gradients");
       idx = idx(1);
     endif
-    ## move the index from Z to P. Keep P sorted.
+    ## move the index from Z to P.  Keep P sorted.
     z = [1:n]; z(p) = [];
     zidx = z(idx);
     jdx = 1 + lookup (p, zidx);
     p = [p(1:jdx-1), zidx, p(jdx:end)];
     if (useqr)
       ## insert the column into the QR factorization.
       [q, r] = qrinsert (q, r, jdx, c(:,zidx));
     endif
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -166,17 +166,17 @@ function [x, minval, exitflag, output, l
 
     ## find the maximum gradient.
     idx = find (w == max (w));
     if (numel (idx) > 1)
       warning ("pqpnonneg:nonunique",
                "a non-unique solution may be returned due to equal gradients");
       idx = idx(1);
     endif
-    ## move the index from Z to P. Keep P sorted.
+    ## move the index from Z to P.  Keep P sorted.
     z = [1:n]; z(p) = [];
     zidx = z(idx);
     jdx = 1 + lookup (p, zidx);
     p = [p(1:jdx-1), zidx, p(jdx:end)];
     if (usechol)
       ## insert the column into the Cholesky factorization.
       [r, bad] = cholinsert (r, jdx, c(p,zidx));
       if (bad)
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -93,21 +93,21 @@ function configure_make (desc, packdir, 
         disp (output);
         error ("pkg: error running `make' for the %s package.", desc.name);
       endif
     endif
 
   endif
 endfunction
 
-## Executes a shell command. In the end it calls system() but in case of
+## Executes a shell command.  In the end it calls system() but in case of
 ## windows will first check if sh.exe works.
 ##
 ## If VERBOSE is true, it will prints the output to STDOUT in real time and
-## the second output argument will be an empty string. Otherwise, it will
+## the second output argument will be an empty string.  Otherwise, it will
 ## contain the output of the execeuted command.
 function [status, output] = shell (cmd, verbose)
   persistent have_sh;
 
   cmd = strrep (cmd, "\\", "/");
   if (ispc () && ! isunix ())
     if (isempty (have_sh))
       if (system ('sh.exe -c "exit"'))
@@ -117,19 +117,19 @@ function [status, output] = shell (cmd, 
       endif
     endif
     if (have_sh)
       cmd = ['sh.exe -c "' cmd '"'];
     else
       error ("pkg: unable to find the command shell.");
     endif
   endif
-  ## if verbose, we want to display the output in real time. To do this, we
-  ## must call system with 1 output argument. But then the variable `output'
-  ## won't exist. So we initialize it empty. If an error does occur, and we
+  ## if verbose, we want to display the output in real time.  To do this, we
+  ## must call system with 1 output argument.  But then the variable `output'
+  ## won't exist.  So we initialize it empty.  If an error does occur, and we
   ## are verbose we will return an empty string but it's all fine since
   ## the error message has already been displayed.
   output = "";
   if (verbose)
     [status] = system (cmd);
   else
     [status, output] = system (cmd);
   endif
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -37,17 +37,17 @@ function [ver, url] = get_forge_pkg (nam
   name = tolower (name);
 
   ## Try to download package's index page.
   [html, succ] = urlread (sprintf ("http://packages.octave.org/%s/index.html",
                                    name));
   if (succ)
     ## Remove blanks for simpler matching.
     html(isspace(html)) = [];
-    ## Good. Let's grep for the version.
+    ## Good.  Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
         ## Build download string.
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {} install (@var{files}, @var{handle_deps}, @var{prefix}, @var{archprefix}, @var{verbose}, @var{local_list}, @var{global_list}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function install (files, handle_deps, prefix, archprefix, verbose,
                   local_list, global_list, global_install)
 
-  ## Check that the directory in prefix exist. If it doesn't: create it!
+  ## Check that the directory in prefix exist.  If it doesn't: create it!
   if (! exist (prefix, "dir"))
     warning ("creating installation directory %s", prefix);
     [status, msg] = mkdir (prefix);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
 
@@ -237,17 +237,17 @@ function install (files, handle_deps, pr
     endfor
     for i = 1:length (descriptions)
       rmdir (descriptions{i}.dir, "s");
       rmdir (getarchdir (descriptions{i}), "s");
     endfor
     rethrow (lasterror ());
   end_try_catch
 
-  ## Check if the installed directory is empty. If it is remove it
+  ## Check if the installed directory is empty.  If it is remove it
   ## from the list.
   for i = length (descriptions):-1:1
     if (dirempty (descriptions{i}.dir, {"packinfo", "doc"})
         && dirempty (getarchdir (descriptions{i})))
       warning ("package %s is empty\n", descriptions{i}.name);
       rmdir (descriptions{i}.dir, "s");
       rmdir (getarchdir (descriptions{i}), "s");
       descriptions(i) = [];
@@ -675,17 +675,17 @@ function write_index (desc, dir, index_f
 endfunction
 
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "at"); # append to support PKG_ADD at inst/
   ## If it is exists, most of the PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
-  ## commands work as expected. The only part that doesn't is the
+  ## commands work as expected.  The only part that doesn't is the
   ## part in the main directory.
   archdir = fullfile (getarchprefix (desc, global_install),
                       [desc.name "-" desc.version], getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -139,17 +139,17 @@ function [hleg, hleg_obj, hplot, labels]
     plty = get (ca, "__plotyy_axes__");
     if (isscalar (plty) && ishandle (plty))
       ca = [ca, plty];
     elseif (iscell (plty))
       ca = [ca, plty{:}];
     elseif (all (ishandle (plty)))
       ca = [ca, plty(:).'];
     else
-      error ("legend.m: This should not happen. File a bug report.");
+      error ("legend.m: This should not happen.  File a bug report.");
     endif
     ## Remove duplicates while preserving order
     [~, n] = unique (ca);
     ca = ca(sort (n));
   endif
 
   if (nargin > 0 && all (ishandle (varargin{1})))
     kids = flipud (varargin{1}(:));
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -65,18 +65,18 @@ function whitebg (varargin)
     isroot = false;
     fig = h;
   else
     error ("whitebg: HFIF must be a valid figure handle");
   endif
 
   axes = findall (fig, "type", "axes");
   if (isnan (color))
-    ## Root figure. Set the default axes and figure properties so that
-    ## subsequent plots have the new color scheme
+    ## Root figure.  Set the default axes and figure properties so that
+    ## subsequent plots have the new color scheme.
     if (isroot)
       fac = get (0, "factory");
       fields = fieldnames (fac);
       fieldindex = intersect (find (! cellfun ("isempty", regexp (fields, 'color'))), union (find (! cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (! cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
 
       ## Check whether the factory value has been replaced
       for nf = 1 : numel (fieldindex);
         defaultfield = strrep (fields{fieldindex(nf)}, "factory", "default");
diff --git a/scripts/plot/draw/feather.m b/scripts/plot/draw/feather.m
--- a/scripts/plot/draw/feather.m
+++ b/scripts/plot/draw/feather.m
@@ -82,19 +82,19 @@ function h = feather (varargin)
       else
         error ("feather: invalid linestyle STYLE");
       endif
     else
       error ("feather: invalid linestyle STYLE");
     endif
   endif
 
-  ## Matlab draws feather plots, with the arrow head as one continous
-  ## line, and each arrow separately. This is completely different from
-  ## quiver and quite ugly.
+  ## Matlab draws feather plots, with the arrow head as one continuous line,
+  ## and each arrow separately.  This is completely different from quiver and
+  ## quite ugly.
   n = length (u);
   xend = [1 : n] + u;
   xtmp = [1 : n] + u .* (1 - arrowsize);
   yend = v;
   ytmp = v .* (1 - arrowsize);
   x = [[1 : n]; xend; xtmp - v * arrowsize / 3; xend; ...
        xtmp + v * arrowsize / 3];
   y = [zeros(1, n); yend; ytmp + u * arrowsize / 3; yend; ...
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -176,25 +176,25 @@ function [ax, h1, h2] = __plotyy__ (ax, 
 
   ## Store the axes handles for the sister axes.
   if (ishandle (ax(1)) && ! isprop (ax(1), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(1), "data");
     set (ax(1), "__plotyy_axes__", ax);
   elseif (ishandle (ax(1)))
     set (ax(1), "__plotyy_axes__", ax);
   else
-    error ("plotyy.m: This shouldn't happen. File a bug report.");
+    error ("plotyy.m: This shouldn't happen.  File a bug report.");
   endif
   if (ishandle (ax(2)) && ! isprop (ax(2), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(2), "data");
     set (ax(2), "__plotyy_axes__", ax);
   elseif (ishandle (ax(2)))
     set (ax(2), "__plotyy_axes__", ax);
   else
-    error ("plotyy.m: This shouldn't happen. File a bug report.");
+    error ("plotyy.m: This shouldn't happen.  File a bug report.");
   endif
 endfunction
 
 function deleteplotyy (h, ~, ax2, t2)
   if (isaxes (ax2)
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
diff --git a/scripts/plot/draw/stemleaf.m b/scripts/plot/draw/stemleaf.m
--- a/scripts/plot/draw/stemleaf.m
+++ b/scripts/plot/draw/stemleaf.m
@@ -1,28 +1,25 @@
 ## Copyright (C) 2013-2015 Michael D. Godfrey
 ##
 ## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or
-## modify it under the terms of the GNU General Public
-## License as published by the Free Software Foundation;
-## either version 3 of the License, or (at your option) any
-## later version.
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
 ##
-## Octave is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied
-## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-## PURPOSE. See the GNU General Public License for more
-## details.
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
 ##
-## You should have received a copy of the GNU General Public
-## License along with Octave; see the file COPYING. If not,
-## see <http://www.gnu.org/licenses/>.
-
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} stemleaf (@var{x}, @var{caption})
 ## @deftypefnx {} {} stemleaf (@var{x}, @var{caption}, @var{stem_sz})
 ## @deftypefnx {} {@var{plotstr} =} stemleaf (@dots{})
 ## Compute and display a stem and leaf plot of the vector @var{x}.
 ##
 ## The input @var{x} should be a vector of integers.  Any non-integer values
@@ -110,17 +107,17 @@ function plotstr = stemleaf (x, caption,
   ## quite easily be modified to provide specific display results.  Or,
   ## the returned output string can be edited.  The returned output is an
   ## array of strings with each row containing a line of the plot
   ## preceded by the lines of header text as the first row.  This
   ## facilitates annotation.
   ##
   ## Note that the code has some added complexity due to the need to
   ## distinguish both + and - 0 stems.  The +- stem values are essential
-  ## for all plots which span 0. After dealing with +-0 stems, the added
+  ## for all plots which span 0.  After dealing with +-0 stems, the added
   ## complexity of putting +- data values in the correct stem is minor,
   ## but the sign of 0 leaves must be checked.  And, the cases where the
   ## stems start or end at +- 0 must also be considered.
   ##
   ## The fact that IEEE floating point defines +- 0 helps make this
   ## easier.
   ##
   ## Michael D. Godfrey   January 2013
@@ -161,17 +158,17 @@ function plotstr = stemleaf (x, caption,
     if (isscalar (stem_sz) && stem_sz >= 0 && isreal (stem_sz))
       stem_sz = fix (stem_sz);
       stem_step = 10^(stem_sz+1);
     else
       error ("stemleaf: STEM_SZ must be a real integer >= 0");
     endif
   endif
 
-  ## Note that IEEE 754 states that -+ 0 should compare equal. This has
+  ## Note that IEEE 754 states that -+ 0 should compare equal.  This has
   ## led to C sort (and therefore Octave) treating them as equal.  Thus,
   ## sort([-1 0 -0 1]) yields [-1 0 -0 1], and sort([-1 -0 0 1])
   ## yields: [-1 -0 0 1].  This means that stem-and-leaf plotting cannot
   ## rely on sort to order the data as needed for display.
   ## This also applies to min()/max() so these routines can't be relied
   ## upon if the max or min is -+ 0.
 
   ## Compute hinges and fences based on ref: EDA pgs. 33 and 44.
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -526,17 +526,17 @@ function print (varargin)
   if (isfigure (orig_figure))
     set (0, "currentfigure", orig_figure);
   endif
 
 endfunction
 
 function cmd = epstool (opts, filein, fileout)
   ## As epstool does not work with pipes, a subshell is used to
-  ## permit piping. Since this solution does not work with the DOS
+  ## permit piping.  Since this solution does not work with the DOS
   ## command shell, the -tight and -preview options are disabled if
   ## output must be piped.
 
   ## DOS Shell:
   ##   gs.exe [...] -sOutputFile=<filein> - & epstool -bbox -preview-tiff <filein> <fileout> & del <filein>
   ## Unix Shell;
   ##   cat > <filein> ; epstool -bbox -preview-tiff <filein> <fileout> ; rm <filein>
 
diff --git a/scripts/plot/util/printd.m b/scripts/plot/util/printd.m
--- a/scripts/plot/util/printd.m
+++ b/scripts/plot/util/printd.m
@@ -1,27 +1,25 @@
 ## Copyright (C) 2013-2015 Michael D. Godfrey
 ##
 ## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or
-## modify it under the terms of the GNU General Public
-## License as published by the Free Software Foundation;
-## either version 3 of the License, or (at your option) any
-## later version.
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
 ##
-## Octave is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied
-## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-## PURPOSE. See the GNU General Public License for more
-## details.
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
 ##
-## You should have received a copy of the GNU General Public
-## License along with Octave; see the file COPYING. If not,
-## see <http://www.gnu.org/licenses/>.
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} printd (@var{obj}, @var{filename})
 ## @deftypefnx {} {@var{out_file} =} printd (@dots{})
 ##
 ## Convert any object acceptable to @code{disp} into the format selected by
 ## the suffix of @var{filename}.
 ##
diff --git a/scripts/plot/util/private/__gnuplot_draw_axes__.m b/scripts/plot/util/private/__gnuplot_draw_axes__.m
--- a/scripts/plot/util/private/__gnuplot_draw_axes__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_axes__.m
@@ -815,17 +815,17 @@ function __gnuplot_draw_axes__ (h, plot_
 
            if (isfield (obj, "markersize"))
              mdat = obj.markersize / 3;
            endif
 
            if (isfield (obj, "edgecolor"))
              ## FIXME: This is the wrong thing to do as edgecolor,
              ## markeredgecolor and markerfacecolor can have different values
-             ## and we should treat them seperately. However, the code below
+             ## and we should treat them seperately.  However, the code below
              ## allows the scatter functions to work as expected, where only
              ## one of these values is set.
              if (strcmp (obj.edgecolor, "none"))
                if (strcmp (obj.markeredgecolor, "none"))
                  ec = obj.markerfacecolor;
                else
                  ec = obj.markeredgecolor;
                endif
@@ -1301,32 +1301,32 @@ function __gnuplot_draw_axes__ (h, plot_
 
         if (ischar (obj.string))
           num_lines = rows (obj.string);
           num_lines += numel (strfind (obj.string, "\n"));
         else
           num_lines = numel (obj.string);
         endif
         switch (valign)
-          ## Text offset in characters. Relies on gnuplot for font metrics.
+          ## Text offset in characters.  Relies on gnuplot for font metrics.
           case "top"
             dy = -0.5;
           case "cap"
             dy = -0.5;
           case "middle"
             dy = 0.5 * (num_lines - 1);
           case "baseline"
             dy = 0.5 + (num_lines - 1);
           case "bottom"
             dy = 0.5 + (num_lines - 1);
         endswitch
         ## Gnuplot's Character units are different for x/y and vary with
-        ## fontsize. The aspect ratio of 1:1.7 was determined by experiment
-        ## to work for eps/ps/etc. For the MacOS aqua terminal a value of 2.5
-        ## is needed. However, the difference is barely noticable.
+        ## fontsize.  The aspect ratio of 1:1.7 was determined by experiment
+        ## to work for eps/ps/etc.  For the MacOS aqua terminal a value of 2.5
+        ## is needed.  However, the difference is barely noticeable.
         dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
 
         ## FIXME: Multiline text produced the gnuplot
         ##        "warning: ft_render: skipping glyph"
         if (nd == 3)
           ## This produces the desired vertical alignment in 3D.
           fprintf (plot_stream,
                    "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
@@ -2391,17 +2391,17 @@ function str = __tex2enhanced__ (str, fn
         b2 = strfind (str(e(i) + 1:end),'}');
         if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
           str = [str(1:s(i) - 1), '/=', str(e(i)+b1(1) + 1:e(i)+b2(1)-1), ...
                  '{}', str(e(i) + b2(1) + 1:end)];
         endif
       else
-        ## Last desperate attempt to treat the symbol. Look for things
+        ## Last desperate attempt to treat the symbol.  Look for things
         ## like \pix, that should be translated to the symbol Pi and x
         for j = 1 : length (flds)
           if (strncmp (flds{j}, f, length (flds{j})))
             g = getfield (sym, flds{j});
             ## FIXME: The symbol font doesn't seem to support bold or italic
             ##if (bld)
             ##  if (it)
             ##    g = strrep (g, '/Symbol', '/Symbol-bolditalic');
@@ -2420,17 +2420,17 @@ function str = __tex2enhanced__ (str, fn
   endfor
 
   ## Prepend @ to things like _0^x or _{-100}^{100} for alignment.
   ## But need to put the shorter of the two arguments first.
   ## Careful of nested {} and unprinted characters when defining
   ## shortest..  Don't have to worry about things like ^\theta as they
   ## are already converted to ^{/Symbol q}.
 
-  ## FIXME: This is a mess... Is it worth it just for a "@" character?
+  ## FIXME: This is a mess.  Is it worth it just for a "@" character?
 
   [s, m] = regexp (str,'[_\^]','start','matches');
   i = 1;
   p = 0;
   while (i < length (s))
     if (i < length (s))
       if (str(s(i) + p + 1) == "{")
         s1 = strfind (str(s(i) + p + 2:end),'{');
diff --git a/scripts/plot/util/private/__gnuplot_draw_figure__.m b/scripts/plot/util/private/__gnuplot_draw_figure__.m
--- a/scripts/plot/util/private/__gnuplot_draw_figure__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_figure__.m
@@ -45,22 +45,22 @@ function __gnuplot_draw_figure__ (h, plo
       endif
       fg_was_set = false;
 
       for i = nkids:-1:1
         type = get (kids(i), "type");
         switch (type)
           case "axes"
             if (strcmpi (get (kids (i), "tag"), "legend"))
-              ## This is so ugly. If there was a way of getting
+              ## This is so ugly.  If there was a way of getting
               ## gnuplot to give us the text extents of strings
               ## then we could get rid of this mess.
               lh = getfield (get (kids(i), "userdata"), "handle");
               if (isscalar (lh))
-                ## We have a legend with a single parent. It'll be handled
+                ## We have a legend with a single parent.  It'll be handled
                 ## below as a gnuplot key to the axis it corresponds to
                 continue;
               else
                 ca = lh(1);
                 ## Rely upon listener to convert axes position
                 ## to "normalized" units.
                 legend_axes_units = get (kids(i), "units");
                 legend_axes_position = get (kids(i), "position");
diff --git a/scripts/plot/util/private/__gnuplot_ginput__.m b/scripts/plot/util/private/__gnuplot_ginput__.m
--- a/scripts/plot/util/private/__gnuplot_ginput__.m
+++ b/scripts/plot/util/private/__gnuplot_ginput__.m
@@ -72,17 +72,17 @@ function [x, y, button] = __gnuplot_ginp
 
   unwind_protect
 
     k = 0;
     while (true)
       k += 1;
 
       ## Notes: MOUSE_* can be undefined if user closes gnuplot by "q"
-      ## or Alt-F4. Further, this abrupt close also requires the leading
+      ## or Alt-F4.  Further, this abrupt close also requires the leading
       ## "\n" on the next line.
       if (use_mkfifo)
         fprintf (ostream, "set print \"%s\";\n", gpin_name);
         fflush (ostream);
         [gpin, err] = fopen (gpin_name, "r");
         if (err)
           error ("ginput: Can not open FIFO (%s)", msg);
         endif
diff --git a/scripts/plot/util/private/__gnuplot_has_terminal__.m b/scripts/plot/util/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/util/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/util/private/__gnuplot_has_terminal__.m
@@ -40,17 +40,17 @@ function gnuplot_supports_term = __gnupl
       if (numel (plot_stream) > 1)
         pclose (plot_stream(2));
       endif
       if (numel (plot_stream) > 2)
         waitpid (plot_stream(3));
       endif
     endif
   else
-    ## Gnuplot 4.0 terminals. No new terminals were added until 4.4 which
+    ## Gnuplot 4.0 terminals.  No new terminals were added until 4.4 which
     ## allows the list of terminals to be obtained from GPVAL_TERMINALS.
     available_terminals = {"aifm", "aqua", "canvas", "cgm", "corel", ...
                            "dumb", "dxf", "eepic", "emf", "epslatex", ...
                            "epson_180dpi", "fig", "gif", "gnugraph", ...
                            "gpic", "hp2623A", "hp2648", "hp500c", ...
                            "hpgl", "hpljii", "hppj", "imagen", "jpeg", ...
                            "latex", "mf", "mif", "mp", "pbm", "pdf", ...
                            "pm", "png", "postscript", "pslatex", ...
diff --git a/scripts/plot/util/private/__gnuplot_print__.m b/scripts/plot/util/private/__gnuplot_print__.m
--- a/scripts/plot/util/private/__gnuplot_print__.m
+++ b/scripts/plot/util/private/__gnuplot_print__.m
@@ -233,17 +233,17 @@ function f = font_spec (opts, varargin)
       elseif (! isempty (opts.font))
         f = sprintf ('font "%s"', opts.font);
       elseif (! isempty (opts.fontsize))
         f = sprintf ("%d", opts.fontsize);
       endif
     case {"eps", "eps2", "epsc", "epsc2"}
       ## Gnuplot renders fonts as half their specification, which
       ## results in a tight spacing for the axes-labels and tick-labels.
-      ## Compensate for the half scale. This will produce the proper
+      ## Compensate for the half scale.  This will produce the proper
       ## spacing for the requested fontsize.
       if (! isempty (opts.font) && ! isempty (opts.fontsize))
         f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
       elseif (! isempty (opts.font))
         f = sprintf ('font "%s"', opts.font);
       elseif (! isempty (opts.fontsize))
         f = sprintf ("%d", 2 * opts.fontsize);
       endif
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -252,18 +252,18 @@ function [h, sout] = createaxes (s, p, p
     endif
 
     ## visibility
     tst = arrayfun (@(x) strcmp (x.properties.visible, "on"), kids);
     if (! any (tst))
       legend ("hide");
     endif
 
-    ## remove all properties such as "textposition" that redefines
-    ## the entire legend. Also remove chidren
+    ## remove all properties such as "textposition" that redefine
+    ## the entire legend.  Also remove chidren.
     s.properties = rmfield (s.properties, ...
                               {"userdata", "xlabel",...
                                "ylabel", "zlabel", "location", ...
                                "title", "string","orientation", ...
                                "visible", "textposition"});
 
     s.children = [];
 
@@ -537,17 +537,17 @@ function [h, sout, pout] = createhg_hile
 
     h = area (xdata, ydata, level);
 
     ## delete already set properties,
     s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", ...
                                "xdatasource", "ydatasource"});
   else
-    warning ("struct2hdl: could not infer the hggroup type. Will build objects but listener/callback functions will be lost");
+    warning ("struct2hdl: could not infer the hggroup type.  Will build objects but listener/callback functions will be lost");
     h = hggroup ("parent", par);
     addmissingprops (h, s.properties);
     s.special = [];           # children will be treated as normal children
   endif
   sout = s;
   pout = p;
 endfunction
 
@@ -560,17 +560,17 @@ function setprops (s, h, p, hilev)
       hdls = [specs.handle];
     endif
     nh = length (hdls);
     msg = "";
     if (! nh)
       set (h, s.properties);
     else
       ## Specials are objects that where automatically constructed with
-      ## current object. Among them are "x(yz)labels", "title", high
+      ## current object.  Among them are "x(yz)labels", "title", high
       ## level hggroup children
       fields = fieldnames (s.properties);
       vals = struct2cell (s.properties);
       idx = find (cellfun (@(x) valcomp(x, hdls) , vals));
       s.properties = rmfield (s.properties, fields(idx));
 
       ## set all properties but special handles
       set (h, s.properties);
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -365,18 +365,18 @@ function [pos, opos, li] = subplot_posit
   li = [margin.left, margin.bottom, margin.right, margin.top];
 
 endfunction
 
 function subplot_align (h, d, rmupdate = false)
   persistent updating = false;
   if (! updating)
     if (rmupdate)
-      ## The "position" property has been changed from outside this
-      ## routine. Don't update anymore.
+      ## The "position" property has been changed from outside this routine.
+      ## Don't update anymore.
       if (isappdata (h, "__subplotposition__"))
         rmappdata (h, "__subplotposition__");
         rmappdata (h, "__subplotouterposition__");
       endif
       return
     endif
 
     unwind_protect
@@ -391,18 +391,18 @@ function subplot_align (h, d, rmupdate =
         do_align = ! cellfun (@isempty, pos);
         pos = cell2mat (pos(do_align));
       else
         return
       endif
       hsubplots = children(do_align);
 
 
-      ## There may be mixed subplot series (e.g. 2-by-6 and 1-by-6) in
-      ## the same figure. Only subplots that have the same width and
+      ## There may be mixed subplot series (e.g., 2-by-6 and 1-by-6) in
+      ## the same figure.  Only subplots that have the same width and
       ## height as this one are updated.
       if (any (h == hsubplots))
         width = pos(h == hsubplots, 3);
         height = pos(h == hsubplots, 4);
         do_align = (pos(:,3) == width) & (pos(:,4) == height);
         hsubplots(! do_align) = [];
         pos(! do_align,:) = [];
       else
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -131,18 +131,18 @@ function [p, s, mu] = polyfit (x, y, n)
       s.yf = yf.';
     else
       s.yf = yf;
     endif
     s.X = v;
 
     ## r.'*r is positive definite if X(:, polymask) is of full rank.
     ## Invert it by cholinv to avoid taking the square root of squared
-    ## quantities. If cholinv fails, then X(:, polymask) is rank
-    ## deficient and not invertible.
+    ## quantities.  If cholinv fails, then X(:, polymask) is rank deficient
+    ## and not invertible.
     try
       C = cholinv (r.'*r)(k, k);
     catch
       C = NaN (m+1, m+1);
     end_try_catch
 
     if (n != m)
       ## fill matrices if required
@@ -165,17 +165,17 @@ endfunction
 
 %!shared x
 %! x = [-2, -1, 0, 1, 2];
 %!assert (polyfit (x, x.^2+x+1, 2), [1, 1, 1], sqrt (eps))
 %!assert (polyfit (x, x.^2+x+1, 3), [0, 1, 1, 1], sqrt (eps))
 %!fail ("polyfit (x, x.^2+x+1)")
 %!fail ("polyfit (x, x.^2+x+1, [])")
 
-## Test difficult case where scaling is really needed. This example
+## Test difficult case where scaling is really needed.  This example
 ## demonstrates the rather poor result which occurs when the dependent
 ## variable is not normalized properly.
 ## Also check the usage of 2nd & 3rd output arguments.
 %!test
 %! warning ("off", "Octave:nearly-singular-matrix", "local");
 %! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, ...
 %!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
 %! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966, ...
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -154,17 +154,17 @@ function [r, p, k, e] = residue (b, a, v
   toler = .001;
 
   if (nargin >= 3)
     if (nargin >= 4)
       e = varargin{2};
     else
       e = [];
     endif
-    ## The inputs are the residue, pole, and direct part. Solve for the
+    ## The inputs are the residue, pole, and direct part.  Solve for the
     ## corresponding numerator and denominator polynomials
     [r, p] = rresidue (b, a, varargin{1}, toler, e);
     return;
   endif
 
   ## Make sure both polynomials are in reduced form.
 
   a = polyreduce (a);
@@ -193,17 +193,17 @@ function [r, p, k, e] = residue (b, a, v
   lp = length (p);
 
   ## Sort poles so that multiplicity loop will work.
 
   [e, indx] = mpoles (p, toler, 1);
   p = p(indx);
 
   ## For each group of pole multiplicity, set the value of each
-  ## pole to the average of the group. This reduces the error in
+  ## pole to the average of the group.  This reduces the error in
   ## the resulting poles.
 
   p_group = cumsum (e == 1);
   for ng = 1:p_group(end)
     m = find (p_group == ng);
     p(m) = mean (p(m));
   endfor
 
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -80,42 +80,42 @@ function S = sprandsym (n, d)
 endfunction
 
 function r = pick_rand_diag (n, k)
   ## Pick a random number R of entries for the diagonal of a sparse NxN
   ## symmetric square matrix with exactly K nonzero entries, ensuring
   ## that this R is chosen uniformly over all such matrices.
   ##
   ## Let D be the number of diagonal entries and M the number of
-  ## off-diagonal entries. Then K = D + 2*M. Let A = N*(N-1)/2 be the
+  ## off-diagonal entries.  Then K = D + 2*M.  Let A = N*(N-1)/2 be the
   ## number of available entries in the upper triangle of the matrix.
   ## Then, by a simple counting argument, there is a total of
   ##
   ##     T = nchoosek (N, D) * nchoosek (A, M)
   ##
   ## symmetric NxN matrices with a total of K nonzero entries and D on
-  ## the diagonal. Letting D range from mod (K,2) through min (N,K), and
+  ## the diagonal.  Letting D range from mod (K,2) through min (N,K), and
   ## dividing by this sum, we obtain the probability P for D to be each
   ## of those values.
   ##
   ## However, we cannot use this form for computation, as the binomial
-  ## coefficients become unmanageably large. Instead, we use the
+  ## coefficients become unmanageably large.  Instead, we use the
   ## successive quotients Q(i) = T(i+1)/T(i), which we easily compute to
   ## be
   ##
   ##               (N - D)*(N - D - 1)*M
   ##     Q =  -------------------------------
   ##            (D + 2)*(D + 1)*(A - M + 1)
   ##
   ## Then, after prepending 1, the cumprod of these quotients is
   ##
   ##      C = [ T(1)/T(1), T(2)/T(1), T(3)/T(1), ..., T(N)/T(1) ]
   ##
   ## Their sum is thus S = sum (T)/T(1), and then C(i)/S is the desired
-  ## probability P(i) for i=1:N. The cumsum will finally give the
+  ## probability P(i) for i=1:N.  The cumsum will finally give the
   ## distribution function for computing the random number of entries on
   ## the diagonal R.
   ##
   ## Thanks to Zsbn Ambrus <ambrus@math.bme.hu> for most of the ideas
   ## of the implementation here, especially how to do the computation
   ## numerically to avoid overflow.
 
   ## Degenerate case
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -166,17 +166,17 @@ function [u, s, v, flag] = svds (A, k, s
     endif
 
     if (b_sigma == 0)
       ## Find the smallest eigenvalues
       ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
       ## As we are only interested in the positive eigenvalues, we have to
       ## double k and then throw out the k negative eigenvalues.
       ## Separately, if sigma is nonzero, but smaller than the smallest
-      ## singular value, ARPACK may not return k eigenvalues. However, as
+      ## singular value, ARPACK may not return k eigenvalues.  However, as
       ## computation scales with k we'd like to avoid doubling k for all
       ## scalar values of sigma.
       b_k = 2 * k;
     else
       b_k = k;  # Normal case, find just the k largest eigenvalues
     endif
 
     if (nargout > 1)
@@ -188,20 +188,20 @@ function [u, s, v, flag] = svds (A, k, s
     endif
 
     if (ischar (sigma))
       norma = max (s);
     else
       norma = normest (A);
     endif
     ## We wish to exclude all eigenvalues that are less than zero as these
-    ## are artifacts of the way the matrix passed to eigs is formed. There
+    ## are artifacts of the way the matrix passed to eigs is formed.  There
     ## is also the possibility that the value of sigma chosen is exactly
     ## a singular value, and in that case we're dead!! So have to rely on
-    ## the warning from eigs. We exclude the singular values which are
+    ## the warning from eigs.  We exclude the singular values which are
     ## less than or equal to zero to within some tolerance scaled by the
     ## norm since if we don't we might end up with too many singular
     ## values.
     if (b_sigma == 0)
       if (sum (s>0) < k)
         ## It may happen that the number of positive s is less than k.
         ## In this case, take -s (if s in an eigenvalue, so is -s),
         ## flipped upside-down.
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -59,17 +59,17 @@ function [pf, n] = factor (q)
   endif
 
   q = double (q);  # For the time being, calcs rely on double precision var.
   qorig = q;
   pf = [];
   ## There is at most one prime greater than sqrt(q), and if it exists,
   ## it has multiplicity 1, so no need to consider any factors greater
   ## than sqrt(q) directly.  [If there were two factors p1, p2 > sqrt(q),
-  ## then q >= p1*p2 > sqrt(q)*sqrt(q) == q. Contradiction.]
+  ## then q >= p1*p2 > sqrt(q)*sqrt(q) == q.  Contradiction.]
   p = primes (sqrt (q));
   while (q > 1)
     ## Find prime factors in remaining q.
     p = p(rem (q, p) == 0);
     if (isempty (p))
       ## Can't be reduced further, so q must itself be a prime.
       p = q;
     endif
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -398,17 +398,17 @@
 ##
 ## @deftypefn {} {[@var{a}, @var{b}] =} gallery ("wilk", @var{n})
 ## Create various specific matrices devised/discussed by Wilkinson.
 ##
 ## @end deftypefn
 
 ## Code for most of the individual matrices (except binomial, gcdmat,
 ## integerdata, leslie, normaldata, randcolu, randcorr, randjorth, sampling,
-## uniformdata) by Nicholas .J. Higham <Nicholas.J.Higham@manchester.ac.uk>
+## uniformdata) by Nicholas J. Higham <Nicholas.J.Higham@manchester.ac.uk>
 ## Adapted for Octave and into single gallery function by Carn Draug
 
 function [varargout] = gallery (name, varargin)
 
   if (nargin < 1)
     print_usage ();
   elseif (! ischar (name))
     error ("gallery: NAME must be a string.");
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {} {} magic (@var{n})
 ##
 ## Create an @var{n}-by-@var{n} magic square.
 ##
 ## A magic square is an arrangement of the integers @code{1:n^2} such that the
 ## row sums, column sums, and diagonal sums are all equal to the same value.
 ##
-## Note: @var{n} must be a scalar greater than or equal to 3. If you supply
+## Note: @var{n} must be a scalar greater than or equal to 3.  If you supply
 ## @var{n} less than 3, magic returns either a nonmagic square, or else the
 ## degenerate magic squares 1 and [].
 ## @end deftypefn
 
 function A = magic (n)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -122,17 +122,17 @@ function [n, idx] = histc (x, edges, dim
     endif
 
   else
 
     ## This is the O(M*log(N) + N) algorithm.
 
     ## Look-up indices.
     idx = lookup (edges, x);
-    ## Zero invalid ones (including NaNs). x < edges(1) are already zero.
+    ## Zero invalid ones (including NaNs).  x < edges(1) are already zero.
     idx(! (x <= edges(end))) = 0;
 
     iidx = idx;
 
     ## In case of matrix input, we adjust the indices.
     if (! isvector (x))
       nl = prod (sz(1:dim-1));
       nn = sz(dim);
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -335,17 +335,17 @@ endfunction
 %!error quantile (1, 1, 3)
 %!error quantile ((1:5)', 0.5, 1, 0)
 %!error quantile ((1:5)', 0.5, 1, 10)
 
 ## For the cumulative probability values in @var{p}, compute the
 ## quantiles, @var{q} (the inverse of the cdf), for the sample, @var{x}.
 ##
 ## The optional input, @var{method}, refers to nine methods available in R
-## (http://www.r-project.org/). The default is @var{method} = 7.
+## (http://www.r-project.org/).  The default is @var{method} = 7.
 ## @seealso{prctile, quantile, statistics}
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Vectorized version: Jaroslav Hajek <highegg@gmail.com>
 ## Description: Quantile function of empirical samples
 
 function inv = __quantile__ (x, p, method = 5)
 
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -24,18 +24,18 @@
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{spearman, kendall}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute ranks
 
 ## This code was rather ugly, since it didn't use sort due to the
-## fact of how to deal with ties. Now it does use sort and its
-## even uglier!!! At least it handles NDArrays..
+## fact of how to deal with ties.  Now it does use sort and its
+## even uglier!  At least it handles NDArrays.
 
 function y = ranks (x, dim)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (! (isnumeric (x) || islogical (x)))
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -103,17 +103,17 @@ function retval = dec2base (d, base, len
   for k = max_len:-1:1
     digits(:,k) = mod (d, base);
     d = round ((d - digits(:,k)) / base);
   endfor
 
   ## convert digits to symbols
   retval = reshape (symbols(digits+1), size (digits));
 
-  ## Check if the first element is the zero symbol. It seems possible
+  ## Check if the first element is the zero symbol.  It seems possible
   ## that LEN is provided, and is less than the computed MAX_LEN and
   ## MAX_LEN is computed to be one larger than necessary, so we would
   ## have a leading zero to remove.  But if LEN >= MAX_LEN, we should
   ## not remove any leading zeros.
   if ((nargin == 2 || (nargin == 3 && max_len > len))
       && length (retval) != 1 && ! any (retval(:,1) != symbols(1)))
     retval = retval(:,2:end);
   endif
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -54,25 +54,25 @@ function y = strjust (s, pos = "right")
   if (isempty (s))
     y = s;
     return;
   endif
 
   ## Apparently, Matlab considers nulls to be blanks as well; however, does
   ## not preserve the nulls, but rather converts them to blanks.  That's a
   ## bit unexpected, but it allows simpler processing, because we can move
-  ## just the nonblank characters. So we'll do the same here.
+  ## just the nonblank characters.  So we'll do the same here.
 
   [nr, nc] = size (s);
   ## Find the indices of all nonblanks.
   nonbl = s != " " & s != "\0";
   [idx, jdx] = find (nonbl);
 
   if (strcmpi (pos, "right"))
-    ## We wish to find the maximum column index for each row. Because jdx is
+    ## We wish to find the maximum column index for each row.  Because jdx is
     ## sorted, we can take advantage of the fact that assignment is processed
     ## sequentially and for duplicate indices the last value will remain.
     maxs = repmat (nc, [nr, 1]);
     maxs(idx) = jdx;
     shift = nc - maxs;
   elseif (strcmpi (pos, "left"))
     ## See above for explanation.
     mins = ones (nr, 1);
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -909,11 +909,11 @@ endfunction
 ## %!error <wrong pattern> error("message")  # error pattern must match
 ## %!demo   with syntax error  # syntax errors in demo fail properly
 ## %!shared a,b,c
 ## %!demo                      # shared variables not available in demo
 ## %! assert (exist ("a", "var"))
 ## %!error
 ## %! test ('/etc/passwd');
 ## %! test ("nonexistent file");
-## %! ## These don't signal an error, so the test for an error fails. Note
+## %! ## These don't signal an error, so the test for an error fails.  Note
 ## %! ## that the call doesn't reference the current fid (it is unavailable),
 ## %! ## so of course the informational message is not printed in the log.
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -149,17 +149,17 @@ function [days, secs] = datenum (year, m
     day += monthstart (mod (month-1,12) + 1) + 60;
     if (numel (month) > 1)
       day = reshape (day, size (month));
     endif
   else
     day += reshape (monthstart (mod (month-1,12) + 1), size (day)) + 60;
   endif
 
-  ## Add number of days to the start of the current year. Correct
+  ## Add number of days to the start of the current year.  Correct
   ## for leap year every 4 years except centuries not divisible by 400.
   day += 365*year + floor (year/4) - floor (year/100) + floor (year/400);
 
   ## Add fraction representing current second of the day.
   days = day + (hour + (minute + second/60)/60)/24;
 
   ## Output seconds if asked so that etime can be more accurate
   if (isargout (2))
