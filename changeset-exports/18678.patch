# HG changeset patch
# User Rik <rik@octave.org>
# Date 1398457525 25200
#      Fri Apr 25 13:25:25 2014 -0700
# Node ID 6113e0c6920bac495f3e3488b6a8dc4f14339eae
# Parent  f684f7075aeed487c8c878bbf1892ffd089240cd
maint: Clean up extra spaces before/after parentheses.

diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -462,17 +462,17 @@ void Figure::updateBoundingBox (bool int
     {
       QRect r = m_outerRect;
 
       if (flags & UpdateBoundingBoxPosition)
         r.moveTopLeft (win->pos ());
       if (flags & UpdateBoundingBoxSize)
         r.setSize (win->frameGeometry ().size ());
 
-      if (r.isValid () && r != m_outerRect )
+      if (r.isValid () && r != m_outerRect)
         {
           //qDebug() << "outer rect changed:" << m_outerRect << "->>" << r;
           m_outerRect = r;
 
           bb(0) = r.x ();
           bb(1) = r.y ();
           bb(2) = r.width ();
           bb(3) = r.height ();
diff --git a/libgui/qterminal/libqterminal/QTerminal.cc b/libgui/qterminal/libqterminal/QTerminal.cc
--- a/libgui/qterminal/libqterminal/QTerminal.cc
+++ b/libgui/qterminal/libqterminal/QTerminal.cc
@@ -113,10 +113,10 @@ QTerminal::notice_settings (const QSetti
   setSelectionColor
     (settings->value ("terminal/color_s",
                       QVariant (colors.at (2))).value<QColor> ());
 
   setCursorColor
     (cursorUseForegroundColor,
      settings->value ("terminal/color_c",
                       QVariant (colors.at (3))).value<QColor> ());
-  setScrollBufferSize (settings->value ("terminal/history_buffer",1000).toInt() );
+  setScrollBufferSize (settings->value ("terminal/history_buffer",1000).toInt () );
 }
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -546,17 +546,17 @@ files_dock_widget::contextmenu_requested
 
 void
 files_dock_widget::contextmenu_open (bool)
 {
 
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  for ( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+  for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       QFileInfo file = _file_system_model->fileInfo (*it);
       if (file.exists ())
         {
           if (file.isFile ())
             emit open_file (file.absoluteFilePath ());
           else
             set_current_directory (file.absoluteFilePath ());
@@ -656,17 +656,17 @@ files_dock_widget::contextmenu_rename (b
 }
 
 void
 files_dock_widget::contextmenu_delete (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  for ( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+  for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       QModelIndex index = *it;
 
       QFileInfo info = _file_system_model->fileInfo (index);
 
       if (QMessageBox::question (this, tr ("Delete file/directory"),
                                  tr ("Are you sure you want to delete\n")
                                  + info.filePath (),
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -96,17 +96,17 @@ find_files_model::clear ()
   _files.clear ();
 
   endResetModel ();
 }
 
 void
 find_files_model::addFile (const QFileInfo &info)
 {
-  beginInsertRows (QModelIndex (), _files.size (), _files.size () );
+  beginInsertRows (QModelIndex (), _files.size (), _files.size ());
 
   QList<QFileInfo>::Iterator it;
   find_file_less_than less_than (_sortorder);
 
   for (it=_files.begin (); it!=_files.end (); it++)
     {
       if (less_than (info, *it)) break;
     }
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -201,17 +201,17 @@ history_dock_widget::clear_history (void
 void
 history_dock_widget::copyClipboard ()
 {
   if (_history_list_view->hasFocus ())
     handle_contextmenu_copy (true);
   if (_filter_line_edit->hasFocus () && _filter_line_edit->hasSelectedText ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
-      clipboard->setText ( _filter_line_edit->selectedText ());
+      clipboard->setText (_filter_line_edit->selectedText ());
     }
 }
 
 void
 history_dock_widget::pasteClipboard ()
 {
   if (_filter_line_edit->hasFocus ())
     {
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -35,17 +35,17 @@ public:
   file_editor_interface (QWidget *p)
     : octave_dock_widget (p)
   {
     setObjectName ("FileEditor");
   }
 
   virtual ~file_editor_interface () { }
 
-  virtual QMenu *get_mru_menu ( ) = 0;
+  virtual QMenu *get_mru_menu () = 0;
   virtual QMenu *debug_menu () = 0;
   virtual QToolBar *toolbar () = 0;
 
   virtual void insert_new_open_actions (QAction*,QAction*,QAction*) = 0;
   virtual void handle_enter_debug_mode (void) = 0;
   virtual void handle_exit_debug_mode (void) = 0;
 
   virtual void
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -110,17 +110,17 @@ octave_qscintilla::context_run ()
     contextmenu_run (true);
 }
 
 #ifdef HAVE_QSCI_VERSION_2_6_0
 // context menu requested
 void
 octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
 {
-  QMenu *context_menu = createStandardContextMenu ( );  // standard menu
+  QMenu *context_menu = createStandardContextMenu ();  // standard menu
 
   // the menu's position
   QPoint global_pos, local_pos;
 
   if (e->reason () == QContextMenuEvent::Mouse)
     {
       // context menu by mouse
       global_pos = e->globalPos ();            // global mouse position
@@ -198,13 +198,13 @@ octave_qscintilla::contextmenu_edit (boo
   emit execute_command_in_terminal_signal (QString("edit ") + _word_at_cursor);
 }
 
 void
 octave_qscintilla::contextmenu_run (bool)
 {
   QStringList commands = selectedText ().split (QRegExp("[\r\n]"),
                                                 QString::SkipEmptyParts);
-  for (int i = 0; i < commands.size (); i++ )
+  for (int i = 0; i < commands.size (); i++)
     emit execute_command_in_terminal_signal (commands.at (i));
 }
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1971,17 +1971,17 @@ main_window::hide_warning_bar (void)
 
   construct_gui_info_button ();
 }
 
 void
 main_window::show_gui_info (void)
 {
   QString gui_info
-    ( QObject::tr ("<p><strong>A Note about Octave's New GUI</strong></p>"
+    (QObject::tr ("<p><strong>A Note about Octave's New GUI</strong></p>"
          "<p>One of the biggest new features for Octave 3.8 is a graphical "
          "user interface.  It is the one thing that users have requested "
          "most often over the last few years and now it is almost ready.  "
          "But because it is not quite as polished as we would like, we "
          "have decided to wait until the 4.0.x release series before "
          "making the GUI the default interface.</p>"
          "<p>Given the length of time and the number of bug fixes and "
          "improvements since the last major release, we also "
@@ -2368,17 +2368,17 @@ main_window::clear_clipboard ()
 
 bool
 main_window::confirm_exit_octave ()
 {
   bool closenow = true;
 
   QSettings *settings = resource_manager::get_settings ();
 
-  if (settings->value ("prompt_to_exit", false ).toBool())
+  if (settings->value ("prompt_to_exit", false).toBool ())
     {
       int ans = QMessageBox::question (this, tr ("Octave"),
          tr ("Are you sure you want to exit Octave?"),
           QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);
 
       if (ans !=  QMessageBox::Ok)
         closenow = false;
 
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -61,17 +61,17 @@ octave_dock_widget::octave_dock_widget (
   connect (_dock_action, SIGNAL (triggered (bool)),
            this, SLOT (change_floating (bool)));
   _dock_button = new QToolButton (this);
   _dock_button->setDefaultAction (_dock_action);
   _dock_button->setFocusPolicy (Qt::NoFocus);
   _dock_button->setIconSize (QSize (12,12));
 
   _close_action = new QAction
-                   (QIcon (":/actions/icons/widget-close.png"), "", this );
+                   (QIcon (":/actions/icons/widget-close.png"), "", this);
   _close_action-> setToolTip (tr ("Hide widget"));
   connect (_close_action, SIGNAL (triggered (bool)),
            this, SLOT (change_visibility (bool)));
   _close_button = new QToolButton (this);
   _close_button->setDefaultAction (_close_action);
   _close_button->setFocusPolicy (Qt::NoFocus);
   _close_button->setIconSize (QSize (12,12));
 
@@ -173,17 +173,17 @@ octave_dock_widget::make_window ()
   settings->setValue ("DockWidgets/" + objectName (), saveGeometry ());
   settings->sync ();
 
   // remove parent and adjust the (un)dock icon
   setParent (0, Qt::Window);
   _dock_action->setIcon (QIcon (":/actions/icons/widget-dock"+_icon_color+".png"));
   _dock_action->setToolTip (tr ("Dock widget"));
 
-  // restore the last geometry( when floating
+  // restore the last geometry when floating
   setGeometry (settings->value ("DockWidgets/" + objectName ()
                        + "_floating_geometry",QRect(50,100,480,480)).toRect ());
 
 #else
 
   // non windows: Just set the appripriate window flag
   setWindowFlags (Qt::Window);
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -95,17 +95,17 @@ octave_qt_link::do_prompt_new_edit_file 
   QStringList role;
   role << "AcceptRole" << "AcceptRole";
   btn << tr ("Yes") << tr ("No");
 
   uiwidget_creator.signal_dialog (
     tr ("File\n%1\ndoes not exist. Do you want to create it?").
     arg (QDir::currentPath () + QDir::separator ()
          + QString::fromStdString (file)),
-    tr ("Octave Editor"), "quest", btn, tr ("Yes"), role );
+    tr ("Octave Editor"), "quest", btn, tr ("Yes"), role);
 
   // Wait while the user is responding to message box.
   uiwidget_creator.wait ();
   // The GUI has sent a signal and the process has been awakened.
   QString answer = uiwidget_creator.get_dialog_button ();
 
   return (answer == tr ("Yes"));
 }
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -72,17 +72,17 @@ parser::get_info_path ()
 {
   return _info_path;
 }
 
 QIODevice *
 parser::open_file (QFileInfo & file_info)
 {
   QIODevice *iodevice = 0;
-  if ( _compressors_map.contains(file_info.suffix ()))
+  if (_compressors_map.contains (file_info.suffix ()))
     {
       QProcess gzip;
       gzip.start (_compressors_map.value (file_info.suffix ()).arg (file_info.absoluteFilePath ()));
 
       if (!gzip.waitForFinished ())
         return 0;
 
       QByteArray result = gzip.readAll ();
@@ -272,17 +272,17 @@ parser::get_node_prev (const QString& te
 }
 
 static void
 replace_links (QString& text)
 {
   QRegExp re ("(\\*[N|n]ote|\n\\*)([ |\n]+)([^:]+):([^:\\.,]*)([:,\\.]+)");
   int i = 0, f;
 
-  while ( (i = re.indexIn (text,i)) != -1)
+  while ((i = re.indexIn (text,i)) != -1)
     {
       QString type     = re.cap (1);
       QString note     = re.cap (3);
       QString url_link = re.cap (4);
       QString term     = re.cap (5);
 
       if (url_link.isEmpty ())
         {
@@ -325,17 +325,17 @@ replace_links (QString& text)
     }
 }
 
 static void
 replace_colons (QString& text)
 {
   QRegExp re ("`([^']+)'");
   int i = 0, f;
-  while ( (i = re.indexIn (text, i)) != -1)
+  while ((i = re.indexIn (text, i)) != -1)
     {
       QString t = re.cap (1);
       QString bold = "<font style=\"color:SteelBlue;font-weight:bold\">" + t +
                      "</font>";
 
       f = re.matchedLength ();
       text.replace (i,f,bold);
       i += bold.size ();
@@ -431,17 +431,17 @@ parser::parse_info_map ()
         {
           continue;
         }
 
       QString nodeText;
       while (! (nodeText=get_next_node (io)).isEmpty () && foundCount < 2)
         {
           QString first_line = get_first_line (nodeText);
-          if (first_line.startsWith ("Tag") )
+          if (first_line.startsWith ("Tag"))
             {
               foundCount++;
               int pos = 0;
               QString last_node;
 
               while ((pos = re.indexIn (nodeText, pos)) != -1)
                 {
                   QString type = re.cap (1);
@@ -466,17 +466,17 @@ parser::parse_info_map ()
                 }
               break;
             }
           else if (first_line.startsWith ("Indirect:"))
             {
               foundCount++;
               int pos = 0;
 
-              while ( (pos = re_files.indexIn (nodeText, pos)) != -1)
+              while ((pos = re_files.indexIn (nodeText, pos)) != -1)
                 {
                   QString fileCap = re_files.cap (1).trimmed ();
                   int index = re_files.cap (2).toInt ();
 
                   info_file_item item;
                   for (int j = 0; j < _info_files.size (); j++)
                     {
                       QFileInfo info = _info_files.at (j);
@@ -534,17 +534,17 @@ parser::seek (QIODevice *io, int pos)
     }
 }
 
 static void
 replace (QString& text, const QRegExp& re, const QString& after)
 {
   int pos = 0;
 
-  while ( (pos = re.indexIn (text, pos)) != -1)
+  while ((pos = re.indexIn (text, pos)) != -1)
     {
       QString cap = text.mid (pos,re.matchedLength ());
       QString a (after);
       a = a.arg (cap);
       text.remove (pos, re.matchedLength ());
       text.insert (pos, a);
       pos += a.size ();
     }
@@ -574,17 +574,17 @@ parser::global_search (const QString& te
       QFileInfo file_info = _info_files.at (i);
       QIODevice *io = open_file (file_info);
       if (! io)
         {
           continue;
         }
 
       QString node_text;
-      while ( !(node_text = get_next_node (io)).isEmpty ())
+      while (! (node_text = get_next_node (io)).isEmpty ())
         {
           QString firstLine = get_first_line (node_text);
           QString node = get_node_name (node_text);
           if (node.isEmpty ())
             {
               continue;
             }
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -177,17 +177,17 @@ webinfo::current_tab_changed (int index)
 QTextBrowser *
 webinfo::addNewTab (const QString& name)
 {
   _text_browser = new QTextBrowser (this);
   _text_browser->setOpenLinks (false);
   _text_browser->show ();
 
   connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this,
-           SLOT (link_clicked (const QUrl &)) );
+           SLOT (link_clicked (const QUrl &)));
   disconnect(_tab_bar, SIGNAL (currentChanged(int)), this,
              SLOT (current_tab_changed (int)));
 
   int ns = _stacked_widget->addWidget (_text_browser);
   _stacked_widget->setCurrentIndex (ns);
 
   int nt = _tab_bar->addTab (name);
   _tab_bar->setCurrentIndex (nt);
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -131,36 +131,36 @@ settings_dialog::settings_dialog (QWidge
            this, SLOT (get_octave_dir ()));
 
   // editor
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",
                                                         false).toBool ());
   ui->customFileEditor->setText (
     settings->value ("customFileEditor").toString ());
   ui->editor_showLineNumbers->setChecked (
-    settings->value ("editor/showLineNumbers",true).toBool () );
+    settings->value ("editor/showLineNumbers",true).toBool ());
 
   default_var = QColor (240, 240, 240);
   QColor setting_color = settings->value ("editor/highlight_current_line_color",
                                           default_var).value<QColor> ();
   _editor_current_line_color = new color_picker (setting_color);
   ui->editor_grid_current_line->addWidget (_editor_current_line_color,0,3);
   _editor_current_line_color->setMinimumSize (50,10);
   _editor_current_line_color->setEnabled (false);
   connect (ui->editor_highlightCurrentLine, SIGNAL (toggled (bool)),
            _editor_current_line_color, SLOT (setEnabled (bool)));
   ui->editor_highlightCurrentLine->setChecked (
-    settings->value ("editor/highlightCurrentLine",true).toBool () );
+    settings->value ("editor/highlightCurrentLine",true).toBool ());
   ui->editor_long_line_marker->setChecked (
     settings->value ("editor/long_line_marker",true).toBool ());
   ui->editor_long_line_column->setValue (
     settings->value ("editor/long_line_column",80).toInt ());
 
   ui->editor_codeCompletion->setChecked (
-    settings->value ("editor/codeCompletion", true).toBool () );
+    settings->value ("editor/codeCompletion", true).toBool ());
   ui->editor_spinbox_ac_threshold->setValue (
     settings->value ("editor/codeCompletion_threshold",2).toInt ());
   ui->editor_checkbox_ac_keywords->setChecked (
     settings->value ("editor/codeCompletion_keywords",true).toBool ());
   ui->editor_checkbox_ac_document->setChecked (
     settings->value ("editor/codeCompletion_document",false).toBool ());
   ui->editor_checkbox_ac_case->setChecked (
     settings->value ("editor/codeCompletion_case",true).toBool ());
@@ -190,17 +190,17 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("editor/notebook_tab_width_max", 300).toInt ());
   ui->editor_restoreSession->setChecked (
     settings->value ("editor/restoreSession", true).toBool ());
   ui->editor_create_new_file->setChecked (
     settings->value ("editor/create_new_file",false).toBool ());
 
   // terminal
   ui->terminal_fontName->setCurrentFont (QFont (
-    settings->value ("terminal/fontName","Courier New").toString ()) );
+    settings->value ("terminal/fontName","Courier New").toString ()));
   ui->terminal_fontSize->setValue (
     settings->value ("terminal/fontSize", 10).toInt ());
   ui->terminal_history_buffer->setValue (
      settings->value ("terminal/history_buffer",1000).toInt ());
 
   // file browser
   ui->showFileSize->setChecked (
     settings->value ("filesdockwidget/showFileSize", false).toBool ());
@@ -249,17 +249,17 @@ settings_dialog::settings_dialog (QWidge
     ui->terminal_cursorType->setCurrentIndex (0);
   else if (cursorType == "block")
     ui->terminal_cursorType->setCurrentIndex (1);
   else if (cursorType == "underline")
     ui->terminal_cursorType->setCurrentIndex (2);
 
   int currentIndex = 0;
   QString proxyTypeString = settings->value ("proxyType").toString ();
-  while ( (currentIndex < ui->proxyType->count ())
+  while ((currentIndex < ui->proxyType->count ())
           && (ui->proxyType->currentText () != proxyTypeString))
     {
       currentIndex++;
       ui->proxyType->setCurrentIndex (currentIndex);
     }
 
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
@@ -538,17 +538,17 @@ settings_dialog::write_changed_settings 
                       _widget_title_bg_color->color ());
   settings->setValue ("Dockwidgets/title_fg_color",
                       _widget_title_fg_color->color ());
 
   // icon size
   settings->setValue ("toolbar_icon_size", ui->toolbar_icon_size->value ());
 
   // promp to exit
-  settings->setValue ( "prompt_to_exit", ui->cb_prompt_to_exit->isChecked ());
+  settings->setValue ("prompt_to_exit", ui->cb_prompt_to_exit->isChecked ());
 
   // Octave startup
   settings->setValue ("restore_octave_dir",
                       ui->cb_restore_octave_dir->isChecked ());
   settings->setValue ("octave_startup_dir", ui->le_octave_dir->text ());
 
   //editor
   settings->setValue ("useCustomFileEditor",
@@ -634,17 +634,17 @@ settings_dialog::write_changed_settings 
   settings->setValue ("proxyPassword", ui->proxyPassword->text ());
   settings->setValue ("terminal/cursorBlinking",
                       ui->terminal_cursorBlinking->isChecked ());
   settings->setValue ("terminal/cursorUseForegroundColor",
                       ui->terminal_cursorUseForegroundColor->isChecked ());
   settings->setValue ("terminal/focus_after_command",
                       ui->terminal_focus_command->isChecked ());
   settings->setValue ("terminal/history_buffer",
-                      ui->terminal_history_buffer->value() );
+                      ui->terminal_history_buffer->value ());
 
   // the cursor
   QString cursorType;
   switch (ui->terminal_cursorType->currentIndex ())
     {
     case 0: cursorType = "ibeam"; break;
     case 1: cursorType = "block"; break;
     case 2: cursorType = "underline";  break;
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -77,101 +77,134 @@ shortcut_manager::instance_ok (void)
 }
 
 void
 shortcut_manager::do_init_data ()
 {
   // actions of the main window
 
   // file
-  init (tr ("New File"), "main_file:new_file", QKeySequence::New );
-  init (tr ("New Function"), "main_file:new_function", QKeySequence ("Ctrl+Shift+N") );
-  init (tr ("New Figure"), "main_file:new_figure", QKeySequence () );
-  init (tr ("Open File"), "main_file:open_file", QKeySequence::Open );
-  init (tr ("Load Workspace"), "main_file:load_workspace", QKeySequence () );
-  init (tr ("Save Workspace As"), "main_file:save_workspace", QKeySequence () );
-  init (tr ("Preferences"), "main_file:preferences", QKeySequence () );
-  init (tr ("Exit Octave"), "main_file:exit", QKeySequence::Quit );
+  init (tr ("New File"), "main_file:new_file", QKeySequence::New);
+  init (tr ("New Function"), "main_file:new_function",
+        QKeySequence ("Ctrl+Shift+N"));
+  init (tr ("New Figure"), "main_file:new_figure", QKeySequence ());
+  init (tr ("Open File"), "main_file:open_file", QKeySequence::Open);
+  init (tr ("Load Workspace"), "main_file:load_workspace", QKeySequence ());
+  init (tr ("Save Workspace As"), "main_file:save_workspace", QKeySequence ());
+  init (tr ("Preferences"), "main_file:preferences", QKeySequence ());
+  init (tr ("Exit Octave"), "main_file:exit", QKeySequence::Quit);
 
   // edit
   init (tr ("Copy"), "main_edit:copy", QKeySequence::Copy);
   init (tr ("Paste"), "main_edit:paste", QKeySequence::Paste);
   init (tr ("Undo"), "main_edit:undo", QKeySequence::Undo);
-  init (tr ("Select All"), "main_edit:select_all", QKeySequence () );
-  init (tr ("Clear Clipboard"), "main_edit:clear_clipboard", QKeySequence () );
-  init (tr ("Find in Files"), "main_edit:find_in_files", QKeySequence (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_F) );
-  init (tr ("Clear Command Window"), "main_edit:clear_command_window", QKeySequence () );
-  init (tr ("Clear Command History"), "main_edit:clear_history", QKeySequence () );
-  init (tr ("Clear Workspace"), "main_edit:clear_workspace", QKeySequence () );
+  init (tr ("Select All"), "main_edit:select_all", QKeySequence ());
+  init (tr ("Clear Clipboard"), "main_edit:clear_clipboard", QKeySequence ());
+  init (tr ("Find in Files"), "main_edit:find_in_files",
+        QKeySequence (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_F));
+  init (tr ("Clear Command Window"), "main_edit:clear_command_window",
+        QKeySequence ());
+  init (tr ("Clear Command History"), "main_edit:clear_history",
+        QKeySequence ());
+  init (tr ("Clear Workspace"), "main_edit:clear_workspace", QKeySequence ());
 
   // actions of the editor
 
   // file
-  init (tr ("Edit Function"), "editor_file:edit_function", QKeySequence (Qt::ControlModifier + Qt::Key_E) );
-  init (tr ("Save File"), "editor_file:save", QKeySequence::Save );
-  init (tr ("Save File As"), "editor_file:save_as", QKeySequence::SaveAs );
-  init (tr ("Close"), "editor_file:close", QKeySequence::Close );
-  init (tr ("Close All"), "editor_file:close_all", QKeySequence () );
-  init (tr ("Close Other"), "editor_file:close_other",  QKeySequence () );
-  init (tr ("Print"), "editor_file:print",  QKeySequence::Print );
+  init (tr ("Edit Function"), "editor_file:edit_function",
+        QKeySequence (Qt::ControlModifier + Qt::Key_E));
+  init (tr ("Save File"), "editor_file:save", QKeySequence::Save);
+  init (tr ("Save File As"), "editor_file:save_as", QKeySequence::SaveAs);
+  init (tr ("Close"), "editor_file:close", QKeySequence::Close);
+  init (tr ("Close All"), "editor_file:close_all", QKeySequence ());
+  init (tr ("Close Other"), "editor_file:close_other", QKeySequence ());
+  init (tr ("Print"), "editor_file:print", QKeySequence::Print);
 
   // edit
-  init (tr ("Undo"), "editor_edit:undo",  QKeySequence::Undo );
-  init (tr ("Redo"), "editor_edit:redo",  QKeySequence::Redo );
-  init (tr ("Copy"), "editor_edit:copy",  QKeySequence::Copy );
-  init (tr ("Cuy"), "editor_edit:cut",  QKeySequence::Cut );
-  init (tr ("Paste"), "editor_edit:paste",  QKeySequence::Paste );
-  init (tr ("Select All"), "editor_edit:select_all",  QKeySequence::SelectAll );
-  init (tr ("Find and Replace"), "editor_edit:find_replace",  QKeySequence::Find );
+  init (tr ("Undo"), "editor_edit:undo", QKeySequence::Undo);
+  init (tr ("Redo"), "editor_edit:redo", QKeySequence::Redo);
+  init (tr ("Copy"), "editor_edit:copy", QKeySequence::Copy);
+  init (tr ("Cuy"), "editor_edit:cut", QKeySequence::Cut);
+  init (tr ("Paste"), "editor_edit:paste", QKeySequence::Paste);
+  init (tr ("Select All"), "editor_edit:select_all", QKeySequence::SelectAll);
+  init (tr ("Find and Replace"), "editor_edit:find_replace",
+        QKeySequence::Find);
 
-  init (tr ("Delete to Start of Word"), "editor_edit:delete_start_word",  QKeySequence::DeleteStartOfWord );
-  init (tr ("Delete to End of Word"), "editor_edit:delete_end_word",  QKeySequence::DeleteEndOfWord );
-  init (tr ("Delete to Start of Line"), "editor_edit:delete_start_line",  QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_Backspace) );
-  init (tr ("Delete to End of Line"), "editor_edit:delete_end_line",  QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_Delete) );
-  init (tr ("Delete Line"), "editor_edit:delete_line",  QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_L) );
-  init (tr ("Copy Line"), "editor_edit:copy_line",  QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_C) );
-  init (tr ("Cut Line"), "editor_edit:cut_line",  QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_X) );
-  init (tr ("Duplicate Selection/Line"), "editor_edit:duplicate_selection",  QKeySequence (Qt::ControlModifier + Qt::Key_D) );
-  init (tr ("Transpose Line"), "editor_edit:transpose_line",  QKeySequence (Qt::ControlModifier + Qt::Key_T) );
-  init (tr ("Completion List"), "editor_edit:completion_list",  QKeySequence (Qt::ControlModifier + Qt::Key_Space) );
+  init (tr ("Delete to Start of Word"), "editor_edit:delete_start_word", 
+        QKeySequence::DeleteStartOfWord);
+  init (tr ("Delete to End of Word"), "editor_edit:delete_end_word", 
+        QKeySequence::DeleteEndOfWord);
+  init (tr ("Delete to Start of Line"), "editor_edit:delete_start_line",
+        QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_Backspace));
+  init (tr ("Delete to End of Line"), "editor_edit:delete_end_line",
+        QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_Delete));
+  init (tr ("Delete Line"), "editor_edit:delete_line", 
+        QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_L));
+  init (tr ("Copy Line"), "editor_edit:copy_line",
+        QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_C));
+  init (tr ("Cut Line"), "editor_edit:cut_line",
+        QKeySequence (Qt::ControlModifier + Qt::SHIFT + Qt::Key_X));
+  init (tr ("Duplicate Selection/Line"), "editor_edit:duplicate_selection", 
+        QKeySequence (Qt::ControlModifier + Qt::Key_D));
+  init (tr ("Transpose Line"), "editor_edit:transpose_line", 
+        QKeySequence (Qt::ControlModifier + Qt::Key_T));
+  init (tr ("Completion List"), "editor_edit:completion_list",
+        QKeySequence (Qt::ControlModifier + Qt::Key_Space));
 
-  init (tr ("Comment Selection"), "editor_edit:comment_selection",  QKeySequence (Qt::ControlModifier + Qt::Key_R) );
-  init (tr ("Uncomment Selection"), "editor_edit:uncomment_selection",  QKeySequence (Qt::SHIFT + Qt::ControlModifier + Qt::Key_R) );
-  init (tr ("Uppercase Selection"), "editor_edit:upper_case",  QKeySequence (Qt::ControlModifier + Qt::Key_U) );
-  init (tr ("Lowercase Selection"), "editor_edit:lower_case",  QKeySequence (Qt::ControlModifier + Qt::AltModifier + Qt::Key_U) );
-  init (tr ("Indent Selection"), "editor_edit:indent_selection",  QKeySequence (Qt::ControlModifier + Qt::Key_Tab) );
-  init (tr ("Unindent Selection"), "editor_edit:unindent_selection",  QKeySequence (Qt::SHIFT + Qt::ControlModifier + Qt::Key_Tab) );
+  init (tr ("Comment Selection"), "editor_edit:comment_selection",
+        QKeySequence (Qt::ControlModifier + Qt::Key_R));
+  init (tr ("Uncomment Selection"), "editor_edit:uncomment_selection", 
+        QKeySequence (Qt::SHIFT + Qt::ControlModifier + Qt::Key_R));
+  init (tr ("Uppercase Selection"), "editor_edit:upper_case",
+        QKeySequence (Qt::ControlModifier + Qt::Key_U));
+  init (tr ("Lowercase Selection"), "editor_edit:lower_case",
+        QKeySequence (Qt::ControlModifier + Qt::AltModifier + Qt::Key_U));
+  init (tr ("Indent Selection"), "editor_edit:indent_selection", 
+        QKeySequence (Qt::ControlModifier + Qt::Key_Tab));
+  init (tr ("Unindent Selection"), "editor_edit:unindent_selection",
+        QKeySequence (Qt::SHIFT + Qt::ControlModifier + Qt::Key_Tab));
 
-  init (tr ("Goto Line"), "editor_edit:goto_line",  QKeySequence (Qt::ControlModifier+ Qt::Key_G) );
-  init (tr ("Toggle Bookmark"), "editor_edit:toggle_bookmark",  QKeySequence (Qt::Key_F7) );
-  init (tr ("Next Bookmark"), "editor_edit:next_bookmark",  QKeySequence (Qt::Key_F2) );
-  init (tr ("Previous Bookmark"), "editor_edit:previous_bookmark",  QKeySequence (Qt::SHIFT + Qt::Key_F2) );
-  init (tr ("Remove All Bookmark"), "editor_edit:remove_bookmark",  QKeySequence () );
+  init (tr ("Goto Line"), "editor_edit:goto_line",
+        QKeySequence (Qt::ControlModifier+ Qt::Key_G));
+  init (tr ("Toggle Bookmark"), "editor_edit:toggle_bookmark",
+        QKeySequence (Qt::Key_F7));
+  init (tr ("Next Bookmark"), "editor_edit:next_bookmark",
+        QKeySequence (Qt::Key_F2));
+  init (tr ("Previous Bookmark"), "editor_edit:previous_bookmark",
+        QKeySequence (Qt::SHIFT + Qt::Key_F2));
+  init (tr ("Remove All Bookmark"), "editor_edit:remove_bookmark",
+        QKeySequence ());
 
-  init (tr ("Preferences"), "editor_edit:preferences",  QKeySequence () );
-  init (tr ("Styles Preferences"), "editor_edit:styles_preferences",  QKeySequence () );
+  init (tr ("Preferences"), "editor_edit:preferences", QKeySequence ());
+  init (tr ("Styles Preferences"), "editor_edit:styles_preferences",
+        QKeySequence ());
 
   // view
-  init (tr ("Zoom In"), "editor_view:zoom_in",  QKeySequence::ZoomIn );
-  init (tr ("Zoom Out"), "editor_view:zoom_out",  QKeySequence::ZoomOut );
-  init (tr ("Zoom Normal"), "editor_view:zoom_normal",  QKeySequence (Qt::ControlModifier + Qt::Key_Slash) );
+  init (tr ("Zoom In"), "editor_view:zoom_in", QKeySequence::ZoomIn);
+  init (tr ("Zoom Out"), "editor_view:zoom_out", QKeySequence::ZoomOut);
+  init (tr ("Zoom Normal"), "editor_view:zoom_normal",
+        QKeySequence (Qt::ControlModifier + Qt::Key_Slash));
 
   // debug
-  init (tr ("Toggle Breakpoint"), "editor_debug:toggle_breakpoint",  QKeySequence () );
-  init (tr ("Next Breakpoint"), "editor_debug:next_breakpoint",  QKeySequence () );
-  init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",  QKeySequence () );
-  init (tr ("Remove All Breakpoints"), "editor_debug:remove_breakpoints",  QKeySequence () );
+  init (tr ("Toggle Breakpoint"), "editor_debug:toggle_breakpoint",
+        QKeySequence ());
+  init (tr ("Next Breakpoint"), "editor_debug:next_breakpoint",
+        QKeySequence ());
+  init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",
+        QKeySequence ());
+  init (tr ("Remove All Breakpoints"), "editor_debug:remove_breakpoints",
+        QKeySequence ());
 
   // run
-  init (tr ("Run File"), "editor_run:run_file", QKeySequence (Qt::Key_F5) );
-  init (tr ("Run Selection"), "editor_run:run_selection", QKeySequence (Qt::Key_F9) );
+  init (tr ("Run File"), "editor_run:run_file", QKeySequence (Qt::Key_F5));
+  init (tr ("Run Selection"), "editor_run:run_selection", QKeySequence (Qt::Key_F9));
 
   // help
-  init (tr ("Help on Keyword"), "editor_help:help_keyword", QKeySequence::HelpContents );
-  init (tr ("Document on Keyword"), "editor_help:doc_keyword", QKeySequence (Qt::SHIFT + Qt::Key_F1) );
+  init (tr ("Help on Keyword"), "editor_help:help_keyword", QKeySequence::HelpContents);
+  init (tr ("Document on Keyword"), "editor_help:doc_keyword", QKeySequence (Qt::SHIFT + Qt::Key_F1));
 }
 
 void
 shortcut_manager::init (QString description, QString key, QKeySequence def_sc)
 {
   QKeySequence actual = QKeySequence (_settings->value ("shortcuts/"+key, def_sc).toString ());
 
   // append the new shortcut to the list
@@ -275,17 +308,17 @@ shortcut_manager::do_write_shortcuts ()
 }
 
 void
 shortcut_manager::do_set_shortcut (QAction* action, const QString& key)
 {
   int index = _action_hash[key] - 1;
 
   if (index > -1 && index < _sc.count ())
-    action->setShortcut ( QKeySequence (
+    action->setShortcut (QKeySequence (
       _settings->value ("shortcuts/" + key, _sc.at (index).default_sc).toString ()));
   else
     qDebug () << "Key: " << key << " not found in _action_hash";
 }
 
 void
 shortcut_manager::handle_double_clicked (QTreeWidgetItem* item, int)
 {
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -136,17 +136,17 @@ workspace_model::data (const QModelIndex
           if (actual_class >= 0)
             return QVariant (_storage_class_colors.at (actual_class));
           else
             return retval;
         }
 
       if (role == Qt::DisplayRole
           || (idx.column () == 0 && role == Qt::EditRole)
-          || (idx.column () == 0 && role == Qt::ToolTipRole) )
+          || (idx.column () == 0 && role == Qt::ToolTipRole))
         {
           switch (idx.column ())
             {
             case 0:
               if (role == Qt::ToolTipRole)
                 retval
                   = QVariant (tr ("Right click to copy, rename, or display"));
               else
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -590,17 +590,17 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
           int64_t mask = max_mantissa_value<double> ();
           if (nbits < bits_in_mantissa)
             mask = mask >> (bits_in_mantissa - nbits);
           else if (nbits < 1)
             mask = 0;
           int bits_in_type = sizeof (double)
                              * std::numeric_limits<unsigned char>::digits;
           NDArray m = m_arg.array_value ();
-          DO_BITSHIFT ( );
+          DO_BITSHIFT ();
         }
       else if (cname == "single")
         {
           static const int bits_in_mantissa
             = std::numeric_limits<float>::digits;
           nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
           int64_t mask = max_mantissa_value<float> ();
           if (nbits < bits_in_mantissa)
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1222,17 +1222,17 @@ arrayfun (@@str2num, [1234],\n\
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
       // The following is an optimisation because the symbol table can
       // give a more specific function class, so this can result in
       // fewer polymorphic function calls as the function gets called
       // for each value of the array.
 
-      if (! symbol_table_lookup )
+      if (! symbol_table_lookup)
         {
           if (func.is_function_handle ())
             {
               octave_fcn_handle* f = func.fcn_handle_value ();
 
               // Overloaded function handles need to check the type of
               // the arguments for each element of the array, so they
               // cannot be optimised this way.
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2315,18 +2315,18 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
 %!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [], []), zeros (0, 0, 3))
 
 %!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
 %!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
 
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat ([0;0;0;1],[1,2,2]) )
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat (zeros (3,2,2), ones (1,2,2)) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat ([0;0;0;1],[1,2,2]))
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat (zeros (3,2,2), ones (1,2,2)))
 
 %!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
 %!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -164,17 +164,17 @@ find_nonzero_elem_idx (const Sparse<T>& 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
-        for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++ )
+        for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++)
           {
             OCTAVE_QUIT;
             if (direction < 0 && i < nz - count)
               continue;
             i_idx(cx) = static_cast<double> (v.ridx (i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
             idx(cx) = j * nr + v.ridx (i) + 1;
             val(cx) = v.data(i);
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -225,17 +225,17 @@ ambiguous.\n\
   pair_type ("(",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} (\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type (")",
     "-*- texinfo -*-\n\
-@deftypefn {Operator} {} )\n\
+@deftypefn {Operator} {})\n\
 Array index or function argument delimiter.\n\
 @end deftypefn"),
 
   pair_type ("*",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -258,17 +258,17 @@ hdf5_read_next_data (hid_t group_id, con
   herr_t retval = 0;
   bool ident_valid = valid_identifier (name);
 
   std::string vname = name;
 
   // Allow identifiers as all digits so we can load lists saved by
   // earlier versions of Octave.
 
-  if (! ident_valid )
+  if (! ident_valid)
     {
       // fix the identifier, replacing invalid chars with underscores
       vname = make_valid_identifier (vname);
 
       // check again (in case vname was null, empty, or some such thing):
       ident_valid = valid_identifier (vname);
     }
 
@@ -611,17 +611,17 @@ read_hdf5_data (std::istream& is, const 
   while (load_named_vars && hs.current_item < static_cast<int> (num_obj))
     {
       std::vector<char> var_name;
       bool found = false;
       size_t len = 0;
 
       len = H5Gget_objname_by_idx (hs.file_id, hs.current_item, 0, 0);
       var_name.resize (len+1);
-      H5Gget_objname_by_idx( hs.file_id, hs.current_item, &var_name[0], len+1);
+      H5Gget_objname_by_idx (hs.file_id, hs.current_item, &var_name[0], len+1);
 
       for (int i = argv_idx; i < argc; i++)
         {
           glob_match pattern (argv[i]);
           if (pattern.match (std::string (&var_name[0])))
             {
               found = true;
               break;
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -434,34 +434,34 @@ read_mat5_integer_data (std::istream& is
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes,
                bool& is_small_data_element)
 {
   unsigned int upper;
   int32_t temp;
 
-  if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
+  if (! is.read (reinterpret_cast<char *> (&temp), 4))
     goto data_read_error;
 
   if (swap)
     swap_bytes<4> (&temp);
 
   upper = (temp >> 16) & 0xffff;
   type = temp & 0xffff;
 
   if (upper)
     {
       // "compressed" format
       bytes = upper;
       is_small_data_element = true;
     }
   else
     {
-      if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
+      if (! is.read (reinterpret_cast<char *> (&temp), 4))
         goto data_read_error;
       if (swap)
         swap_bytes<4> (&temp);
       bytes = temp;
       is_small_data_element = false;
     }
 
   return 0;
@@ -696,17 +696,17 @@ read_mat5_binary_element (std::istream& 
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
     // Structure field subelements have zero-length array name subelements.
 
     std::streampos tmp_pos = is.tellg ();
 
     if (len)
       {
-        if (! is.read (name, len ))
+        if (! is.read (name, len))
           goto data_read_error;
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
       }
 
     name[len] = '\0';
     retval = name;
@@ -1158,17 +1158,17 @@ read_mat5_binary_element (std::istream& 
 
         {
           OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
           std::streampos tmp_pos = is.tellg ();
 
           if (len)
             {
-              if (! is.read (name, len ))
+              if (! is.read (name, len))
                 goto data_read_error;
 
               is.seekg (tmp_pos + static_cast<std::streamoff>
                         (READ_PAD (is_small_data_element, len)));
             }
 
           name[len] = '\0';
           classname = name;
@@ -1188,17 +1188,17 @@ read_mat5_binary_element (std::istream& 
         // that eventually someone will recognize that's a waste of space.
         if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
             || fn_type != miINT32)
           {
             error ("load: invalid field name length subelement");
             goto data_read_error;
           }
 
-        if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len ))
+        if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len))
           goto data_read_error;
 
         if (swap)
           swap_bytes<4> (&field_name_length);
 
         // field name subelement.  The length of this subelement tells
         // us how many fields there are.
         if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -157,29 +157,29 @@ information.\n\
 
   int n = 1;
   while (n < nargin && ! error_state)
     {
       if (args(n).is_string ())
         {
           std::string tmp = args(n++).string_value ();
 
-          if (! error_state )
+          if (! error_state)
             {
               if (tmp.compare ("vector") == 0)
                 vecout = true;
               else
                 error ("lu: unrecognized string argument");
             }
         }
       else
         {
           Matrix tmp = args(n++).matrix_value ();
 
-          if (! error_state )
+          if (! error_state)
             {
               if (!issparse)
                 error ("lu: can not define pivoting threshold THRES for full matrices");
               else if (tmp.nelem () == 1)
                 {
                   thres.resize (1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
@@ -206,47 +206,47 @@ information.\n\
       else if (arg_is_empty > 0)
         return octave_value_list (5, SparseMatrix ());
 
       if (arg.is_real_type ())
         {
 
           SparseMatrix m = arg.sparse_matrix_value ();
 
-          if ( nargout < 4 )
+          if (nargout < 4)
             {
 
               ColumnVector Qinit;
               Qinit.resize (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit (i) = i;
               SparseLU fact (m, Qinit, thres, false, true);
 
-              if ( nargout < 2 )
+              if (nargout < 2)
                   retval(0) = fact.Y ();
               else
                 {
 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),                    
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseMatrix L = fact.L ();
-                  if ( nargout < 3 )
+                  if (nargout < 3)
                       retval(0)
-                        = octave_value ( P.transpose () * L,
+                        = octave_value (P.transpose () * L,
                             MatrixType (MatrixType::Permuted_Lower,
                                         nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
-                      if ( vecout )
+                      if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
 
                 }
 
             }
@@ -274,49 +274,49 @@ information.\n\
                                           MatrixType (MatrixType::Lower));
             }
 
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-          if ( nargout < 4 )
+          if (nargout < 4)
             {
 
               ColumnVector Qinit;
               Qinit.resize (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit (i) = i;
               SparseComplexLU fact (m, Qinit, thres, false, true);
 
-              if ( nargout < 2 )
+              if (nargout < 2)
 
                   retval(0) = fact.Y ();
 
               else
                 {
 
                   retval(1)
                     = octave_value (
                         fact.U () * fact.Pc_mat ().transpose (),                    
                         MatrixType (MatrixType::Permuted_Upper,
                                     nc, fact.col_perm ()));
 
                   PermMatrix P = fact.Pr_mat ();
                   SparseComplexMatrix L = fact.L ();
-                  if ( nargout < 3 )
+                  if (nargout < 3)
                       retval(0)
-                        = octave_value ( P.transpose () * L,
+                        = octave_value (P.transpose () * L,
                             MatrixType (MatrixType::Permuted_Lower,
                                         nr, fact.row_perm ()));
                   else
                     {
                       retval(0) = L;
-                      if ( vecout )
+                      if (vecout)
                         retval(2) = fact.Pr_vec();
                       else
                         retval(2) = P;
                     }
 
                 }
 
             }
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -172,17 +172,17 @@ values of @var{p} @var{q} as vector valu
         }
       else
         droptol = args(1).double_value ();
 
       if (nargin == 3)
         {
           std::string tmp = args(2).string_value ();
 
-          if (! error_state )
+          if (! error_state)
             {
               if (tmp.compare ("vector") == 0)
                 vecout = true;
               else
                 error ("luinc: unrecognized string argument");
             }
         }
 
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -143,17 +143,17 @@ LU@tie{}factorization.  Once the matrix 
           if (nargin == 1)
             {
               MatrixType mattyp;
 
               if (args(0).is_complex_type ())
                 {
                   mattyp = args(0).matrix_type ();
 
-                  if (mattyp.is_unknown () && autocomp )
+                  if (mattyp.is_unknown () && autocomp)
                     {
                       SparseComplexMatrix m =
                         args(0).sparse_complex_matrix_value ();
                       if (!error_state)
                         {
                           mattyp = MatrixType (m);
                           args(0).matrix_type (mattyp);
                         }
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -427,17 +427,17 @@ Undocumented internal function.\n\
 
   retval = octave_link::show_preferences ();
 
   return retval;
 }
 
 DEFUN (__octave_link_show_doc__, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __octave_link_show_doc__ ( @var{filename} )\n\
+@deftypefn {Built-in Function} {} __octave_link_show_doc__ (@var{filename})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string file;
 
   if (args.length () >= 1)
     file = args(0).string_value();
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -923,17 +923,17 @@ compatibility with @sc{matlab}.\n\
 
               if (zcnt == 1)
                 {
                   // Real zero.
 #ifdef DEBUG_EIG
                   std::cout << "  single gen eig:" << std::endl;
                   std::cout << "  alphar(" << jj << ") = " << aa(jj,jj)
                             << std::endl;
-                  std::cout << "  betar( " << jj << ") = " << bb(jj,jj)
+                  std::cout << "  betar(" << jj << ") = " << bb(jj,jj)
                             << std::endl;
                   std::cout << "  alphai(" << jj << ") = 0" << std::endl;
 #endif
 
                   alphar(jj) = aa(jj,jj);
                   alphai(jj) = 0;
                   betar(jj) = bb(jj,jj);
                 }
@@ -1272,19 +1272,19 @@ compatibility with @sc{matlab}.\n\
 %!test
 %! a = [ 10  1  2;
 %!        1  2 -1;
 %!        1  1  2];
 %! b = reshape (1:9,3,3);
 %! [aa, bb, q, z, v, w, lambda] = qz (a, b);
 %! sz = length (lambda);
 %! observed = (b * v * diag ([lambda;0])) (:, 1:sz);
-%! assert ( (a*v) (:, 1:sz), observed, norm (observed) * 1e-14);
+%! assert ((a*v)(:, 1:sz), observed, norm (observed) * 1e-14);
 %! observed = (diag ([lambda;0]) * w' * b) (1:sz, :);
-%! assert ( (w'*a) (1:sz, :) , observed, norm (observed) * 1e-13);
+%! assert ((w'*a)(1:sz, :) , observed, norm (observed) * 1e-13);
 %! assert (q * a * z, aa, norm (aa) * 1e-14);
 %! assert (q * b * z, bb, norm (bb) * 1e-14);
 
 %!test
 %! A = [0, 0, -1, 0; 1, 0, 0, 0; -1, 0, -2, -1; 0, -1, 1, 0];
 %! B = [0, 0, 0, 0; 0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1];
 %! [AA, BB, Q, Z1] = qz (A, B);
 %! [AA, BB, Z2] = qz (A, B, '-');
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -297,17 +297,17 @@ RT do_rightdiv_sm_dm (const SM& a, const
   const octave_idx_type d_nr = d.rows ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   using std::min;
   const octave_idx_type nc = min (d_nr, a_nc);
 
-  if ( ! mx_div_conform (a, d))
+  if (! mx_div_conform (a, d))
     return RT ();
 
   const octave_idx_type nz = a.nnz ();
   RT r (a_nr, nc, nz);
 
   typedef typename DM::element_type DM_elt_type;
   const DM_elt_type zero = DM_elt_type ();
 
@@ -564,17 +564,17 @@ RT do_leftdiv_dm_sm (const DM& d, const 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   const octave_idx_type d_nc = d.cols ();
 
   using std::min;
   const octave_idx_type nr = min (d_nc, a_nr);
 
-  if ( ! mx_leftdiv_conform (d, a))
+  if (! mx_leftdiv_conform (d, a))
     return RT ();
 
   const octave_idx_type nz = a.nnz ();
   RT r (nr, a_nc, nz);
 
   typedef typename DM::element_type DM_elt_type;
   const DM_elt_type zero = DM_elt_type ();
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -386,17 +386,17 @@ urlwrite (\"http://www.google.com/search
 
       if (error_state)
         {
           error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
           return retval;
         }
 
 
-      if (param.numel () % 2 == 1 )
+      if (param.numel () % 2 == 1)
         {
           error ("urlwrite: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
@@ -534,17 +534,17 @@ s = urlread (\"http://www.google.com/sea
       param = args(2).cellstr_value ();
 
       if (error_state)
         {
           error ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of character strings");
           return retval;
         }
 
-      if (param.numel () % 2 == 1 )
+      if (param.numel () % 2 == 1)
         {
           error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -286,17 +286,17 @@ public:
     Fl_Menu_Bar (xx, yy, ww, hh);
   }
 
   int items_to_show (void)
   {
     //returns the number of visible menu items
     int len = menubar->size ();
     int n = 0;
-    for (int t = 0; t < len; t++ )
+    for (int t = 0; t < len; t++)
       {
         const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*> (&
                                 (menubar->menu ()[t]));
         if (m->label () && m->visible ())
           n++;
       }
 
     return n;
@@ -321,27 +321,27 @@ public:
   {
     // This function is derived from Greg Ercolano's function
     // int GetIndexByName(...), see:
     // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
     // He agreed via PM that it can be included in octave using GPLv3
     // Kai Habel (14.10.2010)
 
     std::string menupath;
-    for (int t = 0; t < menubar->size (); t++ )
+    for (int t = 0; t < menubar->size (); t++)
       {
         Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
         if (m->submenu ())
           {
             // item has submenu
             if (!menupath.empty ())
               menupath += "/";
             menupath += m->label ();
 
-            if (menupath.compare (findname) == 0 )
+            if (menupath.compare (findname) == 0)
               return (t);
           }
         else
           {
             // End of submenu? Pop back one level.
             if (! m->label ())
               {
                 std::size_t idx = menupath.find_last_of ("/");
@@ -1051,33 +1051,33 @@ private:
 
     feval ("grid", args);
     mark_modified ();
   }
 
   void pixel2pos (const graphics_handle& ax, int px, int py, double& xx,
                   double& yy) const
   {
-    pixel2pos ( gh_manager::get_object (ax), px, py, xx, yy);
+    pixel2pos (gh_manager::get_object (ax), px, py, xx, yy);
   }
 
   void pixel2pos (graphics_object ax, int px, int py, double& xx,
                   double& yy) const
   {
     if (ax && ax.isa ("axes"))
       {
         axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
         ColumnVector pp = ap.pixel2coord (px, py);
         xx = pp(0);
         yy = pp(1);
       }
   }
 
-  graphics_handle pixel2axes_or_ca (int px, int py )
+  graphics_handle pixel2axes_or_ca (int px, int py)
   {
     Matrix kids = fp.get_children ();
     int len = kids.length ();
 
     for (int k = 0; k < len; k++)
       {
         graphics_handle hnd = gh_manager::lookup (kids(k));
 
@@ -1459,17 +1459,17 @@ private:
             if (fp.get_windowbuttonupfcn ().is_defined ())
               {
                 set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                 fp.execute_windowbuttonupfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
-                if ( Fl::event_clicks () == 1)
+                if (Fl::event_clicks () == 1)
                   {
                     if (ax_obj && ax_obj.isa ("axes"))
                       {
                         axes::properties& ap = dynamic_cast<axes::properties&>
                                                (ax_obj.get_properties ());
                         ap.set_xlimmode ("auto");
                         ap.set_ylimmode ("auto");
                         ap.set_zlimmode ("auto");
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -150,17 +150,17 @@ sparse matrices.\n\
       return retval;
     }
 
   int n = 1;
   while (n < nargin && ! error_state)
     {
       std::string tmp = args(n++).string_value ();
 
-      if (! error_state )
+      if (! error_state)
         {
           if (tmp.compare ("vector") == 0)
             vecout = true;
           else if (tmp.compare ("lower") == 0)
             // FIXME: currently the option "lower" is handled by transposing
             //  the matrix, factorizing it with the lapack function
             //  DPOTRF ('U', ...) and finally transposing the factor.  It would
             //  be more efficient to use DPOTRF ('L', ...) in this case.
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -298,17 +298,17 @@ used per default.\n\
             }
           else if (arg0 == "threads")
             {
               if (nargin == 2)  //threads setter
                 {
                   if (args(1).is_real_scalar ())
                     {
                       int nthreads = args(1).int_value();
-                      if ( nthreads >= 1)
+                      if (nthreads >= 1)
                         {
 #if defined (HAVE_FFTW3_THREADS)
                           octave_fftw_planner::threads (nthreads);
 #else
                           warning ("this copy of Octave was not configured to use the multithreaded fftw libraries.");
 #endif
 #if defined (HAVE_FFTW3F_THREADS)
                           octave_float_fftw_planner::threads (nthreads);
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -261,17 +261,17 @@ octave_base_int_matrix<T>::save_binary (
             this->byte_size ());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
-                                        oct_mach_info::float_format )
+                                        oct_mach_info::float_format)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -69,20 +69,20 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   octave_value convert_to_str_internal (bool, bool, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
-  bool save_binary (std::ostream& os, bool& );
+  bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format );
+                    oct_mach_info::float_format);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
@@ -114,21 +114,21 @@ public:
   //  void decrement (void) { scalar -= 1; }
 
   octave_value convert_to_str_internal (bool, bool, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
-  bool save_binary (std::ostream& os, bool& );
+  bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
-                    oct_mach_info::float_format );
+                    oct_mach_info::float_format);
 
 #if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool );
+  bool save_hdf5 (hid_t loc_id, const char *name, bool);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -146,20 +146,20 @@ public:
   FloatNDArray float_array_value (bool = false) const
   { return FloatNDArray (matrix); }
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
-  { return ComplexMatrix (matrix.matrix_value ( )); }
+  { return ComplexMatrix (matrix.matrix_value ()); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-  { return FloatComplexMatrix (matrix.matrix_value ( )); }
+  { return FloatComplexMatrix (matrix.matrix_value ()); }
 
   ComplexNDArray complex_array_value (bool = false) const
   { return ComplexNDArray (matrix); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
   { return FloatComplexNDArray (matrix); }
 
   charNDArray
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -563,17 +563,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1178,20 +1178,20 @@ octave_class::reconstruct_parents (void)
   bool might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
-      if ( val(0).is_object () )
+      if (val(0).is_object ())
         {
           dbgstr = "blork";
-          if ( key == val(0).class_name () )
+          if (key == val(0).class_name ())
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
             }
         }
     }
 
@@ -1320,17 +1320,17 @@ octave_class::load_ascii (std::istream& 
                     }
                 }
               else
                 {
                   error ("load: failed to load class");
                   success = false;
                 }
             }
-          else if (len == 0 )
+          else if (len == 0)
             {
               map = octave_map (dim_vector (1, 1));
               c_name = classname;
             }
           else
             panic_impossible ();
         }
       else
@@ -1464,17 +1464,17 @@ octave_class::load_binary (std::istream&
             }
         }
       else
         {
           warning ("load: failed to load class");
           success = false;
         }
     }
-  else if (len == 0 )
+  else if (len == 0)
     map = octave_map (dim_vector (1, 1));
   else
     panic_impossible ();
 
   return success;
 }
 
 #if defined (HAVE_HDF5)
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -632,17 +632,17 @@ octave_sparse_complex_matrix::load_hdf5 
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -279,17 +279,17 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
                               bool /* save_as_floats */)
 {
   hid_t group_hid = -1;
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.length (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
@@ -419,17 +419,17 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
   hsize_t rank;
   int slen;
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
-  if (group_hid < 0 ) return false;
+  if (group_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "args", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "args");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -320,17 +320,17 @@ octave_perm_matrix::save_binary (std::os
   os.write (reinterpret_cast<const char *> (matrix.data ()),
                                             matrix.byte_size ());
 
   return true;
 }
 
 bool
 octave_perm_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format )
+                                 oct_mach_info::float_format)
 {
   int32_t sz;
   bool colp;
   if (! (is.read (reinterpret_cast<char *> (&sz), 4)
          && is.read (reinterpret_cast<char *> (&colp), 1)))
     return false;
 
   MArray<octave_idx_type> m (dim_vector (sz, 1));
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -839,17 +839,17 @@ octave_struct::load_ascii (std::istream&
           if (is)
             map = m;
           else
             {
               error ("load: failed to load structure");
               success = false;
             }
         }
-      else if (len == 0 )
+      else if (len == 0)
         map = octave_map (dv);
       else
         panic_impossible ();
     }
   else
     {
       error ("load: failed to extract number of elements in structure");
       success = false;
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -101,18 +101,18 @@ DEFBINOP_FN (el_mul, complex_matrix, spa
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
 
   return octave_value
-         (elem_xpow ( SparseComplexMatrix (v1.complex_matrix_value ()),
-                      v2.sparse_matrix_value ()));
+         (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
+                     v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
   return octave_value
          (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
diff --git a/libinterp/operators/op-pm-sm.cc b/libinterp/operators/op-pm-sm.cc
--- a/libinterp/operators/op-pm-sm.cc
+++ b/libinterp/operators/op-pm-sm.cc
@@ -39,22 +39,22 @@ along with Octave; see the file COPYING.
 //Avoid casting to a full matrix
 DEFUNOP_OP (uplus, perm_matrix, /* no-op */)
 
 // Not calling standard CAST_UNOP_ARG for these next two because a
 // dynamic_cast would fail.
 DEFUNOP (not, perm_matrix)
 {
   // Obviously negation of a permutation matrix destroys sparsity
-  return octave_value ( ! a.bool_array_value ());
+  return octave_value (! a.bool_array_value ());
 }
 
 DEFUNOP (uminus, perm_matrix)
 {
-  return octave_value ( - a.sparse_matrix_value ());
+  return octave_value (- a.sparse_matrix_value ());
 }
 
 // Most other logical operations cast to SparseBoolMatrix
 DEFBINOP (eq_pm, perm_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
   return v1.sparse_bool_matrix_value () == v2.sparse_bool_matrix_value ();
 }
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -44,17 +44,17 @@ DEFUNOP (uplus, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
   return octave_value (v.sparse_matrix_value ());
 }
 
 DEFUNOP (uminus, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
-  return octave_value ( - v.sparse_matrix_value ());
+  return octave_value (- v.sparse_matrix_value ());
 }
 
 DEFUNOP (transpose, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
   return octave_value (v.sparse_bool_matrix_value ().transpose ());
 }
 
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -118,17 +118,17 @@ tree_switch_case::~tree_switch_case (voi
 }
 
 
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
-  if (! error_state && label_value.is_defined () )
+  if (! error_state && label_value.is_defined ())
     {
       if (label_value.is_cell ())
         {
           Cell cell (label_value.cell_value ());
 
           for (octave_idx_type i = 0; i < cell.rows (); i++)
             {
               for (octave_idx_type j = 0; j < cell.columns (); j++)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -7703,34 +7703,34 @@ min (const SparseComplexMatrix& a, const
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmin (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   Complex tmp = xmin (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
@@ -7821,34 +7821,34 @@ max (const SparseComplexMatrix& a, const
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   Complex tmp = xmax (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   Complex tmp = xmax (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -63,30 +63,30 @@ plus_or_minus (MSparse<T>& a, const MSpa
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.ridx (jx) = a.ridx (ja);
                   r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.ridx (jx) = b.ridx (jb);
                   r.data (jx) = op (0., b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
@@ -335,30 +335,30 @@ plus_or_minus (const MSparse<T>& a, cons
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.ridx (jx) = a.ridx (ja);
                   r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.ridx (jx) = b.ridx (jb);
                   r.data (jx) = op (0.,  b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
@@ -457,26 +457,26 @@ product (const MSparse<T>& a, const MSpa
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   ja++; ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
                   if ((a.data (ja) * b.data (jb)) != 0.)
                     {
                       r.data (jx) = a.data (ja) * b.data (jb);
@@ -564,39 +564,39 @@ quotient (const MSparse<T>& a, const MSp
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
-      r = MSparse<T>( a_nr, a_nc, (Zero / Zero));
+      r = MSparse<T> (a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   r.elem (a.ridx (ja),i) = a.data (ja) / Zero;
                   ja++; ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   r.elem (b.ridx (jb),i) = Zero / b.data (jb);
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
                   r.elem (a.ridx (ja),i) = a.data (ja) / b.data (jb);
                   ja++; ja_lt_max= ja < ja_max;
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -2430,17 +2430,17 @@ Sparse<T>::diag (octave_idx_type k) cons
           // Count the number of non-zero elements
           octave_idx_type nel = 0;
           if (k > 0)
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
                 if (elem (i, i+k) != 0.)
                   nel++;
             }
-          else if ( k < 0)
+          else if (k < 0)
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
                 if (elem (i-k, i) != 0.)
                   nel++;
             }
           else
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
@@ -2460,17 +2460,17 @@ Sparse<T>::diag (octave_idx_type k) cons
                   T tmp = elem (i, i+k);
                   if (tmp != 0.)
                     {
                       d.xdata (ii) = tmp;
                       d.xridx (ii++) = i;
                     }
                 }
             }
-          else if ( k < 0)
+          else if (k < 0)
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
                 {
                   T tmp = elem (i-k, i);
                   if (tmp != 0.)
                     {
                       d.xdata (ii) = tmp;
                       d.xridx (ii++) = i;
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -772,30 +772,30 @@ atan2 (const SparseMatrix& x, const Spar
               octave_idx_type  ja = x.cidx (i);
               octave_idx_type  ja_max = x.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
               octave_idx_type  jb = y.cidx (i);
               octave_idx_type  jb_max = y.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
-              while (ja_lt_max || jb_lt_max )
+              while (ja_lt_max || jb_lt_max)
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
                     {
                       r.ridx (jx) = x.ridx (ja);
                       r.data (jx) = atan2 (x.data (ja), 0.);
                       jx++;
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
-                  else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (y.ridx (jb) < x.ridx (ja)) ) )
+                  else if ((! ja_lt_max) ||
+                           (jb_lt_max && (y.ridx (jb) < x.ridx (ja))))
                     {
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
                       double tmp = atan2 (x.data (ja), y.data (jb));
                       if (tmp != 0.)
@@ -7816,34 +7816,34 @@ min (const SparseMatrix& a, const Sparse
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmin (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   double tmp = xmin (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
@@ -7967,34 +7967,34 @@ max (const SparseMatrix& a, const Sparse
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
           octave_idx_type  jb = b.cidx (i);
           octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
-          while (ja_lt_max || jb_lt_max )
+          while (ja_lt_max || jb_lt_max)
             {
               octave_quit ();
               if ((! jb_lt_max) ||
                   (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   double tmp = xmax (a.data (ja), 0.);
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = a.ridx (ja);
                       r.data (jx) = tmp;
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
-              else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+              else if ((! ja_lt_max) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja))))
                 {
                   double tmp = xmax (0., b.data (jb));
                   if (tmp != 0.)
                     {
                       r.ridx (jx) = b.ridx (jb);
                       r.data (jx) = tmp;
                       jx++;
                     }
diff --git a/liboctave/numeric/bsxfun.h b/liboctave/numeric/bsxfun.h
--- a/liboctave/numeric/bsxfun.h
+++ b/liboctave/numeric/bsxfun.h
@@ -36,17 +36,17 @@ bool
 is_valid_bsxfun (const std::string& name, const dim_vector& dx,
                  const dim_vector& dy)
 {
   for (int i = 0; i < std::min (dx.length (), dy.length ()); i++)
     {
       octave_idx_type xk = dx(i);
       octave_idx_type yk = dy(i);
       // Check the three conditions for valid bsxfun dims
-      if (! ( (xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
+      if (! ((xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
     ("Octave:broadcast", "%s: automatic broadcasting operation applied",
      name.c_str ());
 
   return true;
@@ -66,17 +66,17 @@ is_valid_inplace_bsxfun (const std::stri
     return false;
 
   for (int i = 0; i < drl; i++)
     {
       octave_idx_type rk = dr(i);
       octave_idx_type xk = dx(i);
 
       // Only two valid canditions to check; can't stretch rk
-      if (! ( (rk == xk) || (rk > 1 && xk == 1)))
+      if (! ((rk == xk) || (rk > 1 && xk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
     ("Octave:broadcast", "%s: automatic broadcasting operation applied",
      name.c_str ());
 
   return true;
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3628,40 +3628,40 @@ ellipj (double u, double m, double& sn, 
         ("ellipj: expecting 0 <= M <= 1");
       sn = cn = dn = lo_ieee_nan_value ();
       return;
     }
 
   double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
   if (m < sqrt_eps)
     {
-      // For small m, ( Abramowitz and Stegun, Section 16.13 )
+      // For small m, (Abramowitz and Stegun, Section 16.13)
       si_u = sin (u);
       co_u = cos (u);
       t = 0.25*m*(u - si_u*co_u);
       sn = si_u - t * co_u;
       cn = co_u + t * si_u;
       dn = 1 - 0.5*m*si_u*si_u;
     }
   else if ((1 - m) < sqrt_eps)
     {
-      // For m1 = (1-m) small ( Abramowitz and Stegun, Section 16.15 )
+      // For m1 = (1-m) small (Abramowitz and Stegun, Section 16.15)
       m1 = 1 - m;
       si_u = sinh (u);
       co_u = cosh (u);
       ta_u = tanh (u);
       se_u = 1/co_u;
       sn = ta_u + 0.25*m1*(si_u*co_u - u)*se_u*se_u;
       cn = se_u - 0.25*m1*(si_u*co_u - u)*ta_u*se_u;
       dn = se_u + 0.25*m1*(si_u*co_u + u)*ta_u*se_u;
     }
   else
     {
-      //  Arithmetic-Geometric Mean (AGM) algorithm
-      //    ( Abramowitz and Stegun, Section 16.4 )
+      // Arithmetic-Geometric Mean (AGM) algorithm
+      //   (Abramowitz and Stegun, Section 16.4)
       a[0] = 1;
       b    = sqrt (1 - m);
       c[0] = sqrt (m);
       for (n = 1; n < Nmax; ++n)
         {
           a[n] = (a[n - 1] + b)/2;
           c[n] = (a[n - 1] - b)/2;
           b = sqrt (a[n - 1]*b);
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -451,30 +451,30 @@ along with Octave; see the file COPYING.
             octave_idx_type  ja = m1.cidx (i); \
             octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx (i); \
             octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
-            while (ja_lt_max || jb_lt_max ) \
+            while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                     r.ridx (jx) = m1.ridx (ja); \
                     r.data (jx) = m1.data (ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
-                else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
+                else if ((! ja_lt_max) || \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)))) \
                   { \
                     r.ridx (jx) = m2.ridx (jb); \
                     r.data (jx) = 0. OP m2.data (jb); \
                     jx++; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
@@ -559,26 +559,26 @@ along with Octave; see the file COPYING.
             octave_idx_type  ja = m1.cidx (i); \
             octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx (i); \
             octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
-            while (ja_lt_max || jb_lt_max ) \
+            while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
-                else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
+                else if ((! ja_lt_max) || \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)))) \
                   { \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
                      if ((m1.data (ja) OP m2.data (jb)) != 0.) \
                        { \
                           r.data (jx) = m1.data (ja) OP m2.data (jb); \
@@ -675,29 +675,29 @@ along with Octave; see the file COPYING.
             octave_idx_type  ja = m1.cidx (i); \
             octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
             octave_idx_type  jb = m2.cidx (i); \
             octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
-            while (ja_lt_max || jb_lt_max ) \
+            while (ja_lt_max || jb_lt_max) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
                       (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                     /* keep those kludges coming */ \
                     r.elem (m1.ridx (ja),i) = m1.data (ja) OP Complex (); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
-                else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
+                else if ((! ja_lt_max) || \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)))) \
                   { \
                     /* keep those kludges coming */ \
                     r.elem (m2.ridx (jb),i) = Complex () OP m2.data (jb);  \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
@@ -1831,17 +1831,17 @@ along with Octave; see the file COPYING.
   else \
     { \
       SPARSE_ANY_ALL_OP (DIM, (cidx (j+1) - cidx (j) < nr ? false : true), \
                          true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
-#define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
+#define SPARSE_SPARSE_MUL(RET_TYPE, RET_EL_TYPE, EL_TYPE) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
    { \
@@ -2000,17 +2000,17 @@ along with Octave; see the file COPYING.
                     retval.xdata (k) = Xcol[retval.xridx (k)]; \
                 }  \
             } \
           retval.maybe_compress (true);\
           return retval; \
         } \
     }
 
-#define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
+#define SPARSE_FULL_MUL(RET_TYPE, EL_TYPE, ZERO) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
@@ -2035,17 +2035,17 @@ along with Octave; see the file COPYING.
               EL_TYPE tmpval = a.elem (j,i); \
               for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
                 retval.elem (m.ridx (k),i) += tmpval * m.data (k); \
             } \
         } \
       return retval; \
     }
 
-#define SPARSE_FULL_TRANS_MUL( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
+#define SPARSE_FULL_TRANS_MUL(RET_TYPE, EL_TYPE, ZERO, CONJ_OP) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
@@ -2071,17 +2071,17 @@ along with Octave; see the file COPYING.
               for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
                 acc += a.elem (m.ridx (k),i) * CONJ_OP (m.data (k)); \
               retval.xelem (j,i) = acc; \
             } \
         } \
       return retval; \
     }
 
-#define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE, ZERO ) \
+#define FULL_SPARSE_MUL(RET_TYPE, EL_TYPE, ZERO) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
@@ -2107,17 +2107,17 @@ along with Octave; see the file COPYING.
               \
               for (octave_idx_type k = 0 ; k < nr; k++) \
                 retval.xelem (k,i) += tmpval * m.elem (k,col); \
             } \
         } \
       return retval; \
     }
 
-#define FULL_SPARSE_MUL_TRANS( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
+#define FULL_SPARSE_MUL_TRANS(RET_TYPE, EL_TYPE, ZERO, CONJ_OP) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
diff --git a/liboctave/util/caseless-str.h b/liboctave/util/caseless-str.h
--- a/liboctave/util/caseless-str.h
+++ b/liboctave/util/caseless-str.h
@@ -52,26 +52,26 @@ public:
     const_iterator p1 = begin ();
     const_iterator p2 = s.begin ();
 
     while (p1 != end () && p2 != s.end ())
       {
         char lp1 = std::tolower (*p1);
         char lp2 = std::tolower (*p2);
 
-        if ( lp1 > lp2 )
+        if (lp1 > lp2)
           return false;
-        if ( lp1 < lp2)
+        if (lp1 < lp2)
           return true;
 
         p1++;
         p2++;
       }
 
-    if ( length () >= s.length ())
+    if (length () >= s.length ())
       return false;
     else
       return true;
   }
 
   // Case-insensitive comparison.
   bool compare (const std::string& s, size_t limit = std::string::npos) const
   {
