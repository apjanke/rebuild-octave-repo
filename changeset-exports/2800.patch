# HG changeset patch
# User jwe
# Date 857901039 0
#      Sun Mar 09 09:50:39 1997 +0000
# Node ID 9aeba8e006a4fd36b7254433018e668b1d7029d7
# Parent  d77a29e4387fcc3e85243e181a95033202a5b96c
[project @ 1997-03-09 09:50:20 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+Sun Mar  9 03:44:33 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* config.h.bot (STATIC_CAST): Delete definition.
+
 Thu Mar  6 03:26:41 1997  Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 
 	* emacs/octave-hlp.el: Provide octave-hlp.
 	* emacs/octave-inf.el: Provide octave-inf.
 
 	* examples/info-emacs-octave-help: Require octave-hlp instead of
 	loading it.
 
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,8 +1,21 @@
+Summary of changes for version 2.0.6:
+------------------------------------
+
+  * Functions like quad, fsolve, and lsode can take either a function
+    name or a simple function body as a string.  For example,
+
+      quad ("sqrt (x)", 0, 1)
+
+    is equivalent to
+
+      function y = f (x) y = sqrt (x); endfunction
+      quad ("f", 0, 1)
+
 Summary of changes for version 2.0.5:
 ------------------------------------
 
   * A `switch' statement is now available.  See the Statements chapter
     in the manual for details.
 
   * Commands like ls, save, and cd may now also be used as formal
     parameters for functions.
diff --git a/config.h.bot b/config.h.bot
--- a/config.h.bot
+++ b/config.h.bot
@@ -2,17 +2,15 @@
 #if defined (__GNUC__)
 #define GCC_ATTR_NORETURN __attribute__ ((__noreturn__))
 #define GCC_ATTR_UNUSED __attribute__ ((__unused__))
 #else
 #define GCC_ATTR_NORETURN
 #define GCC_ATTR_UNUSED
 #endif
 
-#define STATIC_CAST(T, E) (T) (E)
-
 #define DYNAMIC_CAST(T, E) (T) (E)
 
 #define REINTERPRET_CAST(T, E) (T) (E)
 
 #define HEAVYWEIGHT_INDEXING 1
 
 #define WITH_KPATHSEARCH 1
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -995,17 +995,17 @@ ComplexMatrix::ifourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / (double) npts;
+    tmp_data[j] = tmp_data[j] / npts;
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
   ComplexMatrix retval;
@@ -1095,17 +1095,17 @@ ComplexMatrix::ifourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / (double) npts;
+    tmp_data[j] = tmp_data[j] / npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
@@ -1117,17 +1117,17 @@ ComplexMatrix::ifourier2d (void) const
   for (int j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FCN (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / (double) npts;
+	tmp_data[i*nr + j] = prow[i] / npts;
     }
 
   return retval;
 }
 
 ComplexDET
 ComplexMatrix::determinant (void) const
 {
@@ -1574,19 +1574,18 @@ ComplexMatrix::expm (void) const
 
   // Preconditioning step 3: scaling.
 
   ColumnVector work (nc);
   double inf_norm
     = F77_FCN (zlange, ZLANGE) ("I", nc, nc, m.fortran_vec (), nc,
 				work.fortran_vec ());
 
-  int sqpow = (int) (inf_norm > 0.0
-		     ? (1.0 + log (inf_norm) / log (2.0))
-		     : 0.0);
+  int sqpow = (inf_norm > 0.0
+	       ? static_cast<int> (1.0 + log (inf_norm) / log (2.0)) : 0);
 
   // Check whether we need to square at all.
 
   if (sqpow < 0)
     sqpow = 0;
 
   if (sqpow > 0)
     {
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,15 @@
+Sun Mar  9 03:44:52 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* CMatrix.cc, FEGrid.cc, Range.cc, dMatrix.cc, data-conv.cc,
+	dir-ops.cc, file-ops.h, idx-vector.cc, idx-vector.h, lo-ieee.cc,
+	lo-mappers.cc, oct-alloc.cc: Use `static_cast<T> (val)' instead of
+	old C-style `(T) val' casts.
+
 Thu Mar  6 20:20:01 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dMatrix.cc (operator >>): Return if an error occurs instead of
 	just breaking out of the innermost loop.
 	* CMatrix.cc (operator >>): Likewise.
 
 Sat Mar  1 15:23:14 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -68,17 +68,17 @@ FEGrid::FEGrid (int nel, double left, do
   if (nel < 1)
     {
       nel_error ();
       return;
     }
 
   elem.resize (nel+1);
 
-  double width = (right - left) / (double) nel;
+  double width = (right - left) / nel;
 
   for (int i = 0; i <= nel; i++)
     elem.elem (i) = i * width + left;
 
   check_grid ();
 }
 
 int
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -41,18 +41,18 @@ Software Foundation, 59 Temple Place - S
 
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
   // will also be an integer, even if the limit is not.
 
   return (! (xisnan (rng_base) || xisnan (rng_inc))
-	  && (double) NINT (rng_base) == rng_base
-	  && (double) NINT (rng_inc) == rng_inc);
+	  && NINT (rng_base) == rng_base
+	  && NINT (rng_inc) == rng_inc);
 }
 
 Matrix
 Range::matrix_value (void) const
 {
   Matrix retval;
 
   if (rng_nelem > 0)
@@ -232,17 +232,17 @@ round (double x, double ct)
 
 int
 Range::nelem_internal (void) const
 {
   double ct = 3.0 * DBL_EPSILON;
 
   double tmp = tfloor ((rng_limit - rng_base + rng_inc) / rng_inc, ct);
 
-  int n_intervals = (int) (tmp > 0.0 ? tmp : 0);
+  int n_intervals = (tmp > 0.0 ? static_cast<int> (tmp) : 0);
 
   return (n_intervals >= INT_MAX - 1) ? -1 : n_intervals;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -703,17 +703,17 @@ Matrix::ifourier (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / (double) npts;
+    tmp_data[j] = tmp_data[j] / npts;
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
   ComplexMatrix retval;
@@ -803,17 +803,17 @@ Matrix::ifourier2d (void) const
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / (double) npts;
+    tmp_data[j] = tmp_data[j] / npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
 
   wsave.resize (nn);
   pwsave = wsave.fortran_vec ();
 
@@ -825,17 +825,17 @@ Matrix::ifourier2d (void) const
   for (int j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	prow[i] = tmp_data[i*nr + j];
 
       F77_FCN (cfftb, CFFTB) (npts, prow, pwsave);
 
       for (int i = 0; i < npts; i++)
-	tmp_data[i*nr + j] = prow[i] / (double) npts;
+	tmp_data[i*nr + j] = prow[i] / npts;
     }
 
   return retval;
 }
 
 DET
 Matrix::determinant (void) const
 {
@@ -2634,35 +2634,35 @@ operator >> (istream& is, Matrix& a)
 
   return is;
 }
 
 template <class T>
 static void
 read_int (istream& is, bool swap_bytes, T& val)
 {
-  is.read ((char *) &val, sizeof (T));
+  is.read (static_cast<char *> (&val), sizeof (T));
 
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
 	  break;
 
 	case 2:
-	  swap_2_bytes ((char *) &val);
+	  swap_2_bytes (static_cast<char *> (&val));
 	  break;
 
 	case 4:
-	  swap_4_bytes ((char *) &val);
+	  swap_4_bytes (static_cast<char *> (&val));
 	  break;
 
 	case 8:
-	  swap_8_bytes ((char *) &val);
+	  swap_8_bytes (static_cast<char *> (&val));
 	  break;
 
 	default:
 	  (*current_liboctave_error_handler)
 	    ("read_int: unrecognized data format!");
 	}
     }
 }
@@ -2757,28 +2757,28 @@ do_read (istream& is, oct_data_conv::dat
 	val = tmp;
       }
       break;
 
     case oct_data_conv::dt_float:
       {
 	float f;
 
-	is.read ((char *) &f, sizeof (float));
+	is.read (static_cast<char *> (&f), sizeof (float));
 
 	if (do_float_conversion)
 	  do_float_format_conversion (&f, 1, flt_fmt);
 
 	val = f;
       }
       break;
 
     case oct_data_conv::dt_double:
       {
-	is.read ((char *) &val, sizeof (double));
+	is.read (static_cast<char *> (&val), sizeof (double));
 
 	if (do_float_conversion)
 	  do_double_format_conversion (&val, 1, flt_fmt);
       }
       break;
 
     default:
       retval = false;
@@ -2948,34 +2948,34 @@ write_int (ostream& os, bool swap_bytes,
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
 	  break;
 
 	case 2:
-	  swap_2_bytes ((char *) &val);
+	  swap_2_bytes (static_cast<char *> (&val));
 	  break;
 
 	case 4:
-	  swap_4_bytes ((char *) &val);
+	  swap_4_bytes (static_cast<char *> (&val));
 	  break;
 
 	case 8:
-	  swap_8_bytes ((char *) &val);
+	  swap_8_bytes (static_cast<char *> (&val));
 	  break;
 
 	default:
 	  (*current_liboctave_error_handler)
 	    ("write_int: unrecognized data format!");
 	}
     }
 
-  os.write ((char *) &val, sizeof (T));
+  os.write (static_cast<char *> (&val), sizeof (T));
 }
 
 template void write_int (ostream&, bool, char);
 template void write_int (ostream&, bool, signed char);
 template void write_int (ostream&, bool, unsigned char);
 template void write_int (ostream&, bool, short);
 template void write_int (ostream&, bool, unsigned short);
 template void write_int (ostream&, bool, int);
@@ -2988,68 +2988,68 @@ do_write (ostream& os, double d, oct_dat
 	  oct_mach_info::float_format flt_fmt, bool swap_bytes,
 	  bool do_float_conversion)
 {
   bool retval = true;
 
   switch (dt)
     {
     case oct_data_conv::dt_char:
-      write_int (os, swap_bytes, (char) d);
+      write_int (os, swap_bytes, static_cast<char> (d));
       break;
 
     case oct_data_conv::dt_schar:
-      write_int (os, swap_bytes, (signed char) d);
+      write_int (os, swap_bytes, static_cast<signed char> (d));
       break;
 
     case oct_data_conv::dt_uchar:
-      write_int (os, swap_bytes, (unsigned char) d);
+      write_int (os, swap_bytes, static_cast<unsigned char> (d));
       break;
 
     case oct_data_conv::dt_short:
-      write_int (os, swap_bytes, (short) d);
+      write_int (os, swap_bytes, static_cast<short> (d));
       break;
 
     case oct_data_conv::dt_ushort:
-      write_int (os, swap_bytes, (unsigned short) d);
+      write_int (os, swap_bytes, static_cast<unsigned short> (d));
       break;
 
     case oct_data_conv::dt_int:
-      write_int (os, swap_bytes, (int) d);
+      write_int (os, swap_bytes, static_cast<int> (d));
       break;
 
     case oct_data_conv::dt_uint:
-      write_int (os, swap_bytes, (unsigned int) d);
+      write_int (os, swap_bytes, static_cast<unsigned int> (d));
       break;
 
     case oct_data_conv::dt_long:
-      write_int (os, swap_bytes, (long) d);
+      write_int (os, swap_bytes, static_cast<long> (d));
       break;
 
     case oct_data_conv::dt_ulong:
-      write_int (os, swap_bytes, (unsigned long) d);
+      write_int (os, swap_bytes, static_cast<unsigned long> (d));
       break;
 
     case oct_data_conv::dt_float:
       {
-	float f = (float) d;
+	float f = d;
 
 	if (do_float_conversion)
 	  do_float_format_conversion (&f, 1, flt_fmt);
 
-	os.write ((char *) &f, sizeof (float));
+	os.write (static_cast<char *> (&f), sizeof (float));
       }
       break;
 
     case oct_data_conv::dt_double:
       {
 	if (do_float_conversion)
 	  do_double_format_conversion (&d, 1, flt_fmt);
 
-	os.write ((char *) &d, sizeof (double));
+	os.write (static_cast<char *> (&d), sizeof (double));
       }
       break;
 
     default:
       retval = false;
       (*current_liboctave_error_handler)
 	("write: invalid type specification");
       break;
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -104,31 +104,31 @@ oct_data_conv::string_to_data_type (cons
 #define swap_1_bytes(x, y)
 
 #define LS_DO_READ(TYPE,swap,data,size,len,stream) \
   do \
     { \
       volatile TYPE *ptr = (TYPE *) data; \
       stream.read ((TYPE *) ptr, size * len); \
       if (swap) \
-        swap_ ## size ## _bytes ((char *) ptr, len); \
+        swap_ ## size ## _bytes (static_cast<char *> (ptr), len); \
       TYPE tmp = ptr[0]; \
       for (int i = len - 1; i > 0; i--) \
         data[i] = ptr[i]; \
       data[0] = tmp; \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define LS_DO_WRITE(TYPE,data,size,len,stream) \
   do \
     { \
-      char tmp_type = (char) type; \
+      char tmp_type = static_cast<char> (type); \
       stream.write (&tmp_type, 1); \
       TYPE *ptr = new TYPE [len]; \
       for (int i = 0; i < len; i++) \
         ptr[i] = (TYPE) data[i]; \
       stream.write ((TYPE *) ptr, size * len); \
       delete [] ptr ; \
     } \
   while (0)
@@ -156,17 +156,17 @@ gripe_data_conversion (const char *from,
 
 // XXX FIXME XXX -- assumes sizeof (Complex) == 8
 // XXX FIXME XXX -- assumes sizeof (double) == 8
 // XXX FIXME XXX -- assumes sizeof (float) == 4
 
 static void
 IEEE_big_double_to_IEEE_little_double (double *d, int len)
 {
-  swap_8_bytes ((char *) d, len);
+  swap_8_bytes (static_cast<char *> (d), len);
 }
 
 static void
 VAX_D_double_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
@@ -180,17 +180,17 @@ static void
 Cray_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_big_float_to_IEEE_little_float (float *d, int len)
 {
-  swap_4_bytes ((char *) d, len);
+  swap_4_bytes (static_cast<char *> (d), len);
 }
 
 static void
 VAX_D_float_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
@@ -204,17 +204,17 @@ static void
 Cray_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_little_double_to_IEEE_big_double (double *d, int len)
 {
-  swap_8_bytes ((char *) d, len);
+  swap_8_bytes (static_cast<char *> (d), len);
 }
 
 static void
 VAX_D_double_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
@@ -228,17 +228,17 @@ static void
 Cray_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
 IEEE_little_float_to_IEEE_big_float (float *d, int len)
 {
-  swap_4_bytes ((char *) d, len);
+  swap_4_bytes (static_cast<char *> (d), len);
 }
 
 static void
 VAX_D_float_to_IEEE_big_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
@@ -629,19 +629,19 @@ read_doubles (istream& is, double *data,
       break;
 
     case LS_INT:
       LS_DO_READ (FOUR_BYTE_INT, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
-	volatile float *ptr = (float *) data;
+	volatile float *ptr = static_cast<float *> (data);
 	is.read (data, 4 * len);
-	do_float_format_conversion ((float *) data, len, fmt);
+	do_float_format_conversion (static_cast<float *> (data), len, fmt);
 	float tmp = ptr[0];
 	for (int i = len - 1; i > 0; i--)
 	  data[i] = ptr[i];
 	data[0] = tmp;
       }
       break;
 
     case LS_DOUBLE:
@@ -685,17 +685,17 @@ write_doubles (ostream& os, const double
       break;
 
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE:
       {
-	char tmp_type = (char) type;
+	char tmp_type = static_cast<char> (type);
 	os.write (&tmp_type, 1);
 	os.write (data, 8 * len);
       }
       break;
 
     default:
       (*current_liboctave_error_handler)
 	("unrecognized data format requested");
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -39,17 +39,17 @@ dir_entry::open (const string& n)
 
   if (! n.empty ())
     name = n;
 
   if (! name.empty ())
     {
       close ();
 
-      dir = (void *) opendir (name.c_str ());
+      dir = static_cast<void *> (opendir (name.c_str ()));
 
       if (dir)
 	fail = false;
       else
 	errmsg = strerror (errno);
     }
   else
     errmsg = "dir_entry::open: empty file name";
@@ -63,42 +63,42 @@ dir_entry::read (void)
   string_vector dirlist;
 
   if (ok ())
     {
       int count = 0;
 
       struct dirent *dir_ent;
 
-      while ((dir_ent = readdir ((DIR *) dir)))
+      while ((dir_ent = readdir (static_cast<DIR *> (dir))))
 	count++;
 
-      rewinddir ((DIR *) dir);
+      rewinddir (static_cast<DIR *> (dir));
 
       dirlist.resize (count);
 
       for (int i = 0; i < count; i++)
 	{
-	  dir_ent = readdir ((DIR *) dir);
+	  dir_ent = readdir (static_cast<DIR *> (dir));
 
 	  if (dir_ent)
 	    dirlist[i] = dir_ent->d_name;
 	  else
 	    break;
 	}
     }
 
   return dirlist;
 }
 
 void
 dir_entry::close (void)
 {
   if (dir)
-    closedir ((DIR *) dir);
+    closedir (static_cast<DIR *> (dir));
 
   dir = 0;
 }
 
 void
 dir_entry::copy (const dir_entry& de)
 {
   name = de.name;
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -107,17 +107,19 @@ public:
 #if defined (HAVE_ST_BLOCKS)
   long blocks (void) const { return fs_blocks; }
 #endif
 
   string mode_as_string (void) const;
 
   bool ok (void) const { return initialized && ! fail; }
 
-  operator void* () const { return ok () ? (void *) -1 : (void *) 0; }
+  operator void* () const
+    { return ok ()
+	? static_cast<void *> (-1) : static_cast<void *> (0); }
 
   bool exists (void) const { return ok (); }
 
   string error (void) const { return ok () ? string () : errmsg; }
 
   // Has the file referenced by this object been modified since TIME?
   bool is_newer (time_t time) const { return fs_mtime > time; }
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -405,18 +405,17 @@ static inline int
 intcmp (int *ii, int *jj)
 {
   return (*ii - *jj);
 }
 
 static inline void
 sort_data (int *d, int l)
 {
-  qsort ((void *) d, l, sizeof (int),
-	 (int (*)(const void*, const void*)) intcmp);
+  qsort (d, l, sizeof (int), intcmp);
 }
 
 static inline int
 make_uniq (int *d, int l)
 {
   int k = 0;
   for (int ii = 1; ii < l; ii++)
     {
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -189,17 +189,18 @@ public:
 	    delete rep;
 
 	  rep = a.rep;
 	  rep->count++;
 	}
       return *this;
     }
 
-  idx_vector::operator void * () const { return (void *) rep->ok (); }
+  idx_vector::operator void * () const
+    { return static_cast<void *> (rep->ok ()); }
 
   int idx_vector::capacity (void) const { return rep->capacity (); }
   int idx_vector::length (int cl) const { return rep->length (cl); }
 
   int idx_vector::elem (int n) const { return rep->elem (n); }
   int idx_vector::checkelem (int n) const { return rep->checkelem (n); }
   int idx_vector::operator () (int n) const { return rep->operator () (n); }
 
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -65,17 +65,17 @@ octave_ieee_init (void)
 // Some version of gcc on some old version of Linux used to crash when
 // trying to make Inf and NaN.
 
 #if defined (SCO)
   double tmp = 1.0;
   octave_Inf = 1.0 / (tmp - tmp);
 #elif defined (__alpha__)
   extern unsigned int DINFINITY[2];
-  octave_Inf =  (*((double *) (DINFINITY)));
+  octave_Inf =  (*(static_cast<double *> (DINFINITY)));
 #elif defined (HAVE_INFINITY)
   octave_Inf = infinity ();
 #elif defined (linux)
   octave_Inf = HUGE_VAL;
 #else
   double tmp = 1e+10;
   octave_Inf = tmp;
   for (;;)
@@ -90,17 +90,17 @@ octave_ieee_init (void)
 #endif
 
 #if defined (HAVE_ISNAN)
 
 #if defined (linux)
   octave_NaN = NAN;
 #elif defined (__alpha__)
   extern unsigned int DQNAN[2];
-  octave_NaN = (*((double *) (DQNAN)));
+  octave_NaN = (*(static_cast<double *> (DQNAN)));
 #elif defined (HAVE_QUIET_NAN)
   octave_NaN = quiet_nan (0L);
 #else
   octave_NaN = octave_Inf / octave_Inf;
 #endif
 
 #endif
 }
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -78,19 +78,17 @@ double
 conj (double x)
 {
   return x;
 }
 
 double
 fix (double x)
 {
-  int tmp;
-  tmp = (int) x;
-  return (double) tmp;
+  return static_cast<int> (x);
 }
 
 double
 imag (double x)
 {
 #if defined (HAVE_ISNAN)
   return xisnan (x) ? octave_NaN : 0.0;
 #else
@@ -147,47 +145,47 @@ xerfc (double x)
     ("erfc (x) not available on this system");
 #endif
 }
 
 double
 xisnan (double x)
 {
 #if defined (HAVE_ISNAN)
-  return (double) isnan (x);
+  return isnan (x);
 #else
   return 0;
 #endif
 }
 
 double
 xfinite (double x)
 {
 #if defined (HAVE_FINITE)
-  return (double) finite (x);
+  return finite (x);
 #elif defined (HAVE_ISINF) && defined (HAVE_ISNAN)
-  return (double) (! isinf (x) && ! isnan (x));
+  return (! isinf (x) && ! isnan (x));
 #else
   return 1;
 #endif
 }
 
 double
 xgamma (double x)
 {
   return F77_FCN (dgamma, DGAMMA) (x);
 }
 
 double
 xisinf (double x)
 {
 #if defined (HAVE_ISINF)
-  return (double) isinf (x);
+  return isinf (x);
 #elif defined (HAVE_FINITE) && defined (HAVE_ISNAN)
-  return (double) (! (finite (x) || isnan (x)));
+  return (! (finite (x) || isnan (x)));
 #else
   return 0;
 #endif
 }
 
 double
 xlgamma (double x)
 {
@@ -200,36 +198,32 @@ xlgamma (double x)
 }
 
 // Complex -> double mappers.
 
 double
 xisnan (const Complex& x)
 {
 #if defined (HAVE_ISNAN)
-  double rx = real (x);
-  double ix = imag (x);
-  return (double) (isnan (rx) || isnan (ix));
+  return (isnan (real (x)) || isnan (imag (x)));
 #else
   return 0;
 #endif
 }
 
 double
 xfinite (const Complex& x)
 {
-  double rx = real (x);
-  double ix = imag (x);
-  return (double) (! ((int) xisinf (rx) || (int) xisinf (ix)));
+  return (! (xisinf (real (x)) || xisinf (imag (x))));
 }
 
 double
 xisinf (const Complex& x)
 {
-  return (double) (! (int) xfinite (x));
+  return (! xfinite (x));
 }
 
 // Complex -> complex mappers.
 
 Complex
 acos (const Complex& x)
 {
   static Complex i (0, 1);
@@ -273,49 +267,41 @@ atanh (const Complex& x)
   static Complex i (0, 1);
   Complex retval = log ((1 + x) / (1 - x)) / 2.0;
   return retval;
 }
 
 Complex
 ceil (const Complex& x)
 {
-  int re = (int) ceil (real (x));
-  int im = (int) ceil (imag (x));
-  return Complex (re, im);
+  return Complex (ceil (real (x)), ceil (imag (x)));
 }
 
 Complex
 fix (const Complex& x)
 {
-  int re = (int) real (x);
-  int im = (int) imag (x);
-  return Complex (re, im);
+  return Complex (real (x), imag (x));
 }
 
 Complex
 floor (const Complex& x)
 {
-  int re = (int) floor (real (x));
-  int im = (int) floor (imag (x));
-  return Complex (re, im);
+  return Complex (floor (real (x)), floor (imag (x)));
 }
 
 Complex
 log10 (const Complex& x)
 {
   return M_LOG10E * log (x);
 }
 
 Complex
 round (const Complex& x)
 {
-  double re = D_NINT (real (x));
-  double im = D_NINT (imag (x));
-  return Complex (re, im);
+  return Complex (D_NINT (real (x)), D_NINT (imag (x)));
 }
 
 Complex
 signum (const Complex& x)
 {
   return x / abs (x);
 }
 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -48,20 +48,20 @@ octave_allocator::alloc (size_t size)
   head = head->next;
   return tmp;
 }
 
 void
 octave_allocator::free (void *p, size_t size)
 {
   if (size != item_size)
-    ::delete [] ((char *) p);
+    ::delete [] (static_cast<char *> (p));
   else
     {
-      link *tmp = (link *) p;
+      link *tmp = static_cast<link *> (p);
       tmp->next = head;
       head = tmp;
     }
 }
 
 // Return TRUE for successful allocation, FALSE otherwise.
 
 bool
@@ -74,23 +74,23 @@ octave_allocator::grow (void)
   if (start)
     {
       char *last = &start[(grow_size - 1) * item_size];
 
       char *p = start;
       while (p < last)
 	{
 	  char *next = p + item_size;
-	  ((link *) p) -> next = (link *) next;
+	  (static_cast<link *> (p)) -> next = static_cast<link *> (next);
 	  p = next;
 	}
 
-      ((link *) last) -> next = 0;
+      (static_cast<link *> (last)) -> next = 0;
 
-      head = (link *) start;
+      head = static_cast<link *> (start);
     }
   else
     {
       typedef void (*error_handler_function) (void);
 
       error_handler_function f = set_new_handler (0);
       set_new_handler (f);
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,22 @@
+Sun Mar  9 03:46:45 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	 * Map.cc, data.cc, dirfns.cc, dynamic-ld.cc, file-io.cc,
+	 fsolve.cc, getgrent.cc, getpwent.cc, getrusage.cc, help.cc,
+	 input.cc, load-save.cc, mappers.cc, minmax.cc, npsol.cc,
+	 oct-fstrm.cc, oct-procbuf.h, oct-stdstrm.cc, oct-stdstrm.h,
+	 oct-stream.cc, oct-stream.h, oct-strstrm.cc, octave.cc,
+	 ov-base.h, ov-range.cc, ov-typeinfo.cc, ov.cc, pr-output.cc,
+	 pt-cmd.cc, pt-exp.cc, pt-fcn.cc, pt-fvc.cc, pt-mat.cc,
+	 pt-misc.cc, pt-plot.cc, qpsol.cc, quad.cc, sort.cc, strfns.cc,
+	 symtab.cc, syscalls.cc, sysdep.cc, time.cc, toplev.cc,
+	 unwind-prot.cc, unwind-prot.h, variables.cc, xpow.cc:
+	 Use `static_cast<T> (val)' instead of old C-style `(T) val' casts.
+
 Sat Mar  8 02:35:13 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* load-save.cc (save_ascii_data, save_three_d): Where appropriate,
 	use bool instead of int.
 	(save_binary_data, save_mat_binary_data, save_ascii_data):
 	Print warning instead of error for wrong type arg.
 
 	* gripes.cc (gripe_wrong_type_arg): New arg, is_error.
diff --git a/src/Map.cc b/src/Map.cc
--- a/src/Map.cc
+++ b/src/Map.cc
@@ -111,49 +111,49 @@ Map<C>::error (const string& msg) const
 // The nodes are linked together serially via a version of a trick
 // used in some vtables: odd pointers are actually links to the next
 // table entry.  Not terrible, but not wonderful either.
 
 template <class C>
 static int
 goodCHptr (CHNode<C> *t)
 {
-  return ((((unsigned) t) & 1) == 0);
+  return (((static_cast<unsigned> (t)) & 1) == 0);
 }
 
 // This sucks, but avoids g++ 2.6.0 `type unification failed' errors.
 
 static void *
 index_to_CHptr (int i)
 {
-  return (void *) ((i << 1) + 1);
+  return static_cast<void *> ((i << 1) + 1);
 }
 
 template <class C>
 static unsigned int
 CHptr_to_index (CHNode<C> *t)
 {
-  return ((unsigned) t) >> 1;
+  return (static_cast<unsigned> (t)) >> 1;
 }
 
 template <class C>
 CHMap<C>::CHMap (const C& dflt, unsigned int sz) : Map<C> (dflt)
 {
   tab = new CHNode<C>* [size = sz];
   for (unsigned int i = 0; i < size; ++i)
-    tab[i] = (CHNode<C> *) index_to_CHptr (i+1);
+    tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
   count = 0;
 }
 
 template <class C>
 CHMap<C>::CHMap (const CHMap& a) : Map<C> (a.def)
 {
   tab = new CHNode<C>* [size = a.size];
   for (unsigned int i = 0; i < size; ++i)
-    tab[i] = (CHNode<C> *) index_to_CHptr (i+1);
+    tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
   count = 0;
   for (Pix p = a.first (); p; a.next (p))
     (*this) [a.key (p)] = a.contents (p);
 }
 
 template <class C>
 Pix
 CHMap<C>::seek (const string& key) const
@@ -211,17 +211,17 @@ CHMap<C>::del (const string& key)
 
 template <class C>
 void
 CHMap<C>::clear (void)
 {
   for (unsigned int i = 0; i < size; ++i)
     {
       CHNode<C> *p = tab[i];
-      tab[i] = (CHNode<C> *) index_to_CHptr (i+1);
+      tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
       while (goodCHptr (p))
 	{
 	  CHNode<C> *nxt = p->tl;
 	  delete p;
 	  p = nxt;
 	}
     }
   count = 0;
@@ -236,17 +236,17 @@ CHMap<C>::first (void) const
       return Pix (tab[i]);
   return 0;
 }
 
 template <class C>
 void
 CHMap<C>::next (Pix& p) const
 {
-  CHNode<C> *t = ((CHNode<C> *) p)->tl;
+  CHNode<C> *t = (static_cast<CHNode<C> *> (p))->tl;
   if (goodCHptr (t))
     p = Pix (t);
   else
     {
       for (unsigned int i = CHptr_to_index (t); i < size; ++i)
 	{
 	  if (goodCHptr (tab[i]))
 	    {
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -628,32 +628,32 @@ m = size (x, 2): return number of column
 	{
 	  Matrix m (1, 2);
 	  m (0, 0) = nr;
 	  m (0, 1) = nc;
 	  retval = m;
 	}
       else if (nargout == 2)
 	{
-	  retval(1) = (double) nc;
-	  retval(0) = (double) nr;
+	  retval(1) = static_cast<double> (nc);
+	  retval(0) = static_cast<double> (nr);
 	}
     }
   else if (nargin == 2 && nargout < 2)
     {
       int nd = NINT (args(1).double_value ());
 
       if (error_state)
 	error ("size: expecting scalar as second argument");
       else
 	{
 	  if (nd == 1)
-	    retval(0) = (double) (args(0).rows ());
+	    retval(0) = static_cast<double> (args(0).rows ());
 	  else if (nd == 2)
-	    retval(0) = (double) (args(0).columns ());
+	    retval(0) = static_cast<double> (args(0).columns ());
 	  else
 	    error ("size: invalid second argument -- expecting 1 or 2");
 	}
     }
   else
     print_usage ("size");
 
   return retval;
@@ -793,17 +793,17 @@ S must be a structure and NAME must be a
   if (nargin == 2)
     {
       retval = 0.0;
 
       if (args(0).is_map () && args(1).is_string ())
 	{
 	  string s = args(1).string_value ();
 	  octave_value tmp = args(0).struct_elt_val (s, true);
-	  retval = (double) tmp.is_defined ();
+	  retval = static_cast<double> (tmp.is_defined ());
 	}
       else
 	print_usage ("struct_contains");
     }
   else
     print_usage ("struct_contains");
 
   return retval;
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -360,17 +360,17 @@ users home directory")
 
 DEFALIAS (chdir, cd);
 
 // Get a directory listing.
 
 static void
 cleanup_iprocstream (void *p)
 {
-  delete (iprocstream *) p;
+  delete static_cast <iprocstream *> (p);
 }
 
 DEFUN_TEXT (ls, args, ,
   "ls [options]\n\
 \n\
 print a directory listing")
 {
   octave_value_list retval;
@@ -507,17 +507,17 @@ STATUS is nonzero and MSG contains a sys
 	gripe_wrong_type_arg ("mkdir", args(0));
       else
 	{
 	  string msg;
 
 	  int status = oct_mkdir (oct_tilde_expand (dirname),
 				  0777, msg);
 
-	  retval(0) = (double) status;
+	  retval(0) = static_cast<double> (status);
 
 	  if (status < 0)
 	    retval(1) = msg;
 	}
     }
   else
     print_usage ("mkdir");
 
@@ -544,17 +544,17 @@ STATUS is nonzero and MSG contains a sys
       if (error_state)
 	gripe_wrong_type_arg ("rmdir", args(0));
       else
 	{
 	  string msg;
 
 	  int status = oct_rmdir (oct_tilde_expand (dirname), msg);
 
-	  retval(0) = (double) status;
+	  retval(0) = static_cast<double> (status);
 
 	  if (status < 0)
 	    retval(1) = msg;
 	}
     }
   else
     print_usage ("rmdir");
 
@@ -587,17 +587,17 @@ STATUS is nonzero and MSG contains a sys
 	  if (error_state)
 	    gripe_wrong_type_arg ("rename", args(1));
 	  else
 	    {
 	      string msg;
 
 	      int status = oct_rename (from, to, msg);
 
-	      retval(0) = (double) status;
+	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	}
     }
   else
     print_usage ("rename");
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -113,21 +113,21 @@ static void *
 shl_resolve_octave_reference (const string& name, const string& file)
 {
   void *retval = 0;
 
   // Dynamic linking with shl_load/shl_findsym doesn't require
   // specification of the libraries at runtime.  Instead, they are
   // specified when the .oct file is created.
 
-  void *handle = shl_load (file.c_str (), BIND_DEFERRED, 0L);
+  shl_t handle = shl_load (file.c_str (), BIND_DEFERRED, 0L);
 
   if (handle)
     {
-      int status = shl_findsym ((shl_t *) &handle, name.c_str (),
+      int status = shl_findsym (&handle, name.c_str (),
 				TYPE_UNDEFINED, retval);
 
       if (status < 0)
 	{
 	  const char *errmsg = strerror (errno);
 
 	  if (errmsg)
 	    error("%s: `%s'", name.c_str (), errmsg);
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -142,17 +142,17 @@ DEFUN (fclose, args, ,
   "fclose (FILENUM): close a file")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      retval = (double) octave_stream_list::remove (args(0));
+      retval = static_cast<double> (octave_stream_list::remove (args(0)));
 
       if (retval < 0)
 	gripe_invalid_file_id ("fclose");
     }
   else
     print_usage ("fclose");
 
   return retval;
@@ -177,17 +177,17 @@ DEFUN (fflush, args, ,
 
 	  retval = 0.0;
 	}
       else
 	{
 	  octave_stream *os = octave_stream_list::lookup (fid);
 
 	  if (os)
-	    retval = (double) os->flush ();
+	    retval = static_cast<double> (os->flush ());
 	  else
 	    gripe_invalid_file_id ("fflush");
 	}
     }
   else
     print_usage ("fflush");
 
   return retval;
@@ -207,25 +207,25 @@ read a string from a file")
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream *os = octave_stream_list::lookup (args(0));
 
       if (os)
 	{
 	  octave_value len_arg = (nargin == 2)
-	    ? args(1) : octave_value ((double) INT_MAX);
+	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
 
 	  bool err = false;
 
 	  string tmp = os->getl (len_arg, err);
 
 	  if (! err)
 	    {
-	      retval(1) = (double) tmp.length ();
+	      retval(1) = static_cast<double> (tmp.length ());
 	      retval(0) = tmp;
 	    }
 	}
       else
 	gripe_invalid_file_id ("fgetl");
     }
   else
     print_usage ("fgetl");
@@ -247,25 +247,25 @@ read a string from a file")
 
   if (nargin == 1 || nargin == 2)
     {
       octave_stream *os = octave_stream_list::lookup (args(0));
 
       if (os)
 	{
 	  octave_value len_arg = (nargin == 2)
-	    ? args(1) : octave_value ((double) INT_MAX);
+	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
 
 	  bool err = false;
 
 	  string tmp = os->gets (len_arg, err);
 
 	  if (! err)
 	    {
-	      retval(1) = (double) tmp.length ();
+	      retval(1) = static_cast<double> (tmp.length ());
 	      retval(0) = tmp;
 	    }
 	}
       else
 	gripe_invalid_file_id ("fgets");
     }
   else
     print_usage ("fgets");
@@ -400,17 +400,18 @@ DEFUN (fopen, args, ,
       octave_base_stream *os
 	= do_stream_open (args(0), mode, arch, "fopen", fid);
 
       if (os)
 	{
 	  if (os->ok () && ! error_state)
 	    {
 	      retval(1) = "";
-	      retval(0) = (double) octave_stream_list::insert (os);
+	      retval(0)
+		= static_cast<double> (octave_stream_list::insert (os));
 	    }
 	  else
 	    {
 	      int errno = 0;
 	      retval(1) = os->error (false, errno);
 	      retval(0) = -1.0;
 	    }
 	}
@@ -445,17 +446,17 @@ DEFUN (frewind, args, ,
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream *os = octave_stream_list::lookup (args(0));
 
       if (os)
-	retval = (double) os->rewind ();
+	retval = static_cast<double> (os->rewind ());
       else
 	gripe_invalid_file_id ("frewind");
     }
   else
     print_usage ("frewind");
 
   return retval;
 }
@@ -479,17 +480,17 @@ ORIGIN may be one of:\n\
     {
       octave_stream *os = octave_stream_list::lookup (args(0));
 
       if (os)
 	{
 	  octave_value origin_arg = (nargin == 3)
 	    ? args(2) : octave_value (-1.0);
 
-	  retval = (double) os->seek (args(1), origin_arg);
+	  retval = static_cast<double> (os->seek (args(1), origin_arg));
 	}
       else
 	::error ("fseek: invalid file id");
     }
   else
     print_usage ("fseek");
 
   return retval;
@@ -502,17 +503,17 @@ DEFUN (ftell, args, ,
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_stream *os = octave_stream_list::lookup (args(0));
 
       if (os)
-	retval = (double) os->tell ();
+	retval = static_cast<double> (os->tell ());
       else
 	gripe_invalid_file_id ("ftell");
     }
   else
     print_usage ("ftell");
 
   return retval;
 }
@@ -695,17 +696,17 @@ more `C-like', and also compatible with 
 
 		  Matrix size = (nargin == 3)
 		    ? args(2).matrix_value () : Matrix (1, 1, octave_Inf);
 
 		  if (! error_state)
 		    {
 		      octave_value tmp = os->scanf (fmt, size, count);
 
-		      retval(1) = (double) count;
+		      retval(1) = static_cast<double> (count);
 		      retval(0) = tmp;
 		    }
 		}
 	      else
 		::error ("fscanf: format must be a string");
 	    }
 	  else
 	    gripe_invalid_file_id ("fscanf");
@@ -804,19 +805,19 @@ more `C-like', and also compatible with 
 
 		      octave_value tmp = os.scanf (fmt, size, count);
 
 		      // XXX FIXME XXX -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
 		      string errmsg = os.error ();
 
-		      retval(3) = (double) (os.tell () + 1);
+		      retval(3) = static_cast<double> (os.tell () + 1);
 		      retval(2) = errmsg;
-		      retval(1) = (double) count;
+		      retval(1) = static_cast<double> (count);
 		      retval(0) = tmp;
 		    }
 		  else
 		    ::error ("sscanf: format must be a string");
 		}
 	      else
 		::error ("sscanf: unable to create temporary input buffer");
 	    }
@@ -975,17 +976,17 @@ Reads data in binary form of type PRECIS
 
 	  octave_value arch = (nargin > 4)
 	    ? args(4) : octave_value ("unknown");
 
 	  int count = -1;
 
 	  octave_value tmp = do_fread (*os, size, prec, skip, arch, count);
 
-	  retval(1) = (double) count;
+	  retval(1) = static_cast<double> (count);
 	  retval(0) = tmp;
 	}
       else
 	gripe_invalid_file_id ("fread");
     }
   else
     print_usage ("fread");
 
@@ -1170,17 +1171,17 @@ DEFUN (ferror, args, ,
 	      else
 		return retval;
 	    }
 
 	  int error_number = 0;
 
 	  string error_message = os->error (clear, error_number);
 
-	  retval(1) = (double) error_number;
+	  retval(1) = static_cast<double> (error_number);
 	  retval(0) = error_message;
 	}
       else
 	gripe_invalid_file_id ("ferror");
     }
   else
     print_usage ("ferror");
 
@@ -1242,17 +1243,17 @@ DEFUN (pclose, args, ,
   Close a pipe and terminate the associated process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      retval = (double) octave_stream_list::remove (args(0));
+      retval = static_cast<double> (octave_stream_list::remove (args(0)));
 
       if (retval < 0)
 	gripe_invalid_file_id ("pclose");
     }
   else
     print_usage ("pclose");
 
   return retval;
@@ -1324,17 +1325,17 @@ printed.")
 	{
 	  status = -1;
 	  ::error ("umask: expecting integer argument");
 	}
       else
 	{
 	  int mask = NINT (dmask);
 
-	  if ((double) mask != dmask || mask < 0)
+	  if (mask != dmask || mask < 0)
 	    {
 	      status = -1;
 	      ::error ("umask: MASK must be a positive integer value");
 	    }
 	  else
 	    {
 	      int oct_mask = convert (mask, 8, 10);
 
@@ -1342,17 +1343,17 @@ printed.")
 		status = convert (oct_umask (oct_mask), 10, 8);
 	    }
 	}
     }
   else
     print_usage ("umask");
 
   if (status >= 0)
-    retval(0) = (double) status;
+    retval(0) = static_cast<double> (status);
 
   return retval;
 }
 
 void
 symbols_of_file_io (void)
 {
   // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -171,17 +171,17 @@ where y and x are vectors.")
   ColumnVector soln = foo.solve (info);
 
   info = hybrd_info_to_fsolve_info (info);
 
   retval.resize (nargout ? nargout : 1);
   retval(0) = soln, 1;
 
   if (nargout > 1)
-    retval(1) = (double) info;
+    retval(1) = static_cast<double> (info);
 
   return retval;
 }
 
 typedef void (NLEqn_options::*d_set_opt_mf) (double);
 typedef double (NLEqn_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 1
diff --git a/src/getgrent.cc b/src/getgrent.cc
--- a/src/getgrent.cc
+++ b/src/getgrent.cc
@@ -55,17 +55,17 @@ mk_gr_map (struct group *gr)
       Octave_map m;
 
       m ["name"] = gr->gr_name;
 #if defined (HAVE_GR_PASSWD)
       m ["passwd"] = gr->gr_passwd;
 #else
       m ["passwd"] = "";
 #endif
-      m ["gid"] = STATIC_CAST (double, gr->gr_gid);
+      m ["gid"] = static_cast<double> (gr->gr_gid);
 
       if (gr->gr_mem)
 	{
 	  // XXX FIXME XXX -- maybe there should be a string_vector
 	  // constructor that takes a NULL terminated list of C
 	  // strings.
 
 	  char **tmp = gr->gr_mem;
@@ -133,17 +133,17 @@ Search for a group entry with a matching
     {
 #ifdef HAVE_GETGRGID
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
-	      gid_t gid = STATIC_CAST (gid_t, dval);
+	      gid_t gid = static_cast<gid_t> (dval);
 
 	      retval = mk_gr_map (getgrgid (gid));
 	    }
 	  else
 	    error ("getgrgid: argument must be an integer");
 	}
 #else
       gripe_not_supported ("getgrgid");
diff --git a/src/getpwent.cc b/src/getpwent.cc
--- a/src/getpwent.cc
+++ b/src/getpwent.cc
@@ -51,18 +51,18 @@ mk_pw_map (struct passwd *pw)
   octave_value retval;
 
   if (pw)
     {
       Octave_map m;
 
       m ["name"] = pw->pw_name;
       m ["passwd"] = pw->pw_passwd;
-      m ["uid"] = STATIC_CAST (double, pw->pw_uid);
-      m ["gid"] = STATIC_CAST (double, pw->pw_gid);
+      m ["uid"] = static_cast<double> (pw->pw_uid);
+      m ["gid"] = static_cast<double> (pw->pw_gid);
       m ["gecos"] = pw->pw_gecos;
       m ["dir"] = pw->pw_dir;
       m ["shell"] = pw->pw_shell;
 
       retval = m;
     }
   else
     retval = 0.0;
@@ -106,17 +106,17 @@ Search for a password entry with a match
     {
 #ifdef HAVE_GETPWUID
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
-	      uid_t uid = STATIC_CAST (uid_t, dval);
+	      uid_t uid = static_cast<uid_t> (dval);
 
 	      retval = mk_pw_map (getpwuid (uid));
 	    }
 	  else
 	    error ("getpwuid: argument must be an integer");
 	}
 #else
       gripe_not_supported ("getpwuid");
diff --git a/src/getrusage.cc b/src/getrusage.cc
--- a/src/getrusage.cc
+++ b/src/getrusage.cc
@@ -72,39 +72,39 @@ Return system resource statistics.")
   Octave_map tv_tmp;
 
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
-  tv_tmp ["sec"] = (double) ru.ru_utime.tv_sec;
-  tv_tmp ["usec"] = (double) ru.ru_utime.tv_usec;
+  tv_tmp ["sec"] = static_cast<double> (ru.ru_utime.tv_sec);
+  tv_tmp ["usec"] = static_cast<double> (ru.ru_utime.tv_usec);
   m ["utime"] = octave_value (tv_tmp);
 
-  tv_tmp ["sec"] = (double) ru.ru_stime.tv_sec;
-  tv_tmp ["usec"] = (double) ru.ru_stime.tv_usec;
+  tv_tmp ["sec"] = static_cast<double> (ru.ru_stime.tv_sec);
+  tv_tmp ["usec"] = static_cast<double> (ru.ru_stime.tv_usec);
   m ["stime"] = octave_value (tv_tmp);
 
 #if ! defined (RUSAGE_TIMES_ONLY)
-  m ["maxrss"] = (double) ru.ru_maxrss;
-  m ["ixrss"] = (double) ru.ru_ixrss;
-  m ["idrss"] = (double) ru.ru_idrss;
-  m ["isrss"] = (double) ru.ru_isrss;
-  m ["minflt"] = (double) ru.ru_minflt;
-  m ["majflt"] = (double) ru.ru_majflt;
-  m ["nswap"] = (double) ru.ru_nswap;
-  m ["inblock"] = (double) ru.ru_inblock;
-  m ["oublock"] = (double) ru.ru_oublock;
-  m ["msgsnd"] = (double) ru.ru_msgsnd;
-  m ["msgrcv"] = (double) ru.ru_msgrcv;
-  m ["nsignals"] = (double) ru.ru_nsignals;
-  m ["nvcsw"] = (double) ru.ru_nvcsw;
-  m ["nivcsw"] = (double) ru.ru_nivcsw;
+  m ["maxrss"] = static_cast<double> (ru.ru_maxrss);
+  m ["ixrss"] = static_cast<double> (ru.ru_ixrss);
+  m ["idrss"] = static_cast<double> (ru.ru_idrss);
+  m ["isrss"] = static_cast<double> (ru.ru_isrss);
+  m ["minflt"] = static_cast<double> (ru.ru_minflt);
+  m ["majflt"] = static_cast<double> (ru.ru_majflt);
+  m ["nswap"] = static_cast<double> (ru.ru_nswap);
+  m ["inblock"] = static_cast<double> (ru.ru_inblock);
+  m ["oublock"] = static_cast<double> (ru.ru_oublock);
+  m ["msgsnd"] = static_cast<double> (ru.ru_msgsnd);
+  m ["msgrcv"] = static_cast<double> (ru.ru_msgrcv);
+  m ["nsignals"] = static_cast<double> (ru.ru_nsignals);
+  m ["nvcsw"] = static_cast<double> (ru.ru_nvcsw);
+  m ["nivcsw"] = static_cast<double> (ru.ru_nivcsw);
 #endif
 
 #else
 #if defined (HAVE_TIMES) && defined (HAVE_SYS_TIMES_H)
 
   struct tms t;
 
   times (&t);
@@ -112,26 +112,26 @@ Return system resource statistics.")
   unsigned long ticks;
   unsigned long seconds;
   unsigned long fraction;
 
   ticks = t.tms_utime + t.tms_cutime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
-  tv_tmp ["sec"] = (double) seconds;
-  tv_tmp ["usec"] = (double) (fraction * 1e6 / HZ);
+  tv_tmp ["sec"] = static_cast<double> (seconds);
+  tv_tmp ["usec"] = static_cast<double> (fraction * 1e6 / HZ);
   m ["utime"] = octave_value (tv_tmp);
 
   ticks = t.tms_stime + t.tms_cstime;
   fraction = ticks % HZ;
   seconds = ticks / HZ;
 
-  tv_tmp ["sec"] = (double) seconds;
-  tv_tmp ["usec"] = (double) (fraction * 1e6 / HZ);
+  tv_tmp ["sec"] = static_cast<double> (seconds);
+  tv_tmp ["usec"] = static_cast<double> (fraction * 1e6 / HZ);
   m ["stime"] = octave_value (tv_tmp);
 
 #else
 
   tv_tmp ["sec"] = 0.0;
   tv_tmp ["usec"] = 0.0;
   m ["utime"] = octave_value (tv_tmp);
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -828,17 +828,17 @@ display the definition of each NAME that
 		output_buf << argv[i] << " is a builtin function\n";
 	      else if (sym_rec->is_user_variable ()
 		       || sym_rec->is_builtin_variable ())
 		{
 		  tree_fvc *defn = sym_rec->def ();
 
 		  assert (defn && defn->is_constant ());
 
-		  tree_constant *tmp = (tree_constant *) defn;
+		  tree_constant *tmp = static_cast<tree_constant *> (defn);
 
 		  int var_ok = 1;
 		  if (tmp && tmp->is_map ())
 		    {
 		      if (! elts.empty ())
 			{
 			  octave_value ult =
 			    tmp->lookup_map_element (elts, 0, 1);
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -417,17 +417,17 @@ gnu_readline (const char *s, bool force_
   char *retval = 0;
 
   if (using_readline || force_readline)
     {
       char *tmp = retval = ::readline (s);
 
       if (tmp && strlen (tmp) == 0)
 	{
-	  retval = (char *) malloc (2);
+	  retval = static_cast<char *> (malloc (2));
 	  retval[0] = '\n';
 	  retval[1] = '\0';
 	}
     }
   else
     {
       if (s && *s && (interactive || forced_interactive))
 	{
@@ -437,31 +437,31 @@ gnu_readline (const char *s, bool force_
 
       FILE *curr_stream = rl_instream;
       if (reading_fcn_file || reading_script_file)
 	curr_stream = ff_instream;
 
       int grow_size = 1024;
       int max_size = grow_size;
 
-      char *buf = (char *) malloc (max_size);
+      char *buf = static_cast<char *> (malloc (max_size));
       char *bufptr = buf;
 
       do
 	{
 	  if (fgets (bufptr, grow_size, curr_stream))
 	    {
 	      int len = strlen (bufptr);
 
 	      if (len == grow_size - 1)
 		{
 		  int tmp = bufptr - buf + grow_size - 1;
 		  grow_size *= 2;
 		  max_size += grow_size;
-		  buf = (char *) realloc (buf, max_size);
+		  buf = static_cast<char *> (realloc (buf, max_size));
 		  bufptr = buf + tmp;
 
 		  if (*(bufptr-1) == '\n')
 		    {
 		      *bufptr = '\0';
 		      retval = buf;
 		    }
 		}
@@ -533,17 +533,17 @@ static char *
 get_user_input (void)
 {
   char *retval = 0;
 
   if (get_input_from_eval_string)
     {
       size_t len = current_eval_string.length ();
 
-      retval = (char *) malloc (len + 2);
+      retval = static_cast<char *> (malloc (len + 2));
 
       strcpy (retval, current_eval_string.c_str ());
 
       retval[len++] = '\n';
       retval[len] = '\0';    // Paranoia.
     }
   else
     retval = octave_gets ();
@@ -678,17 +678,17 @@ generate_struct_completions (const char 
     sr = global_sym_tab->lookup (id, 0, 0);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
       tree_constant *def = 0;
       if (tmp_fvc->is_constant ())
-	def = (tree_constant *) tmp_fvc;
+	def = static_cast<tree_constant *> (tmp_fvc);
 
       if (def && def->is_map ())
 	{
 	  if (elts && *elts)
 	    {
 	      octave_value ult = def->lookup_map_element (elts, 0, 1);
 
 	      if (ult.is_map ())
@@ -772,17 +772,17 @@ looks_like_struct (const char *nm)
     sr = global_sym_tab->lookup (id, 0, 0);
 
   if (sr && sr->is_defined ())
     {
       tree_fvc *tmp_fvc = sr->def ();
 
       tree_constant *def = 0;
       if (tmp_fvc->is_constant ())
-	def = (tree_constant *) tmp_fvc;
+	def = static_cast<tree_constant *> (tmp_fvc);
 
       if (def && def->is_map ())
 	{
 	  if (elts && *elts)
 	    {
 	      octave_value ult = def->lookup_map_element (elts, 0, 1);
 
 	      if (ult.is_map ())
@@ -853,17 +853,17 @@ command_generator (const char *text, int
 	{
 	  name = name_list[list_index].c_str ();
 
 	  list_index++;
 
 	  if (strncmp (name, hint, hint_len) == 0)
 	    {
 	      int len = 2 + prefix_len + strlen (name);
-	      char *buf = (char *) malloc (len);
+	      char *buf = static_cast<char *> (malloc (len));
 
 	      if (prefix)
 		{
 		  strcpy (buf, prefix);
 		  strcat (buf, ".");
 		  strcat (buf, name);
 		}
 	      else
@@ -947,48 +947,48 @@ operate_and_get_next (int /* count */, i
 
   if ((history_is_stifled () && (history_length >= max_input_history))
       || (where >= history_length - 1))
     saved_history_line_to_use = where;
   else
     saved_history_line_to_use = where + 1;
 
   old_rl_startup_hook = rl_startup_hook;
-  rl_startup_hook = (Function *) set_saved_history;
+  rl_startup_hook = static_cast<Function *> (set_saved_history);
 }
 
 void
 initialize_readline (void)
 {
   // Set things up internally in case some function that uses readline
   // (currently Fclc(), maybe others) is called before readline().
 
   rl_initialize ();
 
   // Allow conditional parsing of the ~/.inputrc file
 
   rl_readline_name = "Octave";
 
   // Tell the completer that we want to try first.
 
-  rl_attempted_completion_function = (CPPFunction *) command_completer;
+  rl_attempted_completion_function
+    = static_cast<CPPFunction *> (command_completer);
 
   // Bind operate-and-get-next.
 
-  rl_add_defun ("operate-and-get-next",
-		(Function *) operate_and_get_next, CTRL ('O'));
+  rl_add_defun ("operate-and-get-next", operate_and_get_next, CTRL ('O'));
 
 
   // And the history search functions.
 
-  rl_add_defun ("history-search-backward",
-		(Function *) rl_history_search_backward, META ('p'));
+  rl_add_defun ("history-search-backward", rl_history_search_backward,
+		META ('p'));
 
-  rl_add_defun ("history-search-forward",
-		(Function *) rl_history_search_forward, META ('n'));
+  rl_add_defun ("history-search-forward", rl_history_search_forward,
+		META ('n'));
 
   // Don't treat single quotes as string delimiters when doing paren
   // matching.
 
   rl_paren_string_delimiters = "\"";
 }
 
 static int
@@ -1156,48 +1156,51 @@ Without any arguments, toggle the curren
 
   switch (argc)
     {
     case 1:
       {
 	if ((Vecho_executing_commands & ECHO_SCRIPTS)
 	    || (Vecho_executing_commands & ECHO_FUNCTIONS))
 	  bind_builtin_variable ("echo_executing_commands",
-				 (double) ECHO_OFF);
+				 static_cast<double> (ECHO_OFF));
 	else
 	  bind_builtin_variable ("echo_executing_commands",
-				 (double) ECHO_SCRIPTS);
+				 static_cast<double> (ECHO_SCRIPTS));
       }
       break;
 
     case 2:
       {
 	string arg = argv[1];
 
 	if (arg == "on")
 	  bind_builtin_variable ("echo_executing_commands",
-				 (double) ECHO_SCRIPTS);
+				 static_cast<double> (ECHO_SCRIPTS));
 	else if (arg == "off")
 	  bind_builtin_variable ("echo_executing_commands",
-				 (double) ECHO_OFF);
+				 static_cast<double> (ECHO_OFF));
 	else
 	  print_usage ("echo");
       }
       break;
 
     case 3:
       {
 	string arg = argv[1];
 
 	if (arg == "on" && argv[2] == "all")
-	  bind_builtin_variable ("echo_executing_commands",
-				 (double) (ECHO_SCRIPTS | ECHO_FUNCTIONS));
+	  {
+	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
+	    bind_builtin_variable ("echo_executing_commands",
+				   static_cast<double> (tmp));
+	  }
 	else if (arg == "off" && argv[2] == "all")
 	  bind_builtin_variable ("echo_executing_commands",
-				 (double) ECHO_OFF);
+				 static_cast<double> (ECHO_OFF));
 	else
 	  print_usage ("echo");
       }
       break;
 
     default:
       print_usage ("echo");
       break;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -720,28 +720,28 @@ read_binary_data (istream& is, int swap,
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another name should not result in an error.
 
   is.read (&name_len, 4);
   if (! is)
     return 0;
   if (swap)
-    swap_4_bytes ((char *) &name_len);
+    swap_4_bytes (static_cast<char *> (&name_len));
 
   name = new char [name_len+1];
   name[name_len] = '\0';
   if (! is.read (name, name_len))
     goto data_read_error;
 
   is.read (&doc_len, 4);
   if (! is)
     goto data_read_error;
   if (swap)
-    swap_4_bytes ((char *) &doc_len);
+    swap_4_bytes (static_cast<char *> (&doc_len));
 
   doc = new char [doc_len+1];
   doc[doc_len] = '\0';
   if (! is.read (doc, doc_len))
     goto data_read_error;
 
   if (! is.read (&tmp, 1))
     goto data_read_error;
@@ -753,89 +753,90 @@ read_binary_data (istream& is, int swap,
 
   switch (tmp)
     {
     case 1:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	double dtmp;
-	read_doubles (is, &dtmp, (save_type) tmp, 1, swap, fmt);
+	read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = dtmp;
       }
       break;
 
     case 2:
       {
 	FOUR_BYTE_INT nr, nc;
 	if (! is.read (&nr, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &nr);
+	  swap_4_bytes (static_cast<char *> (&nr));
 	if (! is.read (&nc, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &nc);
+	  swap_4_bytes (static_cast<char *> (&nc));
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	Matrix m (nr, nc);
 	double *re = m.fortran_vec ();
 	int len = nr * nc;
-	read_doubles (is, re, (save_type) tmp, len, swap, fmt);
+	read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = m;
       }
       break;
 
     case 3:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	Complex ctmp;
-	read_doubles (is, (double *) &ctmp, (save_type) tmp, 2, swap, fmt);
+	read_doubles (is, static_cast<double *> (&ctmp),
+		      static_cast<save_type> (tmp), 2, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = ctmp;
       }
       break;
 
     case 4:
       {
 	FOUR_BYTE_INT nr, nc;
 	if (! is.read (&nr, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &nr);
+	  swap_4_bytes (static_cast<char *> (&nr));
 	if (! is.read (&nc, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &nc);
+	  swap_4_bytes (static_cast<char *> (&nc));
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	ComplexMatrix m (nr, nc);
 	Complex *im = m.fortran_vec ();
 	int len = nr * nc;
-	read_doubles (is, (double *) im, (save_type) tmp, 2*len,
-		      swap, fmt);
+	read_doubles (is, static_cast<double *> (im),
+		      static_cast<save_type> (tmp), 2*len, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = m;
       }
       break;
 
     case 5:
       {
 	FOUR_BYTE_INT len;
 	if (! is.read (&len, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &len);
+	  swap_4_bytes (static_cast<char *> (&len));
 	char *s = new char [len+1];
 	if (! is.read (s, len))
 	  {
 	    delete [] s;
 	    goto data_read_error;
 	  }
 	s[len] = '\0';
 	tc = s;
@@ -845,46 +846,46 @@ read_binary_data (istream& is, int swap,
     case 6:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	double bas, lim, inc;
 	if (! is.read (&bas, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes ((char *) &bas);
+	  swap_8_bytes (static_cast<char *> (&bas));
 	if (! is.read (&lim, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes ((char *) &lim);
+	  swap_8_bytes (static_cast<char *> (&lim));
 	if (! is.read (&inc, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes ((char *) &inc);
+	  swap_8_bytes (static_cast<char *> (&inc));
 	Range r (bas, lim, inc);
 	tc = r;
       }
       break;
 
     case 7:
       {
 	FOUR_BYTE_INT elements;
 	if (! is.read (&elements, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes ((char *) &elements);
+	  swap_4_bytes (static_cast<char *> (&elements));
 	charMatrix chm (elements, 0);
 	int max_len = 0;
 	for (int i = 0; i < elements; i++)
 	  {
 	    FOUR_BYTE_INT len;
 	    if (! is.read (&len, 4))
 	      goto data_read_error;
 	    if (swap)
-	      swap_4_bytes ((char *) &len);
+	      swap_4_bytes (static_cast<char *> (&len));
 	    char *tmp = new char [len+1];
 	    if (! is.read (tmp, len))
 	      {
 		delete [] tmp;
 		goto data_read_error;
 	      }
 	    if (len > max_len)
 	      {
@@ -1117,21 +1118,21 @@ read_mat_file_header (istream& is, int& 
 
   // mopt is signed, therefore byte swap may result in negative value.
 
   if (mopt > 9999 || mopt < 0)
     swap = 1;
 
   if (swap)
     {
-      swap_4_bytes ((char *) &mopt);
-      swap_4_bytes ((char *) &nr);
-      swap_4_bytes ((char *) &nc);
-      swap_4_bytes ((char *) &imag);
-      swap_4_bytes ((char *) &len);
+      swap_4_bytes (static_cast<char *> (&mopt));
+      swap_4_bytes (static_cast<char *> (&nr));
+      swap_4_bytes (static_cast<char *> (&nc));
+      swap_4_bytes (static_cast<char *> (&imag));
+      swap_4_bytes (static_cast<char *> (&len));
     }
 
   if (mopt > 9999 || mopt < 0 || imag > 1 || imag < 0)
     {
       if (! quiet)
 	error ("load: can't read binary file");
       return -1;
     }
@@ -1861,17 +1862,17 @@ save_binary_data (ostream& os, const oct
 	}
       else if (len > 4096) // XXX FIXME XXX -- make this configurable.
 	{
 	  double max_val, min_val;
 	  if (m.all_integers (max_val, min_val))
 	    st = get_save_type (max_val, min_val);
 	}
       const Complex *mtmp = m.data ();
-      write_doubles (os, (const double *) mtmp, st, 2*len);
+      write_doubles (os, static_cast<const double *> (mtmp), st, 2*len);
     }
   else if (tc.is_string ())
     {
       tmp = 7;
       os.write (&tmp, 1);
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (&nr, 4);
       charMatrix chm = tc.char_matrix_value ();
@@ -2570,17 +2571,17 @@ default_save_format (void)
 static int
 save_precision (void)
 {
   double val;
   if (builtin_real_scalar_variable ("save_precision", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
+      if (ival >= 0 && ival == val)
 	{
 	  Vsave_precision = ival;
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("save_precision");
   return -1;
 }
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -81,19 +81,17 @@ double
 conj (double x)
 {
   return x;
 }
 
 double
 fix (double x)
 {
-  int tmp;
-  tmp = (int) x;
-  return (double) tmp;
+  return static_cast<int> (x);
 }
 
 double
 imag (double x)
 {
 #if defined (HAVE_ISNAN)
   return xisnan (x) ? octave_NaN : 0.0;
 #else
@@ -148,47 +146,47 @@ xerfc (double x)
   error ("erfc(x) not available on this system");
 #endif
 }
 
 double
 xisnan (double x)
 {
 #if defined (HAVE_ISNAN)
-  return (double) isnan (x);
+  return isnan (x);
 #else
   return 0;
 #endif
 }
 
 double
 xfinite (double x)
 {
 #if defined (HAVE_FINITE)
-  return (double) finite (x);
+  return finite (x);
 #elif defined (HAVE_ISINF) && defined (HAVE_ISNAN)
-  return (double) (! isinf (x) && ! isnan (x));
+  return (! isinf (x) && ! isnan (x));
 #else
   return 1;
 #endif
 }
 
 double
 xgamma (double x)
 {
   return F77_FCN (dgamma, DGAMMA) (x);
 }
 
 double
 xisinf (double x)
 {
 #if defined (HAVE_ISINF)
-  return (double) isinf (x);
+  return isinf (x);
 #elif defined (HAVE_FINITE) && defined (HAVE_ISNAN)
-  return (double) (! (finite (x) || isnan (x)));
+  return (! (finite (x) || isnan (x)));
 #else
   return 0;
 #endif
 }
 
 double
 xlgamma (double x)
 {
@@ -203,34 +201,34 @@ xlgamma (double x)
 // Complex -> double mappers.
 
 double
 xisnan (const Complex& x)
 {
 #if defined (HAVE_ISNAN)
   double rx = real (x);
   double ix = imag (x);
-  return (double) (isnan (rx) || isnan (ix));
+  return (isnan (rx) || isnan (ix));
 #else
   return 0;
 #endif
 }
 
 double
 xfinite (const Complex& x)
 {
   double rx = real (x);
   double ix = imag (x);
-  return (double) (! ((int) xisinf (rx) || (int) xisinf (ix)));
+  return (! (xisinf (rx) || xisinf (ix)));
 }
 
 double
 xisinf (const Complex& x)
 {
-  return (double) (! (int) xfinite (x));
+  return (! xfinite (x));
 }
 
 // Complex -> complex mappers.
 
 Complex
 acos (const Complex& x)
 {
   static Complex i (0, 1);
@@ -274,49 +272,41 @@ atanh (const Complex& x)
   static Complex i (0, 1);
   Complex retval = log ((1 + x) / (1 - x)) / 2.0;
   return retval;
 }
 
 Complex
 ceil (const Complex& x)
 {
-  int re = (int) ceil (real (x));
-  int im = (int) ceil (imag (x));
-  return Complex (re, im);
+  return Complex (real (x), imag (x));
 }
 
 Complex
 fix (const Complex& x)
 {
-  int re = (int) real (x);
-  int im = (int) imag (x);
-  return Complex (re, im);
+  return Complex (real (x), imag (x));
 }
 
 Complex
 floor (const Complex& x)
 {
-  int re = (int) floor (real (x));
-  int im = (int) floor (imag (x));
-  return Complex (re, im);
+  return Complex (floor (real (x)), floor (imag (x)));
 }
 
 Complex
 log10 (const Complex& x)
 {
   return M_LOG10E * log (x);
 }
 
 Complex
 round (const Complex& x)
 {
-  double re = D_NINT (real (x));
-  double im = D_NINT (imag (x));
-  return Complex (re, im);
+  return Complex (D_NINT (real (x)), D_NINT (imag (x)));
 }
 
 Complex
 signum (const Complex& x)
 {
   return x / abs (x);
 }
 
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -461,17 +461,18 @@ DEFUN_DLD (min, args, nargout,
 
       if (len > 0)
 	{
 	  RowVector idx (len);
 
 	  for (int i = 0; i < len; i++)
 	    {
 	      int tmp = index.elem (i) + 1;
-	      idx.elem (i) = (tmp <= 0) ? octave_NaN : (double) tmp;
+	      idx.elem (i) = (tmp <= 0)
+		? octave_NaN : static_cast<double> (tmp);
 	    }
 
 	  retval(1) = octave_value (idx, 0);
 	}
     }
   else if (nargin == 2)
     {
       int arg1_is_scalar = arg1.is_scalar_type ();
@@ -674,17 +675,18 @@ DEFUN_DLD (max, args, nargout,
 
       if (len > 0)
 	{
 	  RowVector idx (len);
 
 	  for (int i = 0; i < len; i++)
 	    {
 	      int tmp = index.elem (i) + 1;
-	      idx.elem (i) = (tmp <= 0) ? octave_NaN : (double) tmp;
+	      idx.elem (i) = (tmp <= 0)
+		? octave_NaN : static_cast<double> (tmp);
 	    }
 
 	  retval(1) = octave_value (idx, 0);
 	}
     }
   else if (nargin == 2)
     {
       int arg1_is_scalar = arg1.is_scalar_type ();
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -517,17 +517,17 @@ Handle all of the following:
 
  solved:
 
   retval.resize (nargout ? nargout : 1);
   retval(0) = soln, 1;
   if (nargout > 1)
     retval(1) = objf;
   if (nargout > 2)
-    retval(2) = (double) inform;
+    retval(2) = static_cast<double> (inform);
   if (nargout > 3)
     retval(3) = lambda;
 
 #endif
 
   return retval;
 }
 
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -72,17 +72,17 @@ octave_fstream::seek (streamoff offset, 
 long
 octave_fstream::tell (void) const
 {
   long retval = -1;
 
   if (fs)
     {
       filebuf *fb = fs.rdbuf ();
-      retval = (long) fb->seekoff (0, ios::cur);
+      retval = static_cast<long> (fb->seekoff (0, ios::cur));
     }
 
   return retval;
 }
 
 // Return non-zero if EOF has been reached on this stream.
 
 bool
diff --git a/src/oct-procbuf.h b/src/oct-procbuf.h
--- a/src/oct-procbuf.h
+++ b/src/oct-procbuf.h
@@ -43,17 +43,17 @@ public:
   octave_procbuf (const char *command, int mode)
     : filebuf (), proc_pid (-1), next (0) { open (command, mode); }
 
   ~octave_procbuf (void) { close (); }
 
   octave_procbuf *open (const char *command, int mode);
 
   octave_procbuf *close (void)
-    { return (octave_procbuf *) filebuf::close (); }
+    { return static_cast<octave_procbuf *> (filebuf::close ()); }
 
   virtual int sys_close (void);
 
   pid_t pid (void) { return proc_pid; }
 
 protected:
 
   pid_t proc_pid;
diff --git a/src/oct-stdstrm.cc b/src/oct-stdstrm.cc
--- a/src/oct-stdstrm.cc
+++ b/src/oct-stdstrm.cc
@@ -68,17 +68,17 @@ octave_base_stdiostream::tell (void) con
   long retval = -1;
 
   if (! bad ())
     {
       stdiobuf *sb = rdbuf ();
 
       if (sb)
 	{
-	  retval = (long) sb->seekoff (0, ios::cur);
+	  retval = static_cast<long> (sb->seekoff (0, ios::cur));
 
 	  if (bad ())
 	    retval = -1;
 	}
     }
 
   return retval;
 }
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -88,17 +88,17 @@ public:
   bool eof (void) const { return is ? is->eof () : true; }
 
   istream *input_stream (void) { return is; }
 
   ostream *output_stream (void) { return 0; }
 
   // XXX FIXME XXX -- should not have to cast away const here.
   stdiobuf *rdbuf (void) const
-    { return is ? ((istdiostream *) is)->rdbuf () : 0; }
+    { return is ? (const_cast<istdiostream *> (is))->rdbuf () : 0; }
 
   bool bad (void) const { return is ? is->bad () : true; }
 
   void clear (void)
     {
       if (is)
 	is->clear ();
     }
@@ -133,17 +133,17 @@ public:
   bool eof (void) const { return os ? os->eof () : true; }
 
   istream *input_stream (void) { return 0; }
 
   ostream *output_stream (void) { return os; }
 
   // XXX FIXME XXX -- should not have to cast away const here.
   stdiobuf *rdbuf (void) const
-    { return os ? ((ostdiostream *) os)->rdbuf () : 0; }
+    { return os ? (const_cast<ostdiostream *> (os))->rdbuf () : 0; }
 
   bool bad (void) const { return os ? os->bad () : true; }
 
   void clear (void)
     {
       if (os)
 	os->clear ();
     }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -57,17 +57,17 @@ convert_to_valid_int (const octave_value
       double dval = tc.double_value ();
 
       if (! error_state)
 	{
 	  if (! xisnan (dval))
 	    {
 	      int ival = NINT (dval);
 
-	      if ((double) ival == dval)
+	      if (ival == dval)
 		retval = ival;
 	      else
 		conv_err = 4;
 	    }
 	  else
 	    conv_err = 3;
 	}
       else
@@ -1255,17 +1255,17 @@ octave_base_stream::do_oscanf (const sca
 
 	    case 'd': case 'i': case 'o': case 'u': case 'x':
 	      {
 		int tmp;
 
 		if (is.scan (fmt, &tmp))
 		  {
 		    if (! discard)
-		      retval = (double) tmp;
+		      retval = static_cast<double> (tmp);
 		  }
 		else
 		  quit = true;
 	      }
 	      break;
 
 	    case 'e': case 'f': case 'g':
 	      {
@@ -1542,17 +1542,20 @@ public:
 
   // Get the current value as an int and advance the internal pointer.
   int int_value (void);
 
   // Get the current value as a string and advance the internal pointer.
   string string_value (void);
 
   operator void* () const
-    { return (curr_state == ok) ? (void *) -1 : (void *) 0; }
+    {
+      return (curr_state == ok)
+	? static_cast<void *> (-1) : static_cast<void *> (0);
+    }
 
   bool no_more_values (void) { return curr_state == list_exhausted; }
 
   bool looking_at_string (void);
 
 private:
 
   const octave_value_list values;
@@ -1809,20 +1812,22 @@ octave_base_stream::do_printf (printf_fo
 			{
 			  switch (elt->type)
 			    {
 			    case 'd': case 'i': case 'o': case 'x':
 			    case 'X': case 'u': case 'c':
 			      {
 				if (elt->modifier == 'l')
 				  do_printf_conv (os, fmt, nsa, sa_1,
-						  sa_2, true, (long) val);
+						  sa_2, true,
+						  static_cast<long> (val));
 				else
 				  do_printf_conv (os, fmt, nsa, sa_1,
-						  sa_2, true, (int) val);
+						  sa_2, true,
+						  static_cast<int> (val));
 			      }
 			      break;
 
 			    case 'f': case 'e': case 'E':
 			    case 'g': case 'G':
 			      do_printf_conv (os, fmt, nsa, sa_1,
 					      sa_2, true, val);
 			      break;
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -85,17 +85,21 @@ public:
 	curr_idx = 0;
       return current ();
     }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
-  operator void* () const { return ok () ? (void *) -1 : (void *) 0; }
+  operator void* () const
+    {
+      return ok ()
+	? static_cast<void *> (-1) : static_cast<void *> (0);
+    }
 
   bool all_character_conversions (void);
 
   bool all_numeric_conversions (void);
 
 private:
 
   // Number of conversions specified by this format string, or -1 if
@@ -170,17 +174,21 @@ public:
 	curr_idx = 0;
       return current ();
     }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
-  operator void* () const { return ok () ? (void *) -1 : (void *) 0; }
+  operator void* () const
+    {
+      return ok ()
+	? static_cast<void *> (-1) : static_cast<void *> (0);
+    }
 
 private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   int nconv;
 
   // Index to current element;
@@ -404,17 +412,21 @@ public:
   string error (bool clear = false)
     {
       int err_num;
       return error (clear, err_num);
     }
 
   bool ok (void) const { return rep && rep->ok (); }
 
-  operator void* () const { return ok () ? (void *) -1 : (void *) 0; }
+  operator void* () const
+    {
+      return ok ()
+	? static_cast<void *> (-1) : static_cast<void *> (0);
+    }
 
   string name (void);
 
   int mode (void);
 
   oct_mach_info::float_format float_format (void);
 
   static string mode_as_string (int mode);
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -55,21 +55,21 @@ long
 octave_base_strstream::tell (void) const
 {
   long retval = -1;
 
   if (! bad ())
     {
       // XXX FIXME XXX -- shouldn't have to do this!
 
-      streambuf *sb = ((octave_base_strstream *)this)->rdbuf ();
+      streambuf *sb = (static_cast<octave_base_strstream *>(this))->rdbuf ();
 
       if (sb)
 	{
-	  retval = (long) sb->seekoff (0, ios::cur);
+	  retval = static_cast<long> (sb->seekoff (0, ios::cur));
 
 	  if (bad ())
 	    retval = -1;
 	}
     }
 
   return retval;
 }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -173,17 +173,17 @@ intern_argv (int argc, char **argv)
       // Skip program name in argv.
 
       octave_argv = string_vector (argv+1, argc-1);
 
       bind_builtin_variable ("argv", octave_argv, 1, 1, 0);
       bind_builtin_variable ("__argv__", octave_argv, 1, 1, 0);
     }
 
-  bind_builtin_variable ("nargin", (double) argc-1, 1, 1, 0);
+  bind_builtin_variable ("nargin", static_cast<double> (argc-1), 1, 1, 0);
 }
 
 // Initialize some global variables for later use.
 
 static void
 initialize_globals (const string& name)
 {
   // Kpathsea needs this.
@@ -595,17 +595,17 @@ main (int argc, char **argv)
 
   if (! interactive && forced_interactive)
     {
       rl_blink_matching_paren = 0;
 
       // XXX FIXME XXX -- is this the right thing to do?
 
       bind_builtin_variable ("echo_executing_commands",
-			     (double) ECHO_CMD_LINE);
+			     static_cast<double> (ECHO_CMD_LINE));
     }
 
   if (! interactive)
     using_readline = 0;
 
   int retval = main_loop ();
 
   if (retval == 1 && ! error_state)
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -60,20 +60,20 @@ public:
   octave_base_value (const octave_base_value&)
     : octave_value (octave_xvalue ()) { }
 
   ~octave_base_value (void) { }
 
   octave_value *clone (void) { return new octave_base_value (*this); }
 
   type_conv_fcn numeric_conversion_function (void) const
-    { return (type_conv_fcn) 0; }
+    { return static_cast<type_conv_fcn> (0); }
 
   octave_value *try_narrowing_conversion (void)
-    { return (octave_value *) 0; }
+    { return static_cast<octave_value *> (0); }
 
   octave_value index (const octave_value_list& idx) const;
 
   idx_vector index_vector (void) const;
 
   octave_value struct_elt_val (const string& nm, bool silent) const;
 
   octave_value& struct_elt_ref (const string& nm);
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -124,17 +124,17 @@ octave_range::all (void) const
   Matrix m = range.matrix_value ();
 
   return m.all ();
 }
 
 octave_value
 octave_range::any (void) const
 {
-  return (double) (range.base () != 0.0 || range.nelem () > 1);
+  return static_cast<double> (range.base () != 0.0 || range.nelem () > 1);
 }
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
   if (range.nelem () == 0)
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -117,39 +117,39 @@ octave_value_typeinfo::do_register_type 
   int len = types.length ();
 
   if (i == len)
     {
       len *= 2;
 
       types.resize (len, string ());
 
-      binary_ops.resize ((int) octave_value::num_binary_ops, len, len,
-			 (binary_op_fcn) 0);
+      binary_ops.resize (static_cast<int> (octave_value::num_binary_ops),
+			 len, len, static_cast<binary_op_fcn> (0));
 
-      assign_ops.resize (len, len, (assign_op_fcn) 0);
+      assign_ops.resize (len, len, static_cast<assign_op_fcn> (0));
 
       pref_assign_conv.resize (len, len, -1);
 
-      widening_ops.resize (len, len, (type_conv_fcn) 0);
+      widening_ops.resize (len, len, static_cast<type_conv_fcn> (0));
     }
 
   types (i) = name;
 
   num_types++;
 
   return i;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::binary_op op,
 					      int t1, int t2,
 					      binary_op_fcn f)
 {
-  binary_ops.checkelem ((int) op, t1, t2) = f;
+  binary_ops.checkelem (static_cast<int> (op), t1, t2) = f;
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assign_op (int t_lhs, int t_rhs,
 					      assign_op_fcn f)
 {
@@ -177,17 +177,17 @@ octave_value_typeinfo::do_register_widen
 }
 
 #include <iostream.h>
 
 binary_op_fcn
 octave_value_typeinfo::do_lookup_binary_op (octave_value::binary_op op,
 					    int t1, int t2)
 {
-  return binary_ops.checkelem ((int) op, t1, t2);
+  return binary_ops.checkelem (static_cast<int> (op), t1, t2);
 }
 
 assign_op_fcn
 octave_value_typeinfo::do_lookup_assign_op (int t_lhs, int t_rhs)
 {
   return assign_ops.checkelem (t_lhs, t_rhs);
 }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -844,17 +844,17 @@ resize_on_range_error (void)
 static int
 struct_levels_to_print (void)
 {
   double val;
   if (builtin_real_scalar_variable ("struct_levels_to_print", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
+      if (ival >= 0 && ival == val)
 	{
 	  Vstruct_levels_to_print = ival;
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("struct_levels_to_print");
   return -1;
 }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -241,18 +241,18 @@ set_format (double d, int& fw)
   bool sign = (d < 0.0);
 
   bool inf_or_nan = (xisinf (d) || xisnan (d));
 
   bool nan_or_int = (xisnan (d) || D_NINT (d) == d);
 
   double d_abs = d < 0.0 ? -d : d;
 
-  int digits = (inf_or_nan || d_abs == 0.0) ? 0
-    : (int) floor (log10 (d_abs) + 1.0);
+  int digits = (inf_or_nan || d_abs == 0.0)
+    ? 0 : static_cast<int> (floor (log10 (d_abs) + 1.0));
 
   set_real_format (sign, digits, inf_or_nan, nan_or_int, fw);
 }
 
 static inline void
 set_format (double d)
 {
   int fw;
@@ -375,18 +375,21 @@ set_format (const Matrix& m, int& fw)
   bool inf_or_nan = m.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = m.all_elements_are_int_or_inf_or_nan ();
 
   Matrix m_abs = m.abs ();
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
-  int x_max = max_abs == 0.0 ? 0 : (int) floor (log10 (max_abs) + 1.0);
-  int x_min = min_abs == 0.0 ? 0 : (int) floor (log10 (min_abs) + 1.0);
+  int x_max = max_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (max_abs) + 1.0));
+
+  int x_min = min_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (min_abs) + 1.0));
 
   set_real_matrix_format (sign, x_max, x_min, inf_or_nan,
 			  int_or_inf_or_nan, fw);
 }
 
 static inline void
 set_format (const Matrix& m)
 {
@@ -524,18 +527,21 @@ set_format (const Complex& c, int& r_fw,
 
   bool inf_or_nan = (xisinf (c) || xisnan (c));
 
   bool int_only = (D_NINT (rp) == rp && D_NINT (ip) == ip);
 
   double r_abs = rp < 0.0 ? -rp : rp;
   double i_abs = ip < 0.0 ? -ip : ip;
 
-  int r_x = r_abs == 0.0 ? 0 : (int) floor (log10 (r_abs) + 1.0);
-  int i_x = i_abs == 0.0 ? 0 : (int) floor (log10 (i_abs) + 1.0);
+  int r_x = r_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (r_abs) + 1.0));
+
+  int i_x = i_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (i_abs) + 1.0));
 
   int x_max, x_min;
 
   if (r_x > i_x)
     {
       x_max = r_x;
       x_min = i_x;
     }
@@ -693,21 +699,27 @@ set_format (const ComplexMatrix& cm, int
   Matrix r_m_abs = rp.abs ();
   double r_max_abs = pr_max_internal (r_m_abs);
   double r_min_abs = pr_min_internal (r_m_abs);
 
   Matrix i_m_abs = ip.abs ();
   double i_max_abs = pr_max_internal (i_m_abs);
   double i_min_abs = pr_min_internal (i_m_abs);
 
-  int r_x_max = r_max_abs == 0.0 ? 0 : (int) floor (log10 (r_max_abs) + 1.0);
-  int r_x_min = r_min_abs == 0.0 ? 0 : (int) floor (log10 (r_min_abs) + 1.0);
+  int r_x_max = r_max_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (r_max_abs) + 1.0));
+
+  int r_x_min = r_min_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (r_min_abs) + 1.0));
 
-  int i_x_max = i_max_abs == 0.0 ? 0 : (int) floor (log10 (i_max_abs) + 1.0);
-  int i_x_min = i_min_abs == 0.0 ? 0 : (int) floor (log10 (i_min_abs) + 1.0);
+  int i_x_max = i_max_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (i_max_abs) + 1.0));
+
+  int i_x_min = i_min_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (i_min_abs) + 1.0));
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
   set_complex_matrix_format (sign, x_max, x_min, r_x_max, r_x_min,
 			     inf_or_nan, int_or_inf_or_nan, r_fw, i_fw);
 }
 
@@ -828,18 +840,21 @@ set_format (const Range& r, int& fw)
 
   bool sign = (r_min < 0.0);
 
   bool all_ints = r.all_elements_are_ints ();
 
   double max_abs = r_max < 0.0 ? -r_max : r_max;
   double min_abs = r_min < 0.0 ? -r_min : r_min;
 
-  int x_max = max_abs == 0.0 ? 0 : (int) floor (log10 (max_abs) + 1.0);
-  int x_min = min_abs == 0.0 ? 0 : (int) floor (log10 (min_abs) + 1.0);
+  int x_max = max_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (max_abs) + 1.0));
+
+  int x_min = min_abs == 0.0
+    ? 0 : static_cast<int> (floor (log10 (min_abs) + 1.0));
 
   set_range_format (sign, x_max, x_min, all_ints, fw);
 }
 
 static inline void
 set_format (const Range& r)
 {
   int fw;
@@ -917,22 +932,22 @@ pr_any_float (const char *fmt, ostream& 
 	    oct_mach_info::native_float_format ();
 
 	  if (hex_format > 1
 	      || flt_fmt == oct_mach_info::ieee_big_endian
 	      || flt_fmt == oct_mach_info::cray
 	      || flt_fmt == oct_mach_info::unknown)
 	    {
 	      for (size_t i = 0; i < sizeof (double); i++)
-		os.form ("%02x", (int) tmp.i[i]);
+		os.form ("%02x", static_cast<int> (tmp.i[i]));
 	    }
 	  else
 	    {
 	      for (int i = sizeof (double) - 1; i >= 0; i--)
-		os.form ("%02x", (int) tmp.i[i]);
+		os.form ("%02x", static_cast<int> (tmp.i[i]));
 	    }
 	}
       else if (bit_format)
 	{
 	  equiv tmp;
 	  tmp.d = d;
 
 	  // Unless explicitly asked for, always print in big-endian
@@ -1543,18 +1558,18 @@ init_format_state (void)
   bit_format = 0;
   print_e = false;
   print_big_e = false;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  bind_builtin_variable ("output_precision", (double) prec);
-  bind_builtin_variable ("output_max_field_width", (double) fw);
+  bind_builtin_variable ("output_precision", static_cast<double> (prec));
+  bind_builtin_variable ("output_max_field_width", static_cast<double> (fw));
 }
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
   int idx = 1;
 
   if (--argc > 0)
@@ -1699,17 +1714,17 @@ set output formatting style")
 static int
 output_max_field_width (void)
 {
   double val;
   if (builtin_real_scalar_variable ("output_max_field_width", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival > 0 && (double) ival == val)
+      if (ival > 0 && ival == val)
 	{
 	  Voutput_max_field_width = ival;
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("output_max_field_width");
   return -1;
 }
@@ -1717,17 +1732,17 @@ output_max_field_width (void)
 static int
 output_precision (void)
 {
   double val;
   if (builtin_real_scalar_variable ("output_precision", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
+      if (ival >= 0 && ival == val)
 	{
 	  Voutput_precision = ival;
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("output_precision");
   return -1;
 }
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -567,17 +567,17 @@ tree_try_catch_command::~tree_try_catch_
 {
   delete try_code;
   delete catch_code;
 }
 
 static void
 do_catch_code (void *ptr)
 {
-  tree_statement_list *list = (tree_statement_list *) ptr;
+  tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
 
   // Set up for letting the user print any messages from errors that
   // occurred in the body of the try_catch statement.
 
   buffer_error_messages = 0;
   bind_global_error_variable ();
   add_unwind_protect (clear_global_error_variable, 0);
 
@@ -656,17 +656,17 @@ tree_unwind_protect_command::~tree_unwin
 {
   delete unwind_protect_code;
   delete cleanup_code;
 }
 
 static void
 do_unwind_protect_cleanup_code (void *ptr)
 {
-  tree_statement_list *list = (tree_statement_list *) ptr;
+  tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
 
   // We want to run the cleanup code without error_state being set,
   // but we need to restore its value, so that any errors encountered
   // in the first part of the unwind_protect are not completely
   // ignored.
 
   unwind_protect_int (error_state);
   error_state = 0;
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -606,17 +606,17 @@ tree_boolean_expression::eval (bool /* p
 		    }
 		}
 	      else
 		eval_error ();
 
 	    done:
 
 	      if (! error_state)
-		retval = octave_value ((double) result);
+		retval = octave_value (static_cast<double> (result));
 	    }
 	}
     }
   else
     eval_error ();
 
   return retval;
 }
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -74,18 +74,18 @@ tree_function::install_nargin_and_nargou
 {
   nargin_sr = sym_tab->lookup ("nargin", 1, 0);
   nargout_sr = sym_tab->lookup ("nargout", 1, 0);
 }
 
 void
 tree_function::bind_nargin_and_nargout (int nargin, int nargout)
 {
-  nargin_sr->define ((double) nargin);
-  nargout_sr->define ((double) nargout);
+  nargin_sr->define (static_cast<double> (nargin));
+  nargout_sr->define (static_cast<double> (nargout));
 }
 
 tree_function::~tree_function (void)
 {
   delete param_list;
   delete ret_list;
   delete sym_tab;
   delete cmd_list;
@@ -220,44 +220,45 @@ tree_function::eval (bool print)
   return retval;
 }
 
 // For unwind protect.
 
 static void
 pop_symbol_table_context (void *table)
 {
-  symbol_table *tmp = (symbol_table *) table;
+  symbol_table *tmp = static_cast<symbol_table *> (table);
   tmp->pop_context ();
 }
 
 static void
 delete_vr_list (void *list)
 {
-  tree_va_return_list *tmp = (tree_va_return_list *) list;
+  tree_va_return_list *tmp = static_cast<tree_va_return_list *> (list);
   tmp->clear ();
   delete tmp;
 }
 
 static void
 clear_symbol_table (void *table)
 {
-  symbol_table *tmp = (symbol_table *) table;
+  symbol_table *tmp = static_cast<symbol_table *> (table);
   tmp->clear ();
 }
 
 static void
 unprotect_function (void *sr_arg)
 {
-  symbol_record *sr = (symbol_record *) sr_arg;
+  symbol_record *sr = static_cast<symbol_record *> (sr_arg);
   sr->unprotect ();
 }
 
 octave_value_list
-tree_function::eval (bool /* print */, int nargout, const octave_value_list& args)
+tree_function::eval (bool /* print */, int nargout,
+		     const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
@@ -267,44 +268,44 @@ tree_function::eval (bool /* print */, i
   begin_unwind_frame ("func_eval");
 
   unwind_protect_int (call_depth);
   call_depth++;
 
   if (symtab_entry && ! symtab_entry->is_read_only ())
     {
       symtab_entry->protect ();
-      add_unwind_protect (unprotect_function, (void *) symtab_entry);
+      add_unwind_protect (unprotect_function, symtab_entry);
     }
 
   if (call_depth > 1)
     {
       sym_tab->push_context ();
-      add_unwind_protect (pop_symbol_table_context, (void *) sym_tab);
+      add_unwind_protect (pop_symbol_table_context, sym_tab);
 
       if (vr_list)
 	{
 	  // Push new vr_list.
 
 	  unwind_protect_ptr (vr_list);
 	  vr_list = new tree_va_return_list;
 
 	  // Clear and delete the new one before restoring the old
 	  // one.
 
-	  add_unwind_protect (delete_vr_list, (void *) vr_list);
+	  add_unwind_protect (delete_vr_list, vr_list);
 	}
     }
 
   if (vr_list)
     vr_list->clear ();
 
   // Force symbols to be undefined again when this function exits.
 
-  add_unwind_protect (clear_symbol_table, (void *) sym_tab);
+  add_unwind_protect (clear_symbol_table, sym_tab);
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   unwind_protect_ptr (curr_sym_tab);
   curr_sym_tab = sym_tab;
 
   unwind_protect_ptr (curr_function);
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -172,17 +172,17 @@ tree_identifier::assign (const octave_va
 	}
       else if (sym->is_function ())
 	{
 	  sym->clear ();
 	}
 
       if (sym->is_variable () && sym->is_defined ())
 	{
-	  tree_constant *tmp = (tree_constant *) sym->def ();
+	  tree_constant *tmp = static_cast<tree_constant *> (sym->def ());
 	  retval = tmp->assign (args, rhs);
 	}
       else
 	{
 	  assert (! sym->is_defined ());
 
 	  if (! Vresize_on_range_error)
 	    {
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -153,17 +153,18 @@ public:
   const octave_value& operator () (Pix p) const
     { return rep->operator () (p); }
 
   Pix first (void) const { return rep->first (); }
   void next (Pix& p) const { rep->next (p); }
   
   operator void* () const
     {
-      return (rep && rep->ok) ? (void *) -1 : (void *) 0;
+      return (rep && rep->ok)
+	? static_cast<void *> (-1) : static_cast<void *> (0);
     }
 
 private:
 
   tm_row_const_rep *rep;
 };
 
 void
@@ -271,17 +272,18 @@ public:
 
   int rows (void) const { return nr; }
   int cols (void) const { return nc; }
 
   bool all_strings (void) const { return all_str; }
   bool is_complex (void) const { return is_cmplx; }
   bool all_empty (void) const { return all_mt; }
 
-  operator void* () const { return ok ? (void *) -1 : (void *) 0; }
+  operator void* () const
+    { return ok ? static_cast<void *> (-1) : static_cast<void *> (0); }
 
 private:
 
   int nr;
   int nc;
 
   bool all_str;
   bool is_cmplx;
@@ -411,21 +413,21 @@ tree_matrix_row::to_return_list (void)
       bool is_idx_expr = elt->is_index_expression ();
 
       if (is_id || is_idx_expr)
 	{
 	  tree_index_expression *idx_expr;
 
 	  if (is_id)
 	    {
-	      tree_identifier *id = (tree_identifier *) elt;
+	      tree_identifier *id = static_cast<tree_identifier *> (elt);
 	      idx_expr = new tree_index_expression (id);
 	    }
 	  else
-	    idx_expr = (tree_index_expression *) elt;
+	    idx_expr = static_cast<tree_index_expression *> (elt);
 
 	  if (first_elem)
 	    {
 	      first_elem = false;
 
 	      retval = new tree_return_list (idx_expr);
 	    }
 	  else
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -175,17 +175,18 @@ tree_statement_list::eval (bool print, i
 
 	      if (cmd)
 		cmd->eval ();
 	      else
 		{
 		  if (expr->is_multi_val_ret_expression ())
 		    {
 		      octave_value_list args;
-		      tree_multi_val_ret *t = (tree_multi_val_ret *) expr;
+		      tree_multi_val_ret *t;
+		      t = static_cast<tree_multi_val_ret *> (expr);
 		      retval = t->eval (pf, nargout, args);
 		    }
 		  else
 		    retval = expr->eval (pf);
 		}
 
 	      if (error_state)
 		return octave_value ();
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -998,17 +998,17 @@ drawn.  With no argument, toggle the cur
   return retval;
 }
 
 DEFUN (ishold, , ,
   "ishold\n\
 \n\
 Return 1 if hold is on, otherwise return 0.")
 {
-  return (double) (! clear_before_plotting);
+  return static_cast<double> (! clear_before_plotting);
 }
 
 DEFUN (purge_tmp_files, , ,
   "delete temporary data files used for plotting")
 {
   octave_value_list retval;
   cleanup_tmp_files ();
   return retval;
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -247,17 +247,17 @@ Handle all of the following:
 
  solved:
 
   retval.resize (nargout ? nargout : 1);
   retval(0) = soln, 1;
   if (nargout > 1)
     retval(1) = objf;
   if (nargout > 2)
-    retval(2) = (double) inform;
+    retval(2) = static_cast<double> (inform);
   if (nargout > 3)
     retval(3) = lambda;
 
 #endif
 
   return retval;
 }
 
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -140,28 +140,28 @@ integrand is singular.")
     {
       error ("quad: expecting third argument to be a scalar");
       return retval;
     }
 
   int indefinite = 0;
   IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
   double bound = 0.0;
-  if ((int) xisinf (a) && (int) xisinf (b))
+  if (xisinf (a) && xisinf (b))
     {
       indefinite = 1;
       indef_type = IndefQuad::doubly_infinite;
     }
-  else if ((int) xisinf (a))
+  else if (xisinf (a))
     {
       indefinite = 1;
       bound = b;
       indef_type = IndefQuad::neg_inf_to_bound;
     }
-  else if ((int) xisinf (b))
+  else if (xisinf (b))
     {
       indefinite = 1;
       bound = a;
       indef_type = IndefQuad::bound_to_inf;
     }
 
   int ier = 0;
   int nfun = 0;
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -131,28 +131,28 @@ create_index_array (int n)
     }
 
 #define VECTOR_CREATE_RETURN_VALUES(vs, v) \
   int k = l (0); \
   idx (0) = k; \
   vs (0) = v (k-1); \
   for (int i = 1; i < n; i++) \
     { \
-      k = l ((int) idx (i-1)); \
+      k = l (static_cast<int> (idx (i-1))); \
       idx (i) = k; \
       vs (i) = v (k-1); \
     }
 
 #define MATRIX_CREATE_RETURN_VALUES(ms, m) \
   int k = l (0); \
   idx (0, j) = k; \
   ms (0, j) = m (k-1, j); \
   for (int i = 1; i < nr; i++) \
     { \
-      k = l ((int) idx (i-1, j)); \
+      k = l (static_cast<int> (idx (i-1, j))); \
       idx (i, j) = k; \
       ms (i, j) = m (k-1, j); \
     }
 
 static octave_value_list
 mx_sort (const Matrix& m)
 {
   octave_value_list retval;
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -39,17 +39,17 @@ Software Foundation, 59 Temple Place - S
 DEFUN (isstr, args, ,
   "isstr (X): return 1 if X is a string, 0 otherwise")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
-    retval = (double) args(0).is_string ();
+    retval = static_cast<double> (args(0).is_string ());
   else
     print_usage ("isstr");
 
   return retval;
 }
 
 DEFUN (setstr, args, ,
   "setstr (V): convert a vector to a string")
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -410,17 +410,17 @@ symbol_record::define (tree_constant *t)
     }
 
   definition->define (t);
 
   if (sv_fcn && sv_fcn () < 0)
     {
       // Would be nice to be able to avoid this cast.  XXX FIXME XXX
 
-      definition->define ((tree_constant *) saved_def);
+      definition->define (static_cast<tree_constant *> (saved_def));
       return 0;
     }
 
   delete saved_def;
 
   return 1;
 }
 
@@ -599,17 +599,17 @@ symbol_record::is_linked_to_global (void
 
 octave_value
 symbol_record::variable_value (void) const
 {
   octave_value retval;
 
   if (is_variable ())
     {
-      tree_constant *tmp = (tree_constant *) def ();
+      tree_constant *tmp = static_cast<tree_constant *> (def ());
       retval = tmp->value ();
     }
 
   return retval;
 }
 
 octave_value&
 symbol_record::variable_reference (void)
@@ -624,17 +624,17 @@ symbol_record::variable_reference (void)
 
       if (! is_defined ())
 	{
 	  tree_constant *tmp = new tree_constant ();
 	  define (tmp);
 	}
     }
 
-  tree_constant *tmp = (tree_constant *) def ();
+  tree_constant *tmp = static_cast<tree_constant *> (def ());
 
   return tmp->reference ();
 }
 
 symbol_record *
 symbol_record::next (void) const
 {
   return next_elem;
@@ -647,17 +647,17 @@ symbol_record::chain (symbol_record *s)
 }
 
 void
 symbol_record::push_context (void)
 {
   context.push (definition);
   definition = 0;
 
-  global_link_context.push ((unsigned) linked_to_global);
+  global_link_context.push (static_cast<unsigned> (linked_to_global));
   linked_to_global = 0;
 }
 
 void
 symbol_record::pop_context (void)
 {
   // It is possible for context to be empty if new symbols have been
   // inserted in the symbol table during recursive calls.  This can
@@ -736,17 +736,17 @@ symbol_record_info::symbol_record_info (
   : initialized (0), nr (-1), nc (-1), type (sr.type ()),
     hides (SR_INFO_NONE), eternal (0), read_only (0), nm (),
     const_type ()
 {
   if (sr.is_variable () && sr.is_defined ())
     {
       // Would be nice to avoid this cast.  XXX FIXME XXX
 
-      tree_constant *tmp = (tree_constant *) sr.def ();
+      tree_constant *tmp = static_cast<tree_constant *> (sr.def ());
 
       const_type = tmp->type_name ();
 
       nr = tmp->rows ();
       nc = tmp->columns ();
 
       symbol_def *sr_def = sr.definition;
       symbol_def *hidden_def = sr_def->next_elem;
@@ -1053,18 +1053,18 @@ symbol_table::long_list (int& count, con
 	    symbols[count++] = symbol_record_info (*ptr);
 
 	  ptr = ptr->next ();
 	}
     }
   symbols[count] = symbol_record_info ();
 
   if (sort && symbols)
-    qsort ((void *) symbols, count, sizeof (symbol_record_info),
-	   (int (*)(const void*, const void*)) symbol_record_info_cmp);
+    qsort (symbols, count, sizeof (symbol_record_info),
+	   symbol_record_info_cmp);
 
   return symbols;
 }
 
 string_vector
 symbol_table::list (int& count, const string_vector& pats, int npats,
 		    int sort, unsigned type, unsigned scope) const
 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -59,34 +59,34 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 #include "variables.h"
 
 static Octave_map
 mk_stat_map (const file_stat& fs)
 {
   Octave_map m;
 
-  m["dev"] = (double) fs.dev ();
-  m["ino"] = (double) fs.ino ();
+  m["dev"] = static_cast<double> (fs.dev ());
+  m["ino"] = static_cast<double> (fs.ino ());
   m["modestr"] = fs.mode_as_string ();
-  m["nlink"] = (double) fs.nlink ();
-  m["uid"] = (double) fs.uid ();
-  m["gid"] = (double) fs.gid ();
+  m["nlink"] = static_cast<double> (fs.nlink ());
+  m["uid"] = static_cast<double> (fs.uid ());
+  m["gid"] = static_cast<double> (fs.gid ());
 #if defined (HAVE_ST_RDEV)
-  m["rdev"] = (double) fs.rdev ();
+  m["rdev"] = static_cast<double> (fs.rdev ());
 #endif
-  m["size"] = (double) fs.size ();
-  m["atime"] = (double) fs.atime ();
-  m["mtime"] = (double) fs.mtime ();
-  m["ctime"] = (double) fs.ctime ();
+  m["size"] = static_cast<double> (fs.size ());
+  m["atime"] = static_cast<double> (fs.atime ());
+  m["mtime"] = static_cast<double> (fs.mtime ());
+  m["ctime"] = static_cast<double> (fs.ctime ());
 #if defined (HAVE_ST_BLKSIZE)
-  m["blksize"] = (double) fs.blksize ();
+  m["blksize"] = static_cast<double> (fs.blksize ());
 #endif
 #if defined (HAVE_ST_BLOCKS)
-  m["blocks"] = (double) fs.blocks ();
+  m["blocks"] = static_cast<double> (fs.blocks ());
 #endif
 
   return m;
 }
 
 DEFUN (dup2, args, ,
  "[FID, MSG] = dup2 (OLD, NEW)\n\
 \n\
@@ -115,17 +115,17 @@ Otherwise, FID is negative and MSG conta
 	      int i_old = NINT (d_old);
 	      int i_new = NINT (d_new);
 
 	      // XXX FIXME XXX -- are these checks sufficient?
 	      if (i_old >= 0 && i_new >= 0)
 		{
 		  int status = dup2 (i_old, i_new);
 
-		  retval(0) = (double) status;
+		  retval(0) = static_cast<double> (status);
 
 		  if (status < 0)
 		    retval(1) = strerror (errno);
 		}
 	      else
 		error ("dup2: invalid file id");
 	    }
 	  else
@@ -201,17 +201,17 @@ be nonzero, and MSG will contain a syste
 	      exec_args[0] = strsave (exec_file.c_str ());
 	      exec_args[1] = 0;
 	    }
 
 	  if (! error_state)
 	    {
 	      int status = execvp (exec_file.c_str (), exec_args);
 
-	      retval(0) = (double) status;
+	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = strerror (errno);
 	    }
 	}
       else
 	error ("exec: first argument must be a string");
 #else
@@ -257,17 +257,17 @@ STATUS is nonzero and MSG contains a sys
 
 	  // XXX FIXME XXX -- Need better checking here?
 	  if (fid < 0)
 	    error ("fcntl: invalid file id");
 	  else
 	    {
 	      int status = fcntl (fid, req, arg);
 
-	      retval(0) = (double) status;
+	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = strerror (errno);
 	    }
 	}
       else
 	error ("fcntl: file id must be an integer");
 #else
@@ -296,17 +296,17 @@ has occured, and MSG contains a system-d
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
 #if defined (HAVE_FORK)
       pid_t pid = fork ();
 
-      retval(0) = (double) pid;
+      retval(0) = static_cast<double> (pid);
 
       if (pid < 0)
 	retval(1) = strerror (errno);
 #else
       gripe_not_supported ("fork");
 #endif
     }
   else
@@ -517,23 +517,23 @@ STATUS is nonzero and MSG contains a sys
   if (nargin == 2)
     {
       if (args(0).is_string ())
 	{
 	  string name = args(0).string_value ();
 
 	  if (args(1).is_scalar_type ())
 	    {
-	      long mode = (long) args(1).double_value ();
+	      long mode = static_cast<long> (args(1).double_value ());
 
 	      string msg;
 
 	      int status = oct_mkfifo (name, mode, msg);
 
-	      retval(0) = (double) status;
+	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	  else
 	    error ("mkfifo: MODE must be an integer");
 	}
       else
@@ -586,17 +586,17 @@ STATUS is nonzero and MSG contains a sys
 	    = new octave_ostdiostream (string (), out_file);
 
 	  Matrix file_ids (1, 2);
 
 	  file_ids (0, 0) = octave_stream_list::insert (is);
 	  file_ids (0, 1) = octave_stream_list::insert (os);
 
           retval(0) = file_ids;
-	  retval(1) = (double) status;
+	  retval(1) = static_cast<double> (status);
 	}
 #else
       gripe_not_supported ("pipe");
 #endif
     }
   else
     print_usage ("pipe");
 
@@ -679,17 +679,17 @@ STATUS is nonzero and MSG contains a sys
       if (args(0).is_string ())
 	{
 	  string name = args(0).string_value ();
 
 	  string msg;
 
 	  int status = oct_unlink (name, msg);
 
-	  retval(0) = (double) status;
+	  retval(0) = static_cast<double> (status);
 
 	  if (status < 0)
 	    retval(1) = msg;	    
 	}
       else
 	error ("unlink: file name must be a string");
     }
   else
@@ -763,17 +763,17 @@ error message.")
 			}
 		    }
 		}
 
 	      if (! error_state)
 		{
 		  pid_t status = waitpid (pid, 0, options);
 
-		  retval(0) = (double) status;
+		  retval(0) = static_cast<double> (status);
 
 		  if (status < 0)
 		    retval(1) = strerror (errno);
 		}
 	    }
 	}
 #else
       gripe_not_supported ("waitpid");
@@ -788,87 +788,87 @@ error message.")
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
 void
 symbols_of_syscalls (void)
 {
 #if defined (F_DUPFD)
-  DEFCONST (F_DUPFD, (double) F_DUPFD, 0, 0,
+  DEFCONST (F_DUPFD, static_cast<double> (F_DUPFD), 0, 0,
     "");
 #endif
 
 #if defined (F_GETFD)
-  DEFCONST (F_GETFD, (double) F_GETFD, 0, 0,
+  DEFCONST (F_GETFD, static_cast<double> (F_GETFD), 0, 0,
     "");
 #endif
 
 #if defined (F_GETFL)
-  DEFCONST (F_GETFL, (double) F_GETFL, 0, 0,
+  DEFCONST (F_GETFL, static_cast<double> (F_GETFL), 0, 0,
     "");
 #endif
 
 #if defined (F_SETFD)
-  DEFCONST (F_SETFD, (double) F_SETFD, 0, 0,
+  DEFCONST (F_SETFD, static_cast<double> (F_SETFD), 0, 0,
     "");
 #endif
 
 #if defined (F_SETFL)
-  DEFCONST (F_SETFL, (double) F_SETFL, 0, 0,
+  DEFCONST (F_SETFL, static_cast<double> (F_SETFL), 0, 0,
     "");
 #endif
 
 #if defined (O_APPEND)
-  DEFCONST (O_APPEND, (double) O_APPEND, 0, 0,
+  DEFCONST (O_APPEND, static_cast<double> (O_APPEND), 0, 0,
     "");
 #endif
 
 #if defined (O_ASYNC)
-  DEFCONST (O_ASYNC, (double) O_ASYNC, 0, 0,
+  DEFCONST (O_ASYNC, static_cast<double> (O_ASYNC), 0, 0,
     "");
 #endif
 
 #if defined (O_CREAT)
-  DEFCONST (O_CREAT, (double) O_CREAT, 0, 0,
+  DEFCONST (O_CREAT, static_cast<double> (O_CREAT), 0, 0,
     "");
 #endif
 
 #if defined (O_EXCL)
-  DEFCONST (O_EXCL, (double) O_EXCL, 0, 0,
+  DEFCONST (O_EXCL, static_cast<double> (O_EXCL), 0, 0,
     "");
 #endif
 
 #if defined (O_NONBLOCK)
-  DEFCONST (O_NONBLOCK, (double) O_NONBLOCK, 0, 0,
+  DEFCONST (O_NONBLOCK, static_cast<double> (O_NONBLOCK), 0, 0,
     "");
 #endif
 
 #if defined (O_RDONLY)
-  DEFCONST (O_RDONLY, (double) O_RDONLY, 0, 0,
+  DEFCONST (O_RDONLY, static_cast<double> (O_RDONLY), 0, 0,
     "");
 #endif
 
 #if defined (O_RDWR)
-  DEFCONST (O_RDWR, (double) O_RDWR, 0, 0,
+  DEFCONST (O_RDWR, static_cast<double> (O_RDWR), 0, 0,
     "");
 #endif
 
 #if defined (O_SYNC)
-  DEFCONST (O_SYNC, (double) O_SYNC, 0, 0,
+  DEFCONST (O_SYNC, static_cast<double> (O_SYNC), 0, 0,
     "");
 #endif
 
 #if defined (O_TRUNC)
-  DEFCONST (O_TRUNC, (double) O_TRUNC, 0, 0,
+  DEFCONST (O_TRUNC, static_cast<double> (O_TRUNC), 0, 0,
     "");
 #endif
 
 #if defined (O_WRONLY)
-  DEFCONST (O_WRONLY, (double) O_WRONLY, 0, 0,
+  DEFCONST (O_WRONLY, static_cast<double> (O_WRONLY), 0, 0,
     "");
 #endif
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -603,18 +603,18 @@ DEFUN (usleep, args, ,
 // point functions really work.
 
 DEFUN (isieee, , ,
   "isieee (): return 1 if host uses IEEE floating point")
 {
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();
 
-  return (double) (flt_fmt == oct_mach_info::ieee_little_endian
-		   || flt_fmt == oct_mach_info::ieee_big_endian);
+  return static_cast<double> (flt_fmt == oct_mach_info::ieee_little_endian
+			      || flt_fmt == oct_mach_info::ieee_big_endian);
 }
 
 #if !defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
 int
 gethostname (char *name, int namelen)
 {
   int i;
   struct utsname ut;
diff --git a/src/time.cc b/src/time.cc
--- a/src/time.cc
+++ b/src/time.cc
@@ -40,25 +40,25 @@ Software Foundation, 59 Temple Place - S
 // Date and time functions.
 
 static Octave_map
 mk_tm_map (struct tm *tm, double fraction)
 {
   Octave_map m;
 
   m ["usec"] = fraction * 1e6;
-  m ["sec"] = (double) tm->tm_sec;
-  m ["min"] = (double) tm->tm_min;
-  m ["hour"] = (double) tm->tm_hour;
-  m ["mday"] = (double) tm->tm_mday;
-  m ["mon"] = (double) tm->tm_mon;
-  m ["year"] = (double) tm->tm_year;
-  m ["wday"] = (double) tm->tm_wday;
-  m ["yday"] = (double) tm->tm_yday;
-  m ["isdst"] = (double) tm->tm_isdst;
+  m ["sec"] = static_cast<double> (tm->tm_sec);
+  m ["min"] = static_cast<double> (tm->tm_min);
+  m ["hour"] = static_cast<double> (tm->tm_hour);
+  m ["mday"] = static_cast<double> (tm->tm_mday);
+  m ["mon"] = static_cast<double> (tm->tm_mon);
+  m ["year"] = static_cast<double> (tm->tm_year);
+  m ["wday"] = static_cast<double> (tm->tm_wday);
+  m ["yday"] = static_cast<double> (tm->tm_yday);
+  m ["isdst"] = static_cast<double> (tm->tm_isdst);
 #if defined (HAVE_TM_ZONE)
   m ["zone"]  = tm->tm_zone;
 #elif defined (HAVE_TZNAME)
   if (tm->tm_isdst == 0 || tm->tm_isdst == 1)
     m ["zone"] = tzname[tm->tm_isdst];
 #else
   m ["zone"] = zone_name (tm);
 #endif
@@ -113,17 +113,17 @@ seconds since the epoch.")
   fraction = tp.tv_usec / 1e6;
 
 #else
 
   now = time (0);
 
 #endif
  
-  return (double) now + fraction;
+  return static_cast<double> (now + fraction);
 }
 
 DEFUN_DLD (gmtime, args, ,
   "gmtime (TIME)\n\
 \n\
 Given a value returned from time(), return a structure like that\n\
 returned from localtime() but with values corresponding to\n\
 Coordinated Universal Time (UTC).")
@@ -197,17 +197,17 @@ DEFUN_DLD (mktime, args, ,
     {
       Octave_map map = args(0).map_value ();
 
       double fraction;
 
       struct tm *tm = extract_tm (map, fraction);
 
       if (! error_state)
-	retval = (double) mktime (tm) + fraction;
+	retval = static_cast<double> (mktime (tm) + fraction);
     }
   else
     print_usage ("mktime");
 
   return retval;
 }
 
 DEFUN_DLD (strftime, args, ,
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -139,18 +139,18 @@ jmp_buf toplevel;
 void
 parse_and_execute (FILE *f, int print)
 {
   begin_unwind_frame ("parse_and_execute");
   
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (f);
 
-  add_unwind_protect (restore_input_buffer, (void *) old_buf);
-  add_unwind_protect (delete_input_buffer, (void *) new_buf);
+  add_unwind_protect (restore_input_buffer, old_buf);
+  add_unwind_protect (delete_input_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   unwind_protect_int (using_readline);
   unwind_protect_int (input_from_command_line_file);
 
   using_readline = 0;
   input_from_command_line_file = 0;
@@ -196,17 +196,17 @@ parse_and_execute (FILE *f, int print)
 
   run_unwind_frame ("parse_and_execute");
 }
 
 static void
 safe_fclose (void *f)
 {
   if (f)
-    fclose ((FILE *) f);
+    fclose (static_cast<FILE *> (f));
 }
 
 void
 parse_and_execute (const string& s, int print, int verbose,
 		   const char *warn_for)
 {
   begin_unwind_frame ("parse_and_execute_2");
 
@@ -215,17 +215,17 @@ parse_and_execute (const string& s, int 
 
   reading_script_file = 1;
   curr_fcn_file_full_name = s;
 
   FILE *f = get_input_from_file (s, 0);
 
   if (f)
     {
-      add_unwind_protect (safe_fclose, (void *) f);
+      add_unwind_protect (safe_fclose, f);
 
       unwind_protect_int (input_line_number);
       unwind_protect_int (current_input_column);
 
       input_line_number = 0;
       current_input_column = 1;
 
       if (verbose)
@@ -536,18 +536,18 @@ eval_string (const string& s, int print,
 
   get_input_from_eval_string = 1;
   input_from_command_line_file = 0;
   current_eval_string = s;
 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
-  add_unwind_protect (restore_input_buffer, (void *) old_buf);
-  add_unwind_protect (delete_input_buffer, (void *) new_buf);
+  add_unwind_protect (restore_input_buffer, old_buf);
+  add_unwind_protect (delete_input_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   unwind_protect_ptr (curr_sym_tab);
 
   reset_parser ();
 
   parse_status = yyparse ();
@@ -647,17 +647,17 @@ string CATCH.")
   return retval;
 }
 
 // Execute a shell command.
 
 static void
 cleanup_iprocstream (void *p)
 {
-  delete (iprocstream *) p;
+  delete static_cast<iprocstream *> (p);
 }
 
 static octave_value_list
 run_command_and_return_output (const string& cmd_str)
 {
   octave_value_list retval;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
@@ -682,17 +682,17 @@ run_command_and_return_output (const str
 
       if (WIFEXITED (status))
 	status = WEXITSTATUS (status);
 
       output_buf << ends;
 
       char *msg = output_buf.str ();
 
-      retval(1) = (double) status;
+      retval(1) = static_cast<double> (status);
       retval(0) = msg;
 
       delete [] msg;
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   run_unwind_protect ();
@@ -769,33 +769,33 @@ or\n\
 		error ("system: fork failed -- can't create child process");
 	      else if (pid == 0)
 		{
 		  system (cmd_str.c_str ());
 		  exit (0);
 		  retval(0) = 0.0;
 		}
 	      else
-		retval(0) = (double) pid;
+		retval(0) = static_cast<double> (pid);
 	    }
 	  else if (return_output)
 	    retval = run_command_and_return_output (cmd_str);
 	  else
 	    {
 	      int status = system (cmd_str.c_str ());
 
 	      // The value in status is as returned by waitpid.  If
 	      // the process exited normally, extract the actual exit
 	      // status of the command.  Otherwise, return 127 as a
 	      // failure code.
 
 	      if (WIFEXITED (status))
 		status = WEXITSTATUS (status);
 
-	      retval = (double) status;
+	      retval = static_cast<double> (status);
 	    }
 	}
     }
   else
     print_usage ("system");
 
   return retval;
 }
@@ -864,17 +864,17 @@ information.")
 #endif
 
   Octave_map m;
 
   m ["default_pager"] = DEFAULT_PAGER;
   m ["prefix"] = OCTAVE_PREFIX;
   m ["exec_prefix"] = OCTAVE_EXEC_PREFIX;
   m ["datadir"] = OCTAVE_DATADIR;
-  m ["dld"] = (double) octave_supports_dynamic_linking;
+  m ["dld"] = static_cast<double> (octave_supports_dynamic_linking);
   m ["libdir"] = OCTAVE_LIBDIR;
   m ["bindir"] = OCTAVE_BINDIR;
   m ["infodir"] = OCTAVE_INFODIR;
   m ["fcnfiledir"] = OCTAVE_FCNFILEDIR;
   m ["localfcnfiledir"] = OCTAVE_LOCALFCNFILEDIR;
   m ["localstartupfiledir"] = OCTAVE_LOCALSTARTUPFILEDIR;
   m ["startupfiledir"] = OCTAVE_STARTUPFILEDIR;
   m ["localfcnfilepath"] = OCTAVE_LOCALFCNFILEPATH;
@@ -937,21 +937,21 @@ extern vfp __new_handler;
 void *
 __builtin_new (size_t sz)
 {
   void *p;
 
   /* malloc (0) is unpredictable; avoid it.  */
   if (sz == 0)
     sz = 1;
-  p = (void *) malloc (sz);
+  p = malloc (sz);
   while (p == 0)
     {
       (*__new_handler) ();
-      p = (void *) malloc (sz);
+      p = malloc (sz);
     }
 
   if (debug_new_delete)
     cout << "__builtin_new: " << p << endl;
 
   return p;
 }
 
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -210,17 +210,17 @@ saved_variable::restore_value (void)
 {
   switch (type_tag)
     {
     case integer:
       *ptr_to_int = int_value;
       break;
 
     case string_type:
-      ((string *) gen_ptr) -> assign (*str_value);
+      (static_cast<string *> (gen_ptr)) -> assign (*str_value);
       break;
 
     case generic_ptr:
       *ptr_to_gen_ptr = gen_ptr_value;
       break;
 
     case generic:
       memcpy (gen_ptr, gen_ptr_value, size);
@@ -230,39 +230,39 @@ saved_variable::restore_value (void)
       panic_impossible ();
       break;
     }
 }
 
 static void
 restore_saved_variable (void *s)
 {
-  saved_variable *sv = (saved_variable *) s;
+  saved_variable *sv = static_cast<saved_variable *> (s);
   sv->restore_value ();
   delete sv;
 }
 
 void
 unwind_protect_int_internal (int *ptr, int value)
 {
   saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, (void *) s);
+  add_unwind_protect (restore_saved_variable, s);
 }
 
 void
 unwind_protect_str_internal (string *ptr, const string& value)
 {
   saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, (void *) s);
+  add_unwind_protect (restore_saved_variable, s);
 }
 
 void
 unwind_protect_ptr_internal (void **ptr, void *value)
 {
   saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, (void *) s);
+  add_unwind_protect (restore_saved_variable, s);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -49,17 +49,18 @@ void unwind_protect_var_internal (void *
 
 #define unwind_protect_int(i) \
   unwind_protect_int_internal (&(i), (i))
 
 #define unwind_protect_str(s) \
   unwind_protect_str_internal (&(s), (s))
 
 #define unwind_protect_ptr(p) \
-  unwind_protect_ptr_internal ((void **) &(p), (void *) (p))
+  unwind_protect_ptr_internal (static_cast<void **> (&(p)), \
+			       static_cast<void *> (p))
 
 class
 unwind_elem
 {
  public:
   unwind_elem (void)
     : ue_tag (), ue_fptr (0), ue_ptr (0) { }
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -338,17 +338,17 @@ otherwise, return 0.")
   if (error_state)
     {
       error ("is_global: expecting string argument");
       return retval;
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
 
-  retval = (double) (sr && sr->is_linked_to_global ());
+  retval = static_cast<double> (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
 DEFUN (exist, args, ,
   "exist (NAME): check if variable or file exists\n\
 \n\
 returns:\n\
@@ -637,17 +637,17 @@ restore_command_history (void *)
 {
   octave_command_history.ignore_entries (! Vsaving_history);
 }
 
 static void
 safe_fclose (void *f)
 {
   if (f)
-    fclose ((FILE *) f);
+    fclose (static_cast<FILE *> (f));
 }
 
 static int
 parse_fcn_file (int exec_script, const string& ff)
 {
   begin_unwind_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
@@ -666,17 +666,17 @@ parse_fcn_file (int exec_script, const s
 
   using_readline = 0;
   reading_fcn_file = 1;
   input_line_number = 0;
   current_input_column = 1;
 
   FILE *ffile = get_input_from_file (ff, 0);
 
-  add_unwind_protect (safe_fclose, (void *) ffile);
+  add_unwind_protect (safe_fclose, ffile);
 
   if (ffile)
     {
       // Check to see if this file defines a function or is just a
       // list of commands.
 
       if (is_function_file (ffile))
 	{
@@ -1537,17 +1537,17 @@ echo_executing_commands (void)
 static int
 history_size (void)
 {
   double val;
   if (builtin_real_scalar_variable ("history_size", val)
       && ! xisnan (val))
     {
       int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
+      if (ival >= 0 && ival == val)
 	{
 	  Vhistory_size = ival;
 	  octave_command_history.set_size (ival);
 	  return 0;
 	}
     }
   gripe_invalid_value_specified ("history_size");
   return -1;
@@ -1611,17 +1611,17 @@ static void
 symbols_of_variables (void)
 {
   DEFVAR (ans, , 0, 0,
     "");
 
   DEFCONST (argv, , 0, 0,
     "the command line arguments this program was invoked with");
 
-  DEFVAR (echo_executing_commands, (double) ECHO_OFF, 0,
+  DEFVAR (echo_executing_commands, static_cast<double> (ECHO_OFF), 0,
 	  echo_executing_commands,
     "echo commands as they are executed");
 
   DEFCONST (error_text, "", 0, 0,
     "the text of error messages that would have been printed in the
 body of the most recent unwind_protect statement or the TRY part of\n\
 the most recent eval() command.  Outside of unwind_protect and\n\
 eval(), or if no error has ocurred within them, the value of\n\
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -60,17 +60,17 @@ xisint (double x)
 //                  +---+---+----+----+
 //   complex_matrix | 4 | * | 10 |  * |
 //                  +---+---+----+----+
 
 // -*- 1 -*-
 octave_value
 xpow (double a, double b)
 {
-  if (a < 0.0 && (int) b != b)
+  if (a < 0.0 && static_cast<int> (b) != b)
     {
       Complex atmp (a);
       return pow (atmp, b);
     }
   else
     return pow (a, b);
 }
 
@@ -158,19 +158,19 @@ xpow (const Matrix& a, double b)
 
   int nr = a.rows ();
   int nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
-      if ((int) b == b)
+      if (static_cast<int> (b) == b)
 	{
-	  int btmp = (int) b;
+	  int btmp = b;
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
@@ -248,17 +248,17 @@ xpow (const Matrix& a, const Complex& b)
 
 // -*- 7 -*-
 octave_value
 xpow (const Complex& a, double b)
 {
   Complex result;
 
   if (xisint (b))
-    result = pow (a, (int) b);
+    result = pow (a, static_cast<int> (b));
   else
     result = pow (a, b);
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
@@ -343,19 +343,19 @@ xpow (const ComplexMatrix& a, double b)
 
   int nr = a.rows ();
   int nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
-      if ((int) b == b)
+      if (static_cast<int> (b) == b)
 	{
-	  int btmp = (int) b;
+	  int btmp = b;
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
@@ -499,17 +499,17 @@ elem_xpow (double a, const ComplexMatrix
 octave_value
 elem_xpow (const Matrix& a, double b)
 {
   octave_value retval;
 
   int nr = a.rows ();
   int nc = a.cols ();
 
-  if ((int) b != b && a.any_element_is_negative ())
+  if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    Complex atmp (a (i, j));
 	    result (i, j) = pow (atmp, b);
 	  }
@@ -548,17 +548,17 @@ elem_xpow (const Matrix& a, const Matrix
     }
 
   int convert_to_complex = 0;
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	double atmp = a (i, j);
 	double btmp = b (i, j);
-	if (atmp < 0.0 && (int) btmp != btmp)
+	if (atmp < 0.0 && static_cast<int> (btmp) != btmp)
 	  {
 	    convert_to_complex = 1;
 	    goto done;
 	  }
       }
 
 done:
 
@@ -637,17 +637,17 @@ elem_xpow (const Complex& a, const Matri
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result (i, j) = pow (a, (int) btmp);
+	  result (i, j) = pow (a, static_cast<int> (btmp));
 	else
 	  result (i, j) = pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
@@ -673,17 +673,17 @@ elem_xpow (const ComplexMatrix& a, doubl
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
-	  result (i, j) = pow (a (i, j), (int) b);
+	  result (i, j) = pow (a (i, j), static_cast<int> (b));
     }
   else
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  result (i, j) = pow (a (i, j), b);
     }
 
@@ -707,17 +707,17 @@ elem_xpow (const ComplexMatrix& a, const
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result (i, j) = pow (a (i, j), (int) btmp);
+	  result (i, j) = pow (a (i, j), static_cast<int> (btmp));
 	else
 	  result (i, j) = pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
