# HG changeset patch
# User Jordi Gutiérrez Hermoso <jordigh@octave.org>
# Date 1331680312 14400
#      Tue Mar 13 19:11:52 2012 -0400
# Branch gui
# Node ID 80e8c03548a4e7074fbf97350b2748c83439722e
# Parent  d738c29a2528f166c7b6ba3e065e9bd440056826
# Parent  6c3441f3146b2f287c59f121fdba4539acc9ac9b
Merge default onto gui

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -54,8 +54,9 @@ 901d466ee55ac902a875ec0ade6f1eccef0841dc
 3666e8e6f96e6899b8306d6ea9614aadf0500d67 release-3-4-2
 b0e70a71647b671ebcfa7a79af1ae6d3c0f52065 release-3-4-3
 3781981be535e80d44c85373b8fdaa60ca5cd097 ss-3-5-90
 ff5588774680d4f54567311fc109c8e351950f1c ss-3-5-91
 a737b3fb9c4d89d3694da6b4e623aeee64b212e1 ss-3-5-92
 72aebe6196414e38ef802469ff6e238f914f04c9 rc-3-6-0-0
 64d9f33313cc8c691974bcd123357e24bccbabdc rc-3-6-0-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3.6.0
+95c43fc8dbe1a07a46fefb3372df5b2309d874fd rc-3-6-1-0
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -65,18 +65,17 @@ EXTRA_DIST = \
   etc/gdbinit \
   run-octave.in
 
 include m4/module.mk
 
 # Subdirectories in which to run `make all'.
 SUBDIRS = libgnu libcruft liboctave src scripts @DOCDIR@ examples test
 
-if AMCOND_BUILD_DOCS
-else
+if ! AMCOND_BUILD_DOCS
 dist-hook:
 	echo "Documentation disabled.  Cannot package distribution!" ; exit 1;
 endif
 
 BUILT_SOURCES = run-octave
 
 noinst_SCRIPTS = run-octave
 
@@ -114,18 +113,20 @@ run-octave: run-octave.in Makefile
 .gdbinit: etc/gdbinit
 	@if [ -f .gdbinit ]; then \
 	  echo "refusing to overwrite .gdbinit with newer version from $<" 1>&2; \
 	else \
 	  echo "Installing .gdbinit from version at $<" ; \
 	  cp $< $@; \
 	fi
 
+if AMCOND_BUILD_DOCS
 AUTHORS BUGS INSTALL.OCTAVE:
 	$(MAKE) -C doc/interpreter ../../$@
+endif
 .PHONY: AUTHORS BUGS INSTALL.OCTAVE
 
 ChangeLog:
 	(cd $(srcdir); hg log --style=build-aux/changelog.tmpl --prune=b0e60ad4ae26 --only-branch=`hg branch`; echo ""; echo "See the files in the directory etc/OLD-ChangeLogs for changes before 2011-04-19") > $@.t
 	mv $@.t $@
 .PHONY: ChangeLog
 
 octetc_DATA = NEWS
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -46,17 +46,17 @@ Summary of important user-visible change
  ** The ARPACK library is no longer distributed with Octave.
     If you need the eigs or svds functions you must provide an
     external ARPACK through a package manager or by compiling it
     yourself.  If a pre-compiled package does not exist for your system,
     you can find the current ARPACK sources at
     http://forge.scilab.org/index.php/p/arpack-ng
 
  ** Many of Octave's binary operators (.*, .^, +, -, ...) now perform
-    automatic broadcasting for array operations that allows you to use
+    automatic broadcasting for array operations which allows you to use
     operator notation instead of calling bsxfun or expanding arrays (and
     unnecessarily wasting memory) with repmat or similar idioms.  For
     example, to scale the columns of a matrix by the elements of a row
     vector, you may now write
 
       rv .* M
 
     In this expression, the number of elements of rv must match the
@@ -79,17 +79,17 @@ Summary of important user-visible change
       atan2
       hypot
       max
       min
       mod
       rem
       xor
 
-    additionally, since the A op= B assginment operators are equivalent
+    additionally, since the A op= B assignment operators are equivalent
     to A = A op B, the following operators are also affected:
 
       +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
 
     See the "Broadcasting" section in the new "Vectorization and Faster
     Code Execution" chapter of the manual for more details.
 
  ** Octave now features a profiler, thanks to the work of Daniel Kraft
@@ -107,18 +107,18 @@ Summary of important user-visible change
     a comma separated list of dimensions or a dimension vector.
 
     Functions have been made Matlab-compatible with regard to special
     cases (probability on boundaries, probabilities for values outside
     distribution, etc.).  This may cause subtle changes to existing
     scripts.
 
     negative binomial function has been extended to real, non-integer
-    inputs.  The discrete_inv fucntion now returns v(1) for 0 instead of
-    NaN.  The nbincdf fucntion has bbeen recoded to use a closed form
+    inputs.  The discrete_inv function now returns v(1) for 0 instead of
+    NaN.  The nbincdf function has been recoded to use a closed form
     solution with betainc.
 
  ** strread, textscan, and textread have been completely revamped.
 
     They now support nearly all Matlab functionality including:
 
       * Matlab-compatible whitespace and delimiter defaults
 
@@ -170,17 +170,17 @@ Summary of important user-visible change
                 Default options are "Qt Qbb Qc Qx" for 4D and higher
 
       voronoi:  No default arguments
 
  ** Date/Time functions updated.  Millisecond support with FFF format
     string now supported.
 
     datestr: Numerical formats 21, 22, 29 changed to match Matlab.
-             Now accepts cellstr inputs.
+             Now accepts cellstr input.
 
  ** The following warning IDs have been removed:
 
       Octave:associativity-change
       Octave:complex-cmp-ops
       Octave:empty-list-elements
       Octave:fortran-indexing
       Octave:precedence-change
@@ -199,17 +199,17 @@ Summary of important user-visible change
       guidata         uipanel        uitoolbar
       guihandles      uipushtool     uiwait
       uicontextmenu   uiresume       waitfor
       uicontrol       uitoggletool
 
     The uiXXX functions above are experimental.
 
     Except for uiwait and uiresume, the uiXXX functions are not
-    supported with the the FLTK+OpenGL graphics toolkit.
+    supported with the FLTK+OpenGL graphics toolkit.
 
     The gnuplot graphics toolkit does not support any of the uiXXX
     functions nor the waitfor function.
 
  ** New keyword parfor (parallel for loop) is now recognized as a valid
     keyword.  Implementation, however, is still mapped to an ordinary
     for loop.
 
@@ -243,16 +243,20 @@ Summary of important user-visible change
     release after 3.6):
 
       cut                is_duplicate_entry
       cor                polyderiv
       corrcoef           shell_cmd 
       __error_text__     studentize
       error_text         sylvester_matrix
 
+ ** The following functions have been modified for Matlab compatibility:
+
+      randperm
+
 Summary of important user-visible changes for version 3.4.3:
 -----------------------------------------------------------
 
  ** Octave 3.4.3 is a bug fixing release.
      
 Summary of important user-visible changes for version 3.4.2:
 -----------------------------------------------------------
 
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -28,17 +28,17 @@ EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT([GNU Octave], [3.7.0+], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
 OCTAVE_API_VERSION_NUMBER="48"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2012-01-15"
+OCTAVE_RELEASE_DATE="2012-02-22"
 OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 AC_REVISION($Revision: 1.603 $)
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -147,28 +147,30 @@ Ross Lippert
 David Livings
 Sebastien Loisel
 Erik de Castro Lopo
 Massimo Lorenzin
 Emil Lucretiu
 Hoxide Ma
 James Macnicol
 Jens-Uwe Mager
+Colin Macdonald
 Rob Mahurin
 Ricardo Marranita
 Orestes Mas
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 Júlio Hoffimann Mendes
 Thorsten Meyer
 Petr Mikulik
+Mike Miller
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
 Hannes Müller
 Victor Munoz
 Iain Murray
 Carmen Navarrete
 Todd Neal
@@ -262,16 +264,17 @@ Georg Thimm
 Duncan Temple Lang
 Kris Thielemans
 Olaf Till
 Christophe Tournery
 Thomas Treichl
 Karsten Trulsen
 Frederick Umminger
 Utkarsh Upadhyay
+Daniel Wagenaar
 Stefan van der Walt
 Peter Van Wieren
 James R. Van Zandt
 Gregory Vanuxem
 Ivana Varekova
 Thomas Walter
 Andreas Weber
 Olaf Weber
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -18,17 +18,17 @@
 
 @node Diagonal and Permutation Matrices 
 @chapter Diagonal and Permutation Matrices
 
 @menu
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
 * Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
-* Example Codes::        Some Examples of Usage
+* Example Code::         Some Examples of Usage
 * Zeros Treatment::      The Differences in Treatment of Zero Elements
 @end menu
 
 @node Basic Usage
 @section Creating and Manipulating Diagonal and Permutation Matrices
 
 A diagonal matrix is defined as a matrix that has zero entries outside the main
 diagonal; that is, 
@@ -407,50 +407,61 @@ calculating the sign of the permutation 
 A permutation matrix can also be returned from the built-in functions
 @dfn{lu} and @dfn{qr}, if a pivoted factorization is requested.
 
 The @dfn{sparse} function will convert a permutation matrix efficiently to a
 sparse matrix.
 The @dfn{find} function will also work efficiently with a permutation matrix,
 making it possible to conveniently obtain the permutation indices.
 
-@node Example Codes
+@node Example Code
 @section Some Examples of Usage
 
 The following can be used to solve a linear system @code{A*x = b}
 using the pivoted LU@tie{}factorization:
 
 @example
 @group
   [L, U, P] = lu (A); ## now L*U = P*A
   x = U \ L \ P*b;
 @end group
 @end example
 
 @noindent
-This is how you normalize columns of a matrix @var{X} to unit norm:
+This is one way to normalize columns of a matrix @var{X} to unit norm:
 
 @example
 @group
   s = norm (X, "columns");
-  X = diag (s) \ X;
+  X /= diag (s);
+@end group
+@end example
+
+@noindent
+The same can also be accomplished with broadcasting
+(@pxref{Broadcasting}):
+
+@example
+@group
+  s = norm (X, "columns");
+  X ./= s;
 @end group
 @end example
 
 @noindent
 The following expression is a way to efficiently calculate the sign of a
 permutation, given by a permutation vector @var{p}.  It will also work
 in earlier versions of Octave, but slowly.
 
 @example
   det (eye (length (p))(p, :))
 @end example
 
 @noindent
-Finally, here's how you solve a linear system @code{A*x = b} 
+Finally, here's how you solve a linear system @code{A*x = b}
 with Tikhonov regularization (ridge regression) using SVD (a skeleton only):
 
 @example
 @group
   m = rows (A); n = columns (A);
   [U, S, V] = svd (A);
   ## determine the regularization factor alpha
   ## alpha = @dots{}
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -24,30 +24,56 @@
 @cindex script files
 
 Complicated Octave programs can often be simplified by defining
 functions.  Functions can be defined directly on the command line during
 interactive Octave sessions, or in external files, and can be called just
 like built-in functions.
 
 @menu
+* Introduction to Function and Script Files::
 * Defining Functions::          
 * Multiple Return Values::      
 * Variable-length Argument Lists::  
 * Ignoring Arguments::  
 * Variable-length Return Lists::  
 * Returning from a Function::   
 * Default Arguments::   
 * Function Files::              
 * Script Files::                
 * Function Handles Inline Functions and Anonymous Functions::
 * Commands::
 * Organization of Functions::   
 @end menu
 
+@node  Introduction to Function and Script Files
+@section  Introduction to Function and Script Files
+
+There are six different things covered in this section.
+@enumerate
+@item
+Typing in a function at the command prompt.
+@item
+Storing a group of commands in a file - called a script file.
+@item
+Storing a function in a file - called a function file.
+@item
+Sub-functions in function files.
+@item
+Multiple functions in one script file.
+@item
+Private functions.
+@end enumerate
+
+Both function files and script files end with an extension of .m, for
+@sc{Matlab} compatibility. If you want more than one independent
+functions in a file, it must be a script file (@pxref{Script Files}),
+and to use these functions you must execute the script file before you
+can use the functions that are in the script file.
+
 @node Defining Functions
 @section Defining Functions
 @cindex @code{function} statement
 @cindex @code{endfunction} statement
 
 In its simplest form, the definition of a function named @var{name}
 looks like this:
 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -768,19 +768,19 @@ min (single (1), 0)
 where the returned value is single precision.
 
 In the case of mixed type indexed assignments, the type is not
 changed.  For example,
 
 @example
 @group
 x = ones (2, 2);
-x (1, 1) = single (2)
-    @result{} x = 2   1
-           1   1
+x(1, 1) = single (2)
+   @result{} x = 2   1
+          1   1
 @end group
 @end example
 
 @noindent
 where @code{x} remains of the double precision type. 
 
 @node Predicates for Numeric Objects
 @section Predicates for Numeric Objects
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -639,17 +639,17 @@ Nonlinear Equations
 * Solvers::
 * Minimizers::          
 
 Diagonal and Permutation Matrices
 
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
 * Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
-* Example Codes::        Some Examples of Usage
+* Example Code::         Some Examples of Usage
 * Zeros Treatment::      The Differences in Treatment of Zero Elements
 
 Basic Usage
 
 * Creating Diagonal Matrices::
 * Creating Permutation Matrices::
 * Explicit and Implicit Conversions::
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -829,25 +829,32 @@ The result of which can be seen in @ref{
 @end float
 @end ifnotinfo
 
 @node Printing and Saving Plots
 @subsection Printing and Saving Plots
 @cindex printing plots
 @cindex saving plots
 
-The @code{print} command allows you to save plots in a variety of
-formats.  For example,
+The @code{print} command allows you to send plots to you printer and
+to save plots in a variety of formats.  For example,
+
+@example
+print -dpsc
+@end example
+
+@noindent
+prints the current figure to a color PostScript printer. And,
 
 @example
 print -deps foo.eps
 @end example
 
 @noindent
-writes the current figure to an encapsulated PostScript file called
+saves the current figure to an encapsulated PostScript file called
 @file{foo.eps}.
 
 @DOCSTRING(print)
 
 @DOCSTRING(saveas)
 
 @DOCSTRING(orient)
 
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -182,24 +182,24 @@ matrix.
 @DOCSTRING(ischar)
 
 To test if an object is a string (i.e., a character vector and not a character
 matrix) you can use the @code{ischar} function in combination with the
 @code{isvector} function as in the following example:
 
 @example
 @group
-ischar(collection)
-     @result{} ans = 1
+ischar (collection)
+     @result{} 1
 
-ischar(collection) && isvector(collection)
-     @result{} ans = 0
+ischar (collection) && isvector (collection)
+     @result{} 0
 
-ischar("my string") && isvector("my string")
-     @result{} ans = 1
+ischar ("my string") && isvector ("my string")
+     @result{} 1
 @end group
 @end example
 
 One relevant question is, what happens when a character matrix is
 created from strings of different length.  The answer is that Octave
 puts blank characters at the end of strings shorter than the longest
 string.  It is possible to use a different character than the
 blank character using the @code{string_fill_char} function.
@@ -238,107 +238,99 @@ purpose concatenation functions can be u
 
 @itemize @bullet
 @item All string concatenation functions except @code{cstrcat}
 convert numerical input into character data by taking the corresponding ASCII
 character for each element, as in the following example:
 
 @example
 @group
-char([98, 97, 110, 97, 110, 97])
-     @result{} ans =
-       banana
+char ([98, 97, 110, 97, 110, 97])
+   @result{} banana
 @end group
 @end example
 
 @item
 @code{char} and @code{strvcat}
 concatenate vertically, while @code{strcat} and @code{cstrcat} concatenate
 horizontally.  For example:
 
 @example
 @group
-char("an apple", "two pears")
-     @result{} ans =
-       an apple
+char ("an apple", "two pears")
+    @result{} an apple
        two pears
 @end group
 
 @group
-strcat("oc", "tave", " is", " good", " for you")
-     @result{} ans =
-       octave is good for you
+strcat ("oc", "tave", " is", " good", " for you")
+     @result{} octave is good for you
 @end group
 @end example
 
 @item @code{char} generates an empty row in the output
 for each empty string in the input.  @code{strvcat}, on the other hand,
 eliminates empty strings.
 
 @example
 @group
-char("orange", "green", "", "red")
-     @result{} ans =
-       orange
+char ("orange", "green", "", "red")
+    @result{} orange
        green 
              
        red   
 @end group
 
 @group
-strvcat("orange", "green", "", "red")
-     @result{} ans =
-       orange
+strvcat ("orange", "green", "", "red")
+    @result{} orange
        green 
        red  
 @end group
 @end example
 
 @item All string concatenation functions except @code{cstrcat} also accept cell
 array data (@pxref{Cell Arrays}).  @code{char} and
 @code{strvcat} convert cell arrays into character arrays, while @code{strcat}
 concatenates within the cells of the cell arrays:
 
 @example
 @group
-char(@{"red", "green", "", "blue"@})
-     @result{} ans =
-       red  
-       green
+char (@{"red", "green", "", "blue"@})
+     @result{} red  
+        green
 
-       blue 
+        blue 
 @end group
 
 @group
-strcat(@{"abc"; "ghi"@}, @{"def"; "jkl"@})
-     @result{} ans =
-       @{
-         [1,1] = abcdef
-         [2,1] = ghijkl
-       @}
+strcat (@{"abc"; "ghi"@}, @{"def"; "jkl"@})
+     @result{}
+        @{
+          [1,1] = abcdef
+          [2,1] = ghijkl
+        @}
 @end group
 @end example
 
 @item @code{strcat} removes trailing white space in the arguments (except
 within cell arrays), while @code{cstrcat} leaves white space untouched.  Both
 kinds of behavior can be useful as can be seen in the examples:
 
 @example
 @group
-strcat(["dir1";"directory2"], ["/";"/"], ["file1";"file2"])
-     @result{} ans =
-       dir1/file1      
-       directory2/file2
+strcat (["dir1";"directory2"], ["/";"/"], ["file1";"file2"])
+     @result{} dir1/file1      
+        directory2/file2
 @end group
 @group
 
-cstrcat(["thirteen apples"; "a banana"], [" 5$";" 1$"])
-     @result{} ans =
-       thirteen apples 5$
-       a banana        1$
+cstrcat (["thirteen apples"; "a banana"], [" 5$";" 1$"])
+      @result{} thirteen apples 5$
+         a banana        1$
 @end group
 @end example
 
 Note that in the above example for @code{cstrcat}, the white space originates
 from the internal representation of the strings in a string array
 (@pxref{Character Arrays}).
 @end itemize
 
@@ -462,17 +454,17 @@ general regular expressions, the followi
 
 Octave supports various kinds of conversions between strings and
 numbers.  As an example, it is possible to convert a string containing
 a hexadecimal number to a floating point number.
 
 @example
 @group
 hex2dec ("FF")
-     @result{} ans = 255
+      @result{} 255
 @end group
 @end example
 
 @DOCSTRING(bin2dec)
 
 @DOCSTRING(dec2bin)
 
 @DOCSTRING(dec2hex)
diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -15,17 +15,20 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
-AM_CPPFLAGS = @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu
+## Search local directories before those specified by the user.
+AM_CPPFLAGS = \
+  -I../libgnu -I$(top_srcdir)/libgnu \
+  @CPPFLAGS@
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 octlib_LTLIBRARIES = libcruft.la
 
 libcruft_la_SOURCES =
 
 libcruft_la_FFLAGS = $(F77_INTEGER_8_FLAG)
diff --git a/libcruft/lapack-xtra/crsf2csf.f b/libcruft/lapack-xtra/crsf2csf.f
--- a/libcruft/lapack-xtra/crsf2csf.f
+++ b/libcruft/lapack-xtra/crsf2csf.f
@@ -20,40 +20,40 @@ c <http://www.gnu.org/licenses/>.
 c
 
        subroutine crsf2csf(n,t,u,c,s)
        integer n
        complex t(n,n),u(n,n)
        real c(n-1),s(n-1)
        real x,y,z
        integer j
+       do j = 1,n-1
+          c(j) = 1
+       end do
        j = 1
        do while (j < n)
 c apply previous rotations to rows
          call crcrot1(j,t(1,j),c,s)
 
          y = t(j+1,j)
          if (y /= 0) then
 c 2x2 block, form Givens rotation [c, i*s; i*s, c]
-           x = t(j,j)
            z = t(j,j+1)
            c(j) = sqrt(z/(z-y))
-           s(j) = sign(sqrt(-y/(z-y)),z)
+           s(j) = sqrt(y/(y-z))
 c apply new rotation to t(j:j+1,j)
            call crcrot1(2,t(j,j),c(j),s(j))
 c apply all rotations to t(1:j+1,j+1)
            call crcrot1(j+1,t(1,j+1),c,s)
 c apply new rotation to columns j,j+1
            call crcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))
 c zero subdiagonal entry, skip next row
            t(j+1,j) = 0
-           c(j+1) = 1
            j = j + 2
          else
-           c(j) = 1
            j = j + 1
          end if
        end do
 
 c apply rotations to last column if needed
        if (j == n) then
          call crcrot1(j,t(1,j),c,s)
        end if
diff --git a/libcruft/lapack-xtra/zrsf2csf.f b/libcruft/lapack-xtra/zrsf2csf.f
--- a/libcruft/lapack-xtra/zrsf2csf.f
+++ b/libcruft/lapack-xtra/zrsf2csf.f
@@ -20,40 +20,40 @@ c <http://www.gnu.org/licenses/>.
 c
 
        subroutine zrsf2csf(n,t,u,c,s)
        integer n
        double complex t(n,n),u(n,n)
        double precision c(n-1),s(n-1)
        double precision x,y,z
        integer j
+       do j = 1,n-1
+          c(j) = 1
+       end do
        j = 1
        do while (j < n)
 c apply previous rotations to rows
          call zrcrot1(j,t(1,j),c,s)
 
          y = t(j+1,j)
          if (y /= 0) then
 c 2x2 block, form Givens rotation [c, i*s; i*s, c]
-           x = t(j,j)
            z = t(j,j+1)
            c(j) = sqrt(z/(z-y))
-           s(j) = sign(sqrt(-y/(z-y)),z)
+           s(j) = sqrt(y/(y-z))
 c apply new rotation to t(j:j+1,j)
            call zrcrot1(2,t(j,j),c(j),s(j))
 c apply all rotations to t(1:j+1,j+1)
            call zrcrot1(j+1,t(1,j+1),c,s)
 c apply new rotation to columns j,j+1
            call zrcrot2(j+1,t(1,j),t(1,j+1),c(j),s(j))
 c zero subdiagonal entry, skip next row
            t(j+1,j) = 0
-           c(j+1) = 1
            j = j + 2
          else
-           c(j) = 1
            j = j + 1
          end if
        end do
 
 c apply rotations to last column if needed
        if (j == n) then
          call zrcrot1(j,t(1,j),c,s)
        end if
diff --git a/libcruft/slatec-fn/atanh.f b/libcruft/slatec-fn/atanh.f
--- a/libcruft/slatec-fn/atanh.f
+++ b/libcruft/slatec-fn/atanh.f
@@ -52,18 +52,24 @@ C***FIRST EXECUTABLE STATEMENT  ATANH
       IF (FIRST) THEN
          NTERMS = INITS (ATNHCS, 15, 0.1*R1MACH(3))
          DXREL = SQRT (R1MACH(4))
          SQEPS = SQRT (3.0*R1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
-      IF (Y .GE. 1.0) CALL XERMSG ('SLATEC', 'ATANH', 'ABS(X) GE 1', 2,
-     +   2)
+      IF (Y .GE. 1.0) THEN
+         IF (Y .GT. 1.0) THEN 
+            ATANH = (X - X) / (X - X)
+         ELSE
+            ATANH = X / 0.0
+         ENDIF
+         RETURN
+      ENDIF
 C
       IF (1.0-Y .LT. DXREL) CALL XERMSG ('SLATEC', 'ATANH',
      +   'ANSWER LT HALF PRECISION BECAUSE ABS(X) TOO NEAR 1', 1, 1)
 C
       ATANH = X
       IF (Y.GT.SQEPS .AND. Y.LE.0.5) ATANH = X*(1.0 + CSEVL (8.*X*X-1.,
      1  ATNHCS, NTERMS))
       IF (Y.GT.0.5) ATANH = 0.5*LOG((1.0+X)/(1.0-X))
diff --git a/libcruft/slatec-fn/datanh.f b/libcruft/slatec-fn/datanh.f
--- a/libcruft/slatec-fn/datanh.f
+++ b/libcruft/slatec-fn/datanh.f
@@ -63,18 +63,24 @@ C***FIRST EXECUTABLE STATEMENT  DATANH
       IF (FIRST) THEN
          NTERMS = INITDS (ATNHCS, 27, 0.1*REAL(D1MACH(3)) )
          DXREL = SQRT(D1MACH(4))
          SQEPS = SQRT(3.0D0*D1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
       Y = ABS(X)
-      IF (Y .GE. 1.D0) CALL XERMSG ('SLATEC', 'DATANH', 'ABS(X) GE 1',
-     +   2, 2)
+      IF (Y .GE. 1.D0) THEN
+         IF (Y .GT. 1.D0) THEN 
+            DATANH = (X - X) / (X - X)
+         ELSE
+            DATANH = X / 0.D0
+         ENDIF
+         RETURN
+      ENDIF
 C
       IF (1.D0-Y .LT. DXREL) CALL XERMSG ('SLATEC', 'DATANH',
      +   'ANSWER LT HALF PRECISION BECAUSE ABS(X) TOO NEAR 1', 1, 1)
 C
       DATANH = X
       IF (Y.GT.SQEPS .AND. Y.LE.0.5D0) DATANH = X*(1.0D0 +
      1  DCSEVL (8.D0*X*X-1.D0, ATNHCS, NTERMS) )
       IF (Y.GT.0.5D0) DATANH = 0.5D0*LOG ((1.0D0+X)/(1.0D0-X))
diff --git a/libcruft/slatec-fn/derfc.f b/libcruft/slatec-fn/derfc.f
--- a/libcruft/slatec-fn/derfc.f
+++ b/libcruft/slatec-fn/derfc.f
@@ -186,16 +186,21 @@ C***FIRST EXECUTABLE STATEMENT  DERFC
 C
          XSML = -SQRT(-LOG(SQRTPI*D1MACH(3)))
          TXMAX = SQRT(-LOG(SQRTPI*D1MACH(1)))
          XMAX = TXMAX - 0.5D0*LOG(TXMAX)/TXMAX - 0.01D0
          SQEPS = SQRT(2.0D0*D1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
+      IF (ISNAN(X)) THEN
+         DERFC = X
+         RETURN
+      ENDIF
+C
       IF (X.GT.XSML) GO TO 20
 C
 C ERFC(X) = 1.0 - ERF(X)  FOR  X .LT. XSML
 C
       DERFC = 2.0D0
       RETURN
 C
  20   IF (X.GT.XMAX) GO TO 40
@@ -214,13 +219,12 @@ C
  30   Y = Y*Y
       IF (Y.LE.4.D0) DERFC = EXP(-Y)/ABS(X) * (0.5D0 + DCSEVL (
      1  (8.D0/Y-5.D0)/3.D0, ERC2CS, NTERC2) )
       IF (Y.GT.4.D0) DERFC = EXP(-Y)/ABS(X) * (0.5D0 + DCSEVL (
      1  8.D0/Y-1.D0, ERFCCS, NTERFC) )
       IF (X.LT.0.D0) DERFC = 2.0D0 - DERFC
       RETURN
 C
- 40   CALL XERMSG ('SLATEC', 'DERFC', 'X SO BIG ERFC UNDERFLOWS', 1, 1)
-      DERFC = 0.D0
+ 40   DERFC = 0.D0
       RETURN
 C
       END
diff --git a/libcruft/slatec-fn/erfc.f b/libcruft/slatec-fn/erfc.f
--- a/libcruft/slatec-fn/erfc.f
+++ b/libcruft/slatec-fn/erfc.f
@@ -116,16 +116,21 @@ C***FIRST EXECUTABLE STATEMENT  ERFC
 C
          XSML = -SQRT (-LOG(SQRTPI*R1MACH(3)))
          TXMAX = SQRT (-LOG(SQRTPI*R1MACH(1)))
          XMAX = TXMAX - 0.5*LOG(TXMAX)/TXMAX - 0.01
          SQEPS = SQRT (2.0*R1MACH(3))
       ENDIF
       FIRST = .FALSE.
 C
+      IF (ISNAN(X)) THEN
+         ERFC = X
+         RETURN
+      ENDIF
+C
       IF (X.GT.XSML) GO TO 20
 C
 C ERFC(X) = 1.0 - ERF(X) FOR X .LT. XSML
 C
       ERFC = 2.
       RETURN
 C
  20   IF (X.GT.XMAX) GO TO 40
@@ -144,13 +149,12 @@ C
  30   Y = Y*Y
       IF (Y.LE.4.) ERFC = EXP(-Y)/ABS(X) * (0.5 + CSEVL ((8./Y-5.)/3.,
      1  ERC2CS, NTERC2) )
       IF (Y.GT.4.) ERFC = EXP(-Y)/ABS(X) * (0.5 + CSEVL (8./Y-1.,
      1  ERFCCS, NTERFC) )
       IF (X.LT.0.) ERFC = 2.0 - ERFC
       RETURN
 C
- 40   CALL XERMSG ('SLATEC', 'ERFC', 'X SO BIG ERFC UNDERFLOWS', 1, 1)
-      ERFC = 0.
+ 40   ERFC = 0.
       RETURN
 C
       END
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -1640,34 +1640,34 @@ Array<T>::hermitian (T (*fcn) (const T&)
 %!shared m7, mt7, m8, mt8, m9, mt9
 %! m7 = reshape (1 : 7*8, 8, 7);
 %! mt7 = [1:8; 9:16; 17:24; 25:32; 33:40; 41:48; 49:56];
 %! m8 = reshape (1 : 8*8, 8, 8);
 %! mt8 = mt8 = [mt7; 57:64];
 %! m9 = reshape (1 : 9*8, 8, 9);
 %! mt9 = [mt8; 65:72];
 
-%!assert(m7', mt7)
-%!assert((1i*m7).', 1i * mt7)
-%!assert((1i*m7)', conj (1i * mt7))
-%!assert(m8', mt8)
-%!assert((1i*m8).', 1i * mt8)
-%!assert((1i*m8)', conj (1i * mt8))
-%!assert(m9', mt9)
-%!assert((1i*m9).', 1i * mt9)
-%!assert((1i*m9)', conj (1i * mt9))
-%!assert([m7, m8; m7, m8]', [mt7, mt7; mt8, mt8])
-%!assert((1i*[m7, m8; m7, m8]).', 1i * [mt7, mt7; mt8, mt8])
-%!assert((1i*[m7, m8; m7, m8])', conj (1i * [mt7, mt7; mt8, mt8]))
-%!assert([m8, m8; m8, m8]', [mt8, mt8; mt8, mt8])
-%!assert((1i*[m8, m8; m8, m8]).', 1i * [mt8, mt8; mt8, mt8])
-%!assert((1i*[m8, m8; m8, m8])', conj (1i * [mt8, mt8; mt8, mt8]))
-%!assert([m9, m8; m9, m8]', [mt9, mt9; mt8, mt8])
-%!assert((1i*[m9, m8; m9, m8]).', 1i * [mt9, mt9; mt8, mt8])
-%!assert((1i*[m9, m8; m9, m8])', conj (1i * [mt9, mt9; mt8, mt8]))
+%!assert (m7', mt7)
+%!assert ((1i*m7).', 1i * mt7)
+%!assert ((1i*m7)', conj (1i * mt7))
+%!assert (m8', mt8)
+%!assert ((1i*m8).', 1i * mt8)
+%!assert ((1i*m8)', conj (1i * mt8))
+%!assert (m9', mt9)
+%!assert ((1i*m9).', 1i * mt9)
+%!assert ((1i*m9)', conj (1i * mt9))
+%!assert ([m7, m8; m7, m8]', [mt7, mt7; mt8, mt8])
+%!assert ((1i*[m7, m8; m7, m8]).', 1i * [mt7, mt7; mt8, mt8])
+%!assert ((1i*[m7, m8; m7, m8])', conj (1i * [mt7, mt7; mt8, mt8]))
+%!assert ([m8, m8; m8, m8]', [mt8, mt8; mt8, mt8])
+%!assert ((1i*[m8, m8; m8, m8]).', 1i * [mt8, mt8; mt8, mt8])
+%!assert ((1i*[m8, m8; m8, m8])', conj (1i * [mt8, mt8; mt8, mt8]))
+%!assert ([m9, m8; m9, m8]', [mt9, mt9; mt8, mt8])
+%!assert ((1i*[m9, m8; m9, m8]).', 1i * [mt9, mt9; mt8, mt8])
+%!assert ((1i*[m9, m8; m9, m8])', conj (1i * [mt9, mt9; mt8, mt8]))
 
 */
 
 template <class T>
 T *
 Array<T>::fortran_vec (void)
 {
   make_unique ();
@@ -2248,16 +2248,17 @@ Array<T>::nth_element (const idx_vector&
     dv.resize (dim+1, 1);
 
   octave_idx_type ns = dv(dim);
 
   octave_idx_type nn = n.length (ns);
 
   dv(dim) = std::min (nn, ns);
   dv.chop_trailing_singletons ();
+  dim = std::min (dv.length (), dim);
 
   Array<T> m (dv);
 
   if (m.numel () == 0)
     return m;
 
   sortmode mode = UNSORTED;
   octave_idx_type lo = 0;
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -341,23 +341,29 @@ operator * (const ComplexMatrix& m, cons
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
-          Complex *y = retval.fortran_vec ();
+          if (nc == 0)
+            retval.fill (0.0);
+          else
+            {
+              Complex *y = retval.fortran_vec ();
 
-          F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0, m.data (), nr,
-                                   a.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
+              F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                       nr, nc, 1.0, m.data (), nr,
+                                       a.data (), 1, 0.0, y, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
         }
+
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
 ComplexColumnVector
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3697,35 +3697,37 @@ ComplexMatrix
 operator * (const Matrix& m, const ComplexMatrix& a)
 {
   if (a.rows () > std::min (m.rows (), a.columns ()) / 10)
     return ComplexMatrix (m * real (a), m * imag (a));
   else
     return ComplexMatrix (m) * a;
 }
 
-/* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
-%!assert([1+i 2+i 3+i] * [ 4+i ; 5+i ; 6+i], 29+21i, 1e-14)
-%!assert([1+i 2+i ; 3+i 4+i ] * [5+i ; 6+i], [15 + 14i ; 37 + 18i], 1e-14)
-%!assert([1+i 2+i ; 3+i 4+i ] * [5+i 6+i ; 7+i 8+i], [17 + 15i 20 + 17i; 41 + 19i 48 + 21i], 1e-14)
-%!assert([1 i]*[i 0]', -i);
-*/
-
-/* Test some simple identities
+/*
+
+## Simple Dot Product, Matrix-Vector, and Matrix-Matrix Unit tests
+%!assert ([1+i 2+i 3+i] * [ 4+i ; 5+i ; 6+i], 29+21i, 1e-14)
+%!assert ([1+i 2+i ; 3+i 4+i ] * [5+i ; 6+i], [15 + 14i ; 37 + 18i], 1e-14)
+%!assert ([1+i 2+i ; 3+i 4+i ] * [5+i 6+i ; 7+i 8+i], [17 + 15i 20 + 17i; 41 + 19i 48 + 21i], 1e-14)
+%!assert ([1 i]*[i 0]', -i);
+
+## Test some simple identities
 %!shared M, cv, rv
-%! M = randn(10,10)+i*rand(10,10);
-%! cv = randn(10,1)+i*rand(10,1);
-%! rv = randn(1,10)+i*rand(1,10);
-%!assert([M*cv,M*cv],M*[cv,cv],1e-14)
-%!assert([M.'*cv,M.'*cv],M.'*[cv,cv],1e-14)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],1e-14)
-%!assert([rv*M;rv*M],[rv;rv]*M,1e-14)
-%!assert([rv*M.';rv*M.'],[rv;rv]*M.',1e-14)
-%!assert([rv*M';rv*M'],[rv;rv]*M',1e-14)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],1e-14)
+%! M = randn (10,10) + i*rand (10,10);
+%! cv = randn (10,1) + i*rand (10,1);
+%! rv = randn (1,10) + i*rand (1,10);
+%!assert ([M*cv,M*cv], M*[cv,cv], 1e-14)
+%!assert ([M.'*cv,M.'*cv], M.'*[cv,cv], 1e-14)
+%!assert ([M'*cv,M'*cv], M'*[cv,cv], 1e-14)
+%!assert ([rv*M;rv*M], [rv;rv]*M, 1e-14)
+%!assert ([rv*M.';rv*M.'], [rv;rv]*M.', 1e-14)
+%!assert ([rv*M';rv*M'], [rv;rv]*M', 1e-14)
+%!assert (2*rv*cv, [rv,rv]*[cv;cv], 1e-14)
+
 */
 
 static inline char
 get_blas_trans_arg (bool trans, bool conj)
 {
   return trans ? (conj ? 'C' : 'T') : 'N';
 }
 
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -15,19 +15,21 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
+## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
-  @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu \
-  -I$(top_srcdir)/libcruft/misc
+  -I../libgnu -I$(top_srcdir)/libgnu \
+  -I$(top_srcdir)/libcruft/misc \
+  @CPPFLAGS@
 
 EXTRA_DIST = \
   config-ops.sh \
   mk-ops.awk \
   mx-op-inc.mk \
   mx-op-src.mk \
   mx-ops \
   smx-op-inc.mk \
@@ -516,17 +518,17 @@ liboctave_la_CPPFLAGS = \
   $(SPARSE_XCPPFLAGS) \
   $(FFTW_XCPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
   $(AM_CPPFLAGS)
 
 # Increment these as needed and according to the rules in the libtool
 # manual:
 liboctave_current = 1
-liboctave_revision = 0
+liboctave_revision = 1
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -1399,17 +1399,21 @@ Sparse<T>::index (const idx_vector& idx,
           mx_inline_sub (nz_new, retval.xridx (), ridx () + li, lb);
           retval.xcidx(1) = nz_new;
         }
       else if (idx.is_permutation (nel) && idx.is_vector ())
         {
           if (idx.is_range () && idx.increment () == -1)
             {
               retval = Sparse<T> (nr, 1, nz);
-              std::reverse_copy (ridx (), ridx () + nz, retval.ridx ());
+
+              for (octave_idx_type j = 0; j < nz; j++)
+                retval.ridx (j) = nr - ridx (nz - j - 1) - 1;
+
+              copy_or_memcpy (2, cidx (), retval.cidx ());
               std::reverse_copy (data (), data () + nz, retval.data ());
             }
           else
             {
               Array<T> tmp = array_value ();
               tmp = tmp.index (idx);
               retval = Sparse<T> (tmp);
             }
@@ -2566,170 +2570,174 @@ Sparse<T>::array_value () const
 
   return retval;
 }
 
 /*
  * Tests
  *
 
-%!function x = set_slice(x, dim, slice, arg)
+%!function x = set_slice (x, dim, slice, arg)
 %!  switch dim
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    otherwise
-%!      error("invalid dim, '%d'", dim);
+%!      error ("invalid dim, '%d'", dim);
 %!  endswitch
-%! endfunction
+%!endfunction
 
-%!function x = set_slice2(x, dim, slice)
+%!function x = set_slice2 (x, dim, slice)
 %!  switch dim
 %!    case 11
-%!      x(slice) = 2 * ones (size(slice));
+%!      x(slice) = 2 * ones (size (slice));
 %!    case 21
-%!      x(slice, :) = 2 * ones (length(slice), columns (x));
+%!      x(slice, :) = 2 * ones (length (slice), columns (x));
 %!    case 22
-%!      x(:, slice) = 2 * ones (rows (x), length(slice));
+%!      x(:, slice) = 2 * ones (rows (x), length (slice));
 %!    otherwise
-%!      error("invalid dim, '%d'", dim);
+%!      error ("invalid dim, '%d'", dim);
 %!  endswitch
-%! endfunction
+%!endfunction
 
-%!function test_sparse_slice(size, dim, slice)
-%!  x = ones(size);
-%!  s = set_slice(sparse(x), dim, slice);
-%!  f = set_slice(x, dim, slice);
+%!function test_sparse_slice (size, dim, slice)
+%!  x = ones (size);
+%!  s = set_slice (sparse (x), dim, slice);
+%!  f = set_slice (x, dim, slice);
 %!  assert (nnz(s), nnz(f));
-%!  assert(full(s), f);
-%!  s = set_slice2(sparse(x), dim, slice);
-%!  f = set_slice2(x, dim, slice);
+%!  assert (full(s), f);
+%!  s = set_slice2 (sparse(x), dim, slice);
+%!  f = set_slice2 (x, dim, slice);
 %!  assert (nnz(s), nnz(f));
-%!  assert(full(s), f);
-%! endfunction
+%!  assert (full(s), f);
+%!endfunction
 
 #### 1d indexing
 
 ## size = [2 0]
-%!test test_sparse_slice([2 0], 11, []);
-%!assert(set_slice(sparse(ones([2 0])), 11, 1), sparse([2 0]'));  # sparse different from full
-%!assert(set_slice(sparse(ones([2 0])), 11, 2), sparse([0 2]'));  # sparse different from full
-%!assert(set_slice(sparse(ones([2 0])), 11, 3), sparse([0 0; 2 0]'));  # sparse different from full
-%!assert(set_slice(sparse(ones([2 0])), 11, 4), sparse([0 0; 0 2]'));  # sparse different from full
+%!test test_sparse_slice ([2 0], 11, []);
+%!assert (set_slice (sparse (ones ([2 0])), 11, 1), sparse ([2 0]'))  # sparse different from full
+%!assert (set_slice (sparse (ones ([2 0])), 11, 2), sparse ([0 2]'))  # sparse different from full
+%!assert (set_slice (sparse (ones ([2 0])), 11, 3), sparse ([0 0; 2 0]'))  # sparse different from full
+%!assert (set_slice (sparse (ones ([2 0])), 11, 4), sparse ([0 0; 0 2]'))  # sparse different from full
 
 ## size = [0 2]
-%!test test_sparse_slice([0 2], 11, []);
-%!assert(set_slice(sparse(ones([0 2])), 11, 1), sparse([2 0]));  # sparse different from full
-%!test test_sparse_slice([0 2], 11, 2);
-%!test test_sparse_slice([0 2], 11, 3);
-%!test test_sparse_slice([0 2], 11, 4);
-%!test test_sparse_slice([0 2], 11, [4, 4]);
+%!test test_sparse_slice ([0 2], 11, []);
+%!assert (set_slice (sparse (ones ([0 2])), 11, 1), sparse ([2 0]))  # sparse different from full
+%!test test_sparse_slice ([0 2], 11, 2);
+%!test test_sparse_slice ([0 2], 11, 3);
+%!test test_sparse_slice ([0 2], 11, 4);
+%!test test_sparse_slice ([0 2], 11, [4, 4]);
 
 ## size = [2 1]
-%!test test_sparse_slice([2 1], 11, []);
-%!test test_sparse_slice([2 1], 11, 1);
-%!test test_sparse_slice([2 1], 11, 2);
-%!test test_sparse_slice([2 1], 11, 3);
-%!test test_sparse_slice([2 1], 11, 4);
-%!test test_sparse_slice([2 1], 11, [4, 4]);
+%!test test_sparse_slice ([2 1], 11, []);
+%!test test_sparse_slice ([2 1], 11, 1);
+%!test test_sparse_slice ([2 1], 11, 2);
+%!test test_sparse_slice ([2 1], 11, 3);
+%!test test_sparse_slice ([2 1], 11, 4);
+%!test test_sparse_slice ([2 1], 11, [4, 4]);
 
 ## size = [1 2]
-%!test test_sparse_slice([1 2], 11, []);
-%!test test_sparse_slice([1 2], 11, 1);
-%!test test_sparse_slice([1 2], 11, 2);
-%!test test_sparse_slice([1 2], 11, 3);
-%!test test_sparse_slice([1 2], 11, 4);
-%!test test_sparse_slice([1 2], 11, [4, 4]);
+%!test test_sparse_slice ([1 2], 11, []);
+%!test test_sparse_slice ([1 2], 11, 1);
+%!test test_sparse_slice ([1 2], 11, 2);
+%!test test_sparse_slice ([1 2], 11, 3);
+%!test test_sparse_slice ([1 2], 11, 4);
+%!test test_sparse_slice ([1 2], 11, [4, 4]);
 
 ## size = [2 2]
-%!test test_sparse_slice([2 2], 11, []);
-%!test test_sparse_slice([2 2], 11, 1);
-%!test test_sparse_slice([2 2], 11, 2);
-%!test test_sparse_slice([2 2], 11, 3);
-%!test test_sparse_slice([2 2], 11, 4);
-%!test test_sparse_slice([2 2], 11, [4, 4]);
+%!test test_sparse_slice ([2 2], 11, []);
+%!test test_sparse_slice ([2 2], 11, 1);
+%!test test_sparse_slice ([2 2], 11, 2);
+%!test test_sparse_slice ([2 2], 11, 3);
+%!test test_sparse_slice ([2 2], 11, 4);
+%!test test_sparse_slice ([2 2], 11, [4, 4]);
 # These 2 errors are the same as in the full case
-%!error id=Octave:invalid-resize set_slice(sparse(ones([2 2])), 11, 5);
-%!error id=Octave:invalid-resize set_slice(sparse(ones([2 2])), 11, 6);
+%!error id=Octave:invalid-resize set_slice (sparse (ones ([2 2])), 11, 5)
+%!error id=Octave:invalid-resize set_slice (sparse (ones ([2 2])), 11, 6)
 
 
 #### 2d indexing
 
 ## size = [2 0]
-%!test test_sparse_slice([2 0], 21, []);
-%!test test_sparse_slice([2 0], 21, 1);
-%!test test_sparse_slice([2 0], 21, 2);
-%!test test_sparse_slice([2 0], 21, [2,2]);
-%!assert(set_slice(sparse(ones([2 0])), 21, 3), sparse(3,0));
-%!assert(set_slice(sparse(ones([2 0])), 21, 4), sparse(4,0));
-%!test test_sparse_slice([2 0], 22, []);
-%!test test_sparse_slice([2 0], 22, 1);
-%!test test_sparse_slice([2 0], 22, 2);
-%!test test_sparse_slice([2 0], 22, [2,2]);
-%!assert(set_slice(sparse(ones([2 0])), 22, 3), sparse([0 0 2;0 0 2]));  # sparse different from full
-%!assert(set_slice(sparse(ones([2 0])), 22, 4), sparse([0 0 0 2;0 0 0 2]));  # sparse different from full
+%!test test_sparse_slice ([2 0], 21, []);
+%!test test_sparse_slice ([2 0], 21, 1);
+%!test test_sparse_slice ([2 0], 21, 2);
+%!test test_sparse_slice ([2 0], 21, [2,2]);
+%!assert (set_slice (sparse (ones ([2 0])), 21, 3), sparse (3,0))
+%!assert (set_slice (sparse (ones ([2 0])), 21, 4), sparse (4,0))
+%!test test_sparse_slice ([2 0], 22, []);
+%!test test_sparse_slice ([2 0], 22, 1);
+%!test test_sparse_slice ([2 0], 22, 2);
+%!test test_sparse_slice ([2 0], 22, [2,2]);
+%!assert (set_slice (sparse (ones ([2 0])), 22, 3), sparse ([0 0 2;0 0 2]))  # sparse different from full
+%!assert (set_slice (sparse (ones ([2 0])), 22, 4), sparse ([0 0 0 2;0 0 0 2]))  # sparse different from full
 
 ## size = [0 2]
-%!test test_sparse_slice([0 2], 21, []);
-%!test test_sparse_slice([0 2], 21, 1);
-%!test test_sparse_slice([0 2], 21, 2);
-%!test test_sparse_slice([0 2], 21, [2,2]);
-%!assert(set_slice(sparse(ones([0 2])), 21, 3), sparse([0 0;0 0;2 2]));  # sparse different from full
-%!assert(set_slice(sparse(ones([0 2])), 21, 4), sparse([0 0;0 0;0 0;2 2]));  # sparse different from full
-%!test test_sparse_slice([0 2], 22, []);
-%!test test_sparse_slice([0 2], 22, 1);
-%!test test_sparse_slice([0 2], 22, 2);
-%!test test_sparse_slice([0 2], 22, [2,2]);
-%!assert(set_slice(sparse(ones([0 2])), 22, 3), sparse(0,3));
-%!assert(set_slice(sparse(ones([0 2])), 22, 4), sparse(0,4));
+%!test test_sparse_slice ([0 2], 21, []);
+%!test test_sparse_slice ([0 2], 21, 1);
+%!test test_sparse_slice ([0 2], 21, 2);
+%!test test_sparse_slice ([0 2], 21, [2,2]);
+%!assert (set_slice (sparse (ones ([0 2])), 21, 3), sparse ([0 0;0 0;2 2]))  # sparse different from full
+%!assert (set_slice (sparse (ones ([0 2])), 21, 4), sparse ([0 0;0 0;0 0;2 2]))  # sparse different from full
+%!test test_sparse_slice ([0 2], 22, []);
+%!test test_sparse_slice ([0 2], 22, 1);
+%!test test_sparse_slice ([0 2], 22, 2);
+%!test test_sparse_slice ([0 2], 22, [2,2]);
+%!assert (set_slice (sparse (ones ([0 2])), 22, 3), sparse (0,3))
+%!assert (set_slice (sparse (ones ([0 2])), 22, 4), sparse (0,4))
 
 ## size = [2 1]
-%!test test_sparse_slice([2 1], 21, []);
-%!test test_sparse_slice([2 1], 21, 1);
-%!test test_sparse_slice([2 1], 21, 2);
-%!test test_sparse_slice([2 1], 21, [2,2]);
-%!test test_sparse_slice([2 1], 21, 3);
-%!test test_sparse_slice([2 1], 21, 4);
-%!test test_sparse_slice([2 1], 22, []);
-%!test test_sparse_slice([2 1], 22, 1);
-%!test test_sparse_slice([2 1], 22, 2);
-%!test test_sparse_slice([2 1], 22, [2,2]);
-%!test test_sparse_slice([2 1], 22, 3);
-%!test test_sparse_slice([2 1], 22, 4);
+%!test test_sparse_slice ([2 1], 21, []);
+%!test test_sparse_slice ([2 1], 21, 1);
+%!test test_sparse_slice ([2 1], 21, 2);
+%!test test_sparse_slice ([2 1], 21, [2,2]);
+%!test test_sparse_slice ([2 1], 21, 3);
+%!test test_sparse_slice ([2 1], 21, 4);
+%!test test_sparse_slice ([2 1], 22, []);
+%!test test_sparse_slice ([2 1], 22, 1);
+%!test test_sparse_slice ([2 1], 22, 2);
+%!test test_sparse_slice ([2 1], 22, [2,2]);
+%!test test_sparse_slice ([2 1], 22, 3);
+%!test test_sparse_slice ([2 1], 22, 4);
 
 ## size = [1 2]
-%!test test_sparse_slice([1 2], 21, []);
-%!test test_sparse_slice([1 2], 21, 1);
-%!test test_sparse_slice([1 2], 21, 2);
-%!test test_sparse_slice([1 2], 21, [2,2]);
-%!test test_sparse_slice([1 2], 21, 3);
-%!test test_sparse_slice([1 2], 21, 4);
-%!test test_sparse_slice([1 2], 22, []);
-%!test test_sparse_slice([1 2], 22, 1);
-%!test test_sparse_slice([1 2], 22, 2);
-%!test test_sparse_slice([1 2], 22, [2,2]);
-%!test test_sparse_slice([1 2], 22, 3);
-%!test test_sparse_slice([1 2], 22, 4);
+%!test test_sparse_slice ([1 2], 21, []);
+%!test test_sparse_slice ([1 2], 21, 1);
+%!test test_sparse_slice ([1 2], 21, 2);
+%!test test_sparse_slice ([1 2], 21, [2,2]);
+%!test test_sparse_slice ([1 2], 21, 3);
+%!test test_sparse_slice ([1 2], 21, 4);
+%!test test_sparse_slice ([1 2], 22, []);
+%!test test_sparse_slice ([1 2], 22, 1);
+%!test test_sparse_slice ([1 2], 22, 2);
+%!test test_sparse_slice ([1 2], 22, [2,2]);
+%!test test_sparse_slice ([1 2], 22, 3);
+%!test test_sparse_slice ([1 2], 22, 4);
 
 ## size = [2 2]
-%!test test_sparse_slice([2 2], 21, []);
-%!test test_sparse_slice([2 2], 21, 1);
-%!test test_sparse_slice([2 2], 21, 2);
-%!test test_sparse_slice([2 2], 21, [2,2]);
-%!test test_sparse_slice([2 2], 21, 3);
-%!test test_sparse_slice([2 2], 21, 4);
-%!test test_sparse_slice([2 2], 22, []);
-%!test test_sparse_slice([2 2], 22, 1);
-%!test test_sparse_slice([2 2], 22, 2);
-%!test test_sparse_slice([2 2], 22, [2,2]);
-%!test test_sparse_slice([2 2], 22, 3);
-%!test test_sparse_slice([2 2], 22, 4);
+%!test test_sparse_slice ([2 2], 21, []);
+%!test test_sparse_slice ([2 2], 21, 1);
+%!test test_sparse_slice ([2 2], 21, 2);
+%!test test_sparse_slice ([2 2], 21, [2,2]);
+%!test test_sparse_slice ([2 2], 21, 3);
+%!test test_sparse_slice ([2 2], 21, 4);
+%!test test_sparse_slice ([2 2], 22, []);
+%!test test_sparse_slice ([2 2], 22, 1);
+%!test test_sparse_slice ([2 2], 22, 2);
+%!test test_sparse_slice ([2 2], 22, [2,2]);
+%!test test_sparse_slice ([2 2], 22, 3);
+%!test test_sparse_slice ([2 2], 22, 4);
+
+bug #35570:
+
+%!assert (speye (3,1)(3:-1:1), sparse ([0; 0; 1]))
 
 */
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << "\n"
diff --git a/liboctave/config-ops.sh b/liboctave/config-ops.sh
--- a/liboctave/config-ops.sh
+++ b/liboctave/config-ops.sh
@@ -29,77 +29,77 @@ liboctave_dir="$top_srcdir/liboctave"
 mk_ops="$liboctave_dir/mk-ops.awk"
 sparse_mk_ops="$liboctave_dir/sparse-mk-ops.awk"
 
 case "$obj_type" in
   vx | all)
     case "$src_type" in
       inc | all)
         VX_INC=$($AWK -f $mk_ops prefix=vx list_h_files=1 $liboctave_dir/vx-ops)
-        echo "VX_OP_INC = $(echo $VX_INC)" > $liboctave_dir/vx-op-inc.mk-t
+        echo "VX_OP_INC = $VX_INC" > $liboctave_dir/vx-op-inc.mk-t
         $move_if_change $liboctave_dir/vx-op-inc.mk-t $liboctave_dir/vx-op-inc.mk
       ;;
     esac
   ;;
 esac
 
 case "$obj_type" in
   vx | all)
     case "$src_type" in
       src | all)
         VX_SRC=$($AWK -f $mk_ops prefix=vx list_cc_files=1 $liboctave_dir/vx-ops)
-        echo "VX_OP_SRC = $(echo $VX_SRC)" > $liboctave_dir/vx-op-src.mk-t
+        echo "VX_OP_SRC = $VX_SRC" > $liboctave_dir/vx-op-src.mk-t
         $move_if_change $liboctave_dir/vx-op-src.mk-t $liboctave_dir/vx-op-src.mk
       ;;
     esac
   ;;
 esac
 
 case "$obj_type" in
   mx | all)
     case "$src_type" in
       inc | all)
         MX_INC=$($AWK -f $mk_ops prefix=mx list_h_files=1 $liboctave_dir/mx-ops)
-        echo "MX_OP_INC = $(echo $MX_INC)" > $liboctave_dir/mx-op-inc.mk-t
+        echo "MX_OP_INC = $MX_INC" > $liboctave_dir/mx-op-inc.mk-t
         $move_if_change $liboctave_dir/mx-op-inc.mk-t $liboctave_dir/mx-op-inc.mk
       ;;
     esac
   ;;
 esac
 
 case "$obj_type" in
   mx | all)
     case "$src_type" in
       src | all)
         MX_SRC=$($AWK -f $mk_ops prefix=mx list_cc_files=1 $liboctave_dir/mx-ops)
-        echo "MX_OP_SRC = $(echo $MX_SRC)" > $liboctave_dir/mx-op-src.mk-t
+        echo "MX_OP_SRC = $MX_SRC" > $liboctave_dir/mx-op-src.mk-t
         $move_if_change $liboctave_dir/mx-op-src.mk-t $liboctave_dir/mx-op-src.mk
       ;;
     esac
   ;;
 esac
 
 case "$obj_type" in
   smx | all)
     case "$src_type" in
       inc | all)
         SMX_INC=$($AWK -f $sparse_mk_ops prefix=smx list_h_files=1 $liboctave_dir/sparse-mx-ops)
-        echo "SMX_OP_INC = $(echo $SMX_INC)" > $liboctave_dir/smx-op-inc.mk-t
+        echo "SMX_OP_INC = $SMX_INC" > $liboctave_dir/smx-op-inc.mk-t
         $move_if_change $liboctave_dir/smx-op-inc.mk-t $liboctave_dir/smx-op-inc.mk
       ;;
     esac
   ;;
 esac
 
 case "$obj_type" in
   smx | all)
     case "$src_type" in
       src | all)
         SMX_SRC=$($AWK -f $sparse_mk_ops prefix=smx list_cc_files=1 $liboctave_dir/sparse-mx-ops)
-        echo "SMX_OP_SRC = $(echo $SMX_SRC)" > $liboctave_dir/smx-op-src.mk-t
+        echo "SMX_OP_SRC = $SMX_SRC" > $liboctave_dir/smx-op-src.mk-t
         $move_if_change $liboctave_dir/smx-op-src.mk-t $liboctave_dir/smx-op-src.mk
       ;;
     esac
   ;;
 esac
 
 
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -207,22 +207,27 @@ operator * (const Matrix& m, const Colum
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
-          double *y = retval.fortran_vec ();
+          if (nc == 0)
+            retval.fill (0.0);
+          else
+            {
+              double *y = retval.fortran_vec ();
 
-          F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0, m.data (), nr,
-                                   a.data (), 1, 0.0, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
+              F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                       nr, nc, 1.0, m.data (), nr,
+                                       a.data (), 1, 0.0, y, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
         }
     }
 
   return retval;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3108,36 +3108,38 @@ Sylvester (const Matrix& a, const Matrix
 
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
-/* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
-%!assert([1 2 3] * [ 4 ; 5 ; 6], 32, 1e-14)
-%!assert([1 2 ; 3 4 ] * [5 ; 6], [17 ; 39 ], 1e-14)
-%!assert([1 2 ; 3 4 ] * [5 6 ; 7 8], [19 22; 43 50], 1e-14)
-*/
-
-/* Test some simple identities
+/*
+
+## Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
+%!assert ([1 2 3] * [ 4 ; 5 ; 6], 32, 1e-14)
+%!assert ([1 2 ; 3 4 ] * [5 ; 6], [17 ; 39 ], 1e-14)
+%!assert ([1 2 ; 3 4 ] * [5 6 ; 7 8], [19 22; 43 50], 1e-14)
+
+## Test some simple identities
 %!shared M, cv, rv, Mt, rvt
-%! M = randn(10,10)+100*eye(10,10);
+%! M = randn (10,10) + 100*eye (10,10);
 %! Mt = M';
-%! cv = randn(10,1);
-%! rv = randn(1,10);
+%! cv = randn (10,1);
+%! rv = randn (1,10);
 %! rvt = rv';
-%!assert([M*cv,M*cv],M*[cv,cv],1e-13)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],1e-13)
-%!assert([rv*M;rv*M],[rv;rv]*M,1e-13)
-%!assert([rv*M';rv*M'],[rv;rv]*M',1e-13)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],1e-13)
-%!assert(M'\cv,Mt\cv,1e-14)
-%!assert(M'\rv',Mt\rvt,1e-14)
+%!assert ([M*cv,M*cv], M*[cv,cv], 1e-13)
+%!assert ([M'*cv,M'*cv], M'*[cv,cv], 1e-13)
+%!assert ([rv*M;rv*M], [rv;rv]*M, 1e-13)
+%!assert ([rv*M';rv*M'], [rv;rv]*M', 1e-13)
+%!assert (2*rv*cv, [rv,rv]*[cv;cv], 1e-13)
+%!assert (M'\cv, Mt\cv, 1e-14)
+%!assert (M'\rv', Mt\rvt, 1e-14)
+
 */
 
 static inline char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
 }
 
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -124,20 +124,20 @@ private:
     assert (count () == 0);
     delete [] (rep - 2);
   }
 
   void make_unique (void)
   {
     if (count () > 1)
       {
-	octave_idx_type *new_rep = clonerep ();
+        octave_idx_type *new_rep = clonerep ();
 
-	if (OCTREFCOUNT_ATOMIC_DECREMENT(&(count())) == 0)
-	  freerep ();
+        if (OCTREFCOUNT_ATOMIC_DECREMENT(&(count())) == 0)
+          freerep ();
 
         rep = new_rep;
       }
   }
 
 public:
 
   // The constructor
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -341,22 +341,27 @@ operator * (const FloatComplexMatrix& m,
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
-          FloatComplex *y = retval.fortran_vec ();
+          if (nc == 0)
+            retval.fill (0.0);
+          else
+            {
+              FloatComplex *y = retval.fortran_vec ();
 
-          F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0f, m.data (), nr,
-                                   a.data (), 1, 0.0f, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
+              F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                       nr, nc, 1.0f, m.data (), nr,
+                                       a.data (), 1, 0.0f, y, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
         }
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -3693,35 +3693,37 @@ FloatComplexMatrix
 operator * (const FloatMatrix& m, const FloatComplexMatrix& a)
 {
   if (a.rows () > std::min (m.rows (), a.columns ()) / 10)
     return FloatComplexMatrix (m * real (a), m * imag (a));
   else
     return m * FloatComplexMatrix (a);
 }
 
-/* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
-%!assert(single([1+i 2+i 3+i]) * single([ 4+i ; 5+i ; 6+i]), single(29+21i), 5e-7)
-%!assert(single([1+i 2+i ; 3+i 4+i ]) * single([5+i ; 6+i]), single([15 + 14i ; 37 + 18i]), 5e-7)
-%!assert(single([1+i 2+i ; 3+i 4+i ]) * single([5+i 6+i ; 7+i 8+i]), single([17 + 15i 20 + 17i; 41 + 19i 48 + 21i]), 5e-7)
-%!assert(single([1 i])*single([i 0])', single(-i));
-*/
-
-/* Test some simple identities
+/*
+
+## Simple Dot Product, Matrix-Vector, and Matrix-Matrix Unit tests
+%!assert (single ([1+i 2+i 3+i]) * single ([ 4+i ; 5+i ; 6+i]), single (29+21i), 5e-7)
+%!assert (single ([1+i 2+i ; 3+i 4+i]) * single ([5+i ; 6+i]), single ([15 + 14i ; 37 + 18i]), 5e-7)
+%!assert (single ([1+i 2+i ; 3+i 4+i ]) * single ([5+i 6+i ; 7+i 8+i]), single ([17 + 15i 20 + 17i; 41 + 19i 48 + 21i]), 5e-7)
+%!assert (single ([1 i])*single ([i 0])', single (-i))
+
+## Test some simple identities
 %!shared M, cv, rv
-%! M = single(randn(10,10))+i*single(rand(10,10));
-%! cv = single(randn(10,1))+i*single(rand(10,1));
-%! rv = single(randn(1,10))+i*single(rand(1,10));
-%!assert([M*cv,M*cv],M*[cv,cv],5e-6)
-%!assert([M.'*cv,M.'*cv],M.'*[cv,cv],5e-6)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],5e-6)
-%!assert([rv*M;rv*M],[rv;rv]*M,5e-6)
-%!assert([rv*M.';rv*M.'],[rv;rv]*M.',5e-6)
-%!assert([rv*M';rv*M'],[rv;rv]*M',5e-6)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],5e-6)
+%! M = single (randn (10,10))+ i*single (rand (10,10));
+%! cv = single (randn (10,1))+ i*single (rand (10,1));
+%! rv = single (randn (1,10))+ i*single (rand (1,10));
+%!assert ([M*cv,M*cv], M*[cv,cv], 5e-6)
+%!assert ([M.'*cv,M.'*cv], M.'*[cv,cv], 5e-6)
+%!assert ([M'*cv,M'*cv], M'*[cv,cv], 5e-6)
+%!assert ([rv*M;rv*M], [rv;rv]*M, 5e-6)
+%!assert ([rv*M.';rv*M.'], [rv;rv]*M.', 5e-6)
+%!assert ([rv*M';rv*M'], [rv;rv]*M', 5e-6)
+%!assert (2*rv*cv, [rv,rv]*[cv;cv], 5e-6)
+
 */
 
 static char
 get_blas_trans_arg (bool trans, bool conj)
 {
   return trans ? (conj ? 'C' : 'T') : 'N';
 }
 
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -206,22 +206,27 @@ operator * (const FloatMatrix& m, const 
   if (nc != a_len)
     gripe_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
-          float *y = retval.fortran_vec ();
+          if (nc == 0)
+            retval.fill (0.0);
+          else
+            {
+              float *y = retval.fortran_vec ();
 
-          F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0f, m.data (), nr,
-                                   a.data (), 1, 0.0f, y, 1
-                                   F77_CHAR_ARG_LEN (1)));
+              F77_XFCN (sgemv, SGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
+                                       nr, nc, 1.0f, m.data (), nr,
+                                       a.data (), 1, 0.0f, y, 1
+                                       F77_CHAR_ARG_LEN (1)));
+            }
         }
     }
 
   return retval;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -3108,32 +3108,33 @@ Sylvester (const FloatMatrix& a, const F
 
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
-/* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
-%!assert(single([1 2 3]) * single([ 4 ; 5 ; 6]), single(32), 5e-7)
-%!assert(single([1 2 ; 3 4 ]) * single([5 ; 6]), single([17 ; 39 ]), 5e-7)
-%!assert(single([1 2 ; 3 4 ]) * single([5 6 ; 7 8]), single([19 22; 43 50]), 5e-7)
-*/
-
-/* Test some simple identities
+/*
+## Simple Dot Product, Matrix-Vector, and Matrix-Matrix Unit tests
+%!assert (single ([1 2 3]) * single ([ 4 ; 5 ; 6]), single (32), 5e-7)
+%!assert (single ([1 2 ; 3 4]) * single ([5 ; 6]), single ([17 ; 39]), 5e-7)
+%!assert (single ([1 2 ; 3 4]) * single ([5 6 ; 7 8]), single ([19 22; 43 50]), 5e-7)
+
+## Test some simple identities
 %!shared M, cv, rv
-%! M = single(randn(10,10));
-%! cv = single(randn(10,1));
-%! rv = single(randn(1,10));
-%!assert([M*cv,M*cv],M*[cv,cv],5e-6)
-%!assert([M'*cv,M'*cv],M'*[cv,cv],5e-6)
-%!assert([rv*M;rv*M],[rv;rv]*M,5e-6)
-%!assert([rv*M';rv*M'],[rv;rv]*M',5e-6)
-%!assert(2*rv*cv,[rv,rv]*[cv;cv],5e-6)
+%! M = single (randn (10,10));
+%! cv = single (randn (10,1));
+%! rv = single (randn (1,10));
+%!assert ([M*cv,M*cv], M*[cv,cv], 5e-6)
+%!assert ([M'*cv,M'*cv], M'*[cv,cv], 5e-6)
+%!assert ([rv*M;rv*M], [rv;rv]*M, 5e-6)
+%!assert ([rv*M';rv*M'], [rv;rv]*M', 5e-6)
+%!assert (2*rv*cv, [rv,rv]*[cv;cv], 5e-6)
+
 */
 
 static char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
 }
 
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -88,23 +88,23 @@ BEGIN {
           while (NF > n)
             bool_headers[k++] = $(++n);
 
           cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
           h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
           if (list_cc_files)
             {
-              print cc_file;
+              printf (" %s", cc_file);
               next;
             }
 
           if (list_h_files)
             {
-              print h_file;
+              printf (" %s", h_file);
               next;
             }
 
           if (make_inclusive_header)
             {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -625,29 +625,28 @@ INSTANTIATE_INTTYPE (int32_t);
 INSTANTIATE_INTTYPE (int64_t);
 
 INSTANTIATE_INTTYPE (uint8_t);
 INSTANTIATE_INTTYPE (uint16_t);
 INSTANTIATE_INTTYPE (uint32_t);
 INSTANTIATE_INTTYPE (uint64_t);
 
 
-// Tests follow.
-
 /*
 
-%!assert(intmax("int64")/intmin("int64"),int64(-1))
-%!assert(intmin("int64")/int64(-1),intmax("int64"))
-%!assert(int64(2**63),intmax("int64"))
-%!assert(uint64(2**64),intmax("uint64"))
+%!assert (intmax ("int64") / intmin ("int64"), int64 (-1))
+%!assert (intmin ("int64") / int64 (-1), intmax ("int64"))
+%!assert (int64 (2**63), intmax ("int64"))
+%!assert (uint64 (2**64), intmax ("uint64"))
 %!test
-%! a = 1.9*2^61; b = uint64(a); b++; assert(b > a)
+%! a = 1.9*2^61; b = uint64 (a); b++; assert (b > a);
 %!test
-%! a = -1.9*2^61; b = int64(a); b++; assert(b > a)
+%! a = -1.9*2^61; b = int64 (a); b++; assert (b > a);
 %!test
-%! a = int64(-2**60) + 2; assert(1.25*a == (5*a)/4)
+%! a = int64 (-2**60) + 2; assert (1.25*a == (5*a)/4);
 %!test
-%! a = uint64(2**61) + 2; assert(1.25*a == (5*a)/4)
-%!assert(int32(2**31+0.5),intmax('int32'))
-%!assert(int32(-2**31-0.5),intmin('int32'))
-%!assert((int64(2**62)+1)**1, int64(2**62)+1)
-%!assert((int64(2**30)+1)**2, int64(2**60+2**31) + 1)
+%! a = uint64 (2**61) + 2; assert (1.25*a == (5*a)/4);
+%!assert (int32 (2**31+0.5), intmax ("int32"))
+%!assert (int32 (-2**31-0.5), intmin ("int32"))
+%!assert ((int64 (2**62)+1)**1, int64 (2**62)+1)
+%!assert ((int64 (2**30)+1)**2, int64 (2**60+2**31) + 1)
+
 */
diff --git a/liboctave/regexp.cc b/liboctave/regexp.cc
--- a/liboctave/regexp.cc
+++ b/liboctave/regexp.cc
@@ -328,18 +328,17 @@ regexp::match (const std::string& buffer
         {
           int pos_match = 0;
           Matrix token_extents (matches-1, 2);
 
           for (int i = 1; i < matches; i++)
             {
               if (ovector[2*i] >= 0 && ovector[2*i+1] > 0
                   && (i == 1 || ovector[2*i] != ovector[2*i-2]
-                      || ovector[2*i-1] != ovector[2*i+1])
-                  && ovector[2*i] >= 0 && ovector[2*i+1] > 0)
+                      || ovector[2*i-1] != ovector[2*i+1]))
                 {
                   token_extents(pos_match,0) = double (ovector[2*i]+1);
                   token_extents(pos_match++,1) = double (ovector[2*i+1]);
                 }
             }
 
           token_extents.resize (pos_match, 2);
 
@@ -366,18 +365,31 @@ regexp::match (const std::string& buffer
           for (int i = 1; i < matches; i++)
             {
               if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
                 {
                   if (i == 1 || ovector[2*i] != ovector[2*i-2]
                       || ovector[2*i-1] != ovector[2*i+1])
                     {
                       if (namecount > 0)
-                        named_tokens(named_idx(i-pos_offset-1)) =
-                          std::string (*(listptr+nidx[i-pos_offset-1]));
+                        {
+                          // FIXME: Should probably do this with a map()
+                          // rather than a linear search.  However,
+                          // the number of captured, named expressions
+                          // is usually pretty small (< 4)
+                          for (int j = 0; j < namecount; j++)
+                            {
+                              if (nidx[j] == i)
+                                { 
+                                  named_tokens(named_idx(j)) =
+                                    std::string (*(listptr+i-pos_offset));
+                                  break;
+                                }
+                            }
+                        }
 
                       tokens(pos_match++) = std::string (*(listptr+i));
                     }
                   else
                     pos_offset++;
                 }
             }
 
diff --git a/liboctave/regexp.h b/liboctave/regexp.h
--- a/liboctave/regexp.h
+++ b/liboctave/regexp.h
@@ -84,17 +84,17 @@ public:
 
   bool is_match (const std::string& buffer);
 
   Array<bool> is_match (const string_vector& buffer);
 
   std::string replace (const std::string& buffer,
                        const std::string& replacement);
 
-  struct opts
+  class opts
   {
   public:
 
     opts (void)
       : x_case_insensitive (false), x_dotexceptnewline (false),
         x_freespacing (false), x_lineanchors (false), x_once (false) { }
 
     opts (const opts& o)
diff --git a/liboctave/sparse-mk-ops.awk b/liboctave/sparse-mk-ops.awk
--- a/liboctave/sparse-mk-ops.awk
+++ b/liboctave/sparse-mk-ops.awk
@@ -87,23 +87,23 @@ BEGIN {
           while (NF > n)
             bool_headers[k++] = $(++n);
 
           cc_file = sprintf ("%s-%s-%s.cc", prefix, lhs_tag, rhs_tag);
           h_file = sprintf ("%s-%s-%s.h", prefix, lhs_tag, rhs_tag);
 
           if (list_cc_files)
             {
-              print cc_file;
+              printf (" %s", cc_file);
               next;
             }
 
           if (list_h_files)
             {
-              print h_file;
+              printf (" %s", h_file);
               next;
             }
 
           if (make_inclusive_header)
             {
               printf ("#include \"%s\"\n", h_file);
               next;
             }
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -473,33 +473,33 @@ AC_DEFUN([OCTAVE_PROG_FLEX], [
   AC_PROG_LEX
   case "$LEX" in
     flex*)
       LFLAGS="-I"
       AC_MSG_RESULT([defining LFLAGS to be $LFLAGS])
       LEXLIB=
     ;;
     *)
-      LEX='$(top_srcdir)/missing flex'
+      LEX='$(top_srcdir)/build-aux/missing flex'
       warn_flex="I didn't find flex, but it's only a problem if you need to reconstruct lex.cc"
       AC_MSG_WARN([$warn_flex])
     ;;
   esac
   AC_SUBST(LFLAGS)
 ])
 dnl
 dnl Check for bison
 dnl
 AC_DEFUN([OCTAVE_PROG_BISON], [
   AC_PROG_YACC
   case "$YACC" in
     bison*)
     ;;
     *)
-      YACC='$(top_srcdir)/missing bison'
+      YACC='$(top_srcdir)/build-aux/missing bison'
       warn_bison="I didn't find bison, but it's only a problem if you need to reconstruct parse.cc"
       AC_MSG_WARN([$warn_bison])
     ;;
   esac
 ])
 dnl
 dnl What pager should we use?
 dnl
@@ -548,17 +548,17 @@ AC_SUBST(GNUPLOT)
 ])
 dnl
 dnl Is gperf installed?
 dnl
 dnl OCTAVE_PROG_GPERF
 AC_DEFUN([OCTAVE_PROG_GPERF], [
   AC_CHECK_PROG(GPERF, gperf, gperf, [])
   if test -z "$GPERF"; then
-    GPERF='$(top_srcdir)/missing gperf'
+    GPERF='$(top_srcdir)/build-aux/missing gperf'
     warn_gperf="I didn't find gperf, but it's only a problem if you need to reconstruct oct-gperf.h"
     AC_MSG_WARN([$warn_gperf])
   fi
   AC_SUBST(GPERF)
 ])
 dnl
 dnl Is ghostscript installed?
 dnl
@@ -569,30 +569,30 @@ AC_DEFUN([OCTAVE_PROG_GHOSTSCRIPT], [
       gs_names="gswin32c gs mgs"
     ;;
     *)
       gs_names="gs"
     ;;
   esac
   AC_CHECK_PROGS(GHOSTSCRIPT, [$gs_names])
   if test -z "$GHOSTSCRIPT"; then
-    GHOSTSCRIPT='$(top_srcdir)/missing gs'
+    GHOSTSCRIPT='$(top_srcdir)/build-aux/missing gs'
     warn_ghostscript="I didn't find ghostscript, so reconstructing figures for the manual will fail, and saving graphics in some output formats will fail when using Octave"
     AC_MSG_WARN([$warn_ghostscript])
   fi
   AC_SUBST(GHOSTSCRIPT)
 ])
 dnl
 dnl Is texi2dvi installed?
 dnl
 dnl OCTAVE_PROG_TEXI2DVI
 AC_DEFUN([OCTAVE_PROG_TEXI2DVI], [
   AC_CHECK_PROG(TEXI2DVI, texi2dvi, texi2dvi, [])
   if test -z "$TEXI2DVI"; then
-    TEXI2DVI='$(top_srcdir)/missing texi2dvi'
+    TEXI2DVI='$(top_srcdir)/build-aux/missing texi2dvi'
     warn_texi2dvi="I didn't find texi2dvi, but it's only a problem if you need to reconstruct the DVI version of the manual"
     AC_MSG_WARN([$warn_texi2dvi])
   fi
   AC_SUBST(TEXI2DVI)
 ])
 dnl
 dnl Is texi2pdf installed?
 dnl
@@ -605,17 +605,17 @@ AC_DEFUN([OCTAVE_PROG_TEXI2PDF], [
     if test -n "$TEXI2DVI"; then
       TEXI2PDF="$TEXI2DVI --pdf"
       missing=false;
     fi
   else
     missing=false;
   fi
   if $missing; then
-    TEXI2PDF='$(top_srcdir)/missing texi2pdf'
+    TEXI2PDF='$(top_srcdir)/build-aux/missing texi2pdf'
     warn_texi2pdf="I didn't find texi2pdf, but it's only a problem if you need to reconstruct the PDF version of the manual"
     AC_MSG_WARN([$warn_texi2pdf])
   fi
   AC_SUBST(TEXI2PDF)
 ])
 dnl
 dnl See if the C++ library is ISO compliant.
 dnl FIXME: This is obviously very simplistic, and trivially fooled.
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -69,17 +69,21 @@ include testfun/module.mk
 include time/module.mk
 
 nobase_fcnfile_DATA = $(FCN_FILES) $(GEN_FCN_FILES)
 
 image_DATA = $(IMAGES)
 
 FCN_FILES_IN = $(GEN_FCN_FILES:.m=.in)
 
+if AMCOND_BUILD_DOCS
 all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES) .DOCSTRINGS
+else
+all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES)
+endif
 
 octave_dirstamp = $(am__leading_dot)dirstamp
 
 @ftp/PKG_ADD: $(@ftp_FCN_FILES) $(@ftp_GEN_FCN_FILES) @ftp/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(@ftp_FCN_FILES) -- $(@ftp_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 audio/PKG_ADD: $(audio_FCN_FILES) $(audio_GEN_FCN_FILES) audio/$(octave_dirstamp) mk-pkg-add
@@ -315,31 +319,33 @@ strings/$(octave_dirstamp):
 	: > strings/$(octave_dirstamp)
 testfun/$(octave_dirstamp):
 	$(MKDIR_P) testfun
 	: > testfun/$(octave_dirstamp)
 time/$(octave_dirstamp):
 	$(MKDIR_P) time
 	: > time/$(octave_dirstamp)
 
+if AMCOND_BUILD_DOCS
 ## Program compiled only to help build documentation.  No installation needed.
 noinst_PROGRAMS = gethelp
 
 gethelp_SOURCES = gethelp.cc
 
 .DOCSTRINGS: $(FCN_FILES) $(GEN_FCN_FILES) mkdoc $(gethelp_SOURCES) Makefile
 	@$(MAKE) $(AM_MAKEFLAGS) gethelp$(BUILD_EXEEXT)
 	if [ "x$(srcdir)" != "x." ] && [ -f $(srcdir)/DOCSTRINGS ] && [ ! -f DOCSTRINGS ]; then \
 		cp $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 		touch -r $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 	fi
 	@echo "creating .DOCSTRINGS from .m script files"
 	@$(srcdir)/mkdoc "$(srcdir)" $(FCN_FILES) -- $(GEN_FCN_FILES) > $@
 	$(top_srcdir)/build-aux/move-if-change $@ DOCSTRINGS
 	touch $@
+endif
 
 $(GEN_FCN_FILES) : %.m : %.in Makefile
 	@$(do_subst_config_vals)
 
 check-m-sources:
 	@echo "checking whether files in source tree are listed in module.mk files..."; \
 	for f in $$(find $(srcdir) -name '*.m'); do \
 	  found=false; \
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -27,17 +27,17 @@
 ##      @result{} "123"
 ##
 ## s = int2str ([1, 2, 3; 4, 5, 6])
 ##      @result{} s =
 ##         1  2  3
 ##         4  5  6
 ##
 ## whos s
-##      @result{} s =
+##      @result{}
 ##       Attr Name        Size                     Bytes  Class
 ##       ==== ====        ====                     =====  =====
 ##            s           2x7                         14  char
 ## @end group
 ## @end example
 ##
 ## This function is not very flexible.  For better control over the
 ## results, use @code{sprintf} (@pxref{Formatted Output}).
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -41,34 +41,34 @@ function y = prepad (x, l, c, dim)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin < 3 || isempty (c))
     c = 0;
   else
     if (! isscalar (c))
-      error ("prepad: third argument must be empty or a scalar");
+      error ("prepad: pad value C must be empty or a scalar");
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 4)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("prepad: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
-    error ("prepad: second argument must be a positive scaler");
+    error ("prepad: length L must be a positive scalar");
   endif
 
   if (dim > nd)
     sz(nd+1:dim) = 1;
   endif
 
   d = sz (dim);
 
@@ -92,10 +92,15 @@ endfunction
 
 %!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])
 
 ## FIXME -- we need tests for multidimensional arrays.
 
 %!error prepad ()
 %!error prepad (1)
 %!error prepad (1,2,3,4,5)
-%!error prepad ([1,2], 2, 2,3)
+%!error <C must be empty or a scalar> prepad ([1,2], 2, ones (2))
+%!error <DIM must be an integer> prepad ([1,2], 2, 2, ones (3))
+%!error <DIM must be an integer> prepad ([1,2], 2, 2, 1.1)
+%!error <DIM must be an integer> prepad ([1,2], 2, 2, 3)
+%!error <L must be a positive scalar> prepad ([1,2], ones (2))
+%!error <L must be a positive scalar> prepad ([1,2], -1)
 
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -93,10 +93,12 @@ endfunction
 %!demo
 %! profile on;
 %! expm (rand (500) + eye (500));
 %! profile off;
 %! profshow (profile ("info"), 5);
 
 %!error profshow ()
 %!error profshow (1, 2, 3)
-%!error profshow (struct (), 1.2)
+%!error <N must be a positive integer> profshow (struct (), ones (2))
+%!error <N must be a positive integer> profshow (struct (), 1+i)
+%!error <N must be a positive integer> profshow (struct (), -1)
 
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -12,23 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi})
-## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method})
-## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
+## @deftypefn  {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
+## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi}, @var{method})
+## @deftypefnx {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
 ##
 ## Generate a regular mesh from irregular data using interpolation.
-## The function is defined by @code{@var{y} = f (@var{x},@var{y},@var{z})}.
-## The interpolation points are all @var{xi}.
+## The function is defined by @code{@var{v} = f (@var{x}, @var{y}, @var{z})}.
+## The interpolation points are specified by @var{xi}, @var{yi}, @var{zi}.
 ##
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
 ##
 ## The optional argument @var{options} is passed directly to Qhull when
 ## computing the Delaunay triangulation used for interpolation.  See
 ## @code{delaunayn} for information on the defaults and how to pass different
 ## values.
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -33,31 +33,31 @@ function str = fileread (filename)
   endif
 
   fid = fopen (filename, "r");
   if (fid < 0)
     error ("fileread: cannot open file");
   endif
 
   unwind_protect
-    str = fread (fid, "*char");
+    str = (fread (fid, "*char")).';
   unwind_protect_cleanup
     fclose (fid);
   end_unwind_protect
 
 endfunction
 
 
 %!test
 %! cstr = {"Hello World", "The answer is 42", "Goodbye World"};
 %! fname = tmpnam ();
 %! fid = fopen (fname, "w");
 %! fprintf (fid, "%s\n", cstr{:});
 %! fclose (fid);
 %! str = fileread (fname);
-%! assert (str', [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
+%! assert (str, [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
 %! unlink (fname);
 
 %% Test input validation
 %!error fileread ()
 %!error fileread (1, 2)
 %!error <FILENAME argument must be a string> fileread (1)
 
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -66,18 +66,18 @@ function varargout = textread (filename,
 
   ## Skip header lines if requested
   headerlines = find (strcmpi (varargin, "headerlines"), 1);
   ## Beware of zero valued headerline, fskipl would skip to EOF
   if (! isempty (headerlines) && (varargin{headerlines + 1} > 0))
     fskipl (fid, varargin{headerlines + 1});
     varargin(headerlines:headerlines+1) = [];
   endif
-
-  if (nargin > 2 && isnumeric (varargin{1}))
+  
+  if (! isempty (varargin) && isnumeric (varargin{1}))
     nlines = varargin{1};
   else
     nlines = Inf;
   endif
 
   if (isfinite (nlines) && (nlines >= 0))
     str = tmp_str = "";
     n = 0;
@@ -135,14 +135,22 @@ endfunction
 %! d = rand (5, 3);
 %! dlmwrite (f, d, "precision", "%5.2f");
 %! [a, b, c] = textread (f, "%f %f %f", "delimiter", ",", "headerlines", 3);
 %! unlink (f);
 %! assert (a, d(4:5, 1), 1e-2);
 %! assert (b, d(4:5, 2), 1e-2);
 %! assert (c, d(4:5, 3), 1e-2);
 
+%!test
+%! f = tmpnam ();
+%! d = rand (7, 2);
+%! dlmwrite (f, d, "precision", "%5.2f");
+%! [a, b] = textread (f, "%f, %f", "headerlines", 1);
+%! unlink (f);
+%! assert (a, d(2:7, 1), 1e-2);
+
 %% Test input validation
 %!error textread ()
 %!error textread (1)
 %!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
 
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -99,17 +99,17 @@ function [s, iters] = logm (A, opt_iters
 
   if (m > 1)
     s = logm_pade_pf (s, m);
   endif
 
   s = 2^k * u * s * u';
 
   ## Remove small complex values (O(eps)) which may have entered calculation
-  if (real_eig)
+  if (real_eig && isreal(A))
     s = real (s);
   endif
 
   if (nargout == 2)
     iters = k;
   endif
 
 endfunction
@@ -157,14 +157,15 @@ endfunction
 
 
 %!assert (norm (logm ([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5)
 %!assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5)
 %!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
 %!assert (logm (10), log (10))
 %!assert (full (logm (eye (3))), logm (full (eye (3))))
 %!assert (full (logm (10*eye (3))), logm (full (10*eye (3))), 8*eps)
+%!assert (logm (expm ([0 1i; -1i 0])), [0 1i; -1i 0], 10 * eps)
 
 %% Test input validation
 %!error logm ()
 %!error logm (1, 2, 3)
 %!error <logm: A must be a square matrix> logm ([1 0;0 1; 2 2])
 
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -345,41 +345,48 @@ endfunction
 function [fx, gx] = guarded_eval (fun, x)
   if (nargout > 1)
     [fx, gx] = fun (x);
   else
     fx = fun (x);
     gx = [];
   endif
 
-  if (! (isreal (fx) && isreal (jx)))
+  if (! (isreal (fx) && isreal (gx)))
     error ("fminunc:notreal", "fminunc: non-real value encountered");
-  elseif (complexeqn && ! (isnumeric (fx) && isnumeric(jx)))
-    error ("fminunc:notnum", "fminunc: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
     error ("fminunc:isnan", "fminunc: NaN value encountered");
+  elseif (any (isinf (fx(:))))
+    error ("fminunc:isinf", "fminunc: Inf value encountered");
   endif
 endfunction
 
+
 %!function f = __rosenb (x)
 %!  n = length (x);
 %!  f = sumsq (1 - x(1:n-1)) + 100 * sumsq (x(2:n) - x(1:n-1).^2);
 %!endfunction
 %!test
 %! [x, fval, info, out] = fminunc (@__rosenb, [5, -5]);
 %! tol = 2e-5;
 %! assert (info > 0);
 %! assert (x, ones (1, 2), tol);
 %! assert (fval, 0, tol);
 %!test
 %! [x, fval, info, out] = fminunc (@__rosenb, zeros (1, 4));
 %! tol = 2e-5;
 %! assert (info > 0);
 %! assert (x, ones (1, 4), tol);
 %! assert (fval, 0, tol);
+%% Test FunValCheck works correctly
+%!assert (fminunc (@(x) x^2, 1, optimset ("FunValCheck", "on")), 0, eps)
+%!error <non-real value> fminunc (@(x) x + i, 1, optimset ("FunValCheck", "on"))
+%!error <NaN value> fminunc (@(x) x + NaN, 1, optimset ("FunValCheck", "on"))
+%!error <Inf value> fminunc (@(x) x + Inf, 1, optimset ("FunValCheck", "on"))
+
 
 ## Solve the double dogleg trust-region minimization problem:
 ## Minimize 1/2*norm(r*x)^2  subject to the constraint norm(d.*x) <= delta,
 ## x being a convex combination of the gauss-newton and scaled gradient.
 
 ## TODO: error checks
 ## TODO: handle singularity, or leave it up to mldivide?
 
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -445,16 +445,18 @@ function [fx, jx] = guarded_eval (fun, x
   endif
 
   if (! complexeqn && ! (isreal (fx) && isreal (jx)))
     error ("fsolve:notreal", "fsolve: non-real value encountered");
   elseif (complexeqn && ! (isnumeric (fx) && isnumeric(jx)))
     error ("fsolve:notnum", "fsolve: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
     error ("fsolve:isnan", "fsolve: NaN value encountered");
+  elseif (any (isinf (fx(:))))
+    error ("fsolve:isinf", "fsolve: Inf value encountered");
   endif
 endfunction
 
 function [fx, jx] = make_fcn_jac (x, fcn, fjac)
   fx = fcn (x);
   if (nargout == 2)
     jx = fjac (x);
   endif
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -29,18 +29,21 @@
 ## @itemize @bullet
 ## @item AutoScaling
 ##
 ## @item ComplexEqn
 ##
 ## @item FinDiffType
 ##
 ## @item FunValCheck
-## When enabled, display an error if the objective function returns a complex
-## value or NaN@.  Must be set to "on" or "off" [default].
+## When enabled, display an error if the objective function returns an invalid
+## value (a complex value, NaN, or Inf).  Must be set to "on" or "off"
+## [default].  Note: the functions @code{fzero} and @code{fminbnd} correctly
+## handle Inf values and only complex values or NaN will cause an error in this
+## case. 
 ##
 ## @item GradObj
 ## When set to "on", the function to be minimized must return a second argument
 ## which is the gradient, or first derivative, of the function at the point
 ## @var{x}.  If set to "off" [default], the gradient is computed via finite
 ## differences.
 ##
 ## @item Jacobian
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1746,17 +1746,18 @@ function desc = get_description (filenam
       if (length (colon) == 0)
         disp ("skipping line");
       else
         colon = colon(1);
         keyword = tolower (strip (line(1:colon-1)));
         value = strip (line (colon+1:end));
         if (length (value) == 0)
             fclose (fid);
-            error ("the keyword %s has an empty value", desc.keywords{end});
+            error ("The keyword `%s' of the package `%s' has an empty value",
+                    keyword, desc.name);
         endif
         desc.(keyword) = value;
       endif
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
 
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -192,16 +192,19 @@ function enhanced = gnuplot_set_term (pl
           gnuplot_pos = gnuplot_pos / 72;
           gnuplot_size = gnuplot_size / 72;
         endif
         if (all (gnuplot_size > 0))
           terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
                                  "gif", "jpeg", "latex", "pbm", "pdf", ...
                                  "pdfcairo", "postscript", "png", "pngcairo", ...
                                  "pstex", "pslatex", "svg", "tikz"};
+          if (__gnuplot_has_feature__ ("windows_figure_position"))
+            terminals_with_size{end+1} = "windows";
+          endif
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
           switch (term)
           case terminals_with_size
@@ -221,28 +224,30 @@ function enhanced = gnuplot_set_term (pl
             endif
           case {"aqua", "fig", "corel"}
             size_str = sprintf ("size %g %g", gnuplot_size);
           case "dxf"
             size_str = "";
           otherwise
             size_str = "";
           endswitch
-          if (strncmpi (term, "x11", 3)
-              && __gnuplot_has_feature__ ("x11_figure_position"))
-            ## X11 allows the window to be positioned as well.
+          if ((strncmpi (term, "x11", 3)
+               && __gnuplot_has_feature__ ("x11_figure_position"))
+              || (strcmpi (term, "windows")
+                  && __gnuplot_has_feature__ ("windows_figure_position")))
+            ## X11/Windows allows the window to be positioned as well.
             units = get (0, "units");
             unwind_protect
               set (0, "units", "pixels");
               screen_size = get (0, "screensize")(3:4);
             unwind_protect_cleanup
               set (0, "units", units);
             end_unwind_protect
             if (all (screen_size > 0))
-              ## For X11, set the figure positon as well as the size
+              ## For X11/Windows, set the figure positon as well as the size
               ## gnuplot position is UL, Octave's is LL (same for screen/window)
               gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
               gnuplot_pos = max (gnuplot_pos, 1);
               size_str = sprintf ("%s position %d,%d", size_str,
                                   gnuplot_pos(1), gnuplot_pos(2));
             endif
           endif
         else
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -12,50 +12,54 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} box (@var{arg})
-## @deftypefnx {Function File} {} box (@var{h}, @dots{})
+## @deftypefn  {Function File} {} box
+## @deftypefnx {Function File} {} box ("on")
+## @deftypefnx {Function File} {} box ("off")
+## @deftypefnx {Function File} {} box (@var{hax}, @dots{})
 ## Control the display of a border around the plot.
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, the current box state is toggled.
+##
+## If the first argument is an axis handle, @var{hax}, operate on the
+## specified axis object.
 ## @seealso{grid}
 ## @end deftypefn
 
 ## Author: jwe
 
 function box (varargin)
 
-  h = gca ();
-
-  box_state = get (h, "box");
-
-  nargs = numel (varargin);
+  [ax, varargin, nargs] = __plt_get_axis_arg__ ("box", varargin{:});
 
   if (nargs == 0)
-    if (strcmpi (box_state, "on"))
+    box_state = get (ax, "box");
+    if (strcmp (box_state, "on"))
       box_state = "off";
     else
       box_state = "on";
     endif
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
       if (strcmpi (state, "off"))
         box_state = "off";
       elseif (strcmpi (state, "on"))
         box_state = "on";
       else
-        print_usage ();
+        error ('box: argument must be "on" or "off"');
       endif
+    else
+      error ('box: argument must be "on" or "off"');
     endif
   else
     print_usage ();
   endif
 
-  set (h, "box", box_state);
+  set (ax, "box", box_state);
 
 endfunction
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -15,30 +15,35 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezpolar (@var{h}, @dots{})
+## @deftypefnx {Function File} {} ezpolar (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
-## Plot a function in polar coordinates.  The function @var{f} is either
-## a string, inline function or function handle with one arguments defining
-## the function.  By default the plot is over the domain @code{0 < @var{x} <
-## 2*pi} with 60 points.
+## Plot a function in polar coordinates.  The function @var{f} is
+## a string, inline function, or function handle with a single argument.
+## The expected form of the function is
+## @code{@var{rho} = @var{f}(@var{theta})}.
+## By default the plot is over the domain @code{0 < @var{theta} < 2*pi} with 60
+## points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{t}.  @var{n} is a scalar defining the number of points to
-## use.
+## values of @var{theta}.  @var{n} is a scalar defining the number of points to
+## use.  If the optional input @var{hax} is given then the plot is placed into
+## the specified axes rather than the current axes.
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
+## Example:
+##
 ## @example
 ## ezpolar (@@(t) 1 + sin (t));
 ## @end example
 ##
 ## @seealso{polar, ezplot, ezsurf, ezmesh}
 ## @end deftypefn
 
 function retval = ezpolar (varargin)
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -58,10 +58,30 @@ function h = mesh (varargin)
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
-%% FIXME: Need demo or test for function
+%!demo
+%! clf ();
+%! x = logspace(0,1,11);
+%! z = x'*x;
+%! mesh (x, x, z, z.^2);
+%! xlabel xlabel
+%! ylabel ylabel
+%! zlabel "linear scale"
 
+%!demo
+%! clf ();
+%! x = logspace(0,1,11);
+%! z = x'*x;
+%! mesh (x, x, z, z.^2);
+%! set (gca, "zscale", "log")
+%! xlabel xlabel
+%! ylabel ylabel
+%! zlabel "log scale"
+%! if (strcmp (get (gcf, "__graphics_toolkit__"), "gnuplot"))
+%!   title ({"Gnuplot: mesh color is wrong", "This a Gnuplot bug"})
+%! endif
+
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -16,27 +16,39 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a graph, or save it to a file
-##
-## @var{filename} defines the file name of the output file.  If the
-## file name has no suffix, one is inferred from the specified
-## device and appended to the file name.  If no
-## filename is specified, the output is sent to the printer.
+## Print a graph, or save it to a file. Both output formatted for 
+## printing (PDF and PostScript), and many bitmapped and vector
+## image formats are supported.
 ##
 ## @var{h} specifies the figure handle.  If no handle is specified
 ## the handle for the current figure is used.
 ##
-## @var{options}:
+## @var{filename} defines the name of the output file.  If the
+## file name has no suffix, one is inferred from the specified
+## device and appended to the file name.  If no filename is
+## specified, the output is sent to the printer.
+##
+## For output to a printer, to a PostScript file, or a PDF file,
+## the paper size is specified by the figure's @code{papersize}
+## property. The location and size of the image on the page are
+## specified by the figure's @code{paperposition} property. The
+## orientation of the page is specified by the figure's
+## @code{paperorientation} property.
+##
+## The width and height of images are specified by the figure's
+## @code{paperpositon(3:4)} property values.
+##
+## The @code{print} command supports several @var{options}:
 ##
 ## @table @code
 ## @item -f@var{h}
 ##   Specify the handle, @var{h}, of the figure to be printed.  The
 ##   default is the current figure.
 ##
 ## @item -P@var{printer}
 ##   Set the @var{printer} name to which the graph is sent if no
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -77,17 +77,19 @@ function varargout = __bar__ (vertical, 
       group = false;
       idx++;
     else
       if ((ischar (varargin{idx}) || iscell (varargin{idx}))
           && ! have_line_spec)
         [linespec, valid] = __pltopt__ (func, varargin{idx}, false);
         if (valid)
           have_line_spec = true;
-          newargs = [{"facecolor", linespec.color}, newargs]
+          ## FIXME: strange parse error requires semicolon to be spaced
+          ##        away from closing ']' on next line.
+          newargs = [{"facecolor", linespec.color}, newargs] ;
           idx++;
           continue;
         endif
       endif
       if (isscalar(varargin{idx}))
         width = varargin{idx++};
       elseif (idx == nargin - 2)
         newargs = [newargs,varargin(idx++)];
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -143,16 +143,27 @@ function opts = __fltk_print__ (opts)
   otherwise
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for GL2PS output",
            upper (opts.devopt));
   endswitch
 
   opts.pipeline = pipeline;
 
+  ## Tell gl2ps to use different rendering options for 2D plots
+  haxes = findall (opts.figure, "type", "axes");
+  vw = get (haxes, "view");
+  if (iscell (vw))
+    vw = vertcat (vw{:});
+  end
+  is2D = all (abs (vw(:,2)) == 90);
+  if (is2D)
+    gl2ps_device{end} = [gl2ps_device{end}, "is2D"];
+  endif
+
   for n = 1:numel(pipeline)
     if (opts.debug)
       fprintf ("fltk-pipeline: '%s'\n", pipeline{n});
     endif
     drawnow (gl2ps_device{n}, strcat('|',pipeline{n}));
   endfor
 
   if (! isempty (strfind (opts.devopt, "standalone")))
diff --git a/scripts/plot/private/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
--- a/scripts/plot/private/__gnuplot_has_feature__.m
+++ b/scripts/plot/private/__gnuplot_has_feature__.m
@@ -29,27 +29,28 @@ function res = __gnuplot_has_feature__ (
   features = {"x11_figure_position",
               "wxt_figure_size",
               "transparent_patches",
               "transparent_surface",
               "epslatex_implies_eps_filesuffix",
               "epslatexstandalone_terminal",
               "screen_coordinates_for_{lrtb}margin",
               "variable_GPVAL_TERMINALS",
-              "key_has_font_properties"};
+              "key_has_font_properties",
+              "windows_figure_position"};
 
   if (isempty (has_features))
     try
       gnuplot_version = __gnuplot_version__ ();
     catch
       ## Don't throw an error if gnuplot isn't installed
       gnuplot_version = "0.0.0";
     end_try_catch
-    versions = {"4.2.5", "4.4", "4.4", "4.4", "4.2", "4.2", "4.4", "4.4", "4.4"};
-    operators = {">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">="};
+    versions = {"4.2.5", "4.4", "4.4", "4.4", "4.2", "4.2", "4.4", "4.4", "4.4", "4.4"};
+    operators = {">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">=", ">="};
     have_features = logical (zeros (size (features)));
     for n = 1 : numel (have_features)
       has_features(n) = compare_versions (gnuplot_version, versions{n}, operators{n});
     endfor
   endif
 
   n = find (strcmpi (feature, features));
   if (isempty (n))
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -172,21 +172,27 @@ function __go_draw_figure__ (h, plot_str
                   set (kids(i), "units", orig_axes_units);
                   set (kids(i), "position", orig_axes_position);
                   bg_is_set = false;
                   fg_is_set = false;
                 end_unwind_protect
               endif
             case "uimenu"
               ## ignore uimenu objects
+              kids(i) = [];
             otherwise
               error ("__go_draw_figure__: unknown object class, %s", type);
           endswitch
         endfor
-        fputs (plot_stream, "\nunset multiplot;\n");
+        if (isempty (kids))
+          fputs (plot_stream, "\nreset; clear;\n");
+          fflush (plot_stream);
+        else
+          fputs (plot_stream, "\nunset multiplot;\n");
+        endif
       else
         fputs (plot_stream, "\nreset; clear;\n");
         fflush (plot_stream);
       endif
     else
       error ("__go_draw_figure__: expecting figure object, found `%s'",
              htype);
     endif
diff --git a/scripts/plot/private/__line__.m b/scripts/plot/private/__line__.m
--- a/scripts/plot/private/__line__.m
+++ b/scripts/plot/private/__line__.m
@@ -30,18 +30,18 @@
 function h = __line__ (p, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   nvargs = numel (varargin);
 
-  if (nvargs > 1 && isnumeric (varargin{1}) && isnumeric (varargin{2}))
-    if (nvargs > 2 && isnumeric (varargin{3}))
+  if (nvargs > 1 && ! ischar (varargin{1}) && ! ischar (varargin{2}))
+    if (nvargs > 2 && ! ischar (varargin{3}))
       num_data_args = 3;
     else
       num_data_args = 2;
     endif
   else
     num_data_args = 0;
   endif
 
@@ -85,21 +85,24 @@ function h = __line__ (p, varargin)
     nlines = 1;
   endif
 
   handles = zeros (nlines, 1);
 
   data = cell (1, 3);
 
   if (num_data_args > 1)
-    data(1) = varargin{1};
-    data(2) = varargin{2};
-    if (num_data_args == 3)
-      data(3) = varargin{3};
-    endif
+    data(1:num_data_args) = varargin(1:num_data_args);
+    for i = 1:num_data_args
+      if (islogical (data{i}))
+        data(i) = double (data{i});
+      elseif (iscomplex (data{i}))
+        data(i) = real (data{i});
+      endif
+    endfor
   endif
 
   data_args = reshape ({"xdata", "ydata", "zdata"; data{:}}, [1, 6]);
   mask = reshape ([false(1,3); ismat], [1, 6]);
 
   for i = 1:nlines
     tmp = data(ismat);
     if (! size_equal (tmp)
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -172,24 +172,27 @@ function retval = __plt1__ (h, x1, optio
 
   if (! isstruct (options))
     error ("__plt1__: options must be a struct array");
   endif
 
   [nr, nc] = size (x1);
   if (nr == 1)
     x1 = x1.';
-    tmp = nr;
-    nr = nc;
-    nc = tmp;
+    [nr, nc] = deal (nc, nr);   # Swap rows and columns
   endif
-  x1_i = imag (x1);
-  if (any (any (x1_i)))
-    x2 = x1_i;
-    x1 = real (x1);
+  if (iscomplex (x1))
+    x1_i = imag (x1);
+    if (any ((x1_i(:))))
+      x2 = x1_i;
+      x1 = real (x1);
+    else
+      x2 = x1;
+      x1 = (1:nr)';
+    endif
   else
     x2 = x1;
     x1 = (1:nr)';
   endif
 
   retval = __plt2__ (h, x1, x2, options, properties);
 
 endfunction
@@ -207,21 +210,25 @@ function retval = __plt2__ (h, x1, x2, o
   if (nargin < 5)
     properties = {};
   endif
 
   if (! isstruct (options))
     error ("__plt1__: options must be a struct array");
   endif
 
-  if (any (any (imag (x1))))
+  if (islogical (x1))
+    x1 = int8 (x1);
+  elseif (iscomplex ((x1)))
     x1 = real (x1);
   endif
 
-  if (any (any (imag (x2))))
+  if (islogical (x2))
+    x2 = int8 (x2);
+  elseif (iscomplex (x2))
     x2 = real (x2);
   endif
 
   h_set = false;
   if (isempty (x1) && isempty (x2))
     retval = zeros (0, 1);
   elseif (isscalar (x1))
     if (isscalar (x2))
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -418,18 +418,27 @@ endfunction
 %! opts = __print_parse_opts__ ("-f5", "-dljet3");
 %! assert (opts.ghostscript.device, "ljet3");
 %! assert (strfind (opts.ghostscript.output, ".ljet3"));
 %! assert (opts.devopt, "ljet3");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.figure, 5);
 
 function cmd = __quote_path__ (cmd)
-  if (any (cmd == " ") && ! (cmd(1) == """" && cmd(end) == """"))
-    cmd = strcat ("""", strrep (cmd, """", """"""), """");
+  if (! isempty (cmd))
+    is_quoted = all (cmd([1, end]) == "'");
+    if (! is_quoted)
+      dos_shell = ! isunix () && ispc ();
+      if (dos_shell && any (cmd == "/"))
+        cmd = strrep (cmd, "/", "\\");
+      endif
+      if (any (cmd == " "))
+        cmd = strcat ('"', strrep (cmd, '"', '""') ,'"');
+      endif
+    endif
   endif
 endfunction
 
 function gs = __ghostscript_binary__ ()
 
   persistent ghostscript_binary = ""
   persistent warn_on_no_ghostscript = true
   persistent warn_on_bad_gsc = true
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit to the points
 ## @code{[@var{x}, @var{y}]}. If @var{n} is a logical vector, it is used
-## as a mask to selectivelly force the corresponding polynomial
+## as a mask to selectively force the corresponding polynomial
 ## coefficients to be used or ignored.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
 ## @item R
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -24,17 +24,21 @@
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
-## kurtosis (x) = 1/N std(x)^(-4) sum ((x - mean(x)).^4) - 3
+## @group
+##                 1    sum ((x - mean(x)).^4)
+## kurtosis (x) = --- * ----------------------  -  3
+##                 N           std(x)^4
+## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return the kurtosis over the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
 ##
 ## Note: The definition of kurtosis above yields a kurtosis of zero for the
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -97,16 +97,26 @@ endfunction
 %! assert (median (x) == median (x2) && median (x) == 3.5);
 %! assert (median (y) == median (y2) && median (y) == 4);
 %! assert (median ([x2, 2*x2]), [3.5, 7]);
 %! assert (median ([y2, 3*y2]), [4, 12]);
 
 %!assert (median (single ([1,2,3])), single (2))
 %!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
 
+%% Test multidimensional arrays (bug #35679)
+%!shared a, b, x, y
+%! rand ("seed", 2);
+%! a = rand (2,3,4,5);
+%! b = rand (3,4,6,5);
+%! x = sort (a, 4);
+%! y = sort (b, 3);
+%!assert (median (a, 4), x(:, :, :, 3));
+%!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2);
+
 %% Test input validation
 %!error median ()
 %!error median (1, 2, 3)
 %!error median ({1:5})
 %!error median (['A'; 'B'])
 %!error median (1, ones(2,2))
 %!error median (1, 1.5)
 %!error median (1, 0)
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -84,30 +84,33 @@ function out = base2dec (s, base)
   ## Right justify the values before anything else.
   s = strjust (s, "right");
 
   ## Lookup value of symbols in symbol table, with invalid symbols
   ## evaluating to NaN and space evaluating to 0.
   table = NaN (1, 256);
   table(toascii (symbols(1:base))) = 0 : base-1;
   table(toascii (" ")) = 0;
-  s = table(toascii (s));
+  s = reshape (table(toascii (s)), size (s));
 
   ## Multiply the resulting digits by the appropriate power
   ## and sum the rows.
   out = s * (base .^ (columns(s)-1 : -1 : 0)');
 
 endfunction
 
 
 %!assert (base2dec ("11120", 3), 123)
 %!assert (base2dec ("yyyzx", "xyz"), 123)
 %!assert (base2dec ("-1", 2), NaN)
 %!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
+%% Bug #35621
+%!assert (base2dec (["0"; "1"], 2), [0; 1])
+
 %%Test input validation
 %!error base2dec ()
 %!error base2dec ("11120")
 %!error base2dec ("11120", 3, 4)
 %!error base2dec ("11120", "1231")
 %!error base2dec ("11120", "12 3")
 %!error base2dec ("11120", ones (2))
 %!error base2dec ("11120", 37)
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} bin2dec (@var{s})
 ## Return the decimal number corresponding to the binary number represented
 ## by the string @var{s}.  For example:
 ##
 ## @example
 ## @group
 ## bin2dec ("1110")
-##      @result{} 14
+##       @result{} 14
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, return a column vector with one converted
 ## number per row of @var{s}; Invalid rows evaluate to NaN@.
 ##
 ## If @var{s} is a cell array of strings, return a column vector with one
 ## converted number per cell element in @var{s}.
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blanks (@var{n})
 ## Return a string of @var{n} blanks, for example:
 ##
 ## @example
 ## @group
 ## blanks (10);
-## whos ans;
+## whos ans
 ##      @result{}
 ##       Attr Name        Size                     Bytes  Class
 ##       ==== ====        ====                     =====  =====
 ##            ans         1x10                        10  char
 ## @end group
 ## @end example
 ## @seealso{repmat}
 ## @end deftypefn
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -27,18 +27,18 @@
 ##       @result{} "ab   cd"
 ## @end group
 ## @end example
 ##
 ## @example
 ## @group
 ## s = [ "ab"; "cde" ];
 ## cstrcat (s, s, s)
-##      @result{} "ab ab ab "
-##         "cdecdecde"
+##       @result{} "ab ab ab "
+##          "cdecdecde"
 ## @end group
 ## @end example
 ## @seealso{strcat, char, strvcat}
 ## @end deftypefn
 
 ## Author: jwe
 
 function st = cstrcat (varargin)
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -19,19 +19,19 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hex2dec (@var{s})
 ## Return the integer corresponding to the hexadecimal number represented
 ## by the string @var{s}.  For example:
 ##
 ## @example
 ## @group
 ## hex2dec ("12B")
-##      @result{} 299
+##       @result{} 299
 ## hex2dec ("12b")
-##      @result{} 299
+##       @result{} 299
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a string matrix, return a column vector with one converted
 ## number per row of @var{s}; Invalid rows evaluate to NaN@.
 ##
 ## If @var{s} is a cell array of strings, return a column vector with one
 ## converted number per cell element in @var{s}.
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -23,17 +23,17 @@
 ## string @var{s}, or 0 if no occurrence is found.  @var{s} may also be a
 ## string array or cell array of strings.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## index ("Teststring", "t")
-##    @result{} 4
+##     @result{} 4
 ## @end group
 ## @end example
 ##
 ## If @var{direction} is @samp{"first"}, return the first element found.
 ## If @var{direction} is @samp{"last"}, return the last element found.
 ##
 ## @seealso{find, rindex}
 ## @end deftypefn
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -174,17 +174,17 @@ private:
       {
         valid (1);
         setup_viewport (w (), h ());
       }
 
     if (print_mode)
       {
         FILE *fp = octave_popen (print_cmd.c_str (), "w");
-        glps_renderer rend (fileno (fp), print_term);
+        glps_renderer rend (fp, print_term);
 
         rend.draw (gh_manager::get_object (number));
 
         octave_pclose (fp);
         print_mode = false;
       }
     else
       {
@@ -663,16 +663,24 @@ public:
     : Fl_Window (xx, yy, ww, hh, "octave"), window_label (), shift (0),
       ndim (2), fp (xfp), canvas (0), autoscale (0), togglegrid (0),
       panzoom (0), rotate (0), help (0), status (0),
       ax_obj (), pos_x (0), pos_y (0)
   {
     callback (window_close, static_cast<void*> (this));
     size_range (4*status_h, 2*status_h);
 
+    // FIXME: The function below is only available in FLTK >= 1.3
+    // At some point support for FLTK 1.1 will be dropped in Octave.
+    // At that point this function should be uncommented.
+    // The current solution is to call xclass() before show() for each window.
+    // Set WM_CLASS which allows window managers to properly group related
+    // windows.  Otherwise, the class is just "FLTK"
+    //default_xclass ("Octave");
+
     begin ();
     {
 
       canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
 
       uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
@@ -717,16 +725,23 @@ public:
       status->textfont (FL_COURIER);
       status->textsize (10);
       status->box (FL_ENGRAVED_BOX);
 
       // This allows us to have a valid OpenGL context right away.
       canvas->mode (FL_DEPTH | FL_DOUBLE );
       if (fp.is_visible ())
         {
+          // FIXME: This code should be removed when Octave drops support
+          // for FLTK 1.1.  Search for default_xclass in this file to find
+          // code that should be uncommented to take its place.
+          //
+          // Set WM_CLASS which allows window managers to properly group
+          // related windows.  Otherwise, the class is just "FLTK"
+          xclass ("Octave");
           show ();
           if (fp.get_currentaxes ().ok())
             show_canvas ();
           else
             hide_canvas ();
         }
     }
     end ();
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -526,20 +526,20 @@ DEFUN_DLD (airy, args, nargout,
 @deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
- 0   Ai (Z)     exp (2/3 * Z * sqrt (Z))\n\
- 1   dAi(Z)/dZ  exp (2/3 * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
+ 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
+ 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
+ 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
@@ -923,9 +923,328 @@ return @code{NaN}.\n\
 %!assert(besselh(-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
 %!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
 %!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
+
+
+Tests contributed by Robert T. Short.
+Tests are based on the properties and tables in A&S:
+ Abramowitz and Stegun, "Handbook of Mathematical Functions",
+ 1972.
+
+For regular Bessel functions, there are 3 tests. These compare octave
+results against Tables 9.1, 9.2, and 9.4 in A&S. Tables 9.1 and 9.2
+are good to only a few decimal places, so any failures should be
+considered a broken implementation. Table 9.4 is an extended table
+for larger orders and arguments. There are some differences between
+Octave and Table 9.4, mostly in the last decimal place but in a very
+few instances the errors are in the last two places. The comparison
+tolerance has been changed to reflect this.
+
+Similarly for modifed Bessel functions, there are 3 tests. These
+compare octave results against Tables 9.8, 9.9, and 9.11 in A&S.
+Tables 9.8 and 9.9 are good to only a few decimal places, so any
+failures should be considered a broken implementation. Table 9.11 is
+an extended table for larger orders and arguments. There are some
+differences between octave and Table 9.11, mostly in the last decimal
+place but in a very few instances the errors are in the last two
+places. The comparison tolerance has been changed to reflect this.
+
+For spherical Bessel functions, there are also three tests, comparing
+octave results to Tables 10.1, 10.2, and 10.4 in A&S. Very similar
+comments may be made here as in the previous lines. At this time,
+modified spherical Bessel function tests are not included.
+
+% Table 9.1 - J and Y for integer orders 0, 1, 2.
+% Compare against excerpts of Table 9.1, Abramowitz and Stegun.
+%!test
+%! n = 0:2;
+%! z = (0:2.5:17.5)';
+%!
+%! Jt = [[ 1.000000000000000,  0.0000000000,  0.0000000000];
+%!       [-0.048383776468198,  0.4970941025,  0.4460590584];
+%!       [-0.177596771314338, -0.3275791376,  0.0465651163];
+%!       [ 0.266339657880378,  0.1352484276, -0.2302734105];
+%!       [-0.245935764451348,  0.0434727462,  0.2546303137];
+%!       [ 0.146884054700421, -0.1654838046, -0.1733614634];
+%!       [-0.014224472826781,  0.2051040386,  0.0415716780];
+%!       [-0.103110398228686, -0.1634199694,  0.0844338303]];
+%!
+%! Yt = [[-Inf,          -Inf,         -Inf         ];
+%!       [ 0.4980703596,  0.1459181380, -0.38133585 ];
+%!       [-0.3085176252,  0.1478631434,  0.36766288 ];
+%!       [ 0.1173132861, -0.2591285105, -0.18641422 ];
+%!       [ 0.0556711673,  0.2490154242, -0.00586808 ];
+%!       [-0.1712143068, -0.1538382565,  0.14660019 ];
+%!       [ 0.2054642960,  0.0210736280, -0.20265448 ];
+%!       [-0.1604111925,  0.0985727987,  0.17167666 ]];
+%!
+%! J = besselj(n,z);
+%! Y = bessely(n,z);
+%! assert(Jt(:,1), J(:,1), 0.5e-10);
+%! assert(Yt(:,1), Y(:,1), 0.5e-10);
+%! assert(Jt(:,2:3), J(:,2:3), 0.5e-10);
+
+Table 9.2 - J and Y for integer orders 3-9.
+
+%!test
+%!  n = (3:9);
+%!  z = (0:2:20).';
+%!
+%!  Jt = [[ 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00];
+%!        [ 1.2894e-01, 3.3996e-02, 7.0396e-03, 1.2024e-03, 1.7494e-04, 2.2180e-05, 2.4923e-06];
+%!        [ 4.3017e-01, 2.8113e-01, 1.3209e-01, 4.9088e-02, 1.5176e-02, 4.0287e-03, 9.3860e-04];
+%!        [ 1.1477e-01, 3.5764e-01, 3.6209e-01, 2.4584e-01, 1.2959e-01, 5.6532e-02, 2.1165e-02];
+%!        [-2.9113e-01,-1.0536e-01, 1.8577e-01, 3.3758e-01, 3.2059e-01, 2.2345e-01, 1.2632e-01];
+%!        [ 5.8379e-02,-2.1960e-01,-2.3406e-01,-1.4459e-02, 2.1671e-01, 3.1785e-01, 2.9186e-01];
+%!        [ 1.9514e-01, 1.8250e-01,-7.3471e-02,-2.4372e-01,-1.7025e-01, 4.5095e-02, 2.3038e-01];
+%!        [-1.7681e-01, 7.6244e-02, 2.2038e-01, 8.1168e-02,-1.5080e-01,-2.3197e-01,-1.1431e-01];
+%!        [-4.3847e-02,-2.0264e-01,-5.7473e-02, 1.6672e-01, 1.8251e-01,-7.0211e-03,-1.8953e-01];
+%!        [ 1.8632e-01, 6.9640e-02,-1.5537e-01,-1.5596e-01, 5.1399e-02, 1.9593e-01, 1.2276e-01];
+%!        [-9.8901e-02, 1.3067e-01, 1.5117e-01,-5.5086e-02,-1.8422e-01,-7.3869e-02, 1.2513e-01]];
+%!
+%!  Yt = [[       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf,       -Inf];
+%!        [-1.1278e+00,-2.7659e+00,-9.9360e+00,-4.6914e+01,-2.7155e+02,-1.8539e+03,-1.4560e+04];
+%!        [-1.8202e-01,-4.8894e-01,-7.9585e-01,-1.5007e+00,-3.7062e+00,-1.1471e+01,-4.2178e+01];
+%!        [ 3.2825e-01, 9.8391e-02,-1.9706e-01,-4.2683e-01,-6.5659e-01,-1.1052e+00,-2.2907e+00];
+%!        [ 2.6542e-02, 2.8294e-01, 2.5640e-01, 3.7558e-02,-2.0006e-01,-3.8767e-01,-5.7528e-01];
+%!        [-2.5136e-01,-1.4495e-01, 1.3540e-01, 2.8035e-01, 2.0102e-01, 1.0755e-03,-1.9930e-01];
+%!        [ 1.2901e-01,-1.5122e-01,-2.2982e-01,-4.0297e-02, 1.8952e-01, 2.6140e-01, 1.5902e-01];
+%!        [ 1.2350e-01, 2.0393e-01,-6.9717e-03,-2.0891e-01,-1.7209e-01, 3.6816e-02, 2.1417e-01];
+%!        [-1.9637e-01,-7.3222e-05, 1.9633e-01, 1.2278e-01,-1.0425e-01,-2.1399e-01,-1.0975e-01];
+%!        [ 3.3724e-02,-1.7722e-01,-1.1249e-01, 1.1472e-01, 1.8897e-01, 3.2253e-02,-1.6030e-01];
+%!        [ 1.4967e-01, 1.2409e-01,-1.0004e-01,-1.7411e-01,-4.4312e-03, 1.7101e-01, 1.4124e-01]];
+%!
+%!  n = (3:9);
+%!  z = (0:2:20).';
+%!  J=besselj(n,z);
+%!  Y=bessely(n,z);
+%!
+%!  assert(J(1,:), zeros (1, columns (J)));
+%!  assert(J(2:end,:), Jt(2:end,:), -5e-5);
+%!  assert(Yt(1,:), Y(1,:));
+%!  assert(Y(2:end,:), Yt(2:end,:), -5e-5);
+
+Table 9.4 - J and Y for various integer orders and arguments.
+
+%!test
+%! Jt = [[ 7.651976866e-01,   2.238907791e-01,  -1.775967713e-01,  -2.459357645e-01,  5.581232767e-02,  1.998585030e-02];
+%!       [ 2.497577302e-04,   7.039629756e-03,   2.611405461e-01,  -2.340615282e-01, -8.140024770e-02, -7.419573696e-02];
+%!       [ 2.630615124e-10,   2.515386283e-07,   1.467802647e-03,   2.074861066e-01, -1.138478491e-01, -5.473217694e-02];
+%!       [ 2.297531532e-17,   7.183016356e-13,   4.796743278e-07,   4.507973144e-03, -1.082255990e-01,  1.519812122e-02];
+%!       [ 3.873503009e-25,   3.918972805e-19,   2.770330052e-11,   1.151336925e-05, -1.167043528e-01,  6.221745850e-02];
+%!       [ 3.482869794e-42,   3.650256266e-33,   2.671177278e-21,   1.551096078e-12,  4.843425725e-02,  8.146012958e-02];
+%!       [ 1.107915851e-60,   1.196077458e-48,   8.702241617e-33,   6.030895312e-21, -1.381762812e-01,  7.270175482e-02];
+%!       [ 2.906004948e-80,   3.224095839e-65,   2.294247616e-45,   1.784513608e-30,  1.214090219e-01, -3.869833973e-02];
+%!       [ 8.431828790e-189,  1.060953112e-158,  6.267789396e-119,  6.597316064e-89,  1.115927368e-21,  9.636667330e-02]];
+%!
+%! Yt = [[ 8.825696420e-02,   5.103756726e-01,  -3.085176252e-01,   5.567116730e-02, -9.806499547e-02, -7.724431337e-02]
+%!       [-2.604058666e+02,  -9.935989128e+00,  -4.536948225e-01,   1.354030477e-01, -7.854841391e-02, -2.948019628e-02]
+%!       [-1.216180143e+08,  -1.291845422e+05,  -2.512911010e+01,  -3.598141522e-01,  5.723897182e-03,  5.833157424e-02]
+%!       [-9.256973276e+14,  -2.981023646e+10,  -4.694049564e+04,  -6.364745877e+00,  4.041280205e-02,  7.879068695e-02]
+%!       [-4.113970315e+22,  -4.081651389e+16,  -5.933965297e+08,  -1.597483848e+03,  1.644263395e-02,  5.124797308e-02]
+%!       [-3.048128783e+39,  -2.913223848e+30,  -4.028568418e+18,  -7.256142316e+09, -1.164572349e-01,  6.138839212e-03]
+%!       [-7.184874797e+57,  -6.661541235e+45,  -9.216816571e+29,  -1.362803297e+18, -4.530801120e-02,  4.074685217e-02]
+%!       [-2.191142813e+77,  -1.976150576e+62,  -2.788837017e+42,  -3.641066502e+27, -2.103165546e-01,  7.650526394e-02]
+%!       [-3.775287810e+185, -3.000826049e+155, -5.084863915e+115, -4.849148271e+85, -3.293800188e+18, -1.669214114e-01]];
+%!
+%! n = [(0:5:20).';30;40;50;100];
+%! z = [1,2,5,10,50,100];
+%! J = besselj(n.',z.').';
+%! Y = bessely(n.',z.').';
+%!  assert(J, Jt, -1e-9);
+%!  assert(Y, Yt, -1e-9);
+
+Table 9.8 - I and K for integer orders 0, 1, 2.
+
+%!test
+%! n  = 0:2;
+%! z1 = [0.1;2.5;5.0];
+%! z2 = [7.5;10.0;15.0;20.0];
+%! rtbl = [ [ 0.9071009258   0.0452984468   0.1251041992   2.6823261023  10.890182683    1.995039646  ];
+%!          [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
+%!          [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
+%!          [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
+%!          [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
+%!          [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
+%!          [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
+%!
+%! tbl = [besseli(n,z1,1), besselk(n,z1,1)];
+%! tbl(:,3) = tbl(:,3).*(exp(z1).*z1.^(-2));
+%! tbl(:,6) = tbl(:,6).*(exp(-z1).*z1.^(2));
+%! tbl = [tbl;[besseli(n,z2,1),besselk(n,z2,1)]];
+%!
+%! assert(tbl, rtbl, -2e-8);
+
+Table 9.9 - I and K for orders 3-9.
+
+%!test
+%! It = [[  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00];
+%!       [  2.8791e-02  6.8654e-03  1.3298e-03  2.1656e-04  3.0402e-05  3.7487e-06  4.1199e-07];
+%!       [  6.1124e-02  2.5940e-02  9.2443e-03  2.8291e-03  7.5698e-04  1.7968e-04  3.8284e-05];
+%!       [  7.4736e-02  4.1238e-02  1.9752e-02  8.3181e-03  3.1156e-03  1.0484e-03  3.1978e-04];
+%!       [  7.9194e-02  5.0500e-02  2.8694e-02  1.4633e-02  6.7449e-03  2.8292e-03  1.0866e-03];
+%!       [  7.9830e-02  5.5683e-02  3.5284e-02  2.0398e-02  1.0806e-02  5.2694e-03  2.3753e-03];
+%!       [  7.8848e-02  5.8425e-02  3.9898e-02  2.5176e-02  1.4722e-02  8.0010e-03  4.0537e-03];
+%!       [  7.7183e-02  5.9723e-02  4.3056e-02  2.8969e-02  1.8225e-02  1.0744e-02  5.9469e-03];
+%!       [  7.5256e-02  6.0155e-02  4.5179e-02  3.1918e-02  2.1240e-02  1.3333e-02  7.9071e-03];
+%!       [  7.3263e-02  6.0059e-02  4.6571e-02  3.4186e-02  2.3780e-02  1.5691e-02  9.8324e-03];
+%!       [  7.1300e-02  5.9640e-02  4.7444e-02  3.5917e-02  2.5894e-02  1.7792e-02  1.1661e-02]];
+%!
+%! Kt = [
+%!      [         Inf         Inf         Inf         Inf         Inf         Inf         Inf];
+%!      [  4.7836e+00  1.6226e+01  6.9687e+01  3.6466e+02  2.2576e+03  1.6168e+04  1.3160e+05];
+%!      [  1.6317e+00  3.3976e+00  8.4268e+00  2.4465e+01  8.1821e+01  3.1084e+02  1.3252e+03];
+%!      [  9.9723e-01  1.6798e+00  3.2370e+00  7.0748e+00  1.7387e+01  4.7644e+01  1.4444e+02];
+%!      [  7.3935e-01  1.1069e+00  1.8463e+00  3.4148e+00  6.9684e+00  1.5610e+01  3.8188e+01];
+%!      [  6.0028e-01  8.3395e-01  1.2674e+00  2.1014e+00  3.7891e+00  7.4062e+00  1.5639e+01];
+%!      [  5.1294e-01  6.7680e-01  9.6415e-01  1.4803e+00  2.4444e+00  4.3321e+00  8.2205e+00];
+%!      [  4.5266e-01  5.7519e-01  7.8133e-01  1.1333e+00  1.7527e+00  2.8860e+00  5.0510e+00];
+%!      [  4.0829e-01  5.0414e-01  6.6036e-01  9.1686e-01  1.3480e+00  2.0964e+00  3.4444e+00];
+%!      [  3.7411e-01  4.5162e-01  5.7483e-01  7.7097e-01  1.0888e+00  1.6178e+00  2.5269e+00];
+%!      [  3.4684e-01  4.1114e-01  5.1130e-01  6.6679e-01  9.1137e-01  1.3048e+00  1.9552e+00]];
+%!
+%! n = (3:9);
+%! z = (0:2:20).';
+%! I=besseli(n,z,1);
+%! K=besselk(n,z,1);
+%!
+%! assert(abs (I(1,:)), zeros(1, columns(I)));
+%! assert(I(2:end,:), It(2:end,:), -5e-5);
+%! assert(Kt(1,:), K(1,:));
+%! assert(K(2:end,:), Kt(2:end,:), -5e-5);
+
+Table 9.11 - I and K for various integer orders and arguments.
+
+%!test
+%! It = [[   1.266065878e+00    2.279585302e+00    2.723987182e+01    2.815716628e+03     2.93255378e+20     1.07375171e+42 ];
+%!       [   2.714631560e-04    9.825679323e-03    2.157974547e+00    7.771882864e+02     2.27854831e+20     9.47009387e+41 ];
+%!       [   2.752948040e-10    3.016963879e-07    4.580044419e-03    2.189170616e+01     1.07159716e+20     6.49897552e+41 ];
+%!       [   2.370463051e-17    8.139432531e-13    1.047977675e-06    1.043714907e-01     3.07376455e+19     3.47368638e+41 ];
+%!       [   3.966835986e-25    4.310560576e-19    5.024239358e-11    1.250799736e-04     5.44200840e+18     1.44834613e+41 ];
+%!       [   3.539500588e-42    3.893519664e-33    3.997844971e-21    7.787569783e-12     4.27499365e+16     1.20615487e+40 ];
+%!       [   1.121509741e-60    1.255869192e-48    1.180426980e-32    2.042123274e-20     6.00717897e+13     3.84170550e+38 ];
+%!       [   2.934635309e-80    3.353042830e-65    2.931469647e-45    4.756894561e-30     1.76508024e+10     4.82195809e+36 ];
+%!       [   8.473674008e-189   1.082171475e-158   7.093551489e-119   1.082344202e-88     2.72788795e-16     4.64153494e+21 ]];
+%!
+%! Kt = [[   4.210244382e-01    1.138938727e-01    3.691098334e-03    1.778006232e-05     3.41016774e-23     4.65662823e-45 ];
+%!       [   3.609605896e+02    9.431049101e+00    3.270627371e-02    5.754184999e-05     4.36718224e-23     5.27325611e-45 ];
+%!       [   1.807132899e+08    1.624824040e+05    9.758562829e+00    1.614255300e-03     9.15098819e-23     7.65542797e-45 ];
+%!       [   1.403066801e+15    4.059213332e+10    3.016976630e+04    2.656563849e-01     3.11621117e-22     1.42348325e-44 ];
+%!       [   6.294369360e+22    5.770856853e+16    4.827000521e+08    1.787442782e+02     1.70614838e-21     3.38520541e-44 ];
+%!       [   4.706145527e+39    4.271125755e+30    4.112132063e+18    2.030247813e+09     2.00581681e-19     3.97060205e-43 ];
+%!       [   1.114220651e+58    9.940839886e+45    1.050756722e+30    5.938224681e+17     1.29986971e-16     1.20842080e-41 ];
+%!       [   3.406896854e+77    2.979981740e+62    3.394322243e+42    2.061373775e+27     4.00601349e-13     9.27452265e-40 ];
+%!       [   5.900333184e+185   4.619415978e+155   7.039860193e+115   4.596674084e+85     1.63940352e+13     7.61712963e-25 ]];
+%!
+%! n = [(0:5:20).';30;40;50;100];
+%! z = [1,2,5,10,50,100];
+%! I = besseli(n.',z.').';
+%! K = besselk(n.',z.').';
+%! assert(I, It, -5e-9);
+%! assert(K, Kt, -5e-9);
+
+The next section checks that negative integer orders and positive
+integer orders are appropriately related.
+
+%!test
+%! n=(0:2:20);
+%! assert(besselj(n,1), besselj(-n,1), 1e-8);
+%! assert(-besselj(n+1,1), besselj(-n-1,1), 1e-8);
+
+besseli(n,z) = besseli(-n,z);
+
+%!test
+%! n=(0:2:20);
+%! assert(besseli(n,1), besseli(-n,1), 1e-8);
+
+Table 10.1 - j and y for integer orders 0, 1, 2.
+Compare against excerpts of Table 10.1, Abramowitz and Stegun.
+
+%!test
+%! n = (0:2);
+%! z = [0.1;(2.5:2.5:10.0).'];
+%!
+%! jt = [[ 9.9833417e-01  3.33000119e-02  6.6619061e-04 ];
+%!       [ 2.3938886e-01  4.16212989e-01  2.6006673e-01 ];
+%!       [-1.9178485e-01 -9.50894081e-02  1.3473121e-01 ];
+%!       [    1.2507e-01     -2.9542e-02    -1.3688e-01 ];
+%!       [   -5.4402e-02      7.8467e-02     7.7942e-02 ]];
+%!
+%! yt = [[-9.9500417e+00  -1.0049875e+02 -3.0050125e+03 ];
+%!       [ 3.2045745e-01  -1.1120588e-01 -4.5390450e-01 ];
+%!       [-5.6732437e-02   1.8043837e-01  1.6499546e-01 ];
+%!       [   -4.6218e-02     -1.3123e-01    -6.2736e-03 ];
+%!       [    8.3907e-02      6.2793e-02    -6.5069e-02 ]];
+%!
+%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
+%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
+%! assert(jt, j, -5e-5);
+%! assert(yt, y, -5e-5);
+
+Table 10.2 - j and y for orders 3-8.
+Compare against excerpts of Table 10.2, Abramowitzh and Stegun.
+
+ Important note: In A&S, y_4(0.1) = -1.0507e+7, but Octave returns
+ y_4(0.1) = -1.0508e+07 (-10507503.75). If I compute the same term using
+ a series, the difference is in the eighth significant digit so I left
+ the Octave results in place.
+
+%!test
+%! n = (3:8);
+%! z = (0:2.5:10).'; z(1)=0.1;
+%!
+%! jt = [[ 9.5185e-06  1.0577e-07  9.6163e-10  7.3975e-12  4.9319e-14  2.9012e-16];
+%!       [ 1.0392e-01  3.0911e-02  7.3576e-03  1.4630e-03  2.5009e-04  3.7516e-05];
+%!       [ 2.2982e-01  1.8702e-01  1.0681e-01  4.7967e-02  1.7903e-02  5.7414e-03];
+%!       [-6.1713e-02  7.9285e-02  1.5685e-01  1.5077e-01  1.0448e-01  5.8188e-02];
+%!       [-3.9496e-02 -1.0559e-01 -5.5535e-02  4.4501e-02  1.1339e-01  1.2558e-01]];
+%!
+%! yt = [[-1.5015e+05 -1.0508e+07 -9.4553e+08 -1.0400e+11 -1.3519e+13 -2.0277e+15];
+%!       [-7.9660e-01 -1.7766e+00 -5.5991e+00 -2.2859e+01 -1.1327e+02 -6.5676e+02];
+%!       [-1.5443e-02 -1.8662e-01 -3.2047e-01 -5.1841e-01 -1.0274e+00 -2.5638e+00];
+%!       [ 1.2705e-01  1.2485e-01  2.2774e-02 -9.1449e-02 -1.8129e-01 -2.7112e-01];
+%!       [-9.5327e-02 -1.6599e-03  9.3834e-02  1.0488e-01  4.2506e-02 -4.1117e-02]];
+%!
+%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
+%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
+%!
+%! assert(jt, j, -5e-5);
+%! assert(yt, y, -5e-5);
+
+Table 10.4 - j and y for various integer orders and arguments.
+
+%!test
+%! jt = [[ 8.414709848e-01    4.546487134e-01   -1.917848549e-01   -5.440211109e-02   -5.247497074e-03   -5.063656411e-03];
+%!       [ 9.256115861e-05    2.635169770e-03    1.068111615e-01   -5.553451162e-02   -2.004830056e-02   -9.290148935e-03];
+%!       [ 7.116552640e-11    6.825300865e-08    4.073442442e-04    6.460515449e-02   -1.503922146e-02   -1.956578597e-04];
+%!       [ 5.132686115e-18    1.606982166e-13    1.084280182e-07    1.063542715e-03   -1.129084539e-02    7.877261748e-03];
+%!       [ 7.537795722e-26    7.632641101e-20    5.427726761e-12    2.308371961e-06   -1.578502990e-02    1.010767128e-02];
+%!       [ 5.566831267e-43    5.836617888e-34    4.282730217e-22    2.512057385e-13   -1.494673454e-03    8.700628514e-03];
+%!       [ 1.538210374e-61    1.660978779e-49    1.210347583e-33    8.435671634e-22   -2.606336952e-02    1.043410851e-02];
+%!       [ 3.615274717e-81    4.011575290e-66    2.857479350e-46    2.230696023e-31    1.882910737e-02    5.797140882e-04];
+%!       [7.444727742e-190   9.367832591e-160   5.535650303e-120    5.832040182e-90    1.019012263e-22    1.088047701e-02]];
+%!
+%! yt = [[ -5.403023059e-01    2.080734183e-01   -5.673243709e-02    8.390715291e-02   -1.929932057e-02   -8.623188723e-03]
+%!       [ -9.994403434e+02   -1.859144531e+01   -3.204650467e-01    9.383354168e-02   -6.971131965e-04    3.720678486e-03]
+%!       [ -6.722150083e+08   -3.554147201e+05   -2.665611441e+01   -1.724536721e-01    1.352468751e-02    1.002577737e-02]
+%!       [ -6.298007233e+15   -1.012182944e+11   -6.288146513e+04   -3.992071745e+00    1.712319725e-02    6.258641510e-03]
+%!       [ -3.239592219e+23   -1.605436493e+17   -9.267951403e+08   -1.211210605e+03    1.375953130e-02    5.631729379e-05]
+%!       [ -2.946428547e+40   -1.407393871e+31   -7.760717570e+18   -6.908318646e+09   -2.241226812e-02   -5.412929349e-03]
+%!       [ -8.028450851e+58   -3.720929322e+46   -2.055758716e+30   -1.510304919e+18    4.978797221e-05   -7.048420407e-04]
+%!       [ -2.739192285e+78   -1.235021944e+63   -6.964109188e+42   -4.528227272e+27   -4.190000150e-02    1.074782297e-02]
+%!       [-6.683079463e+186  -2.655955830e+156  -1.799713983e+116   -8.573226309e+85   -1.125692891e+18   -2.298385049e-02]];
+%!
+%! n = [(0:5:20).';30;40;50;100];
+%! z = [1,2,5,10,50,100];
+%! j = sqrt((pi/2)./z).*besselj((n+1/2).',z.').';
+%! y = sqrt((pi/2)./z).*bessely((n+1/2).',z.').';
+%! assert(j, jt, -1e-9);
+%! assert(y, yt, -1e-9);
+
+
+
 */
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -41,22 +41,21 @@ Return the regularized incomplete Beta f
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
-@c spacing appears odd here, but is correct after Makeinfo\n\
-                                     x\n\
-                          1         /\n\
-betainc (x, a, b) = -----------    | t^(a-1) (1-t)^(b-1) dt.\n\
-                     beta (a, b)   /\n\
-                                t=0\n\
+                                   x\n\
+                          1       /\n\
+betainc (x, a, b) = -----------   | t^(a-1) (1-t)^(b-1) dt.\n\
+                    beta (a, b)   /\n\
+                               t=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -42,18 +42,18 @@ Compute the normalized incomplete gamma 
 $$\n\
  \\gamma (x, a) = {1 \\over {\\Gamma (a)}}\\displaystyle{\\int_0^x t^{a-1} e^{-t} dt}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-                                 x\n\
-                       1        /\n\
+                                x\n\
+                       1       /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
                   gamma (a)    /\n\
                             t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -636,17 +636,17 @@ Alternatively, use (?x) in the pattern.\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
   else if (args(0).is_cell () || args(1).is_cell ())
-    retval = octcellregexp (args, nargout, "regexp");
+    retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexp");
   else
     retval = octregexp (args, nargout, "regexp");
 
   return retval;
 }
 
 /*
 
@@ -764,20 +764,30 @@ Alternatively, use (?x) in the pattern.\
 %! assert (t{2}{1},'Rogers');
 %! assert (t{2}{2},'James');
 %! assert (size(nm), [1,1]);
 %! assert (nm.first{1},'John');
 %! assert (nm.first{2},'James');
 %! assert (nm.last{1},'Davis');
 %! assert (nm.last{2},'Rogers');
 
+## Tests for named tokens
 %!test
 %! # Parenthesis in named token (ie (int)) causes a problem
 %! assert (regexp('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
+%!test
+%! ## Mix of named and unnamed tokens can cause segfault (bug #35683)
+%! str = "abcde";
+%! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
+%! tokens = regexp (str, ptn, "names");
+%! assert (isstruct (tokens) && numel (tokens) == 1);
+%! assert (tokens.T1, "a");
+%! assert (tokens.T2, "de");
+
 %!assert(regexp("abc\nabc",'.'),[1:7])
 %!assert(regexp("abc\nabc",'.','dotall'),[1:7])
 %!test
 %! assert(regexp("abc\nabc",'(?s).'),[1:7])
 %! assert(regexp("abc\nabc",'.','dotexceptnewline'),[1,2,3,5,6,7])
 %! assert(regexp("abc\nabc",'(?-s).'),[1,2,3,5,6,7])
 
 %!assert(regexp("caseCaSe",'case'),1)
@@ -874,17 +884,17 @@ syntax of the search pattern.\n\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
   else if (args(0).is_cell () || args(1).is_cell ())
-    retval = octcellregexp (args, nargout, "regexpi", true);
+    retval = octcellregexp (args, (nargout > 0 ? nargout : 1), "regexpi", true);
   else
     retval = octregexp (args, nargout, "regexpi", true);
 
   return retval;
 }
 
 /*
 
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -371,9 +371,14 @@ Note also that @var{U} and @var{T} are n
 
 %!test
 %! A = rand (10);
 %! [u, t] = schur (A);
 %! [U, T] = rsf2csf (u, t);
 %! assert (norm (tril (T, -1)), 0)
 %! assert (norm (U * U'), 1, 1e-14)
 
+%!test
+%! A = [0, 1;-1, 0];
+%! [u, t] = schur (A);
+%! [U, T] = rsf2csf (u,t);
+%! assert (U * T * U', A, 1e-14)
 */
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -50,16 +50,21 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 #ifdef HAVE_CURL
 
 #include <curl/curl.h>
 #include <curl/curlver.h>
 #include <curl/easy.h>
 
+// Backwards compatibility for curl < 7.17.0
+#if LIBCURL_VERSION_NUM < 0x071100
+#define CURLOPT_DIRLISTONLY CURLOPT_FTPLISTONLY
+#endif
+
 static int
 write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
 {
   std::ostream& stream = *(static_cast<std::ostream*> (streamp));
   stream.write (static_cast<const char*> (buffer), size*nmemb);
   return (stream.fail () ? 0 : size * nmemb);
 }
 
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -15,21 +15,23 @@
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
+## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
-  @CPPFLAGS@ -I../libgnu -I$(top_srcdir)/libgnu \
+  -I../libgnu -I$(top_srcdir)/libgnu \
   -I$(top_srcdir)/libcruft/misc \
   -I../liboctave -I$(top_srcdir)/liboctave \
-  -I. -I$(srcdir)
+  -I. -I$(srcdir) \
+  @CPPFLAGS@
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 octlib_LTLIBRARIES = liboctinterp.la
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 bin_PROGRAMS = \
   mkoctfile \
@@ -514,17 +516,17 @@ include link-deps.mk
 
 liboctinterp_la_LIBADD = \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
   $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
 liboctinterp_current = 1
-liboctinterp_revision = 0
+liboctinterp_revision = 1
 liboctinterp_age = 0
 
 liboctinterp_version_info = $(liboctinterp_current):$(liboctinterp_revision):$(liboctinterp_age)
 
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
@@ -654,16 +656,17 @@ lex.lo lex.o oct-parse.lo oct-parse.o: \
   AM_CXXFLAGS := $(filter-out -Wold-style-cast, $(AM_CXXFLAGS))
 
 __fltk_uigetfile__.lo __fltk_uigetfile__.o: \
   AM_CXXFLAGS := $(filter-out $(DLL_CXXDEFS), $(AM_CXXFLAGS) $(GRAPHICS_CFLAGS))
 
 __init_fltk__.lo __init_fltk__.o: \
   AM_CXXFLAGS := $(filter-out $(DLL_CXXDEFS), $(AM_CXXFLAGS) $(GRAPHICS_CFLAGS))
 
+if AMCOND_BUILD_DOCS
 .DOCSTRINGS: gendoc$(BUILD_EXEEXT)
 	if [ "x$(srcdir)" != "x." ] && [ -f $(srcdir)/DOCSTRINGS ] && [ ! -f DOCSTRINGS ]; then \
 		cp $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 		touch -r $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 	fi
 	@echo "creating .DOCSTRINGS from .cc source files"
 	@./gendoc > $@
 	$(top_srcdir)/build-aux/move-if-change $@ DOCSTRINGS
@@ -676,16 +679,19 @@ doc-files: $(ALL_DEF_FILES)
 gendoc.cc: doc-files mkgendoc
 	$(srcdir)/mkgendoc doc-files > $@-t
 	mv $@-t $@
 
 gendoc$(BUILD_EXEEXT): gendoc.cc
 	$(BUILD_CXX) $(BUILD_CXXFLAGS) -o $@ $^ $(BUILD_LDFLAGS)
 
 all-local: $(OCT_STAMP_FILES) $(DLD_FUNCTIONS_PKG_ADD_FILE) .DOCSTRINGS
+else
+all-local: $(OCT_STAMP_FILES) $(DLD_FUNCTIONS_PKG_ADD_FILE)
+endif
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
 octave-config.cc: octave-config.cc.in Makefile
 	@$(do_subst_default_vals)
 
 mkoctfile.cc: mkoctfile.cc.in Makefile
 	@$(do_subst_config_vals)
 else
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -127,37 +127,35 @@ If the optional argument @var{dim} is su
 @var{dim}.\n\
 @seealso{any}\n\
 @end deftypefn")
 {
   ANY_ALL (all);
 }
 
 /*
-
 %!test
 %! x = ones (3);
 %! x(1,1) = 0;
-%! assert((all (all (rand (3) + 1) == [1, 1, 1]) == 1
-%! && all (all (x) == [0, 1, 1]) == 1
-%! && all (x, 1) == [0, 1, 1]
-%! && all (x, 2) == [0; 1; 1]));
+%! assert (all (all (rand (3) + 1) == [1, 1, 1]) == 1);
+%! assert (all (all (x) == [0, 1, 1]) == 1);
+%! assert (all (x, 1) == [0, 1, 1]);
+%! assert (all (x, 2) == [0; 1; 1]);
 
 %!test
-%! x = ones (3, 'single');
+%! x = ones (3, "single");
 %! x(1,1) = 0;
-%! assert((all (all (single (rand (3) + 1)) == [1, 1, 1]) == 1
-%! && all (all (x) == [0, 1, 1]) == 1
-%! && all (x, 1) == [0, 1, 1]
-%! && all (x, 2) == [0; 1; 1]));
-
-%!error <Invalid call to all> all ();
-%!error <Invalid call to all> all (1, 2, 3);
-
- */
+%! assert (all (all (single (rand (3) + 1)) == [1, 1, 1]) == 1);
+%! assert (all (all (x) == [0, 1, 1]) == 1);
+%! assert (all (x, 1) == [0, 1, 1]);
+%! assert (all (x, 2) == [0; 1; 1]);
+
+%!error all ()
+%!error all (1, 2, 3)
+*/
 
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} any (@var{x})\n\
 @deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if any element of the vector\n\
 is nonzero.\n\
 \n\
@@ -183,37 +181,35 @@ any (eye (2, 4), 2)\n\
 @end example\n\
 @seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
 /*
-
 %!test
 %! x = zeros (3);
 %! x(3,3) = 1;
-%! assert((all (any (x) == [0, 0, 1]) == 1
-%! && all (any (ones (3)) == [1, 1, 1]) == 1
-%! && any (x, 1) == [0, 0, 1]
-%! && any (x, 2) == [0; 0; 1]));
+%! assert (all (any (x) == [0, 0, 1]) == 1);
+%! assert (all (any (ones (3)) == [1, 1, 1]) == 1);
+%! assert (any (x, 1) == [0, 0, 1]);
+%! assert (any (x, 2) == [0; 0; 1]);
 
 %!test
-%! x = zeros (3,'single');
+%! x = zeros (3, "single");
 %! x(3,3) = 1;
-%! assert((all (any (x) == [0, 0, 1]) == 1
-%! && all (any (ones (3, 'single')) == [1, 1, 1]) == 1
-%! && any (x, 1) == [0, 0, 1]
-%! && any (x, 2) == [0; 0; 1]));
-
-%!error <Invalid call to any> any ();
-%!error <Invalid call to any> any (1, 2, 3);
-
- */
+%! assert (all (any (x) == [0, 0, 1]) == 1);
+%! assert (all (any (ones (3, "single")) == [1, 1, 1]) == 1);
+%! assert (any (x, 1) == [0, 0, 1]);
+%! assert (any (x, 2) == [0; 0; 1]);
+
+%!error any ()
+%!error any (1, 2, 3)
+*/
 
 // These mapping functions may also be useful in other places, eh?
 
 DEFUN (atan2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.  Signal an error if @var{y} and @var{x} do not match in size\n\
@@ -278,29 +274,28 @@ and orientation.\n\
 %!assert (size (atan2 (1, 2)), [1, 1])
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
 %! y = [0, rt3, 1, rt3, -rt3, -1, -rt3, 0];
 %! x = [1, 3, 1, 1, 1, 1, 3, 1];
-%! assert(atan2 (y, x), v, sqrt (eps));
+%! assert (atan2 (y, x), v, sqrt (eps));
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! v = single([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
-%! y = single([0, rt3, 1, rt3, -rt3, -1, -rt3, 0]);
-%! x = single([1, 3, 1, 1, 1, 1, 3, 1]);
-%! assert(atan2 (y, x), v, sqrt (eps('single')));
-
-%!error <Invalid call to atan2> atan2 ();
-%!error <Invalid call to atan2> atan2 (1, 2, 3);
-
+%! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
+%! y = single ([0, rt3, 1, rt3, -rt3, -1, -rt3, 0]);
+%! x = single ([1, 3, 1, 1, 1, 1, 3, 1]);
+%! assert (atan2 (y, x), v, sqrt (eps ("single")));
+
+%!error atan2 ()
+%!error atan2 (1, 2, 3)
 */
 
 
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
@@ -392,18 +387,18 @@ hypot (hypot (hypot (@var{x}, @var{y}), 
 }
 
 /*
 %!assert (size (hypot (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (hypot (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (hypot (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (1, 2)), [1, 1])
-%!assert (hypot (1:10, 1:10), sqrt(2) * [1:10], 16*eps)
-%!assert (hypot (single(1:10), single(1:10)), single(sqrt(2) * [1:10]));
+%!assert (hypot (1:10, 1:10), sqrt (2) * [1:10], 16*eps)
+%!assert (hypot (single (1:10), single (1:10)), single (sqrt (2) * [1:10]))
 */
 
 template<typename T, typename ET>
 void
 map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
 {
   f = Array<T>(x.dims ());
   e = Array<ET>(x.dims ());
@@ -493,26 +488,26 @@ and @var{e} is an integer.  If\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
-%!assert(log2(Inf), Inf);
-%!assert(isnan(log2(NaN)));
-%!assert(log2(4*i), 2 + log2(1*i));
-%!assert(log2(complex(0,Inf)), Inf + log2(i));
+%!assert (log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2])
+%!assert (log2 (Inf), Inf)
+%!assert (isnan (log2 (NaN)))
+%!assert (log2 (4*i), 2 + log2 (1*i))
+%!assert (log2 (complex (0,Inf)), Inf + log2 (i))
 
 %!test
 %! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
 %! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
-%! assert (e(1:2,:), [0,1;2,3])
+%! assert (e(1:2,:), [0,1;2,3]);
 
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 */
 
 DEFUN (rem, args, ,
@@ -615,31 +610,31 @@ agree, or if either of the arguments is 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(rem ([1, 2, 3; -1, -2, -3], 2), [1, 0, 1; -1, 0, -1]);
-%!assert(rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3)),[1, 0, 1; -1, 0, -1]);
-%!error rem ();
-%!error rem (1, 2, 3);
-%!error rem ([1, 2], [3, 4, 5]);
-%!error rem (i, 1);
-%!assert(rem (uint8([1, 2, 3; -1, -2, -3]), uint8 (2)), uint8([1, 0, 1; -1, 0, -1]));
-%!assert(uint8(rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3))),uint8([1, 0, 1; -1, 0, -1]));
-%!error rem (uint(8),int8(5));
-%!error rem (uint8([1, 2]), uint8([3, 4, 5]));
-
+%!assert (rem ([1, 2, 3; -1, -2, -3], 2), [1, 0, 1; -1, 0, -1])
+%!assert (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3)),[1, 0, 1; -1, 0, -1])
+%!assert (rem (uint8 ([1, 2, 3; -1, -2, -3]), uint8 (2)), uint8 ([1, 0, 1; -1, 0, -1]))
+%!assert (uint8 (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3))),uint8 ([1, 0, 1; -1, 0, -1]))
+
+%!error rem (uint (8), int8 (5))
+%!error rem (uint8 ([1, 2]), uint8 ([3, 4, 5]))
+%!error rem ()
+%!error rem (1, 2, 3)
+%!error rem ([1, 2], [3, 4, 5])
+%!error rem (i, 1)
 */
 
 /*
+
 %!assert (size (fmod (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (fmod (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (fmod (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (fmod (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (fmod (1, 2)), [1, 1])
 */
 
 DEFALIAS (fmod, rem)
@@ -749,58 +744,58 @@ either of the arguments is complex.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 ## empty input test
-%!assert (isempty(mod([], [])));
+%!assert (isempty (mod ([], [])))
 
 ## x mod y, y != 0 tests
-%!assert (mod(5, 3), 2);
-%!assert (mod(-5, 3), 1);
-%!assert (mod(0, 3), 0);
-%!assert (mod([-5, 5, 0], [3, 3, 3]), [1, 2, 0]);
-%!assert (mod([-5; 5; 0], [3; 3; 3]), [1; 2; 0]);
-%!assert (mod([-5, 5; 0, 3], [3, 3 ; 3, 1]), [1, 2 ; 0, 0]);
+%!assert (mod (5, 3), 2)
+%!assert (mod (-5, 3), 1)
+%!assert (mod (0, 3), 0)
+%!assert (mod ([-5, 5, 0], [3, 3, 3]), [1, 2, 0])
+%!assert (mod ([-5; 5; 0], [3; 3; 3]), [1; 2; 0])
+%!assert (mod ([-5, 5; 0, 3], [3, 3 ; 3, 1]), [1, 2 ; 0, 0])
 
 ## x mod 0 tests
-%!assert (mod(5, 0), 5);
-%!assert (mod(-5, 0), -5);
-%!assert (mod([-5, 5, 0], [3, 0, 3]), [1, 5, 0]);
-%!assert (mod([-5; 5; 0], [3; 0; 3]), [1; 5; 0]);
-%!assert (mod([-5, 5; 0, 3], [3, 0 ; 3, 1]), [1, 5 ; 0, 0]);
-%!assert (mod([-5, 5; 0, 3], [0, 0 ; 0, 0]), [-5, 5; 0, 3]);
+%!assert (mod (5, 0), 5)
+%!assert (mod (-5, 0), -5)
+%!assert (mod ([-5, 5, 0], [3, 0, 3]), [1, 5, 0])
+%!assert (mod ([-5; 5; 0], [3; 0; 3]), [1; 5; 0])
+%!assert (mod ([-5, 5; 0, 3], [3, 0 ; 3, 1]), [1, 5 ; 0, 0])
+%!assert (mod ([-5, 5; 0, 3], [0, 0 ; 0, 0]), [-5, 5; 0, 3])
 
 ## mixed scalar/matrix tests
-%!assert (mod([-5, 5; 0, 3], 0), [-5, 5; 0, 3]);
-%!assert (mod([-5, 5; 0, 3], 3), [1, 2; 0, 0]);
-%!assert (mod(-5,[0,0; 0,0]), [-5, -5; -5, -5]);
-%!assert (mod(-5,[3,0; 3,1]), [1, -5; 1, 0]);
-%!assert (mod(-5,[3,2; 3,1]), [1, 1; 1, 0]);
+%!assert (mod ([-5, 5; 0, 3], 0), [-5, 5; 0, 3])
+%!assert (mod ([-5, 5; 0, 3], 3), [1, 2; 0, 0])
+%!assert (mod (-5, [0,0; 0,0]), [-5, -5; -5, -5])
+%!assert (mod (-5, [3,0; 3,1]), [1, -5; 1, 0])
+%!assert (mod (-5, [3,2; 3,1]), [1, 1; 1, 0])
 
 ## integer types
-%!assert (mod(uint8(5),uint8(4)),uint8(1))
-%!assert (mod(uint8([1:5]),uint8(4)),uint8([1,2,3,0,1]))
-%!assert (mod(uint8([1:5]),uint8(0)),uint8([1:5]))
-%!error (mod(uint8(5),int8(4)))
+%!assert (mod (uint8 (5), uint8 (4)), uint8 (1))
+%!assert (mod (uint8 ([1:5]), uint8 (4)), uint8 ([1,2,3,0,1]))
+%!assert (mod (uint8 ([1:5]), uint8 (0)), uint8 ([1:5]))
+%!error (mod (uint8 (5), int8 (4)))
 
 ## mixed integer/real types
-%!assert (mod(uint8(5),4),uint8(1))
-%!assert (mod(5,uint8(4)),uint8(1))
-%!assert (mod(uint8([1:5]),4),uint8([1,2,3,0,1]))
+%!assert (mod (uint8 (5), 4), uint8 (1))
+%!assert (mod (5, uint8 (4)), uint8 (1))
+%!assert (mod (uint8 ([1:5]), 4), uint8 ([1,2,3,0,1]))
 
 ## non-integer real numbers
 %!assert (mod (2.1, 0.1), 0)
 %!assert (mod (2.1, 0.2), 0.1, eps)
 */
 
-// FIXME Need to convert the reduction functions of this file for single precision
+// FIXME: Need to convert the reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
       \
       if (! error_state) \
         { \
@@ -1063,36 +1058,34 @@ Cumulative product of elements along dim
 \n\
 @seealso{prod, cumsum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumprod);
 }
 
 /*
-
-%!assert (cumprod ([1, 2, 3]), [1, 2, 6]);
-%!assert (cumprod ([-1; -2; -3]), [-1; 2; -6]);
-%!assert (cumprod ([i, 2+i, -3+2i, 4]), [i, -1+2i, -1-8i, -4-32i]);
-%!assert (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]);
-
-%!assert (cumprod (single([1, 2, 3])), single([1, 2, 6]));
-%!assert (cumprod (single([-1; -2; -3])), single([-1; 2; -6]));
-%!assert (cumprod (single([i, 2+i, -3+2i, 4])), single([i, -1+2i, -1-8i, -4-32i]));
-%!assert (cumprod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]));
-
-%!error <Invalid call to cumprod> cumprod ();
-
-%!assert (cumprod ([2, 3; 4, 5], 1), [2, 3; 8, 15]);
-%!assert (cumprod ([2, 3; 4, 5], 2), [2, 6; 4, 20]);
-
-%!assert (cumprod (single([2, 3; 4, 5]), 1), single([2, 3; 8, 15]));
-%!assert (cumprod (single([2, 3; 4, 5]), 2), single([2, 6; 4, 20]));
-
- */
+%!assert (cumprod ([1, 2, 3]), [1, 2, 6])
+%!assert (cumprod ([-1; -2; -3]), [-1; 2; -6])
+%!assert (cumprod ([i, 2+i, -3+2i, 4]), [i, -1+2i, -1-8i, -4-32i])
+%!assert (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i])
+
+%!assert (cumprod (single ([1, 2, 3])), single ([1, 2, 6]))
+%!assert (cumprod (single ([-1; -2; -3])), single ([-1; 2; -6]))
+%!assert (cumprod (single ([i, 2+i, -3+2i, 4])), single ([i, -1+2i, -1-8i, -4-32i]))
+%!assert (cumprod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]))
+
+%!assert (cumprod ([2, 3; 4, 5], 1), [2, 3; 8, 15])
+%!assert (cumprod ([2, 3; 4, 5], 2), [2, 6; 4, 20])
+
+%!assert (cumprod (single ([2, 3; 4, 5]), 1), single ([2, 3; 8, 15]))
+%!assert (cumprod (single ([2, 3; 4, 5]), 2), single ([2, 6; 4, 20]))
+
+%!error cumprod ()
+*/
 
 DEFUN (cumsum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
@@ -1214,36 +1207,34 @@ See @code{sum} for an explanation of the
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (cumsum ([1, 2, 3]), [1, 3, 6]);
-%!assert (cumsum ([-1; -2; -3]), [-1; -3; -6]);
-%!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i]);
-%!assert (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]);
-
-%!assert (cumsum (single([1, 2, 3])), single([1, 3, 6]));
-%!assert (cumsum (single([-1; -2; -3])), single([-1; -3; -6]));
-%!assert (cumsum (single([i, 2+i, -3+2i, 4])), single([i, 2+2i, -1+4i, 3+4i]));
-%!assert (cumsum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]));
-
-%!error <Invalid call to cumsum> cumsum ();
-
-%!assert (cumsum ([1, 2; 3, 4], 1), [1, 2; 4, 6]);
-%!assert (cumsum ([1, 2; 3, 4], 2), [1, 3; 3, 7]);
-
-%!assert (cumsum (single([1, 2; 3, 4]), 1), single([1, 2; 4, 6]));
-%!assert (cumsum (single([1, 2; 3, 4]), 2), single([1, 3; 3, 7]));
-
- */
+%!assert (cumsum ([1, 2, 3]), [1, 3, 6])
+%!assert (cumsum ([-1; -2; -3]), [-1; -3; -6])
+%!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i])
+%!assert (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i])
+
+%!assert (cumsum (single ([1, 2, 3])), single ([1, 3, 6]))
+%!assert (cumsum (single ([-1; -2; -3])), single ([-1; -3; -6]))
+%!assert (cumsum (single ([i, 2+i, -3+2i, 4])), single ([i, 2+2i, -1+4i, 3+4i]))
+%!assert (cumsum (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]))
+
+%!assert (cumsum ([1, 2; 3, 4], 1), [1, 2; 4, 6])
+%!assert (cumsum ([1, 2; 3, 4], 2), [1, 3; 3, 7])
+
+%!assert (cumsum (single ([1, 2; 3, 4]), 1), single ([1, 2; 4, 6]))
+%!assert (cumsum (single ([1, 2; 3, 4]), 2), single ([1, 3; 3, 7]))
+
+%!error cumsum ()
+*/
 
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{M} =} diag (@var{v})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{k})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M}, @var{k})\n\
@@ -1303,114 +1294,110 @@ Given a matrix argument, instead of a ve
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3]);
-%!assert(diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]);
-%!assert(diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]);
-%!assert(diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]);
-%!assert(diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]);
-
-%!assert(diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3]);
-%!assert(diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3]);
-%!assert(diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3]);
-%!assert(diag (ones(1, 0), 2), zeros (2));
-%!assert(diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0]);
-
-%!assert(full (diag (single([1; 2; 3]))), single([1, 0, 0; 0, 2, 0; 0, 0, 3]));
-%!assert(diag (single([1; 2; 3]), 1), single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
-%!assert(diag (single([1; 2; 3]), 2), single([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
-%!assert(diag (single([1; 2; 3]),-1), single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
-%!assert(diag (single([1; 2; 3]),-2), single([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
-
-%!assert(diag (single([1, 0, 0; 0, 2, 0; 0, 0, 3])), single([1; 2; 3]));
-%!assert(diag (single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single([1; 2; 3]));
-%!assert(diag (single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single([1; 2; 3]));
-
-%!assert(diag (int8([1; 2; 3])), int8([1, 0, 0; 0, 2, 0; 0, 0, 3]));
-%!assert(diag (int8([1; 2; 3]), 1), int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
-%!assert(diag (int8([1; 2; 3]), 2), int8([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
-%!assert(diag (int8([1; 2; 3]),-1), int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
-%!assert(diag (int8([1; 2; 3]),-2), int8([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
-
-%!assert(diag (int8([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8([1; 2; 3]));
-%!assert(diag (int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8([1; 2; 3]));
-%!assert(diag (int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8([1; 2; 3]));
-
-%% Test input validation
-%!error <Invalid call to diag> diag ();
-%!error <Invalid call to diag> diag (1,2,3,4);
-%!error diag (ones (2), 3, 3);
-%!error diag (1:3, -4, 3);
-
- */
+%!assert (full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
+%!assert (diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0])
+%!assert (diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0])
+
+%!assert (diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3])
+%!assert (diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3])
+%!assert (diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3])
+%!assert (diag (ones (1, 0), 2), zeros (2))
+%!assert (diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0])
+
+%!assert (full (diag (single ([1; 2; 3]))), single ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (single ([1; 2; 3]), 1), single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]), 2), single ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]),-1), single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (single ([1; 2; 3]),-2), single ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (single ([1, 0, 0; 0, 2, 0; 0, 0, 3])), single ([1; 2; 3]))
+%!assert (diag (single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single ([1; 2; 3]))
+%!assert (diag (single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single ([1; 2; 3]))
+
+%!assert (diag (int8 ([1; 2; 3])), int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (int8 ([1; 2; 3]), 1), int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
+
+## Test input validation
+%!error diag ()
+%!error diag (1,2,3,4)
+%!error diag (ones (2), 3, 3)
+%!error diag (1:3, -4, 3)
+*/
 
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} prod (@var{x})\n\
 @deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 @seealso{cumprod, sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (prod);
 }
 
 /*
-
-%!assert (prod ([1, 2, 3]), 6);
-%!assert (prod ([-1; -2; -3]), -6);
-%!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i);
-%!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i]);
-
-%!assert (prod (single([1, 2, 3])), single(6));
-%!assert (prod (single([-1; -2; -3])), single(-6));
-%!assert (prod (single([i, 2+i, -3+2i, 4])), single(-4 - 32i));
-%!assert (prod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([-1+i, -8+8i, -27+27i]));
-
-%!error <Invalid call to prod> prod ();
-
-%!assert (prod ([1, 2; 3, 4], 1), [3, 8]);
-%!assert (prod ([1, 2; 3, 4], 2), [2; 12]);
-%!assert (prod (zeros (1, 0)), 1);
-%!assert (prod (zeros (1, 0), 1), zeros (1, 0));
-%!assert (prod (zeros (1, 0), 2), 1);
-%!assert (prod (zeros (0, 1)), 1);
-%!assert (prod (zeros (0, 1), 1), 1);
-%!assert (prod (zeros (0, 1), 2), zeros (0, 1));
-%!assert (prod (zeros (2, 0)), zeros (1, 0));
-%!assert (prod (zeros (2, 0), 1), zeros (1, 0));
-%!assert (prod (zeros (2, 0), 2), [1; 1]);
-%!assert (prod (zeros (0, 2)), [1, 1]);
-%!assert (prod (zeros (0, 2), 1), [1, 1]);
-%!assert (prod (zeros (0, 2), 2), zeros(0, 1));
-
-%!assert (prod (single([1, 2; 3, 4]), 1), single([3, 8]));
-%!assert (prod (single([1, 2; 3, 4]), 2), single([2; 12]));
-%!assert (prod (zeros (1, 0, 'single')), single(1));
-%!assert (prod (zeros (1, 0, 'single'), 1), zeros (1, 0, 'single'));
-%!assert (prod (zeros (1, 0, 'single'), 2), single(1));
-%!assert (prod (zeros (0, 1, 'single')), single(1));
-%!assert (prod (zeros (0, 1, 'single'), 1), single(1));
-%!assert (prod (zeros (0, 1, 'single'), 2), zeros (0, 1, 'single'));
-%!assert (prod (zeros (2, 0, 'single')), zeros (1, 0, 'single'));
-%!assert (prod (zeros (2, 0, 'single'), 1), zeros (1, 0, 'single'));
-%!assert (prod (zeros (2, 0, 'single'), 2), single([1; 1]));
-%!assert (prod (zeros (0, 2, 'single')), single([1, 1]));
-%!assert (prod (zeros (0, 2, 'single'), 1), single([1, 1]));
-%!assert (prod (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
-
- */
+%!assert (prod ([1, 2, 3]), 6)
+%!assert (prod ([-1; -2; -3]), -6)
+%!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i)
+%!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i])
+
+%!assert (prod (single ([1, 2, 3])), single (6))
+%!assert (prod (single ([-1; -2; -3])), single (-6))
+%!assert (prod (single ([i, 2+i, -3+2i, 4])), single (-4 - 32i))
+%!assert (prod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([-1+i, -8+8i, -27+27i]))
+
+%!assert (prod ([1, 2; 3, 4], 1), [3, 8])
+%!assert (prod ([1, 2; 3, 4], 2), [2; 12])
+%!assert (prod (zeros (1, 0)), 1)
+%!assert (prod (zeros (1, 0), 1), zeros (1, 0))
+%!assert (prod (zeros (1, 0), 2), 1)
+%!assert (prod (zeros (0, 1)), 1)
+%!assert (prod (zeros (0, 1), 1), 1)
+%!assert (prod (zeros (0, 1), 2), zeros (0, 1))
+%!assert (prod (zeros (2, 0)), zeros (1, 0))
+%!assert (prod (zeros (2, 0), 1), zeros (1, 0))
+%!assert (prod (zeros (2, 0), 2), [1; 1])
+%!assert (prod (zeros (0, 2)), [1, 1])
+%!assert (prod (zeros (0, 2), 1), [1, 1])
+%!assert (prod (zeros (0, 2), 2), zeros (0, 1))
+
+%!assert (prod (single ([1, 2; 3, 4]), 1), single ([3, 8]))
+%!assert (prod (single ([1, 2; 3, 4]), 2), single ([2; 12]))
+%!assert (prod (zeros (1, 0, "single")), single (1))
+%!assert (prod (zeros (1, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (prod (zeros (1, 0, "single"), 2), single (1))
+%!assert (prod (zeros (0, 1, "single")), single (1))
+%!assert (prod (zeros (0, 1, "single"), 1), single (1))
+%!assert (prod (zeros (0, 1, "single"), 2), zeros (0, 1, "single"))
+%!assert (prod (zeros (2, 0, "single")), zeros (1, 0, "single"))
+%!assert (prod (zeros (2, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (prod (zeros (2, 0, "single"), 2), single ([1; 1]))
+%!assert (prod (zeros (0, 2, "single")), single ([1, 1]))
+%!assert (prod (zeros (0, 2, "single"), 1), single ([1, 1]))
+%!assert (prod (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
+
+%!error prod ()
+*/
 
 static bool
 all_scalar_1x1 (const octave_value_list& args)
 {
   int n_args = args.length ();
   for (int i = 0; i < n_args; i++)
     if (args(i).numel () != 1)
       return false;
@@ -1870,204 +1857,205 @@ new matrices.  For example:\n\
 @end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 /*
-%% test concatenation with all zero matrices
-%!assert(horzcat ('', 65*ones(1,10)), 'AAAAAAAAAA');
-%!assert(horzcat (65*ones(1,10), ''), 'AAAAAAAAAA');
-
-%!assert (class (horzcat (int64(1), int64(1))), 'int64')
-%!assert (class (horzcat (int64(1), int32(1))), 'int64')
-%!assert (class (horzcat (int64(1), int16(1))), 'int64')
-%!assert (class (horzcat (int64(1), int8(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint64(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint32(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint16(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint8(1))), 'int64')
-%!assert (class (horzcat (int64(1), single(1))), 'int64')
-%!assert (class (horzcat (int64(1), double(1))), 'int64')
-%!assert (class (horzcat (int64(1), cell(1))), 'cell')
-%!assert (class (horzcat (int64(1), true)), 'int64')
-%!assert (class (horzcat (int64(1), 'a')), 'char')
-
-%!assert (class (horzcat (int32(1), int64(1))), 'int32')
-%!assert (class (horzcat (int32(1), int32(1))), 'int32')
-%!assert (class (horzcat (int32(1), int16(1))), 'int32')
-%!assert (class (horzcat (int32(1), int8(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint64(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint32(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint16(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint8(1))), 'int32')
-%!assert (class (horzcat (int32(1), single(1))), 'int32')
-%!assert (class (horzcat (int32(1), double(1))), 'int32')
-%!assert (class (horzcat (int32(1), cell(1))), 'cell')
-%!assert (class (horzcat (int32(1), true)), 'int32')
-%!assert (class (horzcat (int32(1), 'a')), 'char')
-
-%!assert (class (horzcat (int16(1), int64(1))), 'int16')
-%!assert (class (horzcat (int16(1), int32(1))), 'int16')
-%!assert (class (horzcat (int16(1), int16(1))), 'int16')
-%!assert (class (horzcat (int16(1), int8(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint64(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint32(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint16(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint8(1))), 'int16')
-%!assert (class (horzcat (int16(1), single(1))), 'int16')
-%!assert (class (horzcat (int16(1), double(1))), 'int16')
-%!assert (class (horzcat (int16(1), cell(1))), 'cell')
-%!assert (class (horzcat (int16(1), true)), 'int16')
-%!assert (class (horzcat (int16(1), 'a')), 'char')
-
-%!assert (class (horzcat (int8(1), int64(1))), 'int8')
-%!assert (class (horzcat (int8(1), int32(1))), 'int8')
-%!assert (class (horzcat (int8(1), int16(1))), 'int8')
-%!assert (class (horzcat (int8(1), int8(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint64(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint32(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint16(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint8(1))), 'int8')
-%!assert (class (horzcat (int8(1), single(1))), 'int8')
-%!assert (class (horzcat (int8(1), double(1))), 'int8')
-%!assert (class (horzcat (int8(1), cell(1))), 'cell')
-%!assert (class (horzcat (int8(1), true)), 'int8')
-%!assert (class (horzcat (int8(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint64(1), int64(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int32(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int16(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int8(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint32(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint16(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint8(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), single(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), double(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint64(1), true)), 'uint64')
-%!assert (class (horzcat (uint64(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint32(1), int64(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int32(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int16(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int8(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint64(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint16(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint8(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), single(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), double(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint32(1), true)), 'uint32')
-%!assert (class (horzcat (uint32(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint16(1), int64(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int32(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int16(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int8(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint64(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint32(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint8(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), single(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), double(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint16(1), true)), 'uint16')
-%!assert (class (horzcat (uint16(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint8(1), int64(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int32(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int16(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int8(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint64(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint32(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint16(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), single(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), double(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint8(1), true)), 'uint8')
-%!assert (class (horzcat (uint8(1), 'a')), 'char')
-
-%!assert (class (horzcat (single(1), int64(1))), 'int64')
-%!assert (class (horzcat (single(1), int32(1))), 'int32')
-%!assert (class (horzcat (single(1), int16(1))), 'int16')
-%!assert (class (horzcat (single(1), int8(1))), 'int8')
-%!assert (class (horzcat (single(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (single(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (single(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (single(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (single(1), single(1))), 'single')
-%!assert (class (horzcat (single(1), double(1))), 'single')
-%!assert (class (horzcat (single(1), cell(1))), 'cell')
-%!assert (class (horzcat (single(1), true)), 'single')
-%!assert (class (horzcat (single(1), 'a')), 'char')
-
-%!assert (class (horzcat (double(1), int64(1))), 'int64')
-%!assert (class (horzcat (double(1), int32(1))), 'int32')
-%!assert (class (horzcat (double(1), int16(1))), 'int16')
-%!assert (class (horzcat (double(1), int8(1))), 'int8')
-%!assert (class (horzcat (double(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (double(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (double(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (double(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (double(1), single(1))), 'single')
-%!assert (class (horzcat (double(1), double(1))), 'double')
-%!assert (class (horzcat (double(1), cell(1))), 'cell')
-%!assert (class (horzcat (double(1), true)), 'double')
-%!assert (class (horzcat (double(1), 'a')), 'char')
-
-%!assert (class (horzcat (cell(1), int64(1))), 'cell')
-%!assert (class (horzcat (cell(1), int32(1))), 'cell')
-%!assert (class (horzcat (cell(1), int16(1))), 'cell')
-%!assert (class (horzcat (cell(1), int8(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint64(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint32(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint16(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint8(1))), 'cell')
-%!assert (class (horzcat (cell(1), single(1))), 'cell')
-%!assert (class (horzcat (cell(1), double(1))), 'cell')
-%!assert (class (horzcat (cell(1), cell(1))), 'cell')
-%!assert (class (horzcat (cell(1), true)), 'cell')
-%!assert (class (horzcat (cell(1), 'a')), 'cell')
-
-%!assert (class (horzcat (true, int64(1))), 'int64')
-%!assert (class (horzcat (true, int32(1))), 'int32')
-%!assert (class (horzcat (true, int16(1))), 'int16')
-%!assert (class (horzcat (true, int8(1))), 'int8')
-%!assert (class (horzcat (true, uint64(1))), 'uint64')
-%!assert (class (horzcat (true, uint32(1))), 'uint32')
-%!assert (class (horzcat (true, uint16(1))), 'uint16')
-%!assert (class (horzcat (true, uint8(1))), 'uint8')
-%!assert (class (horzcat (true, single(1))), 'single')
-%!assert (class (horzcat (true, double(1))), 'double')
-%!assert (class (horzcat (true, cell(1))), 'cell')
-%!assert (class (horzcat (true, true)), 'logical')
-%!assert (class (horzcat (true, 'a')), 'char')
-
-%!assert (class (horzcat ('a', int64(1))), 'char')
-%!assert (class (horzcat ('a', int32(1))), 'char')
-%!assert (class (horzcat ('a', int16(1))), 'char')
-%!assert (class (horzcat ('a', int8(1))), 'char')
-%!assert (class (horzcat ('a', int64(1))), 'char')
-%!assert (class (horzcat ('a', int32(1))), 'char')
-%!assert (class (horzcat ('a', int16(1))), 'char')
-%!assert (class (horzcat ('a', int8(1))), 'char')
-%!assert (class (horzcat ('a', single(1))), 'char')
-%!assert (class (horzcat ('a', double(1))), 'char')
-%!assert (class (horzcat ('a', cell(1))), 'cell')
-%!assert (class (horzcat ('a', true)), 'char')
-%!assert (class (horzcat ('a', 'a')), 'char')
-
-%!assert (class (horzcat (cell(1), struct('foo', 'bar'))), 'cell')
-%!error horzcat (struct('foo', 'bar'), cell(1));
+## Test concatenation with all zero matrices
+%!assert (horzcat ("", 65*ones (1,10)), "AAAAAAAAAA");
+%!assert (horzcat (65*ones (1,10), ""), "AAAAAAAAAA");
+
+%!assert (class (horzcat (int64 (1), int64 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int32 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int16 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int8 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint64 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint32 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint16 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint8 (1))), "int64")
+%!assert (class (horzcat (int64 (1), single (1))), "int64")
+%!assert (class (horzcat (int64 (1), double (1))), "int64")
+%!assert (class (horzcat (int64 (1), cell (1))), "cell")
+%!assert (class (horzcat (int64 (1), true)), "int64")
+%!assert (class (horzcat (int64 (1), "a")), "char")
+
+%!assert (class (horzcat (int32 (1), int64 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int32 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int16 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int8 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint64 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint32 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint16 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint8 (1))), "int32")
+%!assert (class (horzcat (int32 (1), single (1))), "int32")
+%!assert (class (horzcat (int32 (1), double (1))), "int32")
+%!assert (class (horzcat (int32 (1), cell (1))), "cell")
+%!assert (class (horzcat (int32 (1), true)), "int32")
+%!assert (class (horzcat (int32 (1), "a")), "char")
+
+%!assert (class (horzcat (int16 (1), int64 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int32 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int16 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int8 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint64 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint32 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint16 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint8 (1))), "int16")
+%!assert (class (horzcat (int16 (1), single (1))), "int16")
+%!assert (class (horzcat (int16 (1), double (1))), "int16")
+%!assert (class (horzcat (int16 (1), cell (1))), "cell")
+%!assert (class (horzcat (int16 (1), true)), "int16")
+%!assert (class (horzcat (int16 (1), "a")), "char")
+
+%!assert (class (horzcat (int8 (1), int64 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int32 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int16 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int8 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint64 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint32 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint16 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint8 (1))), "int8")
+%!assert (class (horzcat (int8 (1), single (1))), "int8")
+%!assert (class (horzcat (int8 (1), double (1))), "int8")
+%!assert (class (horzcat (int8 (1), cell (1))), "cell")
+%!assert (class (horzcat (int8 (1), true)), "int8")
+%!assert (class (horzcat (int8 (1), "a")), "char")
+
+%!assert (class (horzcat (uint64 (1), int64 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int32 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int16 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int8 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint32 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint16 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint8 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), single (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), double (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint64 (1), true)), "uint64")
+%!assert (class (horzcat (uint64 (1), "a")), "char")
+
+%!assert (class (horzcat (uint32 (1), int64 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int32 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int16 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int8 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint64 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint16 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint8 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), single (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), double (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint32 (1), true)), "uint32")
+%!assert (class (horzcat (uint32 (1), "a")), "char")
+
+%!assert (class (horzcat (uint16 (1), int64 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int32 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int16 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int8 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint64 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint32 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint8 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), single (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), double (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint16 (1), true)), "uint16")
+%!assert (class (horzcat (uint16 (1), "a")), "char")
+
+%!assert (class (horzcat (uint8 (1), int64 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int32 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int16 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int8 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint64 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint32 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint16 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), single (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), double (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint8 (1), true)), "uint8")
+%!assert (class (horzcat (uint8 (1), "a")), "char")
+
+%!assert (class (horzcat (single (1), int64 (1))), "int64")
+%!assert (class (horzcat (single (1), int32 (1))), "int32")
+%!assert (class (horzcat (single (1), int16 (1))), "int16")
+%!assert (class (horzcat (single (1), int8 (1))), "int8")
+%!assert (class (horzcat (single (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (single (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (single (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (single (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (single (1), single (1))), "single")
+%!assert (class (horzcat (single (1), double (1))), "single")
+%!assert (class (horzcat (single (1), cell (1))), "cell")
+%!assert (class (horzcat (single (1), true)), "single")
+%!assert (class (horzcat (single (1), "a")), "char")
+
+%!assert (class (horzcat (double (1), int64 (1))), "int64")
+%!assert (class (horzcat (double (1), int32 (1))), "int32")
+%!assert (class (horzcat (double (1), int16 (1))), "int16")
+%!assert (class (horzcat (double (1), int8 (1))), "int8")
+%!assert (class (horzcat (double (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (double (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (double (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (double (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (double (1), single (1))), "single")
+%!assert (class (horzcat (double (1), double (1))), "double")
+%!assert (class (horzcat (double (1), cell (1))), "cell")
+%!assert (class (horzcat (double (1), true)), "double")
+%!assert (class (horzcat (double (1), "a")), "char")
+
+%!assert (class (horzcat (cell (1), int64 (1))), "cell")
+%!assert (class (horzcat (cell (1), int32 (1))), "cell")
+%!assert (class (horzcat (cell (1), int16 (1))), "cell")
+%!assert (class (horzcat (cell (1), int8 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint64 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint32 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint16 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint8 (1))), "cell")
+%!assert (class (horzcat (cell (1), single (1))), "cell")
+%!assert (class (horzcat (cell (1), double (1))), "cell")
+%!assert (class (horzcat (cell (1), cell (1))), "cell")
+%!assert (class (horzcat (cell (1), true)), "cell")
+%!assert (class (horzcat (cell (1), "a")), "cell")
+
+%!assert (class (horzcat (true, int64 (1))), "int64")
+%!assert (class (horzcat (true, int32 (1))), "int32")
+%!assert (class (horzcat (true, int16 (1))), "int16")
+%!assert (class (horzcat (true, int8 (1))), "int8")
+%!assert (class (horzcat (true, uint64 (1))), "uint64")
+%!assert (class (horzcat (true, uint32 (1))), "uint32")
+%!assert (class (horzcat (true, uint16 (1))), "uint16")
+%!assert (class (horzcat (true, uint8 (1))), "uint8")
+%!assert (class (horzcat (true, single (1))), "single")
+%!assert (class (horzcat (true, double (1))), "double")
+%!assert (class (horzcat (true, cell (1))), "cell")
+%!assert (class (horzcat (true, true)), "logical")
+%!assert (class (horzcat (true, "a")), "char")
+
+%!assert (class (horzcat ("a", int64 (1))), "char")
+%!assert (class (horzcat ("a", int32 (1))), "char")
+%!assert (class (horzcat ("a", int16 (1))), "char")
+%!assert (class (horzcat ("a", int8 (1))), "char")
+%!assert (class (horzcat ("a", int64 (1))), "char")
+%!assert (class (horzcat ("a", int32 (1))), "char")
+%!assert (class (horzcat ("a", int16 (1))), "char")
+%!assert (class (horzcat ("a", int8 (1))), "char")
+%!assert (class (horzcat ("a", single (1))), "char")
+%!assert (class (horzcat ("a", double (1))), "char")
+%!assert (class (horzcat ("a", cell (1))), "cell")
+%!assert (class (horzcat ("a", true)), "char")
+%!assert (class (horzcat ("a", "a")), "char")
+
+%!assert (class (horzcat (cell (1), struct ("foo", "bar"))), "cell")
+
+%!error horzcat (struct ("foo", "bar"), cell (1))
 */
 
 DEFUN (vertcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
@@ -2080,18 +2068,18 @@ new matrices.  For example:\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 /*
 %!test
-%! c = {'foo'; 'bar'; 'bazoloa'};
-%! assert (vertcat (c, 'a', 'bc', 'def'), {'foo'; 'bar'; 'bazoloa'; 'a'; 'bc'; 'def'});
+%! c = {"foo"; "bar"; "bazoloa"};
+%! assert (vertcat (c, "a", "bc", "def"), {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 */
 
 DEFUN (cat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
@@ -2153,157 +2141,156 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!function ret = __testcat (t1, t2, tr, cmplx)
-%! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
-%!
-%! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
-%! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
-%! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
-%! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
-%! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
-%! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
-%! assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
-%! assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
-%!
-%! assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
-%! assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
-%! assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
-%! assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
-%! assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
-%! assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
-%! assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
-%! assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
-%!
-%! if (nargin == 3 || cmplx)
-%!   assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
-%!   assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
-%!   assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
-%!   assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
-%!
-%!   assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
-%!   assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
-%!   assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
-%!   assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
-%!
-%!   assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
-%!   assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
-%!   assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
-%!   assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
-%!   assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
-%!   assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
-%!   assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
-%!   assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
-%!
-%!   assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
-%!   assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
-%!   assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
-%!   assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
-%!   assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
-%!   assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
-%!   assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
-%!   assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
-%!
-%!   assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
-%!   assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
-%!   assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
-%!   assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
-%!
-%!   assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
-%!   assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
-%!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
-%!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
-%!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
-%!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
-%! endif
-%! ret = true;
+%!  assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
+%! 
+%!  assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
+%!  assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
+%!  assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
+%!  assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
+%!  assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
+%!  assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
+%!  assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
+%!  assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
+%! 
+%!  assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
+%!  assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
+%!  assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
+%!  assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
+%!  assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
+%!  assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
+%!  assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
+%!  assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
+%! 
+%!  if (nargin == 3 || cmplx)
+%!    assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
+%!    assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
+%!    assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
+%!    assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
+%! 
+%!    assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
+%!    assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
+%!    assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
+%!    assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
+%! 
+%!    assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
+%!    assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
+%!    assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
+%!    assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
+%!    assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
+%!    assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
+%!    assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
+%!    assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
+%! 
+%!    assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
+%!    assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
+%!    assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
+%!    assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
+%!    assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
+%!    assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
+%!    assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
+%!    assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
+%! 
+%!    assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
+%!    assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
+%!    assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
+%!    assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
+%! 
+%!    assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
+%!    assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
+%!    assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
+%!    assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
+%!    assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
+%!    assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
+%!  endif
+%!  ret = true;
 %!endfunction
 
-%!assert (__testcat('double', 'double', 'double'))
-%!assert (__testcat('single', 'double', 'single'))
-%!assert (__testcat('double', 'single', 'single'))
-%!assert (__testcat('single', 'single', 'single'))
-
-%!assert (__testcat('double', 'int8', 'int8', false))
-%!assert (__testcat('int8', 'double', 'int8', false))
-%!assert (__testcat('single', 'int8', 'int8', false))
-%!assert (__testcat('int8', 'single', 'int8', false))
-%!assert (__testcat('int8', 'int8', 'int8', false))
-%!assert (__testcat('double', 'int16', 'int16', false))
-%!assert (__testcat('int16', 'double', 'int16', false))
-%!assert (__testcat('single', 'int16', 'int16', false))
-%!assert (__testcat('int16', 'single', 'int16', false))
-%!assert (__testcat('int16', 'int16', 'int16', false))
-%!assert (__testcat('double', 'int32', 'int32', false))
-%!assert (__testcat('int32', 'double', 'int32', false))
-%!assert (__testcat('single', 'int32', 'int32', false))
-%!assert (__testcat('int32', 'single', 'int32', false))
-%!assert (__testcat('int32', 'int32', 'int32', false))
-%!assert (__testcat('double', 'int64', 'int64', false))
-%!assert (__testcat('int64', 'double', 'int64', false))
-%!assert (__testcat('single', 'int64', 'int64', false))
-%!assert (__testcat('int64', 'single', 'int64', false))
-%!assert (__testcat('int64', 'int64', 'int64', false))
-
-%!assert (__testcat('double', 'uint8', 'uint8', false))
-%!assert (__testcat('uint8', 'double', 'uint8', false))
-%!assert (__testcat('single', 'uint8', 'uint8', false))
-%!assert (__testcat('uint8', 'single', 'uint8', false))
-%!assert (__testcat('uint8', 'uint8', 'uint8', false))
-%!assert (__testcat('double', 'uint16', 'uint16', false))
-%!assert (__testcat('uint16', 'double', 'uint16', false))
-%!assert (__testcat('single', 'uint16', 'uint16', false))
-%!assert (__testcat('uint16', 'single', 'uint16', false))
-%!assert (__testcat('uint16', 'uint16', 'uint16', false))
-%!assert (__testcat('double', 'uint32', 'uint32', false))
-%!assert (__testcat('uint32', 'double', 'uint32', false))
-%!assert (__testcat('single', 'uint32', 'uint32', false))
-%!assert (__testcat('uint32', 'single', 'uint32', false))
-%!assert (__testcat('uint32', 'uint32', 'uint32', false))
-%!assert (__testcat('double', 'uint64', 'uint64', false))
-%!assert (__testcat('uint64', 'double', 'uint64', false))
-%!assert (__testcat('single', 'uint64', 'uint64', false))
-%!assert (__testcat('uint64', 'single', 'uint64', false))
-%!assert (__testcat('uint64', 'uint64', 'uint64', false))
+%!assert (__testcat ("double", "double", "double"))
+%!assert (__testcat ("single", "double", "single"))
+%!assert (__testcat ("double", "single", "single"))
+%!assert (__testcat ("single", "single", "single"))
+
+%!assert (__testcat ("double", "int8", "int8", false))
+%!assert (__testcat ("int8", "double", "int8", false))
+%!assert (__testcat ("single", "int8", "int8", false))
+%!assert (__testcat ("int8", "single", "int8", false))
+%!assert (__testcat ("int8", "int8", "int8", false))
+%!assert (__testcat ("double", "int16", "int16", false))
+%!assert (__testcat ("int16", "double", "int16", false))
+%!assert (__testcat ("single", "int16", "int16", false))
+%!assert (__testcat ("int16", "single", "int16", false))
+%!assert (__testcat ("int16", "int16", "int16", false))
+%!assert (__testcat ("double", "int32", "int32", false))
+%!assert (__testcat ("int32", "double", "int32", false))
+%!assert (__testcat ("single", "int32", "int32", false))
+%!assert (__testcat ("int32", "single", "int32", false))
+%!assert (__testcat ("int32", "int32", "int32", false))
+%!assert (__testcat ("double", "int64", "int64", false))
+%!assert (__testcat ("int64", "double", "int64", false))
+%!assert (__testcat ("single", "int64", "int64", false))
+%!assert (__testcat ("int64", "single", "int64", false))
+%!assert (__testcat ("int64", "int64", "int64", false))
+
+%!assert (__testcat ("double", "uint8", "uint8", false))
+%!assert (__testcat ("uint8", "double", "uint8", false))
+%!assert (__testcat ("single", "uint8", "uint8", false))
+%!assert (__testcat ("uint8", "single", "uint8", false))
+%!assert (__testcat ("uint8", "uint8", "uint8", false))
+%!assert (__testcat ("double", "uint16", "uint16", false))
+%!assert (__testcat ("uint16", "double", "uint16", false))
+%!assert (__testcat ("single", "uint16", "uint16", false))
+%!assert (__testcat ("uint16", "single", "uint16", false))
+%!assert (__testcat ("uint16", "uint16", "uint16", false))
+%!assert (__testcat ("double", "uint32", "uint32", false))
+%!assert (__testcat ("uint32", "double", "uint32", false))
+%!assert (__testcat ("single", "uint32", "uint32", false))
+%!assert (__testcat ("uint32", "single", "uint32", false))
+%!assert (__testcat ("uint32", "uint32", "uint32", false))
+%!assert (__testcat ("double", "uint64", "uint64", false))
+%!assert (__testcat ("uint64", "double", "uint64", false))
+%!assert (__testcat ("single", "uint64", "uint64", false))
+%!assert (__testcat ("uint64", "single", "uint64", false))
+%!assert (__testcat ("uint64", "uint64", "uint64", false))
 
 %!assert (cat (3, [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [], []), zeros (0, 0, 3))
 
 %!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
 %!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
+
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat ([0;0;0;1],[1,2,2]) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat (zeros (3,2,2), ones (1,2,2)) )
+
 %!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
 %!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
-
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) )
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) )
-
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
@@ -2798,74 +2785,72 @@ effect.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (sum([true,true]), 2)
-%!assert (sum([true,true],'native'), true)
-%!assert (sum(int8([127,10,-20])), 117);
-%!assert (sum(int8([127,10,-20]),'native'), int8(107));
-
-%!assert(sum ([1, 2, 3]), 6)
-%!assert(sum ([-1; -2; -3]), -6);
-%!assert(sum ([i, 2+i, -3+2i, 4]), 3+4i);
-%!assert(sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [2+2i, 4+4i, 6+6i]);
-
-%!assert(sum (single([1, 2, 3])), single(6))
-%!assert(sum (single([-1; -2; -3])), single(-6));
-%!assert(sum (single([i, 2+i, -3+2i, 4])), single(3+4i));
-%!assert(sum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([2+2i, 4+4i, 6+6i]));
-
-%!error <Invalid call to sum> sum ();
-
-%!assert (sum ([1, 2; 3, 4], 1), [4, 6]);
-%!assert (sum ([1, 2; 3, 4], 2), [3; 7]);
-%!assert (sum (zeros (1, 0)), 0);
-%!assert (sum (zeros (1, 0), 1), zeros(1, 0));
-%!assert (sum (zeros (1, 0), 2), 0);
-%!assert (sum (zeros (0, 1)), 0);
-%!assert (sum (zeros (0, 1), 1), 0);
-%!assert (sum (zeros (0, 1), 2), zeros(0, 1));
-%!assert (sum (zeros (2, 0)),  zeros(1, 0));
-%!assert (sum (zeros (2, 0), 1), zeros(1, 0));
-%!assert (sum (zeros (2, 0), 2),  [0; 0]);
-%!assert (sum (zeros (0, 2)), [0, 0]);
-%!assert (sum (zeros (0, 2), 1), [0, 0]);
-%!assert (sum (zeros (0, 2), 2), zeros(0, 1));
-%!assert (sum (zeros (2, 2, 0, 3)), zeros(1, 2, 0, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 2), zeros(2, 1, 0, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 3), zeros(2, 2, 1, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 4), zeros(2, 2, 0));
-%!assert (sum (zeros (2, 2, 0, 3), 7), zeros(2, 2, 0, 3));
-
-%!assert (sum (single([1, 2; 3, 4]), 1), single([4, 6]));
-%!assert (sum (single([1, 2; 3, 4]), 2), single([3; 7]));
-%!assert (sum (zeros (1, 0, 'single')), single(0));
-%!assert (sum (zeros (1, 0, 'single'), 1), zeros(1, 0, 'single'));
-%!assert (sum (zeros (1, 0, 'single'), 2), single(0));
-%!assert (sum (zeros (0, 1, 'single')), single(0));
-%!assert (sum (zeros (0, 1, 'single'), 1), single(0));
-%!assert (sum (zeros (0, 1, 'single'), 2), zeros(0, 1, 'single'));
-%!assert (sum (zeros (2, 0, 'single')),  zeros(1, 0, 'single'));
-%!assert (sum (zeros (2, 0, 'single'), 1), zeros(1, 0, 'single'));
-%!assert (sum (zeros (2, 0, 'single'), 2),  single([0; 0]));
-%!assert (sum (zeros (0, 2, 'single')), single([0, 0]));
-%!assert (sum (zeros (0, 2, 'single'), 1), single([0, 0]));
-%!assert (sum (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single')), zeros(1, 2, 0, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 2), zeros(2, 1, 0, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 3), zeros(2, 2, 1, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 4), zeros(2, 2, 0, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 7), zeros(2, 2, 0, 3, 'single'));
-
+%!assert (sum ([true,true]), 2)
+%!assert (sum ([true,true],"native"), true)
+%!assert (sum (int8 ([127,10,-20])), 117)
+%!assert (sum (int8 ([127,10,-20]),'native'), int8 (107))
+
+%!assert (sum ([1, 2, 3]), 6)
+%!assert (sum ([-1; -2; -3]), -6)
+%!assert (sum ([i, 2+i, -3+2i, 4]), 3+4i)
+%!assert (sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [2+2i, 4+4i, 6+6i])
+
+%!assert (sum (single ([1, 2, 3])), single (6))
+%!assert (sum (single ([-1; -2; -3])), single (-6))
+%!assert (sum (single ([i, 2+i, -3+2i, 4])), single (3+4i))
+%!assert (sum (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([2+2i, 4+4i, 6+6i]))
+
+%!assert (sum ([1, 2; 3, 4], 1), [4, 6])
+%!assert (sum ([1, 2; 3, 4], 2), [3; 7])
+%!assert (sum (zeros (1, 0)), 0)
+%!assert (sum (zeros (1, 0), 1), zeros (1, 0))
+%!assert (sum (zeros (1, 0), 2), 0)
+%!assert (sum (zeros (0, 1)), 0)
+%!assert (sum (zeros (0, 1), 1), 0)
+%!assert (sum (zeros (0, 1), 2), zeros (0, 1))
+%!assert (sum (zeros (2, 0)),  zeros (1, 0))
+%!assert (sum (zeros (2, 0), 1), zeros (1, 0))
+%!assert (sum (zeros (2, 0), 2),  [0; 0])
+%!assert (sum (zeros (0, 2)), [0, 0])
+%!assert (sum (zeros (0, 2), 1), [0, 0])
+%!assert (sum (zeros (0, 2), 2), zeros (0, 1))
+%!assert (sum (zeros (2, 2, 0, 3)), zeros (1, 2, 0, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 2), zeros (2, 1, 0, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 3), zeros (2, 2, 1, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 4), zeros (2, 2, 0))
+%!assert (sum (zeros (2, 2, 0, 3), 7), zeros (2, 2, 0, 3))
+
+%!assert (sum (single ([1, 2; 3, 4]), 1), single ([4, 6]))
+%!assert (sum (single ([1, 2; 3, 4]), 2), single ([3; 7]))
+%!assert (sum (zeros (1, 0, "single")), single (0))
+%!assert (sum (zeros (1, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (sum (zeros (1, 0, "single"), 2), single (0))
+%!assert (sum (zeros (0, 1, "single")), single (0))
+%!assert (sum (zeros (0, 1, "single"), 1), single (0))
+%!assert (sum (zeros (0, 1, "single"), 2), zeros (0, 1, "single"))
+%!assert (sum (zeros (2, 0, "single")),  zeros (1, 0, "single"))
+%!assert (sum (zeros (2, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (sum (zeros (2, 0, "single"), 2),  single ([0; 0]))
+%!assert (sum (zeros (0, 2, "single")), single ([0, 0]))
+%!assert (sum (zeros (0, 2, "single"), 1), single ([0, 0]))
+%!assert (sum (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single")), zeros (1, 2, 0, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 2), zeros (2, 1, 0, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 3), zeros (2, 2, 1, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 4), zeros (2, 2, 0, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 7), zeros (2, 2, 0, 3, "single"))
+
+%!error sum ()
 */
 
 DEFUN (sumsq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
 @deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
@@ -2880,34 +2865,32 @@ sum (x .* conj (x), dim)\n\
 but it uses less memory and avoids calling @code{conj} if @var{x} is real.\n\
 @seealso{sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
 /*
-
-%!assert(sumsq ([1, 2, 3]), 14)
-%!assert(sumsq ([-1; -2; 4i]), 21);
-%!assert(sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]), [21, 49, 29]);
-
-%!assert(sumsq (single([1, 2, 3])), single(14))
-%!assert(sumsq (single([-1; -2; 4i])), single(21));
-%!assert(sumsq (single([1, 2, 3; 2, 3, 4; 4i, 6i, 2])), single([21, 49, 29]));
-
-%!error <Invalid call to sumsq> sumsq ();
-
-%!assert (sumsq ([1, 2; 3, 4], 1), [10, 20]);
-%!assert (sumsq ([1, 2; 3, 4], 2), [5; 25]);
-
-%!assert (sumsq (single([1, 2; 3, 4]), 1), single([10, 20]));
-%!assert (sumsq (single([1, 2; 3, 4]), 2), single([5; 25]));
-
- */
+%!assert (sumsq ([1, 2, 3]), 14)
+%!assert (sumsq ([-1; -2; 4i]), 21)
+%!assert (sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]), [21, 49, 29])
+
+%!assert (sumsq (single ([1, 2, 3])), single (14))
+%!assert (sumsq (single ([-1; -2; 4i])), single (21))
+%!assert (sumsq (single ([1, 2, 3; 2, 3, 4; 4i, 6i, 2])), single ([21, 49, 29]))
+
+%!assert (sumsq ([1, 2; 3, 4], 1), [10, 20])
+%!assert (sumsq ([1, 2; 3, 4], 2), [5; 25])
+
+%!assert (sumsq (single ([1, 2; 3, 4]), 1), single ([10, 20]))
+%!assert (sumsq (single ([1, 2; 3, 4]), 2), single ([5; 25]))
+
+%!error sumsq ()
+*/
 
 DEFUN (islogical, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} islogical (@var{x})\n\
 @deftypefnx {Built-in Function} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
@@ -2920,30 +2903,28 @@ Return true if @var{x} is a logical obje
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (isbool, islogical);
 
 /*
-
-%!assert (islogical(true), true)
-%!assert (islogical(false), true)
-%!assert (islogical([true, false]), true)
-%!assert (islogical(1), false)
-%!assert (islogical(1i), false)
-%!assert (islogical([1,1]), false)
-%!assert (islogical(single(1)), false)
-%!assert (islogical(single(1i)), false)
-%!assert (islogical(single([1,1])), false)
-%!assert (islogical(sparse ([true, false])), true)
-%!assert (islogical(sparse ([1, 0])), false)
-
- */
+%!assert (islogical (true), true)
+%!assert (islogical (false), true)
+%!assert (islogical ([true, false]), true)
+%!assert (islogical (1), false)
+%!assert (islogical (1i), false)
+%!assert (islogical ([1,1]), false)
+%!assert (islogical (single (1)), false)
+%!assert (islogical (single (1i)), false)
+%!assert (islogical (single ([1,1])), false)
+%!assert (islogical (sparse ([true, false])), true)
+%!assert (islogical (sparse ([1, 0])), false)
+*/
 
 DEFUN (isinteger, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
@@ -3338,31 +3319,29 @@ numeric.\n\
     retval = args(0).is_numeric_type ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (isnumeric(1), true)
-%!assert (isnumeric(1i), true)
-%!assert (isnumeric([1,1]), true)
-%!assert (isnumeric(single(1)), true)
-%!assert (isnumeric(single(1i)), true)
-%!assert (isnumeric(single([1,1])), true)
-%!assert (isnumeric(int8(1)), true)
-%!assert (isnumeric(uint8([1,1])), true)
-%!assert (isnumeric("Hello World"), false)
-%!assert (isnumeric(true), false)
-%!assert (isnumeric(false), false)
-%!assert (isnumeric([true, false]), false)
-%!assert (isnumeric(sparse ([true, false])), false)
-
+%!assert (isnumeric (1), true)
+%!assert (isnumeric (1i), true)
+%!assert (isnumeric ([1,1]), true)
+%!assert (isnumeric (single (1)), true)
+%!assert (isnumeric (single (1i)), true)
+%!assert (isnumeric (single ([1,1])), true)
+%!assert (isnumeric (int8 (1)), true)
+%!assert (isnumeric (uint8 ([1,1])), true)
+%!assert (isnumeric ("Hello World"), false)
+%!assert (isnumeric (true), false)
+%!assert (isnumeric (false), false)
+%!assert (isnumeric ([true, false]), false)
+%!assert (isnumeric (sparse ([true, false])), false)
 */
 
 DEFUN (ismatrix, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a numeric, logical, or character matrix.\n\
 Scalars (1x1 matrices) and vectors (@nospell{1xN} or @nospell{Nx1} matrices)\n\
 are subsets of the more general N-dimensional matrix and @code{ismatrix}\n\
@@ -3380,40 +3359,38 @@ will return true for these objects as we
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(ismatrix ([]));
-%!assert(ismatrix (1));
-%!assert(ismatrix ([1, 2, 3]));
-%!assert(ismatrix ([1, 2; 3, 4]));
-%!assert(ismatrix (zeros (3, 2, 4)));
-
-%!assert(ismatrix (single([])));
-%!assert(ismatrix (single(1)));
-%!assert(ismatrix (single([1, 2, 3])));
-%!assert(ismatrix (single([1, 2; 3, 4])));
-
-%!assert(ismatrix ("t"));
-%!assert(ismatrix ("test"));
-%!assert(ismatrix (["test"; "ing"]));
+%!assert (ismatrix ([]))
+%!assert (ismatrix (1))
+%!assert (ismatrix ([1, 2, 3]))
+%!assert (ismatrix ([1, 2; 3, 4]))
+%!assert (ismatrix (zeros (3, 2, 4)))
+
+%!assert (ismatrix (single ([])))
+%!assert (ismatrix (single (1)))
+%!assert (ismatrix (single ([1, 2, 3])))
+%!assert (ismatrix (single ([1, 2; 3, 4])))
+
+%!assert (ismatrix ("t"))
+%!assert (ismatrix ("test"))
+%!assert (ismatrix (["test"; "ing"]))
 
 %!test
 %! s.a = 1;
-%! assert(ismatrix (s), false);
-
-%!error <Invalid call to ismatrix> ismatrix ();
-%!error <Invalid call to ismatrix> ismatrix ([1, 2; 3, 4], 2);
-
- */
+%! assert (ismatrix (s), false);
+
+%!error ismatrix ()
+%!error ismatrix ([1, 2; 3, 4], 2)
+*/
 
 static octave_value
 fill_matrix (const octave_value_list& args, int val, const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -3857,33 +3834,31 @@ val = ones (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
 /*
-
-%!assert(ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1]);
-%!assert(ones (2, 3), [1, 1, 1; 1, 1, 1]);
-%!assert(ones (3, 2), [1, 1; 1, 1; 1, 1]);
-%!assert(size (ones (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(ones (3,'single'), single([1, 1, 1; 1, 1, 1; 1, 1, 1]));
-%!assert(ones (2, 3,'single'), single([1, 1, 1; 1, 1, 1]));
-%!assert(ones (3, 2,'single'), single([1, 1; 1, 1; 1, 1]));
-%!assert(size (ones (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!assert(ones (3,'int8'), int8([1, 1, 1; 1, 1, 1; 1, 1, 1]));
-%!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
-%!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
-%!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
-
- */
+%!assert (ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1])
+%!assert (ones (2, 3), [1, 1, 1; 1, 1, 1])
+%!assert (ones (3, 2), [1, 1; 1, 1; 1, 1])
+%!assert (size (ones (3, 4, 5)), [3, 4, 5])
+
+%!assert (ones (3, "single"), single ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
+%!assert (ones (2, 3, "single"), single ([1, 1, 1; 1, 1, 1]))
+%!assert (ones (3, 2, "single"), single ([1, 1; 1, 1; 1, 1]))
+%!assert (size (ones (3, 4, 5, "single")), [3, 4, 5])
+
+%!assert (ones (3, "int8"), int8 ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
+%!assert (ones (2, 3, "int8"), int8 ([1, 1, 1; 1, 1, 1]))
+%!assert (ones (3, 2, "int8"), int8 ([1, 1; 1, 1; 1, 1]))
+%!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
+*/
 
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} zeros (@var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
@@ -3901,33 +3876,31 @@ val = zeros (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
 /*
-
-%!assert(zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0]);
-%!assert(zeros (2, 3), [0, 0, 0; 0, 0, 0]);
-%!assert(zeros (3, 2), [0, 0; 0, 0; 0, 0]);
-%!assert(size (zeros (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(zeros (3,'single'), single([0, 0, 0; 0, 0, 0; 0, 0, 0]));
-%!assert(zeros (2, 3,'single'), single([0, 0, 0; 0, 0, 0]));
-%!assert(zeros (3, 2,'single'), single([0, 0; 0, 0; 0, 0]));
-%!assert(size (zeros (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!assert(zeros (3,'int8'), int8([0, 0, 0; 0, 0, 0; 0, 0, 0]));
-%!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
-%!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
-%!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
-
- */
+%!assert (zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0])
+%!assert (zeros (2, 3), [0, 0, 0; 0, 0, 0])
+%!assert (zeros (3, 2), [0, 0; 0, 0; 0, 0])
+%!assert (size (zeros (3, 4, 5)), [3, 4, 5])
+
+%!assert (zeros (3, "single"), single ([0, 0, 0; 0, 0, 0; 0, 0, 0]))
+%!assert (zeros (2, 3, "single"), single ([0, 0, 0; 0, 0, 0]))
+%!assert (zeros (3, 2, "single"), single ([0, 0; 0, 0; 0, 0]))
+%!assert (size (zeros (3, 4, 5, "single")), [3, 4, 5])
+
+%!assert (zeros (3, "int8"), int8 ([0, 0, 0; 0, 0, 0; 0, 0, 0]))
+%!assert (zeros (2, 3, "int8"), int8 ([0, 0, 0; 0, 0, 0]))
+%!assert (zeros (3, 2, "int8"), int8 ([0, 0; 0, 0; 0, 0]))
+%!assert (size (zeros (3, 4, 5, "int8")), [3, 4, 5])
+*/
 
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex inf\n\
 \n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
@@ -3960,33 +3933,31 @@ either \"double\" or \"single\".\n\
 {
   return fill_matrix (args, lo_ieee_inf_value (),
                       lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
 /*
-
-%!assert(inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]);
-%!assert(inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf]);
-%!assert(inf (3, 2), [Inf, Inf; Inf, Inf; Inf, Inf]);
-%!assert(size (inf (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(inf (3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]));
-%!assert(inf (2, 3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf]));
-%!assert(inf (3, 2,'single'), single([Inf, Inf; Inf, Inf; Inf, Inf]));
-%!assert(size (inf (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!error(inf (3,'int8'));
-%!error(inf (2, 3,'int8'));
-%!error(inf (3, 2,'int8'));
-%!error(inf (3, 4, 5, 'int8'));
-
- */
+%!assert (inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf])
+%!assert (inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf])
+%!assert (inf (3, 2), [Inf, Inf; Inf, Inf; Inf, Inf])
+%!assert (size (inf (3, 4, 5)), [3, 4, 5])
+
+%!assert (inf (3, "single"), single ([Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]))
+%!assert (inf (2, 3, "single"), single ([Inf, Inf, Inf; Inf, Inf, Inf]))
+%!assert (inf (3, 2, "single"), single ([Inf, Inf; Inf, Inf; Inf, Inf]))
+%!assert (size (inf (3, 4, 5, "single")), [3, 4, 5])
+
+%!error (inf (3, "int8"))
+%!error (inf (2, 3, "int8"))
+%!error (inf (3, 2, "int8"))
+%!error (inf (3, 4, 5, "int8"))
+*/
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex nan\n\
 \n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
@@ -4021,32 +3992,31 @@ either \"double\" or \"single\".\n\
 {
   return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
 /*
-%!assert(NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]);
-%!assert(NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN]);
-%!assert(NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN]);
-%!assert(size (NaN (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(NaN (3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]));
-%!assert(NaN (2, 3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN]));
-%!assert(NaN (3, 2,'single'), single([NaN, NaN; NaN, NaN; NaN, NaN]));
-%!assert(size (NaN (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!error(NaN (3,'int8'));
-%!error(NaN (2, 3,'int8'));
-%!error(NaN (3, 2,'int8'));
-%!error(NaN (3, 4, 5, 'int8'));
-
- */
+%!assert (NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN])
+%!assert (NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN])
+%!assert (NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN])
+%!assert (size (NaN (3, 4, 5)), [3, 4, 5])
+
+%!assert (NaN (3, "single"), single ([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]))
+%!assert (NaN (2, 3, "single"), single ([NaN, NaN, NaN; NaN, NaN, NaN]))
+%!assert (NaN (3, 2, "single"), single ([NaN, NaN; NaN, NaN; NaN, NaN]))
+%!assert (size (NaN (3, 4, 5, "single")), [3, 4, 5])
+
+%!error (NaN (3, "int8"))
+%!error (NaN (2, 3, "int8"))
+%!error (NaN (3, 2, "int8"))
+%!error (NaN (3, 4, 5, "int8"))
+*/
 
 DEFUN (e, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} e\n\
 @deftypefnx {Built-in Function} {} e (@var{n})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
@@ -4166,39 +4136,36 @@ either \"double\" or \"single\".\n\
     }
   else
     retval = fill_matrix (args, DBL_EPSILON, FLT_EPSILON, "eps");
 
   return retval;
 }
 
 /*
-
-%!assert(eps(1/2),2^(-53))
-%!assert(eps(1),2^(-52))
-%!assert(eps(2),2^(-51))
-%!assert(eps(realmax),2^971)
-%!assert(eps(0),2^(-1074))
-%!assert(eps(realmin/2),2^(-1074))
-%!assert(eps(realmin/16),2^(-1074))
-%!assert(eps(Inf),NaN)
-%!assert(eps(NaN),NaN)
-%!assert(eps(single(1/2)),single(2^(-24)))
-%!assert(eps(single(1)),single(2^(-23)))
-%!assert(eps(single(2)),single(2^(-22)))
-%!assert(eps(realmax('single')),single(2^104))
-%!assert(eps(single(0)),single(2^(-149)))
-%!assert(eps(realmin('single')/2),single(2^(-149)))
-%!assert(eps(realmin('single')/16),single(2^(-149)))
-%!assert(eps(single(Inf)),single(NaN))
-%!assert(eps(single(NaN)),single(NaN))
-
+%!assert (eps (1/2), 2^(-53))
+%!assert (eps (1), 2^(-52))
+%!assert (eps (2), 2^(-51))
+%!assert (eps (realmax), 2^971)
+%!assert (eps (0), 2^(-1074))
+%!assert (eps (realmin/2), 2^(-1074))
+%!assert (eps (realmin/16), 2^(-1074))
+%!assert (eps (Inf), NaN)
+%!assert (eps (NaN), NaN)
+%!assert (eps (single (1/2)), single (2^(-24)))
+%!assert (eps (single (1)), single (2^(-23)))
+%!assert (eps (single (2)), single (2^(-22)))
+%!assert (eps (realmax ("single")), single (2^104))
+%!assert (eps (single (0)), single (2^(-149)))
+%!assert (eps (realmin ("single")/2), single (2^(-149)))
+%!assert (eps (realmin ("single")/16), single (2^(-149)))
+%!assert (eps (single (Inf)), single (NaN))
+%!assert (eps (single (NaN)), single (NaN))
 */
 
-
 DEFUN (pi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pi\n\
 @deftypefnx {Built-in Function} {} pi (@var{n})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
@@ -4363,21 +4330,19 @@ either \"double\" or \"single\".\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_na_value (),
                       lo_ieee_float_na_value (), "NA");
 }
 
 /*
-
-%!assert(single(NA('double')),NA('single'))
-%!assert(double(NA('single')),NA('double'))
-
- */
+%!assert (single (NA ("double")), NA ("single"))
+%!assert (double (NA ("single")), NA ("double"))
+*/
 
 DEFUN (false, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} false (@var{x})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
@@ -4616,31 +4581,28 @@ These odd definitions are for compatibil
     default:
       print_usage ();
       break;
     }
 
   return retval;
 }
 
-
 /*
-
-%!assert (full (eye(3)), [1, 0, 0; 0, 1, 0; 0, 0, 1]);
-%!assert (full (eye(2, 3)), [1, 0, 0; 0, 1, 0]);
-
-%!assert (full (eye(3,'single')), single([1, 0, 0; 0, 1, 0; 0, 0, 1]));
-%!assert (full (eye(2, 3,'single')), single([1, 0, 0; 0, 1, 0]));
-
-%!assert (eye(3,'int8'), int8([1, 0, 0; 0, 1, 0; 0, 0, 1]));
-%!assert (eye(2, 3,'int8'), int8([1, 0, 0; 0, 1, 0]));
-
-%!error <Invalid call to eye> eye (1, 2, 3);
-
- */
+%!assert (full (eye (3)), [1, 0, 0; 0, 1, 0; 0, 0, 1])
+%!assert (full (eye (2, 3)), [1, 0, 0; 0, 1, 0])
+
+%!assert (full (eye (3,"single")), single ([1, 0, 0; 0, 1, 0; 0, 0, 1]))
+%!assert (full (eye (2, 3,"single")), single ([1, 0, 0; 0, 1, 0]))
+
+%!assert (eye (3, "int8"), int8 ([1, 0, 0; 0, 1, 0; 0, 0, 1]))
+%!assert (eye (2, 3, "int8"), int8 ([1, 0, 0; 0, 1, 0]))
+
+%!error eye (1, 2, 3)
+*/
 
 template <class MT>
 static octave_value
 do_linspace (const octave_value& base, const octave_value& limit,
              octave_idx_type n)
 {
   typedef typename MT::column_vector_type CVT;
   typedef typename MT::element_type T;
@@ -4739,34 +4701,30 @@ if fewer than two values are requested.\
   else
     error ("linspace: N must be an integer");
 
   return retval;
 }
 
 
 /*
-
 %!test
 %! x1 = linspace (1, 2);
 %! x2 = linspace (1, 2, 10);
 %! x3 = linspace (1, -2, 10);
-%! assert((size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2
-%! && size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2
-%! && size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2));
-
-
-% assert(linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6));
-
-%!error <Invalid call to linspace> linspace ();
-%!error <Invalid call to linspace> linspace (1, 2, 3, 4);
-
-%!test
-%! fail("linspace ([1, 2; 3, 4], 5, 6)","warning");
-
+%! assert (size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2);
+%! assert (size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2);
+%! assert (size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2);
+
+%#assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
+
+%!fail ("linspace ([1, 2; 3, 4], 5, 6)", "warning")
+
+%!error linspace ()
+%!error linspace (1, 2, 3, 4)
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
@@ -4972,35 +4930,33 @@ the unspecified dimension.\n\
 
   if (! error_state)
     retval = args(0).reshape (new_dims);
 
   return retval;
 }
 
 /*
-
-%!assert(size (reshape (ones (4, 4), 2, 8)), [2, 8])
-%!assert(size (reshape (ones (4, 4), 8, 2)), [8, 2])
-%!assert(size (reshape (ones (15, 4), 1, 60)), [1, 60])
-%!assert(size (reshape (ones (15, 4), 60, 1)), [60, 1])
-
-%!assert(size (reshape (ones (4, 4, 'single'), 2, 8)), [2, 8])
-%!assert(size (reshape (ones (4, 4, 'single'), 8, 2)), [8, 2])
-%!assert(size (reshape (ones (15, 4, 'single'), 1, 60)), [1, 60])
-%!assert(size (reshape (ones (15, 4, 'single'), 60, 1)), [60, 1])
+%!assert (size (reshape (ones (4, 4), 2, 8)), [2, 8])
+%!assert (size (reshape (ones (4, 4), 8, 2)), [8, 2])
+%!assert (size (reshape (ones (15, 4), 1, 60)), [1, 60])
+%!assert (size (reshape (ones (15, 4), 60, 1)), [60, 1])
+
+%!assert (size (reshape (ones (4, 4, "single"), 2, 8)), [2, 8])
+%!assert (size (reshape (ones (4, 4, "single"), 8, 2)), [8, 2])
+%!assert (size (reshape (ones (15, 4, "single"), 1, 60)), [1, 60])
+%!assert (size (reshape (ones (15, 4, "single"), 60, 1)), [60, 1])
 
 %!test
 %! s.a = 1;
-%! fail("reshape (s, 2, 3)");
-
-%!error <Invalid call to reshape> reshape ();
-%!error reshape (1, 2, 3, 4);
-
- */
+%! fail ("reshape (s, 2, 3)");
+
+%!error reshape ()
+%!error reshape (1, 2, 3, 4)
+*/
 
 DEFUN (vec, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
@@ -5044,30 +5000,28 @@ This is equivalent to @code{shiftdim (@v
           retval = retval.reshape (new_dims);
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(vec ([1, 2; 3, 4]), [1; 3; 2; 4])
-%!assert(vec ([1, 3, 2, 4]), [1; 3; 2; 4]);
-%!assert(vec ([1, 2, 3, 4], 2), [1, 2, 3, 4]);
-%!assert(vec ([1, 2; 3, 4]), vec ([1, 2; 3, 4], 1));
-%!assert(vec ([1, 2; 3, 4], 1), [1; 3; 2; 4]);
-%!assert(vec ([1, 2; 3, 4], 2), [1, 3, 2, 4]);
-%!assert(vec ([1, 3; 2, 4], 3), reshape ([1, 2, 3, 4], 1, 1, 4));
-%!assert(vec ([1, 3; 2, 4], 3), shiftdim (vec ([1, 3; 2, 4]), -2));
-
-%!error vec ();
-%!error vec (1, 2, 3);
-%!error vec ([1, 2; 3, 4], 0);
-
+%!assert (vec ([1, 2; 3, 4]), [1; 3; 2; 4])
+%!assert (vec ([1, 3, 2, 4]), [1; 3; 2; 4])
+%!assert (vec ([1, 2, 3, 4], 2), [1, 2, 3, 4])
+%!assert (vec ([1, 2; 3, 4]), vec ([1, 2; 3, 4], 1))
+%!assert (vec ([1, 2; 3, 4], 1), [1; 3; 2; 4])
+%!assert (vec ([1, 2; 3, 4], 2), [1, 3, 2, 4])
+%!assert (vec ([1, 3; 2, 4], 3), reshape ([1, 2, 3, 4], 1, 1, 4))
+%!assert (vec ([1, 3; 2, 4], 3), shiftdim (vec ([1, 3; 2, 4]), -2))
+
+%!error vec ()
+%!error vec (1, 2, 3)
+%!error vec ([1, 2; 3, 4], 0)
 */
 
 DEFUN (squeeze, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
@@ -5222,63 +5176,63 @@ the norms of each column and return a ro
     print_usage ();
 
   return retval;
 }
 
 /*
 %!shared x
 %! x = [1, -3, 4, 5, -7];
-%!assert(norm(x,1), 20);
-%!assert(norm(x,2), 10);
-%!assert(norm(x,3), 8.24257059961711, -4*eps);
-%!assert(norm(x,Inf), 7);
-%!assert(norm(x,-Inf), 1);
-%!assert(norm(x,"inf"), 7);
-%!assert(norm(x,"fro"), 10, -eps);
-%!assert(norm(x), 10);
-%!assert(norm([1e200, 1]), 1e200);
-%!assert(norm([3+4i, 3-4i, sqrt(31)]), 9, -4*eps);
+%!assert (norm (x,1), 20)
+%!assert (norm (x,2), 10)
+%!assert (norm (x,3), 8.24257059961711, -4*eps)
+%!assert (norm (x,Inf), 7)
+%!assert (norm (x,-Inf), 1)
+%!assert (norm (x,"inf"), 7)
+%!assert (norm (x,"fro"), 10, -eps)
+%!assert (norm (x), 10)
+%!assert (norm ([1e200, 1]), 1e200)
+%!assert (norm ([3+4i, 3-4i, sqrt(31)]), 9, -4*eps)
 %!shared m
 %! m = magic (4);
-%!assert(norm(m,1), 34);
-%!assert(norm(m,2), 34, -eps);
-%!assert(norm(m,Inf), 34);
-%!assert(norm(m,"inf"), 34);
+%!assert (norm (m,1), 34)
+%!assert (norm (m,2), 34, -eps)
+%!assert (norm (m,Inf), 34)
+%!assert (norm (m,"inf"), 34)
 %!shared m2, flo, fhi
 %! m2 = [1,2;3,4];
 %! flo = 1e-300;
 %! fhi = 1e+300;
-%!assert (norm(flo*m2,"fro"), sqrt(30)*flo, -eps)
-%!assert (norm(fhi*m2,"fro"), sqrt(30)*fhi, -eps)
+%!assert (norm (flo*m2,"fro"), sqrt (30)*flo, -eps)
+%!assert (norm (fhi*m2,"fro"), sqrt (30)*fhi, -eps)
 
 %!shared x
-%! x = single([1, -3, 4, 5, -7]);
-%!assert(norm(x,1), single(20));
-%!assert(norm(x,2), single(10));
-%!assert(norm(x,3), single(8.24257059961711), -4*eps('single'));
-%!assert(norm(x,Inf), single(7));
-%!assert(norm(x,-Inf), single(1));
-%!assert(norm(x,"inf"), single(7));
-%!assert(norm(x,"fro"), single(10), -eps('single'));
-%!assert(norm(x), single(10));
-%!assert(norm(single([1e200, 1])), single(1e200));
-%!assert(norm(single([3+4i, 3-4i, sqrt(31)])), single(9), -4*eps('single'));
+%! x = single ([1, -3, 4, 5, -7]);
+%!assert (norm (x,1), single (20))
+%!assert (norm (x,2), single (10))
+%!assert (norm (x,3), single (8.24257059961711), -4*eps ("single"))
+%!assert (norm (x,Inf), single (7))
+%!assert (norm (x,-Inf), single (1))
+%!assert (norm (x,"inf"), single (7))
+%!assert (norm (x,"fro"), single (10), -eps ("single"))
+%!assert (norm (x), single (10))
+%!assert (norm (single ([1e200, 1])), single (1e200))
+%!assert (norm (single ([3+4i, 3-4i, sqrt(31)])), single (9), -4*eps ("single"))
 %!shared m
-%! m = single(magic (4));
-%!assert(norm(m,1), single(34));
-%!assert(norm(m,2), single(34), -eps('single'));
-%!assert(norm(m,Inf), single(34));
-%!assert(norm(m,"inf"), single(34));
+%! m = single (magic (4));
+%!assert (norm (m,1), single (34))
+%!assert (norm (m,2), single (34), -eps ("single"))
+%!assert (norm (m,Inf), single (34))
+%!assert (norm (m,"inf"), single (34))
 %!shared m2, flo, fhi
-%! m2 = single([1,2;3,4]);
-%! flo = single(1e-300);
-%! fhi = single(1e+300);
-%!assert (norm(flo*m2,"fro"), single(sqrt(30)*flo), -eps('single'))
-%!assert (norm(fhi*m2,"fro"), single(sqrt(30)*fhi), -eps('single'))
+%! m2 = single ([1,2;3,4]);
+%! flo = single (1e-300);
+%! fhi = single (1e+300);
+%!assert (norm (flo*m2,"fro"), single (sqrt (30)*flo), -eps ("single"))
+%!assert (norm (fhi*m2,"fro"), single (sqrt (30)*fhi), -eps ("single"))
 */
 
 static octave_value
 unary_op_defun_body (octave_value::unary_op op,
                      const octave_value_list& args)
 {
   octave_value retval;
   if (args.length () == 1)
@@ -5325,68 +5279,64 @@ Return the transpose of @var{x}.\n\
 This function and @xcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
 
 /*
-
-%!assert (2.', 2);
-%!assert (2i.',2i);
-%!assert ([1:4].',[1;2;3;4]);
-%!assert ([1;2;3;4].',[1:4]);
-%!assert ([1,2;3,4].',[1,3;2,4]);
-%!assert ([1,2i;3,4].',[1,3;2i,4]);
-
-%!assert (transpose ([1,2;3,4]),[1,3;2,4]);
-
-%!assert (single(2).', single(2));
-%!assert (single(2i).',single(2i));
-%!assert (single([1:4]).',single([1;2;3;4]));
-%!assert (single([1;2;3;4]).',single([1:4]));
-%!assert (single([1,2;3,4]).',single([1,3;2,4]));
-%!assert (single([1,2i;3,4]).',single([1,3;2i,4]));
-
-%!assert (transpose (single([1,2;3,4])),single([1,3;2,4]));
-
+%!assert (2.', 2)
+%!assert (2i.', 2i)
+%!assert ([1:4].', [1;2;3;4])
+%!assert ([1;2;3;4].', [1:4])
+%!assert ([1,2;3,4].', [1,3;2,4])
+%!assert ([1,2i;3,4].', [1,3;2i,4])
+
+%!assert (transpose ([1,2;3,4]), [1,3;2,4])
+
+%!assert (single (2).', single (2))
+%!assert (single (2i).', single (2i))
+%!assert (single ([1:4]).', single ([1;2;3;4]))
+%!assert (single ([1;2;3;4]).', single ([1:4]))
+%!assert (single ([1,2;3,4]).', single ([1,3;2,4]))
+%!assert (single ([1,2i;3,4]).', single ([1,3;2i,4]))
+
+%!assert (transpose (single ([1,2;3,4])), single ([1,3;2,4]))
 */
 
 DEFUN (ctranspose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
 Return the complex conjugate transpose of @var{x}.\n\
 This function and @xcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
 
 /*
-
-%!assert (2', 2);
-%!assert (2i',-2i);
-%!assert ([1:4]',[1;2;3;4]);
-%!assert ([1;2;3;4]',[1:4]);
-%!assert ([1,2;3,4]',[1,3;2,4]);
-%!assert ([1,2i;3,4]',[1,3;-2i,4]);
-
-%!assert (ctranspose ([1,2i;3,4]),[1,3;-2i,4]);
-
-%!assert (single(2)', single(2));
-%!assert (single(2i)',single(-2i));
-%!assert (single([1:4])',single([1;2;3;4]));
-%!assert (single([1;2;3;4])',single([1:4]));
-%!assert (single([1,2;3,4])',single([1,3;2,4]));
-%!assert (single([1,2i;3,4])',single([1,3;-2i,4]));
-
-%!assert (ctranspose (single([1,2i;3,4])),single([1,3;-2i,4]));
-
+%!assert (2', 2)
+%!assert (2i', -2i)
+%!assert ([1:4]', [1;2;3;4])
+%!assert ([1;2;3;4]', [1:4])
+%!assert ([1,2;3,4]', [1,3;2,4])
+%!assert ([1,2i;3,4]', [1,3;-2i,4])
+
+%!assert (ctranspose ([1,2i;3,4]), [1,3;-2i,4])
+
+%!assert (single (2)', single (2))
+%!assert (single (2i)', single (-2i))
+%!assert (single ([1:4])', single ([1;2;3;4]))
+%!assert (single ([1;2;3;4])', single ([1:4]))
+%!assert (single ([1,2;3,4])', single ([1,3;2,4]))
+%!assert (single ([1,2i;3,4])', single ([1,3;-2i,4]))
+
+%!assert (ctranspose (single ([1,2i;3,4])), single ([1,3;-2i,4]))
 */
 
 static octave_value
 binary_op_defun_body (octave_value::binary_op op,
                       const octave_value_list& args)
 {
   octave_value retval;
 
@@ -5999,190 +5949,188 @@ ordered lists.\n\
     }
   else
     retval(0) = arg.sort (dim, smode);
 
   return retval;
 }
 
 /*
-
-%% Double
+## Double
 %!assert (sort ([NaN, 1, -1, 2, Inf]), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 1), [NaN, 1, -1, 2, Inf])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 3), [NaN, 1, -1, 2, Inf])
 %!assert (sort ([NaN, 1, -1, 2, Inf], "ascend"), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2, "ascend"), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], "descend"), [NaN, Inf, 2, 1, -1])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2, "descend"), [NaN, Inf, 2, 1, -1])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4]), [3, 1, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4], 1), [3, 1, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4], 2), [1, 3, 5, 7; 2, 4, 6, 8])
 %!assert (sort (1), 1)
 
 %!test
 %! [v, i] = sort ([NaN, 1, -1, Inf, 1]);
-%! assert (v, [-1, 1, 1, Inf, NaN])
-%! assert (i, [3, 2, 5, 4, 1])
-
-%% Complex
+%! assert (v, [-1, 1, 1, Inf, NaN]);
+%! assert (i, [3, 2, 5, 4, 1]);
+
+## Complex
 %!assert (sort ([NaN, 1i, -1, 2, Inf]), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 1), [NaN, 1i, -1, 2, Inf])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 3), [NaN, 1i, -1, 2, Inf])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], "ascend"), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2, "ascend"), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], "descend"), [NaN, Inf, 2, -1, 1i])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2, "descend"), [NaN, Inf, 2, -1, 1i])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4]), [3, 1i, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4], 1), [3, 1i, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4], 2), [1i, 3, 5, 7; 2, 4, 6, 8])
 %!assert (sort (1i), 1i)
 
 %!test
 %! [v, i] = sort ([NaN, 1i, -1, Inf, 1, 1i]);
-%! assert (v, [1, 1i, 1i, -1, Inf, NaN])
-%! assert (i, [5, 2, 6, 3, 4, 1])
-
-%% Single
-%!assert (sort (single([NaN, 1, -1, 2, Inf])), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 1), single([NaN, 1, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 3), single([NaN, 1, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), "ascend"), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "ascend"), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, 1, -1]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, 1, -1]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4])), single([3, 1, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 1), single([3, 1, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 2), single([1, 3, 5, 7; 2, 4, 6, 8]))
-%!assert (sort (single(1)), single(1))
+%! assert (v, [1, 1i, 1i, -1, Inf, NaN]);
+%! assert (i, [5, 2, 6, 3, 4, 1]);
+
+## Single
+%!assert (sort (single ([NaN, 1, -1, 2, Inf])), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 1), single ([NaN, 1, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 3), single ([NaN, 1, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), "ascend"), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2, "ascend"), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), "descend"), single ([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2, "descend"), single ([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4])), single ([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4]), 1), single ([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4]), 2), single ([1, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single (1)), single (1))
 
 %!test
-%! [v, i] = sort (single([NaN, 1, -1, Inf, 1]));
-%! assert (v, single([-1, 1, 1, Inf, NaN]))
-%! assert (i, [3, 2, 5, 4, 1])
-
-%% Single Complex
-%!assert (sort (single([NaN, 1i, -1, 2, Inf])), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 1), single([NaN, 1i, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 3), single([NaN, 1i, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "ascend"), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "ascend"), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, -1, 1i]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, -1, 1i]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4])), single([3, 1i, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 1), single([3, 1i, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 2), single([1i, 3, 5, 7; 2, 4, 6, 8]))
-%!assert (sort (single(1i)),single( 1i))
+%! [v, i] = sort (single ([NaN, 1, -1, Inf, 1]));
+%! assert (v, single ([-1, 1, 1, Inf, NaN]));
+%! assert (i, [3, 2, 5, 4, 1]);
+
+## Single Complex
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf])), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 1), single ([NaN, 1i, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 3), single ([NaN, 1i, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), "ascend"), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2, "ascend"), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), "descend"), single ([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2, "descend"), single ([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4])), single ([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4]), 1), single ([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4]), 2), single ([1i, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single (1i)), single (1i))
 
 %!test
-%! [v, i] = sort (single([NaN, 1i, -1, Inf, 1, 1i]));
-%! assert (v, single([1, 1i, 1i, -1, Inf, NaN]))
-%! assert (i, [5, 2, 6, 3, 4, 1])
-
-%% Bool
+%! [v, i] = sort (single ([NaN, 1i, -1, Inf, 1, 1i]));
+%! assert (v, single ([1, 1i, 1i, -1, Inf, NaN]));
+%! assert (i, [5, 2, 6, 3, 4, 1]);
+
+## Bool
 %!assert (sort ([true, false, true, false]), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 1), [true, false, true, false])
 %!assert (sort ([true, false, true, false], 2), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 3), [true, false, true, false])
 %!assert (sort ([true, false, true, false], "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 2, "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], "descend"), [true, true, false, false])
 %!assert (sort ([true, false, true, false], 2, "descend"), [true, true, false, false])
 %!assert (sort (true), true)
 
 %!test
 %! [v, i] = sort ([true, false, true, false]);
-%! assert (v, [false, false, true, true])
-%! assert (i, [2, 4, 1, 3])
-
-%% Sparse Double
+%! assert (v, [false, false, true, true]);
+%! assert (i, [2, 4, 1, 3]);
+
+## Sparse Double
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf])), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 1), sparse ([0, NaN, 1, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 3), sparse ([0, NaN, 1, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), "ascend"), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2, "ascend"), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), "descend"), sparse ([NaN, Inf, 2, 1, 0, 0, -1]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2, "descend"), sparse ([NaN, Inf, 2, 1, 0, 0, -1]))
 
 %!shared a
 %! a = randn (10, 10);
-%! a (a < 0) = 0;
+%! a(a < 0) = 0;
 %!assert (sort (sparse (a)), sparse (sort (a)))
 %!assert (sort (sparse (a), 1), sparse (sort (a, 1)))
 %!assert (sort (sparse (a), 2), sparse (sort (a, 2)))
 %!test
 %! [v, i] = sort (a);
 %! [vs, is] = sort (sparse (a));
-%! assert (vs, sparse (v))
-%! assert (is, i)
-
-%% Sparse Complex
+%! assert (vs, sparse (v));
+%! assert (is, i);
+
+## Sparse Complex
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf])), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 1), sparse ([0, NaN, 1i, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 3), sparse ([0, NaN, 1i, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 
 %!shared a
 %! a = randn (10, 10);
-%! a (a < 0) = 0;
+%! a(a < 0) = 0;
 %! a = 1i * a;
 %!assert (sort (sparse (a)), sparse (sort (a)))
 %!assert (sort (sparse (a), 1), sparse (sort (a, 1)))
 %!assert (sort (sparse (a), 2), sparse (sort (a, 2)))
 %!test
 %! [v, i] = sort (a);
 %! [vs, is] = sort (sparse (a));
-%! assert (vs, sparse (v))
-%! assert (is, i)
-
-%% Sparse Bool
+%! assert (vs, sparse (v));
+%! assert (is, i);
+
+## Sparse Bool
 %!assert (sort (sparse ([true, false, true, false])), sparse ([false, false, true, true]))
-%!assert (sort (sparse([true, false, true, false]), 1), sparse ([true, false, true, false]))
+%!assert (sort (sparse ([true, false, true, false]), 1), sparse ([true, false, true, false]))
 %!assert (sort (sparse ([true, false, true, false]), 2), sparse ([false, false, true, true]))
 %!assert (sort (sparse ([true, false, true, false]), 3), sparse ([true, false, true, false]))
-%!assert (sort (sparse ([true, false, true, false]), "ascend"), sparse([false, false, true, true]))
-%!assert (sort (sparse ([true, false, true, false]), 2, "ascend"), sparse([false, false, true, true]))
+%!assert (sort (sparse ([true, false, true, false]), "ascend"), sparse ([false, false, true, true]))
+%!assert (sort (sparse ([true, false, true, false]), 2, "ascend"), sparse ([false, false, true, true]))
 %!assert (sort (sparse ([true, false, true, false]), "descend"), sparse ([true, true, false, false]))
-%!assert (sort (sparse ([true, false, true, false]), 2, "descend"), sparse([true, true, false, false]))
+%!assert (sort (sparse ([true, false, true, false]), 2, "descend"), sparse ([true, true, false, false]))
 
 %!test
-%! [v, i] = sort (sparse([true, false, true, false]));
-%! assert (v, sparse([false, false, true, true]))
-%! assert (i, [2, 4, 1, 3])
-
-%% Cell string array
+%! [v, i] = sort (sparse ([true, false, true, false]));
+%! assert (v, sparse ([false, false, true, true]));
+%! assert (i, [2, 4, 1, 3]);
+
+## Cell string array
 %!shared a, b, c
 %! a = {"Alice", "Cecile", "Eric", "Barry", "David"};
 %! b = {"Alice", "Barry", "Cecile", "David", "Eric"};
 %! c = {"Eric", "David", "Cecile", "Barry", "Alice"};
-%!assert (sort (a), b);
+%!assert (sort (a), b)
 %!assert (sort (a, 1), a)
 %!assert (sort (a, 2), b)
 %!assert (sort (a, 3), a)
 %!assert (sort (a, "ascend"), b)
 %!assert (sort (a, 2, "ascend"), b)
 %!assert (sort (a, "descend"), c)
 %!assert (sort (a, 2, "descend"), c)
 
 %!test
 %! [v, i] = sort (a);
-%! assert (i, [1, 4, 2, 5, 3])
-
-%!error <Invalid call to sort> sort ();
-%!error <Invalid call to sort> sort (1, 2, 3, 4);
-
+%! assert (i, [1, 4, 2, 5, 3]);
+
+%!error sort ()
+%!error sort (1, 2, 3, 4)
 */
 
 // Sort the rows of the matrix @var{a} according to the order
 // specified by @var{mode}, which can either be `ascend' or `descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
@@ -6335,42 +6283,42 @@ This function does not support sparse ma
 }
 
 /*
 %!shared sm, um, sv, uv
 %! sm = [1, 2; 3, 4];
 %! um = [3, 1; 2, 4];
 %! sv = [1, 2, 3, 4];
 %! uv = [2, 1, 4, 3];
-%!assert(issorted (sm, "rows"));
-%!assert(!issorted (um, "rows"));
-%!assert(issorted (sv));
-%!assert(!issorted (uv));
-%!assert(issorted (sv'));
-%!assert(!issorted (uv'));
-%!assert(issorted (sm, "rows", "ascending"));
-%!assert(!issorted (um, "rows", "ascending"));
-%!assert(issorted (sv, "ascending"));
-%!assert(!issorted (uv, "ascending"));
-%!assert(issorted (sv', "ascending"));
-%!assert(!issorted (uv', "ascending"));
-%!assert(!issorted (sm, "rows", "descending"));
-%!assert(issorted (flipud (sm), "rows", "descending"));
-%!assert(!issorted (sv, "descending"));
-%!assert(issorted (fliplr (sv), "descending"));
-%!assert(!issorted (sv', "descending"));
-%!assert(issorted (fliplr (sv)', "descending"));
-%!assert(!issorted (um, "rows", "either"));
-%!assert(!issorted (uv, "either"));
-%!assert(issorted (sm, "rows", "either"));
-%!assert(issorted (flipud (sm), "rows", "either"));
-%!assert(issorted (sv, "either"));
-%!assert(issorted (fliplr (sv), "either"));
-%!assert(issorted (sv', "either"));
-%!assert(issorted (fliplr (sv)', "either"));
+%!assert (issorted (sm, "rows"))
+%!assert (!issorted (um, "rows"))
+%!assert (issorted (sv))
+%!assert (!issorted (uv))
+%!assert (issorted (sv'))
+%!assert (!issorted (uv'))
+%!assert (issorted (sm, "rows", "ascending"))
+%!assert (!issorted (um, "rows", "ascending"))
+%!assert (issorted (sv, "ascending"))
+%!assert (!issorted (uv, "ascending"))
+%!assert (issorted (sv', "ascending"))
+%!assert (!issorted (uv', "ascending"))
+%!assert (!issorted (sm, "rows", "descending"))
+%!assert (issorted (flipud (sm), "rows", "descending"))
+%!assert (!issorted (sv, "descending"))
+%!assert (issorted (fliplr (sv), "descending"))
+%!assert (!issorted (sv', "descending"))
+%!assert (issorted (fliplr (sv)', "descending"))
+%!assert (!issorted (um, "rows", "either"))
+%!assert (!issorted (uv, "either"))
+%!assert (issorted (sm, "rows", "either"))
+%!assert (issorted (flipud (sm), "rows", "either"))
+%!assert (issorted (sv, "either"))
+%!assert (issorted (fliplr (sv), "either"))
+%!assert (issorted (sv', "either"))
+%!assert (issorted (fliplr (sv)', "either"))
 */
 
 DEFUN (nth_element, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
 Select the n-th smallest element of a vector, using the ordering defined by\n\
 @code{sort}.  In other words, the result is equivalent to\n\
@@ -7066,31 +7014,26 @@ an empty matrix is returned.\n\
       if (! error_state)
         retval = do_diff (args(0), order, dim);
     }
 
   return retval;
 }
 
 /*
-
 %!assert (diff ([1, 2, 3, 4]), [1, 1, 1])
 %!assert (diff ([1, 3, 7, 19], 2), [2, 8])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1]), [4, 2; 3, 3; 1, -1; -6, -5])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1], 3), [-1, -5; -5, 0])
-%!assert (isempty (diff (1)));
-
-%!error diff ([1, 2; 3, 4], -1);
-
-%!error diff ("foo");
-
-%!error diff ();
-
-%!error diff (1, 2, 3, 4);
-
+%!assert (isempty (diff (1)))
+
+%!error diff ()
+%!error diff (1, 2, 3, 4)
+%!error diff ("foo")
+%!error diff ([1, 2; 3, 4], -1)
 */
 
 template <class T>
 static Array<T>
 do_repelems (const Array<T>& src, const Array<octave_idx_type>& rep)
 {
   Array<T> retval;
 
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -420,24 +420,25 @@ changed locally for the function and any
 variable value is restored when exiting the function.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
 /*
-%!error (EDITOR (1, 2));
 %!test
 %! orig_val = EDITOR ();
 %! old_val = EDITOR ("X");
 %! assert (orig_val, old_val);
 %! assert (EDITOR (), "X");
 %! EDITOR (orig_val);
 %! assert (EDITOR (), orig_val);
+
+%!error (EDITOR (1, 2))
 */
 
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
@@ -455,24 +456,25 @@ variable value is restored when exiting 
 
   if (args.length () > 0)
     set_exec_path (VEXEC_PATH);
 
   return retval;
 }
 
 /*
-%!error (EXEC_PATH (1, 2));
 %!test
 %! orig_val = EXEC_PATH ();
 %! old_val = EXEC_PATH ("X");
 %! assert (orig_val, old_val);
 %! assert (EXEC_PATH (), "X");
 %! EXEC_PATH (orig_val);
 %! assert (EXEC_PATH (), orig_val);
+
+%!error (EXEC_PATH (1, 2))
 */
 
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
@@ -482,24 +484,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
 /*
-%!error (IMAGE_PATH (1, 2));
 %!test
 %! orig_val = IMAGE_PATH ();
 %! old_val = IMAGE_PATH ("X");
 %! assert (orig_val, old_val);
 %! assert (IMAGE_PATH (), "X");
 %! IMAGE_PATH (orig_val);
 %! assert (IMAGE_PATH (), orig_val);
+
+%!error (IMAGE_PATH (1, 2))
 */
 
 DEFUN (OCTAVE_HOME, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @end deftypefn")
 {
@@ -509,18 +512,18 @@ Return the name of the top-level Octave 
     retval = Voctave_home;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error OCTAVE_HOME (1);
-%!assert (ischar (OCTAVE_HOME ()));
+%!assert (ischar (OCTAVE_HOME ()))
+%!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave, as a string.\n\
 @end deftypefn")
 {
@@ -532,11 +535,11 @@ Return the version number of Octave, as 
     retval = OCTAVE_VERSION;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error OCTAVE_VERSION (1);
-%!assert (ischar (OCTAVE_VERSION ()));
+%!assert (ischar (OCTAVE_VERSION ()))
+%!error OCTAVE_VERSION (1)
 */
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -612,45 +612,44 @@ glob (\"file[12]\")\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  tmpdir = tmpnam;
-%!  filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
-%!  if (mkdir (tmpdir))
-%!    cwd = pwd;
-%!    cd (tmpdir);
-%!    if strcmp (canonicalize_file_name (pwd), ...
-%!               canonicalize_file_name (tmpdir))
-%!      a = 0;
-%!      for n = 1:5
-%!        save (filename{n}, "a");
-%!      endfor
-%!    else
-%!      rmdir (tmpdir);
-%!      error ("Couldn't change to temporary dir");
-%!    endif
-%!  else
-%!    error ("Couldn't create temporary directory");
-%!  endif
-%!  result1 = glob ("*file1");
-%!  result2 = glob ("myfile?");
-%!  result3 = glob ("file[12]");
-%!  for n = 1:5
-%!    delete (filename{n});
-%!  endfor
-%!  cd (cwd);
-%!  rmdir (tmpdir);
-%!  assert (result1, {"file1"; "myfile1"});
-%!  assert (result2, {"myfile1"});
-%!  assert (result3, {"file1"; "file2"});
+%! tmpdir = tmpnam;
+%! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
+%! if (mkdir (tmpdir))
+%!   cwd = pwd;
+%!   cd (tmpdir);
+%!   if strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir))
+%!     a = 0;
+%!     for n = 1:5
+%!       save (filename{n}, "a");
+%!     endfor
+%!   else
+%!     rmdir (tmpdir);
+%!     error ("Couldn't change to temporary dir");
+%!   endif
+%! else
+%!   error ("Couldn't create temporary directory");
+%! endif
+%! result1 = glob ("*file1");
+%! result2 = glob ("myfile?");
+%! result3 = glob ("file[12]");
+%! for n = 1:5
+%!   delete (filename{n});
+%! endfor
+%! cd (cwd);
+%! rmdir (tmpdir);
+%! assert (result1, {"file1"; "myfile1"});
+%! assert (result2, {"myfile1"});
+%! assert (result3, {"file1"; "file2"});
 */
 
 DEFUNX ("fnmatch", Ffnmatch, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return 1 or zero for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 filename pattern matching.  For example:\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -212,17 +212,17 @@ fopen_mode_to_ios_mode (const std::strin
 
 DEFUN (fclose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fclose (@var{fid})\n\
 @deftypefnx {Built-in Function} {} fclose (\"all\")\n\
 Close the specified file.  If successful, @code{fclose} returns 0,\n\
 otherwise, it returns -1.  The second form of the @code{fclose} call closes\n\
 all open files except @code{stdout}, @code{stderr}, and @code{stdin}.\n\
-@seealso{fopen, fseek, ftell}\n\
+@seealso{fopen, freport}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = octave_stream_list::remove (args(0), "fclose");
@@ -231,16 +231,17 @@ all open files except @code{stdout}, @co
 
   return retval;
 }
 
 DEFUN (fclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclear (@var{fid})\n\
 Clear the stream state for the specified file.\n\
+@seealso{fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -297,26 +298,29 @@ stream before calling @code{input}.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fgetl (@var{fid}, @var{len})\n\
+@deftypefn  {Built-in Function} {@var{str} =} fgetl (@var{fid})\n\
+@deftypefnx {Built-in Function} {@var{str} =} fgetl (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, excluding\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgetl} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgetl} returns @minus{}1.\n\
-@seealso{fread, fscanf}\n\
+\n\
+To read a line and return the terminating newline see @code{fgets}.\n\
+@seealso{fgets, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgetl";
 
   octave_value_list retval;
 
   retval(1) = 0;
   retval(0) = -1;
@@ -345,27 +349,29 @@ If there are no more characters to read,
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} fgets (@var{fid})\n\
-@deftypefnx {Built-in Function} {} fgets (@var{fid}, @var{len})\n\
+@deftypefn  {Built-in Function} {@var{str} =} fgets (@var{fid})\n\
+@deftypefnx {Built-in Function} {@var{str} =} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, including\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgets} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgets} returns @minus{}1.\n\
-@seealso{fputs, fopen, fread, fscanf}\n\
+\n\
+To read a line and discard the terminating newline see @code{fgetl}.\n\
+@seealso{fputs, fgetl, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgets";
 
   octave_value_list retval;
 
   retval(1) = 0.0;
   retval(0) = -1.0;
@@ -394,24 +400,29 @@ If there are no more characters to read,
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fskipl (@var{fid}, @var{count})\n\
-Skip a given number of lines, i.e., discards characters until an end-of-line\n\
-is met exactly @var{count}-times, or end-of-file occurs.\n\
+@deftypefn  {Built-in Function} {@var{nlines} =} fskipl (@var{fid})\n\
+@deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
+@deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, Inf)\n\
+Read and skip @var{count} lines from the file descriptor @var{fid}.\n\
+@code{fskipl} discards characters until an end-of-line is encountered exactly\n\
+@var{count}-times, or until the end-of-file marker is found.\n\
+\n\
+If @var{count} is omitted, it defaults to 1.  @var{count} may also be\n\
+@code{Inf}, in which case lines are skipped until the end of the file.\n\
+This form is suitable for counting the number of lines in a file.\n\
+\n\
 Returns the number of lines skipped (end-of-line sequences encountered).\n\
-If @var{count} is omitted, it defaults to 1. @var{count} may also be\n\
-@code{Inf}, in which case lines are skipped to the end of file.\n\
-This form is suitable for counting lines in a file.\n\
-@seealso{fgetl, fgets}\n\
+@seealso{fgetl, fgets, fscanf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fskipl";
 
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -653,17 +664,17 @@ VAX G floating format.\n\
 \n\
 @samp{cray}\n\
 Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 however, conversions are currently only supported for @samp{native}\n\
 @samp{ieee-be}, and @samp{ieee-le} formats.\n\
-@seealso{fclose, fgets, fputs, fread, fseek, ferror, fprintf, fscanf, ftell, fwrite}\n\
+@seealso{fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
@@ -738,16 +749,17 @@ freport ()\n\
      @print{}  number  mode  name\n\
      @print{}\n\
      @print{}       0     r  stdin\n\
      @print{}       1     w  stdout\n\
      @print{}       2     w  stderr\n\
      @print{}       3     r  myfile\n\
 @end group\n\
 @end example\n\
+@seealso{fopen, fclose}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     warning ("freport: ignoring extra arguments");
@@ -758,16 +770,17 @@ freport ()\n\
 }
 
 DEFUN (frewind, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} frewind (@var{fid})\n\
 Move the file pointer to the beginning of the file @var{fid}, returning\n\
 0 for success, and -1 if an error was encountered.  It is equivalent to\n\
 @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
+@seealso{fseek, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int result = -1;
 
   int nargin = args.length ();
 
@@ -784,28 +797,29 @@ 0 for success, and -1 if an error was en
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
+@deftypefn  {Built-in Function} {} fseek (@var{fid}, @var{offset})\n\
+@deftypefnx {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
+@deftypefnx {Built-in Function} {@var{status} =} fseek (@dots{})\n\
 Set the file pointer to any location within the file @var{fid}.\n\
 \n\
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @w{@code{SEEK_CUR}} (current\n\
 position), @w{@code{SEEK_SET}} (beginning), or @w{@code{SEEK_END}} (end of\n\
 file) or strings \"cof\", \"bof\" or \"eof\".  If @var{origin} is omitted,\n\
-@w{@code{SEEK_SET}} is assumed.  The offset must be zero, or a value returned\n\
-by @code{ftell} (in which case @var{origin} must be @w{@code{SEEK_SET}}).\n\
+@w{@code{SEEK_SET}} is assumed.  @var{offset} may be positive, negative, or zero but not all combinations of @var{origin} and @var{offset} can be realized.\n\
 \n\
 Return 0 on success and -1 on error.\n\
-@seealso{ftell, fopen, fclose}\n\
+@seealso{fskipl, frewind, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
@@ -825,17 +839,17 @@ Return 0 on success and -1 on error.\n\
   return retval;
 }
 
 DEFUN (ftell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters\n\
 from the beginning of the file @var{fid}.\n\
-@seealso{fseek, fopen, fclose}\n\
+@seealso{fseek, feof, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -851,17 +865,17 @@ from the beginning of the file @var{fid}
 }
 
 DEFUN (fprintf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
 written to the stream @var{fid} instead of @code{stdout}.\n\
 If @var{fid} is omitted, the output is written to @code{stdout}.\n\
-@seealso{printf, sprintf, fread, fscanf, fopen, fclose}\n\
+@seealso{fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fprintf";
 
   octave_value retval;
 
   int result = -1;
 
@@ -962,17 +976,17 @@ complete description of the syntax of th
 }
 
 DEFUN (fputs, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fputs (@var{fid}, @var{string})\n\
 Write a string to a file with no formatting.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
-@seealso{scanf, sscanf, fread, fprintf, fgets, fscanf}\n\
+@seealso{fdisp, fprintf, fwrite, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fputs";
 
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -990,16 +1004,17 @@ Return a non-negative number on success 
 }
 
 DEFUN (puts, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
+@seealso{fputs, disp}\n\
 @end deftypefn")
 {
   static std::string who = "puts";
 
   octave_value retval = -1;
 
   if (args.length () == 1)
     retval = stdout_stream.puts (args(0), who);
@@ -1115,17 +1130,17 @@ conversions is returned in @var{count}. 
 specify a locale to take into account language specific features, \n\
 such as decimal separator.  This operation restores the previous locales\n\
 setting at the end of the conversion.\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
-@seealso{scanf, sscanf, fread, fprintf, fgets, fputs}\n\
+@seealso{fgets, fgetl, fread, scanf, sscanf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -1139,17 +1154,17 @@ complete description of the syntax of th
             {
               std::locale oldloc;
               try
                 {
                   // Use args(2) val as the new locale setting. Keep
                   // old val for restoring afterwards.
                   oldloc = 
                     os.imbue (std::locale (args(2).string_value ().c_str ()));
-                  
+
                 }
               catch (std::runtime_error)
                 {
                   // Display a warning if the specified locale is unknown
                   warning ("fscanf: invalid locale. Try `locale -a' for a list of supported values.");
                   oldloc = std::locale::classic ();
                 }
               retval = os.oscanf (args(1), who);
@@ -1327,18 +1342,18 @@ is returned in @var{pos}.\n\
         print_usage ();
     }
 
   return retval;
 }
 
 /*
 %!test
-%! assert(sscanf('1,2', '%f', 'C'), 1)
-%! assert(sscanf('1,2', '%f', 'fr_FR'), 1.2)
+%! assert (sscanf ("1,2", "%f", "C"), 1)
+%! assert (sscanf ("1,2", "%f", "fr_FR"), 1.2)
 */
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} scanf (@var{template}, @var{locale})\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
@@ -1584,17 +1599,17 @@ Cray floating format.\n\
 @end table\n\
 \n\
 @noindent\n\
 Conversions are currently only supported for @code{\"ieee-be\"} and\n\
 @code{\"ieee-le\"} formats.\n\
 \n\
 The data read from the file is returned in @var{val}, and the number of\n\
 values read is returned in @code{count}\n\
-@seealso{fwrite, fopen, fclose}\n\
+@seealso{fwrite, fgets, fgetl, fscanf, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 6)
     {
@@ -1701,17 +1716,17 @@ file.\n\
 The argument @var{data} is a matrix of values that are to be written to\n\
 the file.  The values are extracted in column-major order.\n\
 \n\
 The remaining arguments @var{precision}, @var{skip}, and @var{arch} are\n\
 optional, and are interpreted as described for @code{fread}.\n\
 \n\
 The behavior of @code{fwrite} is undefined if the values in @var{data}\n\
 are too large to fit in the specified precision.\n\
-@seealso{fread, fopen, fclose}\n\
+@seealso{fread, fputs, fprintf, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin > 1 && nargin < 6)
     {
@@ -1754,17 +1769,17 @@ are too large to fit in the specified pr
 
 DEFUNX ("feof", Ffeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for a given\n\
 file and 0 otherwise.  Note that it will only return 1 if the end of the\n\
 file has already been encountered, not if the next read operation will\n\
 result in an end-of-file condition.\n\
-@seealso{fread, fopen, fclose}\n\
+@seealso{fread, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -1776,24 +1791,26 @@ result in an end-of-file condition.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ferror", Fferror, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} ferror (@var{fid}, \"clear\")\n\
+@deftypefn  {Built-in Function} {[@var{err}, @var{msg}] =} ferror (@var{fid})\n\
+@deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} ferror (@var{fid}, \"clear\")\n\
 Return 1 if an error condition has been encountered for the file ID\n\
 @var{fid} and 0 otherwise.  Note that it will only return 1 if an error\n\
 has already been encountered, not if the next operation will result in\n\
 an error condition.\n\
 \n\
 The second argument is optional.  If it is supplied, also clear the\n\
 error condition.\n\
+@seealso{fclear, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -38,24 +38,16 @@ void
 glps_renderer::draw (const graphics_object& go)
 {
   static bool in_draw = false;
 
   if (!in_draw)
     {
       in_draw = true;
 
-      FILE *fp = fdopen (fid, "wb");
-
-      if (! fp)
-        {
-          error ("gl2ps-renderer: fdopen failed");
-          return;
-        }
-
       GLint buffsize = 0, state = GL2PS_OVERFLOW;
       GLint viewport[4];
 
       glGetIntegerv (GL_VIEWPORT, viewport);
 
       GLint gl2ps_term;
       if (term.find ("eps") != std::string::npos) gl2ps_term = GL2PS_EPS;
       else if (term.find ("pdf") != std::string::npos) gl2ps_term = GL2PS_PDF;
@@ -67,34 +59,36 @@ glps_renderer::draw (const graphics_obje
         {
           error ("gl2ps-renderer:: Unknown terminal");
           return;
         }
 
       GLint gl2ps_text = 0;
       if (term.find ("notxt") != std::string::npos) gl2ps_text = GL2PS_NO_TEXT;
 
+      // Default sort order optimizes for 3D plots
+      GLint gl2ps_sort = GL2PS_BSP_SORT;
+      if (term.find ("is2D") != std::string::npos) gl2ps_sort = GL2PS_NO_SORT;
+
       while (state == GL2PS_OVERFLOW)
         {
           buffsize += 1024*1024;
           gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
-                          gl2ps_term, GL2PS_BSP_SORT,
+                          gl2ps_term, gl2ps_sort,
                           (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
                            | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
                            | GL2PS_BEST_ROOT | gl2ps_text
                            | GL2PS_NO_PS3_SHADING),
                           GL_RGBA, 0, NULL, 0, 0, 0,
                           buffsize, fp, "" );
 
           opengl_renderer::draw (go);
           state = gl2psEndPage ();
         }
 
-      gnulib::fclose (fp);
-
       in_draw = 0;
     }
   else
     opengl_renderer::draw (go);
 }
 
 int
 glps_renderer::alignment_to_mode (int ha, int va) const
diff --git a/src/gl2ps-renderer.h b/src/gl2ps-renderer.h
--- a/src/gl2ps-renderer.h
+++ b/src/gl2ps-renderer.h
@@ -26,18 +26,18 @@ along with Octave; see the file COPYING.
 #include "gl-render.h"
 #include "gl2ps.h"
 
 class
 OCTINTERP_API
 glps_renderer : public opengl_renderer
 {
 public:
-  glps_renderer (const int _fid, const std::string& _term)
-    : opengl_renderer () , fid (_fid), term (_term),
+  glps_renderer (FILE *_fp, const std::string& _term)
+    : opengl_renderer () , fp (_fp), term (_term),
     fontsize (), fontname () { }
 
   ~glps_renderer (void) { }
 
   void draw (const graphics_object& go);
 
 protected:
 
@@ -47,23 +47,24 @@ protected:
 
 
   void set_font (const base_properties& props);
 
   void draw_text (const text::properties& props);
   void draw_pixels (GLsizei w, GLsizei h, GLenum format,
                     GLenum type, const GLvoid *data);
 
-  void set_linestyle (const std::string& s, bool use_stipple)
+  void set_linestyle (const std::string& s, bool use_stipple = false)
   {
     opengl_renderer::set_linestyle (s, use_stipple);
-    if (use_stipple)
+
+    if (s == "-" && ! use_stipple)
+      gl2psDisable (GL2PS_LINE_STIPPLE);
+    else
       gl2psEnable (GL2PS_LINE_STIPPLE);
-    else
-      gl2psDisable (GL2PS_LINE_STIPPLE);
   }
 
   void set_polygon_offset (bool on, double offset = 0.0)
   {
     opengl_renderer::set_polygon_offset (on, offset);
     if (on)
       gl2psEnable (GL2PS_POLYGON_OFFSET_FILL);
     else
@@ -72,15 +73,15 @@ protected:
 
   void set_linewidth (float w)
   {
     gl2psLineWidth (w);
   }
 
 private:
   int alignment_to_mode (int ha, int va) const;
-  int fid;
+  FILE *fp;
   caseless_str term;
   double fontsize;
   std::string fontname;
 };
 
 #endif
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1962,23 +1962,23 @@ graphics_object::set (const octave_value
             error ("set: expecting argument %d to be a property name", i);
         }
     }
   else
     error ("set: invalid number of arguments");
 }
 
 /*
-%!# test set with name, value pairs
+## test set with name, value pairs
 %!test
-%!  set(gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, "linewidth", 10, "marker", "x");
-%!  assert (get (h, "linewidth"), 10);
-%!  assert (get (h, "marker"), "x");
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, "linewidth", 10, "marker", "x");
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
 */
 
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
@@ -1997,44 +1997,44 @@ graphics_object::set (const Array<std::s
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
-%!# test set with cell array arguments
+## test set with cell array arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, {"linewidth", "marker"}, {10, "x"});
-%!  assert (get(h, "linewidth"), 10);
-%!  assert (get(h, "marker"), "x");
-
-%!# test set with multiple handles and cell array arguments
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, {"linewidth", "marker"}, {10, "x"});
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
+
+## test set with multiple handles and cell array arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
-%!  assert (get (h, "linewidth"), {10; 5});
-%!  assert (get (h, "marker"), {"x"; "o"});
-%!  set (h, {"linewidth", "marker"}, {10, "x"});
-%!  assert (get (h, "linewidth"), {10; 10});
-%!  assert (get (h, "marker"), {"x"; "x"});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
+%! assert (get (h, "linewidth"), {10; 5});
+%! assert (get (h, "marker"), {"x"; "o"});
+%! set (h, {"linewidth", "marker"}, {10, "x"});
+%! assert (get (h, "linewidth"), {10; 10});
+%! assert (get (h, "marker"), {"x"; "x"});
 
 %!error <set: number of graphics handles must match number of value rows>
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
 
 %!error <set: number of names must match number of value columns>
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth"}, {10, "x"; 5, "o"});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth"}, {10, "x"; 5, "o"});
 */
 
 // Set properties given in a struct array
 void
 graphics_object::set (const octave_map& m)
 {
   for (octave_map::const_iterator p = m.begin ();
        p != m.end (); p++)
@@ -2046,26 +2046,26 @@ graphics_object::set (const octave_map& 
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
-%!# test set with struct arguments
+## test set with struct arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, struct ("linewidth", 10, "marker", "x"));
-%!  assert (get (h, "linewidth"), 10);
-%!  assert (get (h, "marker"), "x");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, struct ("linewidth", {5, 10}));
-%!  assert (get(h, "linewidth"), {10; 10});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, struct ("linewidth", 10, "marker", "x"));
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, struct ("linewidth", {5, 10}));
+%! assert (get (h, "linewidth"), {10; 10});
 */
 
 // Set a property to a value or to its (factory) default value.
 
 void
 graphics_object::set_value_or_default (const caseless_str& name,
                                        const octave_value& val)
 {
@@ -2096,25 +2096,25 @@ graphics_object::set_value_or_default (c
       else
         rep->set (name, val);
     }
   else
     rep->set (name, val);
 }
 
 /*
-%!# test setting of default values
+## test setting of default values
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (0, "defaultlinelinewidth", 20);
-%!  set (h, "linewidth", "default");
-%!  assert (get (h, "linewidth"), 20);
-%!  set (h, "linewidth", "factory");
-%!  assert (get (h, "linewidth"), 0.5);
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (0, "defaultlinelinewidth", 20);
+%! set (h, "linewidth", "default");
+%! assert (get (h, "linewidth"), 20);
+%! set (h, "linewidth", "factory");
+%! assert (get (h, "linewidth"), 0.5);
 */
 
 static double
 make_handle_fraction (void)
 {
   static double maxrand = RAND_MAX + 2.0;
 
   return (rand () + 1.0) / maxrand;
@@ -3050,29 +3050,29 @@ root_figure::properties::get_boundingbox
   Matrix pos = Matrix (1, 4, 0);
   pos(2) = screen_size(0);
   pos(3) = screen_size(1);
   return pos;
 }
 
 /*
 %!test
-%! set (0, "units", "pixels")
+%! set (0, "units", "pixels");
 %! sz = get (0, "screensize") - [1, 1, 0, 0];
 %! dpi = get (0, "screenpixelsperinch");
-%! set (0, "units", "inches")
-%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi) 
-%! set (0, "units", "centimeters")
-%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54)
-%! set (0, "units", "points")
-%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72)
-%! set (0, "units", "normalized")
-%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0])
-%! set (0, "units", "pixels")
-%! assert (get (0, "screensize"), sz + [1, 1, 0, 0])
+%! set (0, "units", "inches");
+%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi);
+%! set (0, "units", "centimeters");
+%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54);
+%! set (0, "units", "points");
+%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72);
+%! set (0, "units", "normalized");
+%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0]);
+%! set (0, "units", "pixels");
+%! assert (get (0, "screensize"), sz + [1, 1, 0, 0]);
 */
 
 void
 root_figure::properties::remove_child (const graphics_handle& gh)
 {
   gh_manager::pop_figure (gh);
 
   graphics_handle cf = gh_manager::current_figure ();
@@ -3651,16 +3651,21 @@ figure::properties::update_papersize (vo
       else if (std::abs (sz(0) - 22.0) + std::abs (sz(1) - 34.0) < tol)
         typ = "d";
       else if (std::abs (sz(0) - 34.0) + std::abs (sz(1) - 43.0) < tol)
         typ = "e";
       // Call papertype.set rather than set_papertype to avoid loops between
       // update_papersize and update_papertype
       papertype.set (typ);
     }
+  if (get_paperorientation () == "landscape")
+    {
+      std::swap (sz(0), sz(1));
+      papersize.set (octave_value (sz));
+    }
 }
 
 void
 figure::properties::update_paperorientation (void)
 {
   std::string porient = get_paperorientation ();
   Matrix sz = get_papersize ().matrix_value ();
   Matrix pos = get_paperposition ().matrix_value ();
@@ -3676,32 +3681,33 @@ figure::properties::update_paperorientat
       paperposition.set (octave_value (pos));
     }
 }
 
 /*
 %!test
 %! figure (1, "visible", false);
 %! tol = 100 * eps ();
-%! set (gcf (), "paperorientation", "PORTRAIT")
-%! set (gcf (), "paperunits", "inches")
-%! set (gcf (), "papertype", "USletter")
-%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol)
-%! set (gcf (), "paperorientation", "Landscape")
-%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol)
-%! set (gcf (), "paperunits", "centimeters")
-%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol)
+%! ## UPPER case and MiXed case is part of test and should not be changed.
+%! set (gcf (), "paperorientation", "PORTRAIT");
+%! set (gcf (), "paperunits", "inches");
+%! set (gcf (), "papertype", "USletter");
+%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol);
+%! set (gcf (), "paperorientation", "Landscape");
+%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol);
+%! set (gcf (), "paperunits", "centimeters");
+%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol);
 %! set (gcf (), "papertype", "a4");
-%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol)
-%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0])
-%! assert (get (gcf (), "papertype"), "usletter")
-%! assert (get (gcf (), "paperorientation"), "portrait")
-%! set (gcf (), "papersize", [11.0, 8.5])
-%! assert (get (gcf (), "papertype"), "usletter")
-%! assert (get (gcf (), "paperorientation"), "landscape")
+%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol);
+%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0]);
+%! assert (get (gcf (), "papertype"), "usletter");
+%! assert (get (gcf (), "paperorientation"), "portrait");
+%! set (gcf (), "papersize", [11.0, 8.5]);
+%! assert (get (gcf (), "papertype"), "usletter");
+%! assert (get (gcf (), "paperorientation"), "landscape");
 */
 
 void
 figure::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
@@ -3717,23 +3723,23 @@ void
 figure::properties::update_units (const caseless_str& old_units)
 {
   position.set (convert_position (get_position ().matrix_value (), old_units,
                                   get_units (), screen_size_pixels ()), false);
 }
 
 /*
 %!test
-%! figure (1, "visible", false)
-%! set (0, "units", "pixels")
+%! figure (1, "visible", false);
+%! set (0, "units", "pixels");
 %! rsz = get (0, "screensize");
-%! set (gcf (), "units", "pixels")
+%! set (gcf (), "units", "pixels");
 %! fsz = get (gcf (), "position");
-%! set (gcf (), "units", "normalized")
-%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]))
+%! set (gcf (), "units", "normalized");
+%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]));
 */
 
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
@@ -4928,53 +4934,68 @@ axes::properties::update_axes_layout (vo
       }
     else
       zpTick = zPlane;
   }
 
   Matrix viewmat = get_view ().matrix_value ();
   nearhoriz = std::abs(viewmat(1)) <= 5;
 
-  update_ticklengths ();
-}
-
-void
-axes::properties::update_ticklengths (void)
+  update_ticklength ();
+}
+
+void
+axes::properties::update_ticklength (void)
 {
   bool mode2d = (((xstate > AXE_DEPTH_DIR ? 1 : 0) +
                   (ystate > AXE_DEPTH_DIR ? 1 : 0) +
                   (zstate > AXE_DEPTH_DIR ? 1 : 0)) == 2);
+
   if (tickdirmode_is ("auto"))
-  {
-    // FIXME: tickdir should be updated (code below comes
-    //        from JHandles)
-    //autoMode++;
-    //TickDir.set(mode2d ? "in" : "out", true);
-    //autoMode--;
-  }
-
-  //double ticksign = (tickdir_is ("in") ? -1 : 1);
-  double ticksign = (tickdirmode_is ("auto") ?
-                     (mode2d ? -1 : 1) :
-                     (tickdir_is ("in") ? -1 : 1));
-  // FIXME: use ticklength property
-  xticklen = ticksign*7;
-  yticklen = ticksign*7;
-  zticklen = ticksign*7;
+    tickdir.set (mode2d ? "in" : "out", true);
+
+  double ticksign = (tickdir_is ("in") ? -1 : 1);
+
+  Matrix bbox = get_boundingbox (true);
+  Matrix ticklen = get_ticklength ().matrix_value ();
+  ticklen(0) = ticklen(0) * std::max (bbox(2), bbox(3));
+  ticklen(1) = ticklen(1) * std::max (bbox(2), bbox(3));
+
+  xticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
+  yticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
+  zticklen = ticksign * (mode2d ? ticklen(0) : ticklen(1));
 
   xtickoffset = (mode2d ? std::max (0., xticklen) : std::abs (xticklen)) + 5;
   ytickoffset = (mode2d ? std::max (0., yticklen) : std::abs (yticklen)) + 5;
   ztickoffset = (mode2d ? std::max (0., zticklen) : std::abs (zticklen)) + 5;
 
   update_xlabel_position ();
   update_ylabel_position ();
   update_zlabel_position ();
   update_title_position ();
 }
 
+/*
+## FIXME: A demo can't be called in a C++ file.  This should be made a test
+## or moved to a .m file where it can be called.
+%!demo
+%! clf;
+%! subplot (2,1,1);
+%! plot (rand (3));
+%! xlabel xlabel;
+%! ylabel ylabel;
+%! title title;
+%! subplot (2,1,2);
+%! plot (rand (3));
+%! set (gca, "ticklength", get (gca, "ticklength") * 2, "tickdir", "out");
+%! xlabel xlabel;
+%! ylabel ylabel;
+%! title title;
+*/
+
 static bool updating_xlabel_position = false;
 
 void
 axes::properties::update_xlabel_position (void)
 {
   if (updating_xlabel_position)
     return;
 
@@ -6864,23 +6885,31 @@ text::properties::get_data_position (voi
     pos = convert_text_position (pos, *this, get_units (), "data");
 
   return pos;
 }
 
 Matrix
 text::properties::get_extent_matrix (void) const
 {
+  // FIXME: Should this function also add the (x,y) base position?
   return extent.get ().matrix_value ();
 }
 
 octave_value
 text::properties::get_extent (void) const
 {
+  // FIXME: This doesn't work right for 3D plots.
+  // (It doesn't in Matlab either, at least not in version 6.5.)
   Matrix m = extent.get ().matrix_value ();
+  Matrix pos = get_position ().matrix_value ();
+  Matrix p = convert_text_position (pos, *this, get_units (), "pixels");
+
+  m(0) += p(0);
+  m(1) += p(1);
 
   return convert_text_position (m, *this, "pixels", get_units ());
 }
 
 void
 text::properties::update_font (void)
 {
 #ifdef HAVE_FREETYPE
@@ -6918,16 +6947,20 @@ text::properties::update_text_extent (vo
   // FIXME: string should be parsed only when modified, for efficiency
 
   octave_value string_prop = get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
                            halign, valign, get_rotation ());
+  /* The bbox is relative to the text's position.
+     We'll leave it that way, because get_position() does not return
+     valid results when the text is first constructed.
+     Conversion to proper coordinates is performed in get_extent. */
   set_extent (bbox);
 
 #endif
 
   if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
       autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
     update_autopos ("sync");
 }
@@ -8578,17 +8611,17 @@ values or lists respectively.\n\
             retval = vals;
         }
     }
 
   return retval;
 }
 
 /*
-%!assert (get (findobj (0, 'Tag', 'nonexistenttag'), 'nonexistentproperty'), [])
+%!assert (get (findobj (0, "Tag", "nonexistenttag"), "nonexistentproperty"), [])
 */
 
 // Return all properties from the graphics handle @var{h}.
 // If @var{h} is a vector, return a cell array including the
 // property values or lists respectively.
 
 DEFUN (__get__, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -3819,17 +3819,17 @@ public:
       string_array_property linestyleorder , "-"
       double_property linewidth , 0.5
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
       array_property plotboxaspectratio mu , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode u , "{auto}|manual"
       radio_property projection , "{orthographic}|perpective"
       radio_property tickdir mu , "{in}|out"
       radio_property tickdirmode u , "{auto}|manual"
-      array_property ticklength , default_axes_ticklength ()
+      array_property ticklength u , default_axes_ticklength ()
       array_property tightinset r , Matrix (1, 4, 0.0)
       // FIXME -- uicontextmenu should be moved here.
       radio_property units SU , "{normalized}|inches|centimeters|points|pixels|characters"
       // hidden properties for transformation computation
       array_property x_viewtransform h , Matrix (4, 4, 0.0)
       array_property x_projectiontransform h , Matrix (4, 4, 0.0)
       array_property x_viewporttransform h , Matrix (4, 4, 0.0)
       array_property x_normrendertransform h , Matrix (4, 4, 0.0)
@@ -3892,19 +3892,19 @@ public:
         update_axes_layout ();
         update_xlabel_position ();
       }
 
     void update_xdir (void) { update_camera (); update_axes_layout (); }
     void update_ydir (void) { update_camera (); update_axes_layout (); }
     void update_zdir (void) { update_camera (); update_axes_layout (); }
 
-    void update_ticklengths (void);
-    void update_tickdir (void) { update_ticklengths (); }
-    void update_tickdirmode (void) { update_ticklengths (); }
+    void update_ticklength (void);
+    void update_tickdir (void) { update_ticklength (); }
+    void update_tickdirmode (void) { update_ticklength (); }
 
     void update_xtick (void)
       {
         if (xticklabelmode.is ("auto"))
           calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
       }
     void update_ytick (void)
       {
@@ -4230,23 +4230,48 @@ public:
 class OCTINTERP_API text : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     double get_fontsize_points (double box_pix_height = 0) const;
 
+    void set_position (const octave_value& val)
+    {
+      if (! error_state)
+        {
+          octave_value new_val (val);
+    
+          if (new_val.numel () == 2)
+            {
+              dim_vector dv (1, 3);
+    
+              new_val = new_val.resize (dv, true);
+            }
+
+          if (position.set (new_val, false))
+            {
+              set_positionmode ("manual");
+              update_position ();
+              position.run_listeners (POSTSET);
+              mark_modified ();
+            }
+          else
+            set_positionmode ("manual");
+        }
+    }
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (text)
       text_label_property string u , ""
       radio_property units u , "{data}|pixels|normalized|inches|centimeters|points"
-      array_property position mu , Matrix (1, 3, 0.0)
+      array_property position smu , Matrix (1, 3, 0.0)
       double_property rotation mu , 0
       radio_property horizontalalignment mu , "{left}|center|right"
       color_property color u , color_values (0, 0, 0)
       string_property fontname u , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize u , 10
       radio_property fontangle u , "{normal}|italic|oblique"
       radio_property fontweight u , "light|{normal}|demi|bold"
       radio_property interpreter u , "{tex}|none|latex"
@@ -4282,17 +4307,16 @@ public:
 #if HAVE_FREETYPE
     // freetype renderer, used for calculation of text size
     ft_render renderer;
 #endif
 
   protected:
     void init (void)
       {
-        position.add_constraint (dim_vector (1, 2));
         position.add_constraint (dim_vector (1, 3));
         cached_units = get_units ();
         update_font ();
       }
 
   private:
     void update_position (void)
       {
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -107,17 +107,17 @@ Compute the inverse cosine in radians fo
 %!test
 %! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
 %! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! assert (acos (x), v, sqrt (eps));
 
 %!test
 %! x = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
 %! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
-%! assert (acos (x), v, sqrt (eps ('single')));
+%! assert (acos (x), v, sqrt (eps ("single")));
 
 %!error acos ()
 %!error acos (1, 2)
 */
 
 DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
@@ -138,17 +138,17 @@ Compute the inverse hyperbolic cosine fo
 %!test
 %! x = [1, 0, -1, 0];
 %! v = [0, pi/2*i, pi*i, pi/2*i];
 %! assert (acosh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([1, 0, -1, 0]);
 %! v = single ([0, pi/2*i, pi*i, pi/2*i]);
-%! assert (acosh (x), v, sqrt (eps ('single')));
+%! assert (acosh (x), v, sqrt (eps ("single")));
 
 %!error acosh ()
 %!error acosh (1, 2)
 */
 
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
@@ -208,17 +208,17 @@ arg (3 + 4i)\n\
 %!test
 %! if (ismac ())
 %!   ## Avoid failing for a MacOS feature
 %!   assert (arg (single (-1)), single (pi), 2*eps (single (1)));
 %! else
 %!   assert (arg (single (-1)), single (pi));
 %! endif
 %!assert (arg (single (-i)), single (-pi/2))
-%!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ('single'))
+%!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ("single"))
 
 %!error arg ()
 %!error arg (1, 2)
 */
 
 DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
@@ -267,17 +267,17 @@ Compute the inverse hyperbolic sine for 
 %!test
 %! v = [0, pi/2*i, 0, -pi/2*i];
 %! x = [0, i, 0, -i];
 %! assert (asinh (x), v,  sqrt (eps));
 
 %!test
 %! v = single ([0, pi/2*i, 0, -pi/2*i]);
 %! x = single ([0, i, 0, -i]);
-%! assert (asinh (x), v,  sqrt (eps ('single')));
+%! assert (asinh (x), v,  sqrt (eps ("single")));
 
 %!error asinh ()
 %!error asinh (1, 2)
 */
 
 DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
@@ -302,17 +302,17 @@ Compute the inverse tangent in radians f
 %!test
 %! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
 %! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
 %! assert (atan (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
 %! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert (atan (x), v, sqrt (eps ('single')));
+%! assert (atan (x), v, sqrt (eps ("single")));
 
 %!error atan ()
 %!error atan (1, 2)
 */
 
 DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
@@ -333,17 +333,17 @@ Compute the inverse hyperbolic tangent f
 %!test
 %! v = [0, 0];
 %! x = [0, 0];
 %! assert (atanh (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, 0]);
 %! x = single ([0, 0]);
-%! assert (atanh (x), v, sqrt (eps ('single')));
+%! assert (atanh (x), v, sqrt (eps ("single")));
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
 
 DEFUN (cbrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cbrt (@var{x})\n\
@@ -397,26 +397,26 @@ ceil ([-2.7, 2.7])\n\
     retval = args(0).ceil ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% double precision
+## double precision
 %!assert (ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1])
 
-%% complex double precison
+## complex double precison
 %!assert (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i])
 
-%% single precision
+## single precision
 %!assert (ceil (single ([2, 1.1, -1.1, -1])), single ([2, 2, -1, -1]))
 
-%% complex single precision
+## complex single precision
 %!assert (ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 2+2i, -1-i, -1-i]))
 
 %!error ceil ()
 %!error ceil (1, 2)
 */
 
 DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
@@ -483,17 +483,17 @@ Compute the cosine for each element of @
 %! v = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
 %! assert (cos (x), v, sqrt (eps));
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
-%! assert (cos (x), v, sqrt (eps ('single')));
+%! assert (cos (x), v, sqrt (eps ("single")));
 
 %!error cos ()
 %!error cos (1, 2)
 */
 
 DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
@@ -514,17 +514,17 @@ Compute the hyperbolic cosine for each e
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [1, 0, -1, 0];
 %! assert (cosh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
 %! v = single ([1, 0, -1, 0]);
-%! assert (cosh (x), v, sqrt (eps ('single')));
+%! assert (cosh (x), v, sqrt (eps ("single")));
 
 %!error cosh ()
 %!error cosh (1, 2)
 */
 
 DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
@@ -533,22 +533,21 @@ Compute the error function,\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-@c spacing appears odd here, but is correct after Makeinfo\n\
-                          z\n\
-                         /\n\
-erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
-                        /\n\
-                     t=0\n\
+                        z\n\
+              2        /\n\
+erf (z) = --------- *  | e^(-t^2) dt\n\
+          sqrt (pi)    /\n\
+                    t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erfcx, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -563,32 +562,32 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erf (a), erf (real (a)));
 
 %!test
 %! x = [0,.5,1];
 %! v = [0, .520499877813047, .842700792949715];
-%! assert (all (abs (erf (x)-v) < 1.e-10));
-%! assert (all (abs (erf (-x)+v) < 1.e-10));
-%! assert (all (abs (erfc (x)+v-1) < 1.e-10));
-%! assert (all (abs (erfinv (v)-x) < 1.e-10));
+%! assert (erf (x), v, 1.e-10);
+%! assert (erf (-x), -v, 1.e-10);
+%! assert (erfc (x), 1-v, 1.e-10);
+%! assert (erfinv (v), x, 1.e-10);
 
 %!test
 %! a = -1i*sqrt (single (-1/(6.4187*6.4187)));
 %! assert (erf (a), erf (real (a)));
 
 %!test
 %! x = single ([0,.5,1]);
 %! v = single ([0, .520499877813047, .842700792949715]);
-%! assert (all (abs (erf (x)-v) < 1.e-6));
-%! assert (all (abs (erf (-x)+v) < 1.e-6));
-%! assert (all (abs (erfc (x)+v-1) < 1.e-6));
-%! assert (all (abs (erfinv (v)-x) < 1.e-6));
+%! assert (erf (x), v, 1.e-6);
+%! assert (erf (-x), -v, 1.e-6);
+%! assert (erfc (x), 1-v, 1.e-6);
+%! assert (erfinv (v), x, 1.e-6);
 
 %!error erf ()
 %!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
@@ -605,26 +604,26 @@ erf (@var{y}) == @var{x}\n\
     retval = args(0).erfinv ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% middle region
+## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
 %!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), 1e-8)
-%% tail region
+## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
 %!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), 1e-8)
-%% backward - loss of accuracy
+## backward - loss of accuracy
 %!assert (erfinv (erf ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
 %!assert (erfinv (erf (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
-%% exceptional
+## exceptional
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
 DEFUN (erfc, args, ,
@@ -682,17 +681,17 @@ exp (z^2) * erfc (x)\n\
     retval = args(0).erfcx ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% FIXME: Need a test for erfcx
+## FIXME: Need a test for erfcx
 
 %!error erfcx ()
 %!error erfcx (1, 2)
 */
 
 DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
@@ -715,18 +714,18 @@ exponential, see @ref{Linear Algebra}.\n
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps))
 %!assert (exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps))
-%!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ('single')))
-%!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ('single')))
+%!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ("single")))
+%!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ("single")))
 
 %!assert (exp ([Inf, -Inf, NaN]), [Inf 0 NaN])
 %!assert (exp (single ([Inf, -Inf, NaN])), single ([Inf 0 NaN]))
 
 %!error exp ()
 %!error exp (1, 2)
 */
 
@@ -880,19 +879,18 @@ Compute the Gamma function,\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-@c spacing appears odd here, but is correct after Makeinfo\n\
-              infinity\n\
-             /\n\
+             infinity\n\
+            /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
@@ -919,17 +917,17 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 
 %!test
 %! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
 %! assert (gamma (a), gamma (real (a)));
 
 %!test
 %! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
 %! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert (gamma (x), v, sqrt (eps ('single')));
+%! assert (gamma (x), v, sqrt (eps ("single")));
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 1, Inf];
 %! assert (gamma (x), v);
 %! assert (gamma (single (x)), single (v));
 
 %!error gamma ()
@@ -956,17 +954,17 @@ Return the imaginary part of @var{z} as 
 %!assert (imag (1), 0)
 %!assert (imag (i), 1)
 %!assert (imag (1+i), 1)
 %!assert (imag ([i, 1; 1, i]), full (eye (2)))
 
 %!assert (imag (single (1)), single (0))
 %!assert (imag (single (i)), single (1))
 %!assert (imag (single (1+i)), single (1))
-%!assert (imag (single ([i, 1; 1, i])), full (eye (2,'single')))
+%!assert (imag (single ([i, 1; 1, i])), full (eye (2,"single")))
 
 %!error imag ()
 %!error imag (1, 2)
 */
 
 DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
@@ -987,17 +985,17 @@ letters or digits and false where they a
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (isalnum (charset) == result));
+%! assert (isalnum (charset), result);
 
 %!error isalnum ()
 %!error isalnum (1, 2)
 */
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
@@ -1017,17 +1015,17 @@ letters and false where they are not.  T
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (isalpha (charset) == result));
+%! assert (isalpha (charset), result);
 
 %!error isalpha ()
 %!error isalpha (1, 2)
 */
 
 DEFUNX ("isascii", Fisascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
@@ -1044,17 +1042,17 @@ not.\n\
 
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = true (1, 128);
-%! assert (all (isascii (charset) == result));
+%! assert (isascii (charset), result);
 
 %!error isascii ()
 %!error isascii (1, 2)
 */
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
@@ -1073,17 +1071,17 @@ control characters and false where they 
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(1:32) = true;
 %! result(128) = true;
-%! assert (all (iscntrl (charset) == result));
+%! assert (iscntrl (charset), result);
 
 %!error iscntrl ()
 %!error iscntrl (1, 2)
 */
 
 DEFUNX ("isdigit", Fisdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
@@ -1101,17 +1099,17 @@ decimal digits (0-9) and false where the
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("0":"9") + 1) = true;
-%! assert (all (isdigit (charset) == result));
+%! assert (isdigit (charset), result);
 
 %!error isdigit ()
 %!error isdigit (1, 2)
 */
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
@@ -1172,17 +1170,17 @@ not.\n\
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:127) = true;
-%! assert (all (isgraph (charset) == result));
+%! assert (isgraph (charset), result);
 
 %!error isgraph ()
 %!error isgraph (1, 2)
 */
 
 DEFUNX ("islower", Fislower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
@@ -1200,17 +1198,17 @@ lowercase letters and false where they a
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (islower (charset) == result));
+%! assert (islower (charset), result);
 
 %!error islower ()
 %!error islower (1, 2)
 */
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
@@ -1313,17 +1311,17 @@ are not.\n\
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(33:127) = true;
-%! assert (all (isprint (charset) == result));
+%! assert (isprint (charset), result);
 
 %!error isprint ()
 %!error isprint (1, 2)
 */
 
 DEFUNX ("ispunct", Fispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
@@ -1344,17 +1342,17 @@ punctuation characters and false where t
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:48) = true;
 %! result(59:65) = true;
 %! result(92:97) = true;
 %! result(124:127) = true;
-%! assert (all (ispunct (charset) == result));
+%! assert (ispunct (charset), result);
 
 %!error ispunct ()
 %!error ispunct (1, 2)
 */
 
 DEFUNX ("isspace", Fisspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
@@ -1373,17 +1371,17 @@ vertical tab) and false where they are n
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii (" \f\n\r\t\v") + 1) = true;
-%! assert (all (isspace (charset) == result));
+%! assert (isspace (charset), result);
 
 %!error isspace ()
 %!error isspace (1, 2)
 */
 
 DEFUNX ("isupper", Fisupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
@@ -1401,17 +1399,17 @@ uppercase letters and false where they a
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
-%! assert (all (isupper (charset) == result));
+%! assert (isupper (charset), result);
 
 %!error isupper ()
 %!error isupper (1, 2)
 */
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
@@ -1431,17 +1429,17 @@ hexadecimal digits (0-9 and @nospell{a-f
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"F") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
 %! result(toascii ("a":"f") + 1) = true;
-%! assert (all (isxdigit (charset) == result));
+%! assert (isxdigit (charset), result);
 
 %!error isxdigit ()
 %!error isxdigit (1, 2)
 */
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} lgamma (@var{x})\n\
@@ -1457,40 +1455,40 @@ Return the natural logarithm of the gamm
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
-%! assert (lgamma(a), lgamma(real(a)));
+%! assert (lgamma (a), lgamma (real (a)));
 
 %!test
 %! x = [.5, 1, 1.5, 2, 3, 4, 5];
 %! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert (lgamma(x), log(v), sqrt (eps))
+%! assert (lgamma (x), log (v), sqrt (eps))
 
 %!test
 %! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
-%! assert (lgamma(a), lgamma(real(a)));
+%! assert (lgamma (a), lgamma (real (a)));
 
 %!test
 %! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
 %! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert (lgamma(x), log(v), sqrt (eps ('single')))
+%! assert (lgamma (x), log (v), sqrt (eps ("single")))
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 0, Inf];
-%! assert (lgamma(x), v);
-%! assert (lgamma(single (x)), single (v));
+%! assert (lgamma (x), v);
+%! assert (lgamma (single (x)), single (v));
 
-%!error lgamma()
-%!error lgamma(1,2)
+%!error lgamma ()
+%!error lgamma (1,2)
 */
 
 DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm,\n\
 @tex\n\
 $\\ln{(x)},$\n\
@@ -1509,20 +1507,20 @@ matrix logarithm, see @ref{Linear Algebr
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log ([1, e, e^2]), [0, 1, 2], sqrt (eps))
-%!assert (log ([-0.5, -1.5, -2.5]), log([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
+%!assert (log ([-0.5, -1.5, -2.5]), log ([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
 
-%!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ('single')))
-%!assert (log (single ([-0.5, -1.5, -2.5])), single (log([0.5, 1.5, 2.5]) + pi*1i), 4*eps ('single'))
+%!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ("single")))
+%!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
 
 %!error log ()
 %!error log (1, 2)
 */
 
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
@@ -1536,17 +1534,17 @@ Compute the base-10 logarithm of each el
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
-%!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ('single')))
+%!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
 */
 
 DEFUN (log1p, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
@@ -1567,17 +1565,17 @@ accurately in the neighborhood of zero.\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
-%!assert (log1p (single ([0, 2*eps, -2*eps])), single([0, 2*eps, -2*eps]), 1e-29)
+%!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
 */
 
 DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
@@ -1598,17 +1596,17 @@ Return the real part of @var{z}.\n\
 %!assert (real (1), 1)
 %!assert (real (i), 0)
 %!assert (real (1+i), 1)
 %!assert (real ([1, i; i, 1]), full (eye (2)))
 
 %!assert (real (single (1)), single (1))
 %!assert (real (single (i)), single (0))
 %!assert (real (single (1+i)), single (1))
-%!assert (real (single ([1, i; i, 1])), full (eye (2,'single')))
+%!assert (real (single ([1, i; i, 1])), full (eye (2,"single")))
 
 %!error real ()
 %!error real (1, 2)
 */
 
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
@@ -1768,17 +1766,17 @@ Compute the sine for each element of @va
 %!test
 %! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
 %! assert (sin (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
-%! assert (sin (x), v, sqrt (eps ('single')));
+%! assert (sin (x), v, sqrt (eps ("single")));
 
 %!error sin ()
 %!error sin (1, 2)
 */
 
 DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
@@ -1799,17 +1797,17 @@ Compute the hyperbolic sine for each ele
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [0, i, 0, -i];
 %! assert (sinh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
 %! v = single ([0, i, 0, -i]);
-%! assert (sinh (x), v, sqrt (eps ('single')));
+%! assert (sinh (x), v, sqrt (eps ("single")));
 
 %!error sinh ()
 %!error sinh (1, 2)
 */
 
 DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
@@ -1831,18 +1829,18 @@ a complex result is returned.  To comput
 /*
 %!assert (sqrt (4), 2)
 %!assert (sqrt (-1), i)
 %!assert (sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps))
 %!assert (sqrt ([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt (eps))
 
 %!assert (sqrt (single (4)), single (2))
 %!assert (sqrt (single (-1)), single (i))
-%!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ('single')))
-%!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ('single')))
+%!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ("single")))
+%!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ("single")))
 
 %!error sqrt ()
 %!error sqrt (1, 2)
 */
 
 DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
@@ -1867,17 +1865,17 @@ Compute the tangent for each element of 
 %!test
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
 %! assert (tan (x), v,  sqrt (eps));
 
 %!test
 %! x = single ([0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert (tan (x), v,  sqrt (eps ('single')));
+%! assert (tan (x), v,  sqrt (eps ("single")));
 
 %!error tan ()
 %!error tan (1, 2)
 */
 
 DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
@@ -1898,17 +1896,17 @@ Compute hyperbolic tangent for each elem
 %!test
 %! x = [0, pi*i];
 %! v = [0, 0];
 %! assert (tanh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi*i]);
 %! v = single ([0, 0]);
-%! assert (tanh (x), v, sqrt (eps ('single')));
+%! assert (tanh (x), v, sqrt (eps ("single")));
 
 %!error tanh ()
 %!error tanh (1, 2)
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
@@ -1969,35 +1967,35 @@ tolower (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
 /*
-%!assert (tolower("OCTAVE"), "octave")
-%!assert (tolower("123OCTave!_&"), "123octave!_&")
-%!assert (tolower({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
-%!assert (tolower(["ABC"; "DEF"]), ["abc"; "def"])
-%!assert (tolower({["ABC"; "DEF"]}), {["abc";"def"]})
-%!assert (tolower(68), "d")
-%!assert (tolower({[68, 68; 68, 68]}), {["dd";"dd"]})
+%!assert (tolower ("OCTAVE"), "octave")
+%!assert (tolower ("123OCTave!_&"), "123octave!_&")
+%!assert (tolower ({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
+%!assert (tolower (["ABC"; "DEF"]), ["abc"; "def"])
+%!assert (tolower ({["ABC"; "DEF"]}), {["abc";"def"]})
+%!assert (tolower (68), "d")
+%!assert (tolower ({[68, 68; 68, 68]}), {["dd";"dd"]})
 %!test
-%!  a(3,3,3,3) = "D";
-%!  assert(tolower(a)(3,3,3,3), "d");
+%! a(3,3,3,3) = "D";
+%! assert (tolower (a)(3,3,3,3), "d");
 
 %!test
 %! charset = char (0:127);
 %! result = charset;
-%! result(toascii ("A":"Z") + 1) = result(toascii ("a":"z") + 1);
-%! assert (all (tolower (charset) == result));
+%! result (toascii ("A":"Z") + 1) = result (toascii ("a":"z") + 1);
+%! assert (tolower (charset), result);
 
-%!error <Invalid call to tolower> tolower()
-%!error <Invalid call to tolower> lower()
+%!error <Invalid call to tolower> lower ()
+%!error <Invalid call to tolower> tolower ()
 %!error tolower (1, 2)
 */
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} toupper (@var{s})\n\
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
@@ -2028,24 +2026,24 @@ DEFALIAS (upper, toupper);
 %!assert (toupper ("octave"), "OCTAVE")
 %!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
 %!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
 %!assert (toupper (["abc"; "def"]), ["ABC"; "DEF"])
 %!assert (toupper ({["abc"; "def"]}), {["ABC";"DEF"]})
 %!assert (toupper (100), "D")
 %!assert (toupper ({[100, 100; 100, 100]}), {["DD";"DD"]})
 %!test
-%!  a(3,3,3,3) = "d";
-%!  assert(toupper (a)(3,3,3,3), "D");
+%! a(3,3,3,3) = "d";
+%! assert (toupper (a)(3,3,3,3), "D");
 %!test
 %! charset = char (0:127);
 %! result = charset;
-%! result(toascii  ("a":"z") + 1) = result(toascii  ("A":"Z") + 1);
-%! assert (all (toupper (charset) == result));
+%! result (toascii  ("a":"z") + 1) = result (toascii  ("A":"Z") + 1);
+%! assert (toupper (charset), result);
 
-%!error <Invalid call to toupper> toupper()
-%!error <Invalid call to toupper> upper()
+%!error <Invalid call to toupper> toupper ()
+%!error <Invalid call to toupper> upper ()
 %!error toupper (1, 2)
 */
 
 DEFALIAS (gammaln, lgamma);
 
 DEFALIAS (finite, isfinite);
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -443,20 +443,20 @@ octave_map::squeeze (void) const
     retval.xvals[i] = xvals[i].squeeze ();
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of xkeys by squeeze
+## test preservation of xkeys by squeeze
 %!test
-%!  x(1,1,1,1).d = 10; x(3,5,1,7).a = "b"; x(2,4,1,7).f = 27;
-%!  assert (fieldnames (squeeze (x)), {"d"; "a"; "f"});
+%! x(1,1,1,1).d = 10;  x(3,5,1,7).a = "b";  x(2,4,1,7).f = 27;
+%! assert (fieldnames (squeeze (x)), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::permute (const Array<int>& vec, bool inv) const
 {
   octave_map retval (xkeys);
   octave_idx_type nf = nfields ();
 
@@ -477,20 +477,20 @@ octave_map::permute (const Array<int>& v
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by permute
+## test preservation of key order by permute
 %!test
-%!  x(1,1,1,1).d = 10; x(3,5,1,7).a = "b"; x(2,4,1,7).f = 27;
-%!  assert (fieldnames (permute (x, [3, 4, 1, 2])), {"d"; "a"; "f"});
+%! x(1,1,1,1).d = 10;  x(3,5,1,7).a = "b";  x(2,4,1,7).f = 27;
+%! assert (fieldnames (permute (x, [3, 4, 1, 2])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_map retval (xkeys);
@@ -502,22 +502,22 @@ octave_map::transpose (void) const
     retval.xvals[i] = xvals[i].transpose ();
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by transpose
+## test preservation of key order by transpose
 %!test
-%!  x(1,1).d = 10; x(3,5).a = "b"; x(2,4).f = 27;
-%!  assert (fieldnames (transpose (x)), {"d"; "a"; "f"});
-%!  assert (fieldnames (x'), {"d"; "a"; "f"});
-%!  assert (fieldnames (x.'), {"d"; "a"; "f"});
+%! x(1,1).d = 10;  x(3,5).a = "b";  x(2,4).f = 27;
+%! assert (fieldnames (transpose (x)), {"d"; "a"; "f"});
+%! assert (fieldnames (x'), {"d"; "a"; "f"});
+%! assert (fieldnames (x.'), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::reshape (const dim_vector& dv) const
 {
   octave_map retval (xkeys);
   retval.dimensions = dv;
 
@@ -537,20 +537,20 @@ octave_map::reshape (const dim_vector& d
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by reshape
+## test preservation of key order by reshape
 %!test
-%!  x(1,1).d = 10; x(4,6).a = "b"; x(2,4).f = 27;
-%!  assert (fieldnames (reshape (x, 3, 8)), {"d"; "a"; "f"});
+%! x(1,1).d = 10;  x(4,6).a = "b";  x(2,4).f = 27;
+%! assert (fieldnames (reshape (x, 3, 8)), {"d"; "a"; "f"});
 */
 
 void
 octave_map::resize (const dim_vector& dv, bool fill)
 {
   octave_idx_type nf = nfields ();
   if (nf > 0)
     {
@@ -799,33 +799,33 @@ octave_map::cat (int dim, octave_idx_typ
 
       retval.optimize_dimensions ();
     }
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by concatenation
+## test preservation of key order by concatenation
 %!test
-%!  x(1, 1).d = 10; x(4, 6).a = "b"; x(2, 4).f = 27;
-%!  y(1, 6).f = 11; y(1, 6).a = "c"; y(1, 6).d = 33;
-%!  assert (fieldnames ([x; y]), {"d"; "a"; "f"});
+%! x(1, 1).d = 10;  x(4, 6).a = "b";  x(2, 4).f = 27;
+%! y(1, 6).f = 11;  y(1, 6).a = "c";  y(1, 6).d = 33;
+%! assert (fieldnames ([x; y]), {"d"; "a"; "f"});
 
 %!test
-%!  s = struct ();
-%!  sr = [s,s];
-%!  sc = [s;s];
-%!  sm = [s,s;s,s];
-%!  assert (nfields (sr), 0);
-%!  assert (nfields (sc), 0);
-%!  assert (nfields (sm), 0);
-%!  assert (size (sr), [1, 2]);
-%!  assert (size (sc), [2, 1]);
-%!  assert (size (sm), [2, 2]);
+%! s = struct ();
+%! sr = [s,s];
+%! sc = [s;s];
+%! sm = [s,s;s,s];
+%! assert (nfields (sr), 0);
+%! assert (nfields (sc), 0);
+%! assert (nfields (sm), 0);
+%! assert (size (sr), [1, 2]);
+%! assert (size (sc), [2, 1]);
+%! assert (size (sm), [2, 2]);
 */
 
 octave_map
 octave_map::index (const idx_vector& i, bool resize_ok) const
 {
   octave_map retval (xkeys);
   octave_idx_type nf = nfields ();
 
@@ -1245,20 +1245,20 @@ octave_map::delete_elements (const octav
         break;
     }
 
   if (! error_state)
     delete_elements (ia);
 }
 
 /*
-%!# test preservation of key order by indexing
+## test preservation of key order by indexing
 %!test
-%!  x(1, 1).d = 10; x(4, 6).a = "b"; x(2, 4).f = 27;
-%!  assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
+%! x(1, 1).d = 10;  x(4, 6).a = "b";  x(2, 4).f = 27;
+%! assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (nfields () == rb.nfields ())
     {
       for (const_iterator pa = begin (); pa != end (); pa++)
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -369,19 +369,19 @@ public:
   // pointer to a valid ostream, flush(), write(), and printf() will
   // automatically work for this stream.
 
   virtual std::ostream *output_stream (void) { return 0; }
 
   // If the derived class is locale-aware, it must implement this function 
   // in order to set a new locale. By default, this function avoids messing 
   // with locales and ignores its input argument.
-  virtual std::locale imbue ( const std::locale & loc ) 
+  virtual std::locale imbue ( const std::locale &)
     { return std::locale::classic (); }
-  
+
   // Return TRUE if this stream is open.
 
   bool is_open (void) const { return open_state; }
 
   virtual void do_close (void) { }
 
   void close (void)
     {
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -977,18 +977,18 @@ for an example of how to create an execu
     retval = Cell (octave_argv);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error argv (1);
-%!assert (iscellstr (argv ()));
+%!assert (iscellstr (argv ()))
+%!error argv (1)
 */
 
 DEFUN (program_invocation_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
@@ -1004,18 +1004,18 @@ how to create an executable Octave scrip
     retval = octave_program_invocation_name;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error program_invocation_name (1);
-%!assert (ischar (program_invocation_name ()));
+%!assert (ischar (program_invocation_name ()))
+%!error program_invocation_name (1)
 */
 
 DEFUN (program_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
@@ -1027,11 +1027,11 @@ Return the last component of the value r
     retval = octave_program_name;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error program_name (1);
-%!assert (ischar (program_name ()));
+%!assert (ischar (program_name ()))
+%!error program_name (1)
 */
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1553,19 +1553,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
-
 %!test
- s = speye(3);
- sparse_auto_mutate (false);
- s(:, 1) = 1;
- assert (typeinfo (s), "sparse matrix");
- sparse_auto_mutate (true);
- s(1, :) = 1;
- assert (typeinfo (s), "matrix");
-
+%! s = speye (3);
+%! sparse_auto_mutate (false);
+%! s(:, 1) = 1;
+%! assert (typeinfo (s), "sparse matrix");
+%! sparse_auto_mutate (true);
+%! s(1, :) = 1;
+%! assert (typeinfo (s), "matrix");
+%! sparse_auto_mutate (false);
 */
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -572,18 +572,17 @@ Convert @var{x} to logical type.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!shared m, s, c
+%!test
 %! m = eye (2) != 0;
 %! s = !0;
 %! c = {"double", "single", "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "logical"};
-%!test
 %! for i = 1:numel (c)
 %!   assert (logical (eye (2, c{i})), m)
 %!   assert (logical (eye (1, c{i})), s)
 %! endfor
 */
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1466,24 +1466,24 @@ c(2,1,:)(:)\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  keys = cellstr (char (floor (rand (11,10)*24+65)))';
-%!  vals = cellfun(@(x) mat2cell(rand (19,1), ones (19,1), 1), ...
-%!           mat2cell([1:11]', ones(11,1), 1), "uniformoutput", false)';
-%!  s = struct ([keys; vals]{:});
-%!  t = cell2struct ([vals{:}], keys, 2);
-%!  assert (s, t);
-%!  assert (struct2cell (s), [vals{:}]');
-%!  assert (fieldnames (s), keys');
+%! keys = cellstr (char (floor (rand (11,10)*24+65)))';
+%! vals = cellfun (@(x) mat2cell (rand (19,1), ones (19,1), 1), ...
+%!          mat2cell ([1:11]', ones (11,1), 1), "uniformoutput", false)';
+%! s = struct ([keys; vals]{:});
+%! t = cell2struct ([vals{:}], keys, 2);
+%! assert (s, t);
+%! assert (struct2cell (s), [vals{:}]');
+%! assert (fieldnames (s), keys');
 */
 
 mxArray *
 octave_cell::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (dims ());
 
   mxArray **elts = static_cast<mxArray **> (retval->get_data ());
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1283,50 +1283,48 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
   H5Gclose (group_hid);
 
   return success;
 }
 
 #endif
 
 /*
-
 %!test
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
 %! hm2 = hm;
 %! hdld2 = hdld;
 %! hbi2 = hbi;
 %! modes = {"-text", "-binary"};
-%! if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_HDF5")))
+%! if (!isempty (findstr (octave_config_info ("DEFS"), "HAVE_HDF5")))
 %!   modes(end+1) = "-hdf5";
 %! endif
 %! for i = 1:numel (modes)
 %!   mode = modes{i};
-%!   nm = tmpnam();
+%!   nm = tmpnam ();
 %!   unwind_protect
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!     clear f2 g2 hm2 hdld2 hbi2
 %!     load (nm);
-%!     assert (f(2),f2(2));
-%!     assert (g(2),g2(2));
-%!     assert (g(3),g2(3));
+%!     assert (f (2), f2 (2));
+%!     assert (g (2), g2 (2));
+%!     assert (g (3), g2 (3));
 %!     unlink (nm);
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!   unwind_protect_cleanup
 %!     unlink (nm);
 %!   end_unwind_protect
 %! endfor
-
 */
 
 void
 octave_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
@@ -1587,17 +1585,17 @@ make_fcn_handle (const std::string& nm, 
 %!      "/", "mrdivide";
 %!      "^", "mpower";
 %!      "\\", "mldivide";
 %!      "<", "lt";
 %!      ">", "gt";
 %!      "&", "and";
 %!      "|", "or"};
 %! for i = 1:rows (x)
-%!   assert (functions (str2func (x{i,1})).function, x{i,2})
+%!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
 DEFUN (functions, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} functions (@var{fcn_handle})\n\
 Return a struct containing information about the function handle\n\
 @var{fcn_handle}.\n\
@@ -1754,31 +1752,29 @@ are ignored in the lookup.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!function y = __testrecursionfunc (f, x, n)
 %!  if (nargin < 3)
 %!    n = 0;
 %!  endif
 %!  if (n > 2)
 %!    y = f (x);
 %!  else
 %!    n++;
-%!    y = __testrecursionfunc (@(x) f(2*x), x, n);
+%!    y = __testrecursionfunc (@(x) f (2*x), x, n);
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
-
 */
 
 DEFUN (is_function_handle, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class}\n\
 @end deftypefn")
@@ -1797,22 +1793,21 @@ Return true if @var{x} is a function han
 
 /*
 %!shared fh
 %! fh = @(x) x;
 
 %!assert (is_function_handle (fh))
 %!assert (! is_function_handle ({fh}))
 %!assert (! is_function_handle (1))
-%!error is_function_handle ();
-%!error is_function_handle (1, 2);
 
+%!error is_function_handle ()
+%!error is_function_handle (1, 2)
 */
 
-
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -820,19 +820,19 @@ If the second argument is an integer @va
   return retval;
 }
 
 /*
 %!shared fn
 %! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
-%% FIXME: Need tests for other 2 calling forms of inline()
+## FIXME: Need tests for other 2 calling forms of inline()
 
-%% Test input validation 
+## Test input validation 
 %!error inline ()
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
 %!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
@@ -862,17 +862,17 @@ Note that @code{char (@var{fun})} is equ
 
   return retval;
 }
 
 /*
 %!assert (formula (fn), "x.^2 + 1")
 %!assert (formula (fn), char (fn))
 
-%% Test input validation
+## Test input validation
 %!error formula ()
 %!error formula (1, 2)
 %!error <FUN must be an inline function> formula (1)
 */
 
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
@@ -909,17 +909,17 @@ the arguments of the inline function @va
   return retval;
 }
 
 /*
 %!assert (argnames (fn), {"x"})
 %!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
 %!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
 
-%% Test input validation
+## Test input validation
 %!error argnames ()
 %!error argnames (1, 2)
 %!error <FUN must be an inline function> argnames (1)
 */
 
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
@@ -1007,14 +1007,13 @@ quadv (fcn, 0, 3)\n\
 /*
 %!assert (char (vectorize (fn)), "x.^2 + 1")
 %!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
 %!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
 %!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
 %!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
 %!assert (vectorize ("2**x^5"), "2.**x.^5")
 
-%% Test input validation
+## Test input validation
 %!error vectorize ()
 %!error vectorize (1, 2)
 %!error <FUN must be a string or inline function> vectorize (1)
 */
-
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -836,17 +836,16 @@ Convert @var{x} to single precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-
 %!assert (class (single(1)), "single")
 %!assert (class (single(1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
 %!assert (class (single (uint8 (1))), "single")
 %!assert (class (single (int16 (1))), "single")
 %!assert (class (single (uint16 (1))), "single")
 %!assert (class (single (int32 (1))), "single")
 %!assert (class (single (uint32 (1))), "single")
@@ -860,11 +859,9 @@ Convert @var{x} to single precision type
 %! y = single (x);
 %! assert (class (x), "double");
 %! assert (class (y), "single");
 %!test
 %! x = diag ([i 3 2]);
 %! y = single (x);
 %! assert (class (x), "double");
 %! assert (class (y), "single");
-
 */
-
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -79,18 +79,15 @@ DEFUN (int16, args, ,
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
 
 /*
-
 %!assert (class (int16 (1)), "int16")
 %!assert (int16 (1.25), int16 (1))
 %!assert (int16 (1.5), int16 (2))
 %!assert (int16 (-1.5), int16 (-2))
 %!assert (int16 (2^17), int16 (2^16-1))
 %!assert (int16 (-2^17), int16 (-2^16))
-
 */
-
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -79,18 +79,15 @@ DEFUN (int32, args, ,
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
 
 /*
-
 %!assert (class (int32 (1)), "int32")
 %!assert (int32 (1.25), int32 (1))
 %!assert (int32 (1.5), int32 (2))
 %!assert (int32 (-1.5), int32 (-2))
 %!assert (int32 (2^33), int32 (2^32-1))
 %!assert (int32 (-2^33), int32 (-2^32))
-
 */
-
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -79,18 +79,15 @@ DEFUN (int64, args, ,
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
 
 /*
-
 %!assert (class (int64 (1)), "int64")
 %!assert (int64 (1.25), int64 (1))
 %!assert (int64 (1.5), int64 (2))
 %!assert (int64 (-1.5), int64 (-2))
 %!assert (int64 (2^65), int64 (2^64-1))
 %!assert (int64 (-2^65), int64 (-2^64))
-
 */
-
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -79,17 +79,15 @@ DEFUN (int8, args, ,
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
 
 /*
-
 %!assert (class (int8 (1)), "int8")
 %!assert (int8 (1.25), int8 (1))
 %!assert (int8 (1.5), int8 (2))
 %!assert (int8 (-1.5), int8 (-2))
 %!assert (int8 (2^9), int8 (2^8-1))
 %!assert (int8 (-2^9), int8 (-2^8))
-
 */
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -115,21 +115,19 @@ This should give an error if @code{I} is
     retval = args(0).is_null_value ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!assert (isnull ([]), true)
 %!assert (isnull ([1]), false)
 %!assert (isnull (zeros (0,3)), false)
 %!assert (isnull (""), true)
 %!assert (isnull ("A"), false)
 %!assert (isnull (''), true)
 %!assert (isnull ('A'), false)
 %!test
 %! x = [];
 %! assert (isnull (x), false);
-
 */
diff --git a/src/ov-oncleanup.cc b/src/ov-oncleanup.cc
--- a/src/ov-oncleanup.cc
+++ b/src/ov-oncleanup.cc
@@ -206,22 +206,20 @@ For similar functionality @xref{The @cod
     retval = octave_value (new octave_oncleanup (args(0)));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! old_wstate = warning ("query");
 %! unwind_protect
 %!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
 %!   warning ("off", "__MY_WARNING__");
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
-%!   clear trigger
+%!   clear trigger;
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
 %! unwind_protect_cleanup
 %!   warning (old_wstate);
 %! end_unwind_protect
-
 */
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -665,17 +665,17 @@ variable value is restored when exiting 
 
 /*
 %!test
 %! x = 0:10;
 %! save = allow_noninteger_range_as_index ();
 %! warn_state = warning ("query", "Octave:noninteger-range-as-index");
 %! unwind_protect
 %!   allow_noninteger_range_as_index (false);
-%!   fail ('x(2.1:5)');
+%!   fail ("x(2.1:5)");
 %!   assert (x(2:5), 1:4);
 %!   allow_noninteger_range_as_index (true);
 %!   warning ("off", "Octave:noninteger-range-as-index");
 %!   assert (x(2.49:5), 1:3);
 %!   assert (x(2.5:5), 2:4);
 %!   assert (x(2.51:5), 2:4);
 %! unwind_protect_cleanup
 %!   allow_noninteger_range_as_index (save);
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -976,17 +976,16 @@ Convert @var{x} to double precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-
 %!assert (class (double (single (1))), "double")
 %!assert (class (double (single (1 + i))), "double")
 %!assert (class (double (int8 (1))), "double")
 %!assert (class (double (uint8 (1))), "double")
 %!assert (class (double (int16 (1))), "double")
 %!assert (class (double (uint16 (1))), "double")
 %!assert (class (double (int32 (1))), "double")
 %!assert (class (double (uint32 (1))), "double")
@@ -1005,10 +1004,9 @@ Convert @var{x} to double precision type
 %! y = double (x);
 %! assert (class (x), "single");
 %! assert (class (y), "double");
 %!test
 %! x = diag (single ([i 3 2]));
 %! y = double (x);
 %! assert (class (x), "single");
 %! assert (class (y), "double");
-
 */
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -244,17 +244,18 @@ octave_struct::subsref (const std::strin
   if (idx.size () > 1)
     retval = retval.next_subsref (auto_add, type, idx, skip);
 
   return retval;
 }
 
 /*
 %!test
-%! x(1).a.a = 1; x(2).a.a = 2;
+%! x(1).a.a = 1;
+%! x(2).a.a = 2;
 %! assert (size (x), [1, 2]);
 %! assert (x(1).a.a, 1);
 %! assert (x(2).a.a, 2);
 */
 
 octave_value
 octave_struct::numeric_conv (const octave_value& val,
                              const std::string& type)
@@ -686,35 +687,16 @@ octave_struct::print_name_tag (std::ostr
 }
 
 static bool
 scalar (const dim_vector& dims)
 {
   return dims.length () == 2 && dims (0) == 1 && dims (1) == 1;
 }
 
-/*
-%!shared x
-%! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
-%!assert(struct('a',1,'b',3),x(1))
-%!assert(isempty(x([])))
-%!assert(isempty(struct('a',{},'b',{})))
-%!assert(struct('a',{1,2},'b',{3,3}),x)
-%!assert(struct('a',{1,2},'b',3),x)
-%!assert(struct('a',{1,2},'b',{3}),x)
-%!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x)
-%!test x=struct([]);
-%!assert(size(x),[0,0]);
-%!assert(isstruct(x));
-%!assert(isempty(fieldnames(x)));
-%!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
-*/
 
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
@@ -1184,17 +1166,18 @@ octave_scalar_struct::subsref (const std
   else
     retval = to_array ().subsref (type, idx, auto_add);
 
   return retval;
 }
 
 /*
 %!test
-%! x(1).a.a = 1; x(2).a.a = 2;
+%! x(1).a.a = 1;
+%! x(2).a.a = 2;
 %! assert (size (x), [1, 2]);
 %! assert (x(1).a.a, 1);
 %! assert (x(2).a.a, 2);
 */
 
 octave_value
 octave_scalar_struct::numeric_conv (const octave_value& val,
                                     const std::string& type)
@@ -1707,35 +1690,16 @@ octave_scalar_struct::fast_elem_insert_s
   if (btyp == btyp_struct)
     {
       *(reinterpret_cast<const octave_scalar_map **>(where)) = &map;
       return true;
     }
   else
     return false;
 }
-/*
-%!shared x
-%! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
-%!assert(struct('a',1,'b',3),x(1))
-%!assert(isempty(x([])))
-%!assert(isempty(struct('a',{},'b',{})))
-%!assert(struct('a',{1,2},'b',{3,3}),x)
-%!assert(struct('a',{1,2},'b',3),x)
-%!assert(struct('a',{1,2},'b',{3}),x)
-%!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x)
-%!test x=struct([]);
-%!assert(size(x),[0,0]);
-%!assert(isstruct(x));
-%!assert(isempty(fieldnames(x)));
-%!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
-*/
 
 DEFUN (struct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct (\"field\", @var{value}, \"field\", @var{value}, @dots{})\n\
 \n\
 Create a structure and initialize its value.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize\n\
@@ -1869,16 +1833,36 @@ If the argument is an object, return the
 
       if (error_state)
         return retval;
     }
 
   return octave_value (map);
 }
 
+/*
+%!shared x
+%! x(1).a=1;  x(2).a=2;  x(1).b=3;  x(2).b=3;
+%!assert (struct ("a",1, "b",3), x(1))
+%!assert (isempty (x([])))
+%!assert (isempty (struct ("a",{}, "b",{})))
+%!assert (struct ("a",{1,2}, "b",{3,3}), x)
+%!assert (struct ("a",{1,2}, "b",3), x)
+%!assert (struct ("a",{1,2}, "b",{3}), x)
+%!assert (struct ("b",3, "a",{1,2}), x)
+%!assert (struct ("b",{3}, "a",{1,2}), x)
+%!test x = struct ([]);
+%!assert (size (x), [0,0])
+%!assert (isstruct (x))
+%!assert (isempty (fieldnames (x)))
+%!fail ('struct ("a",{1,2},"b",{1,2,3})', 'dimensions of parameter 2 do not match those of parameter 4')
+%!fail ('struct (1,2,3,4)', 'struct: expecting alternating "field", VALUE pairs')
+%!fail ('struct ("1",2,"3")', 'struct: expecting alternating "field", VALUE pairs')
+*/
+
 DEFUN (isstruct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1923,20 +1907,20 @@ argument that is not a structure.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test preservation of fieldname order
+## test preservation of fieldname order
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3;
-%!  assert(fieldnames(x), {"d"; "a"; "b"; "c"});
+%! x(3).d=1;  x(2).a=2; x(1).b=3;  x(2).c=3;
+%! assert (fieldnames (x), {"d"; "a"; "b"; "c"});
 */
 
 DEFUN (isfield, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfield (@var{x}, @var{name})\n\
 Return true if the @var{x} is a structure and it\n\
 includes an element named @var{name}.  If @var{name} is a cell\n\
 array of strings then a logical array of equal dimension is returned.\n\
@@ -2007,25 +1991,25 @@ Return the number of fields of the struc
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test isfield
+## test isfield
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3;
-%!  assert (isfield (x, 'b'));
-%!assert (isfield (struct('a', '1'), 'a'));
-%!assert (isfield ({1}, 'c'), false);
-%!assert (isfield (struct('a', '1'), 10), false);
-%!assert (isfield (struct('a', 'b'), "a "), false);
-%!assert (isfield (struct('a', 1, 'b', 2), {'a', 'c'}), [true, false]);
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
+%! assert (isfield (x, "b"));
+%!assert (isfield (struct("a", "1"), "a"))
+%!assert (isfield ({1}, "c"), false)
+%!assert (isfield (struct("a", "1"), 10), false)
+%!assert (isfield (struct("a", "b"), "a "), false)
+%!assert (isfield (struct("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
@@ -2133,25 +2117,25 @@ A(1)\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test cell2struct versus struct2cell
+## test cell2struct versus struct2cell
 %!test
-%!  keys = cellstr (char (floor (rand (100,10)*24+65)))';
-%!  vals = mat2cell(rand (100,1), ones (100,1), 1)';
-%!  s = struct ([keys; vals]{:});
-%!  t = cell2struct (vals, keys, 2);
-%!  assert (s, t);
-%!  assert (struct2cell (s), vals');
-%!  assert (fieldnames (s), keys');
+%! keys = cellstr (char (floor (rand (100,10)*24+65)))';
+%! vals = mat2cell (rand (100,1), ones (100,1), 1)';
+%! s = struct ([keys; vals]{:});
+%! t = cell2struct (vals, keys, 2);
+%! assert (s, t);
+%! assert (struct2cell (s), vals');
+%! assert (fieldnames (s), keys');
 
 %!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
 */
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
@@ -2199,22 +2183,22 @@ the named fields.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test rmfield
+## test rmfield
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3; x(6).f="abc123";
-%!  y = rmfield (x, {"a", "f"});
-%!  assert (fieldnames (y), {"d"; "b"; "c"});
-%!  assert (size (y), [1, 6]);
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
+%! y = rmfield (x, {"a", "f"});
+%! assert (fieldnames (y), {"d"; "b"; "c"});
+%! assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -615,77 +615,93 @@ currently installed data types.\n\
     retval = args(0).type_name ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error typeinfo ("foo", 1);
+%!assert (iscellstr (typeinfo ()))
 
-%!assert (iscellstr (typeinfo ()));
+%!assert (typeinfo ({"cell"}), "cell")
 
-%!assert (typeinfo (false), "bool");
-%!assert (typeinfo ([true, false]), "bool matrix");
-
-%!assert (typeinfo (1:2), "range");
+%!assert (typeinfo (1), "scalar")
+%!assert (typeinfo (double (1)), "scalar")
+%!assert (typeinfo (i), "complex scalar")
 
-%!assert (typeinfo ("string"), "string");
-%!assert (typeinfo ('string'), "sq_string");
-
+%!assert (typeinfo ([1, 2]), "matrix")
+%!assert (typeinfo (double ([1, 2])), "matrix")
 %!assert (typeinfo (diag ([1, 2])), "diagonal matrix")
+%!assert (typeinfo ([i, 2]), "complex matrix")
 %!assert (typeinfo (diag ([i, 2])), "complex diagonal matrix")
-%!assert (typeinfo (single (diag ([1, 2]))), "float diagonal matrix")
-%!assert (typeinfo (single (diag ([i, 2]))), "float complex diagonal matrix")
-%!assert (typeinfo (diag (single ([1, 2]))), "float diagonal matrix")
-%!assert (typeinfo (diag (single ([i, 2]))), "float complex diagonal matrix")
+
+%!assert (typeinfo (1:2), "range")
 
-%!assert (typeinfo ([]), "null_matrix");
-%!assert (typeinfo (""), "null_string");
-%!assert (typeinfo (''), "null_sq_string");
+%!assert (typeinfo (false), "bool")
+%!assert (typeinfo ([true, false]), "bool matrix")
+
+%!assert (typeinfo ("string"), "string")
+%!assert (typeinfo ('string'), "sq_string")
 
-%!assert (typeinfo (1), "scalar");
-%!assert (typeinfo (double (1)), "scalar");
-%!assert (typeinfo ([1, 2]), "matrix");
-%!assert (typeinfo (double ([1, 2])), "matrix");
-
-%!assert (typeinfo (i), "complex scalar");
-%!assert (typeinfo ([i, 2]), "complex matrix");
-
-%!assert (typeinfo (single (1)), "float scalar");
-%!assert (typeinfo (single ([1, 2])), "float matrix");
+%!assert (typeinfo (int8 (1)), "int8 scalar")
+%!assert (typeinfo (int16 (1)), "int16 scalar")
+%!assert (typeinfo (int32 (1)), "int32 scalar")
+%!assert (typeinfo (int64 (1)), "int64 scalar")
+%!assert (typeinfo (uint8 (1)), "uint8 scalar")
+%!assert (typeinfo (uint16 (1)), "uint16 scalar")
+%!assert (typeinfo (uint32 (1)), "uint32 scalar")
+%!assert (typeinfo (uint64 (1)), "uint64 scalar")
 
-%!assert (typeinfo (single (i)), "float complex scalar");
-%!assert (typeinfo (single ([i, 2])), "float complex matrix");
-
-%!assert (typeinfo (sparse (eye (10))), "sparse matrix");
-%!assert (typeinfo (sparse (i * eye (10))), "sparse complex matrix");
-%!assert (typeinfo (logical (sparse (i * eye (10)))), "sparse bool matrix");
+%!assert (typeinfo (int8 ([1,2])), "int8 matrix")
+%!assert (typeinfo (int16 ([1,2])), "int16 matrix")
+%!assert (typeinfo (int32 ([1,2])), "int32 matrix")
+%!assert (typeinfo (int64 ([1,2])), "int64 matrix")
+%!assert (typeinfo (uint8 ([1,2])), "uint8 matrix")
+%!assert (typeinfo (uint16 ([1,2])), "uint16 matrix")
+%!assert (typeinfo (uint32 ([1,2])), "uint32 matrix")
+%!assert (typeinfo (uint64 ([1,2])), "uint64 matrix")
 
-%!assert (typeinfo (int8 (1)), "int8 scalar");
-%!assert (typeinfo (int16 (1)), "int16 scalar");
-%!assert (typeinfo (int32 (1)), "int32 scalar");
-%!assert (typeinfo (int64 (1)), "int64 scalar");
-%!assert (typeinfo (uint8 (1)), "uint8 scalar");
-%!assert (typeinfo (uint16 (1)), "uint16 scalar");
-%!assert (typeinfo (uint32 (1)), "uint32 scalar");
-%!assert (typeinfo (uint64 (1)), "uint64 scalar");
+%!assert (typeinfo (sparse ([true, false])), "sparse bool matrix")
+%!assert (typeinfo (logical (sparse (i * eye (10)))), "sparse bool matrix")
+%!assert (typeinfo (sparse ([1,2])), "sparse matrix")
+%!assert (typeinfo (sparse (eye (10))), "sparse matrix")
+%!assert (typeinfo (sparse ([i,2])), "sparse complex matrix")
+%!assert (typeinfo (sparse (i * eye (10))), "sparse complex matrix")
+
+%!test
+%! s(2).a = 1;
+%! assert (typeinfo (s), "struct");
 
 %!test
 %! s.a = 1;
 %! assert (typeinfo (s), "scalar struct");
 
-%!test
-%! s(2).a = 1;
-%! assert (typeinfo (s), "struct");
+## FIXME: This doesn't work as a test for comma-separated list
+%!#test
+%! clist = {1, 2, 3};
+%! assert (typeinfo (clist{:}), "cs-list");
 
-%!assert (typeinfo ({"cell"}), "cell");
+%!assert (typeinfo (@sin), "function handle")
+%!assert (typeinfo (@(x) x), "function handle")
+
+%!assert (typeinfo (inline ("x^2")), "inline function")
 
-%!assert (typeinfo (@sin), "function handle");
-%!assert (typeinfo (@(x) x), "function handle");
+%!assert (typeinfo (single (1)), "float scalar")
+%!assert (typeinfo (single (i)), "float complex scalar")
+%!assert (typeinfo (single ([1, 2])), "float matrix")
 
-%!assert (typeinfo (inline ('x^2')), "inline function");
+%!assert (typeinfo (single (diag ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (diag (single ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (single (diag ([i, 2]))), "float complex diagonal matrix")
+%!assert (typeinfo (diag (single ([i, 2]))), "float complex diagonal matrix")
 
+%!assert (typeinfo (eye(3)(:,[1 3 2])), "permutation matrix")
 %!test
 %! [l, u, p] = lu (rand (3));
 %! assert (typeinfo (p), "permutation matrix");
+
+%!assert (typeinfo ([]), "null_matrix")
+%!assert (typeinfo (""), "null_string")
+%!assert (typeinfo (''), "null_sq_string")
+
+%!error typeinfo ("foo", 1)
 */
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -79,18 +79,15 @@ DEFUN (uint16, args, ,
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
 
 /*
-
 %!assert (class (uint16 (1)), "uint16")
 %!assert (uint16 (1.25), uint16 (1))
 %!assert (uint16 (1.5), uint16 (2))
 %!assert (uint16 (-1.5), uint16 (0))
 %!assert (uint16 (2^17), uint16 (2^16-1))
 %!assert (uint16 (-2^17), uint16 (0))
-
 */
-
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -79,17 +79,15 @@ DEFUN (uint32, args, ,
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
 
 /*
-
 %!assert (class (uint32 (1)), "uint32")
 %!assert (uint32 (1.25), uint32 (1))
 %!assert (uint32 (1.5), uint32 (2))
 %!assert (uint32 (-1.5), uint32 (0))
 %!assert (uint32 (2^33), uint32 (2^32-1))
 %!assert (uint32 (-2^33), uint32 (0))
-
 */
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -79,17 +79,15 @@ DEFUN (uint64, args, ,
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
 
 /*
-
 %!assert (class (uint64 (1)), "uint64")
 %!assert (uint64 (1.25), uint64 (1))
 %!assert (uint64 (1.5), uint64 (2))
 %!assert (uint64 (-1.5), uint64 (0))
 %!assert (uint64 (2^65), uint64 (2^64-1))
 %!assert (uint64 (-2^65), uint64 (0))
-
 */
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -79,17 +79,15 @@ DEFUN (uint8, args, ,
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
 
 /*
-
 %!assert (class (uint8 (1)), "uint8")
 %!assert (uint8 (1.25), uint8 (1))
 %!assert (uint8 (1.5), uint8 (2))
 %!assert (uint8 (-1.5), uint8 (0))
 %!assert (uint8 (2^9), uint8 (2^8-1))
 %!assert (uint8 (-2^9), uint8 (0))
-
 */
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2939,17 +2939,17 @@ and @samp{subs}, return @var{rhs}.\n\
 %! a = subsasgn (a, idx2, 0);
 %! a = subsasgn (a, idx3, 0);
 %!# a = subsasgn (a, idx4, 0);
 %! b = [0    6   11   16    0
 %!      0    0   12    0    0
 %!      0    8    0   18    0
 %!      0    0   14    0    0
 %!      0   10   15   20    0];
-%! assert (a,b);
+%! assert (a, b);
 
 %!test
 %! c = num2cell (reshape ([1:25],5,5));
 %! idx1 = substruct  ("{}", {3, 3});
 %! idx2 = substruct  ("()", {2:2:5, 2:2:5});
 %! idx3 = substruct  ("()", {":", [1,5]});
 %! idx2p = substruct ("{}", {2:2:5, 2:2:5});
 %! idx3p = substruct ("{}", {":", [1,5]});
@@ -2984,17 +2984,16 @@ and @samp{subs}, return @var{rhs}.\n\
 %! s = subsasgn (s, idx1, "Hello");
 %! s = subsasgn (s, idx2, "There");
 %! s = subsasgn (s, idx3, 163);
 %!# s = subsasgn (s, idx4, 163);
 %! t.a = "Hello";
 %! t.b = "There";
 %! t.c = 163;
 %! assert (s, t);
-
 */
 
 DEFUN (is_sq_string, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
@@ -3005,20 +3004,21 @@ Return true if @var{x} is a single-quote
     retval = args(0).is_sq_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (is_sq_string ('foo'), true);
-%!assert (is_sq_string ("foo"), false);
-%!assert (is_sq_string (1.0), false);
-%!assert (is_sq_string ({2.0}), false);
+%!assert (is_sq_string ('foo'), true)
+%!assert (is_sq_string ("foo"), false)
+%!assert (is_sq_string (1.0), false)
+%!assert (is_sq_string ({2.0}), false)
+
 %!error is_sq_string ()
 %!error is_sq_string ('foo', 2)
 */
 
 DEFUN (is_dq_string, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
@@ -3031,15 +3031,16 @@ Return true if @var{x} is a double-quote
     retval = args(0).is_dq_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (is_dq_string ("foo"), true);
-%!assert (is_dq_string ('foo'), false);
-%!assert (is_dq_string (1.0), false);
-%!assert (is_dq_string ({2.0}), false);
+%!assert (is_dq_string ("foo"), true)
+%!assert (is_dq_string ('foo'), false)
+%!assert (is_dq_string (1.0), false)
+%!assert (is_dq_string ({2.0}), false)
+
 %!error is_dq_string ()
 %!error is_dq_string ("foo", 2)
 */
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -310,17 +310,17 @@ public:
     if (--rep->count == 0)
       delete rep;
   }
 
   void make_unique (void)
     {
       if (rep->count > 1)
         {
-	  octave_base_value *r = rep->unique_clone ();
+          octave_base_value *r = rep->unique_clone ();
 
           if (--rep->count == 0)
             delete rep;
 
           rep = r;
         }
     }
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3550,22 +3550,22 @@ Note that the output from @code{fdisp} a
 
 %!test
 %! foo.real = pi * ones (3,20,3);
 %! foo.complex = pi * ones (3,20,3) + 1i;
 %! foo.char = repmat ("- Hello World -", [3, 20]);
 %! foo.cell = {foo.real, foo.complex, foo.char};
 %! fields = fieldnames (foo);
 %! for f = 1:numel(fields)
-%!   format loose
+%!   format loose;
 %!   loose = disp (foo.(fields{f}));
-%!   format compact
+%!   format compact;
 %!   compact = disp (foo.(fields{f}));
 %!   expected = strrep (loose, "\n\n", "\n");
-%!   assert (expected, compact)
+%!   assert (expected, compact);
 %! endfor
 */
 
 static void
 init_format_state (void)
 {
   free_format = false;
   plus_format = false;
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -297,22 +297,19 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
 
 /*
-
 %!test
 %! x = 0;
 %! do_braindead_shortcircuit_evaluation (0);
 %! if (1 | (x = 1))
 %! endif
 %! assert (x, 1);
 %! do_braindead_shortcircuit_evaluation (1);
 %! if (1 | (x = 0))
 %! endif
 %! assert (x, 1);
-
 */
-
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1202,24 +1202,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 /*
-%!error (max_recursion_depth (1, 2));
 %!test
 %! orig_val = max_recursion_depth ();
 %! old_val = max_recursion_depth (2*orig_val);
 %! assert (orig_val, old_val);
 %! assert (max_recursion_depth (), 2*orig_val);
 %! max_recursion_depth (orig_val);
 %! assert (max_recursion_depth (), orig_val);
+
+%!error (max_recursion_depth (1, 2))
 */
 
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
@@ -1231,17 +1232,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
 
 /*
-%!error (silent_functions (1, 2));
 %!test
 %! orig_val = silent_functions ();
 %! old_val = silent_functions (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (silent_functions (), ! orig_val);
 %! silent_functions (orig_val);
 %! assert (silent_functions (), orig_val);
+
+%!error (silent_functions (1, 2))
 */
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -596,23 +596,23 @@ tree_index_expression::lvalue (void)
 
     }
 
   return retval;
 }
 
 /*
 %!test
-%! clear x
-%! clear y
+%! clear x;
+%! clear y;
 %! y = 3;
 %! x(y(end)) = 1;
 %! assert (x, [0, 0, 1]);
-%! clear x
-%! clear y
+%! clear x;
+%! clear y;
 %! y = {3};
 %! x(y{end}) = 1;
 %! assert (x, [0, 0, 1]);
 
 %!test
 %! x = {1, 2, 3};
 %! [x{:}] = deal (4, 5, 6);
 %! assert (x, {4, 5, 6});
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1188,243 +1188,244 @@ tree_matrix::dup (symbol_table::scope_id
 
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 /*
-%% test concatenation with all zero matrices
-%!assert([ '' 65*ones(1,10) ], 'AAAAAAAAAA');
-%!assert([ 65*ones(1,10) '' ], 'AAAAAAAAAA');
+## test concatenation with all zero matrices
+%!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA");
+%!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA");
 
 %!test
-%! c = {'foo'; 'bar'; 'bazoloa'};
-%! assert ([c; 'a'; 'bc'; 'def'], {'foo'; 'bar'; 'bazoloa'; 'a'; 'bc'; 'def'});
+%! c = {"foo"; "bar"; "bazoloa"};
+%! assert ([c; "a"; "bc"; "def"], {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 
-%!assert (class ([int64(1), int64(1)]), 'int64')
-%!assert (class ([int64(1), int32(1)]), 'int64')
-%!assert (class ([int64(1), int16(1)]), 'int64')
-%!assert (class ([int64(1), int8(1)]), 'int64')
-%!assert (class ([int64(1), uint64(1)]), 'int64')
-%!assert (class ([int64(1), uint32(1)]), 'int64')
-%!assert (class ([int64(1), uint16(1)]), 'int64')
-%!assert (class ([int64(1), uint8(1)]), 'int64')
-%!assert (class ([int64(1), single(1)]), 'int64')
-%!assert (class ([int64(1), double(1)]), 'int64')
-%!assert (class ([int64(1), cell(1)]), 'cell')
-%!assert (class ([int64(1), true]), 'int64')
-%!assert (class ([int64(1), 'a']), 'char')
+%!assert (class ([int64(1), int64(1)]), "int64")
+%!assert (class ([int64(1), int32(1)]), "int64")
+%!assert (class ([int64(1), int16(1)]), "int64")
+%!assert (class ([int64(1), int8(1)]), "int64")
+%!assert (class ([int64(1), uint64(1)]), "int64")
+%!assert (class ([int64(1), uint32(1)]), "int64")
+%!assert (class ([int64(1), uint16(1)]), "int64")
+%!assert (class ([int64(1), uint8(1)]), "int64")
+%!assert (class ([int64(1), single(1)]), "int64")
+%!assert (class ([int64(1), double(1)]), "int64")
+%!assert (class ([int64(1), cell(1)]), "cell")
+%!assert (class ([int64(1), true]), "int64")
+%!assert (class ([int64(1), "a"]), "char")
 
-%!assert (class ([int32(1), int64(1)]), 'int32')
-%!assert (class ([int32(1), int32(1)]), 'int32')
-%!assert (class ([int32(1), int16(1)]), 'int32')
-%!assert (class ([int32(1), int8(1)]), 'int32')
-%!assert (class ([int32(1), uint64(1)]), 'int32')
-%!assert (class ([int32(1), uint32(1)]), 'int32')
-%!assert (class ([int32(1), uint16(1)]), 'int32')
-%!assert (class ([int32(1), uint8(1)]), 'int32')
-%!assert (class ([int32(1), single(1)]), 'int32')
-%!assert (class ([int32(1), double(1)]), 'int32')
-%!assert (class ([int32(1), cell(1)]), 'cell')
-%!assert (class ([int32(1), true]), 'int32')
-%!assert (class ([int32(1), 'a']), 'char')
+%!assert (class ([int32(1), int64(1)]), "int32")
+%!assert (class ([int32(1), int32(1)]), "int32")
+%!assert (class ([int32(1), int16(1)]), "int32")
+%!assert (class ([int32(1), int8(1)]), "int32")
+%!assert (class ([int32(1), uint64(1)]), "int32")
+%!assert (class ([int32(1), uint32(1)]), "int32")
+%!assert (class ([int32(1), uint16(1)]), "int32")
+%!assert (class ([int32(1), uint8(1)]), "int32")
+%!assert (class ([int32(1), single(1)]), "int32")
+%!assert (class ([int32(1), double(1)]), "int32")
+%!assert (class ([int32(1), cell(1)]), "cell")
+%!assert (class ([int32(1), true]), "int32")
+%!assert (class ([int32(1), "a"]), "char")
 
-%!assert (class ([int16(1), int64(1)]), 'int16')
-%!assert (class ([int16(1), int32(1)]), 'int16')
-%!assert (class ([int16(1), int16(1)]), 'int16')
-%!assert (class ([int16(1), int8(1)]), 'int16')
-%!assert (class ([int16(1), uint64(1)]), 'int16')
-%!assert (class ([int16(1), uint32(1)]), 'int16')
-%!assert (class ([int16(1), uint16(1)]), 'int16')
-%!assert (class ([int16(1), uint8(1)]), 'int16')
-%!assert (class ([int16(1), single(1)]), 'int16')
-%!assert (class ([int16(1), double(1)]), 'int16')
-%!assert (class ([int16(1), cell(1)]), 'cell')
-%!assert (class ([int16(1), true]), 'int16')
-%!assert (class ([int16(1), 'a']), 'char')
+%!assert (class ([int16(1), int64(1)]), "int16")
+%!assert (class ([int16(1), int32(1)]), "int16")
+%!assert (class ([int16(1), int16(1)]), "int16")
+%!assert (class ([int16(1), int8(1)]), "int16")
+%!assert (class ([int16(1), uint64(1)]), "int16")
+%!assert (class ([int16(1), uint32(1)]), "int16")
+%!assert (class ([int16(1), uint16(1)]), "int16")
+%!assert (class ([int16(1), uint8(1)]), "int16")
+%!assert (class ([int16(1), single(1)]), "int16")
+%!assert (class ([int16(1), double(1)]), "int16")
+%!assert (class ([int16(1), cell(1)]), "cell")
+%!assert (class ([int16(1), true]), "int16")
+%!assert (class ([int16(1), "a"]), "char")
 
-%!assert (class ([int8(1), int64(1)]), 'int8')
-%!assert (class ([int8(1), int32(1)]), 'int8')
-%!assert (class ([int8(1), int16(1)]), 'int8')
-%!assert (class ([int8(1), int8(1)]), 'int8')
-%!assert (class ([int8(1), uint64(1)]), 'int8')
-%!assert (class ([int8(1), uint32(1)]), 'int8')
-%!assert (class ([int8(1), uint16(1)]), 'int8')
-%!assert (class ([int8(1), uint8(1)]), 'int8')
-%!assert (class ([int8(1), single(1)]), 'int8')
-%!assert (class ([int8(1), double(1)]), 'int8')
-%!assert (class ([int8(1), cell(1)]), 'cell')
-%!assert (class ([int8(1), true]), 'int8')
-%!assert (class ([int8(1), 'a']), 'char')
+%!assert (class ([int8(1), int64(1)]), "int8")
+%!assert (class ([int8(1), int32(1)]), "int8")
+%!assert (class ([int8(1), int16(1)]), "int8")
+%!assert (class ([int8(1), int8(1)]), "int8")
+%!assert (class ([int8(1), uint64(1)]), "int8")
+%!assert (class ([int8(1), uint32(1)]), "int8")
+%!assert (class ([int8(1), uint16(1)]), "int8")
+%!assert (class ([int8(1), uint8(1)]), "int8")
+%!assert (class ([int8(1), single(1)]), "int8")
+%!assert (class ([int8(1), double(1)]), "int8")
+%!assert (class ([int8(1), cell(1)]), "cell")
+%!assert (class ([int8(1), true]), "int8")
+%!assert (class ([int8(1), "a"]), "char")
 
-%!assert (class ([uint64(1), int64(1)]), 'uint64')
-%!assert (class ([uint64(1), int32(1)]), 'uint64')
-%!assert (class ([uint64(1), int16(1)]), 'uint64')
-%!assert (class ([uint64(1), int8(1)]), 'uint64')
-%!assert (class ([uint64(1), uint64(1)]), 'uint64')
-%!assert (class ([uint64(1), uint32(1)]), 'uint64')
-%!assert (class ([uint64(1), uint16(1)]), 'uint64')
-%!assert (class ([uint64(1), uint8(1)]), 'uint64')
-%!assert (class ([uint64(1), single(1)]), 'uint64')
-%!assert (class ([uint64(1), double(1)]), 'uint64')
-%!assert (class ([uint64(1), cell(1)]), 'cell')
-%!assert (class ([uint64(1), true]), 'uint64')
-%!assert (class ([uint64(1), 'a']), 'char')
+%!assert (class ([uint64(1), int64(1)]), "uint64")
+%!assert (class ([uint64(1), int32(1)]), "uint64")
+%!assert (class ([uint64(1), int16(1)]), "uint64")
+%!assert (class ([uint64(1), int8(1)]), "uint64")
+%!assert (class ([uint64(1), uint64(1)]), "uint64")
+%!assert (class ([uint64(1), uint32(1)]), "uint64")
+%!assert (class ([uint64(1), uint16(1)]), "uint64")
+%!assert (class ([uint64(1), uint8(1)]), "uint64")
+%!assert (class ([uint64(1), single(1)]), "uint64")
+%!assert (class ([uint64(1), double(1)]), "uint64")
+%!assert (class ([uint64(1), cell(1)]), "cell")
+%!assert (class ([uint64(1), true]), "uint64")
+%!assert (class ([uint64(1), "a"]), "char")
 
-%!assert (class ([uint32(1), int64(1)]), 'uint32')
-%!assert (class ([uint32(1), int32(1)]), 'uint32')
-%!assert (class ([uint32(1), int16(1)]), 'uint32')
-%!assert (class ([uint32(1), int8(1)]), 'uint32')
-%!assert (class ([uint32(1), uint64(1)]), 'uint32')
-%!assert (class ([uint32(1), uint32(1)]), 'uint32')
-%!assert (class ([uint32(1), uint16(1)]), 'uint32')
-%!assert (class ([uint32(1), uint8(1)]), 'uint32')
-%!assert (class ([uint32(1), single(1)]), 'uint32')
-%!assert (class ([uint32(1), double(1)]), 'uint32')
-%!assert (class ([uint32(1), cell(1)]), 'cell')
-%!assert (class ([uint32(1), true]), 'uint32')
-%!assert (class ([uint32(1), 'a']), 'char')
+%!assert (class ([uint32(1), int64(1)]), "uint32")
+%!assert (class ([uint32(1), int32(1)]), "uint32")
+%!assert (class ([uint32(1), int16(1)]), "uint32")
+%!assert (class ([uint32(1), int8(1)]), "uint32")
+%!assert (class ([uint32(1), uint64(1)]), "uint32")
+%!assert (class ([uint32(1), uint32(1)]), "uint32")
+%!assert (class ([uint32(1), uint16(1)]), "uint32")
+%!assert (class ([uint32(1), uint8(1)]), "uint32")
+%!assert (class ([uint32(1), single(1)]), "uint32")
+%!assert (class ([uint32(1), double(1)]), "uint32")
+%!assert (class ([uint32(1), cell(1)]), "cell")
+%!assert (class ([uint32(1), true]), "uint32")
+%!assert (class ([uint32(1), "a"]), "char")
 
-%!assert (class ([uint16(1), int64(1)]), 'uint16')
-%!assert (class ([uint16(1), int32(1)]), 'uint16')
-%!assert (class ([uint16(1), int16(1)]), 'uint16')
-%!assert (class ([uint16(1), int8(1)]), 'uint16')
-%!assert (class ([uint16(1), uint64(1)]), 'uint16')
-%!assert (class ([uint16(1), uint32(1)]), 'uint16')
-%!assert (class ([uint16(1), uint16(1)]), 'uint16')
-%!assert (class ([uint16(1), uint8(1)]), 'uint16')
-%!assert (class ([uint16(1), single(1)]), 'uint16')
-%!assert (class ([uint16(1), double(1)]), 'uint16')
-%!assert (class ([uint16(1), cell(1)]), 'cell')
-%!assert (class ([uint16(1), true]), 'uint16')
-%!assert (class ([uint16(1), 'a']), 'char')
+%!assert (class ([uint16(1), int64(1)]), "uint16")
+%!assert (class ([uint16(1), int32(1)]), "uint16")
+%!assert (class ([uint16(1), int16(1)]), "uint16")
+%!assert (class ([uint16(1), int8(1)]), "uint16")
+%!assert (class ([uint16(1), uint64(1)]), "uint16")
+%!assert (class ([uint16(1), uint32(1)]), "uint16")
+%!assert (class ([uint16(1), uint16(1)]), "uint16")
+%!assert (class ([uint16(1), uint8(1)]), "uint16")
+%!assert (class ([uint16(1), single(1)]), "uint16")
+%!assert (class ([uint16(1), double(1)]), "uint16")
+%!assert (class ([uint16(1), cell(1)]), "cell")
+%!assert (class ([uint16(1), true]), "uint16")
+%!assert (class ([uint16(1), "a"]), "char")
 
-%!assert (class ([uint8(1), int64(1)]), 'uint8')
-%!assert (class ([uint8(1), int32(1)]), 'uint8')
-%!assert (class ([uint8(1), int16(1)]), 'uint8')
-%!assert (class ([uint8(1), int8(1)]), 'uint8')
-%!assert (class ([uint8(1), uint64(1)]), 'uint8')
-%!assert (class ([uint8(1), uint32(1)]), 'uint8')
-%!assert (class ([uint8(1), uint16(1)]), 'uint8')
-%!assert (class ([uint8(1), uint8(1)]), 'uint8')
-%!assert (class ([uint8(1), single(1)]), 'uint8')
-%!assert (class ([uint8(1), double(1)]), 'uint8')
-%!assert (class ([uint8(1), cell(1)]), 'cell')
-%!assert (class ([uint8(1), true]), 'uint8')
-%!assert (class ([uint8(1), 'a']), 'char')
+%!assert (class ([uint8(1), int64(1)]), "uint8")
+%!assert (class ([uint8(1), int32(1)]), "uint8")
+%!assert (class ([uint8(1), int16(1)]), "uint8")
+%!assert (class ([uint8(1), int8(1)]), "uint8")
+%!assert (class ([uint8(1), uint64(1)]), "uint8")
+%!assert (class ([uint8(1), uint32(1)]), "uint8")
+%!assert (class ([uint8(1), uint16(1)]), "uint8")
+%!assert (class ([uint8(1), uint8(1)]), "uint8")
+%!assert (class ([uint8(1), single(1)]), "uint8")
+%!assert (class ([uint8(1), double(1)]), "uint8")
+%!assert (class ([uint8(1), cell(1)]), "cell")
+%!assert (class ([uint8(1), true]), "uint8")
+%!assert (class ([uint8(1), "a"]), "char")
 
-%!assert (class ([single(1), int64(1)]), 'int64')
-%!assert (class ([single(1), int32(1)]), 'int32')
-%!assert (class ([single(1), int16(1)]), 'int16')
-%!assert (class ([single(1), int8(1)]), 'int8')
-%!assert (class ([single(1), uint64(1)]), 'uint64')
-%!assert (class ([single(1), uint32(1)]), 'uint32')
-%!assert (class ([single(1), uint16(1)]), 'uint16')
-%!assert (class ([single(1), uint8(1)]), 'uint8')
-%!assert (class ([single(1), single(1)]), 'single')
-%!assert (class ([single(1), double(1)]), 'single')
-%!assert (class ([single(1), cell(1)]), 'cell')
-%!assert (class ([single(1), true]), 'single')
-%!assert (class ([single(1), 'a']), 'char')
+%!assert (class ([single(1), int64(1)]), "int64")
+%!assert (class ([single(1), int32(1)]), "int32")
+%!assert (class ([single(1), int16(1)]), "int16")
+%!assert (class ([single(1), int8(1)]), "int8")
+%!assert (class ([single(1), uint64(1)]), "uint64")
+%!assert (class ([single(1), uint32(1)]), "uint32")
+%!assert (class ([single(1), uint16(1)]), "uint16")
+%!assert (class ([single(1), uint8(1)]), "uint8")
+%!assert (class ([single(1), single(1)]), "single")
+%!assert (class ([single(1), double(1)]), "single")
+%!assert (class ([single(1), cell(1)]), "cell")
+%!assert (class ([single(1), true]), "single")
+%!assert (class ([single(1), "a"]), "char")
 
-%!assert (class ([double(1), int64(1)]), 'int64')
-%!assert (class ([double(1), int32(1)]), 'int32')
-%!assert (class ([double(1), int16(1)]), 'int16')
-%!assert (class ([double(1), int8(1)]), 'int8')
-%!assert (class ([double(1), uint64(1)]), 'uint64')
-%!assert (class ([double(1), uint32(1)]), 'uint32')
-%!assert (class ([double(1), uint16(1)]), 'uint16')
-%!assert (class ([double(1), uint8(1)]), 'uint8')
-%!assert (class ([double(1), single(1)]), 'single')
-%!assert (class ([double(1), double(1)]), 'double')
-%!assert (class ([double(1), cell(1)]), 'cell')
-%!assert (class ([double(1), true]), 'double')
-%!assert (class ([double(1), 'a']), 'char')
+%!assert (class ([double(1), int64(1)]), "int64")
+%!assert (class ([double(1), int32(1)]), "int32")
+%!assert (class ([double(1), int16(1)]), "int16")
+%!assert (class ([double(1), int8(1)]), "int8")
+%!assert (class ([double(1), uint64(1)]), "uint64")
+%!assert (class ([double(1), uint32(1)]), "uint32")
+%!assert (class ([double(1), uint16(1)]), "uint16")
+%!assert (class ([double(1), uint8(1)]), "uint8")
+%!assert (class ([double(1), single(1)]), "single")
+%!assert (class ([double(1), double(1)]), "double")
+%!assert (class ([double(1), cell(1)]), "cell")
+%!assert (class ([double(1), true]), "double")
+%!assert (class ([double(1), "a"]), "char")
 
-%!assert (class ([cell(1), int64(1)]), 'cell')
-%!assert (class ([cell(1), int32(1)]), 'cell')
-%!assert (class ([cell(1), int16(1)]), 'cell')
-%!assert (class ([cell(1), int8(1)]), 'cell')
-%!assert (class ([cell(1), uint64(1)]), 'cell')
-%!assert (class ([cell(1), uint32(1)]), 'cell')
-%!assert (class ([cell(1), uint16(1)]), 'cell')
-%!assert (class ([cell(1), uint8(1)]), 'cell')
-%!assert (class ([cell(1), single(1)]), 'cell')
-%!assert (class ([cell(1), double(1)]), 'cell')
-%!assert (class ([cell(1), cell(1)]), 'cell')
-%!assert (class ([cell(1), true]), 'cell')
-%!assert (class ([cell(1), 'a']), 'cell')
+%!assert (class ([cell(1), int64(1)]), "cell")
+%!assert (class ([cell(1), int32(1)]), "cell")
+%!assert (class ([cell(1), int16(1)]), "cell")
+%!assert (class ([cell(1), int8(1)]), "cell")
+%!assert (class ([cell(1), uint64(1)]), "cell")
+%!assert (class ([cell(1), uint32(1)]), "cell")
+%!assert (class ([cell(1), uint16(1)]), "cell")
+%!assert (class ([cell(1), uint8(1)]), "cell")
+%!assert (class ([cell(1), single(1)]), "cell")
+%!assert (class ([cell(1), double(1)]), "cell")
+%!assert (class ([cell(1), cell(1)]), "cell")
+%!assert (class ([cell(1), true]), "cell")
+%!assert (class ([cell(1), "a"]), "cell")
 
-%!assert (class ([true, int64(1)]), 'int64')
-%!assert (class ([true, int32(1)]), 'int32')
-%!assert (class ([true, int16(1)]), 'int16')
-%!assert (class ([true, int8(1)]), 'int8')
-%!assert (class ([true, uint64(1)]), 'uint64')
-%!assert (class ([true, uint32(1)]), 'uint32')
-%!assert (class ([true, uint16(1)]), 'uint16')
-%!assert (class ([true, uint8(1)]), 'uint8')
-%!assert (class ([true, single(1)]), 'single')
-%!assert (class ([true, double(1)]), 'double')
-%!assert (class ([true, cell(1)]), 'cell')
-%!assert (class ([true, true]), 'logical')
-%!assert (class ([true, 'a']), 'char')
+%!assert (class ([true, int64(1)]), "int64")
+%!assert (class ([true, int32(1)]), "int32")
+%!assert (class ([true, int16(1)]), "int16")
+%!assert (class ([true, int8(1)]), "int8")
+%!assert (class ([true, uint64(1)]), "uint64")
+%!assert (class ([true, uint32(1)]), "uint32")
+%!assert (class ([true, uint16(1)]), "uint16")
+%!assert (class ([true, uint8(1)]), "uint8")
+%!assert (class ([true, single(1)]), "single")
+%!assert (class ([true, double(1)]), "double")
+%!assert (class ([true, cell(1)]), "cell")
+%!assert (class ([true, true]), "logical")
+%!assert (class ([true, "a"]), "char")
 
-%!assert (class (['a', int64(1)]), 'char')
-%!assert (class (['a', int32(1)]), 'char')
-%!assert (class (['a', int16(1)]), 'char')
-%!assert (class (['a', int8(1)]), 'char')
-%!assert (class (['a', int64(1)]), 'char')
-%!assert (class (['a', int32(1)]), 'char')
-%!assert (class (['a', int16(1)]), 'char')
-%!assert (class (['a', int8(1)]), 'char')
-%!assert (class (['a', single(1)]), 'char')
-%!assert (class (['a', double(1)]), 'char')
-%!assert (class (['a', cell(1)]), 'cell')
-%!assert (class (['a', true]), 'char')
-%!assert (class (['a', 'a']), 'char')
+%!assert (class (["a", int64(1)]), "char")
+%!assert (class (["a", int32(1)]), "char")
+%!assert (class (["a", int16(1)]), "char")
+%!assert (class (["a", int8(1)]), "char")
+%!assert (class (["a", int64(1)]), "char")
+%!assert (class (["a", int32(1)]), "char")
+%!assert (class (["a", int16(1)]), "char")
+%!assert (class (["a", int8(1)]), "char")
+%!assert (class (["a", single(1)]), "char")
+%!assert (class (["a", double(1)]), "char")
+%!assert (class (["a", cell(1)]), "cell")
+%!assert (class (["a", true]), "char")
+%!assert (class (["a", "a"]), "char")
 
-%!assert (class ([cell(1), struct('foo', 'bar')]), 'cell')
-%!error [struct('foo', 'bar'), cell(1)];
+%!assert (class ([cell(1), struct("foo", "bar")]), "cell")
+%!error [struct("foo", "bar"), cell(1)]
 */
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
 value is @code{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
-     @result{}  \"theseXX\"\n\
-         \"areXXXX\"\n\
-         \"strings\"\n\
+      @result{}  \"theseXX\"\n\
+          \"areXXXX\"\n\
+          \"strings\"\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
-%!error (string_fill_char (1, 2));
-%% string_fill_char() function call must be outside of %!test block
-%% due to the way a %!test block is wrapped inside a function
+## string_fill_char() function call must be outside of %!test block
+## due to the way a %!test block is wrapped inside a function
 %!shared orig_val, old_val
 %! orig_val = string_fill_char ();
 %! old_val  = string_fill_char ("X");
 %!test
 %! assert (orig_val, old_val);
 %! assert (string_fill_char (), "X");
 %! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char (orig_val);
 %! assert (string_fill_char (), orig_val);
+
+%!error (string_fill_char (1, 2))
 */
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -434,16 +434,18 @@ w32_sigint_handler (DWORD sig)
   switch(sig)
     {
       case CTRL_BREAK_EVENT:
       case CTRL_C_EVENT:
         w32_raise (SIGINT);
         break;
 
       case CTRL_CLOSE_EVENT:
+        clean_up_and_exit (0);
+        break;
       case CTRL_LOGOFF_EVENT:
       case CTRL_SHUTDOWN_EVENT:
       default:
         // We should do the following:
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
         user_abort(sig_name, sig);
         break;
@@ -952,19 +954,20 @@ Return a structure containing Unix signa
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error SIG (1);
-%!assert (isstruct (SIG ()));
-%!assert (! isempty (SIG ()));
+%!assert (isstruct (SIG ()))
+%!assert (! isempty (SIG ()))
+
+%!error SIG (1)
 */
 
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
@@ -976,24 +979,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 /*
-%!error (debug_on_interrupt (1, 2));
 %!test
 %! orig_val = debug_on_interrupt ();
 %! old_val = debug_on_interrupt (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (debug_on_interrupt (), ! orig_val);
 %! debug_on_interrupt (orig_val);
 %! assert (debug_on_interrupt (), orig_val);
+
+%!error (debug_on_interrupt (1, 2))
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
@@ -1004,24 +1008,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
 /*
-%!error (sighup_dumps_octave_core (1, 2));
 %!test
 %! orig_val = sighup_dumps_octave_core ();
 %! old_val = sighup_dumps_octave_core (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (sighup_dumps_octave_core (), ! orig_val);
 %! sighup_dumps_octave_core (orig_val);
 %! assert (sighup_dumps_octave_core (), orig_val);
+
+%!error (sighup_dumps_octave_core (1, 2))
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
@@ -1032,17 +1037,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
 
 /*
-%!error (sigterm_dumps_octave_core (1, 2));
 %!test
 %! orig_val = sigterm_dumps_octave_core ();
 %! old_val = sigterm_dumps_octave_core (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (sigterm_dumps_octave_core (), ! orig_val);
 %! sigterm_dumps_octave_core (orig_val);
 %! assert (sigterm_dumps_octave_core (), orig_val);
+
+%!error (sigterm_dumps_octave_core (1, 2))
 */
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -73,17 +73,18 @@ of real of complex values @var{sv}, over
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
 compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified\n\
 their values are derived from the maximum index in the vectors @var{i} and\n\
 @var{j} as given by @code{@var{m} = max (@var{i})},\n\
 @code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
-be added.\n\
+be added. See @code{accumarray} for an example of how to produce different\n\
+behavior, such as taking the minimum instead.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
 @group\n\
 s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
 s = sparse (i, j, s, m, n, \"sum\")\n\
@@ -93,17 +94,17 @@ s = sparse (i, j, s, m, n, \"sum\")\n\
 Given the option \"unique\". if more than two values are specified for the\n\
 same @var{i}, @var{j} indices, the last specified value will be used.\n\
 \n\
 @code{sparse(@var{m}, @var{n})} is equivalent to\n\
 @code{sparse ([], [], [], @var{m}, @var{n}, 0)}\n\
 \n\
 If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded\n\
 to have a common size.\n\
-@seealso{full}\n\
+@seealso{full, accumarray}\n\
 @end deftypefn")
 {
    octave_value retval;
    int nargin = args.length ();
 
    // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
    unwind_protect frame;
    frame.protect_var (Vsparse_auto_mutate);
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -147,33 +147,33 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
       retval = octave_value (result, '\'');
     }
 
   return retval;
 }
 
 /*
 %!assert (char (), '');
-%!assert (char (100) == "d");
-%!assert (all(char (100,100) == ["d";"d"]));
-%!assert (all(char ({100,100}) == ["d";"d"]));
-%!assert (all(char ([100,100]) == ["dd"]));
-%!assert (all(char ({100,{100}}) == ["d";"d"]));
-%!assert (all(char (100, [], 100) == ["d";" ";"d"]))
-%!assert (all(char ({100, [], 100}) == ["d";" ";"d"]))
-%!assert (all(char ({100,{100, {""}}}) == ["d";"d";" "]))
-%!assert (all(char (["a";"be"], {"c", 100}) == ["a";"be";"c";"d"]))
-%!assert(strcmp (char ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"]));
-%!assert(strcmp (char ([65, 83, 67, 73, 73]), "ASCII"));
+%!assert (char (100), "d");
+%!assert (char (100,100), ["d";"d"])
+%!assert (char ({100,100}), ["d";"d"])
+%!assert (char ([100,100]), ["dd"])
+%!assert (char ({100,{100}}), ["d";"d"])
+%!assert (char (100, [], 100), ["d";" ";"d"])
+%!assert (char ({100, [], 100}), ["d";" ";"d"])
+%!assert (char ({100,{100, {""}}}), ["d";"d";" "])
+%!assert (char (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
+%!assert (char ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
+%!assert (char ([65, 83, 67, 73, 73]), "ASCII")
 
 %!test
 %! x = char ("foo", "bar", "foobar");
-%! assert((strcmp (x(1,:), "foo   ")
-%! && strcmp (x(2,:), "bar   ")
-%! && strcmp (x(3,:), "foobar")));
+%! assert (x(1,:), "foo   ");
+%! assert (x(2,:), "bar   ");
+%! assert (x(3,:), "foobar");
 */
 
 DEFUN (strvcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} strvcat (@var{x})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{cell_array})\n\
@@ -281,28 +281,29 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strvcat> strvcat()
 %!assert (strvcat (""), "");
 %!assert (strvcat (100) == "d");
-%!assert (all(strvcat (100,100) == ["d";"d"]));
-%!assert (all(strvcat ({100,100}) == ["d";"d"]));
-%!assert (all(strvcat ([100,100]) == ["dd"]));
-%!assert (all(strvcat ({100,{100}}) == ["d";"d"]));
-%!assert (all(strvcat (100, [], 100) == ["d";"d"]))
-%!assert (all(strvcat ({100, [], 100}) == ["d";"d"]))
-%!assert (all(strvcat ({100,{100, {""}}}) == ["d";"d"]))
-%!assert (all(strvcat (["a";"be"], {"c", 100}) == ["a";"be";"c";"d"]))
-%!assert(strcmp (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"]));
+%!assert (strvcat (100,100), ["d";"d"])
+%!assert (strvcat ({100,100}), ["d";"d"])
+%!assert (strvcat ([100,100]), ["dd"])
+%!assert (strvcat ({100,{100}}), ["d";"d"])
+%!assert (strvcat (100, [], 100), ["d";"d"])
+%!assert (strvcat ({100, [], 100}), ["d";"d"])
+%!assert (strvcat ({100,{100, {""}}}), ["d";"d"])
+%!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
+%!assert (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
+
+%!error strvcat ()
 */
 
 
 DEFUN (ischar, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
@@ -316,29 +317,30 @@ Return true if @var{x} is a character ar
     retval = args(0).is_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (ischar ("a"), logical (1));
-%!assert (ischar (["ab";"cd"]), logical (1));
-%!assert (ischar ({"ab"}), logical (0));
-%!assert (ischar (1), logical (0));
-%!assert(ischar ([1, 2]), logical (0));
-%!assert(ischar ([]), logical (0));
-%!assert(ischar ([1, 2; 3, 4]), logical (0));
-%!assert(ischar (""), logical (1));
-%!assert(ischar ("test"), logical (1));
-%!assert(ischar (["test"; "ing"]), logical (1));
-%!assert(ischar (struct ("foo", "bar")), logical (0));
-%!error <Invalid call to ischar> ischar ();
-%!error <Invalid call to ischar> ischar ("test", 1);
+%!assert (ischar ("a"), true)
+%!assert (ischar (["ab";"cd"]), true)
+%!assert (ischar ({"ab"}), false)
+%!assert (ischar (1), false)
+%!assert (ischar ([1, 2]), false)
+%!assert (ischar ([]), false)
+%!assert (ischar ([1, 2; 3, 4]), false)
+%!assert (ischar (""), true)
+%!assert (ischar ("test"), true)
+%!assert (ischar (["test"; "ing"]), true)
+%!assert (ischar (struct ("foo", "bar")), false)
+
+%!error ischar ()
+%!error ischar ("test", 1)
 */
 
 static octave_value
 do_strcmp_fun (const octave_value& arg0, const octave_value& arg1,
                octave_idx_type n, const char *fcn_name,
                bool (*array_op) (const charNDArray&, const charNDArray&, octave_idx_type),
                bool (*str_op) (const std::string&, const std::string&, octave_idx_type))
 
@@ -584,61 +586,61 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strcmp> strcmp ();
-%!error <Invalid call to strcmp> strcmp ("foo", "bar", 3);
-%!
 %!shared x
-%!  x = char (zeros (0, 2));
-%!assert (strcmp ('', x) == false);
-%!assert (strcmp (x, '') == false);
-%!assert (strcmp (x, x) == true);
-## %!assert (strcmp ({''}, x) == true);
-## %!assert (strcmp ({x}, '') == false);
-## %!assert (strcmp ({x}, x) == true);
-## %!assert (strcmp ('', {x}) == false);
-## %!assert (strcmp (x, {''}) == false);
-## %!assert (strcmp (x, {x}) == true);
-## %!assert (all (strcmp ({x; x}, '') == [false; false]));
-## %!assert (all (strcmp ({x; x}, {''}) == [false; false]));
-## %!assert (all (strcmp ('', {x; x}) == [false; false]));
-## %!assert (all (strcmp ({''}, {x; x}) == [false; false]));
-%!assert (strcmp ({'foo'}, x) == false);
-%!assert (strcmp ({'foo'}, 'foo') == true);
-%!assert (strcmp ({'foo'}, x) == false);
-%!assert (strcmp (x, {'foo'}) == false);
-%!assert (strcmp ('foo', {'foo'}) == true);
-%!assert (strcmp (x, {'foo'}) == false);
+%! x = char (zeros (0, 2));
+%!assert (strcmp ("", x), false)
+%!assert (strcmp (x, ""), false)
+%!assert (strcmp (x, x), true)
+## %!assert (strcmp ({""}, x), true)
+## %!assert (strcmp ({x}, ""), false)
+## %!assert (strcmp ({x}, x), true)
+## %!assert (strcmp ("", {x}), false)
+## %!assert (strcmp (x, {""}), false)
+## %!assert (strcmp (x, {x}), true)
+## %!assert (strcmp ({x; x}, ""), [false; false])
+## %!assert (strcmp ({x; x}, {""}), [false; false])
+## %!assert (strcmp ("", {x; x}), [false; false])
+## %!assert (strcmp ({""}, {x; x}), [false; false])
+%!assert (strcmp ({"foo"}, x), false)
+%!assert (strcmp ({"foo"}, "foo"), true)
+%!assert (strcmp ({"foo"}, x), false)
+%!assert (strcmp (x, {"foo"}), false)
+%!assert (strcmp ("foo", {"foo"}), true)
+%!assert (strcmp (x, {"foo"}), false)
 %!shared y
-%!  y = char (zeros (2, 0));
-%!assert (strcmp ('', y) == false);
-%!assert (strcmp (y, '') == false);
-%!assert (strcmp (y, y) == true);
-%!assert (all (strcmp ({''}, y) == [true; true]));
-%!assert (strcmp ({y}, '') == true);
-%!assert (all (strcmp ({y}, y) == [true; true]));
-%!assert (all (strcmp ('', {y}) == [true; true]));
-%!assert (all (strcmp (y, {''}) == [true; true]));
-%!assert (all (strcmp (y, {y}) == [true; true]));
-%!assert (all (strcmp ({y; y}, '') == [true; true]));
-%!assert (all (strcmp ({y; y}, {''}) == [true; true]));
-%!assert (all (strcmp ('', {y; y}) == [true; true]));
-%!assert (all (strcmp ({''}, {y; y}) == [true; true]));
-%!assert (all (strcmp ({'foo'}, y) == [false; false]));
-%!assert (all (strcmp ({'foo'}, y) == [false; false]));
-%!assert (all (strcmp (y, {'foo'}) == [false; false]));
-%!assert (all (strcmp (y, {'foo'}) == [false; false]));
-%!assert (strcmp ("foobar", "foobar"), true);
-%!assert (strcmp ("fooba", "foobar"), false);
+%! y = char (zeros (2, 0));
+%!assert (strcmp ("", y), false)
+%!assert (strcmp (y, ""), false)
+%!assert (strcmp (y, y), true)
+%!assert (strcmp ({""}, y), [true; true])
+%!assert (strcmp ({y}, ""), true)
+%!assert (strcmp ({y}, y), [true; true])
+%!assert (strcmp ("", {y}), true)
+%!assert (strcmp (y, {""}), [true; true])
+%!assert (strcmp (y, {y}), [true; true])
+%!assert (strcmp ({y; y}, ""), [true; true])
+%!assert (strcmp ({y; y}, {""}), [true; true])
+%!assert (strcmp ("", {y; y}), [true; true])
+%!assert (strcmp ({""}, {y; y}), [true; true])
+%!assert (strcmp ({"foo"}, y), [false; false])
+%!assert (strcmp ({"foo"}, y), [false; false])
+%!assert (strcmp (y, {"foo"}), [false; false])
+%!assert (strcmp (y, {"foo"}), [false; false])
+%!assert (strcmp ("foobar", "foobar"), true)
+%!assert (strcmp ("fooba", "foobar"), false)
+
+%!error strcmp ()
+%!error strcmp ("foo", "bar", 3)
 */
 
 // Apparently, Matlab ignores the dims with strncmp. It also
 static bool
 strncmp_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
@@ -707,25 +709,26 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strncmp> strncmp ();
-%!error <Invalid call to strncmp> strncmp ("abc", "def");
-%!assert (strncmp ("abce", "abc", 3) == 1)
-%!assert (strncmp (100, 100, 1) == 0)
-%!assert (all (strncmp ("abce", {"abcd", "bca", "abc"}, 3) == [1, 0, 1]))
-%!assert (all (strncmp ("abc",  {"abcd", "bca", "abc"}, 4) == [0, 0, 0]))
-%!assert (all (strncmp ({"abcd", "bca", "abc"},"abce", 3) == [1, 0, 1]))
-%!assert (all (strncmp ({"abcd", "bca", "abc"},{"abcd", "bca", "abe"}, 3) == [1, 1, 0]))
-%!assert (all (strncmp("abc", {"abcd", 10}, 2) == [1, 0]))
+%!assert (strncmp ("abce", "abc", 3), true)
+%!assert (strncmp (100, 100, 1), false)
+%!assert (strncmp ("abce", {"abcd", "bca", "abc"}, 3), logical ([1, 0, 1]))
+%!assert (strncmp ("abc",  {"abcd", "bca", "abc"}, 4), logical ([0, 0, 0]))
+%!assert (strncmp ({"abcd", "bca", "abc"},"abce", 3), logical ([1, 0, 1]))
+%!assert (strncmp ({"abcd", "bca", "abc"},{"abcd", "bca", "abe"}, 3), logical ([1, 1, 0]))
+%!assert (strncmp ("abc", {"abcd", 10}, 2), logical ([1, 0]))
+
+%!error strncmp ()
+%!error strncmp ("abc", "def")
 */
 
 // case-insensitive character equality functor
 struct icmp_char_eq : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) == std::toupper (y); }
 };
@@ -778,17 +781,17 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (strcmpi("abc123", "ABC123"), logical(1));
+%!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
 strncmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
@@ -845,17 +848,17 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (strncmpi("abc123", "ABC456", 3), logical(1));
+%!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
 Return a string containing the elements of @var{arg} listed in\n\
 columns with an overall maximum width of @var{width}.  The argument\n\
 @var{arg} must be a cell array of character strings or a character array.\n\
@@ -918,20 +921,21 @@ whos ans\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to list_in_columns> list_in_columns ();
-%!error <Invalid call to list_in_columns> list_in_columns (["abc", "def"], 20, 2);
-%!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a");
+%!test
+%! input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
+%! result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
+%! assert (list_in_columns (input, 20), result);
 %!test
-%!  input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
-%!  result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
-%!  assert (list_in_columns (input, 20) == result);
-%!test
-%!  input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
-%!  result = "abc     mnop  \ndef     qrs   \nghijkl  tuv   \n";
-%!  assert (list_in_columns (input, 20) == result);
+%! input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
+%! result = "abc     mnop  \ndef     qrs   \nghijkl  tuv   \n";
+%! assert (list_in_columns (input, 20), result);
+
+%!error list_in_columns ()
+%!error list_in_columns (["abc", "def"], 20, 2)
+%!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a")
 */
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1526,21 +1526,20 @@ need to recompiled.\n\
 %! state = ignore_function_time_stamp ("all");
 %! assert (state, old_state);
 %! assert (ignore_function_time_stamp (), "all");
 %! state = ignore_function_time_stamp ("system");
 %! assert (state, "all");
 %! assert (ignore_function_time_stamp (), "system");
 %! ignore_function_time_stamp (old_state);
 
-%% Test input validation
+## Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
-
 */
 
 DEFUN (__current_scope__, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __dump_symtab_info__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -364,56 +364,54 @@ exit status, it will linger until Octave
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
-%!  if (isunix())
-%!    [in, out, pid] = popen2 ("sort", "-r");
-%!    EAGAIN = errno ("EAGAIN");
-%!  else
-%!    [in, out, pid] = popen2 ("sort", "/R");
-%!    EAGAIN = errno ("EINVAL");
-%!  endif
-%!  fputs (in, "these\nare\nsome\nstrings\n");
-%!  fclose (in);
-%!  done = false;
-%!  str = {};
-%!  idx = 0;
-%!  errs = 0;
-%!  do
-%!     if (!isunix())
-%!       errno (0);
-%!     endif
-%!     s = fgets (out);
-%!     if (ischar (s))
-%!       idx++;
-%!       str{idx} = s;
-%!     elseif (errno () == EAGAIN)
-%!       fclear (out);
-%!       sleep (0.1);
-%!       if (++errs == 100)
-%!         done = true;
-%!       endif
-%!     else
+%! if (isunix ())
+%!   [in, out, pid] = popen2 ("sort", "-r");
+%!   EAGAIN = errno ("EAGAIN");
+%! else
+%!   [in, out, pid] = popen2 ("sort", "/R");
+%!   EAGAIN = errno ("EINVAL");
+%! endif
+%! fputs (in, "these\nare\nsome\nstrings\n");
+%! fclose (in);
+%! done = false;
+%! str = {};
+%! idx = 0;
+%! errs = 0;
+%! do
+%!   if (!isunix ())
+%!     errno (0);
+%!   endif
+%!   s = fgets (out);
+%!   if (ischar (s))
+%!     idx++;
+%!     str{idx} = s;
+%!   elseif (errno () == EAGAIN)
+%!     fclear (out);
+%!     sleep (0.1);
+%!     if (++errs == 100)
 %!       done = true;
 %!     endif
-%!  until (done)
-%!  fclose (out);
-%!  if (isunix())
-%!    assert(str,{"these\n","strings\n","some\n","are\n"})
-%!  else
-%!    assert(str,{"these\r\n","strings\r\n","some\r\n","are\r\n"})
-%!  end
-
+%!   else
+%!     done = true;
+%!   endif
+%! until (done)
+%! fclose (out);
+%! if (isunix ())
+%!   assert(str, {"these\n","strings\n","some\n","are\n"});
+%! else
+%!   assert(str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
+%! endif
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
 may be passed as @var{request}:\n\
 \n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -119,31 +119,31 @@ w32_set_octave_home (void)
   if (h != INVALID_HANDLE_VALUE)
     {
       MODULEENTRY32 mod_info;
 
       ZeroMemory (&mod_info, sizeof (mod_info));
       mod_info.dwSize = sizeof (mod_info);
 
       if (Module32First (h, &mod_info))
-	{
-	  do
-	    {
-	      std::string mod_name (mod_info.szModule);
+        {
+          do
+            {
+              std::string mod_name (mod_info.szModule);
 
-	      if (mod_name.find ("octinterp") != std::string::npos)
-		{
-		  bin_dir = mod_info.szExePath;
-		  if (bin_dir[bin_dir.length () - 1] != '\\')
-		    bin_dir.append (1, '\\');
-		  break;
-		}
-	    }
-	  while (Module32Next (h, &mod_info));
-	}
+              if (mod_name.find ("octinterp") != std::string::npos)
+                {
+                  bin_dir = mod_info.szExePath;
+                  if (bin_dir[bin_dir.length () - 1] != '\\')
+                    bin_dir.append (1, '\\');
+                  break;
+                }
+            }
+          while (Module32Next (h, &mod_info));
+       }
 
       CloseHandle (h);
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
@@ -603,17 +603,17 @@ Set the value of the environment variabl
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (setenv, putenv);
 
 /*
-%!assert (ischar (getenv ("OCTAVE_HOME")));
+%!assert (ischar (getenv ("OCTAVE_HOME")))
 %!test
 %! setenv ("dummy_variable_that_cannot_matter", "foobar");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
 */
 
 // FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
@@ -717,19 +717,20 @@ clc;\n\
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
   return retval;
 }
 
 /*
-%!error (pause (1, 2));
 %!test
 %! pause (1);
+
+%!error (pause (1, 2))
 */
 
 DEFUN (sleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
 @end deftypefn")
 {
@@ -752,20 +753,21 @@ Suspend the execution of the program for
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error (sleep ());
-%!error (sleep (1, 2));
 %!test
 %! sleep (1);
+
+%!error (sleep ())
+%!error (sleep (1, 2))
 */
 
 DEFUN (usleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.  On systems where it is not possible to sleep for periods\n\
 of time less than one second, @code{usleep} will pause the execution for\n\
@@ -795,20 +797,21 @@ of time less than one second, @code{usle
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error (usleep ());
-%!error (usleep (1, 2));
 %!test
 %! usleep (1000);
+
+%!error (usleep ())
+%!error (usleep (1, 2))
 */
 
 // FIXME -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isieee ()\n\
@@ -818,32 +821,32 @@ for floating point calculations.  No act
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
                        || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
-%!assert (islogical (isieee ()));
+%!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} native_float_format ()\n\
 Return the native floating point format as a string\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
-%!assert (ischar (native_float_format ()));
+%!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Perform tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1479,22 +1479,23 @@ specified option.\n\
     retval = m;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error octave_config_info (1, 2);
-%!assert (ischar (octave_config_info ("version")));
+%!assert (ischar (octave_config_info ("version")))
 %!test
 %! x = octave_config_info ();
 %! assert (isstruct (x));
 %! assert (! isempty (x));
+
+%!error octave_config_info (1, 2)
 */
 
 #if defined (__GNUG__) && defined (DEBUG_NEW_DELETE)
 
 int debug_new_delete = 0;
 
 typedef void (*vfp)(void);
 extern vfp __new_handler;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -112,24 +112,24 @@ Return true if @var{name} is a valid var
     retval = valid_identifier (argv[1]) && ! is_keyword (argv[1]);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error isvarname ();
-%!error isvarname ("foo", "bar");
+%!assert (isvarname ("foo"), true)
+%!assert (isvarname ("_foo"), true)
+%!assert (isvarname ("_1"), true)
+%!assert (isvarname ("1foo"), false)
+%!assert (isvarname (""), false)
 
-%!assert (isvarname ("foo"), true);
-%!assert (isvarname ("_foo"), true);
-%!assert (isvarname ("_1"), true);
-%!assert (isvarname ("1foo"), false);
-%!assert (isvarname (""), false);
+%!error isvarname ()
+%!error isvarname ("foo", "bar");
 */
 
 // Return TRUE if F and G are both names for the same file.
 
 bool
 same_file (const std::string& f, const std::string& g)
 {
   return same_file_internal (f, g);
@@ -334,31 +334,31 @@ name in the path.  If no files are found
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error file_in_loadpath ();
-%!error file_in_loadpath ("foo", "bar", 1);
-
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
 %! f = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$");
 %! assert (f, "");
 
 %!test
 %! lst = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$", "all");
 %! assert (lst, {});
+
+%!error file_in_loadpath ()
+%!error file_in_loadpath ("foo", "bar", 1)
 */
 
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
@@ -417,32 +417,32 @@ name in the path.  If no files are found
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error file_in_path ();
-%!error file_in_path ("foo");
-%!error file_in_path ("foo", "bar", "baz", 1);
-
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
 %! f = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$");
 %! assert (f, "");
 
 %!test
 %! lst = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$", "all");
 %! assert (lst, {});
+
+%!error file_in_path ()
+%!error file_in_path ("foo")
+%!error file_in_path ("foo", "bar", "baz", 1)
 */
 
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
 
   if (! suffix.empty ())
@@ -669,29 +669,29 @@ Convert special characters in @var{strin
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error do_string_escapes ();
-%!error do_string_escapes ("foo", "bar");
+%!assert (do_string_escapes ('foo\nbar'), "foo\nbar")
+%!assert (do_string_escapes ("foo\\nbar"), "foo\nbar")
+%!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"])
+%!assert ("foo\nbar", ["foo", char(10), "bar"])
 
-%!assert (do_string_escapes ('foo\nbar'), "foo\nbar");
-%!assert (do_string_escapes ("foo\\nbar"), "foo\nbar");
-%!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"]);
-%!assert ("foo\nbar", ["foo", char(10), "bar"]);
+%!assert (do_string_escapes ('\a\b\f\n\r\t\v'), "\a\b\f\n\r\t\v")
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"), "\a\b\f\n\r\t\v")
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"),
+%!        char ([7, 8, 12, 10, 13, 9, 11]))
+%!assert ("\a\b\f\n\r\t\v", char ([7, 8, 12, 10, 13, 9, 11]))
 
-%!assert (do_string_escapes ('\a\b\f\n\r\t\v'), "\a\b\f\n\r\t\v");
-%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"), "\a\b\f\n\r\t\v");
-%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"),
-%!        char ([7, 8, 12, 10, 13, 9, 11]));
-%!assert ("\a\b\f\n\r\t\v", char ([7, 8, 12, 10, 13, 9, 11]));
+%!error do_string_escapes ()
+%!error do_string_escapes ("foo", "bar")
 */
 
 const char *
 undo_string_escape (char c)
 {
   if (! c)
     return "";
 
@@ -791,27 +791,27 @@ representation.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error undo_string_escapes ();
-%!error undo_string_escapes ("foo", "bar");
+%!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar')
+%!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar")
+%!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar")
 
-%!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar');
-%!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar");
-%!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar");
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v')
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), "\\a\\b\\f\\n\\r\\t\\v")
+%!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
+%!        "\\a\\b\\f\\n\\r\\t\\v")
 
-%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v');
-%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), "\\a\\b\\f\\n\\r\\t\\v");
-%!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
-%!        "\\a\\b\\f\\n\\r\\t\\v");
+%!error undo_string_escapes ()
+%!error undo_string_escapes ("foo", "bar")
 */
 
 DEFUN (is_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
@@ -823,20 +823,20 @@ Return true if @var{file} is an absolute
               && octave_env::absolute_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error is_absolute_filename ();
-%!error is_absolute_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error is_absolute_filename ()
+%!error is_absolute_filename ("foo", "bar")
 */
 
 DEFUN (is_rooted_relative_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
@@ -848,20 +848,20 @@ Return true if @var{file} is a rooted-re
               && octave_env::rooted_relative_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error is_rooted_relative_filename ();
-%!error is_rooted_relative_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error is_rooted_relative_filename ()
+%!error is_rooted_relative_filename ("foo", "bar")
 */
 
 DEFUN (make_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file}, relative to the current directory.\n\
 @seealso{is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
@@ -879,20 +879,20 @@ Return the full name of @var{file}, rela
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error make_absolute_filename ();
-%!error make_absolute_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error make_absolute_filename ()
+%!error make_absolute_filename ("foo", "bar")
 */
 
 DEFUN (find_dir_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} find_dir_in_path (@var{dir})\n\
 @deftypefnx {Built-in Function} {} find_dir_in_path (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.  The\n\
 match is performed at the end of each path element.  For example, if\n\
@@ -926,20 +926,20 @@ containing all name matches rather than 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error find_dir_in_path ();
-%!error find_dir_in_path ("foo", "bar", 1);
+## FIXME: We need system-dependent tests here.
 
-FIXME -- need to create tests using current path, pathsep, and dirsep.
+%!error find_dir_in_path ()
+%!error find_dir_in_path ("foo", "bar", 1)
 */
 
 DEFUNX ("errno", Ferrno, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
@@ -977,28 +977,28 @@ if @var{name} is not found.\n\
     retval = octave_errno::get ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error errno ("foo", 1);
-
-%!assert (isnumeric (errno ()));
+%!assert (isnumeric (errno ()))
 
 %!test
 %! lst = errno_list ();
 %! fns = fieldnames (lst);
 %! oldval = errno (fns{1});
 %! assert (isnumeric (oldval));
 %! errno (oldval);
 %! newval = errno ();
 %! assert (oldval, newval);
+
+%!error errno ("foo", 1)
 */
 
 DEFUN (errno_list, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @end deftypefn")
 {
@@ -1008,19 +1008,19 @@ Return a structure containing the system
     retval = octave_errno::list ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error errno_list ("foo");
+%!assert (isstruct (errno_list ()))
 
-%!assert (isstruct (errno_list ()));
+%!error errno_list ("foo")
 */
 
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       warning_with_id ("Octave:neg-dim-as-zero",
@@ -1326,21 +1326,21 @@ subsequent indexing using @var{ind} will
           retval = false;
         }
     }
 
   return retval;
 }
 
 /*
-%!error isindex ();
+%!assert (isindex ([1, 2, 3]))
+%!assert (isindex (1:3))
+%!assert (isindex ([1, 2, -3]), false)
 
-%!assert (isindex ([1, 2, 3]));
-%!assert (isindex (1:3));
-%!assert (isindex ([1, 2, -3]), false);
+%!error isindex ()
 */
 
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args,
                    int nargout)
 {
   octave_value_list new_args = args, retval;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -575,27 +575,27 @@ Check only for directories.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  if (isunix ())
-%!    assert (exist ("/tmp") == 7);
-%!    assert (exist ("/tmp", "file") == 7);
-%!    assert (exist ("/tmp", "dir") == 7);
-%!    assert (exist ("/bin/sh") == 2);
-%!    assert (exist ("/bin/sh", "file") == 2);
-%!    assert (exist ("/bin/sh", "dir") == 0);
-%!    assert (exist ("/dev/null") == 2);
-%!    assert (exist ("/dev/null", "file") == 2);
-%!    assert (exist ("/dev/null", "dir") == 0);
-%!  endif
+%! if (isunix ())
+%!   assert (exist ("/tmp") == 7);
+%!   assert (exist ("/tmp", "file") == 7);
+%!   assert (exist ("/tmp", "dir") == 7);
+%!   assert (exist ("/bin/sh") == 2);
+%!   assert (exist ("/bin/sh", "file") == 2);
+%!   assert (exist ("/bin/sh", "dir") == 0);
+%!   assert (exist ("/dev/null") == 2);
+%!   assert (exist ("/dev/null", "file") == 2);
+%!   assert (exist ("/dev/null", "dir") == 0);
+%! endif
 */
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
   octave_value val = symbol_table::varval (nm);
 
   return val.is_function_handle () ? val : octave_value ();
