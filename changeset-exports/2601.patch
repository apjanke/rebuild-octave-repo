# HG changeset patch
# User jwe
# Date 852529464 0
#      Mon Jan 06 05:44:24 1997 +0000
# Node ID 3723512a827a67d88551dd6f8debbcbe521a18e5
# Parent  c454cd888adace11eea02ac29b637cd9f935b009
[project @ 1997-01-06 05:43:16 by jwe]

diff --git a/PROJECTS b/PROJECTS
--- a/PROJECTS
+++ b/PROJECTS
@@ -205,16 +205,29 @@ Input/Output:
 
   * Make it possible to tie arbitrary input and output streams
     together, similar to the way iostreams can be tied together.
 
 -----------
 Interpreter:
 -----------
 
+  * Fix the parser so that
+
+      function foo ()
+        implicit_str_to_num_ok = 1;
+        '#' + 0;
+      endfunction
+
+    succeeds, even when implicit_str_to_num_ok is 0 at the time the
+    function is parsed.
+
+  * Consider making x(:) work no matter what the value of
+    do_fortran_indexing.
+
   * If foo.oct and foo.m both exist in the LOADPATH, Octave will
     always find foo.oct, even if foo.m appears earlier in the list of
     directories.  This should be fixed (in the kpathsearch library) to
     find the first .oct or .m file in the path, and only prefer .oct
     over .m if both files are in the same directory.
 
   * Fix the grammar to allow structure references and index operations
     for for anonymous expressions.  For example, it should be possible
diff --git a/README.Linux b/README.Linux
--- a/README.Linux
+++ b/README.Linux
@@ -88,16 +88,22 @@ find something like this:
 
 changing it to
 
   %{!shared: %{p:-lgmon} %{pg:-lgmon} %{!ggdb:-lc} %{ggdb:-lg}}
 
 should keep gcc from adding -lieee to the link command.  You can find
 the location of the specs file by running the command gcc -v.
 
+If you can't edit the gcc specs file for some reason, another solution
+that should work is to create an empty libieee.a file in the Octave
+src directory using the command:
+
+  ar cq libieee.a
+
 My system doesn't have g77
 --------------------------
 
 A binary release of g77 that should work with gcc 2.7.2 is available
 from sunsite.unc.edu in the directory /pub/Linux/devel/lang/fortran.
 There is also a Debian package for g77.
 
 Problems with g77 on Debian 1.2 systems (and possibly others)
@@ -116,16 +122,21 @@ copying f771 and libf2c.a from /usr/lib/
 Upgrading your compiler and libraries
 -------------------------------------
 
 Installing libg++ on a Linux system is not as simple as it should be,
 because libg++ shares some basic I/O code with the Linux C library,
 and they must be compatible.  You should get and read the release
 notes for the compiler and libraries.
 
+If you decide to install versions of the libraries that are older (or
+newer) than the ones you already have, you should follow the
+directions in the release notes very carefully.
+
+
 If you have comments or suggestions for this document, please contact
 bug-octave@bevo.che.wisc.edu.
 
 John W. Eaton
 jwe@bevo.che.wisc.edu
 University of Wisconsin-Madison
 Department of Chemical Engineering
 
diff --git a/WWW/mailing-lists/index.html b/WWW/mailing-lists/index.html
--- a/WWW/mailing-lists/index.html
+++ b/WWW/mailing-lists/index.html
@@ -9,44 +9,47 @@
 <h1>Octave Mailing List Archives</h1>
 <hr>
 
 <h2>help-octave</h2>
 <h3>General discussion about using and installing Octave</h3>
 
 <p>
 <ul>
+<li><a href="help-octave/1997">1997</a>
 <li><a href="help-octave/1996">1996</a>
 <li><a href="help-octave/1995">1995</a>
 <li><a href="help-octave/1994">1994</a>
 <li><a href="help-octave/1993">1993</a>
 <li><a href="help-octave/1992">1992</a>
 </ul>
 </p>
 <hr>
 
 <h2>bug-octave</h2>
 <h3>Bug reports (sometimes fixes are posted to this list)</h3>
 
 <p>
 <ul>
+<li><a href="bug-octave/1997">1997</a>
 <li><a href="bug-octave/1996">1996</a>
 <li><a href="bug-octave/1995">1995</a>
 <li><a href="bug-octave/1994">1994</a>
 <li><a href="bug-octave/1993">1993</a>
 <li><a href="bug-octave/1992">1992</a>
 </ul>
 </p>
 <hr>
 
 <h2>octave-sources</h2>
 <h3>Enhancements contributed by Octave users</h3>
 
 <p>
 <ul>
+<li><a href="octave-sources/1997">1997</a>
 <li><a href="octave-sources/1996">1996</a>
 </ul>
 </p>
 <hr>
 
 <h2><a name="JOIN">How to join the mailing lists</a></h2>
 
 <p>
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,14 @@
+Sun Jan  5 12:07:45 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* dMatrix.cc (Matrix::read): Correctly compute the number of
+	columns for resizing when the number of rows is specified but the
+	number of columns is not.
+
 Wed Dec 18 16:18:58 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Range.cc (operator -): New function.
 
 	* lo-ieee.cc: Include <nan.h> on all systems that have it.
 
 Fri Dec 13 02:01:32 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2883,17 +2883,17 @@ Matrix::read (istream& is, int nr, int n
 		{
 		  if (is)
 		    {
 		      if (count == max_size)
 			{
 			  max_size *= 2;
 
 			  if (nr > 0)
-			    resize (nr, max_size / 2, 0.0);
+			    resize (nr, max_size / nr, 0.0);
 			  else
 			    resize (max_size, 1, 0.0);
 
 			  data = fortran_vec ();
 			}
 
 		      data[count++] = tmp;
 		    }
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,15 @@
+Thu Dec 19 22:16:46 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* elfun/lcm.m: Replace missing if statement.
+
+	* elfun/gcd.m: Report error if no input args.
+	* elfun/lcm.m: Likewise.
+
 Mon Dec 16 15:23:04 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install): Use ls -LR to create ls-R database.
 	Also list contents of $libexecdir/octave in ls-R database.
 
 Tue Dec 10 01:43:07 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Version 2.0 released.
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -26,16 +26,20 @@
 ## [g [, v]] = gcd (a1, ..., ak) is the same with a = [a1, ..., ak].
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function [g, v] = gcd (a, ...)
 
+  if (nargin == 0)
+    usage ("[g, v] = gcd (a, ...)");
+  endif
+
   if (nargin > 1)
     va_start;
     for k = 2:nargin;
       a = [a, (va_arg ())];
     endfor
   endif
 
   if (round (a) != a)
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -24,16 +24,21 @@
 ## lcm (a1, ..., ak) is the same as lcm([a1, ..., ak]).
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (a, ...)
 
+  if (nargin == 0)
+    usage ("lcm (a, ...)");
+  endif
+
+  if (nargin > 1)
     va_start;
     for k = 2:nargin;
       a = [a, (va_arg ())];
     endfor
   endif
 
   if (round (a) != a)
     error ("lcm:  all arguments must be integer");
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,31 @@
+Sun Jan  5 12:50:25 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ops.h (SC_MX_BOOL_OP, MX_SC_BOOL_OP): New arg, empty_result.
+	* op-cm-cm.cc, op-cm-cs.cc, op-cm-m.cc, op-cm-s.cc, op-cs-cm.cc,
+	op-cs-m.cc, op-m-cm.cc, op-m-cs.cc, op-m-m.cc, op-m-s.cc,
+	op-s-cm.cc, op-s-m.cc, op-str-str.cc: Change all uses of
+	SC_MX_BOOL_OP and MX_SC_BOOL_OP macros.  Return correct results
+	for empty matrix cases.
+
+	* pt-fcn.cc (tree_function::eval): If Vdefine_all_return_values is
+	true, initialize return values before evaluating function, for
+	compatibility with Matlab.
+
+	* oct-stream.cc (get_size): Correctly set size when arg is scalar.
+
+Thu Jan  2 12:40:10 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (install-oct): Quote $(OCT_FILES) in for loop to
+	avoid syntax error from ksh.
+
+	* pr-output.cc (octave_print_internal): Avoid unused parameter
+	warning from gcc.
+
 Thu Dec 19 12:13:42 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* oct-stream.cc (octave_base_stream::do_scanf):
 	Don't treat %l{e,f,g} differently from %{e,f,g}.
 	(octave_base_stream::do_oscanf): Likewise.
 
 	* sighandlers.cc (sigchld_handler): Fix typos.
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -256,17 +256,17 @@ install-bin:
 	$(INSTALL_PROGRAM) octave$(EXE) $(bindir)/octave-$(version)$(EXE)
 	$(LN_S) $(bindir)/octave-$(version)$(EXE) $(bindir)/octave$(EXE)
 .PHONY: install-bin
 
 install-oct: mk-oct-links
 	if [ -n "$(OCT_FILES)" ]; then \
 	  $(top_srcdir)/mkinstalldirs $(octfiledir) ; \
 	  chmod a+rx mk-oct-links ; \
-	  for f in $(OCT_FILES); do \
+	  for f in "$(OCT_FILES)"; do \
 	    $(INSTALL_PROGRAM) $$f $(octfiledir)/$$f; \
 	  done ; \
 	  ./mk-oct-links $(octfiledir) $(addprefix $(srcdir)/, $(DLD_SRC)) ; \
 	fi
 .PHONY: install-oct
 
 install-lib:
 	$(top_srcdir)/mkinstalldirs $(libdir)
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -107,32 +107,40 @@ static void
 get_size (const Matrix& size, int& nr, int& nc, const char *warn_for)
 {
   nr = -1;
   nc = -1;
 
   double dnr = -1.0;
   double dnc = -1.0;
 
-  if (size.rows () == 1 && size.cols () > 0)
+  int sz_nr = size.rows ();
+  int sz_nc = size.cols ();
+
+  if (sz_nr == 1 && sz_nc == 1)
+    {
+      dnr = size (0, 0);
+      dnc = 1.0;
+    }
+  else if (sz_nr == 1 && sz_nc > 0)
     {
       dnr = size (0, 0);
 
-      if (size.cols () == 2)
+      if (sz_nc == 2)
 	dnc = size (0, 1);
-      else if (size.cols () > 2)
+      else if (sz_nc > 2)
 	::error ("%s: invalid size specification", warn_for);
     }
-  else if (size.cols () == 1 && size.rows () > 0)
+  else if (sz_nc == 1 && sz_nr > 0)
     {
       dnr = size (0, 0);
 
-      if (size.rows () == 2)
+      if (sz_nr == 2)
 	dnc = size (1, 0);
-      else if (size.rows () > 2)
+      else if (sz_nr > 2)
 	::error ("%s: invalid size specification", warn_for);
     }
   else
     ::error ("%s: invalid size specification", warn_for);
 
   if (! error_state)
     {
       nr = get_size (dnr, warn_for);
diff --git a/src/op-cm-cm.cc b/src/op-cm-cm.cc
--- a/src/op-cm-cm.cc
+++ b/src/op-cm-cm.cc
@@ -94,61 +94,61 @@ ldiv (const octave_value& a1, const octa
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
 		 real (m1 (i, j)) OP real (m2 (i, j)), #OP, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, 0.0);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, 0.0);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 1.0);
+		 m1 (i, j) == m2 (i, j), "==", 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, 0.0);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, 0.0);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != m2 (i, j), "!=", 0.0);
+		 m1 (i, j) != m2 (i, j), "!=", 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return octave_value (product (v1.complex_matrix_value (),
@@ -183,27 +183,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&", 0.0);
+		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&", Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|", 0.0);
+		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|", Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex_matrix&);
 
diff --git a/src/op-cm-cs.cc b/src/op-cm-cs.cc
--- a/src/op-cm-cs.cc
+++ b/src/op-cm-cs.cc
@@ -87,71 +87,71 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 real (m (i, j)) OP real (s))
+		 real (m (i, j)) OP real (s), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) == s);
+		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) != s);
+		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   return octave_value (v1.complex_matrix_value () * v2.complex_value ());
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) != 0.0 && s != 0.0);
+		 m (i, j) != 0.0 && s != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) != 0.0 || s != 0.0);
+		 m (i, j) != 0.0 || s != 0.0, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex&);
 
diff --git a/src/op-cm-m.cc b/src/op-cm-m.cc
--- a/src/op-cm-m.cc
+++ b/src/op-cm-m.cc
@@ -92,51 +92,51 @@ ldiv (const octave_value& a1, const octa
 		 Matrix, m2, v2.matrix_value (), \
 		 real (m1 (i, j)) OP m2 (i, j), #OP, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, 0.0);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, 0.0);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 1.0);
+		 m1 (i, j) == m2 (i, j), "==", 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, 0.0);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, 0.0);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
@@ -178,27 +178,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) != 0.0 && m2 (i, j), "&", 0.0);
+		 m1 (i, j) != 0.0 && m2 (i, j), "&", Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) != 0.0 || m2 (i, j), "|", 0.0);
+		 m1 (i, j) != 0.0 || m2 (i, j), "|", Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_matrix&);
 
diff --git a/src/op-cm-s.cc b/src/op-cm-s.cc
--- a/src/op-cm-s.cc
+++ b/src/op-cm-s.cc
@@ -87,71 +87,71 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 double, s, v2.double_value (), \
-		 real (m (i, j)) OP s)
+		 real (m (i, j)) OP s, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 double, s, v2.double_value (), \
-		 m (i, j) == s);
+		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 double, s, v2.double_value (), \
-		 m (i, j) != s);
+		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   return octave_value (v1.complex_matrix_value () * v2.double_value ());
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 double, s, v2.double_value (), \
-		 m (i, j) != 0.0 && s);
+		 m (i, j) != 0.0 && s, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
 		 double, s, v2.double_value (), \
-		 m (i, j) != 0.0 || s);
+		 m (i, j) != 0.0 || s, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_scalar&);
 
diff --git a/src/op-cs-cm.cc b/src/op-cs-cm.cc
--- a/src/op-cs-cm.cc
+++ b/src/op-cs-cm.cc
@@ -87,71 +87,71 @@ ldiv (const octave_value& a1, const octa
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 real (s) OP real (m (i, j)))
+		 real (s) OP real (m (i, j)), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s == m (i, j));
+		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s != m (i, j));
+		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   return octave_value (v1.complex_value () * v2.complex_matrix_value ());
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s != 0.0 && m (i, j) != 0.0);
+		 s != 0.0 && m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s != 0.0 || m (i, j) != 0.0);
+		 s != 0.0 || m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-cs-m.cc b/src/op-cs-m.cc
--- a/src/op-cs-m.cc
+++ b/src/op-cs-m.cc
@@ -88,71 +88,71 @@ ldiv (const octave_value& a1, const octa
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 real (s) OP m (i, j))
+		 real (s) OP m (i, j), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s == m (i, j));
+		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s != m (i, j));
+		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   return octave_value (v1.complex_value () * v2.matrix_value ());
@@ -189,27 +189,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 && m (i, j));
+		 s != 0.0 && m (i, j), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 || m (i, j));
+		 s != 0.0 || m (i, j), Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-m-cm.cc b/src/op-m-cm.cc
--- a/src/op-m-cm.cc
+++ b/src/op-m-cm.cc
@@ -92,61 +92,61 @@ ldiv (const octave_value& a1, const octa
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
 		 m1 (i, j) OP real (m2 (i, j)), #OP, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, 0.0);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, 0.0);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 1.0);
+		 m1 (i, j) == m2 (i, j), "==", 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, 0.0);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, 0.0);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != m2 (i, j), "!=", 0.0);
+		 m1 (i, j) != m2 (i, j), "!=", 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return product (v1.matrix_value (), v2.complex_matrix_value ());
@@ -178,27 +178,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) && m2 (i, j) != 0.0, "&", 0.0);
+		 m1 (i, j) && m2 (i, j) != 0.0, "&", Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) || m2 (i, j) != 0.0, "|", 0.0);
+		 m1 (i, j) || m2 (i, j) != 0.0, "|", Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-cs.cc b/src/op-m-cs.cc
--- a/src/op-m-cs.cc
+++ b/src/op-m-cs.cc
@@ -88,71 +88,71 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) OP real (s))
+		 m (i, j) OP real (s), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) == s);
+		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) != s);
+		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   return octave_value (v1.matrix_value () * v2.complex_value ());
@@ -189,27 +189,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) && s != 0.0);
+		 m (i, j) && s != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 Complex, s, v2.complex_value (), \
-		 m (i, j) || s != 0.0);
+		 m (i, j) || s != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-m.cc b/src/op-m-m.cc
--- a/src/op-m-m.cc
+++ b/src/op-m-m.cc
@@ -91,49 +91,49 @@ ldiv (const octave_value& a1, const octa
 		 Matrix, m2, v2.matrix_value (), \
 		 m1 (i, j) OP m2 (i, j), #OP, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, 0.0);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, 0.0);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   BOOL_OP (==, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, 0.0);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, 0.0);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   BOOL_OP (!=, 0.0);
@@ -173,27 +173,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) && m2 (i, j), "&", 0.0);
+		 m1 (i, j) && m2 (i, j), "&", Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) || m2 (i, j), "|", 0.0);
+		 m1 (i, j) || m2 (i, j), "|", Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_matrix&);
 
diff --git a/src/op-m-s.cc b/src/op-m-s.cc
--- a/src/op-m-s.cc
+++ b/src/op-m-s.cc
@@ -87,67 +87,67 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
 		 double, s, v2.double_value (), \
-		 m (i, j) OP s)
+		 m (i, j) OP s, EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (==);
+  BOOL_OP (==, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (!=);
+  BOOL_OP (!=, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   return octave_value (v1.matrix_value () * v2.double_value ());
@@ -184,27 +184,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
                  double, s, v2.double_value (), \
-		 m (i, j) && s);
+		 m (i, j) && s, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
                  double, s, v2.double_value (), \
-		 m (i, j) || s);
+		 m (i, j) || s, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_scalar&);
 
diff --git a/src/op-s-cm.cc b/src/op-s-cm.cc
--- a/src/op-s-cm.cc
+++ b/src/op-s-cm.cc
@@ -87,71 +87,71 @@ ldiv (const octave_value& a1, const octa
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s OP real (m (i, j)))
+		 s OP real (m (i, j)), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s == m (i, j));
+		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s != m (i, j));
+		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   return octave_value (v1.double_value () * v2.complex_matrix_value ());
@@ -188,27 +188,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s && m (i, j) != 0.0);
+		 s && m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s || m (i, j) != 0.0);
+		 s || m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-s-m.cc b/src/op-s-m.cc
--- a/src/op-s-m.cc
+++ b/src/op-s-m.cc
@@ -87,67 +87,67 @@ ldiv (const octave_value& a1, const octa
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-#define BOOL_OP(OP) \
+#define BOOL_OP(OP, EMPTY_RESULT) \
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
 		 Matrix, m, v2.matrix_value (), \
-		 s OP m (i, j))
+		 s OP m (i, j), EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<);
+  BOOL_OP (<, Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<=);
+  BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (==);
+  BOOL_OP (==, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>=);
+  BOOL_OP (>=, Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>);
+  BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (!=);
+  BOOL_OP (!=, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   return octave_value (v1.double_value () * v2.matrix_value ());
@@ -184,27 +184,27 @@ el_ldiv (const octave_value& a1, const o
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
                  Matrix, m, v2.matrix_value (), \
-		 s && m (i, j));
+		 s && m (i, j), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   SC_MX_BOOL_OP (double, s, v1.double_value (), \
                  Matrix, m, v2.matrix_value (), \
-		 s || m (i, j));
+		 s || m (i, j), Matrix ());
 }
 
 static octave_value *
 matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
diff --git a/src/op-str-str.cc b/src/op-str-str.cc
--- a/src/op-str-str.cc
+++ b/src/op-str-str.cc
@@ -47,29 +47,29 @@ eq (const octave_value& a1, const octave
 
   if (cm1.rows () == 1 && cm1.columns () == 1)
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
 	return octave_value (cm1 (0, 0) == cm2 (0, 0));
       else
 	SC_MX_BOOL_OP (char, c, cm1 (0, 0), \
 		       charMatrix, m, cm2, \
-		       c == m (i, j));
+		       c == m (i, j), 0.0);
     }
   else
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
 	MX_SC_BOOL_OP (charMatrix, m, cm1, \
 		       char, c, cm2 (0, 0), \
-		       c == m (i, j));
+		       c == m (i, j), 0.0);
       else
 	MX_MX_BOOL_OP (charMatrix, m1, cm1, \
 		       charMatrix, m2, cm2, \
 		       m1 (i, j) == m2 (i, j), \
-		       "==", 1.0);
+		       "==", 0.0);
     }
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_char_matrix_str&,
 		   const octave_char_matrix_str&);
@@ -79,24 +79,24 @@ ne (const octave_value& a1, const octave
 
   if (cm1.rows () == 1 && cm1.columns () == 1)
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
 	return octave_value (cm1 (0, 0) != cm2 (0, 0));
       else
 	SC_MX_BOOL_OP (char, c, cm1 (0, 0), \
 		       charMatrix, m, cm2, \
-		       c != m (i, j));
+		       c != m (i, j), 1.0);
     }
   else
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
 	MX_SC_BOOL_OP (charMatrix, m, cm1, \
 		       char, c, cm2 (0, 0), \
-		       c != m (i, j));
+		       c != m (i, j), 1.0);
       else
 	MX_MX_BOOL_OP (charMatrix, m1, cm1, \
 		       charMatrix, m2, cm2, \
 		       m1 (i, j) != m2 (i, j), \
 		       "!=", 1.0);
     }
 }
 
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -55,43 +55,47 @@ extern void install_ops (void);
 
 #define BOOL_OP3(test) \
   Matrix retval (nr, nc); \
   for (int j = 0; j < nc; j++) \
     for (int i = 0; i < nr; i++) \
       retval (i, j) = test; \
   return retval;
 
-#define SC_MX_BOOL_OP(st, sn, get_s, mt, mn, get_m, test) \
+#define SC_MX_BOOL_OP(st, sn, get_s, mt, mn, get_m, test, empty_result) \
   do \
     { \
       BOOL_OP1 (st, sn, get_s, mt, mn, get_m) \
       BOOL_OP2 (mn) \
+      if (nr == 0|| nc == 0) \
+        return empty_result; \
       BOOL_OP3 (test) \
     } \
   while (0)
 
-#define MX_SC_BOOL_OP(mt, mn, get_m, st, sn, get_s, test) \
+#define MX_SC_BOOL_OP(mt, mn, get_m, st, sn, get_s, test, empty_result) \
   do \
     { \
       BOOL_OP1 (mt, mn, get_m, st, sn, get_s) \
       BOOL_OP2 (mn) \
+      if (nr == 0|| nc == 0) \
+        return empty_result; \
       BOOL_OP3 (test) \
     } \
   while (0)
 
 #define MX_MX_BOOL_OP(m1t, m1n, get_m1, m2t, m2n, get_m2, test, op, \
 		      empty_result) \
   do \
     { \
       BOOL_OP1 (m1t, m1n, get_m1, m2t, m2n, get_m2) \
-      int m1_nr = m1.rows (); \
-      int m1_nc = m1.cols (); \
-      int m2_nr = m2.rows (); \
-      int m2_nc = m2.cols (); \
+      int m1_nr = m1n.rows (); \
+      int m1_nc = m1n.cols (); \
+      int m2_nr = m2n.rows (); \
+      int m2_nc = m2n.cols (); \
       if (m1_nr != m2_nr || m1_nc != m2_nc) \
 	{ \
 	  gripe_nonconformant ("operator " op, m1_nr, m1_nc, m2_nr, m2_nc); \
 	  return Matrix (); \
 	} \
       if (m1_nr == 0 || m1_nc == 0) \
 	return empty_result; \
       BOOL_OP2 (m1n) \
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1475,17 +1475,17 @@ octave_print_internal (ostream& os, cons
 	    }
 	}
     }
 }
 
 void
 octave_print_internal (ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax, bool pr_as_string,
-		       int extra_indent)
+		       int /* extra_indent XXX FIXME XXX */)
 {
   if (pr_as_string)
     {
       int nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -310,16 +310,24 @@ tree_function::eval (bool /* print */, i
 
   if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
 	goto abort;
     }
 
+  if (ret_list && Vdefine_all_return_values)
+    {
+      octave_value tmp = builtin_any_variable ("default_return_value");
+
+      if (tmp.is_defined ())
+	ret_list->initialize_undefined_elements (tmp);
+    }
+
   // The following code is in a separate scope to avoid warnings from
   // G++ about `goto abort' crossing the initialization of some
   // variables.
 
   {
     bind_nargin_and_nargout (nargin, nargout);
 
     bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
@@ -345,26 +353,17 @@ tree_function::eval (bool /* print */, i
       {
 	traceback_error ();
 	goto abort;
       }
     
     // Copy return values out.
 
     if (ret_list)
-      {
-	if (nargout > 0 && Vdefine_all_return_values)
-	  {
-	    octave_value tmp = builtin_any_variable ("default_return_value");
-	    if (tmp.is_defined ())
-	      ret_list->initialize_undefined_elements (tmp);
-	  }
-
-	retval = ret_list->convert_to_const_vector (vr_list);
-      }
+      retval = ret_list->convert_to_const_vector (vr_list);
     else if (Vreturn_last_computed_value)
       retval(0) = last_computed_value;
   }
 
  abort:
   run_unwind_frame ("func_eval");
 
   return retval;
