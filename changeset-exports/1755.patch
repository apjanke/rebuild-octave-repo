# HG changeset patch
# User jwe
# Date 822286042 0
#      Mon Jan 22 04:47:22 1996 +0000
# Node ID 3a9462b655f175364261d27d5ce2a4029ad589a2
# Parent  5f1938919fdccd78ebb54f3a00d1002e50b33626
[project @ 1996-01-22 04:47:22 by jwe]

diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -89,19 +89,20 @@ INCLUDES := arith-ops.h builtins.h defau
 	pathsearch.h pr-output.h procstream.h pt-base.h pt-cmd.h \
 	pt-const.h pt-exp-base.h pt-exp.h pt-fcn.h pt-fvc-base.h \
 	pt-fvc.h pt-mat.h pt-misc.h pt-mvr-base.h pt-mvr.h pt-plot.h \
 	sighandlers.h statdefs.h symtab.h sysdep.h sysdir.h systime.h \
 	syswait.h token.h toplev.h unwind-prot.h user-prefs.h utils.h \
 	variables.h version.h xdiv.h xpow.h Map.h SLStack.h Stack.h
 
 TI_SRC := Array-tc.cc Map-tc.cc DLList-fi.cc \
-	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-tc.cc \
-	SLStack-i.cc SLStack-pc.cc SLStack-str.cc SLStack-sym.cc \
-	SLStack-tok.cc SLStack-tm.cc SLStack-ue.cc SLStack-ui.cc
+	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-str.cc \
+	SLList-tc.cc SLStack-i.cc SLStack-pc.cc SLStack-str.cc \
+	SLStack-sym.cc SLStack-tok.cc SLStack-tm.cc SLStack-ue.cc \
+	SLStack-ui.cc
 
 TI_OBJ := $(patsubst %.cc, %.o, $(TI_SRC))
 
 TI_PICOBJ := $(TI_OBJ)
 ifdef CXXPICFLAG
   TI_PICOBJ := $(addprefix pic/, $(TI_OBJ))
 endif
 
diff --git a/src/Map.cc b/src/Map.cc
--- a/src/Map.cc
+++ b/src/Map.cc
@@ -38,31 +38,31 @@ License as published by the Free Softwar
 #include <config.h>
 #endif
 
 #include <iostream.h>
 
 #include "Map.h"
 
 static unsigned int
-hash (const char *str)
+hash (const string& str)
 {
   unsigned h = 0;
-  while (*str)
-    h = h * 33 + *str++;
+  for (unsigned i = 0; i < str.length (); i++)
+    h = h * 33 + str[i];
   return h;
 }
 
 template <class C>
 Pix
-Map<C>::seek (const char *item) const
+Map<C>::seek (const string& item) const
 {
   Pix i = 0;
 
-  for (i = first (); i != 0 && strcmp (key (i), item) != 0; next (i))
+  for (i = first (); i != 0 && key (i) != item; next (i))
     ; // Skip items until match found.
 
   return i;
 }
 
 template <class C>
 int
 Map<C>::owns (Pix idx) const
@@ -86,24 +86,24 @@ Map<C>::clear (void)
     {
       del (key (i));
       i = first ();
     }
 }
 
 template <class C>
 int
-Map<C>::contains (const char *item) const
+Map<C>::contains (const string& item) const
 {
   return seek (item) != 0;
 }
 
 template <class C>
 void
-Map<C>::error (const char* msg) const
+Map<C>::error (const string& msg) const
 {
   cerr << "Map: " << msg << "\n";
 }
 
 // CHMap class.
 
 // The nodes are linked together serially via a version of a trick
 // used in some vtables: odd pointers are actually links to the next
@@ -148,55 +148,55 @@ CHMap<C>::CHMap (const CHMap& a) : Map<C
     tab[i] = (CHNode<C> *) index_to_CHptr (i+1);
   count = 0;
   for (Pix p = a.first (); p; a.next (p))
     (*this) [a.key (p)] = a.contents (p);
 }
 
 template <class C>
 Pix
-CHMap<C>::seek (const char *key) const
+CHMap<C>::seek (const string& key) const
 {
   unsigned int h = hash (key) % size;
 
   for (CHNode<C> *t = tab[h]; goodCHptr (t); t = t->tl)
-    if (strcmp (key, t->hd) == 0)
+    if (key == t->hd)
       return Pix (t);
 
   return 0;
 }
 
 template <class C>
 C&
-CHMap<C>::operator [] (const char *item)
+CHMap<C>::operator [] (const string& item)
 {
   unsigned int h = hash (item) % size;
 
   CHNode<C> *t = 0;
   for (t = tab[h]; goodCHptr (t); t = t->tl)
-    if (strcmp (item, t->hd) == 0)
+    if (item == t->hd)
       return t->cont;
 
   t = new CHNode<C> (item, def, tab[h]);
   tab[h] = t;
   ++count;
   return t->cont;
 }
 
 template <class C>
 void
-CHMap<C>::del (const char *key)
+CHMap<C>::del (const string& key)
 {
   unsigned int h = hash (key) % size;
 
   CHNode<C> *t = tab[h];
   CHNode<C> *trail = t;
   while (goodCHptr (t))
     {
-      if (strcmp (key, t->hd) == 0)
+      if (key == t->hd)
 	{
 	  if (trail == t)
 	    tab[h] = t->tl;
 	  else
 	    trail->tl = t->tl;
 	  delete t;
 	  --count;
 	  return;
diff --git a/src/Map.h b/src/Map.h
--- a/src/Map.h
+++ b/src/Map.h
@@ -32,17 +32,17 @@ of Map and CHMap from libg++, originally
 and distributed under the terms of the GNU Library General Public
 License as published by the Free Software Foundation.
 
 */
 
 #if ! defined (octave_Map_h)
 #define octave_Map_h 1
 
-#include <cstring>
+#include <string>
 
 #include <Pix.h>
 
 template <class C>
 class Map
 {
 protected:
   int count;
@@ -51,56 +51,52 @@ protected:
 public:
   Map (const C& dflt) : def (dflt) { count = 0; }
 
   virtual ~Map (void) { }
 
   int length (void) const { return count; }	// current number of items
   int empty (void) const { return count == 0; }
 
-  virtual int contains (const char *key) const;	// is key mapped?
+  virtual int contains (const string& key) const;  // is key mapped?
 
   virtual void clear (void);			// delete all items
 	      
-  virtual C& operator [] (const char *key) = 0;	// access contents by key
+  virtual C& operator [] (const string& key) = 0;  // access contents by key
 	      
-  virtual void del (const char *key) = 0;	// delete entry
+  virtual void del (const string& key) = 0;	// delete entry
 	      
   virtual Pix first (void) const = 0;		// Pix of first item or 0
   virtual void next (Pix& i) const = 0;		// advance to next or 0
-  virtual const char *key (Pix i) const = 0;	// access key at i
+  virtual string key (Pix i) const = 0;		// access key at i
   virtual C& contents (Pix i) const = 0;	// access contents at i
 
   virtual int owns (Pix i) const;		// is i a valid Pix  ?
-  virtual Pix seek (const char *key) const;	// Pix of key
+  virtual Pix seek (const string& key) const;	// Pix of key
 
   C& dflt (void) { return def; }		// access default val
 
-  void  error (const char* msg) const;
+  void error (const string& msg) const;
 
   virtual int OK (void) const = 0;		// rep invariant
 };
 
 template <class C>
 struct CHNode
 {
   CHNode *tl;
-  char *hd;
+  string hd;
   C cont;
 
-  CHNode (void) : tl (0), hd (0) { }
+  CHNode (void) : tl (0), hd (), cont () { }
 
-  CHNode (const char *h, const C& c, CHNode *t = 0) : tl (t), cont (c)
-    {
-      hd = h ? strcpy (new char [strlen (h) + 1], h) : 0;
-    }
+  CHNode (const string& h, const C& c, CHNode *t = 0)
+    : tl (t), hd (h), cont (c) { }
 
-
-  ~CHNode (void)
-    { delete [] hd; }
+  ~CHNode (void) { }
 };
 
 #ifndef DEFAULT_INITIAL_CAPACITY
 #define DEFAULT_INITIAL_CAPACITY 8
 #endif
 
 template <class C>
 class CHMap : public Map<C>
@@ -115,42 +111,42 @@ public:
   CHMap (const CHMap& a);
 
   ~CHMap (void)
     {
       clear ();
       delete tab;
     }
 
-  C& operator [] (const char *key);
+  C& operator [] (const string& key);
 
-  void del (const char *key);
+  void del (const string& key);
 
   Pix first (void) const;
   void next (Pix& i) const;
 
-  const char *key (Pix p) const
+  string key (Pix p) const
     {
       if (p == 0)
 	error ("null Pix");
 
       return ((CHNode<C> *) p)->hd;
     }
 
   C& contents (Pix p) const
     {
       if (p == 0)
 	error ("null Pix");
 
      return ((CHNode<C> *) p)->cont;
    }
 
-  Pix seek (const char *key) const;
+  Pix seek (const string& key) const;
 
-  int contains (const char *key) const
+  int contains (const string& key) const
     {
       return seek (key) != 0;
     }
 
   void clear (void);
   int  OK (void) const;
 };
 
diff --git a/src/SLStack-str.cc b/src/SLStack-str.cc
--- a/src/SLStack-str.cc
+++ b/src/SLStack-str.cc
@@ -23,18 +23,20 @@ Software Foundation, 59 Temple Place - S
 
 // Instantiate Stacks of string values.
 
 #include "SLStack.h"
 #include "SLStack.cc"
 
 #include <string>
 
-template class SLNode<string>;
-template class SLList<string>;
+// We already have SLList<string>, so we don't need to make them here.
+
+// template class SLNode<string>;
+// template class SLList<string>;
 template class Stack<string>;
 template class SLStack<string>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -82,38 +82,37 @@ DEFUN_DLD_BUILTIN ("colloc", Fcolloc, Sc
       if (args(i).is_defined ())
 	{
 	  if (! args(i).is_string ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
 
-	  string tstr = args(i).string_value ();
-	  const char *s = tstr.c_str ();
+	  string s = args(i).string_value ();
 
-	  if (s && (((*s == 'R' || *s == 'r') && strlen (s) == 1)
-		    || strcmp (s, "right") == 0))
+	  if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
+	      || s == "right")
 	    {
 	      right = 1;
 	    }
-	  else if (s && (((*s == 'L' || *s == 'l') && strlen (s) == 1)
-			 || strcmp (s, "left") == 0))
+	  else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
+		   || s == "left")
 	    {
 	      left = 1;
 	    }
 	  else
 	    {
 	      error ("colloc: unrecognized argument");
 	      return retval;
 	    }
 	}
       else
 	{
-	  error ("colloc: unexpected NULL argument");
+	  error ("colloc: unexpected empty argument");
 	  return retval;
 	}
     }
 
   ntot += left + right;
   if (ntot < 1)
     {
       error ("colloc: the total number of roots must be positive");
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -271,53 +271,53 @@ print_dassl_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_dassl_option (const char *keyword, double val)
+set_dassl_option (const string& keyword, double val)
 {
   DAE_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (dassl_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
-  warning ("dassl_options: no match for `%s'", keyword);
+  warning ("dassl_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_dassl_option (const char *keyword)
+show_dassl_option (const string& keyword)
 {
   Octave_object retval;
 
   DAE_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  return (dassl_opts.*list->d_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("dassl_options: no match for `%s'", keyword);
+  warning ("dassl_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("dassl_options", Fdassl_options, Sdassl_options,
 		   FSdassl_options, 10,
   "dassl_options (KEYWORD, VALUE)\n\
 \n\
@@ -330,18 +330,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_dassl_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_dassl_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -30,16 +30,18 @@ Software Foundation, Inc.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-map.h"
 #include "pt-const.h"
 #include "oct-obj.h"
 #include "user-prefs.h"
@@ -753,41 +755,17 @@ Return a list of the names of the elemen
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args (0).is_map ())
 	{
 	  Octave_map m = args(0).map_value ();
-	  char **names = m.make_name_list ();
-
-	  char **ptr = names;
-	  int max_len = 0;
-	  while (*ptr)
-	    {
-	      int len = strlen (*ptr);
-	      if (len > max_len)
-		max_len = len;
-	      ptr++;
-	    }
-
-	  charMatrix list (m.length (), max_len);
-
-	  ptr = names;
-	  int i = 0;
-	  while (*ptr)
-	    {
-	      list.insert (*ptr, i++, 0);
-	      delete [] *ptr++;
-	    }
-
-	  delete [] names;
-
-	  retval(0) = list;
+	  retval(0) = m.make_name_list ();
 	}
       else
 	gripe_wrong_type_arg ("struct_elements", args (0));
     }
   else
     print_usage ("struct_elements");
 
   return retval;
@@ -802,18 +780,17 @@ return nonzero if S is a structure with 
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = 0.0;
       if (args(0).is_map () && args(1).is_string ())
 	{
-	  string tstr = args(1).string_value ();
-	  const char *s = tstr.c_str ();
+	  string s = args(1).string_value ();
 	  tree_constant tmp = args(0).lookup_map_element (s, 0, 1);
 	  retval = (double) tmp.is_defined ();
 	}
     }
   else
     print_usage ("struct_contains");
 
   return retval;
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
 // DEFUN_TEXT, or DEFUN_DLD.
 
 #define DEFUN_INTERNAL(name, fname, sname, unused_arg_flags, \
 		       is_text_fcn, doc) \
   BEGIN_INSTALL_BUILTIN \
     extern DECLARE_FUN_ ## unused_arg_flags (fname); \
     DEFINE_FUN_STRUCT (name, fname, sname, is_text_fcn, doc); \
-    install_builtin_function (&sname); \
+    install_builtin_function (sname); \
   END_INSTALL_BUILTIN
 
 // Generate code for making another name for an existing function.
 
 #define DEFALIAS_INTERNAL(alias, name) \
   BEGIN_INSTALL_BUILTIN \
   alias_builtin (#alias, #name); \
   END_INSTALL_BUILTIN
@@ -63,24 +63,23 @@ Software Foundation, 59 Temple Place - S
 #define DEFALIAS_INTERNAL(name, alias)
 
 #endif /* ! MAKE_BUILTINS */
 
 // Define the structure that will be used to insert this function into
 // the symbol table.
 
 #define DEFINE_FUN_STRUCT(name, fname, sname, is_text_fcn, doc) \
-  static builtin_function sname = \
-    { name, is_text_fcn, fname, doc }
+  static builtin_function sname (name, is_text_fcn, fname, doc)
 
 #define DEFINE_FUN_STRUCT_FUN(sname, fsname) \
-  builtin_function * \
+  builtin_function& \
   fsname (void) \
   { \
-    return &sname; \
+    return sname; \
   }
 
 // Declare an internal function named fname.  This is the interface
 // used by all internal functions in Octave that are also callable
 // from the Octave language.  The funny suffixes are used to help us
 // avoid warnings from g++ about unused arguments.
 
 #define DECLARE_FUN_00(fname) \
@@ -92,36 +91,16 @@ Software Foundation, 59 Temple Place - S
 #define DECLARE_FUN_10(fname) \
   Octave_object fname (const Octave_object& args, int)
 
 #define DECLARE_FUN_11(fname) \
   Octave_object fname (const Octave_object& args, int nargout)
 
 #define DECLARE_FUN_(fname) DECLARE_FUN_11 (fname)
 
-// XXX FIXME XXX -- eliminate the need for these in the functions that
-// use them?
-
-#define DEFINE_ARGV(fcn_name) \
-  int argc = args.length () + 1; \
-  int save_argc = argc; \
-  char **argv = make_argv (args, fcn_name); \
-  char **save_argv = argv; \
-  if (error_state) \
-    return retval
-
-#define DELETE_ARGV \
-  do \
-    { \
-      while (--save_argc >= 0) \
-	delete [] save_argv[save_argc]; \
-      delete [] save_argv; \
-    } \
-  while (0)
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -58,27 +58,20 @@ Software Foundation, 59 Temple Place - S
 //     function to call.  See also the code in user-prefs.cc.
 //
 //   doc is the simple help text for this variable.
 
 #define DEFVAR_INT(name, sname, defn, inst_as_fcn, protect, \
 		   sv_fcn, doc) \
   do \
     { \
-      builtin_variable sname = \
-	{ \
-	  name, \
-	  new tree_constant (defn), \
-	  inst_as_fcn, \
-	  protect, \
-	  (sv_fcn ? 1 : 0), \
-	  sv_fcn, \
-	  doc, \
-	}; \
-      install_builtin_variable (&sname); \
+      builtin_variable sname (name, new tree_constant (defn), \
+			      inst_as_fcn, protect, (sv_fcn ? 1 : 0), \
+			      sv_fcn, doc); \
+      install_builtin_variable (sname); \
     } \
   while (0)
 
 #define DEFVAR(name, sname, defn, inst_as_fcn, sv_fcn, doc) \
   DEFVAR_INT (name, sname, defn, inst_as_fcn, 0, sv_fcn, doc)
 
 // Define a builtin-constant, and a corresponding variable that can be
 // redefined.  This is just the same as DEFVAR, except that it defines
@@ -155,28 +148,20 @@ Software Foundation, 59 Temple Place - S
 //     complex arguments that are expected to create complex results.
 //
 //   doc is the simple help text for the function.
 
 #define DEFUN_MAPPER(name, sname, can_ret_cmplx_for_real, lo, hi, \
 		     d_d_map, d_c_map, c_c_map, doc) \
   do \
     { \
-      builtin_mapper_function sname = \
-	{ \
-	  name, \
-	  can_ret_cmplx_for_real, \
-	  lo, \
-	  hi, \
-	  d_d_map, \
-	  d_c_map, \
-	  c_c_map, \
-	  doc, \
-	}; \
-      install_builtin_mapper (&sname); \
+      builtin_mapper_function sname (name, can_ret_cmplx_for_real, \
+				     lo, hi, d_d_map, d_c_map, \
+				     c_c_map, doc); \
+      install_builtin_mapper (sname); \
     } \
   while (0)
 
 // Make alias another name for the existing function name.  This macro
 // must be used in the same file where name is defined, after the
 // definition for name.
 
 #define DEFALIAS(name, alias) DEFALIAS_INTERNAL (name, alias)
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -43,16 +43,18 @@ Free Software Foundation, Inc.
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
 
 #include <string>
 
 #include <strstream.h>
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "pathlen.h"
@@ -61,357 +63,344 @@ Free Software Foundation, Inc.
 #include "statdefs.h"
 #include "sysdep.h"
 #include "sysdir.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
-// Temp storage for a path.
-static char tdir[MAXPATHLEN];
-
 // Non-zero means follow symbolic links that point to directories just
 // as if they are real directories.
 static int follow_symbolic_links = 1;
 
 // Non-zero means that pwd always give verbatim directory, regardless
 // of symbolic link following.
 static int verbatim_pwd = 1;
 
 // Remove the last N directories from PATH.  Do not PATH blank.
 // PATH must contain enough space for MAXPATHLEN characters.
 
-void
-pathname_backup (char *path, int n)
+static void
+pathname_backup (string& path, int n)
 {
-  register char *p;
-
-  if (! *path)
+  if (path.empty ())
     return;
 
-  p = path + (strlen (path) - 1);
+  size_t i = path.length () - 1;
 
   while (n--)
     {
-      while (*p == '/' && p != path)
-	p--;
+      while (path[i] == '/' && i > 0)
+	i--;
 
-      while (*p != '/' && p != path)
-	p--;
+      while (path[i] != '/' && i > 0)
+	i--;
 
-      *++p = '\0';
+      i++;
     }
+
+  path.resize (i);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
 // same as $HOME, then replace that with `~'.
 
-char *
-polite_directory_format (char *name)
+string
+polite_directory_format (const string& name)
 {
-  int l = home_directory ? strlen (home_directory) : 0;
+  string retval;
 
-  if (l > 1 && strncmp (home_directory, name, l) == 0
-      && (! name[l] || name[l] == '/'))
+  size_t len = home_directory.length ();
+
+  if (len > 1 && home_directory.compare (name, 0, len) == 0
+      && (name.length () == len || name[len] == '/'))
     {
-      strcpy (tdir + 1, name + l);
-      tdir[0] = '~';
-      return (tdir);
+      retval = "~";
+      retval.append (name.substr (len));
     }
   else
-    return name;
+    retval = name;
+
+  return retval;
 }
 
 // Return 1 if STRING contains an absolute pathname, else 0.
 
 int
-absolute_pathname (const char *string)
+absolute_pathname (const string& s)
 {
-  if (! string || ! *string)
+  if (s.empty ())
     return 0;
 
-  if (*string == '/')
+  if (s[0] == '/')
     return 1;
 
-  if (*string++ == '.')
+  if (s[0] == '.')
     {
-      if ((! *string) || *string == '/')
+      if (s[1] == '\0' || s[1] == '/')
 	return 1;
 
-      if (*string++ == '.')
-	if (! *string || *string == '/')
+      if (s[1] == '.')
+	if (s[2] == '\0' || s[2] == '/')
 	  return 1;
     }
+
   return 0;
 }
 
 // Return 1 if STRING is an absolute program name; it is absolute if
 // it contains any slashes.  This is used to decide whether or not to
 // look up through $PATH.
 
 int
-absolute_program (const char *string)
+absolute_program (const string& s)
 {
-  return (strchr (string, '/') != 0);
+  return (s.find ('/') != NPOS);
 }
 
 // Return the `basename' of the pathname in STRING (the stuff after
 // the last '/').  If STRING is not a full pathname, simply return it.
 
-char *
-base_pathname (char *string)
+string
+base_pathname (const string& s)
 {
-  char *p = strrchr (string, '/');
+  if (! absolute_pathname (s))
+    return s;
 
-  if (! absolute_pathname (string))
-    return (string);
+  size_t pos = s.rfind ('/');
 
-  if (p)
-    return (++p);
+  if (pos == NPOS)
+    return s;
   else
-    return (string);
+    return s.substr (pos+1);
 }
 
 // Turn STRING (a pathname) into an absolute pathname, assuming that
-// DOT_PATH contains the symbolic location of '.'.  This always
-// returns a new string, even if STRING was an absolute pathname to
-// begin with.
+// DOT_PATH contains the symbolic location of '.'.
 
-char *
-make_absolute (const char *string, const char *dot_path)
+string
+make_absolute (const string& s, const string& dot_path)
 {
-  static char current_path[MAXPATHLEN];
-  register char *cp;
+  if (dot_path.empty () || s[0] == '/')
+    return s;
+
+  string current_path = dot_path;
 
-  if (! dot_path || *string == '/')
-    return strsave (string);
+  if (current_path.empty ())
+    current_path = "./";
 
-  strcpy (current_path, dot_path);
-
-  if (! current_path[0])
-    strcpy (current_path, "./");
+  size_t pos = current_path.length () - 1;
 
-  cp = current_path + (strlen (current_path) - 1);
+  if (current_path[pos] != '/')
+    current_path.append ("/");
 
-  if (*cp++ != '/')
-    *cp++ = '/';
+  size_t i = 0;
+  size_t slen = s.length ();
 
-  *cp = '\0';
-
-  while (*string)
+  while (i < slen)
     {
-      if (*string == '.')
+      if (s[i] == '.')
 	{
-	  if (! string[1])
-	    return strsave (current_path);
+	  if (i + 1 == slen)
+	    return current_path;
 
-	  if (string[1] == '/')
+	  if (s[i+1] == '/')
 	    {
-	      string += 2;
+	      i += 2;
 	      continue;
 	    }
 
-	  if (string[1] == '.' && (string[2] == '/' || ! string[2]))
+	  if (s[i+1] == '.' && (i + 2 == slen || s[i+2] == '/'))
 	    {
-	      string += 2;
+	      i += 2;
 
-	      if (*string)
-		string++;
+	      if (i != slen)
+		i++;
 
 	      pathname_backup (current_path, 1);
-	      cp = current_path + strlen (current_path);
+
 	      continue;
 	    }
 	}
 
-      while (*string && *string != '/')
-	*cp++ = *string++;
+      size_t tmp = s.find ('/', i);
 
-      if (*string)
-	*cp++ = *string++;
+      if (tmp == NPOS)
+	{
+	  current_path.append (s, i, tmp-i);
+	  break;
+	}
+      else
+	{
+	  current_path.append (s, i, tmp-i+1);
+	  i = tmp + 1;
+	}
+    }
 
-      *cp = '\0';
-    }
-  return strsave (current_path);
+  return current_path;
 }
 
 // Has file `A' been modified after time `T'?
 //
 // case:
 //
 //   a newer than t         returns    1
 //   a older than t         returns    0
 //   stat on a fails        returns   -1
 
 int
-is_newer (const char *fa, time_t t)
+is_newer (const string& fa, time_t t)
 {
   struct stat fa_sb;
   register int fa_stat;
   register int status = 0;
 
-  fa_stat = stat (fa, &fa_sb);
+  fa_stat = stat (fa.c_str (), &fa_sb);
   if (fa_stat != 0)
     status = -1;
 
   if (status != 0)
     return status;
 
   return (fa_sb.st_mtime > t);
 }
 
 // Return a consed string which is the current working directory.
 // FOR_WHOM is the name of the caller for error printing.
 
-char *
-get_working_directory (const char *for_whom)
+string
+get_working_directory (const string& for_whom)
 {
   if (! follow_symbolic_links)
-    {
-      if (the_current_working_directory)
-	delete [] the_current_working_directory;
+    the_current_working_directory = "";
 
-      the_current_working_directory = 0;
-    }
-
-  if (! the_current_working_directory)
+  if (the_current_working_directory.empty ())
     {
-      char *directory;
+      the_current_working_directory = octave_getcwd ();
 
-      the_current_working_directory = new char [MAXPATHLEN];
-      directory = octave_getcwd (the_current_working_directory, MAXPATHLEN);
-      if (! directory)
-	{
-	  message (for_whom, the_current_working_directory);
-	  delete [] the_current_working_directory;
-	  the_current_working_directory = 0;
-	  return 0;
-	}
+      if (the_current_working_directory.empty ())
+	warning ("%s: can't find current directory!", for_whom.c_str ());
     }
 
   return the_current_working_directory;
 }
 
 // Do the work of changing to the directory NEWDIR.  Handle symbolic
 // link following, etc.
 
 static int
-change_to_directory (const char *newdir)
+change_to_directory (const string& newdir)
 {
-  char *t;
+  string tmp;
 
   if (follow_symbolic_links)
     {
-      if (! the_current_working_directory)
+      if (the_current_working_directory.empty ())
 	get_working_directory ("cd_links");
 
-      if (the_current_working_directory)
-	t = make_absolute (newdir, the_current_working_directory);
+      if (the_current_working_directory.empty ())
+	tmp = newdir;
       else
-	t = strsave (newdir);
+	tmp = make_absolute (newdir, the_current_working_directory);
 
       // Get rid of trailing `/'.
 
-      {
-	register int len_t = strlen (t);
-	if (len_t > 1)
-	  {
-	    --len_t;
-	    if (t[len_t] == '/')
-	      t[len_t] = '\0';
-	  }
-      }
+      size_t len = tmp.length ();
 
-      if (octave_chdir (t) < 0)
+      if (len > 1)
 	{
-	  delete [] t;
-	  return 0;
+	  if (tmp[--len] == '/')
+	    tmp.resize (len);
 	}
 
-      if (the_current_working_directory)
-	strcpy (the_current_working_directory, t);
-
-      delete [] t;
-      return 1;
+      if (octave_chdir (tmp) < 0)
+	return 0;
+      else
+	{
+	  the_current_working_directory = tmp;
+	  return 1;
+	}
     }
   else
-    {
-      if (octave_chdir (newdir) < 0)
-	return 0;
-      else
-	return 1;
-    }
+    return (octave_chdir (newdir) < 0) ? 0 : 1;
 }
 
 static int
-octave_change_to_directory (const char *newdir)
+octave_change_to_directory (const string& newdir)
 {
   int cd_ok = change_to_directory (newdir);
 
   if (cd_ok)
     do_external_plotter_cd (newdir);
   else
-    error ("%s: %s", newdir, strerror (errno));
+    error ("%s: %s", newdir.c_str (), strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN_TEXT ("cd", Fcd, Scd, 10,
   "cd [dir]\n\
 \n\
 change current working directory\n\
 if no arguments are given, the current directory is changed to the\n\
 users home directory")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("cd");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "cd");
+
+  if (error_state)
+    return retval;
 
   if (argc > 1)
     {
       string dirname = oct_tilde_expand (argv[1]);
 
       if (dirname.length () > 0
-	  && ! octave_change_to_directory (dirname.c_str ()))
+	  && ! octave_change_to_directory (dirname))
 	{
-	  DELETE_ARGV;
 	  return retval;
 	}
     }
   else
     {
-      if (! home_directory || ! octave_change_to_directory (home_directory))
+      if (home_directory.empty ()
+	  || ! octave_change_to_directory (home_directory))
 	{
-	  DELETE_ARGV;
 	  return retval;
 	}
     }
 
-  char *directory = get_working_directory ("cd");
+  string directory = get_working_directory ("cd");
   tree_constant *dir = new tree_constant (directory);
   bind_builtin_variable ("PWD", dir, 1);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 // Get a directory listing.
 
 DEFUN_TEXT ("ls", Fls, Sls, 10,
   "ls [options]\n\
 \n\
 print a directory listing")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("ls");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "ls");
+
+  if (error_state)
+    return retval;
 
   ostrstream ls_buf;
 
   ls_buf << "ls -C ";
   for (int i = 1; i < argc; i++)
     ls_buf << oct_tilde_expand (argv[i]) << " ";
 
   ls_buf << ends;
@@ -433,46 +422,38 @@ print a directory listing")
 
       maybe_page_output (output_buf);
     }
   else
     error ("couldn't start process for ls!");
 
   run_unwind_protect ();
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFALIAS (dir, ls);
 
 DEFUN ("pwd", Fpwd, Spwd, 01,
   "pwd (): print current working directory")
 {
   Octave_object retval;
-  char *directory;
+  string directory;
 
   if (verbatim_pwd)
     {
-      char *buffer = new char [MAXPATHLEN];
-      directory = octave_getcwd (buffer, MAXPATHLEN);
+      directory = octave_getcwd ();
 
-      if (!directory)
-	{
-	  warning ("pwd: can't find working directory!");
-	  delete buffer;
-	}
+      if (directory.empty ())
+	warning ("pwd: can't find working directory!");
     }
   else
-    {
-      directory = get_working_directory ("pwd");
-    }
+    directory = get_working_directory ("pwd");
 
-  if (directory)
+  if (! directory.empty ())
     {
       if (nargout == 0)
 	{
 	  ostrstream output_buf;
 	  output_buf << directory << "\n" << ends;
 	  maybe_page_output (output_buf);
 	}
       else
@@ -490,18 +471,17 @@ named directory.  If sucessful, returns 
 is printed.")
 {
   Octave_object retval;
   charMatrix dirlist;
   int status = 0;
 
   if (args.length () == 1)
     {
-      string tstr = args(0).string_value ();
-      const char *dirname = tstr.c_str ();
+      string dirname = args(0).string_value ();
 
       if (error_state)
 	{
 	  status = -1;
 	  gripe_wrong_type_arg ("readdir", args(0));
 	}
       else
 	{
@@ -578,18 +558,17 @@ Create the directory named by NAME.  If 
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      string tstr = args(0).string_value ();
-      const char *dirname = tstr.c_str ();
+      string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("mkdir", args(0));
       else
 	{
 	  string tmp = oct_tilde_expand (dirname);
 
 	  int mkdir_retval = mkdir (tmp.c_str (), 0777);
@@ -617,18 +596,17 @@ Remove the directory named by NAME.  If 
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 1)
     {
-      string tstr = args(0).string_value ();
-      const char *dirname = tstr.c_str ();
+      string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("rmdir", args(0));
       else
 	{
 	  string tmp = oct_tilde_expand (dirname);
 
 	  int rmdir_retval = rmdir (tmp.c_str ());
@@ -656,29 +634,27 @@ Rename a file.  If successful, returns 0
 otherwise prints an error message and returns -1.")
 {
   Octave_object retval;
 
   int status = 0;
 
   if (args.length () == 2)
     {
-      string tstr1 = args(0).string_value ();
-      const char *from = tstr1.c_str ();
+      string from = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("rename", args(0));
       else
 	{
-	  string tstr2 = args(1).string_value ();
-	  const char *to = tstr2.c_str ();
+	  string to = args(1).string_value ();
 
 	  if (error_state)
 	    gripe_wrong_type_arg ("rename", args(1));
-	  else if (rename (from, to) < 0)
+	  else if (rename (from.c_str (), to.c_str ()) < 0)
 	    {
 	      status = -1;
 	      error ("%s", strerror (errno));
 	    }
 	}
     }
   else
     print_usage ("rename");
diff --git a/src/dirfns.h b/src/dirfns.h
--- a/src/dirfns.h
+++ b/src/dirfns.h
@@ -21,24 +21,25 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_dirfns_h)
 #define octave_dirfns_h 1
 
 #include <ctime>
 
-extern char *polite_directory_format (char *);
-extern int absolute_pathname (const char *);
-extern int absolute_program (const char *);
-extern char *base_pathname (char *);
-extern void pathname_backup (char *, int);
-extern char *make_absolute (const char *, const char *);
-extern int is_newer (const char *, time_t);
-extern char *get_working_directory (const char *);
+#include <string>
+
+extern string polite_directory_format (const string&);
+extern int absolute_pathname (const string&);
+extern int absolute_program (const string&);
+extern string base_pathname (const string&);
+extern string make_absolute (const string&, const string&);
+extern int is_newer (const string&, time_t);
+extern string get_working_directory (const string&);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -31,20 +31,21 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <strstream.h>
 
 extern "C"
 {
 #if defined (WITH_DL)
 #include <dlfcn.h>
+#ifndef RTLD_LAZY
+#define RTLD_LAZY 1
+#endif
 #elif defined (WITH_SHL)
 #include <dl.h>
-#elif defined (WITH_DLD)
-#include <dld/dld.h>
 #endif
 }
 
 #include "defaults.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "toplev.h"
@@ -59,296 +60,158 @@ typedef builtin_function * (*Octave_buil
 #if defined (WITH_DYNAMIC_LINKING)
 
 // XXX FIXME XXX -- need to provide some way to ensure that functions
 // that we are going to use will use the same naming convention as
 // Octave's internal functions.  It needs to be simpler than the
 // current DEFUN_DLD() macro, which assumes you know how to name the
 // function, the struct, and the helper function.
 
-static char *
-mangle_octave_builtin_name (const char *name)
+static string
+mangle_octave_builtin_name (const string& name)
 {
-  char *tmp = strconcat (name, "__FRC13Octave_objecti");
-  char *retval = strconcat ("F", tmp);
-  delete [] tmp;
+  string retval ("F");
+  retval.append (name);
+  retval.append ("__FRC13Octave_objecti");
   return retval;
 }
 
-static char *
-mangle_octave_oct_file_name (const char *name)
+static string
+mangle_octave_oct_file_name (const string& name)
 {
-  char *tmp = strconcat (name, "__Fv");
-  char *retval = strconcat ("FS", tmp);
-  delete [] tmp;
+  string retval ("FS");
+  retval.append (name);
+  retval.append ("__Fv");
   return retval;
 }
 
 #if defined (WITH_DL)
 
 static void *
-dl_resolve_octave_reference (const char *name, const char *file)
+dl_resolve_octave_reference (const string& name, const string& file)
 {
   void *retval = 0;
 
   // Dynamic linking with dlopen/dlsym doesn't require specification
   // of the libraries at runtime.  Instead, they are specified when
   // the .oct file is created.
 
-  void *handle = dlopen (file, RTLD_LAZY);
+  void *handle = dlopen (file.c_str (), RTLD_LAZY);
 
   if (handle)
     {
-      retval = dlsym (handle, name);
+      retval = dlsym (handle, name.c_str ());
 
       if (! retval)
 	{
 	  const char *errmsg = dlerror ();
 
 	  if (errmsg)
-	    error("%s: `%s'", name, errmsg);
+	    error("%s: `%s'", name.c_str (), errmsg);
 	  else
-	    error("unable to link function `%s'", name);
+	    error("unable to link function `%s'", name.c_str ());
 
 	  dlclose (handle);
 	}
     }
   else
-    error ("%s: %s `%s'", dlerror (), file, name);
+    error ("%s: %s `%s'", dlerror (), file.c_str (), name.c_str ());
 
   return retval;
 }
 
 #elif defined (WITH_SHL)
 
 static void *
-shl_resolve_octave_reference (const char *name, const char *file)
+shl_resolve_octave_reference (const string& name, const string& file)
 {
   void *retval = 0;
 
   // Dynamic linking with shl_load/shl_findsym doesn't require
   // specification of the libraries at runtime.  Instead, they are
   // specified when the .oct file is created.
 
-  void *handle = shl_load (file, BIND_DEFERRED, 0L);
+  void *handle = shl_load (file.c_str (), BIND_DEFERRED, 0L);
 
   if (handle)
     {
-      int status = shl_findsym ((shl_t *) &handle, name,
+      int status = shl_findsym ((shl_t *) &handle, name.c_str (),
 				TYPE_UNDEFINED, retval);
 
       if (status < 0)
 	{
 	  const char *errmsg = strerror (errno);
 
 	  if (errmsg)
-	    error("%s: `%s'", name, errmsg);
+	    error("%s: `%s'", name.c_str (), errmsg);
 	  else
-	    error("unable to link function `%s'", name);
+	    error("unable to link function `%s'", name.c_str ());
 
 	  retval = 0;
 	}
     }
   else
-    error ("%s: %s `%s'", strerror (errno), file, name);
+    error ("%s: %s `%s'", strerror (errno), file.c_str (), name.c_str ());
 
   return retval;
 }
 
-#elif defined (WITH_DLD)
-
-// Now that we have the code above to do dynamic linking with the
-// dlopen/dlsym interface and Linux uses elf, I doubt that this code
-// will be used very much.  Maybe it will be able to go away
-// eventually.  Consider it unsupported...
-
-// XXX FIXME XXX -- should this list be in a user-level variable,
-// with default taken from the environment?
-
-#ifndef STD_LIB_PATH
-#define STD_LIB_PATH "/lib:/usr/lib:/usr/local/lib"
-#endif
-
-#ifndef OCTAVE_LIB_PATH
-#define OCTAVE_LIB_PATH OCTAVE_LIBDIR ":" FLIB_PATH ":" CXXLIB_PATH 
-#endif
-
-static char *lib_dir_path = OCTAVE_LIB_PATH ":" STD_LIB_PATH;
-
-// This is the list of interesting libraries that Octave is linked
-// with.  Maybe it should include the readline, info, and kpathsea
-// libraries.  Would there ever be a time that they would really be
-// needed?
-
-#ifndef SYSTEM_LIB_LIST
-#define SYSTEM_LIB_LIST "libtermcap.a:libm.a" ":" CXXLIB_LIST
-#endif
-
-#ifndef OCTAVE_LIB_LIST
-#define OCTAVE_LIB_LIST "liboctdld.a:liboctave.a:libcruft.a:libdld.a"
-#endif
-
-static char *lib_list = OCTAVE_LIB_LIST ":" FLIB_LIST ":" SYSTEM_LIB_LIST;
-
-static void
-octave_dld_init (void)
-{
-  static int initialized = 0;
-
-  if (! initialized)
-    {
-      char *full_path = 0;
-
-      char *tmp = dld_find_executable (raw_prog_name);
-      if (tmp)
-	{
-	  full_path = make_absolute (tmp, the_current_working_directory);
-	  free (tmp);
-	}
-
-      if (full_path)
-	{
-	  int status = dld_init (full_path);
-
-	  if (status != 0)
-	    error ("failed to load symbols from `%s'", full_path);
-	  else
-	    initialized = 1;
-	}
-      else
-	{
-	  error ("octave_dld_init: can't find full path to `%s'",
-		 raw_prog_name);
-	}
-    }
-}
-
-static void
-octave_list_undefined_symbols (ostream& os)
-{
-  char **list = dld_list_undefined_sym ();
-
-  if (list)
-    {
-      os << "undefined symbols:\n\n";
-      for (int i = 0; i < dld_undefined_sym_count; i++)
-	os << list[i] << "\n";
-      os << "\n";
-    }
-}
-
-static void *
-dld_resolve_octave_reference (const char *name, const char *file)
-{
-  dld_create_reference (name);
-
-  if (file)
-    {
-      if (dld_link (file) != 0)
-	{
-	  error ("failed to link file `%s'", file);
-	  return 0;
-	}
-
-      if (dld_function_executable_p (name))
-	return (void *) dld_get_func (name);
-    }
-
-  // For each library, try to find it in a list of directories, then
-  // link to it.  It would have been nice to use the kpathsea
-  // functions here too, but calls to them can't be nested as they
-  // would need to be here...
-
-  char **libs = pathstring_to_vector (lib_list);
-  char **ptr = libs;
-  char *lib_list_elt;
-
-  while ((lib_list_elt = *ptr++))
-    {
-      char *lib = kpse_path_search (lib_dir_path, lib_list_elt,
-				    kpathsea_true);
-
-      if (lib && dld_link (lib) != 0)
-	{
-	  error ("failed to link library %s", lib);
-	  return 0;
-	}
-
-      if (dld_function_executable_p (name))
-	return (void *) dld_get_func (name);
-    }
-
-  // If we get here, there was a problem.
-
-  ostrstream output_buf;
-  octave_list_undefined_symbols (output_buf);
-  char *msg = output_buf.str ();
-  error (msg);
-  delete [] msg;
-
-  return 0;
-}
-
 #endif
 #endif
 
 #if defined (WITH_DYNAMIC_LINKING)
 static void *
-resolve_octave_reference (const char *name, const char *file)
+resolve_octave_reference (const string& name, const string& file)
 {
 #if defined (WITH_DL)
 
   return dl_resolve_octave_reference (name, file);
 
 #elif defined (WITH_SHL)
 
   return shl_resolve_octave_reference (name, file);
 
-#elif defined (WITH_DLD)
-
-  return dld_resolve_octave_reference (name, file);
-
 #endif
 }
 #endif
 
 Octave_builtin_fcn
 #if defined (WITH_DYNAMIC_LINKING)
-load_octave_builtin (const char *name)
+load_octave_builtin (const string& name)
 #else
-load_octave_builtin (const char *)
+load_octave_builtin (const string&)
 #endif
 {
   Octave_builtin_fcn retval = 0;
 
 #if defined (WITH_DYNAMIC_LINKING)
 
-  char *mangled_name = mangle_octave_builtin_name (name);
+  string mangled_name = mangle_octave_builtin_name (name);
 
   retval = (Octave_builtin_fcn) resolve_octave_reference (mangled_name);
 
   delete [] mangled_name;
 
 #endif
 
   return retval;
 }
 
 int
-load_octave_oct_file (const char *name)
+load_octave_oct_file (const string& name)
 {
   int retval = 0;
 
 #if defined (WITH_DYNAMIC_LINKING)
 
-  char *oct_file = oct_file_in_path (name);
+  string oct_file = oct_file_in_path (name);
 
   if (oct_file)
     {
-      char *mangled_name = mangle_octave_oct_file_name (name);
+      string mangled_name = mangle_octave_oct_file_name (name);
 
       Octave_builtin_fcn_struct_fcn f =
 	(Octave_builtin_fcn_struct_fcn) resolve_octave_reference
 	  (mangled_name, oct_file);
 
       if (f)
 	{
 	  builtin_function *s = f ();
@@ -370,21 +233,17 @@ load_octave_oct_file (const char *name)
 #endif
 
   return retval;
 }
 
 void
 init_dynamic_linker (void)
 {
-#if defined (WITH_DLD)
-
-  octave_dld_init ();
-
-#endif
+  // Nothing to do anymore...
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -23,19 +23,19 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_dynamic_ld_h)
 #define octave_dynamic_ld_h 1
 
 #include "oct-obj.h"
 
 typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
 
-extern Octave_builtin_fcn load_octave_builtin (const char *name);
+extern Octave_builtin_fcn load_octave_builtin (const string& name);
 
-extern int load_octave_oct_file (const char *name);
+extern int load_octave_oct_file (const string& name);
 
 extern void init_dynamic_linker (void);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/file-info.cc b/src/file-info.cc
--- a/src/file-info.cc
+++ b/src/file-info.cc
@@ -38,17 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include "file-info.h"
 
 file_info::file_info (void)
 {
   file_number = -1;
   file_fptr = 0;
 }
 
-file_info::file_info (int n, const char *nm, FILE *t, const char *md)
+file_info::file_info (int n, const string& nm, FILE *t, const string& md)
 {
   file_number = n;
   file_name = nm;
   file_fptr = t;
   file_mode = md;
 }
 
 file_info::file_info (const file_info& f)
diff --git a/src/file-info.h b/src/file-info.h
--- a/src/file-info.h
+++ b/src/file-info.h
@@ -32,17 +32,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <Pix.h>
 
 class
 file_info
 {
 public:
   file_info (void);
-  file_info (int num, const char *nm, FILE *t, const char *md);
+  file_info (int num, const string& nm, FILE *t, const string& md);
   file_info (const file_info& f);
 
   file_info& operator = (const file_info& f);
 
   ~file_info (void);
 
   int number (void) const;
   string name (void) const;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -112,18 +112,17 @@ return_valid_file (const tree_constant& 
 {
   if (arg.is_string ())
     {
       Pix p = file_list.first ();
       file_info file;
       int file_count = file_list.length ();
       for (int i = 0; i < file_count; i++)
 	{
-	  string tstr = arg.string_value ();
-	  const char *file_name = tstr.c_str ();
+	  string file_name = arg.string_value ();
 	  file = file_list (p);
 	  if (file.name () == file_name)
 	    return p;
 	  file_list.next (p);
 	}
     }
   else
     {
@@ -151,20 +150,20 @@ return_valid_file (const tree_constant& 
       else
 	error ("inapproriate file specifier");
     }
 
   return 0;
 }
 
 static Pix 
-fopen_file_for_user (const char *name, const char *mode,
+fopen_file_for_user (const string& name, const char *mode,
 		     const char *warn_for)
 {
-  FILE *file_ptr = fopen (name, mode);
+  FILE *file_ptr = fopen (name.c_str (), mode);
   if (file_ptr)
     { 
       int file_number = get_next_avail_file_num ();
 
       file_info file (file_number, name, file_ptr, mode);
       file_list.append (file);
       
       Pix p = file_list.first ();
@@ -174,48 +173,47 @@ fopen_file_for_user (const char *name, c
 	{
 	  file_from_list = file_list (p);
 	  if (file_from_list.name () == name)
 	    return p;
 	  file_list.next (p);
 	}
     }
 
-  error ("%s: unable to open file `%s'", warn_for, name);
+  error ("%s: unable to open file `%s'", warn_for, name.c_str ());
 
   return 0;
 }
 
 static Pix
 file_io_get_file (const tree_constant& arg, const char *mode,
 		  const char *warn_for)
 {
   Pix p = return_valid_file (arg);
 
   if (! p)
     {
       if (arg.is_string ())
 	{
-	  string tstr = arg.string_value ();
-	  const char *name = tstr.c_str ();
+	  string name = arg.string_value ();
 
 	  struct stat buffer;
-	  int status = stat (name, &buffer);
+	  int status = stat (name.c_str (), &buffer);
 
 	  if (status == 0)
 	    {
 	      if ((buffer.st_mode & S_IFREG) == S_IFREG)
 		p = fopen_file_for_user (name, mode, warn_for);
 	      else
 		error ("%s: invalid file type", warn_for);
 	    }
 	  else if (status < 0 && *mode != 'r')
 	    p = fopen_file_for_user (name, mode, warn_for);
 	  else
-	    error ("%s: can't stat file `%s'", warn_for, name);
+	    error ("%s: can't stat file `%s'", warn_for, name.c_str ());
 	}
       else
 	error ("%s: invalid file specifier", warn_for);
     }
 
   return p;
 }
 
@@ -314,26 +312,23 @@ DEFUN ("fflush", Ffflush, Sfflush, 10,
     print_usage ("fflush");
   else
     retval = fflush_internal (args);
 
   return retval;
 }
 
 static int
-valid_mode (const char *mode)
+valid_mode (const string& mode)
 {
-  if (mode)
+  if (! mode.empty ())
     {
       char m = mode[0];
       if (m == 'r' || m == 'w' || m == 'a')
-	{
-	  m = mode[1];
-	  return (m == '\0' || (m == '+' && mode[2] == '\0'));
-	}
+	return (mode.length () == 2) ? mode[1] == '+' : 1;
     }
   return 0;
 }
 
 static Octave_object
 fgets_internal (const Octave_object& args, int nargin, int nargout,
 		int strip_final_newline = 0)
 {
@@ -480,39 +475,38 @@ fopen_internal (const Octave_object& arg
     }
 
   if (! args(1).is_string ())
     {
       error ("fopen: file mode must be a string");
       return retval;
     }
 
-  string tstr1 = args(0).string_value ();
-  const char *name = tstr1.c_str ();
-  string tstr2 = args(1).string_value ();
-  const char *mode = tstr2.c_str ();
+  string name = args(0).string_value ();
+  string mode = args(1).string_value ();
 
   if (! valid_mode (mode))
     {
       error ("fopen: invalid mode");
       return retval;
     }
 
   struct stat buffer;
-  if (stat (name, &buffer) == 0 && (buffer.st_mode & S_IFDIR) == S_IFDIR)
+  if (stat (name.c_str (), &buffer) == 0
+      && (buffer.st_mode & S_IFDIR) == S_IFDIR)
     {
       error ("fopen: can't open directory");
       return retval;
     }
 
-  FILE *file_ptr = fopen (name, mode);
+  FILE *file_ptr = fopen (name.c_str (), mode.c_str ());
 
   if (! file_ptr)
     {
-      error ("fopen: unable to open file `%s'", name);
+      error ("fopen: unable to open file `%s'", name.c_str ());
       return retval;
     }
 
   int file_number = get_next_avail_file_num ();
 
   file_info file (file_number, name, file_ptr, mode);
   file_list.append (file);
 
@@ -936,45 +930,43 @@ process_printf_format (const char *s, co
 	    sb.form (tmp_fmt, val);
 	    delete [] tmp_fmt;
 	    return chars_from_fmt_str;
 	  }
       }
 
     case 's':
       {
-	string tstr = args(fmt_arg_count++).string_value ();
-	const char *val = tstr.c_str ();
+	string val = args(fmt_arg_count++).string_value ();
 
 	if (error_state)
 	  goto invalid_conversion;
 	else
 	  {
 	    chars_from_fmt_str++;
 	    fmt << *s << ends;
 	    char *tmp_fmt = fmt.str ();
-	    sb.form (tmp_fmt, val);
+	    sb.form (tmp_fmt, val.c_str ());
 	    delete [] tmp_fmt;
 	    return chars_from_fmt_str;
 	  }
       }
 
     case 'c':
       {
-	string tstr = args(fmt_arg_count++).string_value ();
-	const char *val = tstr.c_str ();
-
-	if (error_state || strlen (val) != 1)
+	string val = args(fmt_arg_count++).string_value ();
+
+	if (error_state || val.length () != 1)
 	  goto invalid_conversion;
 	else
 	  {
 	    chars_from_fmt_str++;
 	    fmt << *s << ends;
 	    char *tmp_fmt = fmt.str ();
-	    sb.form (tmp_fmt, *val);
+	    sb.form (tmp_fmt, val[0]);
 	    delete [] tmp_fmt;
 	    return chars_from_fmt_str;
 	  }
       }
 
     default:
       goto invalid_format;
    }
@@ -1315,17 +1307,17 @@ process_scanf_format (const char *s, ost
 // Formatted reading from a file.
 
 static Octave_object
 do_scanf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
   const char *scanf_fmt = 0;
   string scanf_fmt_str;
-  char *tmp_file = 0;
+  string tmp_file;
   int tmp_file_open = 0;
   FILE *fptr = 0;
   file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
@@ -1389,24 +1381,24 @@ do_scanf (const char *type, const Octave
       else
 	{
 	  xstring_str = args(0).string_value ();
 	  xstring = xstring_str.c_str ();
 	}
 
       tmp_file = octave_tmp_file_name ();
 
-      fptr = fopen (tmp_file, "w+");
+      fptr = fopen (tmp_file.c_str (), "w+");
       if (! fptr)
 	{
 	  error ("%s: error opening temporary file", type);
 	  return retval;
 	}
       tmp_file_open = 1;
-      unlink (tmp_file);
+      unlink (tmp_file.c_str ());
 
       if (! xstring)
 	{
 	  error ("%s: no string to scan", type); 
 	  return retval;
 	}
 
       int success = fputs (xstring, fptr);
@@ -1903,17 +1895,17 @@ ferror_internal (const Octave_object& ar
 
   file_info file = file_list (p);
 
   int ierr = ferror (file.fptr ());
 
   if (nargout > 1)
     retval(1) = (double) ierr;
 
-  retval(0) = strsave (strerror (ierr));
+  retval(0) = strerror (ierr);
 
   return retval;
 }
 
 DEFUN ("ferror", Fferror, Sferror, 11,
   "ERROR = ferror (FILENAME or FILENUM)\n\
 \n\
  Returns a non zero value for an error condition on the\n\
@@ -1954,39 +1946,38 @@ popen_internal (const Octave_object& arg
     }
 
   if (! args(1).is_string ())
     {
       error ("popen: file mode must be a string");
       return retval;
     }
 
-  string tstr1 = args(0).string_value ();
-  const char *name = tstr1.c_str ();
-  string tstr2 = args(1).string_value ();
-  const char *mode = tstr2.c_str ();
-
-  if (mode[1] || (mode[0] != 'w' && mode[0] != 'r'))
+  string name = args(0).string_value ();
+  string mode = args(1).string_value ();
+
+  if (mode.length () > 1 || (mode[0] != 'w' && mode[0] != 'r'))
     {
       error ("popen: invalid mode, must be either \"r\" or \"w\".");
       return retval;
     }
 
   struct stat buffer;
-  if (stat (name, &buffer) == 0 && (buffer.st_mode & S_IFDIR) == S_IFDIR)
+  if (stat (name.c_str (), &buffer) == 0
+      && (buffer.st_mode & S_IFDIR) == S_IFDIR)
     {
       error ("popen: can't open directory");
       return retval;
     }
 
-  FILE *file_ptr = popen (name, mode);
+  FILE *file_ptr = popen (name.c_str (), mode.c_str ());
 
   if (! file_ptr)
     {
-      error ("popen: unable to start process `%s'", name);
+      error ("popen: unable to start process `%s'", name.c_str ());
       return retval;
     }
 
   int number = get_next_avail_file_num ();
 
   file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
@@ -2079,18 +2070,17 @@ execute_internal (const Octave_object& a
   int new_stdout;
 
   if (! args(0).is_string ())
     {
       error ("execute: file name must be a string");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
+  string name = args(0).string_value ();
 
   if (pipe (stdin_pipe) || pipe (stdout_pipe)) 
     {
       error ("execute: pipe creation failed");
       return retval;
     }
 
   pid = fork ();
@@ -2107,18 +2097,18 @@ execute_internal (const Octave_object& a
       close (stdout_pipe[0]);
 
       dup2 (stdin_pipe[0], STDIN_FILENO);
       close (stdin_pipe[0]);
     
       dup2 (stdout_pipe[1], STDOUT_FILENO);
       close (stdout_pipe[1]);
 
-      if (execlp (name, name, 0) == -1)
-	error ("execute: unable to start process `%s'", name);
+      if (execlp (name.c_str (), name.c_str (), 0) == -1)
+	error ("execute: unable to start process `%s'", name.c_str ());
 
       exit (0);
       return 0.0;
     } 
   else 
     {
       close (stdin_pipe[0]);
       close (stdout_pipe[1]);
@@ -2172,20 +2162,19 @@ sync_system_internal (const Octave_objec
   Octave_object retval (1, tree_constant (-1.0));
 
   if (! args(0).is_string ())
     {
       error ("sync_system: file name must be a string");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
-
-  retval (0) = (double) system (name);
+  string name = args(0).string_value ();
+
+  retval (0) = (double) system (name.c_str ());
   return retval;
 }
 
 DEFUN ("sync_system", Fsync_system, Ssync_system, 10,
   "RETCODE = sync_system (FILENAME)\n\
 \n\
   Start a program and wait until it terminates")
 {
@@ -2208,30 +2197,29 @@ async_system_internal (const Octave_obje
   pid_t pid;
 
   if (! args(0).is_string ())
     {
       error ("async_system: file name must be a string");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
+  string name = args(0).string_value ();
 
   pid = fork ();
 
   if (pid < 0) 
     {
       error ("async_system: fork failed -- can't create child process");
       return retval;
     }
 
   if (pid == 0) 
     {
-      system (name);
+      system (name.c_str ());
       exit (0);
       retval (0) = 0.0;
       return retval;
     } 
   else
     {
       retval (0) = (double) pid;
       return retval;
@@ -2342,28 +2330,27 @@ mkfifo_internal (const Octave_object& ar
   Octave_object retval (1, tree_constant (-1.0));
 
   if (! args(0).is_string ())
     {
       error ("mkfifo: file name must be a string");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
+  string name = args(0).string_value ();
 
   if (! args(1).is_scalar_type ())
     {
       error ("mkfifo:  MODE must be an integer");
       return retval;
     }
 
   long mode = (long) args(1).double_value ();
 
-  retval (0) = (double) mkfifo (name, mode);
+  retval (0) = (double) mkfifo (name.c_str (), mode);
 
   return retval;
 }
 
 DEFUN ("mkfifo", Fmkfifo, Smkfifo, 10,
   "STATUS = mkfifo (NAME, MODE)\n\
 \n\
   Create a FIFO special file named NAME with file mode MODE\n\
@@ -2392,20 +2379,19 @@ unlink_internal (const Octave_object& ar
 
   if (! args(0).is_string ())
     {
       error ("unlink: file name must be a string");
       retval (0) = -1.0;
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
-
-  retval (0) = (double) unlink (name);
+  string name = args(0).string_value ();
+
+  retval (0) = (double) unlink (name.c_str ());
 
   return retval;
 }
 
 DEFUN ("unlink", Funlink, Sunlink, 10,
   "STATUS = unlink (NAME)\n\
 \n\
   Delete the file NAME\n\
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -237,53 +237,53 @@ print_fsolve_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_fsolve_option (const char *keyword, double val)
+set_fsolve_option (const string& keyword, double val)
 {
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (fsolve_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
-  warning ("fsolve_options: no match for `%s'", keyword);
+  warning ("fsolve_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_fsolve_option (const char *keyword)
+show_fsolve_option (const string& keyword)
 {
   Octave_object retval;
 
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  return (fsolve_opts.*list->d_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("fsolve_options: no match for `%s'", keyword);
+  warning ("fsolve_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("fsolve_options", Ffsolve_options, Sfsolve_options,
 		   FSfsolve_options, 10,
   "fsolve_options (KEYWORD, VALUE)\n\
 \n\
@@ -296,18 +296,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_fsolve_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_fsolve_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -24,36 +24,40 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <csignal>
 #include <cstdlib>
 #include <cstring>
 
+#include <string>
+
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "help.h"
-#include "toplev.h"
+#include "oct-obj.h"
 #include "pager.h"
 #include "pathsearch.h"
+#include "pt-const.h"
+#include "pt-exp.h"
 #include "sighandlers.h"
 #include "symtab.h"
-#include "pt-const.h"
-#include "oct-obj.h"
-#include "pt-exp.h"
+#include "toplev.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 static help_list operators[] =
 {
   { "!",
@@ -259,42 +263,42 @@ static help_list keywords[] =
   { "while",
     "Begin a while loop.", },
 
   { 0, 0, },
 };
 
 // Return a copy of the operator or keyword names.
 
-char **
+string_vector
 names (help_list *lst, int& count)
 {
+  string_vector retval;
+
   count = 0;
   help_list *ptr = lst;
   while (ptr->name)
     {
       count++;
       ptr++;
     }
 
-  if (count == 0)
-    return 0;
-    
-  char **name_list = new char * [count+1];
+  if (count > 0)
+    {
+      retval.resize (count);
 
-  ptr = lst;
-  int i = 0;
-  while (ptr->name)
-    {
-      name_list[i++] = strsave (ptr->name);
-      ptr++;
+      ptr = lst;
+      for (int i = 0; i < count; i++)
+	{
+	  retval[i] = ptr->name;
+	  ptr++;
+	}
     }
 
-  name_list[i] = 0;
-  return name_list;
+  return retval;
 }
 
 help_list *
 operator_help (void)
 {
   return operators;
 }
 
@@ -316,65 +320,68 @@ additional_help_message (ostrstream& out
 {
 #ifdef USE_GNU_INFO
   if (! user_pref.suppress_verbose_help_message)
     output_buf << VERBOSE_HELP_MESSAGE;
 #endif
 }
 
 void
-print_usage (const char *string, int just_usage)
+print_usage (const string& nm, int just_usage)
 {
   ostrstream output_buf;
 
-  symbol_record *sym_rec = global_sym_tab->lookup (string, 0, 0);
+  symbol_record *sym_rec = global_sym_tab->lookup (nm, 0, 0);
   if (sym_rec)
     {
-      char *h = sym_rec->help ();
-      if (h && *h)
+      string h = sym_rec->help ();
+
+      if (h.length () > 0)
 	{
-	  output_buf << "\n*** " << string << ":\n\n"
+	  output_buf << "\n*** " << nm << ":\n\n"
 	    << h << "\n";
 
 	  if (! just_usage)
 	    additional_help_message (output_buf);
 	  output_buf << ends;
 	  maybe_page_output (output_buf);
 	}
     }
   else
-    warning ("no usage message found for `%s'", string);
+    warning ("no usage message found for `%s'", nm.c_str ());
 }
 
 static void
 display_names_from_help_list (ostrstream& output_buf, help_list *list,
 			      const char *desc)
 {
   int count = 0;
-  char **symbols = names (list, count);
+  string_vector symbols = names (list, count);
   output_buf << "\n*** " << desc << ":\n\n";
-  if (symbols && count > 0)
+  if (symbols.length () > 0)
     list_in_columns (output_buf, symbols);
-  delete [] symbols;
 }
 
-static char *
+static string
 print_symbol_type (ostrstream& output_buf, symbol_record *sym_rec,
-		   char *name, int print)
+		   const string& name, int print)
 {
-  char *retval = 0;
+  string retval;
 
   if (sym_rec->is_user_function ())
     {
       tree_fvc *defn = sym_rec->def ();
-      char *fn = defn->fcn_file_name ();
-      if (fn)
+
+      string fn = defn->fcn_file_name ();
+
+      if (! fn.empty ())
 	{
-	  char *ff = fcn_file_in_path (fn);
-	  ff = ff ? ff : fn;
+	  string ff = fcn_file_in_path (fn);
+
+	  ff = ff.length () > 0 ? ff : fn;
 
 	  if (print)
 	    output_buf << name
 	      << " is the function defined from:\n"
 		<< ff << "\n";
 	  else
 	    retval = ff;
 	}
@@ -422,21 +429,21 @@ print_symbol_type (ostrstream& output_bu
       else
 	retval = "unknown type";
     }
 
   return retval;
 }
 
 static void
-display_symtab_names (ostrstream& output_buf, char **names,
-		      int count, const char *desc)
+display_symtab_names (ostrstream& output_buf, const string_vector& names,
+		      int /* count */, const string& desc)
 {
   output_buf << "\n*** " << desc << ":\n\n";
-  if (names && count > 0)
+  if (names.length () > 0)
     list_in_columns (output_buf, names);
 }
 
 static void
 simple_help (void)
 {
   ostrstream output_buf;
 
@@ -448,22 +455,18 @@ simple_help (void)
 
 #ifdef LIST_SYMBOLS
 #undef LIST_SYMBOLS
 #endif
 #define LIST_SYMBOLS(type, msg) \
   do \
     { \
       int count; \
-      char **names = global_sym_tab->list (count, 0, 0, 1, type); \
+      string_vector names = global_sym_tab->list (count, 0, 0, 1, type); \
       display_symtab_names (output_buf, names, count, msg); \
-      char **ptr = names; \
-      while (*ptr) \
-        delete [] *ptr++; \
-      delete [] names; \
     } \
   while (0)
 
   // XXX FIXME XXX -- is this distinction needed?
 
   LIST_SYMBOLS (symbol_def::TEXT_FUNCTION,
 		"text functions (these names are also reserved)");
 
@@ -473,78 +476,75 @@ simple_help (void)
 
   LIST_SYMBOLS (symbol_def::BUILTIN_VARIABLE, "builtin variables");
 
   // Also need to list variables and currently compiled functions from
   // the symbol table, if there are any.
 
   // Also need to search octave_path for script files.
 
-  char *path_elt = kpse_path_element (user_pref.loadpath);
+  char *path_elt = kpse_path_element (user_pref.loadpath.c_str ());
 
   while (path_elt)
     {
       str_llist_type *elt_dirs = kpse_element_dirs (path_elt);
 
       str_llist_elt_type *dir;
       for (dir = *elt_dirs; dir; dir = STR_LLIST_NEXT (*dir))
 	{
 	  char *elt_dir = STR_LLIST (*dir);
 
 	  if (elt_dir)
 	    {
 	      int count;
-	      char **names = get_fcn_file_names (count, elt_dir, 0);
+	      string_vector names = get_fcn_file_names (count, elt_dir, 0);
 
 	      output_buf << "\n*** function files in "
 		<< make_absolute (elt_dir, the_current_working_directory)
 		  << ":\n\n";
 
-	      if (names && count > 0)
+	      if (names.length () > 0)
 		list_in_columns (output_buf, names);
-
-	      delete [] names;
 	    }
 	}
 
       path_elt = kpse_path_element (0);
     }
 
   additional_help_message (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 #ifdef USE_GNU_INFO
 static int
-try_info (const char *string)
+try_info (const string& nm)
 {
   int status = 0;
 
   static char *cmd_str = 0;
 
   delete [] cmd_str;
   cmd_str = 0;
 
   ostrstream cmd_buf;
 
   cmd_buf << user_pref.info_prog << " --file " << user_pref.info_file;
 
-  char *directory_name = strsave (user_pref.info_file);
-  char *file = strrchr (directory_name, '/');
-  if (file)
+  string directory_name = user_pref.info_file;
+  size_t pos = directory_name.rfind ('/');
+
+  if (pos != NPOS)
     {
-      file++;
-      *file = 0;
+      directory_name.resize (pos + 1);
       cmd_buf << " --directory " << directory_name;
     }
-  delete [] directory_name;
 
-  if (string)
-    cmd_buf << " --index-search " << string;
+  if (nm.length () > 0)
+    cmd_buf << " --index-search " << nm;
 
   cmd_buf << ends;
 
   cmd_str = cmd_buf.str ();
 
   volatile sig_handler *old_sigint_handler;
   old_sigint_handler = octave_set_signal_handler (SIGINT, SIG_IGN);
 
@@ -557,39 +557,34 @@ try_info (const char *string)
   else
     status = 127;
 
   return status;
 }
 #endif
 
 static void
-help_from_info (int argc, char **argv)
+help_from_info (const string_vector& argv, int idx, int argc)
 {
 #ifdef USE_GNU_INFO
-  if (argc == 1)
-    try_info (0);
+  if (idx == argc)
+    try_info (string ());
   else
     {
-      while (--argc > 0)
+      for (int i = idx; i < argc; i++)
 	{
-	  argv++;
-
-	  if (! *argv || ! **argv)
-	    continue;
-
-	  int status = try_info (*argv);
+	  int status = try_info (argv[i]);
 
 	  if (status)
 	    {
 	      if (status < 0)
 		{
 		  message ("help",
 			   "sorry, `%s' is not indexed in the manual",
-			   *argv);
+			   argv[i].c_str ());
 		  sleep (2);
 		}
 	      else
 		{
 		  error ("help: unable to find info!");
 		  break;
 		}
 	    }
@@ -597,86 +592,82 @@ help_from_info (int argc, char **argv)
     }
 #else
   message (0, "sorry, help -i is not available in this version of Octave");
 #endif
 }
 
 int
 help_from_list (ostrstream& output_buf, const help_list *list,
-		const char *string, int usage)
+		const string& nm, int usage)
 {
   char *name;
   while ((name = list->name) != 0)
     {
-      if (strcmp (name, string) == 0)
+      if (strcmp (name, nm.c_str ()) == 0)
 	{
 	  if (usage)
 	    output_buf << "\nusage: ";
 	  else
 	    {
-	      output_buf << "\n*** " << string << ":\n\n";
+	      output_buf << "\n*** " << nm << ":\n\n";
 	    }
 
 	  output_buf << list->help << "\n";
 
 	  return 1;
 	}
       list++;
     }
   return 0;
 }
 
 static void
-builtin_help (int argc, char **argv)
+builtin_help (int argc, const string_vector& argv)
 {
   ostrstream output_buf;
 
   help_list *op_help_list = operator_help ();
   help_list *kw_help_list = keyword_help ();
 
-  while (--argc > 0)
+  for (int i = 1; i < argc; i++)
     {
-      argv++;
-
-      if (! *argv || ! **argv)
+      if (help_from_list (output_buf, op_help_list, argv[i], 0))
 	continue;
 
-      if (help_from_list (output_buf, op_help_list, *argv, 0))
+      if (help_from_list (output_buf, kw_help_list, argv[i], 0))
 	continue;
 
-      if (help_from_list (output_buf, kw_help_list, *argv, 0))
-	continue;
-
-      symbol_record *sym_rec = lookup_by_name (*argv, 0);
+      symbol_record *sym_rec = lookup_by_name (argv[i], 0);
 
       if (sym_rec && sym_rec->is_defined ())
 	{
-	  char *h = sym_rec->help ();
-	  if (h && *h)
+	  string h = sym_rec->help ();
+
+	  if (h.length () > 0)
 	    {
-	      print_symbol_type (output_buf, sym_rec, *argv, 1);
+	      print_symbol_type (output_buf, sym_rec, argv[i], 1);
 	      output_buf << "\n" << h << "\n";
 	      continue;
 	    }
 	}
 
-      char *path = fcn_file_in_path (*argv);
-      char *h = get_help_from_file (path);
-      if (h && *h)
+      string path = fcn_file_in_path (argv[i]);
+
+      string h = get_help_from_file (path);
+
+      if (! h.empty ())
 	{
-	  output_buf << *argv << " is the file:\n"
+	  output_buf << argv[i] << " is the file:\n"
 	    << path << "\n\n" << h << "\n";
-	  delete [] h;
-	  delete [] path;
+
 	  continue;
 	}
-      delete [] path;
 
-      output_buf << "\nhelp: sorry, `" << *argv << "' is not documented\n"; 
+      output_buf << "\nhelp: sorry, `" << argv[i] << "' is not documented\n"; 
     }
 
   additional_help_message (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 #ifdef USE_GNU_INFO
@@ -688,240 +679,237 @@ print cryptic yet witty messages")
 DEFUN_TEXT ("help", Fhelp, Shelp, 10,
   "help [topic ...]\n\
 \n\
 print cryptic yet witty messages")
 #endif
 {
   Octave_object retval;
 
-  DEFINE_ARGV("help");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "help");
+
+  if (error_state)
+    return retval;
 
   if (argc == 1)
     {
       simple_help ();
     }
   else
     {
-      if (argv[1] && strcmp (argv[1], "-i") == 0)
+      if (argv[1] == "-i")
 	{
-	  argc--;
-	  argv++;
-
-	  help_from_info (argc, argv);
+	  help_from_info (argv, 2, argc);
 	}
       else
 	{
 	  builtin_help (argc, argv);
 	}
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("type", Ftype, Stype, 11,
   "type NAME ...]\n\
 \n\
 display the definition of each NAME that refers to a function")
 {
   Octave_object retval;
 
   begin_unwind_frame ("Ftype");
 
-  unwind_protect_ptr (user_pref.ps4);
-  user_pref.ps4 = "";
+  // XXX FIXME XXX -- need a way to protect strings.
+  //  unwind_protect_ptr (user_pref.ps4);
+  //  user_pref.ps4 = "";
 
-  DEFINE_ARGV("type");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "type");
+
+  if (error_state)
+    return retval;
 
   if (argc > 1)
     {
       // XXX FIXME XXX -- we should really use getopt ()
 
       int quiet = 0;
-      if (argv[1] && strcmp (argv[1], "-q") == 0)
+      int idx = 1;
+      if (argv[idx] == "-q")
 	{
 	  quiet = 1;
-	  argc--;
-	  argv++;
+	  idx++;
 	}
 
       ostrstream output_buf;
 
-      while (--argc > 0)
+      for (int i = idx; i < argc; i++)
 	{
-	  argv++;
-
-	  if (! *argv || ! **argv)
-	    continue;
+	  string id = argv[i];
+	  string elts;
 
-	  char *id = strsave (*argv);
-	  char *elts = 0;
-	  if (id[strlen (id) - 1] != '.')
+	  if (id[id.length () - 1] != '.')
 	    {
-	      char *ptr = strchr (id, '.');
-	      if (ptr)
+	      size_t pos = id.find ('.');
+
+	      if (pos != NPOS)
 		{
-		  *ptr = '\0';
-		  elts = ptr + 1;
+		  id = id.substr (0, pos);
+		  elts = id.substr (pos+1);
 		}
 	    }
 
 	  symbol_record *sym_rec = lookup_by_name (id, 0);
 
 	  if (sym_rec)
 	    {
 	      if (sym_rec->is_user_function ())
 		{
 		  tree_fvc *defn = sym_rec->def ();
 
 		  if (nargout == 0 && ! quiet)
-		    output_buf << *argv << " is a user-defined function\n";
+		    output_buf << argv[i] << " is a user-defined function\n";
 
 		  defn->print_code (output_buf);
 		}
 
 	      // XXX FIXME XXX -- this code should be shared with
 	      // Fwhich.
 
 	      else if (sym_rec->is_text_function ())
-		output_buf << *argv << " is a builtin text-function\n";
+		output_buf << argv[i] << " is a builtin text-function\n";
 	      else if (sym_rec->is_builtin_function ())
-		output_buf << *argv << " is a builtin function\n";
+		output_buf << argv[i] << " is a builtin function\n";
 	      else if (sym_rec->is_user_variable ()
 		       || sym_rec->is_builtin_variable ())
 		{
 		  tree_fvc *defn = sym_rec->def ();
 
 		  assert (defn && defn->is_constant ());
 
 		  tree_constant *tmp = (tree_constant *) defn;
 
 		  int var_ok = 1;
 		  if (tmp && tmp->is_map ())
 		    {
-		      if (elts && *elts)
+		      if (! elts.empty ())
 			{
 			  tree_constant ult =
 			    tmp->lookup_map_element (elts, 0, 1);
 
 			  if (! ult.is_defined ())
 			    var_ok = 0;			    
 			}
 		    }
 
 		  if (nargout == 0 && ! quiet)
 		    {
 		      if (var_ok)
 			{
-			  output_buf << *argv;
+			  output_buf << argv[i];
 			  if (sym_rec->is_user_variable ())
 			    output_buf << " is a user-defined variable\n";
 			  else
 			    output_buf << " is a built-in variable\n";
 			}
 		      else
 			{
-			  if (elts && *elts)
+			  if (! elts.empty ())
 			    output_buf << "type: structure `" << id
 			      << "' has no member `" << elts << "'\n";
 			  else
 			    output_buf << "type: `" << id
 			      << "' has unknown type!";
 			}
 		    }
 		  if (! tmp->is_map ())
 		    {
 		      tmp->print_code (output_buf);
 
 		      if (nargout == 0)
 			output_buf << "\n";
 		    }
 		}
 	      else
-		output_buf << "type: `" << *argv << "' has unknown type!\n";
+		output_buf << "type: `" << argv[i] << "' has unknown type!\n";
 	    }
 	  else
-	    output_buf << "type: `" << *argv << "' undefined\n";
-
-	  delete [] id;
+	    output_buf << "type: `" << argv[i] << "' undefined\n";
 	}
 
       output_buf << ends;
 
       if (nargout == 0)
 	maybe_page_output (output_buf);
       else
 	{
 	  char *s = output_buf.str ();
 	  retval = s;
 	  delete [] s;
 	}
     }
   else
     print_usage ("type");
 
-  DELETE_ARGV;
-
   run_unwind_frame ("Ftype");
 
   return retval;
 }
 
 DEFUN_TEXT ("which", Fwhich, Swhich, 11,
   "which NAME ...\n\
 \n\
 display the type of each NAME.  If NAME is defined from an function\n\
 file, print the full name of the file.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("which");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "which");
+
+  if (error_state)
+    return retval;
 
   if (argc > 1)
     {
       if (nargout > 0)
 	retval.resize (argc-1, Matrix ());
 
       ostrstream output_buf;
 
-      for (int i = 0; i < argc-1; i++)
+      for (int i = 1; i < argc; i++)
 	{
-	  argv++;
-
-	  if (! *argv || ! **argv)
-	    continue;
-
-	  symbol_record *sym_rec = lookup_by_name (*argv, 0);
+	  symbol_record *sym_rec = lookup_by_name (argv[i], 0);
 
 	  if (sym_rec)
 	    {
 	      int print = (nargout == 0);
-	      char *tmp = print_symbol_type (output_buf, sym_rec,
-					     *argv, print);
+	      string tmp = print_symbol_type (output_buf, sym_rec,
+					      argv[i], print);
 	      if (! print)
 		retval(i) = tmp;
 	    }
 	  else
 	    {
 	      if (nargout == 0)
-		output_buf << "which: `" << *argv << "' is undefined\n";
+		output_buf << "which: `" << argv[i] << "' is undefined\n";
 	      else
 		retval(i) = "undefined";
 	    }
 	}
       output_buf << ends;
       maybe_page_output (output_buf);
     }
   else
     print_usage ("which");
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -21,32 +21,38 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_help_h)
 #define octave_help_h 1
 
 class ostrstream;
 
-typedef struct help_list
+#include <string>
+
+class string_vector;
+
+// XXX FIXME XXX -- should probably use string, not char*.
+
+struct help_list
 {
   char *name;
   char *help;
 };
 
-extern char **names (help_list *l, int& count);
+extern string_vector names (help_list *l, int& count);
 extern help_list *operator_help (void);
 extern help_list *keyword_help (void);
 
+extern void print_usage (const string& nm, int just_usage = 0);
+
 extern int help_from_list (ostrstream& output_buf,
-			   const help_list *list, const char *string,
+			   const help_list *list, const string& nm,
 			   int usage);
 
-extern void print_usage (const char *s, int just_usage = 0);
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -86,60 +86,62 @@ gnu_readline (const char *s)
       fgets (line_from_stdin, LINE_SIZE, stdin);
       return line_from_stdin;
     }
   else
 #endif
     return readline (s);
 }
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
 #include "oct-map.h"
 #include "oct-hist.h"
 #include "toplev.h"
+#include "oct-obj.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathlen.h"
+#include "pt-const.h"
 #include "sighandlers.h"
 #include "symtab.h"
 #include "sysdep.h"
-#include "pt-const.h"
-#include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 // The size that strings change by.
 #ifndef DEFAULT_ARRAY_SIZE
 #define DEFAULT_ARRAY_SIZE 512
 #endif
 
 // The growth rate for the prompt string.
 #ifndef PROMPT_GROWTH
 #define PROMPT_GROWTH 50
 #endif
 
 // Global pointer for eval().
-const char *current_eval_string = 0;
+string current_eval_string;
 
 // Nonzero means get input from current_eval_string.
 int get_input_from_eval_string = 0;
 
 // Nonzero means we're parsing a function file.
 int reading_fcn_file = 0;
 
 // Simple name of function file we are reading.
-const char *curr_fcn_file_name = 0;
+string curr_fcn_file_name;
 
 // Full name of file we are reading.
-const char *curr_fcn_file_full_name = 0;
+string curr_fcn_file_full_name;
 
 // Nonzero means we're parsing a script file.
 int reading_script_file = 0;
 
 // If we are reading from an M-file, this is it.
 FILE *ff_instream = 0;
 
 // Nonzero means we are using readline.
@@ -150,63 +152,41 @@ int interactive = 0;
 
 // Nonzero means the user forced this shell to be interactive (-i).
 int forced_interactive = 0;
 
 // Should we issue a prompt?
 int promptflag = 1;
 
 // The current line of input, from wherever.
-char *current_input_line = 0;
+string current_input_line;
 
 // A line of input from readline.
 static char *octave_gets_line = 0;
 
-// Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
-// space allocated to TARGET.  SOURCE can be NULL, in which case
-// nothing happens.  Gets rid of SOURCE by free ()ing it.  Returns
-// TARGET in case the location has changed.
-
-static char *
-sub_append_string (char *source, char *target, int *index, int *size)
-{
-  if (source)
-    {
-      while ((int)strlen (source) >= (int)(*size - *index))
-	{
-	  char *tmp = new char [*size += DEFAULT_ARRAY_SIZE];
-	  strcpy (tmp, target);
-	  delete [] target;
-	  target = tmp;
-	}
-
-      strcat (target, source);
-      *index += strlen (source);
-
-      delete [] source;
-    }
-  return target;
-}
-
 // Return the octal number parsed from STRING, or -1 to indicate that
 // the string contained a bad number.
 
 int
-read_octal (const char *string)
+read_octal (const string& s)
 {
   int result = 0;
   int digits = 0;
 
-  while (*string && *string >= '0' && *string < '8')
+  size_t i = 0;
+  size_t slen = s.length ();
+
+  while (i < slen && s[i] >= '0' && s[i] < '8')
     {
       digits++;
-      result = (result * 8) + *string++ - '0';
+      result = (result * 8) + s[i] - '0';
+      i++;
     }
 
-  if (! digits || result > 0777 || *string)
+  if (! digits || result > 0777 || i < slen)
     result = -1;
 
   return result;
 }
 
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows: 
 //   
@@ -219,261 +199,246 @@ read_octal (const char *string)
 //	\u	your username
 //	\h	the hostname
 //	\#	the command number of this command
 //	\!	the history number of this command
 //	\$	a $ or a # if you are root
 //	\<octal> character code in octal
 //	\\	a backslash
 
-static char *
-decode_prompt_string (const char *string)
+static string
+decode_prompt_string (const string& s)
 {
-  int result_size = PROMPT_GROWTH;
-  int result_index = 0;
-  char *result = new char [PROMPT_GROWTH];
+  string result;
+  string temp;
+  size_t i = 0;
+  size_t slen = s.length ();
   int c;
-  char *temp = 0;
 
-  result[0] = 0;
-  while ((c = *string++))
+  while (i < slen)
     {
+      c = s[i];
+
+      i++;
+
       if (c == '\\')
 	{
-	  c = *string;
+	  c = s[i];
 
 	  switch (c)
 	    {
 	    case '0':
 	    case '1':
 	    case '2':
 	    case '3':
 	    case '4':
 	    case '5':
 	    case '6':
 	    case '7':
+	      // Maybe convert an octal number.
 	      {
-		char octal_string[4];
-		int n;
+		int n = read_octal (s.substr (i, 3));
 
-		strncpy (octal_string, string, 3);
-		octal_string[3] = '\0';
+		temp = "\\";
 
-		n = read_octal (octal_string);
-
-		temp = strsave ("\\");
 		if (n != -1)
 		  {
-		    string += 3;
+		    i += 3;
 		    temp[0] = n;
 		  }
 
 		c = 0;
 		goto add_string;
 	      }
 	  
 	    case 't':
 	    case 'd':
-	      /* Make the current time/date into a string. */
+	      // Make the current time/date into a string.
 	      {
-		time_t the_time = time (0);
-		char *ttemp = ctime (&the_time);
-		temp = strsave (ttemp);
+		time_t now = time (0);
+
+		temp = ctime (&now);
 
 		if (c == 't')
 		  {
-		    strcpy (temp, temp + 11);
-		    temp[8] = '\0';
+		    temp = temp.substr (11);
+		    temp.resize (8);
 		  }
 		else
-		  temp[10] = '\0';
+		  temp.resize (10);
 
 		goto add_string;
 	      }
 
 	    case 'n':
-	      if (! no_line_editing)
-		temp = strsave ("\r\n");
-	      else
-		temp = strsave ("\n");
-	      goto add_string;
+	      {
+		if (! no_line_editing)
+		  temp = "\r\n";
+		else
+		  temp = "\n";
+
+		goto add_string;
+	      }
 
 	    case 's':
 	      {
 		temp = base_pathname (prog_name);
-		temp = strsave (temp);
+
 		goto add_string;
 	      }
 	
 	    case 'w':
 	    case 'W':
 	      {
-		char t_string[MAXPATHLEN];
 #define EFFICIENT
 #ifdef EFFICIENT
-
 		// Use the value of PWD because it is much more
 		// effecient.
 
 		temp = user_pref.pwd;
 
-		if (! temp)
-		  octave_getcwd (t_string, MAXPATHLEN);
-		else
-		  strcpy (t_string, temp);
+		if (temp.empty ())
+		  temp = octave_getcwd ();
 #else
-		octave_getcwd (t_string, MAXPATHLEN);
+		temp = octave_getcwd ();
 #endif	/* EFFICIENT */
 
 		if (c == 'W')
 		  {
-		    char *dir = strrchr (t_string, '/');
-		    if (dir && dir != t_string)
-		      strcpy (t_string, dir + 1);
-		    temp = strsave (t_string);
+		    size_t pos = temp.rfind ('/');
+
+		    if (pos != NPOS && pos != 0)
+		      temp = temp.substr (pos + 1);
 		  }
 		else
-		  temp = strsave (polite_directory_format (t_string));
+		  temp = polite_directory_format (temp);
+
 		goto add_string;
 	      }
       
 	    case 'u':
 	      {
-		temp = strsave (user_name);
+		temp = user_name;
 
 		goto add_string;
 	      }
 
 	    case 'h':
 	      {
-		char *t_string;
+		temp = host_name;
 
-		temp = strsave (host_name);
-		t_string = strchr (temp, '.');
-		if (t_string);
-		  *t_string = '\0';
+		size_t pos = temp.find ('.');
+
+		if (pos != NPOS)
+		  temp.resize (pos);
 		
 		goto add_string;
 	      }
 
 	    case '#':
 	      {
 		char number_buffer[128];
 		sprintf (number_buffer, "%d", current_command_number);
-		temp = strsave (number_buffer);
+		temp = number_buffer;
+
 		goto add_string;
 	      }
 
 	    case '!':
 	      {
 		char number_buffer[128];
 		int num = current_history_number ();
 		if (num > 0)
                   sprintf (number_buffer, "%d", num);
 		else
 		  strcpy (number_buffer, "!");
-		temp = strsave (number_buffer);
+		temp = number_buffer;
+
 		goto add_string;
 	      }
 
 	    case '$':
-	      temp = strsave (geteuid () == 0 ? "#" : "$");
-	      goto add_string;
+	      {
+		temp = (geteuid () == 0 ? "#" : "$");
+
+		goto add_string;
+	      }
 
 	    case '[':
 	    case ']':
-	      temp = new char[3];
-              temp[0] = '\001';
-              temp[1] = ((c == '[')
-			 ? RL_PROMPT_START_IGNORE
-			 : RL_PROMPT_END_IGNORE);
-              temp[2] = '\0';
-	      goto add_string;
+	      {
+		temp.resize (2);
+
+		temp[0] = '\001';
+		temp[1] = ((c == '[')
+			   ? RL_PROMPT_START_IGNORE
+			   : RL_PROMPT_END_IGNORE);
+
+		goto add_string;
+	      }
 
 	    case '\\':
-	      temp = strsave ("\\");
-	      goto add_string;
+	      {
+		temp = "\\";
+
+		goto add_string;
+	      }
 
 	    default:
-	      temp = strsave ("\\ ");
-	      temp[1] = c;
+	      {
+		temp = "\\ ";
+		temp[1] = c;
+
+		goto add_string;
+	      }
 
 	    add_string:
-	      if (c)
-		string++;
-	      result =
-		(char *)sub_append_string (temp, result,
-					   &result_index, &result_size);
-	      temp = 0; // Free ()'ed in sub_append_string ().
-	      result[result_index] = '\0';
-	      break;
+	      {
+		if (c)
+		  i++;
+
+		result.append (temp);
+
+		break;
+	      }
 	    }
 	}
       else
-	{
-	  while (3 + result_index > result_size)
-	    {
-	      char *tmp = new char [result_size += PROMPT_GROWTH];
-	      strcpy (tmp, result);
-	      delete [] result;
-	      result = tmp;
-	    }
-	  result[result_index++] = c;
-	  result[result_index] = '\0';
-	}
+	result += c;
     }
 
-#if 0
-  // I don't really think that this is a good idea.  Do you?
-
-  if (! find_variable ("NO_PROMPT_VARS"))
-    {
-      WORD_LIST *expand_string (), *list;
-      char *string_list ();
-
-      list = expand_string (result, 1);
-      free (result);
-      result = string_list (list);
-      dispose_words (list);
-    }
-#endif
-
   return result;
 }
 
 static void
-do_input_echo (const char *input_string)
+do_input_echo (const string& input_string)
 {
   int do_echo = reading_script_file ?
     (user_pref.echo_executing_commands & ECHO_SCRIPTS)
       : (user_pref.echo_executing_commands & ECHO_CMD_LINE);
 
   if (do_echo)
     {
       ostrstream buf;
 
       if (forced_interactive)
 	{
-	  char *ps = (promptflag > 0) ? user_pref.ps1 : user_pref.ps2;
-	  char *prefix = decode_prompt_string (ps);
-	  buf << prefix;
-	  delete [] prefix;
+	  if (promptflag > 0)
+	    buf << decode_prompt_string (user_pref.ps1);
+	  else
+	    buf << decode_prompt_string (user_pref.ps2);
 	}
       else
-	{
-	  char *prefix = decode_prompt_string (user_pref.ps4);
-	  buf << prefix;
-	  delete [] prefix;
-	}
+	buf << decode_prompt_string (user_pref.ps4);
 
-      if (input_string)
+      if (! input_string.empty ())
 	{
 	  buf << input_string;
-	  int len = strlen (input_string);
-	  if (input_string[len-1] != '\n')
+
+	  if (input_string[input_string.length () - 1] != '\n')
 	    buf << "\n";
 	}
 
       maybe_page_output (buf);
     }
 }
 
 // Use GNU readline to get an input line and store it in the history
@@ -485,18 +450,20 @@ octave_gets (void)
   if (octave_gets_line)
     {
       free (octave_gets_line);
       octave_gets_line = 0;
     }
 
   if (interactive || forced_interactive)
     {
-      char *ps = (promptflag > 0) ? user_pref.ps1 : user_pref.ps2;
-      char *prompt = decode_prompt_string (ps);
+      const char *ps = (promptflag > 0) ? user_pref.ps1.c_str () :
+	user_pref.ps2.c_str ();
+
+      const char *prompt = decode_prompt_string (ps).c_str ();
 
       if (interactive)
 	{
 	  pipe_handler_error_count = 0;
 	  flush_output_to_pager ();
 	}
 
       maybe_write_to_diary_file (prompt);
@@ -522,47 +489,43 @@ octave_gets (void)
   maybe_write_to_diary_file ("\n");
   
   return octave_gets_line;
 }
 
 // Read a line from the input stream.
 
 int
-octave_read (char *buf, int max_size)
+octave_read (char *buf, unsigned max_size)
 {
   int status = 0;
 
-  static char *stashed_line = 0;
-
   if (get_input_from_eval_string)
     {
-      int len = strlen (current_eval_string);
+      size_t len = current_eval_string.length ();
+
       if (len < max_size - 1)
 	{
-	  strcpy (buf, current_eval_string);
+	  strcpy (buf, current_eval_string.c_str ());
 	  buf[len++] = '\n';
 	  buf[len] = '\0';    // Paranoia.
 	  status = len;
 	}
       else
 	status = -1;
 
-      if (stashed_line)
-	delete [] stashed_line;
-
-      stashed_line = strsave (buf);
-      current_input_line = stashed_line;
+      current_input_line = buf;
     }
   else if (using_readline)
     {
       char *cp = octave_gets ();
       if (cp)
 	{
-	  int len = strlen (cp);
+	  size_t len = strlen (cp);
+
 	  if (len >= max_size)
 	    status = -1;
 	  else
 	    {
 	      strcpy (buf, cp);
 	      buf[len++] = '\n';
 	      buf[len] = '\0';    // Paranoia.
 	      status = len;
@@ -578,38 +541,34 @@ octave_read (char *buf, int max_size)
 
       assert (curr_stream);
 
       // Why is this required?
       buf[0] = '\0';
 
       if (fgets (buf, max_size, curr_stream))
 	{
-	  int len = strlen (buf);
+	  size_t len = strlen (buf);
+
 	  if (len > max_size - 2)
 	    status = -1;
 	  else
 	    {
 	      if (buf[len-1] != '\n')
 		{
 		  buf[len++] = '\n';
 		  buf[len] = '\0';
 		}
 	      status = len;
 	    }
 	}
       else
 	status = 0; // Tell yylex that we found EOF.
 
-      if (stashed_line)
-	delete [] stashed_line;
-
-      stashed_line = strsave (buf);
-
-      current_input_line = stashed_line;
+      current_input_line = buf;
 
       do_input_echo (current_input_line);
     }
 
   input_line_number++;
 
   return status;
 }
@@ -642,21 +601,21 @@ get_input_from_file (const string& name,
 
 FILE *
 get_input_from_stdin (void)
 {
   rl_instream = stdin;
   return rl_instream;
 }
 
-static char **
+static const char **
 generate_struct_completions (const char *text, char *& prefix,
 			     char *& hint)
 {
-  char **names = 0;
+  const char **names = 0;
 
   assert (text);
 
   char *id = strsave (text);
   char *ptr = strchr (id, '.');
   *ptr = '\0';
 
   char *elts = ptr + 1;
@@ -682,53 +641,77 @@ generate_struct_completions (const char 
       tree_fvc *tmp_fvc = sr->def ();
 
       tree_constant *def = 0;
       if (tmp_fvc->is_constant ())
 	def = (tree_constant *) tmp_fvc;
 
       if (def && def->is_map ())
 	{
+	  string_vector tmp_names;
+
 	  if (elts && *elts)
 	    {
 	      tree_constant ult = def->lookup_map_element (elts, 0, 1);
 
 	      if (ult.is_map ())
 		{
 		  Octave_map m = ult.map_value ();
-		  names = m.make_name_list ();
+		  tmp_names = m.make_name_list ();
 		}
 	    }
 	  else
 	    {
 	      Octave_map m = def->map_value ();
-	      names = m.make_name_list ();
+	      tmp_names = m.make_name_list ();
+	    }
+
+	  int n = tmp_names.length ();
+
+	  if (n > 0)
+	    {
+	      names = new const char * [n+1];
+	      for (int i = 0; i < n; i++)
+		names[i] = strsave (tmp_names[i].c_str ());
+	      names[n] = 0;
 	    }
 	}
     }
 
   delete [] id;
 
   return names;
 }
 
 // XXX FIXME XXX -- make this generate file names when appropriate.
 
-static char **
+static const char **
 generate_possible_completions (const char *text, char *& prefix,
 			       char *& hint)
 {
-  char **names = 0;
+  const char **names = 0;
 
   prefix = 0;
 
   if (text && *text && *text != '.' && strrchr (text, '.'))
     names = generate_struct_completions (text, prefix, hint);
   else
-    names = make_name_list ();
+    {
+      string_vector tmp_names = make_name_list ();
+
+      int n = tmp_names.length ();
+
+      if (n > 0)
+	{
+	  names = new const char * [n+1];
+	  for (int i = 0; i < n; i++)
+	    names[i] = strsave (tmp_names[i].c_str ());
+	  names[n] = 0;
+	}
+    }
 
   return names;
 }
 
 static int
 looks_like_struct (const char *nm)
 {
   int retval = 0;
@@ -780,27 +763,28 @@ command_generator (const char *text, int
 {
   static char *prefix = 0;
   static char *hint = 0;
 
   static int prefix_len = 0;
   static int hint_len = 0;
 
   static int list_index = 0;
-  static char **name_list = 0;
+  static const char **name_list = 0;
 
   static int matches = 0;
 
   if (state == 0)
     {
       list_index = 0;
 
       if (name_list)
 	{
-	  char **ptr = name_list;
+	  const char **ptr = name_list;
+
 	  while (ptr && *ptr)
 	    delete [] *ptr++;
 
 	  delete [] name_list;
 
 	  name_list = 0;
 	}
 
@@ -826,17 +810,18 @@ command_generator (const char *text, int
 	  while (name_list[i])
 	    if (strncmp (name_list[i++], hint, hint_len) == 0)
 	      matches++;
 	}
     }
 
   if (name_list && matches)
     {
-      char *name;
+      const char *name;
+
       while ((name = name_list[list_index]) != 0)
 	{
 	  list_index++;
 	  if (strncmp (name, hint, hint_len) == 0)
 	    {
 	      int len = 2 + prefix_len + strlen (name);
 	      char *buf = (char *) malloc (len);
 
@@ -1123,62 +1108,67 @@ DEFUN_TEXT("echo", Fecho, Secho, 10,
 \n\
   echo [on all|off all] -- enable or disable echoing of commands as they\n\
                            are executed in script files and functions\n\
 \n\
 Without any arguments, toggle the current echo state.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV ("echo");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "echo");
+
+  if (error_state)
+    return retval;
 
   switch (argc)
     {
     case 1:
       {
 	int echo_cmds = user_pref.echo_executing_commands;
 	if ((echo_cmds & ECHO_SCRIPTS) || (echo_cmds & ECHO_FUNCTIONS))
 	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
 	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
       }
       break;
 
     case 2:
       {
-	char *arg = argv[1];
-	if (strcmp (arg, "on") == 0)
+	string arg = argv[1];
+
+	if (arg == "on")
 	  bind_builtin_variable ("echo_executing_commands", ECHO_SCRIPTS);
-	else if (strcmp (arg, "off") == 0)
+	else if (arg == "off")
 	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
 	  print_usage ("echo");
       }
       break;
 
     case 3:
       {
-	char *arg = argv[1];
-	if (strcmp (arg, "on") == 0 && strcmp (argv[2], "all") == 0)
+	string arg = argv[1];
+
+	if (arg == "on" && argv[2] == "all")
 	  bind_builtin_variable ("echo_executing_commands",
 				 (ECHO_SCRIPTS | ECHO_FUNCTIONS));
-	else if (strcmp (arg, "off") == 0 && strcmp (argv[2], "all") == 0)
+	else if (arg == "off" && argv[2] == "all")
 	  bind_builtin_variable ("echo_executing_commands", ECHO_OFF);
 	else
 	  print_usage ("echo");
       }
       break;
 
     default:
       print_usage ("echo");
       break;
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -25,35 +25,35 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_input_h)
 #define octave_input_h 1
 
 #include <cstdio>
 
 #include <string>
 
-extern int octave_read (char *buf, int max_size);
+extern int octave_read (char *buf, unsigned max_size);
 extern FILE *get_input_from_file (const string& name, int warn = 1);
 extern FILE *get_input_from_stdin (void);
 extern void initialize_readline (void);
 
 // Global pointer for eval().
-extern const char *current_eval_string;
+extern string current_eval_string;
 
 // Nonzero means get input from current_eval_string.
 extern int get_input_from_eval_string;
 
 // Nonzero means we're parsing a function file.
 extern int reading_fcn_file;
 
 // Simple name of function file we are reading.
-extern const char *curr_fcn_file_name;
+extern string curr_fcn_file_name;
 
 // Full name of file we are reading.
-extern const char *curr_fcn_file_full_name;
+extern string curr_fcn_file_full_name;
 
 // Nonzero means we're parsing a script file.
 extern int reading_script_file;
 
 // If we are reading from an M-file, this is it.
 extern FILE *ff_instream;
 
 // Nonzero means we are using readline.
@@ -64,17 +64,17 @@ extern int interactive;
 
 // Nonzero means the user forced this shell to be interactive (-i).
 extern int forced_interactive;
 
 // Should we issue a prompt?
 extern int promptflag;
 
 // A line of input.
-extern char *current_input_line;
+extern string current_input_line;
 
 char *gnu_readline (const char *s);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -471,17 +471,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
   }
 
 %{
 // Gobble comments.  If closest nesting is inside parentheses, don't
 // return a new line.
 %} 
 
 {CCHAR} {
-    if (! help_buf && beginning_of_function && nesting_level.empty ())
+    if (help_buf.empty () && beginning_of_function && nesting_level.empty ())
       {
 	grab_help_text ();
 	beginning_of_function = 0;
       }
     else
       {
 	int c;
 	while ((c = yyinput ()) != EOF && c != '\n')
@@ -676,19 +676,19 @@ reset_parser (void)
       input_line_number = current_command_number - 1;
     }
 
 // Only ask for input from stdin if we are expecting interactive
 // input.
   if (interactive && ! (reading_fcn_file || get_input_from_eval_string))
     yyrestart (stdin);
 
-// Delete the buffer for help text.
-  delete [] help_buf;
-  help_buf = 0;
+// Clear the buffer for help text.
+
+  help_buf.resize (0);
 }
 
 // Replace backslash escapes in a string with the real values.
 
 static void
 do_string_escapes (char *s)
 {
   char *p1 = s;
@@ -1021,21 +1021,22 @@ is_keyword (char *s)
 	  break;
 
 	case function_kw:
 	  if (defining_func)
 	    {
 	      error ("function keyword invalid within a function body");
 
 	      if ((reading_fcn_file || reading_script_file)
-		  && curr_fcn_file_name)
+		  && ! curr_fcn_file_name.empty ())
 		error ("defining new function near line %d of file `%s.m'",
-		       input_line_number, curr_fcn_file_name);
+		       input_line_number, curr_fcn_file_name.c_str ());
 	      else
-		error ("defining new function near line %d", input_line_number);
+		error ("defining new function near line %d",
+		       input_line_number);
 
 	      return LEXICAL_ERROR;
 	    }
 	  else
 	    {
 	      tmp_local_sym_tab = new symbol_table ();
 	      curr_sym_tab = tmp_local_sym_tab;
 	      defining_func = 1;
@@ -1071,29 +1072,27 @@ lookup_identifier (char *name)
 }
 
 // Grab the help text from an function file.  Always overwrites the
 // current contents of help_buf.
 
 static void
 grab_help_text (void)
 {
-  delete [] help_buf;
-  help_buf = 0;
-
-  ostrstream buf;
+  help_buf.resize (0);
 
   int in_comment = 1;
   int c = 0;
 
   while ((c = yyinput ()) != EOF)
     {
       if (in_comment)
 	{
-	  buf << (char) c;
+	  help_buf += (char) c;
+
 	  if (c == '\n')
 	    in_comment = 0;
 	}
       else
 	{
 	  switch (c)
 	    {
 	    case '%':
@@ -1110,26 +1109,16 @@ grab_help_text (void)
 	    }
 	}
     }
 
  done:
 
   if (c)
     yyunput (c, yytext);
-
-  buf << ends;
-
-  help_buf = buf.str ();
-
-  if (! help_buf || ! *help_buf)
-    {
-      delete [] help_buf;
-      help_buf = 0;
-    }
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
 
 static int
 match_any (char c, char *s)
 {
@@ -1829,17 +1818,17 @@ check_for_garbage_after_fcn_def (void)
 	  break;
 
 	default:
 	  if (in_comment)
 	    break;
 	  else
 	    {
 	      warning ("ignoring trailing garbage after end of function\n\
-         near line %d of file `%s.m'", lineno, curr_fcn_file_name);
+         near line %d of file `%s.m'", lineno, curr_fcn_file_name.c_str ());
 	      
 	      yyunput ('\n', yytext);
 	      return;
 	    }
 	}
     }
   yyunput ('\n', yytext);
 }
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -33,16 +33,18 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 #include <iostream.h>
 #include <fstream.h>
 #include <strstream.h>
 
 #include "fnmatch.h"
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "load-save.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "pager.h"
@@ -1251,37 +1253,39 @@ extract_keyword (istream& is, char *keyw
 //  string
 //  # length: 5
 //  array
 //
 // XXX FIXME XXX -- this format is fairly rigid, and doesn't allow for
 // arbitrary comments, etc.  Someone should fix that.
 
 static char *
-read_ascii_data (istream& is, const char *filename, int& global,
+read_ascii_data (istream& is, const string& filename, int& global,
 		 tree_constant& tc)
 {
   // Read name for this entry or break on EOF.
 
   char *name = extract_keyword (is, "name");
 
   if (! name)
     return 0;
 
   if (! *name)
     {
-      error ("load: empty name keyword found in file `%s'", filename);
+      error ("load: empty name keyword found in file `%s'",
+	     filename.c_str ());
       delete [] name;
       return 0;
     }
       
 
   if (! valid_identifier (name))
     {
-      error ("load: bogus identifier `%s' found in file `%s'", name, filename);
+      error ("load: bogus identifier `%s' found in file `%s'", name,
+	     filename.c_str ());
       delete [] name;
       return 0;
     }
 
   // Look for type keyword.
 
   char *tag = extract_keyword (is, "type");
 
@@ -1434,17 +1438,17 @@ read_ascii_data (istream& is, const char
     }
   else
     error ("load: failed to extract keyword specifying value type");
 
   delete [] tag;
 
   if (error_state)
     {
-      error ("load: reading file %s", filename);
+      error ("load: reading file %s", filename.c_str ());
       return 0;
     }
 
   return name;
 }
 
 // Extract one value (scalar, matrix, string, etc.) from stream IS and
 // place it in TC, returning the name of the variable.  If the value
@@ -1513,17 +1517,17 @@ read_ascii_data (istream& is, const char
 //       for each element:
 //         length         int                 4
 //         data           string         length
 //
 // FILENAME is used for error messages.
 
 static char *
 read_binary_data (istream& is, int swap, floating_point_format fmt,
-		  const char *filename, int& global,
+		  const string& filename, int& global,
 		  tree_constant& tc, char *&doc)
 {
   char tmp = 0;
 
   FOUR_BYTE_INT name_len = 0, doc_len = 0;
   char *name = 0;
 
   doc = 0;
@@ -1705,17 +1709,17 @@ read_binary_data (istream& is, int swap,
 	    delete [] tmp;
 	  }
 	tc = chm;
       }
       break;
 
     default:
     data_read_error:
-      error ("load: trouble reading binary file `%s'", filename);
+      error ("load: trouble reading binary file `%s'", filename.c_str ());
       delete [] name;
       name = 0;
       break;
     }
 
   return name;
 }
 
@@ -1871,17 +1875,17 @@ get_floating_point_format (int mach)
 // The data is expected to be in Matlab's .mat format, though not all
 // the features of that format are supported.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 static char *
-read_mat_binary_data (istream& is, const char *filename,
+read_mat_binary_data (istream& is, const string& filename,
 		      tree_constant& tc)
 {
   // These are initialized here instead of closer to where they are
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   Matrix re;
   floating_point_format flt_fmt = OCTAVE_UNKNOWN_FLT_FMT;
@@ -1966,29 +1970,30 @@ read_mat_binary_data (istream& is, const
     tc = re;
 
   if (type == 1)
     tc = tc.convert_to_str ();
 
   return name;
 
  data_read_error:
-  error ("load: trouble reading binary file `%s'", filename);
+  error ("load: trouble reading binary file `%s'", filename.c_str ());
   delete [] name;
   return 0;
 }
 
 // Return nonzero if NAME matches one of the given globbing PATTERNS.
 
 static int
-matches_patterns (char **patterns, int num_pat, char *name)
+matches_patterns (const string_vector& patterns, int pat_idx,
+		  int num_pat, char *name)
 {
-  while (num_pat-- > 0)
+  for (int i = pat_idx; i < num_pat; i++)
     {
-      if (fnmatch (*patterns++, name, __FNM_FLAGS) == 0)
+      if (fnmatch (patterns[i].c_str (), name, __FNM_FLAGS) == 0)
 	return 1;
     }
   return 0;
 }
 
 static int
 read_binary_file_header (istream& is, int& swap,
 			 floating_point_format& flt_fmt, int quiet = 0) 
@@ -2069,20 +2074,20 @@ get_file_format (const string& fname, co
   if (retval == LS_UNKNOWN)
     error ("load: unable to determine file format for `%s'",
 	   orig_fname.c_str ());
 
   return retval;
 }
 
 static Octave_object
-do_load (istream& stream, const char *orig_fname, int force,
+do_load (istream& stream, const string& orig_fname, int force,
 	 load_save_format format, floating_point_format flt_fmt,
-	 int list_only, int swap, int verbose, char **argv,
-	 int argc, int nargout)
+	 int list_only, int swap, int verbose, const string_vector& argv,
+	 int argv_idx, int argc, int nargout)
 {
   Octave_object retval;
 
   ostrstream output_buf;
   int count = 0;
   for (;;)
     {
       int global = 0;
@@ -2116,17 +2121,18 @@ do_load (istream& stream, const char *or
 	  delete [] name;
 	  delete [] doc;
 	  break;
 	}
       else if (! error_state && name)
 	{
 	  if (tc.is_defined ())
 	    {
-	      if (argc == 0 || matches_patterns (argv, argc, name))
+	      if (argv_idx == argc
+		  || matches_patterns (argv, argv_idx, argc, name))
 		{
 		  count++;
 		  if (list_only)
 		    {
 		      if (verbose)
 			{
 			  if (count == 1)
 			    output_buf
@@ -2148,17 +2154,17 @@ do_load (istream& stream, const char *or
 	    }
 	  else
 	    error ("load: unable to load variable `%s'", name);
 	}
       else
 	{
 	  if (count == 0)
 	    error ("load: are you sure `%s' is an Octave data file?",
-		   orig_fname);
+		   orig_fname.c_str ());
 
 	  delete [] name;
 	  delete [] doc;
 	  break;
 	}
 
       delete [] name;
       delete [] doc;
@@ -2189,180 +2195,168 @@ If no argument is supplied to select a f
 named file as an Octave binary, then as a .mat file, and then as an
 Octave text file.\n\
 \n\
 If the option -force is given, variables with the same names as those
 found in the file will be replaced with the values read from the file.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV ("load");
-
-  argc--;
-  argv++;
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "load");
+
+  if (error_state)
+    return retval;
 
   int force = 0;
 
   // It isn't necessary to have the default load format stored in a
   // user preference variable since we can determine the type of file
   // as we are reading.
 
   load_save_format format = LS_UNKNOWN;
 
   int list_only = 0;
   int verbose = 0;
 
-  while (argc > 0)
+  int i;
+  for (i = 1; i < argc; i++)
     {
-      if (strcmp (*argv, "-force") == 0 || strcmp (*argv, "-f") == 0)
+      if (argv[i] == "-force" || argv[i] == "-f")
 	{
 	  force++;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-list") == 0 || strcmp (*argv, "-l") == 0)
+      else if (argv[i] == "-list" || argv[i] == "-l")
 	{
 	  list_only = 1;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-verbose") == 0 || strcmp (*argv, "-v") == 0)
+      else if (argv[i] == "-verbose" || argv[i] == "-v")
 	{
 	  verbose = 1;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-ascii") == 0 || strcmp (*argv, "-a") == 0)
+      else if (argv[i] == "-ascii" || argv[i] == "-a")
 	{
 	  format = LS_ASCII;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-binary") == 0 || strcmp (*argv, "-b") == 0)
+      else if (argv[i] == "-binary" || argv[i] == "-b")
 	{
 	  format = LS_BINARY;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-mat-binary") == 0 || strcmp (*argv, "-m") == 0)
+      else if (argv[i] == "-mat-binary" || argv[i] == "-m")
 	{
 	  format = LS_MAT_BINARY;
-	  argc--;
-	  argv++;
 	}
       else
 	break;
     }
 
-  if (argc < 1)
+  if (i == argc)
     {
       error ("load: you must specify a single file to read");
-      DELETE_ARGV;
       return retval;
     }
 
-  char *orig_fname = *argv;
+  string orig_fname = argv[i];
 
   floating_point_format flt_fmt = OCTAVE_UNKNOWN_FLT_FMT;
 
   int swap = 0;
 
-  if (strcmp (*argv, "-") == 0)
+  if (argv[i] == "-")
     {
-      argc--;
-      argv++;
+      i++;
 
       if (format != LS_UNKNOWN)
 	{
 	  // XXX FIXME XXX -- if we have already seen EOF on a
 	  // previous call, how do we fix up the state of cin so that
 	  // we can get additional input?  I'm afraid that we can't
 	  // fix this using cin only.
 
 	  retval = do_load (cin, orig_fname, force, format, flt_fmt,
-			    list_only, swap, verbose, argv, argc,
+			    list_only, swap, verbose, argv, i, argc,
 			    nargout);
 	}
       else
 	error ("load: must specify file format if reading from stdin");
     }
   else
     {
-      string fname = oct_tilde_expand (*argv);
+      string fname = oct_tilde_expand (argv[i]);
 
       if (format == LS_UNKNOWN)
 	format = get_file_format (fname, orig_fname);
 
       if (format != LS_UNKNOWN)
 	{
-	  argv++;
-	  argc--;
+	  i++;
 
 	  unsigned mode = ios::in;
 	  if (format == LS_BINARY || format == LS_MAT_BINARY)
 	    mode |= ios::bin;
 
 	  ifstream file (fname.c_str (), mode);
 
 	  if (file)
 	    {
 	      if (format == LS_BINARY)
 		{
 		  if (read_binary_file_header (file, swap, flt_fmt) < 0)
 		    {
 		      file.close ();
-		      DELETE_ARGV;
 		      return retval;
 		    }
 		}
 
 	      retval = do_load (file, orig_fname, force, format,
 				flt_fmt, list_only, swap, verbose,
-				argv, argc, nargout);
+				argv, i, argc, nargout);
 
 	      file.close ();
 	    }
 	  else
-	    error ("load: couldn't open input file `%s'", orig_fname);
+	    error ("load: couldn't open input file `%s'",
+		   orig_fname.c_str ());
 	}
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 // Return nonzero if PATTERN has any special globbing chars in it.
 
 static int
-glob_pattern_p (char *pattern)
+glob_pattern_p (const string& pattern)
 {
-  char *p = pattern;
-  char c;
   int open = 0;
 
-  while ((c = *p++) != '\0')
+  int len = pattern.length ();
+
+  for (int i = 0; i < len; i++)
     {
+      char c = pattern[i];
+
       switch (c)
 	{
 	case '?':
 	case '*':
 	  return 1;
 
 	case '[':	// Only accept an open brace if there is a close
 	  open++;	// brace to match it.  Bracket expressions must be
 	  continue;	// complete, according to Posix.2
 
 	case ']':
 	  if (open)
 	    return 1;
 	  continue;
 	  
 	case '\\':
-	  if (*p++ == '\0')
+	  if (i == len - 1)
 	    return 0;
 
 	default:
 	  continue;
 	}
     }
 
   return 0;
@@ -2392,34 +2386,31 @@ get_save_type (double max_val, double mi
   return st;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 static int
-save_binary_data (ostream& os, const tree_constant& tc, char *name,
-		  char *doc, int mark_as_global, int save_as_floats) 
+save_binary_data (ostream& os, const tree_constant& tc,
+		  const string& name, const string& doc,
+		  int mark_as_global, int save_as_floats) 
 {
   int fail = 0;
 
-  FOUR_BYTE_INT name_len = 0;
-  if (name)
-    name_len = strlen (name);
+  FOUR_BYTE_INT name_len = name.length ();
 
   os.write (&name_len, 4);
-  os.write (name, name_len);
-
-  FOUR_BYTE_INT doc_len = 0;
-  if (doc)
-    doc_len = strlen (doc);
+  os << name;
+
+  FOUR_BYTE_INT doc_len = doc.length ();
 
   os.write (&doc_len, 4);
-  os.write (doc, doc_len);
+  os << doc;
 
   char tmp;
 
   tmp = mark_as_global;
   os.write (&tmp, 1);
 
   if (tc.is_real_scalar ())
     {
@@ -2537,17 +2528,18 @@ save_binary_data (ostream& os, const tre
 
   return (os && ! fail);
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS 
 // in the MatLab binary format.
 
 static int
-save_mat_binary_data (ostream& os, const tree_constant& tc, char *name) 
+save_mat_binary_data (ostream& os, const tree_constant& tc,
+		      const string& name) 
 {
   int fail = 0;
 
   FOUR_BYTE_INT mopt = 0;
 
   mopt += tc.is_string () ? 1 : 0;
   mopt += 1000 * get_floating_point_format (native_float_format);
 
@@ -2559,20 +2551,20 @@ save_mat_binary_data (ostream& os, const
   FOUR_BYTE_INT nc = tc.columns ();
   os.write (&nc, 4);
 
   int len = nr * nc;
 
   FOUR_BYTE_INT imag = tc.is_complex_type () ? 1 : 0;
   os.write (&imag, 4);
 
-  FOUR_BYTE_INT name_len = name ? strlen (name) + 1 : 0;
+  FOUR_BYTE_INT name_len = name.length ();
 
   os.write (&name_len, 4);
-  os.write (name, name_len);
+  os << name;
 
   if (tc.is_real_scalar ())
     {
       double tmp = tc.double_value ();
       os.write (&tmp, 8);
     }
   else if (tc.is_real_matrix ())
     {
@@ -2700,40 +2692,40 @@ strip_infnan (const ComplexMatrix& m)
   if (k > 0)
     retval.resize (k, nc);
 
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME, and global
 // flag MARK_AS_GLOBAL on stream OS in the plain text format described
-// above for load_ascii_data.  If NAME is null, the name: line is not
+// above for load_ascii_data.  If NAME is empty, the name: line is not
 // generated.  PRECISION specifies the number of decimal digits to print. 
 // If STRIP_NAN_AND_INF is nonzero, rows containing NaNs are deleted,
 // and Infinite values are converted to +/-OCT_RBV (A Real Big Value,
 // but not so big that gnuplot can't handle it when trying to compute
 // axis ranges, etc.).
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // XXX FIXME XXX -- should probably write the help string here too.
 
 int
 save_ascii_data (ostream& os, const tree_constant& tc,
-		 char *name, int strip_nan_and_inf,
+		 const string& name, int strip_nan_and_inf,
 		 int mark_as_global, int precision) 
 {
   int success = 1;
 
   if (! precision)
     precision = user_pref.save_precision;
 
-  if (name)
+  if (! name.empty ())
     os << "# name: " << name << "\n";
 
   long old_precision = os.precision ();
   os.precision (precision);
 
   if (tc.is_real_scalar ())
     {
       ascii_save_type (os, "scalar", mark_as_global);
@@ -2850,22 +2842,22 @@ do_save (ostream& os, symbol_record *sr,
 	 int save_as_floats)
 {
   if (! sr->is_variable ())
     {
       error ("save: can only save variables, not functions");
       return;
     }
 
-  char *name = sr->name ();
-  char *help = sr->help ();
+  string name = sr->name ();
+  string help = sr->help ();
   int global = sr->is_linked_to_global ();
   tree_constant tc = *((tree_constant *) sr->def ());
 
-  if (! name || ! tc.is_defined ())
+  if (tc.is_undefined ())
     return;
 
   switch (fmt)
     {
     case LS_ASCII:
       save_ascii_data (os, tc, name, 0, global);
       break;
 
@@ -2883,17 +2875,17 @@ do_save (ostream& os, symbol_record *sr,
     }
 }
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.  If SAVE_BUILTINS is nonzero, also save
 // builtin variables with names that match PATTERN.
 
 static int
-save_vars (ostream& os, char *pattern, int save_builtins,
+save_vars (ostream& os, const string& pattern, int save_builtins,
 	   load_save_format fmt, int save_as_floats)
 {
   int count;
 
   symbol_record **vars = curr_sym_tab->glob
     (count, pattern, symbol_def::USER_VARIABLE, SYMTAB_ALL_SCOPES);
 
   int saved = count;
@@ -2931,22 +2923,21 @@ save_vars (ostream& os, char *pattern, i
   return saved;
 }
 
 static load_save_format
 get_default_save_format (void)
 {
   load_save_format retval = LS_ASCII;
 
-  char *fmt = user_pref.default_save_format;
-
-  if (strcasecmp (fmt, "binary") == 0)
+  string fmt = user_pref.default_save_format;
+
+  if (fmt == "binary")
     retval = LS_BINARY;
-  else if (strcasecmp (fmt, "mat-binary") == 0
-	   || strcasecmp (fmt, "mat_binary") == 0)
+  else if (fmt == "mat-binary" || fmt =="mat_binary")
     retval = LS_MAT_BINARY;
       
   return retval;
 }
 
 static void
 write_binary_header (ostream& stream, load_save_format format)
 {
@@ -2955,35 +2946,34 @@ write_binary_header (ostream& stream, lo
       stream << (octave_words_big_endian ? "Octave-1-B" : "Octave-1-L");
 
       char tmp = (char) native_float_format;
       stream.write (&tmp, 1);
     }
 }
 
 static void
-save_vars (char **argv, int argc, ostream& os, int save_builtins,
-	   load_save_format fmt, int save_as_floats)
+save_vars (const string_vector& argv, int argv_idx, int argc,
+	   ostream& os, int save_builtins, load_save_format fmt,
+	   int save_as_floats) 
 {
   write_binary_header (os, fmt);
 
-  if (argc == 0)
+  if (argv_idx == argc)
     {
       save_vars (os, "*", save_builtins, fmt, save_as_floats);
     }
   else
     {
-      while (argc-- > 0)
+      for (int i = argv_idx; i < argc; i++)
 	{
-	  if (! save_vars (os, *argv, save_builtins, fmt, save_as_floats))
+	  if (! save_vars (os, argv[i], save_builtins, fmt, save_as_floats))
 	    {
-	      warning ("save: no such variable `%s'", *argv);
+	      warning ("save: no such variable `%s'", argv[i].c_str ());
 	    }
-
-	  argv++;
 	}
     }
 }
 
 void
 save_user_variables (void)
 {
   // XXX FIXME XXX -- should choose better file name?
@@ -2997,146 +2987,133 @@ save_user_variables (void)
   unsigned mode = ios::out|ios::trunc;
   if (format == LS_BINARY || format == LS_MAT_BINARY)
     mode |= ios::bin;
 
   ofstream file (fname, mode);
 
   if (file)
     {
-      save_vars (0, 0, file, 0, format, 0);
+      save_vars (string_vector (), 0, 0, file, 0, format, 0);
       message (0, "save to `%s' complete", fname);
     }
   else
     warning ("unable to open `%s' for writing...", fname);
 }
 
 DEFUN_TEXT ("save", Fsave, Ssave, 10,
   "save [-ascii] [-binary] [-float-binary] [-mat-binary] \n\
      [-save-builtins] file [pattern ...]\n\
 \n\
 save variables in a file")
 {
   Octave_object retval;
 
-  DEFINE_ARGV ("save");
-
-  argc--;
-  argv++;
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "save");
+
+  if (error_state)
+    return retval;
 
   // Here is where we would get the default save format if it were
   // stored in a user preference variable.
 
   int save_builtins = 0;
 
   int save_as_floats = 0;
 
   load_save_format format = get_default_save_format ();
 
-  while (argc > 0)
+  int i;
+  for (i = 1; i < argc; i++)
     {
-      if (strcmp (*argv, "-ascii") == 0 || strcmp (*argv, "-a") == 0)
+      if (argv[i] == "-ascii" || argv[i] == "-a")
 	{
 	  format = LS_ASCII;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-binary") == 0 || strcmp (*argv, "-b") == 0)
+      else if (argv[i] == "-binary" || argv[i] == "-b")
 	{
 	  format = LS_BINARY;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-mat-binary") == 0 || strcmp (*argv, "-m") == 0)
+      else if (argv[i] == "-mat-binary" || argv[i] == "-m")
 	{
 	  format = LS_MAT_BINARY;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-float-binary") == 0
-	       || strcmp (*argv, "-f") == 0)
+      else if (argv[i] == "-float-binary" || argv[i] == "-f")
 	{
 	  format = LS_BINARY;
 	  save_as_floats = 1;
-	  argc--;
-	  argv++;
 	}
-      else if (strcmp (*argv, "-save-builtins") == 0)
+      else if (argv[i] == "-save-builtins")
 	{
 	  save_builtins = 1;
-	  argc--;
-	  argv++;
 	}
       else
 	break;
     }
 
   if (argc < 1)
     {
       print_usage ("save");
-      DELETE_ARGV;
       return retval;
     }
 
   if (save_as_floats && format == LS_ASCII)
     {
       error ("save: cannot specify both -ascii and -float-binary");
-      DELETE_ARGV;
       return retval;
     }
 
-  if (strcmp (*argv, "-") == 0)
+  if (argv[i] == "-")
     {
-      argc--;
-      argv++;
+      i++;
 
       // XXX FIXME XXX -- should things intended for the screen end up
       // in a tree_constant (string)?
 
       ostrstream buf;
 
-      save_vars (argv, argc, buf, save_builtins, format,
+      save_vars (argv, i, argc, buf, save_builtins, format,
 		 save_as_floats);
 
       maybe_page_output (buf);
     }
-  else if (argc == 1 && glob_pattern_p (*argv)) // Guard against things
-    {						// like `save a*',
-      print_usage ("save");			// which are probably
-      DELETE_ARGV;				// mistakes...
+
+  // Guard against things like `save a*', which are probably mistakes...
+
+  else if (i == argc - 1 && glob_pattern_p (argv[i]))
+    {
+      print_usage ("save");
       return retval;
     }
   else
     {
-      string fname = oct_tilde_expand (*argv);
-
-      argc--;
-      argv++;
+      string fname = oct_tilde_expand (argv[i]);
+
+      i++;
 
       unsigned mode = ios::out|ios::trunc;
       if (format == LS_BINARY || format == LS_MAT_BINARY)
 	mode |= ios::bin;
 
       ofstream file (fname.c_str (), mode);
 
       if (file)
 	{
-	  save_vars (argv, argc, file, save_builtins, format,
+	  save_vars (argv, i, argc, file, save_builtins, format,
 		     save_as_floats);
 	}
       else
 	{
-	  error ("save: couldn't open output file `%s'", *argv);
-	  DELETE_ARGV;
+	  error ("save: couldn't open output file `%s'", fname.c_str ());
 	  return retval;
 	}
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 // Maybe this should be a static function in tree-plot.cc?
 
 // If TC is matrix, save it on stream OS in a format useful for
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
 // nonzero, assume a parametric 3-dimensional plot will be generated.
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -23,18 +23,21 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_load_save_h)
 #define octave_load_save_h 1
 
 class ostream;
 
 class tree_constant;
 
+#include <string>
+
 extern int save_ascii_data (ostream& os, const tree_constant& t,
-			    char *name = 0, int strip_nan_and_inf = 0,
+			    const string& name = string (),
+			    int strip_nan_and_inf = 0,
 			    int mark_as_global = 0, int precision = 0);
 
 extern int save_three_d (ostream& os, const tree_constant& t,
 			 int parametric = 0);
 
 extern void save_user_variables (void);
 
 #endif
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -252,53 +252,53 @@ print_lsode_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_lsode_option (const char *keyword, double val)
+set_lsode_option (const string& keyword, double val)
 {
   ODE_OPTIONS *list = lsode_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (lsode_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
-  warning ("lsode_options: no match for `%s'", keyword);
+  warning ("lsode_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_lsode_option (const char *keyword)
+show_lsode_option (const string& keyword)
 {
   Octave_object retval;
 
   ODE_OPTIONS *list = lsode_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  return (lsode_opts.*list->d_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("lsode_options: no match for `%s'", keyword);
+  warning ("lsode_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("lsode_options", Flsode_options, Slsode_options,
 		   FSlsode_options, 10,
   "lsode_options (KEYWORD, VALUE)\n\
 \n\
@@ -311,18 +311,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_lsode_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_lsode_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/mappers.h b/src/mappers.h
--- a/src/mappers.h
+++ b/src/mappers.h
@@ -19,51 +19,60 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_mappers_h)
 #define octave_mappers_h 1
 
+#include <string>
+
 #include "oct-cmplx.h"
 
 typedef double (*d_d_Mapper)(double);
 typedef double (*d_c_Mapper)(const Complex&);
 typedef Complex (*c_c_Mapper)(const Complex&);
 
 // If can_return_complex_for_real_arg is 1, lower_limit and
 // upper_limit specify the range of values for which a real arg
 // returns a real value.  Outside that range, we have to convert args
 // to complex, and call the complex valued function.
 //
 // If can_return_complex_for_real_arg is 0, lower_limit and
 // upper_limit are ignored.
 
 struct Mapper_fcn
 {
-  char *name;
+  string name;
   int can_return_complex_for_real_arg;
   double lower_limit;
   double upper_limit;
   d_d_Mapper d_d_mapper;
   d_c_Mapper d_c_mapper;
   c_c_Mapper c_c_mapper;
 };
 
 struct builtin_mapper_function
 {
-  char *name;
+  builtin_mapper_function (const string n, int cfr, double l, double u,
+			   d_d_Mapper dd, d_c_Mapper dc, c_c_Mapper cc,
+			   const string& h)
+    : name (n), can_return_complex_for_real_arg (cfr),
+      lower_limit (l), upper_limit (u), d_d_mapper (dd),
+      d_c_mapper (dc), c_c_mapper (cc), help_string (h) { }
+
+  string name;
   int can_return_complex_for_real_arg;
   double lower_limit;
   double upper_limit;
   d_d_Mapper d_d_mapper;
   d_c_Mapper d_c_mapper;
   c_c_Mapper c_c_mapper;
-  char *help_string;
+  string help_string;
 };
 
 extern double arg (double x);
 extern double conj (double x);
 extern double fix (double x);
 extern double imag (double x);
 extern double real (double x);
 extern double round (double x);
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -711,47 +711,47 @@ print_npsol_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_npsol_option (const char *keyword, double val)
+set_npsol_option (const string& keyword, double val)
 {
   NPSOL_OPTIONS *list = npsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  if (list->d_set_fcn)
 	    (npsol_opts.*list->d_set_fcn) (val);
 	  else
 	    {
 	      if (xisnan (val))
 		{
 		  error ("npsol_options: %s: expecting integer, found NaN",
-			 keyword);
+			 keyword.c_str ());
 		}
 	      else
 		(npsol_opts.*list->i_set_fcn) (NINT (val));
 	    }
 	  return;
 	}
       list++;
     }
 
-  warning ("npsol_options: no match for `%s'", keyword);
+  warning ("npsol_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_npsol_option (const char *keyword)
+show_npsol_option (const string& keyword)
 {
   Octave_object retval;
 
   NPSOL_OPTIONS *list = npsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -760,17 +760,17 @@ show_npsol_option (const char *keyword)
 	  if (list->d_get_fcn)
 	    return (npsol_opts.*list->d_get_fcn) ();
 	  else
 	    return (double) (npsol_opts.*list->i_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("npsol_options: no match for `%s'", keyword);
+  warning ("npsol_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 #endif
 
 #if defined (NPSOL_MISSING)
 DEFUN_DLD_BUILTIN ("npsol_options", Fnpsol_options, Snpsol_options,
@@ -799,18 +799,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_npsol_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_npsol_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -45,16 +45,18 @@ Software Foundation, Inc.
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include <fcntl.h>
 
 #include <readline/history.h>
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "oct-hist.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "sighandlers.h"
 #include "statdefs.h"
@@ -85,34 +87,41 @@ default_history_size (void)
     {
       int val;
       if (sscanf (env_size, "%d", &val) == 1)
 	size = val > 0 ? val : 0;
     }
   return size;
 }
 
-char *
+string
 default_history_file (void)
 {
-  char *file = 0;
+  string file;
 
   char *env_file = getenv ("OCTAVE_HISTFILE");
+
   if (env_file)
     {
       fstream f (env_file, (ios::in | ios::out));
+
       if (f)
 	{
-	  file = strsave (env_file);
+	  file = env_file;
 	  f.close ();
 	}
     }
 
-  if (! file && home_directory)
-    file = strconcat (home_directory, "/.octave_hist");
+  if (file.empty ())
+    {
+      if (! home_directory.empty ())
+	file = home_directory.append ("/.octave_hist");
+      else
+	file = ".octave_hist";
+    }
 
   return file;
 }
 
 // Prime the history list.
 
 void
 initialize_history (void)
@@ -133,56 +142,55 @@ clean_up_history (void)
 
   string file = oct_tilde_expand (user_pref.history_file);
 
   if (user_pref.saving_history)
     write_history (file.c_str ());
 }
 
 void
-maybe_save_history (const char *s)
+maybe_save_history (const string& s)
 {
   if (user_pref.saving_history && ! input_from_startup_file)
     {
-      add_history (s);
+      add_history (s.c_str ());
       history_lines_this_session++;
     }
 }
 
 // Display, save, or load history.  Stolen and modified from bash.
 //
 // Arg of -w FILENAME means write file, arg of -r FILENAME
 // means read file, arg of -q means don't number lines.  Arg of N
 // means only display that many items. 
 
-void
-do_history (int argc, char **argv)
+static void
+do_history (int argc, const string_vector& argv)
 {
   HIST_ENTRY **hlist;
 
   int numbered_output = 1;
 
-  while (--argc > 0)
+  int i;
+  for (i = 1; i < argc; i++)
     {
-      argv++;
-
-      if (*argv[0] == '-' && strlen (*argv) == 2
-	  && ((*argv)[1] == 'r' || (*argv)[1] == 'w'
-	      || (*argv)[1] == 'a' || (*argv)[1] == 'n'))
+      if (argv[i][0] == '-' && argv[i].length () == 2
+	  && (argv[i][1] == 'r' || argv[i][1] == 'w'
+	      || argv[i][1] == 'a' || argv[i][1] == 'n'))
 	{
 	  int result = 0;
 
 	  string file;
 
-	  if (argc > 1)
-	    file = oct_tilde_expand (*(argv+1));
+	  if (i < argc - 1)
+	    file = oct_tilde_expand (argv[i+1]);
 	  else
 	    file = oct_tilde_expand (user_pref.history_file);
 
-	  switch ((*argv)[1])
+	  switch (argv[i][1])
 	    {
 	    case 'a':		// Append `new' lines to file.
 	      {
 		if (history_lines_this_session)
 		  {
 		    if (history_lines_this_session < where_history ())
 		      {
 			// Create file if it doesn't already exist.
@@ -225,40 +233,39 @@ do_history (int argc, char **argv)
 	      result = read_history_range (file.c_str (),
 					   history_lines_in_file, -1);
 	      using_history ();
 	      history_lines_in_file = where_history ();
 	      break;
 	    }
 	  return;
 	}
-      else if (strcmp (*argv, "-q") == 0)
+      else if (argv[i] == "-q")
 	numbered_output = 0;
-      else if (strcmp (*argv, "--") == 0)
+      else if (argv[i] == "--")
 	{
-	  argc--;
-	  argv++;
+	  i++;
 	  break;
 	}
       else
 	break;
     }
 
   int limited = 0;
   int limit = 0;
 
-  if (argc > 0)
+  if (i < argc)
     {
       limited = 1;
-      if (sscanf (*argv, "%d", &limit) != 1)
+      if (sscanf (argv[i].c_str (), "%d", &limit) != 1)
         {
-	  if (*argv[0] == '-')
-	    error ("history: unrecognized option `%s'", *argv);
+	  if (argv[i][0] == '-')
+	    error ("history: unrecognized option `%s'", argv[i].c_str ());
 	  else
-	    error ("history: bad non-numeric arg `%s'", *argv);
+	    error ("history: bad non-numeric arg `%s'", argv[i].c_str ());
 	  return;
         }
     }
 
   hlist = history_list ();
 
   if (hlist)
     {
@@ -415,18 +422,19 @@ edit_history_add_hist (char *line)
 
       if (line[0] != '\0')
 	add_history (line);
     }
 }
 
 #define histline(i) (hlist[(i)]->line)
 
-static char *
-mk_tmp_hist_file (int argc, char **argv, int insert_curr, char *warn_for)
+static string
+mk_tmp_hist_file (int argc, const string_vector& argv,
+		  int insert_curr, char *warn_for) 
 {
   HIST_ENTRY **hlist;
 
   hlist = history_list ();
 
   int hist_count = 0;
 
   while (hlist[hist_count++])
@@ -447,30 +455,28 @@ mk_tmp_hist_file (int argc, char **argv,
   int hist_beg = hist_count;
   int reverse = 0;
 
   // Process options.
 
   int usage_error = 0;
   if (argc == 3)
     {
-      argv++;
-      if (sscanf (*argv++, "%d", &hist_beg) != 1
-	  || sscanf (*argv, "%d", &hist_end) != 1)
+      if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1
+	  || sscanf (argv[2].c_str (), "%d", &hist_end) != 1)
 	usage_error = 1;
       else
 	{
 	  hist_beg--;
 	  hist_end--;
 	}
     }
   else if (argc == 2)
     {
-      argv++;
-      if (sscanf (*argv++, "%d", &hist_beg) != 1)
+      if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1)
 	usage_error = 1;
       else
 	{
 	  hist_beg--;
 	  hist_end = hist_beg;
 	}
     }
 
@@ -490,48 +496,49 @@ mk_tmp_hist_file (int argc, char **argv,
   if (hist_end < hist_beg)
     {
       int t = hist_end;
       hist_end = hist_beg;
       hist_beg = t;
       reverse = 1;
     }
 
-  char *name = octave_tmp_file_name ();
+  string name = octave_tmp_file_name ();
 
-  fstream file (name, ios::out);
+  fstream file (name.c_str (), ios::out);
 
   if (! file)
     {
-      error ("%s: couldn't open temporary file `%s'", warn_for, name);
+      error ("%s: couldn't open temporary file `%s'", warn_for,
+	     name.c_str ());
       return 0;
     }
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
 	file << histline (i) << "\n";
     }
   else
     {
       for (int i = hist_beg; i <= hist_end; i++)
 	file << histline (i) << "\n";
     }
 
   file.close ();
 
-  return strsave (name);
+  return name;
 }
 
-void
-do_edit_history (int argc, char **argv)
+static void
+do_edit_history (int argc, const string_vector& argv)
 {
-  char *name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
+  string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
-  if (! name)
+  if (name.empty ())
     return;
 
   // Call up our favorite editor on the file of commands.
 
   ostrstream buf;
   buf << user_pref.editor << " " << name << ends;
   char *cmd = buf.str ();
 
@@ -543,17 +550,17 @@ do_edit_history (int argc, char **argv)
 
   system (cmd);
 
   octave_set_signal_handler (SIGINT, saved_sigint_handler);
 
   // Write the commands to the history file since parse_and_execute
   // disables command line history while it executes.
 
-  fstream file (name, ios::in);
+  fstream file (name.c_str (), ios::in);
 
   char *line;
   int first = 1;
   while ((line = edit_history_readline (file)) != 0)
     {
       // Skip blank lines.
 
       if (line[0] == '\n')
@@ -584,27 +591,25 @@ do_edit_history (int argc, char **argv)
 
   parse_and_execute (name, 1);
 
   run_unwind_frame ("do_edit_history");
 
   // Delete the temporary file.  Should probably be done with an
   // unwind_protect.
 
-  unlink (name);
-
-  delete [] name;
+  unlink (name.c_str ());
 }
 
-void
-do_run_history (int argc, char **argv)
+static void
+do_run_history (int argc, const string_vector& argv)
 {
-  char *name = mk_tmp_hist_file (argc, argv, 1, "run_history");
+  string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
-  if (! name)
+  if (name.empty ())
     return;
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
   begin_unwind_frame ("do_run_history");
   unwind_protect_int (user_pref.echo_executing_commands);
   unwind_protect_int (input_from_tmp_history_file);
@@ -613,19 +618,17 @@ do_run_history (int argc, char **argv)
 
   parse_and_execute (name, 1);
 
   run_unwind_frame ("do_run_history");
 
   // Delete the temporary file.  Should probably be done with an
   // unwind_protect.
 
-  unlink (name);
-
-  delete [] name;
+  unlink (name.c_str ());
 }
 
 int
 current_history_number (void)
 {
   using_history ();
 
   if (user_pref.history_size > 0)
@@ -637,54 +640,63 @@ current_history_number (void)
 
 DEFUN_TEXT ("edit_history", Fedit_history, Sedit_history, 10,
   "edit_history [first] [last]\n\
 \n\
 edit commands from the history list")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("edit_history");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "edit_history");
+
+  if (error_state)
+    return retval;
 
   do_edit_history (argc, argv);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("history", Fhistory, Shistory, 10,
   "history [N] [-w file] [-r file] [-q]\n\
 \n\
 display, save, or load command history")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("history");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "history");
+
+  if (error_state)
+    return retval;
 
   do_history (argc, argv);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("run_history", Frun_history, Srun_history, 10,
   "run_history [first] [last]\n\
 \n\
 run commands from the history list")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("run_history");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "run_history");
+
+  if (error_state)
+    return retval;
 
   do_run_history (argc, argv);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -19,24 +19,23 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_octave_hist_h)
 #define octave_octave_hist_h 1
 
+#include <string>
+
 extern int default_history_size (void);
-extern char *default_history_file (void);
+extern string default_history_file (void);
 extern void initialize_history (void);
 extern void clean_up_history (void);
-extern void maybe_save_history (const char*);
-extern void do_history (int, char**);
-extern void do_edit_history (int, char**);
-extern void do_run_history (int, char**);
+extern void maybe_save_history (const string& s);
 extern int current_history_number (void);
 
 // Nonzero means input is coming from temporary history file.
 extern int input_from_tmp_history_file;
 
 #endif
 
 /*
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -24,32 +24,32 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "str-vec.h"
+
 #include "pt-const.h"
 #include "oct-map.h"
 #include "utils.h"
 
-char **
+string_vector
 Octave_map::make_name_list (void)
 {
   int len = length ();
 
-  char **names = new char * [len + 1];
+  string_vector names (len);
 
   int i = 0;
   for (Pix p = first (); p != 0; next (p))
-    names[i++] = strsave (key (p));
-
-  names[i] = 0;
+    names[i++] = key (p);
 
   return names;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -27,33 +27,35 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "Map.h"
 
 #include "pt-const.h"
 
+class string_vector;
+
 class
 Octave_map : public CHMap<tree_constant>
 {
  public:
   Octave_map (void) : CHMap<tree_constant> (tree_constant ()) { }
 
-  Octave_map (const char *key, const tree_constant& value)
+  Octave_map (const string& key, const tree_constant& value)
     : CHMap<tree_constant> (tree_constant ())
       {
 	CHMap<tree_constant>::operator [] (key) = value;
       }
 
   Octave_map (const Octave_map& m) : CHMap<tree_constant> (m) { }
 
   ~Octave_map (void) { }
 
-  char **make_name_list (void);
+  string_vector make_name_list (void);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -64,16 +64,19 @@ Octave_object::Octave_object (const Comp
   : Array<tree_constant> (1, tree_constant (v, pcv)) { }
 
 Octave_object::Octave_object (const char *s)
   : Array<tree_constant> (1, tree_constant (s)) { }
 
 Octave_object::Octave_object (const string& s)
   : Array<tree_constant> (1, tree_constant (s)) { }
 
+Octave_object::Octave_object (const string_vector& s)
+  : Array<tree_constant> (1, tree_constant (s)) { }
+
 Octave_object::Octave_object (double base, double limit, double inc)
   : Array<tree_constant> (1, tree_constant (base, limit, inc)) { }
 
 Octave_object::Octave_object (const Range& r)
   : Array<tree_constant> (1, tree_constant (r)) { }
 
 tree_constant&
 Octave_object::operator () (int n)
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -55,16 +55,17 @@ public:
   Octave_object (const Complex& c);
   Octave_object (const ComplexMatrix& m);
   Octave_object (const ComplexDiagMatrix& d);
   Octave_object (const ComplexRowVector& v, int pcv = -1);
   Octave_object (const ComplexColumnVector& v, int pcv = -1);
 
   Octave_object (const char *s);
   Octave_object (const string& s);
+  Octave_object (const string_vector& s);
 
   Octave_object (double base, double limit, double inc);
   Octave_object (const Range& r);
 
   Octave_object (const Octave_object& obj) : Array<tree_constant> (obj) { }
 
   Octave_object& operator = (const Octave_object& obj)
     {
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -159,40 +159,40 @@ intern_argv (int argc, char **argv)
 
       bind_builtin_variable ("argv", octave_argv, 1, 1, 0);
     }
 }
 
 // Initialize some global variables for later use.
 
 static void
-initialize_globals (char *name)
+initialize_globals (const string& name)
 {
-  raw_prog_name = strsave (name);
-  char *tmp = strrchr (raw_prog_name, '/');
-  prog_name = tmp ? strsave (tmp+1) : strsave (raw_prog_name);
+  raw_prog_name = name;
+  size_t pos = raw_prog_name.rfind ('/');
+  if (pos == NPOS)
+    prog_name = raw_prog_name;
+  else
+    prog_name = raw_prog_name.substr (pos+1);
 
   struct passwd *entry = getpwuid (getuid ());
   if (entry)
-    user_name = strsave (entry->pw_name);
+    user_name = entry->pw_name;
   else
-    user_name = strsave ("I have no name!");
+    user_name = "I have no name!";
   endpwent ();
 
   char hostname[256];
   if (gethostname (hostname, 255) < 0)
-    host_name = strsave ("I have no host!");
+    host_name = "I have no host!";
   else
-    host_name = strsave (hostname);
+    host_name = hostname;
 
   char *hd = getenv ("HOME");
-  if (hd)
-    home_directory = strsave (hd);
-  else
-    home_directory = strsave ("I have no home!");
+  home_directory = hd ? hd : "I have no home!";
 
   exec_path = default_exec_path ();
 
   load_path = default_path ();
 
   info_file = default_info_file ();
 
   info_prog = default_info_prog ();
@@ -218,41 +218,45 @@ execute_startup_files (void)
 
   int verbose = (verbose_flag && ! inhibit_startup_message);
 
   // Execute commands from the site-wide configuration file.  First
   // from the file $(prefix)/lib/octave/site/m/octaverc (if it exists),
   // then from the file $(prefix)/lib/octave/$(version)/m/octaverc (if
   // it exists).
 
-  char *lsd = get_local_site_defaults ();
+  string lsd = get_local_site_defaults ();
   parse_and_execute (lsd, 0, verbose);
 
-  char *sd = get_site_defaults ();
+  string sd = get_site_defaults ();
   parse_and_execute (sd, 0, verbose);
 
   // Try to execute commands from $HOME/.octaverc and ./.octaverc.
 
-  char *home_rc = 0;
-  if (home_directory)
+  int home_rc_already_executed = 0;
+  string home_rc;
+  if (! home_directory.empty ())
     {
-      home_rc = strconcat (home_directory, "/.octaverc");
+      home_rc = home_directory;
+      home_rc.append ("/.octaverc");
       parse_and_execute (home_rc, 0, verbose);
+
+      // Names alone are not enough.
+
+      struct stat home_rc_statbuf;
+      stat (home_rc.c_str (), &home_rc_statbuf);
+
+      struct stat dot_rc_statbuf;
+      stat ("./.octaverc", &dot_rc_statbuf);
+
+      if (home_rc_statbuf.st_ino == dot_rc_statbuf.st_ino)
+	home_rc_already_executed = 1;
     }
 
-  // Names alone are not enough.
-
-  struct stat home_rc_statbuf;
-  stat (home_rc, &home_rc_statbuf);
-  delete [] home_rc;
-
-  struct stat dot_rc_statbuf;
-  stat ("./.octaverc", &dot_rc_statbuf);
-
-  if (home_rc_statbuf.st_ino != dot_rc_statbuf.st_ino)
+  if (! home_rc_already_executed)
     parse_and_execute ("./.octaverc", 0, verbose);
 
   run_unwind_frame ("execute_startup_files");
 }
 
 // Usage message with extra help.
 
 static void
@@ -375,44 +379,44 @@ main (int argc, char **argv)
 	  break;
 
 	case 'i':
 	  forced_interactive = 1;
 	  break;
 
 	case 'p':
 	  if (optarg)
-	    load_path = strsave (optarg);
+	    load_path = string (optarg);
 	  break;
 
 	case 'q':
 	  inhibit_startup_message = 1;
 	  break;
 
 	case 'x':
 	  echo_commands = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE);
 	  break;
 
 	case 'v':
 	  print_version_and_exit ();
 	  break;
 
 	case EXEC_PATH_OPTION:
 	  if (optarg)
-	    exec_path = strsave (optarg);
+	    exec_path = string (optarg);
 	  break;
 
 	case INFO_FILE_OPTION:
 	  if (optarg)
-	    info_file = strsave (optarg);
+	    info_file = string (optarg);
 	  break;
 
 	case INFO_PROG_OPTION:
 	  if (optarg)
-	    info_prog = strsave (optarg);
+	    info_prog = string (optarg);
 	  break;
 
 	case TRADITIONAL_OPTION:
 	  traditional = 1;
 	  break;
 
 	default:
 	  usage ();
@@ -478,18 +482,20 @@ main (int argc, char **argv)
 
       if (infile)
 	{
 	  input_from_command_line_file = 1;
 
 	  bind_builtin_variable ("program_invocation_name",
 				 curr_fcn_file_name);
 
-	  const char *tmp = strrchr (curr_fcn_file_name, '/');
-	  tmp = tmp ? tmp+1 : curr_fcn_file_name;
+	  size_t pos = curr_fcn_file_name.rfind ('/');
+
+	  string tmp = (pos != NPOS)
+	    ? curr_fcn_file_name.substr (pos+1) : curr_fcn_file_name;
 
 	  bind_builtin_variable ("program_name", tmp);
 
 	  intern_argv (remaining_args, argv+optind);
 
 	  rl_blink_matching_paren = 0;
 	  switch_to_buffer (create_buffer (infile));
 	}
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -23,43 +23,47 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <csignal>
 #include <cstdlib>
 
+#include <string>
+
 #include <iostream.h>
 #include <strstream.h>
 #include <fstream.h>
 
 #include "procstream.h"
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
+#include "oct-obj.h"
 #include "pager.h"
+#include "pt-const.h"
 #include "sighandlers.h"
-#include "pt-const.h"
-#include "oct-obj.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 // Where we stash output headed for the screen.
 static ostrstream *pager_buf = 0;
 
 // Nonzero means we write to the diary file.
 static int write_to_diary_file = 0;
 
 // The name of the current diary file.
-static char *diary_file = 0;
+static string diary_file;
 
 // The diary file.
 static ofstream diary_stream;
 
 static int
 line_count (char *s)
 {
   int count = 0;
@@ -108,17 +112,17 @@ maybe_page_output (ostrstream& msg_buf)
   char *message = msg_buf.str ();
 
   if (message)
     {
       maybe_write_to_diary_file (message);
 
       if (interactive
 	  && user_pref.page_screen_output
-	  && user_pref.pager_binary)
+	  && ! user_pref.pager_binary.empty ())
 	{
 	  *pager_buf << message;
 	}
       else
 	{
 	  cout << message;
 	  cout.flush ();
 	}
@@ -142,23 +146,24 @@ flush_output_to_pager (void)
       delete [] message;
       return;
     }
 
   int nlines = line_count (message);
 
   if (nlines > terminal_rows () - 2)
     {
-      char *pgr = user_pref.pager_binary;
-      if (pgr)
+      string pgr = user_pref.pager_binary;
+
+      if (! pgr.empty ())
 	{
 	  volatile sig_handler *old_sigint_handler;
 	  old_sigint_handler = octave_set_signal_handler (SIGINT, SIG_IGN);
 
-	  oprocstream *pager_stream = new oprocstream (pgr);
+	  oprocstream *pager_stream = new oprocstream (pgr.c_str ());
 
 	  add_unwind_protect (cleanup_oprocstream, pager_stream);
 
 	  int output_paged = 0;
 	  if (pager_stream && *pager_stream)
 	    {
 	      output_paged = 1;
 	      *pager_stream << message;
@@ -182,20 +187,20 @@ flush_output_to_pager (void)
 }
 
 static void
 open_diary_file (void)
 {
   if (diary_stream.is_open ())
     diary_stream.close ();
 
-  diary_stream.open (diary_file, ios::app);
+  diary_stream.open (diary_file.c_str (), ios::app);
 
   if (! diary_stream)
-    error ("diary: can't open diary file `%s'", diary_file);
+    error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
 void
 close_diary_file (void)
 {
   if (diary_stream)
     diary_stream.close ();
 }
@@ -210,83 +215,89 @@ maybe_write_to_diary_file (const char *s
 DEFUN_TEXT ("diary", Fdiary, Sdiary, 10,
   "diary [on|off]\n\
 diary [file]\n\
 \n\
 redirect all input and screen output to a file.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV ("diary");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "diary");
 
-  if (! diary_file)
-    diary_file = strsave ("diary");
+  if (error_state)
+    return retval;
+
+  if (diary_file.empty ())
+    diary_file = "diary";
 
   switch (argc)
     {
     case 1:
       write_to_diary_file = ! write_to_diary_file;
       open_diary_file ();
       break;
 
     case 2:
       {
-	char *arg = argv[1];
-	if (strcmp (arg, "on") == 0)
+	string arg = argv[1];
+
+	if (arg == "on")
 	  {
 	    write_to_diary_file = 1;
 	    open_diary_file ();
 	  }	
-	else if (strcmp (arg, "off") == 0)
+	else if (arg == "off")
 	  write_to_diary_file = 0;
 	else
 	  {
-	    delete [] diary_file;
-	    diary_file = strsave (arg);
+	    diary_file = arg;
 	    open_diary_file ();
 	  }
       }
       break;
 
     default:
       print_usage ("diary");
       break;
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("more", Fmore, Smore, 10,
   "more on\n\
 more off\n\
 \n\
 Turn output pagination on or off.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV ("more");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "more");
+
+  if (error_state)
+    return retval;
 
   if (argc == 2)
     {
-      char *arg = argv[1];
+      string arg = argv[1];
 
-      if (strcmp (arg, "on") == 0)
+      if (arg == "on")
 	bind_builtin_variable ("page_screen_output", "true");
-      else if (strcmp (arg, "off") == 0)
+      else if (arg == "off")
 	bind_builtin_variable ("page_screen_output", "false");
       else
-	error ("more: unrecognized argument `%s'", arg);
+	error ("more: unrecognized argument `%s'", arg.c_str ());
     }
   else
     print_usage ("more");
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -19,16 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_parse_h)
 #define octave_parse_h 1
 
+#include <string>
+
 #include "SLStack.h"
 
 extern void discard_until (char c);
 extern void reset_parser (void);
 extern int yylex (void);
 extern int yyparse (void);
 
 class tree;
@@ -69,17 +71,17 @@ extern int yydebug;
 
 // The current input line number.
 extern int input_line_number;
 
 // The column of the current token.
 extern int current_input_column;
 
 // Buffer for help text snagged from function files.
-extern char *help_buf;
+extern string help_buf;
 
 // Nonzero means we're working on a plot command.
 extern int plotting;
 
 // Nonzero means we've seen something that means we must be past the
 // range part of a plot command.
 extern int past_plot_range;
 
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -89,17 +89,17 @@ SLStack <int> mlnm;
 
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
 
 // Buffer for help text snagged from function files.
-char *help_buf = 0;
+string help_buf;
 
 // Nonzero means we're working on a plot command.
 int plotting = 0;
 
 // Nonzero means we've seen something that means we must be past the
 // range part of a plot command.
 int past_plot_range = 0;
 
@@ -620,21 +620,21 @@ using1		: USING expression
 		  { $$ = $1->add_qualifier ($3); }
 		;
 
 title		: TITLE expression
 		  { $$ = $2; }
 		;
 
 style		: WITH STYLE
-		  { $$ = new subplot_style ($2->string ()); }
+		  { $$ = new subplot_style ($2->text ()); }
 		| WITH STYLE expression
-		  { $$ = new subplot_style ($2->string (), $3); }
+		  { $$ = new subplot_style ($2->text (), $3); }
 		| WITH STYLE expression bogus_syntax expression
-		  { $$ = new subplot_style ($2->string (), $3, $5); }
+		  { $$ = new subplot_style ($2->text (), $3, $5); }
 		;
 
 bogus_syntax	: // empty
 		;
 
 ans_expression	: expression
 		  { $$ = maybe_convert_to_ans_assign ($1); }
 		;
@@ -1023,17 +1023,17 @@ indirect_ref	: indirect_ref1
 		  }
 
 indirect_ref1	: identifier
 		  {
 		    $$ = new tree_indirect_ref ($1, $1->line (),
 						$1->column ());
 		  }
 		| indirect_ref1 '.' { looking_at_indirect_ref = 1; } TEXT_ID
-		  { $$ = $1->chain ($4->string ()); }
+		  { $$ = $1->chain ($4->text ()); }
 		;
 
 variable	: indirect_ref
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' ')'
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' arg_list ')'
 		  { $$ = make_index_expression ($1, $3); }
@@ -1156,45 +1156,41 @@ matrix_row1	: expression		// First eleme
 
 %%
 
 // Generic error messages.
 
 static void
 yyerror (char *s)
 {
-  char *line = current_input_line;
   int err_col = current_input_column - 1;
 
   ostrstream output_buf;
 
   if (reading_fcn_file || reading_script_file)
     output_buf << "parse error near line " << input_line_number
 	       << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
 
-  if (line)
+  if (! current_input_line.empty ())
     {
-      int len = strlen (line);
+      size_t len = current_input_line.length ();
 
-      if (line[len-1] == '\n')
-        {
-          len--;
-          line[len] = '\0';
-        }
+      if (current_input_line[len-1] == '\n')
+        current_input_line.resize (len-1);
 
 // Print the line, maybe with a pointer near the error token.
 
-      output_buf << ">>> " << line << "\n";
+      output_buf << ">>> " << current_input_line << "\n";
 
       if (err_col == 0)
 	err_col = len;
 
       for (int i = 0; i < err_col + 3; i++)
 	output_buf << " ";
 
       output_buf << "^";
@@ -1421,17 +1417,17 @@ make_constant (int op, token *tok_val)
       {
 	Complex C (0.0, tok_val->number ());
 	retval = new tree_constant (C, l, c);
 	retval->stash_original_text (tok_val->text_rep ());
       }
       break;
 
     case TEXT:
-      retval = new tree_constant (tok_val->string (), l, c);
+      retval = new tree_constant (tok_val->text (), l, c);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
@@ -1952,58 +1948,58 @@ start_function_def (tree_parameter_list 
   return fcn;
 }
 
 // Do most of the work for defining a function.
 
 static tree_function *
 frob_function_def (tree_identifier *id, tree_function *fcn)
 {
-  char *id_name = id->name ();
+  string id_name = id->name ();
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
 
   fcn->stash_function_name (id_name);
 
   if (reading_fcn_file)
     {
-      if (strcmp (curr_fcn_file_name, id_name) != 0)
+      if (curr_fcn_file_name != id_name)
 	{
 	  if (user_pref.warn_function_name_clash)
 	    warning ("function name `%s' does not agree with function\
- file name `%s'", id_name, curr_fcn_file_full_name);
+ file name `%s'", id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
 	  global_sym_tab->rename (id_name, curr_fcn_file_name);
 
 	  if (error_state)
 	    return 0;
 
 	  id_name = id->name ();
 	}
 
       fcn->stash_function_name (id_name);
       fcn->stash_fcn_file_name ();
       fcn->stash_fcn_file_time (time (0));
       fcn->mark_as_system_fcn_file ();
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
 	   && reading_script_file
-	   && curr_fcn_file_name
-	   && strcmp (curr_fcn_file_name, id_name) == 0)
+	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
-	       id_name, curr_fcn_file_full_name);
+	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   top_level_sym_tab->clear (id_name);
 
   id->define (fcn);
+
   id->document (help_buf);
 
   return fcn;
 }
 
 // Finish defining a function.
 
 static tree_function *
@@ -2107,11 +2103,12 @@ static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (defining_func && user_pref.warn_missing_semicolon)
     {
       tree_statement *tmp = t->rear();
 
       if (tmp->is_expression ())
 	warning ("missing semicolon near line %d, column %d in file `%s'",
-		 tmp->line (), tmp->column (), curr_fcn_file_full_name);
+		 tmp->line (), tmp->column (),
+		 curr_fcn_file_full_name.c_str ());
     }
 }
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -33,26 +33,27 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream.h>
 #include <strstream.h>
 
 #include "CMatrix.h"
 #include "Range.h"
 #include "dMatrix.h"
 #include "oct-cmplx.h"
+#include "str-vec.h"
 
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "mappers.h"
+#include "oct-obj.h"
 #include "pager.h"
 #include "pr-output.h"
+#include "pt-const.h"
 #include "sysdep.h"
-#include "pt-const.h"
-#include "oct-obj.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 // Current format string for real numbers and the real part of complex
 // numbers.
 static char *curr_real_fmt = 0;
 
@@ -1513,34 +1514,27 @@ octave_print_internal (ostream& os, cons
     {
       int nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       for (int i = 0; i < nstr; i++)
 	{
-	  string tstr = chm.row_as_string (i);
-	  const char *row = tstr.c_str ();
+	  string row = chm.row_as_string (i);
 
 	  if (pr_as_read_syntax)
 	    {
-	      char *tmp = undo_string_escapes (row);
-
-	      os << "\"" << tmp << "\"";
-
-	      delete [] tmp;
+	      os << "\"" << undo_string_escapes (row) << "\"";
 
 	      if (i < nstr - 1)
 		os << "; ";
 	    }
 	  else
 	    os << row << "\n";
-
-	  delete [] row;
 	}
 
       if (pr_as_read_syntax && nstr > 1)
 	os << " ]";
     }
   else
     {
       os << "sorry, printing char matrices not implemented yet\n";
@@ -1581,152 +1575,156 @@ set_output_prec_and_fw (int prec, int fw
 
   tmp = new tree_constant ((double) prec);
   bind_builtin_variable ("output_precision", tmp);
 
   tmp = new tree_constant ((double) fw);
   bind_builtin_variable ("output_max_field_width", tmp);
 }
 
-void
-set_format_style (int argc, char **argv)
+static void
+set_format_style (int argc, const string_vector& argv)
 {
-  if (--argc > 0)
+  int idx = 1;
+  string arg = argv[idx++];
+
+  if (argc > 1)
     {
-      argv++;
-      if (*argv[0])
+      if (arg == "short")
 	{
-	  if (strcmp (*argv, "short") == 0)
+	  if (--argc > 0)
 	    {
-	      if (--argc > 0)
+	      arg = argv[idx++];
+
+	      if (arg == "e")
 		{
-		  argv++;
-		  if (strcmp (*argv, "e") == 0)
-		    {
-		      init_format_state ();
-		      print_e = 1;
-		    }
-		  else if (strcmp (*argv, "E") == 0)
-		    {
-		      init_format_state ();
-		      print_e = 1;
-		      print_big_e = 1;
-		    }
-		  else
-		    {
-		      error ("format: unrecognized option `short %s'", *argv);
-		      return;
-		    }
+		  init_format_state ();
+		  print_e = 1;
+		}
+	      else if (arg == "E")
+		{
+		  init_format_state ();
+		  print_e = 1;
+		  print_big_e = 1;
 		}
 	      else
-		init_format_state ();
-
-	      set_output_prec_and_fw (3, 8);
-	    }
-	  else if (strcmp (*argv, "long") == 0)
-	    {
-	      if (--argc > 0)
 		{
-		  argv++;
-		  if (strcmp (*argv, "e") == 0)
-		    {
-		      init_format_state ();
-		      print_e = 1;
-		    }
-		  else if (strcmp (*argv, "E") == 0)
-		    {
-		      init_format_state ();
-		      print_e = 1;
-		      print_big_e = 1;
-		    }
-		  else
-		    {
-		      error ("format: unrecognized option `long %s'", *argv);
-		      return;
-		    }
+		  error ("format: unrecognized option `short %s'",
+			 arg.c_str ());
+		  return;
+		}
+	    }
+	  else
+	    init_format_state ();
+
+	  set_output_prec_and_fw (3, 8);
+	}
+      else if (arg == "long")
+	{
+	  if (--argc > 0)
+	    {
+	      arg = argv[idx++];
+
+	      if (arg == "e")
+		{
+		  init_format_state ();
+		  print_e = 1;
+		}
+	      else if (arg == "E")
+		{
+		  init_format_state ();
+		  print_e = 1;
+		  print_big_e = 1;
 		}
 	      else
-		init_format_state ();
-
-	      set_output_prec_and_fw (15, 24);
-	    }
-	  else if (strcmp (*argv, "hex") == 0)
-	    {
-	      init_format_state ();
-	      hex_format = 1;
-	    }
-	  else if (strcmp (*argv, "native-hex") == 0)
-	    {
-	      init_format_state ();
-	      hex_format = 2;
-	    }
-	  else if (strcmp (*argv, "bit") == 0)
-	    {
-	      init_format_state ();
-	      bit_format = 1;
-	    }
-	  else if (strcmp (*argv, "native-bit") == 0)
-	    {
-	      init_format_state ();
-	      bit_format = 2;
-	    }
-	  else if (strcmp (*argv, "+") == 0 || strcmp (*argv, "plus") == 0)
-	    {
-	      init_format_state ();
-	      plus_format = 1;
-	    }
-	  else if (strcmp (*argv, "bank") == 0)
-	    {
-	      init_format_state ();
-	      bank_format = 1;
-	    }
-	  else if (strcmp (*argv, "free") == 0)
-	    {
-	      init_format_state ();
-	      free_format = 1;
-	    }
-	  else if (strcmp (*argv, "none") == 0)
-	    {
-	      init_format_state ();
-	      free_format = 1;
-	    }
-	  else if (strcmp (*argv, "compact") == 0)
-	    {
-	      compact_format = 1;
-	    }
-	  else if (strcmp (*argv, "loose") == 0)
-	    {
-	      compact_format = 0;
+		{
+		  error ("format: unrecognized option `long %s'",
+			 arg.c_str ());
+		  return;
+		}
 	    }
 	  else
-	    error ("format: unrecognized format state `%s'", *argv);
+	    init_format_state ();
+
+	  set_output_prec_and_fw (15, 24);
+	}
+      else if (arg == "hex")
+	{
+	  init_format_state ();
+	  hex_format = 1;
+	}
+      else if (arg == "native-hex")
+	{
+	  init_format_state ();
+	  hex_format = 2;
+	}
+      else if (arg == "bit")
+	{
+	  init_format_state ();
+	  bit_format = 1;
+	}
+      else if (arg == "native-bit")
+	{
+	  init_format_state ();
+	  bit_format = 2;
+	}
+      else if (arg == "+" || arg == "plus")
+	{
+	  init_format_state ();
+	  plus_format = 1;
+	}
+      else if (arg == "bank")
+	{
+	  init_format_state ();
+	  bank_format = 1;
+	}
+      else if (arg == "free")
+	{
+	  init_format_state ();
+	  free_format = 1;
+	}
+      else if (arg == "none")
+	{
+	  init_format_state ();
+	  free_format = 1;
+	}
+      else if (arg == "compact")
+	{
+	  compact_format = 1;
+	}
+      else if (arg == "loose")
+	{
+	  compact_format = 0;
 	}
       else
-	usage ("format [format_state]");
+	error ("format: unrecognized format state `%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
 DEFUN_TEXT ("format", Fformat, Sformat, 10,
   "format [style]\n\
 \n\
 set output formatting style")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("format");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "format");
+
+  if (error_state)
+    return retval;
 
   set_format_style (argc, argv);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -47,18 +47,16 @@ extern void octave_print_internal (ostre
 
 extern void octave_print_internal (ostream& os, const Range& r,
 				   int pr_as_read_syntax = 0);
 
 extern void octave_print_internal (ostream& os, const charMatrix& chm,
 				   int pr_as_read_syntax = 0,
 				   int pr_as_string = 0);
 
-extern void set_format_style (int argc, char **argv);
-
 // XXX FIXME XXX -- these should probably be somewhere else.
 
 extern int any_element_is_inf_or_nan (const Matrix& a);
 
 extern int any_element_is_inf_or_nan (const ComplexMatrix& a);
 
 #endif
 
diff --git a/src/pt-base.cc b/src/pt-base.cc
--- a/src/pt-base.cc
+++ b/src/pt-base.cc
@@ -59,17 +59,17 @@ tree_print_code::print_code_new_line (os
 
 void
 tree_print_code::print_code_indent (ostream& os)
 {
   assert (curr_print_indent_level >= 0);
  
   if (beginning_of_line)
     {
-      os.form ("%s%*s", user_pref.ps4, curr_print_indent_level, "");
+      os.form ("%s%*s", user_pref.ps4.c_str (), curr_print_indent_level, "");
       beginning_of_line = 0;
     }
 }
 
 // For ressetting print_code state.
 
 void
 tree_print_code::print_code_reset (void)
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -37,16 +37,17 @@ Software Foundation, 59 Temple Place - S
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #include <SLList.h>
 
 #include "mx-base.h"
 #include "Range.h"
+#include "str-vec.h"
 
 #include "arith-ops.h"
 #include "error.h"
 #include "gripes.h"
 #include "idx-vector.h"
 #include "mappers.h"
 #include "oct-map.h"
 #include "oct-obj.h"
@@ -182,59 +183,57 @@ tree_constant::operator = (const tree_co
 	delete rep;
       rep = a.rep;
       rep->count++;
     }
   return *this;  
 }
 
 tree_constant
-tree_constant::lookup_map_element (const char *ref, int insert,
+tree_constant::lookup_map_element (const string& ref, int insert,
 				   int silent)
 {
   tree_constant retval;
 
-  if (ref)
+  if (! ref.empty ())
     {
-      char *tmp = strsave (ref);
-
-      SLList<char *> list;
-
-      char *beg = tmp;
-      char *end = 0;
+      SLList<string> list;
+
+      size_t beg = 0;
+      size_t end;
+
       do
 	{
-	  end = strchr (beg, '.');
-	  if (end)
-	    *end = '\0';
-
-	  list.append (strsave (beg));
+	  end = ref.find ('.', beg);
+
+	  string tmp = (end == NPOS)
+	    ? ref.substr (beg) : ref.substr (beg, end - 1);
+
+	  list.append (tmp);
 	}
-      while (end && (beg = end + 1));
+      while (end != NPOS && (beg = end + 1));
 
       retval = lookup_map_element (list, insert, silent);
-
-      delete [] tmp;
     }
 
   return retval;
 }
 
 tree_constant
-tree_constant::lookup_map_element (SLList<char*>& list, int insert,
+tree_constant::lookup_map_element (SLList<string>& list, int insert,
 				   int silent)
 {
   tree_constant retval;
 
   tree_constant_rep *tmp_rep = rep;
 
   Pix p = list.first ();
   while (p)
     {
-      char *elt = list (p);
+      string elt = list (p);
 
       list.next (p);
 
       tree_constant tmp;
 
       tmp = tmp_rep->lookup_map_element (elt, insert, silent);
 
       if (error_state)
@@ -253,16 +252,48 @@ void
 tree_constant::print (void)
 {
   ostrstream output_buf;
   print (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
+void
+tree_constant::print_with_name (const string& name, int print_padding)
+{
+  ostrstream output_buf;
+  print_with_name (output_buf, name, print_padding);
+  output_buf << ends;
+  maybe_page_output (output_buf);
+}
+
+void
+tree_constant::print_with_name (ostream& output_buf, const string& name,
+				int print_padding) 
+{
+  int pad_after = 0;
+
+  if (user_pref.print_answer_id_name)
+    {
+      if (print_as_scalar () || print_as_structure ())
+	output_buf << name << " = ";
+      else
+	{
+	  pad_after = 1;
+	  output_buf << name << " =\n\n";
+	}
+    }
+
+  print (output_buf);
+
+  if (print_padding && pad_after)
+    output_buf << "\n";
+}
+
 // Simple structure assignment.
 
 void
 tree_constant::make_unique (void)
 {
   if (rep->count > 1)
     {
       --rep->count;
@@ -293,28 +324,28 @@ tree_constant::make_unique_map (void)
     }
 
   make_unique ();
 
   return rep;
 }
 
 tree_constant
-tree_constant::assign_map_element (SLList<char*>& list,
+tree_constant::assign_map_element (SLList<string>& list,
 				   tree_constant& rhs)
 {
   tree_constant_rep *tmp_rep = make_unique_map ();
 
   if (rhs.is_map ())
     rhs.make_unique ();
 
   Pix p = list.first ();
   while (p)
     {
-      char *elt = list (p);
+      string elt = list (p);
 
       list.next (p);
 
       tree_constant& tmp = tmp_rep->lookup_map_element (elt, 1);
 
       if (! p)
 	{
 	  tmp = rhs;
@@ -325,29 +356,29 @@ tree_constant::assign_map_element (SLLis
     }
 
   return tree_constant ();
 }
 
 // Indexed structure assignment.
 
 tree_constant
-tree_constant::assign_map_element (SLList<char*>& list,
+tree_constant::assign_map_element (SLList<string>& list,
 				   tree_constant& rhs,
 				   const Octave_object& args)
 {
   tree_constant_rep *tmp_rep = make_unique_map ();
 
   if (rhs.is_map ())
     rhs.make_unique ();
 
   Pix p = list.first ();
   while (p)
     {
-      char *elt = list (p);
+      string elt = list (p);
 
       list.next (p);
 
       tree_constant& tmp = tmp_rep->lookup_map_element (elt, 1);
 
       if (! p)
 	{
 	  tmp.assign (rhs, args);
@@ -386,78 +417,55 @@ tree_constant::print_code (ostream& os)
 
   if (rep)
     rep->print_code (os);
 
   if (in_parens)
     os << ")";
 }
 
-int
-print_as_scalar (const tree_constant& val)
-{
-  int nr = val.rows ();
-  int nc = val.columns ();
-  return (val.is_scalar_type ()
-	  || (val.is_string () && nr <= 1)
-	  || (val.is_matrix_type ()
-	      && ((nr == 1 && nc == 1)
-		  || nr == 0
-		  || nc == 0)));
-}
-
-int
-print_as_structure (const tree_constant& val)
-{
-  return val.is_map ();
-}
-
 // The real representation of constants.
 
 TC_REP::tree_constant_rep (void)
 {
   type_tag = unknown_constant;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (double d)
 {
   scalar = d;
   type_tag = scalar_constant;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Matrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       scalar = m.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (m);
       type_tag = matrix_constant;
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const DiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       scalar = d.elem (0, 0);
       type_tag = scalar_constant;
     }
   else
     {
       matrix = new Matrix (d);
       type_tag = matrix_constant;
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const RowVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
       scalar = v.elem (0);
@@ -481,17 +489,16 @@ TC_REP::tree_constant_rep (const RowVect
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const ColumnVector& v, int prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
       scalar = v.elem (0);
@@ -515,32 +522,30 @@ TC_REP::tree_constant_rep (const ColumnV
 	{
 	  Matrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  matrix = new Matrix (m);
 	  type_tag = matrix_constant;
 	}
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Complex& c)
 {
   if (::imag (c) == 0.0)
     {
       scalar = ::real (c);
       type_tag = scalar_constant;
     }
   else
     {
       complex_scalar = new Complex (c);
       type_tag = complex_scalar_constant;
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const ComplexMatrix& m)
 {
   if (m.rows () == 1 && m.columns () == 1)
     {
       Complex c = m.elem (0, 0);
 
@@ -555,17 +560,16 @@ TC_REP::tree_constant_rep (const Complex
 	  type_tag = complex_scalar_constant;
 	}
     }
   else
     {
       complex_matrix = new ComplexMatrix (m);
       type_tag = complex_matrix_constant;
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const ComplexDiagMatrix& d)
 {
   if (d.rows () == 1 && d.columns () == 1)
     {
       Complex c = d.elem (0, 0);
 
@@ -580,17 +584,16 @@ TC_REP::tree_constant_rep (const Complex
 	  type_tag = complex_scalar_constant;
 	}
     }
   else
     {
       complex_matrix = new ComplexMatrix (d);
       type_tag = complex_matrix_constant;
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const ComplexRowVector& v,
 			   int prefer_column_vector) 
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -625,17 +628,16 @@ TC_REP::tree_constant_rep (const Complex
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const ComplexColumnVector& v, int
 			   prefer_column_vector)
 {
   int len = v.capacity ();
   if (len == 1)
     {
@@ -670,38 +672,48 @@ TC_REP::tree_constant_rep (const Complex
 	{
 	  ComplexMatrix m (1, len);
 	  for (int i = 0; i < len; i++)
 	    m.elem (0, i) = v.elem (i);
 	  complex_matrix = new ComplexMatrix (m);
 	  type_tag = complex_matrix_constant;
 	}
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const char *s)
 {
   char_matrix = new charMatrix (s);
   type_tag = char_matrix_constant_str;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const string& s)
 {
   char_matrix = new charMatrix (s);
   type_tag = char_matrix_constant_str;
-  orig_text = 0;
+}
+
+TC_REP::tree_constant_rep (const string_vector& s)
+{
+  int nr = s.length ();
+  int nc = s.max_length ();
+  char_matrix = new charMatrix (nr, nc, 0);
+  for (int i = 0; i < nr; i++)
+    {
+      nc = s[i].length ();
+      for (int j = 0; j < nc; j++)
+	char_matrix->elem (i, j) = s[i][j];
+    }
+  type_tag = char_matrix_constant_str;
 }
 
 TC_REP::tree_constant_rep (const charMatrix& chm, int is_str)
 {
   char_matrix = new charMatrix (chm);
   type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (double b, double l, double i)
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel > 1)
     type_tag = range_constant;
@@ -722,17 +734,16 @@ TC_REP::tree_constant_rep (double b, dou
 	{
 	  type_tag = unknown_constant;
 	  if (nel == -1)
 	    ::error ("number of elements in range exceeds INT_MAX");
 	  else
 	    ::error ("invalid range");
 	}
     }
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Range& r)
 {
   int nel = r.nelem ();
   if (nel > 1)
     {
       range = new Range (r);
@@ -751,32 +762,28 @@ TC_REP::tree_constant_rep (const Range& 
   else
     {
       type_tag = unknown_constant;
       if (nel == -1)
 	::error ("number of elements in range exceeds INT_MAX");
       else
 	::error ("invalid range");
     }
-
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const Octave_map& m)
 {
   a_map = new Octave_map (m);
   type_tag = map_constant;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (TC_REP::constant_type t)
 {
   assert (t == magic_colon || t == all_va_args);
   type_tag = t;
-  orig_text = 0;
 }
 
 TC_REP::tree_constant_rep (const tree_constant_rep& t)
 {
   type_tag = t.type_tag;
 
   switch (t.type_tag)
     {
@@ -815,17 +822,17 @@ TC_REP::tree_constant_rep (const tree_co
       a_map = new Octave_map (*(t.a_map));
       break;
 
     case magic_colon:
     case all_va_args:
       break;
     }
 
-  orig_text = strsave (t.orig_text);
+  orig_text = t.orig_text;
 }
 
 TC_REP::~tree_constant_rep (void)
 {
   switch (type_tag)
     {
     case matrix_constant:
       delete matrix;
@@ -853,18 +860,16 @@ TC_REP::~tree_constant_rep (void)
       break;
 
     case unknown_constant:
     case scalar_constant:
     case magic_colon:
     case all_va_args:
       break;
     }
-
-  delete [] orig_text;
 }
 
 void *
 TC_REP::operator new (size_t size)
 {
   assert (size == sizeof (TC_REP));
 
   if (! tc_rep_newlist)
@@ -1500,30 +1505,30 @@ TC_REP::range_value (void) const
 Octave_map
 TC_REP::map_value (void) const
 {
   assert (type_tag == map_constant);
   return *a_map;
 }
 
 tree_constant&
-TC_REP::lookup_map_element (const char *name, int insert, int silent)
+TC_REP::lookup_map_element (const string& name, int insert, int silent)
 {
   static tree_constant retval;
 
   if (type_tag == map_constant)
     {
       Pix idx = a_map->seek (name);
 
       if (idx)
 	return a_map->contents (idx);
       else if (insert)
 	return (*a_map) [name];
       else if (! silent)
-	error ("structure has no member `%s'", name);
+	error ("structure has no member `%s'", name.c_str ());
     }
   else if (! silent)
     error ("invalid structure access attempted");
 
   return retval;
 }
 
 // This could be made more efficient by doing all the work here rather
@@ -2114,19 +2119,19 @@ TC_REP::resize (int i, int j, double val
 
     default:
       gripe_wrong_type_arg ("resize", type_as_string ());
       break;
     }
 }
 
 void
-TC_REP::stash_original_text (char *s)
+TC_REP::stash_original_text (const string &s)
 {
-  orig_text = strsave (s);
+  orig_text = s;
 }
 
 void
 TC_REP::maybe_mutate (void)
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
@@ -2252,23 +2257,23 @@ TC_REP::print (ostream& output_buf)
 	if (user_pref.struct_levels_to_print-- > 0)
 	  {
 	    output_buf << "{\n";
 
 	    increment_structure_indent_level ();
 
 	    for (Pix p = a_map->first (); p != 0; a_map->next (p))
 	      {
-		const char *key = a_map->key (p);
+		string key = a_map->key (p);
 		tree_constant val = a_map->contents (p);
 
 		output_buf.form ("%*s%s = ", structure_indent_level,
-				 "", key);
-
-		if (! (print_as_scalar (val) || print_as_structure (val))) 
+				 "", key.c_str ());
+
+		if (! (print_as_scalar () || print_as_structure ())) 
 		  output_buf << "\n";
 
 		val.print (output_buf);
 	      }
 
 	    decrement_structure_indent_level ();
 
 	    output_buf.form ("%*s%s", structure_indent_level, "", "}\n");
@@ -2289,36 +2294,36 @@ TC_REP::print (ostream& output_buf)
 }
 
 void
 TC_REP::print_code (ostream& os)
 {
   switch (type_tag)
     {
     case scalar_constant:
-      if (orig_text)
+      if (orig_text.empty ())
+	octave_print_internal (os, scalar, 1);
+      else
 	os << orig_text;
-      else
-	octave_print_internal (os, scalar, 1);
       break;
 
     case matrix_constant:
       octave_print_internal (os, *matrix, 1);
       break;
 
     case complex_scalar_constant:
      {
 	double re = complex_scalar->real ();
 	double im = complex_scalar->imag ();
 
 	// If we have the original text and a pure imaginary, just
 	// print the original text, because this must be a constant
 	// that was parsed as part of a function.
 
-	if (orig_text && re == 0.0 && im > 0.0)
+	if (! orig_text.empty () && re == 0.0 && im > 0.0)
 	  os << orig_text;
 	else
 	  octave_print_internal (os, *complex_scalar, 1);
       }
       break;
 
     case complex_matrix_constant:
       octave_print_internal (os, *complex_matrix, 1);
@@ -3103,14 +3108,33 @@ TC_REP::assign (tree_constant& rhs, cons
 
   // Do the right thing for assignments like `x(1) = pi' when x is
   // undefined before the assignment.
 
   if (is_matrix_type () || is_range ())
     maybe_mutate ();
 }
 
+int
+TC_REP::print_as_scalar (void)
+{
+  int nr = rows ();
+  int nc = columns ();
+  return (is_scalar_type ()
+	  || (is_string () && nr <= 1)
+	  || (is_matrix_type ()
+	      && ((nr == 1 && nc == 1)
+		  || nr == 0
+		  || nc == 0)));
+}
+
+int
+TC_REP::print_as_structure (void)
+{
+  return is_map ();
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -31,16 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include <cstdlib>
 
 #include <string>
 
 class ostream;
 
 #include "Range.h"
 #include "mx-base.h"
+#include "str-vec.h"
 
 #include "pt-fvc.h"
 
 class Octave_map;
 class Octave_object;
 
 // Constants.
 
@@ -91,16 +92,17 @@ private:
 	tree_constant_rep (const Complex& c);
 	tree_constant_rep (const ComplexMatrix& m);
 	tree_constant_rep (const ComplexDiagMatrix& d);
 	tree_constant_rep (const ComplexRowVector& v, int pcv);
 	tree_constant_rep (const ComplexColumnVector& v, int pcv);
 
 	tree_constant_rep (const char *s);
 	tree_constant_rep (const string& s);
+	tree_constant_rep (const string_vector& s);
 	tree_constant_rep (const charMatrix& chm, int is_string);
 
 	tree_constant_rep (double base, double limit, double inc);
 	tree_constant_rep (const Range& r);
 
 	tree_constant_rep (const Octave_map& m);
 
 	tree_constant_rep (tree_constant_rep::constant_type t);
@@ -213,17 +215,18 @@ private:
 	Complex complex_value (int frc_str_conv = 0) const;
 	ComplexMatrix complex_matrix_value (int frc_str_conv = 0) const;
 	charMatrix char_matrix_value (int frc_str_conv = 0) const;
 	charMatrix all_strings (void) const;
         string string_value (void) const;
 	Range range_value (void) const;
 	Octave_map map_value (void) const;
 
-	tree_constant& lookup_map_element (const char *name, int insert = 0,
+	tree_constant& lookup_map_element (const string& name,
+					   int insert = 0,
 					   int silent = 0);
 
 	ColumnVector vector_value (int frc_str_conv = 0,
 				   int frc_vec_conv = 0) const;
 
 	ComplexColumnVector complex_vector_value (int frc_str_conv = 0,
 						  int frc_vec_conv = 0) const;
 
@@ -231,17 +234,17 @@ private:
 
 	void convert_to_row_or_column_vector (void);
 
 	void bump_value (tree_expression::type);
 
 	void resize (int i, int j);
 	void resize (int i, int j, double val);
 
-	void stash_original_text (char *s);
+	void stash_original_text (const string& s);
 
 	void maybe_mutate (void);
 
 	void print (void);
 	void print (ostream& os);
 
 	void print_code (ostream& os);
 
@@ -284,16 +287,20 @@ private:
 	void set_index (const Octave_object& args, int rhs_is_complex = 0);
 
 	tree_constant do_index (const Octave_object& args);
 
 	void maybe_widen (constant_type t);
 
 	void assign (tree_constant& rhs, const Octave_object& args);
 
+	int print_as_scalar (void);
+
+	int print_as_structure (void);
+
 	// Data.
 
 	union
 	  {
 	    double scalar;		    // A real scalar constant.
 	    Matrix *matrix;		    // A real matrix constant.
 	    Complex *complex_scalar;	    // A real scalar constant.
 	    ComplexMatrix *complex_matrix;  // A real matrix constant.
@@ -303,17 +310,17 @@ private:
 
 	    tree_constant_rep *freeptr;     // For custom memory management.
 	  };
 
 	constant_type type_tag;
 
 	int count;
 
-	char *orig_text;
+	string orig_text;
     };
 
   union
     {
       tree_constant *freeptr;  // For custom memory management.
       tree_constant_rep *rep;  // The real representation.
     };
 
@@ -382,16 +389,20 @@ public:
     { rep = new tree_constant_rep (v, pcv); rep->count = 1; }
 
   tree_constant (const char *s, int l = -1, int c = -1) : tree_fvc (l, c)
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
   tree_constant (const string& s, int l = -1, int c = -1) : tree_fvc (l, c)
     { rep = new tree_constant_rep (s); rep->count = 1; }
 
+  tree_constant (const string_vector& s, int l = -1, int c = -1)
+    : tree_fvc (l, c)
+    { rep = new tree_constant_rep (s); rep->count = 1; }
+
   tree_constant (const charMatrix& chm, int is_string = 0) : tree_fvc ()
     { rep = new tree_constant_rep (chm, is_string); rep->count = 1; }
 
   tree_constant (double base, double limit, double inc) : tree_fvc ()
     { rep = new tree_constant_rep (base, limit, inc); rep->count = 1; }
 
   tree_constant (const Range& r) : tree_fvc ()
     { rep = new tree_constant_rep (r); rep->count = 1; }
@@ -445,22 +456,22 @@ public:
 
       rep->assign (rhs, args);
 
       return *this;
     }
 
   // Simple structure assignment.
 
-  tree_constant assign_map_element (SLList<char*>& list,
+  tree_constant assign_map_element (SLList<string>& list,
 				    tree_constant& rhs);
 
   // Indexed structure assignment.
 
-  tree_constant assign_map_element (SLList<char*>& list,
+  tree_constant assign_map_element (SLList<string>& list,
 				    tree_constant& rhs,
 				    const Octave_object& args);
 
   // Type.  It would be nice to eliminate the need for this.
 
   int is_constant (void) const { return 1; }
 
   // Size.
@@ -552,20 +563,20 @@ public:
   string string_value (void) const
     { return rep->string_value (); }
 
   Range range_value (void) const
     { return rep->range_value (); }
 
   Octave_map map_value (void) const;
 
-  tree_constant lookup_map_element (const char *ref, int insert = 0,
+  tree_constant lookup_map_element (const string& ref, int insert = 0,
 				    int silent = 0);
 
-  tree_constant lookup_map_element (SLList<char*>& list,
+  tree_constant lookup_map_element (SLList<string>& list,
 				    int insert = 0, int silent = 0);
 
   ColumnVector vector_value (int /* frc_str_conv */ = 0,
 			     int /* frc_vec_conv */ = 0) const 
     { return rep->vector_value (); }
 
   ComplexColumnVector complex_vector_value (int /* frc_str_conv */ = 0,
 					    int /* frc_vec_conv */ = 0) const
@@ -601,16 +612,20 @@ public:
 	}
 
       rep->bump_value (et);
     }
 
   void print (void);
   void print (ostream& os) { rep->print (os); }
 
+  void print_with_name (const string& name, int print_padding = 1);
+  void print_with_name (ostream& os, const string& name,
+			int print_padding = 1);
+
   // Evaluate this constant, possibly converting complex to real, or
   // matrix to scalar, etc.
 
   tree_constant eval (int print_result)
     {
       if (print_result)
 	{
 	  rep->maybe_mutate ();  // XXX FIXME XXX -- is this necessary?
@@ -620,17 +635,17 @@ public:
       return *this;
     }
 
   Octave_object eval (int, int, const Octave_object&);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
-  void stash_original_text (char *s)
+  void stash_original_text (const string& s)
     { rep->stash_original_text (s); }
 
   // Pretty print this constant.
  
   void print_code (ostream& os);
 
   char *type_as_string (void) const
     { return rep->type_as_string (); }
@@ -660,21 +675,21 @@ private:
 
   tree_constant make_numeric (int frc_str_conv = 0) const
     {
       if (is_numeric_type ())
 	return *this;
       else
 	return rep->make_numeric (frc_str_conv);
     }
-};
+
+  int print_as_scalar (void) { return rep->print_as_scalar (); }
 
-extern int print_as_scalar (const tree_constant& val);
-
-extern int print_as_structure (const tree_constant& val);
+  int print_as_structure (void) { return rep->print_as_structure (); }
+};
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -48,49 +48,16 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 
 // Nonzero means we're returning from a function.
 extern int returning;
 
 // Nonzero means we're breaking out of a loop or function body.
 extern int breaking;
 
-// But first, some extra functions used by the tree classes.
-
-static void
-print_constant (tree_constant& tc, char *name, int print_padding = 1)
-{
-  int pad_after = 0;
-  if (user_pref.print_answer_id_name)
-    {
-      if (print_as_scalar (tc) || print_as_structure (tc))
-	{
-	  ostrstream output_buf;
-	  output_buf << name << " = " << ends;
-	  maybe_page_output (output_buf);
-	}
-      else
-	{
-	  pad_after = 1;
-	  ostrstream output_buf;
-	  output_buf << name << " =\n\n" << ends;
-	  maybe_page_output (output_buf);
-	}
-    }
-
-  tc.eval (1);
-
-  if (print_padding && pad_after)
-    {
-      ostrstream output_buf;
-      output_buf << "\n" << ends;
-      maybe_page_output (output_buf);
-    }
-}
-
 // Prefix expressions.
 
 tree_prefix_expression::~tree_prefix_expression (void)
 {
   delete id;
 }
 
 tree_constant
@@ -710,17 +677,17 @@ tree_simple_assignment_expression::eval 
 		  if (error_state)
 		    eval_error ();
 		}
 	    }
 	}
     }
 
   if (! error_state && print && retval.is_defined ())
-    print_constant (retval, lhs->name ());
+    retval.print_with_name (lhs->name ());
 
   return retval;
 }
 
 void
 tree_simple_assignment_expression::eval_error (void)
 {
   if (error_state > 0)
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -76,18 +76,16 @@ tree_function::bind_nargin_and_nargout (
 }
 
 tree_function::~tree_function (void)
 {
   delete param_list;
   delete ret_list;
   delete sym_tab;
   delete cmd_list;
-  delete [] file_name;
-  delete [] fcn_name;
   delete vr_list;
 }
 
 #if 0
 tree_function *
 tree_function::define (tree statement_list *t)
 {
   cmd_list = t;
@@ -118,43 +116,42 @@ tree_function::define_ret_list (tree_par
     vr_list = new tree_va_return_list;
  
   return this;
 }
 
 void
 tree_function::stash_fcn_file_name (void)
 {
-  delete [] file_name;
-  file_name = fcn_name ? fcn_file_in_path (fcn_name) : 0;
+  if (fcn_name.empty ())
+    file_name = "";
+  else
+    file_name = fcn_file_in_path (fcn_name);
 }
 
 void
 tree_function::mark_as_system_fcn_file (void)
 {
-  if (file_name)
+  if (! file_name.empty ())
     {
       // We really should stash the whole path to the file we found,
       // when we looked it up, to avoid possible race conditions...
       // XXX FIXME XXX
       //
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
-      char *ff_name = fcn_file_in_path (file_name);
-
-      char *system_dir = octave_fcn_file_dir ();
-      int len = strlen (system_dir);
+      string ff_name = fcn_file_in_path (file_name);
 
-      if (strncmp (system_dir, ff_name, len) == 0)
+      string system_dir = octave_fcn_file_dir ();
+
+      if (system_dir.compare (ff_name, 0, system_dir.length ()) == 0)
 	system_fcn_file = 1;
-
-      delete [] ff_name;
     }
   else
     system_fcn_file = 0;
 }
 
 int
 tree_function::takes_varargs (void) const
 {
@@ -199,20 +196,19 @@ void
 tree_function::octave_vr_val (const tree_constant& val)
 {
   assert (vr_list);
 
   vr_list->append (val);
 }
 
 void
-tree_function::stash_function_name (char *s)
+tree_function::stash_function_name (const string& s)
 {
-  delete [] fcn_name;
-  fcn_name = strsave (s);
+  fcn_name = s;
 }
 
 tree_constant
 tree_function::eval (int print)
 {
   tree_constant retval;
 
   if (error_state || ! cmd_list)
@@ -299,17 +295,18 @@ tree_function::eval (int /* print */, in
   // eval_undefined_error().
 
   unwind_protect_ptr (curr_sym_tab);
   curr_sym_tab = sym_tab;
 
   unwind_protect_ptr (curr_function);
   curr_function = this;
 
-  //  unwind_protect_ptr (args_passed);
+  // XXX FIXME XXX -- ???
+  // unwind_protect_ptr (args_passed);
 
   args_passed = args;
 
   unwind_protect_int (num_args_passed);
   num_args_passed = nargin;
 
   unwind_protect_int (num_named_args);
   unwind_protect_int (curr_va_arg_number);
@@ -378,29 +375,30 @@ tree_function::eval (int /* print */, in
 }
 
 void
 tree_function::traceback_error (void)
 {
   if (error_state >= 0)
     error_state = -1;
 
-  if (fcn_name)
+  if (fcn_name.empty ())
     {
-      if (file_name)
-	::error ("called from `%s' in file `%s'", fcn_name, file_name);
-      else 
-	::error ("called from `%s'", fcn_name);
+      if (file_name.empty ())
+	::error ("called from `?unknown?'");
+      else
+	::error ("called from file `%s'", file_name.c_str ());
     }
   else
     {
-      if (file_name)
-	::error ("called from file `%s'", file_name);
-      else
-	::error ("called from `?unknown?'");
+      if (file_name.empty ())
+	::error ("called from `%s'", fcn_name.c_str ());
+      else 
+	::error ("called from `%s' in file `%s'",
+		 fcn_name.c_str (), file_name.c_str ());
     }
 }
 
 void
 tree_function::print_code (ostream& os)
 {
   print_code_reset ();
 
@@ -442,17 +440,17 @@ tree_function::print_code_function_heade
       ret_list->print_code (os);
 
       if (len > 1)
 	os << "]";
 
       os << " = ";
     }
 
-  os << (fcn_name ? fcn_name : "(null)") << " ";
+  os << (fcn_name.empty () ? string ("(empty)") : fcn_name) << " ";
 
   if (param_list)
     {
       int len = param_list->length ();
       if (len > 0)
 	os << "(";
 
       param_list->print_code (os);
diff --git a/src/pt-fcn.h b/src/pt-fcn.h
--- a/src/pt-fcn.h
+++ b/src/pt-fcn.h
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <ctime>
 
 class ostream;
 
+#include <string>
+
 class tree_parameter_list;
 class tree_statement_list;
 class tree_va_return_list;
 
 #include "oct-obj.h"
 #include "symtab.h"
 #include "pt-fvc.h"
 
@@ -52,18 +54,16 @@ private:
 
   void init (void)
     {
       call_depth = 0;
       param_list = 0;
       ret_list = 0;
       sym_tab = 0;
       cmd_list = 0;
-      file_name = 0;
-      fcn_name = 0;
       t_parsed = 0;
       system_fcn_file = 0;
       num_named_args = 0;
       num_args_passed = 0;
       curr_va_arg_number = 0;
       vr_list = 0;
     }
 
@@ -87,17 +87,17 @@ public:
   tree_function *define_param_list (tree_parameter_list *t);
   tree_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (void);
 
   void stash_fcn_file_time (time_t t)
     { t_parsed = t; }
 
-  char *fcn_file_name (void)
+  string fcn_file_name (void)
     { return file_name; }
 
   time_t time_parsed (void)
     { return t_parsed; }
 
   void mark_as_system_fcn_file (void);
 
   int is_system_fcn_file (void) const
@@ -111,37 +111,37 @@ public:
   tree_constant octave_va_arg (void);
 
   Octave_object octave_all_va_args (void);
 
   int takes_var_return (void) const;
 
   void octave_vr_val (const tree_constant& val);
 
-  void stash_function_name (char *s);
+  void stash_function_name (const string& s);
 
-  char *function_name (void)
+  string function_name (void)
     { return fcn_name; }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void traceback_error (void);
 
   void print_code (ostream& os);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
   symbol_table *sym_tab;
   tree_statement_list *cmd_list;
-  char *file_name;
-  char *fcn_name;
+  string file_name;
+  string fcn_name;
   time_t t_parsed;
   int system_fcn_file;
   int num_named_args;
   Octave_object args_passed;
   int num_args_passed;
   int curr_va_arg_number;
   tree_va_return_list *vr_list;
   symbol_record *nargin_sr;
diff --git a/src/pt-fvc-base.cc b/src/pt-fvc-base.cc
--- a/src/pt-fvc-base.cc
+++ b/src/pt-fvc-base.cc
@@ -42,31 +42,32 @@ Software Foundation, 59 Temple Place - S
 
 tree_constant
 tree_fvc::assign (tree_constant&, const Octave_object&)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
-char *
+string
 tree_fvc::name (void) const
 {
+  string retval;
   panic_impossible ();
-  return 0;
+  return retval;
 }
 
 void
 tree_fvc::bump_value (tree_expression::type)
 {
   panic_impossible ();
 }
 
 tree_constant
-tree_fvc::lookup_map_element (SLList<char*>&, int, int)
+tree_fvc::lookup_map_element (SLList<string>&, int, int)
 {
   static tree_constant retval;
 
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("invalid structure reference");
diff --git a/src/pt-fvc-base.h b/src/pt-fvc-base.h
--- a/src/pt-fvc-base.h
+++ b/src/pt-fvc-base.h
@@ -27,16 +27,18 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <ctime>
 
 class ostream;
 
+#include <string>
+
 #include <SLList.h>
 
 class tree_constant;
 class Octave_object;
 
 #include "pt-mvr-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
@@ -47,25 +49,25 @@ tree_fvc : public tree_multi_val_ret
 public:
   tree_fvc (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
 
   ~tree_fvc (void) { }
 
   virtual tree_constant assign (tree_constant& t,
 				const Octave_object& args);
 
-  virtual char *name (void) const;
+  virtual string name (void) const;
 
   virtual void bump_value (tree_expression::type);
 
-  virtual tree_constant lookup_map_element (SLList<char*>& list,
+  virtual tree_constant lookup_map_element (SLList<string>& list,
 					    int insert = 0, int silent = 0);
 
-  virtual char *fcn_file_name (void)
-    { return 0; }
+  virtual string fcn_file_name (void)
+    { return string (); }
 
   virtual time_t time_parsed (void);
 
   virtual int is_system_fcn_file (void) const
     { return 0; }
 
   virtual int save (ostream& /* os */, int /* mark_as_global */ = 0,
 		    int /* precision */ = 17);
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -66,47 +66,16 @@ any_element_greater_than (const Matrix& 
   int nc = a.columns ();
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       if (a.elem (i, j) > val)
 	return 1;
   return 0;
 }
 
-static void
-print_constant (tree_constant& tc, char *name, int print_padding = 1)
-{
-  int pad_after = 0;
-  if (user_pref.print_answer_id_name)
-    {
-      if (print_as_scalar (tc) || print_as_structure (tc))
-	{
-	  ostrstream output_buf;
-	  output_buf << name << " = " << ends;
-	  maybe_page_output (output_buf);
-	}
-      else
-	{
-	  pad_after = 1;
-	  ostrstream output_buf;
-	  output_buf << name << " =\n\n" << ends;
-	  maybe_page_output (output_buf);
-	}
-    }
-
-  tc.eval (1);
-
-  if (print_padding && pad_after)
-    {
-      ostrstream output_buf;
-      output_buf << "\n" << ends;
-      maybe_page_output (output_buf);
-    }
-}
-
 // Make sure that all arguments have values.
 
 // Are any of the arguments `:'?
 
 static int
 any_arg_is_magic_colon (const Octave_object& args)
 {
   int nargin = args.length ();
@@ -115,20 +84,23 @@ any_arg_is_magic_colon (const Octave_obj
     if (args(i).is_magic_colon ())
 	return 1;
 
   return 0;
 }
 
 // Symbols from the symbol table.
 
-char *
+string
 tree_identifier::name (void) const
 {
-  return sym ? sym->name () : 0;
+  string retval;
+  if (sym)
+    retval = sym->name ();
+  return retval;
 }
 
 tree_identifier *
 tree_identifier::define (tree_constant *t)
 {
   int status = sym->define (t);
   return status ? this : 0;
 }
@@ -136,20 +108,20 @@ tree_identifier::define (tree_constant *
 tree_identifier *
 tree_identifier::define (tree_function *t)
 {
   int status = sym->define (t);
   return status ? this : 0;
 }
 
 void
-tree_identifier::document (char *s)
+tree_identifier::document (const string& s)
 {
-  if (sym && s)
-    sym->document (strsave (s));
+  if (sym)
+    sym->document (s);
 }
 
 tree_constant
 tree_identifier::assign (tree_constant& rhs)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
@@ -221,17 +193,17 @@ tree_identifier::assign (tree_constant& 
 	    }
 	}
     }
 
   return retval;
 }
 
 tree_constant
-tree_identifier::assign (SLList<char*> list, tree_constant& rhs)
+tree_identifier::assign (SLList<string> list, tree_constant& rhs)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
 
@@ -253,17 +225,17 @@ tree_identifier::assign (SLList<char*> l
       if (tmp)
 	retval = tmp->assign_map_element (list, rhs);
     }
 
   return retval;
 }
 
 tree_constant
-tree_identifier::assign (SLList<char*> list, tree_constant& rhs,
+tree_identifier::assign (SLList<string> list, tree_constant& rhs,
 			 const Octave_object& args)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (sym->is_function ())
 	sym->clear ();
@@ -312,37 +284,38 @@ tree_identifier::is_defined (void)
 
 void
 tree_identifier::bump_value (tree_expression::type etype)
 {
   if (sym)
     {
       if (sym->is_read_only ())
 	{
-	  ::error ("can't redefined read-only variable `%s'", name ());
+	  ::error ("can't redefined read-only variable `%s'",
+		   name ().c_str ());
 	}
       else
 	{
 	  tree_fvc *tmp = sym->def ();
 	  if (tmp)
 	    tmp->bump_value (etype);
 	}
     }
 }
 
 void
 tree_identifier::eval_undefined_error (void)
 {
-  char *nm = name ();
   int l = line ();
   int c = column ();
   if (l == -1 && c == -1)
-    ::error ("`%s' undefined", nm);
+    ::error ("`%s' undefined", name ().c_str ());
   else
-    ::error ("`%s' undefined near line %d column %d", nm, l, c);
+    ::error ("`%s' undefined near line %d column %d",
+	     name ().c_str (), l, c);
 }
 
 // Try to find a definition for an identifier.  Here's how:
 //
 //   * If the identifier is already defined and is a function defined
 //     in an function file that has been modified since the last time 
 //     we parsed it, parse it again.
 //
@@ -415,17 +388,17 @@ tree_identifier::eval (int print)
 	eval_undefined_error ();
     }
 
   if (! error_state && retval.is_defined ())
     {
       if (maybe_do_ans_assign && ! object_to_eval->is_constant ())
 	bind_ans (retval, print);
       else if (print)
-	print_constant (retval, name ());
+	retval.print_with_name (name ());
     }
 
   return retval;
 }
 
 Octave_object
 tree_identifier::eval (int print, int nargout, const Octave_object& args)
 {
@@ -468,70 +441,54 @@ tree_identifier::eval (int print, int na
 void
 tree_identifier::print_code (ostream& os)
 {
   print_code_indent (os);
 
   if (in_parens)
     os << "(";
 
-  char *nm = name ();
-  os << (nm) ? nm : "(null)";
+  string nm = name ();
+  os << (nm.empty () ? string ("(empty)") : nm);
 
   if (in_parens)
     os << ")";
 }
 
 // Indirect references to values (structure elements).
 
 tree_indirect_ref::~tree_indirect_ref (void)
 {
-  while (! refs.empty ())
-    {
-      char *t = refs.remove_front ();
-      delete [] t;
-    }
-
   if (! preserve_ident)
     delete id;
 }
 
 tree_indirect_ref *
-tree_indirect_ref::chain (const char *elt)
+tree_indirect_ref::chain (const string& elt)
 {
-  refs.append (strsave (elt));
+  refs.append (elt);
   return this;
 }
 
-char *
-tree_indirect_ref::name (void)
+string
+tree_indirect_ref::name (void) const
 {
-  char *id_nm = id->name ();
+  string id_nm = id->name ();
+
   if (refs.empty ())
     return id_nm;
   else
     {
-      static char *nm = 0;
-      delete [] nm;
-
-      ostrstream tmp;
-
-      tmp << id_nm;
-
       for (Pix p = refs.first (); p != 0; refs.next (p))
 	{
-	  char *elt = refs (p);
-
-	  if (elt)
-	    tmp << "." << elt;
+	  id_nm.append (".");
+	  id_nm.append (refs (p));
 	}
 
-      tmp << ends;
-      nm = tmp.str ();
-      return nm;
+      return id_nm;
     }
 }
 
 tree_constant
 tree_indirect_ref::assign (tree_constant& t)
 {
   tree_constant retval;
 
@@ -574,17 +531,17 @@ tree_indirect_ref::eval (int print)
 
       tree_fvc *object_to_eval = id->do_lookup (script_file_executed, 0);
 
       if (object_to_eval)
 	{
 	  retval = object_to_eval->lookup_map_element (refs);
 
 	  if (! error_state && print)
-	    print_constant (retval, name ());
+	    retval.print_with_name (name ());
 	}
       else
 	id->eval_undefined_error ();
     }
 
   return retval;
 }
 
@@ -613,17 +570,17 @@ tree_indirect_ref::eval (int print, int 
 	  if (! error_state)
 	    {
 	      retval = tmp.eval (0, nargout, args);
 
 	      if (! error_state && print)
 		{
 		  tmp = retval (0);
 		  if (tmp.is_defined ())
-		    print_constant (tmp, name ());
+		    tmp.print_with_name (name ());
 		}
 	    }
 	}
       else
 	id->eval_undefined_error ();
     }
 
   return retval;
@@ -632,54 +589,48 @@ tree_indirect_ref::eval (int print, int 
 void
 tree_indirect_ref::print_code (ostream& os)
 {
   print_code_indent (os);
 
   if (in_parens)
     os << "(";
 
-  char *nm = id ? id->name () : "(null)";
-  os << (nm) ? nm : "(null)";
+  string nm = id ? id->name () : string ("(null)");
+  os << (nm.empty () ? string ("(empty)") : nm);
 
   for (Pix p = refs.first (); p != 0; refs.next (p))
-    {
-      char *elt = refs (p);
-
-      if (elt)
-	os << "." << elt;
-    }
+    os << "." << refs (p);
 
   if (in_parens)
     os << ")";
 }
 
 // Builtin functions.
 
-tree_builtin::tree_builtin (const char *nm)
+tree_builtin::tree_builtin (const string& nm)
 {
   is_mapper = 0;
   fcn = 0;
-  if (nm)
-    my_name = strsave (nm);
+  my_name = nm;
 }
 
-tree_builtin::tree_builtin (Mapper_fcn& m_fcn, const char *nm)
+tree_builtin::tree_builtin (Mapper_fcn& m_fcn, const string &nm)
 {
   mapper_fcn = m_fcn;
   is_mapper = 1;
   fcn = 0;
-  my_name = nm ? strsave (nm) : 0;
+  my_name = nm;
 }
 
-tree_builtin::tree_builtin (Octave_builtin_fcn g_fcn, const char *nm)
+tree_builtin::tree_builtin (Octave_builtin_fcn g_fcn, const string& nm)
 {
   is_mapper = 0;
   fcn = g_fcn;
-  my_name = nm ? strsave (nm) : 0;
+  my_name = nm;
 }
 
 tree_constant
 tree_builtin::eval (int /* print */)
 {
   tree_constant retval;
 
   if (error_state)
@@ -691,26 +642,26 @@ tree_builtin::eval (int /* print */)
 
       Octave_object args;
       Octave_object tmp = (*fcn) (args, 0);
       if (tmp.length () > 0)
 	retval = tmp(0);
     }
   else if (is_mapper)
     {
-      ::error ("%s: too few arguments", my_name);
+      ::error ("%s: too few arguments", my_name.c_str ());
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
       if (fcn)
 	goto eval_fcn;
       else
-	::error ("unable to load builtin function %s", my_name);
+	::error ("unable to load builtin function %s", my_name.c_str ());
     }
 
   return retval;
 }
 
 static tree_constant
 apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn,
 		  int /* print */)
@@ -724,71 +675,77 @@ apply_mapper_fcn (const tree_constant& a
 	  double d = arg.double_value ();
 
 	  if (m_fcn.can_return_complex_for_real_arg
 	      && (d < m_fcn.lower_limit || d > m_fcn.upper_limit))
 	    {
 	      if (m_fcn.c_c_mapper)
 		retval = m_fcn.c_c_mapper (Complex (d));
 	      else
-		error ("%s: unable to handle real arguments", m_fcn.name);
+		error ("%s: unable to handle real arguments",
+		       m_fcn.name.c_str ());
 	    }
 	  else if (m_fcn.d_d_mapper)
 	    retval = m_fcn.d_d_mapper (d);
 	  else
-	    error ("%s: unable to handle real arguments", m_fcn.name);
+	    error ("%s: unable to handle real arguments",
+		   m_fcn.name.c_str ());
 	}
       else
 	{
 	  Matrix m = arg.matrix_value ();
 
 	  if (error_state)
 	    return retval;
 
 	  if (m_fcn.can_return_complex_for_real_arg
 	      && (any_element_less_than (m, m_fcn.lower_limit)
 		  || any_element_greater_than (m, m_fcn.upper_limit)))
 	    {
 	      if (m_fcn.c_c_mapper)
 		retval = map (m_fcn.c_c_mapper, ComplexMatrix (m));
 	      else
-		error ("%s: unable to handle real arguments", m_fcn.name);
+		error ("%s: unable to handle real arguments",
+		       m_fcn.name.c_str ());
 	    }
 	  else if (m_fcn.d_d_mapper)
 	    retval = map (m_fcn.d_d_mapper, m);
 	  else
-	    error ("%s: unable to handle real arguments", m_fcn.name);
+	    error ("%s: unable to handle real arguments",
+		   m_fcn.name.c_str ());
 	}
     }
   else if (arg.is_complex_type ())
     {
       if (arg.is_scalar_type ())
 	{
 	  Complex c = arg.complex_value ();
 
 	  if (m_fcn.d_c_mapper)
 	    retval = m_fcn.d_c_mapper (c);
 	  else if (m_fcn.c_c_mapper)
 	    retval = m_fcn.c_c_mapper (c);
 	  else
-	    error ("%s: unable to handle complex arguments", m_fcn.name);
+	    error ("%s: unable to handle complex arguments",
+		   m_fcn.name.c_str ());
 	}
       else
 	{
 	  ComplexMatrix cm = arg.complex_matrix_value ();
 
 	  if (error_state)
 	    return retval;
 
 	  if (m_fcn.d_c_mapper)
 	    retval = map (m_fcn.d_c_mapper, cm);
 	  else if (m_fcn.c_c_mapper)
 	    retval = map (m_fcn.c_c_mapper, cm);
 	  else
-	    error ("%s: unable to handle complex arguments", m_fcn.name);
+	    error ("%s: unable to handle complex arguments",
+		   m_fcn.name.c_str ());
 	}
     }
   else
     gripe_wrong_type_arg ("mapper", arg);
 
   return retval;
 }
 
@@ -811,36 +768,36 @@ tree_builtin::eval (int /* print */, int
       else
 	retval = (*fcn) (args, nargout);
     }
   else if (is_mapper)
     {
 // XXX FIXME XXX -- should we just assume nargin_max == 1?
 //
 //      if (nargin > nargin_max)
-//	::error ("%s: too many arguments", my_name);
+//	::error ("%s: too many arguments", my_name.c_str ());
 //      else
       if (nargin > 0 && args(0).is_defined ())
 	{
 	  tree_constant tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
 	  retval(0) = tmp;
 	}
       else
 	{
-	  ::error ("%s: too few arguments", my_name);
+	  ::error ("%s: too few arguments", my_name.c_str ());
 	}
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
       if (fcn)
 	goto eval_fcn;
       else
-	::error ("unable to load builtin function %s", my_name);
+	::error ("unable to load builtin function %s", my_name.c_str ());
     }
 
   return retval;
 }
 
 void
 tree_builtin::print_code (ostream& os)
 {
diff --git a/src/pt-fvc.h b/src/pt-fvc.h
--- a/src/pt-fvc.h
+++ b/src/pt-fvc.h
@@ -53,28 +53,28 @@ public:
   tree_identifier (symbol_record *s, int l = -1, int c = -1)
     : tree_fvc (l, c), sym (s), maybe_do_ans_assign (0) { }
 
   ~tree_identifier (void) { }
 
   int is_identifier (void) const
     { return 1; }
 
-  char *name (void) const;
+  string name (void) const;
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
-  void document (char *s);
+  void document (const string& s);
 
   tree_constant assign (tree_constant& t);
   tree_constant assign (tree_constant& t, const Octave_object& args);
 
-  tree_constant assign (SLList<char*> list, tree_constant& t);
-  tree_constant assign (SLList<char*> list, tree_constant& t,
+  tree_constant assign (SLList<string> list, tree_constant& t);
+  tree_constant assign (SLList<string> list, tree_constant& t,
 			const Octave_object& args); 
 
   int is_defined (void);
 
   void bump_value (tree_expression::type);
 
   tree_fvc *do_lookup (int& script_file_executed, int exec_script = 1);
 
@@ -107,83 +107,83 @@ public:
   tree_indirect_ref (int l = -1, int c = -1)
     : tree_fvc (l, c), id (0), preserve_ident (0) { }
 
   tree_indirect_ref (tree_identifier *i, int l = -1, int c = -1)
     : tree_fvc (l, c), id (i), preserve_ident (0) { }
 
   ~tree_indirect_ref (void);
 
-  tree_indirect_ref *chain (const char *s);
+  tree_indirect_ref *chain (const string& s);
 
   int is_indirect_ref (void) const
     { return 1; }
 
   int is_identifier_only (void) const
     { return (id && refs.empty ()); }
 
   tree_identifier *ident (void)
     { return id; }
 
   void preserve_identifier (void)
     { preserve_ident = 1; }
 
-  char *name (void);
+  string name (void) const;
 
   tree_constant assign (tree_constant& t);
   tree_constant assign (tree_constant& t, const Octave_object& args);
 
   void mark_for_possible_ans_assign (void)
     { id->mark_for_possible_ans_assign (); }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void print_code (ostream& os);
 
 private:
   tree_identifier *id;
-  SLList<char*> refs;
+  SLList<string> refs;
   int preserve_ident;
 };
 
 // Builtin functions.
 
 class
 tree_builtin : public tree_fvc
 {
 public:
-  tree_builtin (const char *nm = 0);
+  tree_builtin (const string& nm = string ());
 
-  tree_builtin (Mapper_fcn& m_fcn, const char *nm = 0);
+  tree_builtin (Mapper_fcn& m_fcn, const string& nm = string ());
 
-  tree_builtin (Octave_builtin_fcn f, const char *nm = 0);
+  tree_builtin (Octave_builtin_fcn f, const string& nm = string ());
 
   ~tree_builtin (void) { }  // XXX ?? XXX
 
 //  int is_builtin (void) const;
 
   int is_mapper_function (void) const
     { return is_mapper; }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
-  char *name (void) const
+  string name (void) const
     { return my_name; }
 
   void print_code (ostream& os);
 
 private:
   int is_mapper;
   Mapper_fcn mapper_fcn;
   Octave_builtin_fcn fcn;
-  char *my_name;
+  string my_name;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/pt-mvr.cc b/src/pt-mvr.cc
--- a/src/pt-mvr.cc
+++ b/src/pt-mvr.cc
@@ -39,47 +39,16 @@ Software Foundation, 59 Temple Place - S
 #include "pt-exp.h"
 #include "pt-fvc.h"
 #include "pt-misc.h"
 #include "pt-mvr.h"
 #include "user-prefs.h"
 
 // But first, some extra functions used by the tree classes.
 
-static void
-print_constant (tree_constant& tc, char *name, int print_padding = 1)
-{
-  int pad_after = 0;
-  if (user_pref.print_answer_id_name)
-    {
-      if (print_as_scalar (tc) || print_as_structure (tc))
-	{
-	  ostrstream output_buf;
-	  output_buf << name << " = " << ends;
-	  maybe_page_output (output_buf);
-	}
-      else
-	{
-	  pad_after = 1;
-	  ostrstream output_buf;
-	  output_buf << name << " =\n\n" << ends;
-	  maybe_page_output (output_buf);
-	}
-    }
-
-  tc.eval (1);
-
-  if (print_padding && pad_after)
-    {
-      ostrstream output_buf;
-      output_buf << "\n" << ends;
-      maybe_page_output (output_buf);
-    }
-}
-
 // Make sure that all arguments have values.
 
 static int
 all_args_defined (const Octave_object& args)
 {
   int nargin = args.length ();
 
   for (int i = 0; i < nargin; i++)
@@ -123,17 +92,17 @@ tree_index_expression::tree_index_expres
       }
 
 tree_index_expression::~tree_index_expression (void)
 {
   delete id;
   delete list;
 }
 
-char *
+string
 tree_index_expression::name (void)
 {
   return id->name ();
 }
 
 void
 tree_index_expression::mark_for_possible_ans_assign (void)
 {
@@ -375,17 +344,17 @@ tree_multi_assignment_expression::eval (
 	      if (print && pad_after)
 		{
 		  ostrstream output_buf;
 		  output_buf << "\n" << ends;
 		  maybe_page_output (output_buf);
 		}
 
 	      if (print)
-		print_constant (results(i), lhs_expr->name (), 0);
+		results(i).print_with_name (lhs_expr->name (), 0);
 
 	      pad_after++;
 	      i++;
 	    }
 	  else
 	    {
 	      tree_simple_assignment_expression tmp_expr
 		(lhs_expr, 0, 1, 0, ma_line, ma_column);
diff --git a/src/pt-mvr.h b/src/pt-mvr.h
--- a/src/pt-mvr.h
+++ b/src/pt-mvr.h
@@ -33,16 +33,18 @@ class ostream;
 class Octave_object;
 
 class tree_argument_list;
 class tree_identifier;
 class tree_index_expression;
 class tree_indirect_ref;
 class tree_return_list;
 
+#include <string>
+
 #include "pt-const.h"
 #include "pt-mvr-base.h"
 #include "oct-obj.h"
 
 // Used internally.
 
 class
 tree_oct_obj : public tree_multi_val_ret
@@ -89,17 +91,17 @@ public:
   ~tree_index_expression (void);
 
   int is_index_expression (void) const
     { return 1; }
 
   tree_indirect_ref *ident (void)
     { return id; }
 
-  char *name (void);
+  string name (void);
 
   tree_argument_list *arg_list (void)
     { return list; }
 
   void mark_for_possible_ans_assign (void);
 
   tree_constant eval (int print);
 
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -40,16 +40,18 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include "SLStack.h"
 #include "procstream.h"
 
+#include "str-vec.h"
+
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "load-save.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "pt-cmd.h"
@@ -116,33 +118,34 @@ open_plot_stream (void)
     }
 
   if (! plot_stream)
     {
       initialized = 0;
 
       plot_line_count = 0;
 
-      char *plot_prog = user_pref.gnuplot_binary;
-      if (plot_prog)
+      string plot_prog = user_pref.gnuplot_binary;
+
+      if (! plot_prog.empty ())
 	{
-	  plot_stream = new oprocstream (plot_prog);
+	  plot_stream = new oprocstream (plot_prog.c_str ());
 
 	  if (plot_stream && ! *plot_stream)
 	    {
 	      delete plot_stream;
 	      plot_stream = 0;
 	    }
 
 	  if (! plot_stream)
 	    {
 	      warning ("plot: unable to open pipe to `%s'",
-		       plot_prog);
+		       plot_prog.c_str ());
 
-	      if (strcmp (plot_prog, "gnuplot") != 0)
+	      if (plot_prog == "gnuplot")
 		{
 		  warning ("having trouble finding plotting program.");
 		  warning ("trying again with `gnuplot'");
 		  goto last_chance;
 		}
 	    }
 	}
       else
@@ -153,17 +156,18 @@ open_plot_stream (void)
 
 	  if (plot_stream && ! *plot_stream)
 	    {
 	      delete plot_stream;
 	      plot_stream = 0;
 	    }
 
 	  if (! plot_stream)
-	    error ("plot: unable to open pipe to `%s'", plot_prog);
+	    error ("plot: unable to open pipe to `%s'",
+		   plot_prog.c_str ());
 	}
     }
 
   if (! error_state && plot_stream && *plot_stream && ! initialized)
     {
       initialized = 1;
       *plot_stream << "set data style lines\n";
 
@@ -553,49 +557,48 @@ subplot_using::print_code (ostream& os)
       if (i > 0)
 	os << ":";
 
       if (x[i])
 	x[i]->print_code (os);
     }
 }
 
-subplot_style::subplot_style (char *s)
+subplot_style::subplot_style (const string& s)
 {
-  style = strsave (s);
+  style = s;
   linetype = 0;
   pointtype = 0;
 }
 
-subplot_style::subplot_style (char *s, tree_expression *lt)
+subplot_style::subplot_style (const string& s, tree_expression *lt)
 {
-  style = strsave (s);
+  style = s;
   linetype = lt;
   pointtype = 0;
 }
 
-subplot_style::subplot_style (char *s, tree_expression *lt,
+subplot_style::subplot_style (const string& s, tree_expression *lt,
 			      tree_expression *pt)
 {
-  style = strsave (s);
+  style = s;
   linetype = lt;
   pointtype = pt;
 }
 
 subplot_style::~subplot_style (void)
 {
-  delete [] style;
   delete linetype;
   delete pointtype;
 }
 
 int
 subplot_style::print (ostrstream& plot_buf)
 {
-  if (style)
+  if (! style.empty ())
     {
       plot_buf << " " << GNUPLOT_COMMAND_WITH << " " << style;
 
       if (linetype)
 	{
 	  tree_constant tmp = linetype->eval (0);
 	  if (! error_state && tmp.is_defined ())
 	    {
@@ -640,19 +643,18 @@ subplot_style::print (ostrstream& plot_b
     return -1;
 
   return 0;
 }
 
 int
 subplot_style::errorbars (void)
 {
-  return (style
-	  && (almost_match ("errorbars", style, 1, 0)
-	      || almost_match ("boxerrorbars", style, 5, 0)));
+  return (almost_match ("errorbars", style, 1, 0)
+	  || almost_match ("boxerrorbars", style, 5, 0));
 }
 
 void
 subplot_style::print_code (ostream& os)
 {
   os << " with " << style;
 
   if (linetype)
@@ -904,46 +906,49 @@ subplot_list::print_code (ostream& os)
 	  elt->print_code (os);
 
 	  if (p)
 	    os << ",";
 	}
     }
 }
 
-char *
+string
 save_in_tmp_file (tree_constant& t, int ndim, int parametric)
 {
-  char *name = octave_tmp_file_name ();
-  if (name)
+  string name = octave_tmp_file_name ();
+
+  if (! name.empty ())
     {
-      ofstream file (name);
+      ofstream file (name.c_str ());
+
       if (file)
 	{
 	  switch (ndim)
 	    {
 	    case 2:
-	      save_ascii_data (file, t, 0, 1);
+	      save_ascii_data (file, t, name, 1);
 	      break;
 
 	    case 3:
 	      save_three_d (file, t, parametric);
 	      break;
 
 	    default:
 	      gripe_2_or_3_dim_plot ();
 	      break;
 	    }
 	}
       else
 	{
-	  error ("couldn't open temporary output file `%s'", name);
-	  name = 0;
+	  error ("couldn't open temporary output file `%s'", name.c_str ());
+	  name.resize (0);
 	}
     }
+
   return name;
 }
 
 void
 mark_for_deletion (const string& file)
 {
   tmp_files.push (file);
 }
@@ -966,17 +971,17 @@ close_plot_stream (void)
       delete plot_stream;
       plot_stream = 0;
     }
 
   plot_line_count = 0;
 }
 
 void
-do_external_plotter_cd (const char *newdir)
+do_external_plotter_cd (const string& newdir)
 {
   if (plot_stream && *plot_stream)
     {
       ostrstream plot_buf;
       plot_buf << "cd \"" << newdir << "\"\n" << ends;
       char *message = plot_buf.str ();
       send_to_plot_stream (message);
       delete [] message;
@@ -1020,40 +1025,43 @@ DEFUN ("closeplot", Fcloseplot, Sclosepl
 DEFUN_TEXT ("hold", Fhold, Shold, 10,
   "hold [on|off]\n\
 \n\
 determine whether the plot window is cleared before the next line is\n\
 drawn.  With no argument, toggle the current state.") 
 {
   Octave_object retval;
 
-  DEFINE_ARGV("hold");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "hold");
+
+  if (error_state)
+    return retval;
 
   switch (argc)
     {
     case 1:
       clear_before_plotting = ! clear_before_plotting;
       break;
 
     case 2:
-      if (strcasecmp (argv[1], "on") == 0)
+      if (argv[1] == "on")
 	clear_before_plotting = 0;
-      else if (strcasecmp (argv[1], "off") == 0)
+      else if (argv[1] == "off")
 	clear_before_plotting = 1;
       else
 	print_usage ("hold");
       break;
 
     default:
       print_usage ("hold");
       break;
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN ("ishold", Fishold, Sishold, 00,
   "ishold\n\
 \n\
 Return 1 if hold is on, otherwise return 0.")
 {
@@ -1070,17 +1078,22 @@ DEFUN ("purge_tmp_files", Fpurge_tmp_fil
 
 DEFUN_TEXT ("set", Fset, Sset, 10,
   "set [options]\n\
 \n\
 set plotting options")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("set");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "set");
+
+  if (error_state)
+    return retval;
 
   ostrstream plot_buf;
 
   if (argc > 1)
     {
       if (almost_match ("parametric", argv[1], 3))
 	parametric_plot = 1;
       else if (almost_match ("noparametric", argv[1], 5))
@@ -1101,44 +1114,45 @@ set plotting options")
 
   plot_buf << "\n" << ends;
 
   char *plot_command = plot_buf.str ();
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("show", Fshow, Sshow, 10,
   "show [options]\n\
 \n\
 show plotting options")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("show");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "show");
+
+  if (error_state)
+    return retval;
 
   ostrstream plot_buf;
 
   for (int i = 0; i < argc; i++)
     plot_buf << argv[i] << " ";
 
   plot_buf << "\n" << ends;
 
   char *plot_command = plot_buf.str ();
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -160,30 +160,30 @@ private:
 
 class
 subplot_style : public tree_print_code
 {
 public:
   subplot_style (void)
     : tree_print_code (), style (0), linetype (0), pointtype (0) { }
 
-  subplot_style (char *s);
-  subplot_style (char *s, tree_expression *lt);
-  subplot_style (char *s, tree_expression *lt, tree_expression *pt);
+  subplot_style (const string& s);
+  subplot_style (const string& s, tree_expression *lt);
+  subplot_style (const string& s, tree_expression *lt, tree_expression *pt);
 
   ~subplot_style (void);
 
   int print (ostrstream& plot_buf);
 
   int errorbars (void);
 
   void print_code (ostream& os);
 
 private:
-  char *style;
+  string style;
   tree_expression *linetype;
   tree_expression *pointtype;
 };
 
 class
 subplot : public tree_print_code
 {
 public:
@@ -229,26 +229,26 @@ public:
 
   ~subplot_list (void);
 
   int print (int ndim, ostrstream& plot_buf);
 
   void print_code (ostream& os);
 };
 
-extern char *save_in_tmp_file (tree_constant& t, int ndim = 2,
-			       int parametric = 0);
+extern string save_in_tmp_file (tree_constant& t, int ndim = 2,
+				int parametric = 0);
 
 extern void mark_for_deletion (const string&);
 
 extern void cleanup_tmp_files (void);
 
 extern void close_plot_stream (void);
 
-extern void do_external_plotter_cd (const char *newdir);
+extern void do_external_plotter_cd (const string& newdir);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -326,47 +326,47 @@ print_qpsol_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_qpsol_option (const char *keyword, double val)
+set_qpsol_option (const string& keyword, double val)
 {
   QPSOL_OPTIONS *list = qpsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  if (list->d_set_fcn)
 	    (qpsol_opts.*list->d_set_fcn) (val);
 	  else
 	    {
 	      if (xisnan (val))
 		{
 		  error ("qpsol_options: %s: expecting integer, found NaN",
-			 keyword);
+			 keyword.c_str ());
 		}
 	      else
 		(qpsol_opts.*list->i_set_fcn) (NINT (val));
 	    }
 	  return;
 	}
       list++;
     }
 
-  warning ("qpsol_options: no match for `%s'", keyword);
+  warning ("qpsol_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_qpsol_option (const char *keyword)
+show_qpsol_option (const string& keyword)
 {
   Octave_object retval;
 
   QPSOL_OPTIONS *list = qpsol_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -375,17 +375,17 @@ show_qpsol_option (const char *keyword)
 	  if (list->d_get_fcn)
 	    return (qpsol_opts.*list->d_get_fcn) ();
 	  else
 	    return (double) (qpsol_opts.*list->i_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("qpsol_options: no match for `%s'", keyword);
+  warning ("qpsol_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 #endif
 
 #if defined (QPSOL_MISSING)
 DEFUN_DLD_BUILTIN ("qpsol_options", Fqpsol_options, Sqpsol_options,
@@ -414,18 +414,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_qpsol_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_qpsol_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -309,53 +309,53 @@ print_quad_option_list (void)
       list++;
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 }
 
 static void
-set_quad_option (const char *keyword, double val)
+set_quad_option (const string& keyword, double val)
 {
   QUAD_OPTIONS *list = quad_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  (quad_opts.*list->d_set_fcn) (val);
 
 	  return;
 	}
       list++;
     }
 
-  warning ("quad_options: no match for `%s'", keyword);
+  warning ("quad_options: no match for `%s'", keyword.c_str ());
 }
 
 static Octave_object
-show_quad_option (const char *keyword)
+show_quad_option (const string& keyword)
 {
   Octave_object retval;
 
   QUAD_OPTIONS *list = quad_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
 	  return (quad_opts.*list->d_get_fcn) ();
 	}
       list++;
     }
 
-  warning ("quad_options: no match for `%s'", keyword);
+  warning ("quad_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("quad_options", Fquad_options, Squad_options,
 		   FSquad_options, 10,
   "quad_options (KEYWORD, VALUE)\n\
 \n\
@@ -368,18 +368,17 @@ to the shortest match.")
 
   if (nargin == 0)
     {
       print_quad_option_list ();
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string tstr = args(0).string_value ();
-      const char *keyword = tstr.c_str ();
+      string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_quad_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -58,35 +58,36 @@ characters:\n\
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("schur");
       return retval;
     }
 
   tree_constant arg = args(0);
 
-  const char *ord = "U";
-  string tstr;
+  string ord;
 
   if (nargin == 2)
     {
-      tstr = args(1).string_value (); 
-      ord = tstr.c_str ();
+      ord = args(1).string_value (); 
 
       if (error_state)
 	{
 	  error ("schur: expecting string as second argument");
 	  return retval;
 	}
     }
 
-  if (*ord != 'U' && *ord != 'A' && *ord != 'D'
-      && *ord != 'u' && *ord != 'a' && *ord != 'd')
+  char ord_char = ord.empty () ? 'U' : ord[0];
+
+  if (ord_char != 'U' && ord_char != 'A' && ord_char != 'D'
+      && ord_char != 'u' && ord_char != 'a' && ord_char != 'd')
     {
-      warning ("schur: incorrect ordered schur argument `%c'", *ord);
+      warning ("schur: incorrect ordered schur argument `%c'",
+	       ord.c_str ());
       return retval;
     }
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("schur", nr, nc);
 
@@ -102,17 +103,17 @@ characters:\n\
     }
 
   if (arg.is_real_type ())
     {
       Matrix tmp = arg.matrix_value ();
 
       if (! error_state)
 	{
-	  SCHUR result (tmp,ord);
+	  SCHUR result (tmp, ord);
 
 	  if (nargout == 0 || nargout == 1)
 	    {
 	      retval(0) = result.schur_matrix ();
 	    }
 	  else
 	    {
 	      retval(1) = result.schur_matrix ();
@@ -121,17 +122,17 @@ characters:\n\
 	}
     }
   else if (arg.is_complex_type ())
     {
       ComplexMatrix ctmp = arg.complex_matrix_value ();
 
       if (! error_state)
 	{
-	  ComplexSCHUR result (ctmp,ord);
+	  ComplexSCHUR result (ctmp, ord);
  
 	  if (nargout == 0 || nargout == 1)
 	    {
 	      retval(0) = result.schur_matrix ();
 	    }
 	  else
 	    {
 	      retval(1) = result.schur_matrix ();
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -26,21 +26,23 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "fnmatch.h"
 
+#include "str-vec.h"
+
 #include "error.h"
-#include "symtab.h"
 #include "pt-const.h"
 #include "pt-fcn.h"
 #include "pt-fvc.h"
+#include "symtab.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
 // Variables and functions.
 
 symbol_def::symbol_def (void)
 {
@@ -70,25 +72,23 @@ symbol_def::symbol_def (tree_function *t
 
 void
 symbol_def::init_state (void)
 {
   type = UNKNOWN;
   eternal = 0;
   read_only = 0;
 
-  help_string = 0;
   definition = 0;
   next_elem = 0;
   count = 0;
 }
 
 symbol_def::~symbol_def (void)
 {
-  delete [] help_string;
   delete definition;
 }
 
 int
 symbol_def::is_variable (void) const
 {
   return (type & USER_VARIABLE || type & BUILTIN_VARIABLE);
 }
@@ -177,27 +177,26 @@ symbol_def::make_eternal (void)
 }
 
 tree_fvc *
 symbol_def::def (void) const
 {
   return definition;
 }
 
-char *
+string
 symbol_def::help (void) const
 {
   return help_string;
 }
 
 void
-symbol_def::document (const char *h)
+symbol_def::document (const string& h)
 {
-  delete [] help_string;
-  help_string = strsave (h);
+  help_string = h;
 }
 
 int
 maybe_delete (symbol_def *def)
 {
   int count = 0;
   if (def && def->count > 0)
     {
@@ -211,62 +210,58 @@ maybe_delete (symbol_def *def)
 
 // Individual records in a symbol table.
 
 symbol_record::symbol_record (void)
 {
   init_state ();
 }
 
-symbol_record::symbol_record (const char *n, symbol_record *nxt)
+symbol_record::symbol_record (const string& n, symbol_record *nxt)
 {
   init_state ();
-  nm = strsave (n);
+  nm = n;
   next_elem = nxt;
 }
 
 void
 symbol_record::init_state (void)
 {
   formal_param = 0;
   linked_to_global = 0;
-  nm = 0;
   sv_fcn = 0;
   definition = 0;
   next_elem = 0;
 }
 
-symbol_record::~symbol_record (void)
-{
-  delete [] nm;
-}
-
-char *
+string
 symbol_record::name (void) const
 {
   return nm;
 }
 
-char *
+string
 symbol_record::help (void) const
 {
-  return definition ? definition->help () : 0;
+  string retval;
+  if (definition)
+    retval = definition->help ();
+  return retval;
 }
 
 tree_fvc *
 symbol_record::def (void) const
 {
   return definition ? definition->def () : 0;
 }
 
 void
-symbol_record::rename (const char *new_name)
+symbol_record::rename (const string& new_name)
 {
-  delete [] nm;
-  nm = strsave (new_name);
+  nm = new_name;
 }
 
 int
 symbol_record::is_function (void) const
 {
   return definition ? definition->is_function () : 0;
 }
 
@@ -339,17 +334,17 @@ symbol_record::is_eternal (void) const
 void
 symbol_record::protect (void)
 {
   if (definition)
     {
       definition->protect ();
 
       if (! is_defined ())
-	warning ("protecting undefined variable `%s'", nm);
+	warning ("protecting undefined variable `%s'", nm.c_str ());
     }
 }
 
 void
 symbol_record::unprotect (void)
 {
   if (definition)
     definition->unprotect ();
@@ -358,17 +353,18 @@ symbol_record::unprotect (void)
 void
 symbol_record::make_eternal (void)
 {
   if (definition)
     {
       definition->make_eternal ();
 
       if (! is_defined ())
-	warning ("giving eternal life to undefined variable `%s'", nm);
+	warning ("giving eternal life to undefined variable `%s'",
+		 nm.c_str ());
     }
 }
 
 void
 symbol_record::set_sv_function (sv_Function f)
 {
   sv_fcn = f;
 }
@@ -499,24 +495,24 @@ symbol_record::define_builtin_var (tree_
 {
   define (t);
   if (is_variable ())
     definition->type = symbol_def::BUILTIN_VARIABLE;
   return 1;
 }
 
 void
-symbol_record::document (const char *h)
+symbol_record::document (const string& h)
 {
   if (definition)
     {
       definition->document (h);
 
       if (! is_defined ())
-	warning ("documenting undefined variable `%s'", nm);
+	warning ("documenting undefined variable `%s'", nm.c_str ());
     }
 }
 
 int
 symbol_record::clear (void)
 {
   int count = 0;
   if (linked_to_global)
@@ -629,30 +625,32 @@ symbol_record::read_only_error (void)
   if (is_read_only ())
     {
       if (is_variable ())
 	{
 	  if (user_pref.read_only_constants)
 	    {
 	      if (user_pref.read_only_constants < 0)
 		{
-		  ::warning ("redefinition of constant `%s'", nm);
+		  ::warning ("redefinition of constant `%s'",
+			     nm.c_str ());
 		  return 0;
 		}
 	      else
-		::error ("can't redefine read-only constant `%s'", nm);
+		::error ("can't redefine read-only constant `%s'",
+			 nm.c_str ());
 	    }
 	}
       else if (is_function ())
 	{
-	  ::error ("can't redefine read-only function `%s'", nm);
+	  ::error ("can't redefine read-only function `%s'", nm.c_str ());
 	}
       else
 	{
-	  ::error ("can't redefine read-only symbol `%s'", nm);
+	  ::error ("can't redefine read-only symbol `%s'", nm.c_str ());
 	}
 
       return 1;
     }
   else
     return 0;
 }
 
@@ -718,53 +716,47 @@ symbol_record_info::symbol_record_info (
 	  else if (hidden_def->is_builtin_function ())
 	    hides = SR_INFO_BUILTIN_FUNCTION;
 	}
     }
 
   eternal = sr.is_eternal ();
   read_only = sr.is_read_only ();
 
-  nm = strsave (sr.name ());
+  nm = sr.name ();
 
   initialized = 1;
 }
 
 symbol_record_info::symbol_record_info (const symbol_record_info& s)
 {
   type = s.type;
   const_type = s.const_type;
   hides = s.hides;
   eternal = s.eternal;
   read_only = s.read_only;
   nr = s.nr;
   nc = s.nc;
-  nm = strsave (s.nm);
+  nm = s.nm;
   initialized = s.initialized;
 }
 
-symbol_record_info::~symbol_record_info (void)
-{
-  delete nm;
-}
-
 symbol_record_info&
 symbol_record_info::operator = (const symbol_record_info& s)
 {
   if (this != &s)
     {
-      delete nm;
       type = s.type;
       const_type = s.const_type;
       hides = s.hides;
       eternal = s.eternal;
       read_only = s.read_only;
       nr = s.nr;
       nc = s.nc;
-      nm = strsave (s.nm);
+      nm = s.nm;
       initialized = s.initialized;
     }
   return *this;
 }
 
 int
 symbol_record_info::is_defined (void) const
 {
@@ -790,17 +782,17 @@ symbol_record_info::hides_fcn (void) con
 }
 
 int
 symbol_record_info::hides_builtin (void) const
 {
   return (hides & SR_INFO_BUILTIN_FUNCTION);
 }
 
-char *
+string
 symbol_record_info::type_as_string (void) const
 {
   if (type == symbol_def::USER_FUNCTION)
     return "user function";
   else if (type == symbol_def::BUILTIN_FUNCTION)
     return "builtin function";
   else
     {
@@ -835,95 +827,95 @@ symbol_record_info::rows (void) const
 }
 
 int
 symbol_record_info::columns (void) const
 {
   return nc;
 }
 
-char *
+string
 symbol_record_info::name (void) const
 {
   return nm;
 }
 
 void
 symbol_record_info::init_state (void)
 {
   initialized = 0;
   type = symbol_def::UNKNOWN;
   const_type = SR_INFO_UNKNOWN;
   hides = SR_INFO_NONE;
   eternal = 0;
   read_only = 0;
   nr = -1;
   nc = -1;
-  nm = 0;
 }
 
 // A symbol table.
 
 symbol_table::symbol_table (void)
 {
 }
 
 symbol_record *
-symbol_table::lookup (const char *nm, int insert, int warn)
+symbol_table::lookup (const string& nm, int insert, int warn)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
-      if (strcmp (ptr->name (), nm) == 0)
+      if (ptr->name () == nm)
 	return ptr;
       ptr = ptr->next ();
     }
 
   if (insert)
     {
       symbol_record *new_sym;
       new_sym = new symbol_record (nm, table[index].next ());
       table[index].chain (new_sym);
       return new_sym;
     }
   else if (warn)
-    warning ("lookup: symbol`%s' not found", nm);
+    warning ("lookup: symbol`%s' not found", nm.c_str ());
 
   return 0;
 }
 
 void
-symbol_table::rename (const char *old_name, const char *new_name)
+symbol_table::rename (const string& old_name, const string& new_name)
 {
   int index = hash (old_name) & HASH_MASK;
 
   symbol_record *prev = &table[index];
   symbol_record *ptr = prev->next ();
 
   while (ptr)
     {
-      if (strcmp (ptr->name (), old_name) == 0)
+      if (ptr->name () == old_name)
 	{
 	  prev->chain (ptr->next ());
 
 	  index = hash (new_name) & HASH_MASK;
 	  table[index].chain (ptr);
 	  ptr->rename (new_name);
 
 	  return;
 	}
 
       prev = ptr;
       ptr = ptr->next ();
     }
 
-  error ("unable to rename `%s' to `%s', old_name, new_name");
+  error ("unable to rename `%s' to `%s'", old_name.c_str (),
+	 new_name.c_str ());
 }
 
 void
 symbol_table::clear (int clear_user_functions)
 {
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
     {
       symbol_record *ptr = table[i].next ();
@@ -937,25 +929,25 @@ symbol_table::clear (int clear_user_func
 	    }
 
 	  ptr = ptr->next ();
 	}
     }
 }
 
 int
-symbol_table::clear (const char *nm, int clear_user_functions)
+symbol_table::clear (const string& nm, int clear_user_functions)
 {
   int index = hash (nm) & HASH_MASK;
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
-      if (strcmp (ptr->name (), nm) == 0
+      if (ptr->name () == nm
 	  && (ptr->is_user_variable ()
 	      || (clear_user_functions && ptr->is_user_function ())))
 	{
 	  ptr->clear ();
 	  return 1;
 	}
       ptr = ptr->next ();
     }
@@ -983,39 +975,38 @@ static inline int
 pstrcmp (char **a, char **b)
 {
   return strcmp (*a, *b);
 }
 
 static inline int
 symbol_record_info_cmp (symbol_record_info *a, symbol_record_info *b)
 {
-  return strcmp (a->name (), b->name ());
+  return (a->name () == b->name ());
 }
 
 static int
-matches_patterns (const char *name, char **pats, int npats)
+matches_patterns (const string& name, const string_vector& pats, int npats)
 {
-  while (npats-- > 0)
+  for (int i = 0; i < npats; i++)
     {
-      if (fnmatch (*pats, name, __FNM_FLAGS) == 0)
+      if (fnmatch (pats[i].c_str (), name.c_str (), __FNM_FLAGS) == 0)
 	return 1;
-
-      pats++;
     }
 
   return 0;
 }
 
 // This function should probably share code with symbol_table::list.
 // XXX FIXME XXX
 
 symbol_record_info *
-symbol_table::long_list (int& count, char **pats, int npats, int sort,
-			 unsigned type, unsigned scope) const 
+symbol_table::long_list (int& count, const string_vector& pats,
+			 int npats, int sort, unsigned type,
+			 unsigned scope) const 
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return 0;
 
   symbol_record_info *symbols = new symbol_record_info [n+1];
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
@@ -1024,17 +1015,17 @@ symbol_table::long_list (int& count, cha
       while (ptr)
 	{
 	  assert (count < n);
 
 	  unsigned my_scope = ptr->is_linked_to_global () + 1; // Tricky...
 
 	  unsigned my_type = ptr->type ();
 
-	  char *my_name = ptr->name ();
+	  string my_name = ptr->name ();
 
 	  if ((type & my_type) && (scope & my_scope)
 	      && (npats == 0 || matches_patterns (my_name, pats, npats)))
 	    symbols[count++] = symbol_record_info (*ptr);
 
 	  ptr = ptr->next ();
 	}
     }
@@ -1042,57 +1033,58 @@ symbol_table::long_list (int& count, cha
 
   if (sort && symbols)
     qsort ((void *) symbols, count, sizeof (symbol_record_info),
 	   (int (*)(const void*, const void*)) symbol_record_info_cmp);
 
   return symbols;
 }
 
-char **
-symbol_table::list (int& count, char **pats, int npats, int sort,
-		    unsigned type, unsigned scope) const
+string_vector
+symbol_table::list (int& count, const string_vector& pats, int npats,
+		    int sort, unsigned type, unsigned scope) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return 0;
 
-  char **symbols = new char * [n+1];
+  string_vector symbols (n);
+
   for (int i = 0; i < HASH_TABLE_SIZE; i++)
     {
       symbol_record *ptr = table[i].next ();
       while (ptr)
 	{
 	  assert (count < n);
 
 	  unsigned my_scope = ptr->is_linked_to_global () + 1; // Tricky...
 
 	  unsigned my_type = ptr->type ();
 
-	  char *my_name = ptr->name ();
+	  string my_name = ptr->name ();
 
 	  if ((type & my_type) && (scope & my_scope)
 	      && (npats == 0 || matches_patterns (my_name, pats, npats)))
-	    symbols[count++] = strsave (ptr->name ());
+	    symbols[count++] = ptr->name ();
 
 	  ptr = ptr->next ();
 	}
     }
-  symbols[count] = 0;
+
+  symbols.resize (count);
 
-  if (sort && symbols)
-    qsort ((void **) symbols, count, sizeof (char *),
-	   (int (*)(const void*, const void*)) pstrcmp);
+  if (sort && ! symbols.empty ())
+    symbols.qsort ();
 
   return symbols;
 }
 
 symbol_record **
-symbol_table::glob (int& count, char *pat, unsigned type,
+symbol_table::glob (int& count, const string& pat, unsigned type,
 		    unsigned scope) const
 {
   count = 0;
   int n = size ();
   if (n == 0)
     return 0;
 
   symbol_record **symbols = new symbol_record * [n+1];
@@ -1102,18 +1094,20 @@ symbol_table::glob (int& count, char *pa
       while (ptr)
 	{
 	  assert (count < n);
 
 	  unsigned my_scope = ptr->is_linked_to_global () + 1; // Tricky...
 
 	  unsigned my_type = ptr->type ();
 
+	  string tmp = ptr->name ();
+
 	  if ((type & my_type) && (scope & my_scope)
-	      && fnmatch (pat, ptr->name (), __FNM_FLAGS) == 0)
+	      && fnmatch (pat.c_str (), tmp.c_str (), __FNM_FLAGS) == 0)
 	    {
 	      symbols[count++] = ptr;
 	    }
 
 	  ptr = ptr->next ();
 	}
     }
   symbols[count] = 0;
@@ -1149,21 +1143,21 @@ symbol_table::pop_context (void)
 	  ptr = ptr->next ();
 	}
     }
 }
 
 // Chris Torek's fave hash function.
 
 unsigned int
-symbol_table::hash (const char *str)
+symbol_table::hash (const string& str)
 {
   unsigned h = 0;
-  while (*str)
-    h = h * 33 + *str++;
+  for (unsigned i = 0; i < str.length (); i++)
+    h = h * 33 + str[i];
   return h;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -23,30 +23,36 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_symtab_h)
 #define octave_symtab_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <string>
+
 #include "SLStack.h"
 
+#include "str-vec.h"
+
 #include "variables.h"
 
 // Must be multiple of 2.
 #define HASH_TABLE_SIZE 1024
 #define HASH_MASK (HASH_TABLE_SIZE - 1)
 
 class tree;
 class tree_fvc;
 class tree_builtin;
 class tree_constant;
 class tree_function;
 
+class string_vector;
+
 class symbol_def;
 class symbol_record;
 class symbol_record_info;
 class symbol_table;
 
 // Variables or functions.
 
 class symbol_def
@@ -76,18 +82,18 @@ public:
   void define (tree_builtin *t, unsigned fcn_type = 0);
   void define (tree_function *t, unsigned fcn_type = 0);
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   tree_fvc *def (void) const;
-  char *help (void) const;
-  void document (const char *h);
+  string help (void) const;
+  void document (const string& h);
 
   enum TYPE
     {
       UNKNOWN = 0,
       USER_FUNCTION = 1,
       USER_VARIABLE = 2,
       BUILTIN_FUNCTION = 4,
       TEXT_FUNCTION = 8,
@@ -98,17 +104,17 @@ public:
   friend maybe_delete (symbol_def *def);
 
 private:
 
   unsigned type : 6;
   unsigned eternal : 1;
   unsigned read_only : 1;
 
-  char *help_string;
+  string help_string;
   tree_fvc *definition;
   symbol_def *next_elem;
   int count;
 
   void init_state (void);
 
   symbol_def (const symbol_def& sd);
   symbol_def& operator = (const symbol_def& sd);
@@ -118,25 +124,25 @@ private:
 
 class
 symbol_record
 {
   friend class symbol_record_info;
 
 public:
   symbol_record (void);
-  symbol_record (const char *n, symbol_record *nxt = 0);
+  symbol_record (const string& n, symbol_record *nxt = 0);
 
- ~symbol_record (void);
+  ~symbol_record (void) { }
 
-  char *name (void) const;
-  char *help (void) const; 
+  string name (void) const;
+  string help (void) const; 
   tree_fvc *def (void) const;
 
-  void rename (const char *new_name);
+  void rename (const string& new_name);
 
   int is_function (void) const;
   int is_user_function (void) const;
   int is_text_function (void) const;
   int is_mapper_function (void) const;
   int is_builtin_function (void) const;
   int is_variable (void) const;
   int is_user_variable (void) const;
@@ -155,17 +161,17 @@ public:
   void set_sv_function (sv_Function f);
 
   int define (tree_constant *t);
   int define (tree_builtin *t, int text_fcn = 0);
   int define (tree_function *t, int text_fcn = 0);
   int define_as_fcn (tree_constant *t);
   int define_builtin_var (tree_constant *t);
 
-  void document (const char *h);
+  void document (const string& h);
 
   int clear (void);
 
   void alias (symbol_record *s, int force = 0);
 
   void mark_as_formal_parameter (void);
   int is_formal_parameter (void) const;
 
@@ -179,17 +185,17 @@ public:
   void push_context (void);
   void pop_context (void);
 
 private:
 
   unsigned formal_param : 1;
   unsigned linked_to_global : 1;
 
-  char *nm;
+  string nm;
   sv_Function sv_fcn;
   symbol_def *definition;
   symbol_record *next_elem;
 
 // This should maybe be one stack with a structure containing all the
 // items we need to save for recursive calls...
   SLStack <symbol_def *> context;
   SLStack <unsigned> global_link_context;
@@ -211,30 +217,30 @@ symbol_record_info
 {
 public:
 
   symbol_record_info (void);
   symbol_record_info (const symbol_record& s);
 
   symbol_record_info (const symbol_record_info& s);
 
-  ~symbol_record_info (void);
+  ~symbol_record_info (void) { }
 
   symbol_record_info& operator = (const symbol_record_info& s);
 
   int is_defined (void) const;
   int is_read_only (void) const;
   int is_eternal (void) const;
   int hides_fcn (void) const;
   int hides_builtin (void) const;
-  char *type_as_string (void) const;
+  string type_as_string (void) const;
   int is_function (void) const;
   int rows (void) const;
   int columns (void) const;
-  char *name (void) const;
+  string name (void) const;
 
   enum HIDES
     {
       SR_INFO_NONE = 0,
       SR_INFO_USER_FUNCTION = 1,
       SR_INFO_BUILTIN_FUNCTION = 2
     };
 
@@ -255,17 +261,17 @@ private:
 
   unsigned type : 4;
   unsigned const_type : 6;
   unsigned hides : 2;
   unsigned eternal : 1;
   unsigned read_only : 1;
   int nr;
   int nc;
-  char *nm;
+  string nm;
   
   int initialized;
 };
 
 // A symbol table.
 
 #define SYMTAB_LOCAL_SCOPE 1
 #define SYMTAB_GLOBAL_SCOPE 2
@@ -284,44 +290,45 @@ private:
 
 class
 symbol_table
 {
 public:
 
   symbol_table (void);
 
-  symbol_record *lookup (const char *nm, int insert = 0, int warn = 0);
+  symbol_record *lookup (const string& nm, int insert = 0, int warn = 0);
 
-  void rename (const char *old_name, const char *new_name);
+  void rename (const string& old_name, const string& new_name);
 
   void clear (int clear_user_functions = 1);
-  int clear (const char *nm, int clear_user_functions = 1);
+  int clear (const string& nm, int clear_user_functions = 1);
 
   int size (void) const;
 
-  symbol_record_info *long_list (int& count, char **pats = 0,
-				 int npats = 0, int sort = 0,
-				 unsigned type = SYMTAB_ALL_TYPES,
-				 unsigned scope = SYMTAB_ALL_SCOPES) const;
+  symbol_record_info *
+  long_list (int& count, const string_vector& pats = string_vector (),
+	     int npats = 0, int sort = 0, unsigned type = SYMTAB_ALL_TYPES,
+	     unsigned scope = SYMTAB_ALL_SCOPES) const;
 
-  char **list (int& count, char **pats = 0, int npats = 0,
-	       int sort = 0, unsigned type = SYMTAB_ALL_TYPES,
-	       unsigned scope = SYMTAB_ALL_SCOPES) const;
+  string_vector
+  list (int& count, const string_vector& pats = string_vector (),
+	int npats = 0, int sort = 0, unsigned type = SYMTAB_ALL_TYPES,
+	unsigned scope = SYMTAB_ALL_SCOPES) const;
 
-  symbol_record **glob (int& count, char *pat = "*",
+  symbol_record **glob (int& count, const string& pat = string ("*"),
 			unsigned type = SYMTAB_ALL_TYPES,
 			unsigned scope = SYMTAB_ALL_SCOPES) const;
 
   void push_context (void);
   void pop_context (void);
 
 private:
 
-  unsigned int hash (const char *s);
+  unsigned int hash (const string& s);
 
   symbol_record table[HASH_TABLE_SIZE];
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -74,20 +74,21 @@ extern char *term_clrpag;
 extern "C" void _rl_output_character_function ();
 
 #include "defun.h"
 #include "error.h"
 #include "f77-uscore.h"
 #include "help.h"
 #include "input.h"
 #include "mappers.h"
-#include "toplev.h"
+#include "oct-obj.h"
+#include "pathlen.h"
+#include "pt-const.h"
 #include "sysdep.h"
-#include "pt-const.h"
-#include "oct-obj.h"
+#include "toplev.h"
 #include "utils.h"
 
 extern "C" double F77_FCN (d1mach, D1MACH) (const int&);
 
 #ifndef STDIN_FILENO
 #define STDIN_FILENO 1
 #endif
 
@@ -477,45 +478,53 @@ kbhit (void)
 {
   int c;
   raw_mode (1);
   c = cin.get ();
   raw_mode (0);
   return c;
 }
 
-char *
-octave_getcwd (char *buf, int len)
+string
+octave_getcwd (void)
 {
+  string retval;
+  char buf[MAXPATHLEN];
+
 #if defined (__EMX__)
-  return _getcwd2 (buf, len);
+  char *tmp = _getcwd2 (buf, MAXPATHLEN);
 #else
-  return getcwd (buf, len);
+  char *tmp = getcwd (buf, MAXPATHLEN);
 #endif
+
+  if (tmp)
+    retval = tmp;
+
+  return retval;
 }
 
 int
-octave_chdir (const char *path)
+octave_chdir (const string& path)
 {
 #if defined (__EMX__)
   int retval = -1;
 
-  if (strlen (path) == 2 && path[1] == ':')
+  if (path.length () == 2 && path[1] == ':')
     {
-      char *upper_case_dir_name = strupr (path);
+      char *upper_case_dir_name = strupr (path.c_str ());
       _chdrive (upper_case_dir_name[0]);
       if (_getdrive () == upper_case_dir_name[0])
 	retval = _chdir2 ("/");
     }
   else
-    retval = _chdir2 (path);
+    retval = _chdir2 (path.c_str ());
 
   return retval;
 #else
-  return chdir (path);
+  return chdir (path.c_str ());
 #endif
 }
 
 DEFUN ("clc", Fclc, Sclc, 00,
   "clc (): clear screen")
 {
   Octave_object retval;
 
@@ -569,26 +578,24 @@ DEFUN ("putenv", Fputenv, Sputenv, 10,
   "putenv (VAR, VALUE): define environment variable VAR=VALUE")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      string tstr1 = args(0).string_value (); 
-      const char *var = tstr1.c_str ();
+      string var = args(0).string_value (); 
 
       if (! error_state)
 	{
-	  string tstr2 = args(1).string_value (); 
-	  const char *val = tstr2.c_str ();
+	  string val = args(1).string_value (); 
 
 	  if (! error_state)
-	    oct_putenv (var, val);
+	    oct_putenv (var.c_str (), val.c_str ());
 	  else
 	    error ("putenv: second argument should be a string");
 	}
       else
 	error ("putenv: first argument should be a string");
     }
   else
     print_usage ("putenv");
diff --git a/src/sysdep.h b/src/sysdep.h
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -26,18 +26,18 @@ Software Foundation, 59 Temple Place - S
 
 #include <string>
 
 extern void sysdep_init (void);
 
 extern void raw_mode (int);
 extern int kbhit (void);
 
-extern char *octave_getcwd (char *, int);
-extern int octave_chdir (const char *);
+extern string octave_getcwd (void);
+extern int octave_chdir (const string&);
 
 #if !defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
 extern int gethostname (char *, int);
 #endif
 
 // Octave's idea of infinity.
 extern double octave_Inf;
 
diff --git a/src/timefns.cc b/src/timefns.cc
--- a/src/timefns.cc
+++ b/src/timefns.cc
@@ -271,30 +271,30 @@ DEFUN ("strftime", Fstrftime, Sstrftime,
     %x	locale's date representation (mm/dd/yy)\n\
     %y	last two digits of year (00..99)\n\
     %Y	year (1970...)")
 {
   Octave_object retval;
 
   if (args.length () == 2 && args(0).is_string () && args(1).is_map ()) 
     {
-      string tstr = args(0).string_value ();
-      const char *fmt = tstr.c_str ();
+      string fmt = args(0).string_value ();
+
       Octave_map map = args(1).map_value ();
 
       double fraction;
 
       struct tm *tm = extract_tm (map, fraction);
 
       if (! error_state)
 	{
 	  int bufsize = 128;
 	  char *buf = new char [bufsize];
 
-	  while (! strftime (buf, bufsize, fmt, tm))
+	  while (! strftime (buf, bufsize, fmt.c_str (), tm))
 	    {
 	      delete [] buf;
 	      bufsize *= 2;
 	      buf = new char [bufsize];
 	    }
 
 	  retval = buf;
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -36,88 +36,69 @@ Software Foundation, 59 Temple Place - S
 #include "token.h"
 #include "utils.h"
 
 token::token (int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = generic_token;
-  orig_text = 0;
 }
 
-token::token (char *s, int l, int c)
+token::token (const string& s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = string_token;
-  str = strsave (s);
-  orig_text = 0;
+  str = new string (s);
 }
 
-token::token (double d, char * /* s */, int l, int c)
+token::token (double d, const string& /* s */, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = double_token;
   num = d;
-  orig_text = 0; // strsave (s);
 }
 
 token::token (end_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = ettype_token;
   et = t;
-  orig_text = 0;
 }
 
 token::token (plot_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = pttype_token;
   pt = t;
-  orig_text = 0;
 }
 
 token::token (symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
-  orig_text = 0;
 }
 
 token::~token (void)
 {
   if (type_tag == string_token)
-    delete [] str;
-  delete [] orig_text;
-}
-
-int
-token::line (void)
-{
-  return line_num;
+    delete str;
 }
 
-int
-token::column (void)
-{
-  return column_num;
-}
-
-char *
-token::string (void)
+string
+token::text (void)
 {
   assert (type_tag == string_token);
-  return str;
+  return *str;
 }
 
 double
 token::number (void)
 {
   assert (type_tag == double_token);
   return num;
 }
@@ -138,17 +119,17 @@ token::pttype (void)
 
 symbol_record *
 token::sym_rec (void)
 {
   assert (type_tag == sym_rec_token);
   return sr;
 }
 
-char *
+string
 token::text_rep (void)
 {
   return orig_text;
 }
 
 token::token (const token& /* tok */)
 {
   panic_impossible ();
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -23,16 +23,18 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_token_h)
 #define octave_token_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <string>
+
 class symbol_record;
 
 class
 token
 {
 public:
   enum token_type
     {
@@ -58,51 +60,51 @@ public:
   enum plot_tok_type
     {
       replot = 1,
       two_dee = 2,
       three_dee = 3,
     };
 
   token (int l = -1, int c = -1);
-  token (char *s, int l = -1, int c = -1);
-  token (double d, char *s = 0, int l = -1, int c = -1);
+  token (const string& s, int l = -1, int c = -1);
+  token (double d, const string& s = string (), int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
   token (symbol_record *s, int l = -1, int c = -1);
 
- ~token (void);
+  ~token (void);
 
-  int line (void);
-  int column (void);
+  int line (void) { return line_num; }
+  int column (void) { return column_num; }
 
-  char *string (void);
+  string text (void);
   double number (void);
   end_tok_type ettype (void);
   plot_tok_type pttype (void);
   symbol_record *sym_rec (void);
 
-  char *text_rep (void);
+  string text_rep (void);
 
 private:
   token (const token& tok);
   token& operator = (const token& tok);
 
   int line_num;
   int column_num;
   token_type type_tag;
   union
     {
-      char *str;
+      string *str;
       double num;
       end_tok_type et;
       plot_tok_type pt;
       symbol_record *sr;
     };
-  char *orig_text;
+  string orig_text;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -39,16 +39,17 @@ Software Foundation, 59 Temple Place - S
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include "lo-error.h"
+#include "str-vec.h"
 
 #include "builtins.h"
 #include "defaults.h"
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "file-io.h"
 #include "help.h"
@@ -68,51 +69,51 @@ Software Foundation, 59 Temple Place - S
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 
 // argv[0] for this program.
-char *raw_prog_name = 0;
+string raw_prog_name;
 
 // Cleaned-up name of this program, not including path information.
-char *prog_name = 0;
+string prog_name;
 
 // Login name for user running this program.
-char *user_name = 0;
+string user_name;
 
 // Name of the host we are running on.
-char *host_name = 0;
+string host_name;
 
 // User's home directory.
-char *home_directory = 0;
+string home_directory;
 
 // Guess what?
-char *the_current_working_directory = 0;
+string the_current_working_directory;
 
 // The path that will be searched for programs that we execute.
 // (--exec-path path)
-char *exec_path = 0;
+string exec_path;
 
 // Load path specified on command line.
 // (--path path; -p path)
-char *load_path = 0;
+string load_path;
 
 // Name of the info file specified on command line.
 // (--info-file file)
-char *info_file = 0;
+string info_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-char *info_prog = 0;
+string info_prog;
 
 // Name of the editor to be invoked by the edit_history command.
-char *editor = 0;
+string editor;
 
 // If nonzero, don't do fancy line editing.
 int no_line_editing = 0;
 
 // If nonzero, print verbose info in some cases.
 // (--verbose; -V)
 int verbose_flag = 0;
 
@@ -182,20 +183,20 @@ parse_and_execute (FILE *f, int print)
 
 void
 parse_and_execute (const string& s, int print, int verbose,
 		   const char *warn_for)
 {
   begin_unwind_frame ("parse_and_execute_2");
 
   unwind_protect_int (reading_script_file);
-  unwind_protect_ptr (curr_fcn_file_full_name);
+  unwind_protect_str (curr_fcn_file_full_name);
 
   reading_script_file = 1;
-  curr_fcn_file_full_name = s.c_str ();
+  curr_fcn_file_full_name = s;
 
   FILE *f = get_input_from_file (s, 0);
 
   if (f)
     {
       unwind_protect_int (input_line_number);
       unwind_protect_int (current_input_column);
 
@@ -285,27 +286,30 @@ clean_up_and_exit (int retval)
   panic_impossible ();
 }
 
 DEFUN_TEXT ("casesen", Fcasesen, Scasesen, 10,
   "casesen [on|off]")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("casesen");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "casesen");
 
-  if (argc == 1 || (argc > 1 && strcmp (argv[1], "off") == 0))
+  if (error_state)
+    return retval;
+
+  if (argc == 1 || (argc > 1 && argv[1] == "off"))
     warning ("casesen: sorry, Octave is always case sensitive");
-  else if (argc > 1 && strcmp (argv[1], "on") == 0)
+  else if (argc > 1 && argv[1] == "on")
     ; // ok.
   else
     print_usage ("casesen");
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN ("computer", Fcomputer, Scomputer, 11,
   "computer ():\n\
 \n\
 Have Octave ask the system, \"What kind of computer are you?\"")
 {
@@ -425,29 +429,29 @@ evaluate NAME as a function, passing ARG
     retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
 static Octave_object
-eval_string (const char *string, int print, int& parse_status,
+eval_string (const string& s, int print, int& parse_status,
 	     int nargout) 
 {
   begin_unwind_frame ("eval_string");
 
   unwind_protect_int (get_input_from_eval_string);
   unwind_protect_int (input_from_command_line_file);
   unwind_protect_ptr (global_command);
-  unwind_protect_ptr (current_eval_string);
+  unwind_protect_str (current_eval_string);
 
   get_input_from_eval_string = 1;
   input_from_command_line_file = 0;
-  current_eval_string = string;
+  current_eval_string = s;
 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
   add_unwind_protect (restore_input_buffer, (void *) old_buf);
   add_unwind_protect (delete_input_buffer, (void *) new_buf);
 
   switch_to_buffer (new_buf);
@@ -473,42 +477,41 @@ eval_string (const char *string, int pri
       retval = command->eval (print, nargout);
       delete command;
     }
 
   return retval;
 }
 
 tree_constant
-eval_string (const char *string, int print, int& parse_status)
+eval_string (const string& s, int print, int& parse_status)
 {
   tree_constant retval;
 
-  Octave_object tmp = eval_string (string, print, parse_status, 1);
+  Octave_object tmp = eval_string (s, print, parse_status, 1);
 
   retval = tmp(0);
 
   return retval;
 }
 
 static Octave_object
 eval_string (const tree_constant& arg, int& parse_status, int nargout)
 {
-  string tstr = arg.string_value ();
-  const char *string = tstr.c_str ();
+  string s = arg.string_value ();
 
   if (error_state)
     {
       error ("eval: expecting string argument");
       return -1.0;
     }
 
   // Yes Virginia, we always print here...
 
-  return eval_string (string, 1, parse_status, nargout);
+  return eval_string (s, 1, parse_status, nargout);
 }
 
 DEFUN ("eval", Feval, Seval, 11,
   "eval (TRY, CATCH)\n\
 \n\
 Evaluate the string TRY as octave code.  If that fails, evaluate the\n\
 string CATCH.")
 {
@@ -566,26 +569,25 @@ DEFUN ("system", Fsystem, Ssystem, 11,
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("system");
       return retval;
     }
 
   tree_constant tc_command = args(0);
 
-  string tstr = tc_command.string_value ();
-  const char *tmp_str = tstr.c_str ();
+  string tmp = tc_command.string_value ();
 
   if (error_state)
     {
       error ("system: expecting string as first argument");
     }
   else
     {
-      iprocstream *cmd = new iprocstream (tmp_str);
+      iprocstream *cmd = new iprocstream (tmp.c_str ());
 
       add_unwind_protect (cleanup_iprocstream, cmd);
 
       int status = 127;
 
       if (cmd && *cmd)
 	{
 	  ostrstream output_buf;
@@ -613,17 +615,17 @@ DEFUN ("system", Fsystem, Ssystem, 11,
 	      retval(0) = msg;
 
 	      delete [] msg;
 	    }
 	  else
 	    maybe_page_output (output_buf);
 	}
       else
-	error ("unable to start subprocess for `%s'", tmp_str);
+	error ("unable to start subprocess for `%s'", tmp.c_str ());
 
       run_unwind_protect ();
     }
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -36,51 +36,51 @@ class charMatrix;
 extern void clean_up_and_exit (int) NORETURN;
 
 extern void parse_and_execute (FILE *f, int print = 0);
 
 extern void parse_and_execute (const string& s, int print = 0,
 			       int verbose = 0,
 			       const char *warn_for = 0);
 
-extern tree_constant eval_string (const char *string, int print,
+extern tree_constant eval_string (const string&, int print,
 				  int& parse_status);
 
 // argv[0] for this program.
-extern char *raw_prog_name;
+extern string raw_prog_name;
 
 // Cleaned-up name of this program, not including path information.
-extern char *prog_name;
+extern string prog_name;
 
 // Login name for user running this program.
-extern char *user_name;
+extern string user_name;
 
 // Name of the host we are running on.
-extern char *host_name;
+extern string host_name;
 
 // User's home directory.
-extern char *home_directory;
+extern string home_directory;
 
 // Guess what?
-extern char *the_current_working_directory;
+extern string the_current_working_directory;
 
 // The path that will be searched for programs that we execute.
-extern char *exec_path;
+extern string exec_path;
 
 // Load path specified on command line.
-extern char *load_path;
+extern string load_path;
 
 // Name of the info file specified on command line.
-extern char *info_file;
+extern string info_file;
 
 // Name of the info reader we'd like to use.
-extern char *info_prog;
+extern string info_prog;
 
 // Name of the editor to be invoked by the edit_history command.
-extern char *editor;
+extern string editor;
 
 // If nonzero, don't do fancy line editing.
 extern int no_line_editing;
 
 // If nonzero, print verbose info in some cases.
 extern int verbose_flag;
 
 // Nonzero means we printed messages about reading startup files.
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -26,154 +26,97 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstddef>
 
+#include <string>
+
 #include "SLStack.h"
 
 #include "CMatrix.h"
 
 #include "error.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
-unwind_elem::unwind_elem (void)
-{
-  unwind_elem_tag = 0;
-  unwind_elem_fptr = 0;
-  unwind_elem_ptr = 0;
-}
-
-unwind_elem::unwind_elem (char *t)
-{
-  unwind_elem_tag = strsave (t);
-  unwind_elem_fptr = 0;
-  unwind_elem_ptr = 0;
-}
-
-unwind_elem::unwind_elem (cleanup_func f, void *p)
-{
-  unwind_elem_tag = 0;
-  unwind_elem_fptr = f;
-  unwind_elem_ptr = p;
-}
-
-unwind_elem::unwind_elem (const unwind_elem& el)
-{
-  unwind_elem_tag = strsave (el.unwind_elem_tag);
-  unwind_elem_fptr = el.unwind_elem_fptr;
-  unwind_elem_ptr = el.unwind_elem_ptr;
-}
-
-unwind_elem::~unwind_elem (void)
-{
-  delete [] unwind_elem_tag;
-}
-
-unwind_elem&
-unwind_elem::operator = (const unwind_elem& el)
-{
-  unwind_elem_tag = strsave (el.unwind_elem_tag);
-  unwind_elem_fptr = el.unwind_elem_fptr;
-  unwind_elem_ptr = el.unwind_elem_ptr;
-
-  return *this;
-}
-
-char *
-unwind_elem::tag (void)
-{
-  return unwind_elem_tag;
-}
-
-cleanup_func
-unwind_elem::fptr (void)
-{
-  return unwind_elem_fptr;
-}
-
-void *
-unwind_elem::ptr (void)
-{
-  return unwind_elem_ptr;
-}
-
 static SLStack <unwind_elem> unwind_protect_list;
 
 void
 add_unwind_protect (cleanup_func fptr, void *ptr)
 {
   unwind_elem el (fptr, ptr);
   unwind_protect_list.push (el);
 }
 
 void
 run_unwind_protect (void)
 {
   unwind_elem el = unwind_protect_list.pop ();
 
   cleanup_func f = el.fptr ();
+
   if (f)
     f (el.ptr ());
 }
 
 void
 discard_unwind_protect (void)
 {
   unwind_protect_list.pop ();
 }
 
 void
-begin_unwind_frame (char *tag)
+begin_unwind_frame (const string& tag)
 {
   unwind_elem elem (tag);
   unwind_protect_list.push (elem);
 }
 
 void
-run_unwind_frame (char *tag)
+run_unwind_frame (const string& tag)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
 
       cleanup_func f = el.fptr ();
+
       if (f)
 	f (el.ptr ());
 
-      char *t = el.tag ();
-      if (t && strcmp (t, tag) == 0)
+      if (tag == el.tag ())
 	break;
     }
 }
 
 void
-discard_unwind_frame (char *tag)
+discard_unwind_frame (const string& tag)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
-      char *t = el.tag ();
-      if (t && strcmp (t, tag) == 0)
+
+      if (tag == el.tag ())
 	break;
     }
 }
 
 void
 run_all_unwind_protects (void)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
 
       cleanup_func f = el.fptr ();
+
       if (f)
 	f (el.ptr ());
     }
 }
 
 void
 discard_all_unwind_protects (void)
 {
@@ -190,36 +133,38 @@ void
 complex_matrix_cleanup (void *cm)
 {
   delete [] (ComplexMatrix *) cm;
 }
 
 class saved_variable
 {
  public:
-  enum var_type { integer, generic_ptr, generic };
+  enum var_type { integer, string_type, generic_ptr, generic };
 
   saved_variable (void);
   saved_variable (int *p, int v);
+  saved_variable (string *p, const string& v);
   saved_variable (void **p, void *v);
   ~saved_variable (void);
 
   void restore_value (void);
 
  private:
   union
     {
       int *ptr_to_int;
       void *gen_ptr;
       void **ptr_to_gen_ptr;
     };
 
   union
     {
       int int_value;
+      const string *str_value;
       void *gen_ptr_value;
     };
 
   var_type type_tag;
   size_t size;
 };
 
 saved_variable::saved_variable (void)
@@ -230,42 +175,65 @@ saved_variable::saved_variable (void)
   size = 0;
 }
 
 saved_variable::saved_variable (int *p, int v)
 {
   type_tag = integer;
   ptr_to_int = p;
   int_value = v;
-  size = sizeof (int);
+  size = sizeof (int);  // Is this necessary?
+}
+
+saved_variable::saved_variable (string *p, const string& v)
+{
+  type_tag = string_type;
+  gen_ptr = p;
+  str_value = new string (v);
+  size = sizeof (string);  // Is this necessary?
 }
 
 saved_variable::saved_variable (void **p, void *v)
 {
   type_tag = generic_ptr;
   ptr_to_gen_ptr = p;
   gen_ptr_value = v;
   size = sizeof (void *);
 }
 
 saved_variable::~saved_variable (void)
 {
-  if (type_tag == generic)
-    delete [] gen_ptr_value;
+  switch (type_tag)
+    {
+    case string_type:
+      delete str_value;
+      break;
+
+    case generic:
+      delete [] gen_ptr_value;  // Can this be right?
+      break;
+
+    default:
+      break;
+    }
 }
 
 void
 saved_variable::restore_value (void)
 {
   switch (type_tag)
     {
     case integer:
       *ptr_to_int = int_value;
       break;
 
+    case string_type:
+      ((string *) gen_ptr) -> assign (*str_value);
+      break;
+
     case generic_ptr:
       *ptr_to_gen_ptr = gen_ptr_value;
       break;
 
     case generic:
       memcpy (gen_ptr, gen_ptr_value, size);
       break;
 
@@ -286,16 +254,23 @@ restore_saved_variable (void *s)
 void
 unwind_protect_int_internal (int *ptr, int value)
 {
   saved_variable *s = new saved_variable (ptr, value);
   add_unwind_protect (restore_saved_variable, (void *) s);
 }
 
 void
+unwind_protect_str_internal (string *ptr, const string& value)
+{
+  saved_variable *s = new saved_variable (ptr, value);
+  add_unwind_protect (restore_saved_variable, (void *) s);
+}
+
+void
 unwind_protect_ptr_internal (void **ptr, void *value)
 {
   saved_variable *s = new saved_variable (ptr, value);
   add_unwind_protect (restore_saved_variable, (void *) s);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -25,60 +25,83 @@ Software Foundation, 59 Temple Place - S
 #define octave_unwind_prot_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <cstddef>
 
+#include <string>
+
 typedef void (*cleanup_func)(void *ptr);
 
 void add_unwind_protect (cleanup_func fptr, void *ptr);
 void run_unwind_protect (void);
 void discard_unwind_protect (void);
-void begin_unwind_frame (char *tag);
-void run_unwind_frame (char *tag);
-void discard_unwind_frame (char *tag);
+void begin_unwind_frame (const string& tag);
+void run_unwind_frame (const string& tag);
+void discard_unwind_frame (const string& tag);
 void run_all_unwind_protects (void);
 void discard_all_unwind_protects (void);
 
 void matrix_cleanup (void *m);
 void complex_matrix_cleanup (void *cm);
 
 void unwind_protect_int_internal (int *ptr, int value);
+void unwind_protect_str_internal (string *ptr, const string& value);
 void unwind_protect_ptr_internal (void **ptr, void *value);
 void unwind_protect_var_internal (void *ptr, void *value, size_t size);
 
 #define unwind_protect_int(i) \
   unwind_protect_int_internal (&(i), (i))
 
+#define unwind_protect_str(s) \
+  unwind_protect_str_internal (&(s), (s))
+
 #define unwind_protect_ptr(p) \
   unwind_protect_ptr_internal ((void **) &(p), (void *) (p))
 
 class
 unwind_elem
 {
  public:
-  unwind_elem (void);
-  unwind_elem (char *t);
-  unwind_elem (cleanup_func f, void *p);
-  unwind_elem (const unwind_elem& el);
-  ~unwind_elem (void);
+  unwind_elem (void)
+    : ue_tag (), ue_fptr (0), ue_ptr (0) { }
+
+  unwind_elem (const string &t)
+    : ue_tag (t), ue_fptr (0), ue_ptr (0) { }
+
+  unwind_elem (cleanup_func f, void *p)
+    : ue_tag (), ue_fptr (f), ue_ptr (p) { }
+
+  unwind_elem (const unwind_elem& el)
+    : ue_tag (el.ue_tag), ue_fptr (el.ue_fptr), ue_ptr (el.ue_ptr) { }
+
+  ~unwind_elem (void) { }
 
-  unwind_elem& operator = (const unwind_elem& el);
+  unwind_elem& operator = (const unwind_elem& el)
+    {
+      ue_tag = el.ue_tag;
+      ue_fptr = el.ue_fptr;
+      ue_ptr = el.ue_ptr;
 
-  char *tag (void);
-  cleanup_func fptr (void);
-  void *ptr (void);
+      return *this;
+    }
+
+  string tag (void) { return ue_tag; }
+
+  cleanup_func fptr (void) { return ue_fptr; }
+
+  void *ptr (void) { return ue_ptr; }
 
  private:
-  char *unwind_elem_tag;
-  cleanup_func unwind_elem_fptr;
-  void *unwind_elem_ptr;
+  string ue_tag;
+  cleanup_func ue_fptr;
+  void *ue_ptr;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/user-prefs.cc b/src/user-prefs.cc
--- a/src/user-prefs.cc
+++ b/src/user-prefs.cc
@@ -77,67 +77,65 @@ init_user_prefs (void)
   user_pref.warn_assign_as_truth_value = 0;
   user_pref.warn_comma_in_global_decl = 0;
   user_pref.warn_divide_by_zero = 0;
   user_pref.warn_function_name_clash = 0;
   user_pref.whitespace_in_literal_matrix = 0;
 
   user_pref.completion_append_char = '\0';
 
-  user_pref.default_save_format = 0;
-  user_pref.editor = 0;
-  user_pref.exec_path = 0;
-  user_pref.gnuplot_binary = 0;
-  user_pref.history_file = 0;
-  user_pref.imagepath = 0;
-  user_pref.info_file = 0;
-  user_pref.info_prog = 0;
-  user_pref.loadpath = 0;
-  user_pref.pager_binary = 0;
-  user_pref.ps1 = 0;
-  user_pref.ps2 = 0;
-  user_pref.ps4 = 0;
-  user_pref.pwd = 0;
+  user_pref.default_save_format = string ();
+  user_pref.editor = string ();
+  user_pref.exec_path = string ();
+  user_pref.gnuplot_binary = string ();
+  user_pref.history_file = string ();
+  user_pref.imagepath = string ();
+  user_pref.info_file = string ();
+  user_pref.info_prog = string ();
+  user_pref.loadpath = string ();
+  user_pref.pager_binary = string ();
+  user_pref.ps1 = string ();
+  user_pref.ps2 = string ();
+  user_pref.ps4 = string ();
+  user_pref.pwd = string ();
 }
 
 // Check the value of a string variable to see if it it's ok to do
 // something.
 //
 //   return of  1 => always ok.
 //   return of  0 => never ok.
 //   return of -1 => ok, but give me warning (default).
 
 // XXX FIXME XXX -- should also allow zero to mean "false" and nonzero
 // to mean "true".
 
 static int
-check_preference (char *var)
+check_preference (const string& var)
 {
   int pref = -1;
 
-  char *val = builtin_string_variable (var);
+  string val = builtin_string_variable (var);
 
-  if (val)
-    {
-      if (strncmp (val, "yes", 3) == 0
-	  || strncmp (val, "true", 4) == 0)
-	pref = 1;
-      else if (strncmp (val, "never", 5) == 0
-	       || strncmp (val, "no", 2) == 0
-	       || strncmp (val, "false", 5) == 0)
-	pref = 0;
-
-      delete [] val;
-    }
-  else
+  if (val.empty ())
     {
       double dval = 0;
       if (builtin_real_scalar_variable (var, dval))
 	pref = NINT (dval);
     }
+  else
+    {
+      if (val.compare ("yes", 0, 3) == 0
+	  || val.compare ("true", 0, 4) == 0)
+	pref = 1;
+      else if (val.compare ("never", 0, 5) == 0
+	       || val.compare ("no", 0, 2) == 0
+	       || val.compare ("false", 0, 5) == 0)
+	pref = 0;
+    }
 
   return pref;
 }
 
 // XXX FIXME XXX -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
 // Should a replot command be generated automatically each time a plot
@@ -259,23 +257,23 @@ history_size (void)
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 
 int
 ignore_function_time_stamp (void)
 {
   int pref = 0;
 
-  char *val = builtin_string_variable ("ignore_function_time_stamp");
+  string val = builtin_string_variable ("ignore_function_time_stamp");
 
-  if (val)
+  if (! val.empty ())
     {
-      if (strncmp (val, "all", 3) == 0)
+      if (val.compare ("all", 0, 3) == 0)
 	pref = 2;
-      if (strncmp (val, "system", 6) == 0)
+      if (val.compare ("system", 0, 6) == 0)
 	pref = 1;
     }
 
   user_pref.ignore_function_time_stamp = pref;
 
   return 0;
 }
 
@@ -625,22 +623,22 @@ warn_missing_semicolon (void)
 //   [eye (2)]
 //
 // will result in a call to `eye' with the argument `2'. 
 
 int
 whitespace_in_literal_matrix (void)
 {
   int pref = 0;
-  char *val = builtin_string_variable ("whitespace_in_literal_matrix");
-  if (val)
+  string val = builtin_string_variable ("whitespace_in_literal_matrix");
+  if (! val.empty ())
     {
-      if (strncmp (val, "ignore", 6) == 0)
+      if (val.compare ("ignore", 0, 6) == 0)
 	pref = 2;
-      else if (strncmp (val, "traditional", 11) == 0)
+      else if (val.compare ("traditional", 0, 11) == 0)
 	pref = 1;
     }
   user_pref.whitespace_in_literal_matrix = pref;
   return 0;
 }
 
 
 int
@@ -697,368 +695,349 @@ set_save_precision (void)
   return -1;
 }
 
 int
 sv_completion_append_char (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("completion_append_char");
-  if (s)
+  string s = builtin_string_variable ("completion_append_char");
+
+  switch (s.length ())
     {
-      if (s[0] == '\0' || (s[0] && s[1] == '\0'))
-	user_pref.completion_append_char = s[0];
-      else
-	{
-	  warning ("completion_append_char must be a single character");
-	  status = -1;
-	}
-    }
-  else
-    {
-      gripe_invalid_value_specified ("completion_append_char");
+    case 1:
+      user_pref.completion_append_char = s[0];
+      break;
+
+    case 0:
+      user_pref.completion_append_char = '\0';
+      break;
+
+    default:
+      warning ("completion_append_char must be a single character");
       status = -1;
+      break;
     }
 
   return status;
 }
 
 int
 sv_default_save_format (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("default_save_format");
-  if (s)
-    {
-      delete [] user_pref.default_save_format;
-      user_pref.default_save_format = s;
-    }
-  else
+  string s = builtin_string_variable ("default_save_format");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("default_save_format");
       status = -1;
     }
+  else
+    user_pref.default_save_format = s;
 
   return status;
 }
 
 int
 sv_editor (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("EDITOR");
-  if (s)
-    {
-      delete [] user_pref.editor;
-      user_pref.editor = s;
-    }
-  else
+  string s = builtin_string_variable ("EDITOR");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("EDITOR");
       status = -1;
     }
+  else
+    user_pref.editor = s;
 
   return status;
 }
 
 int
 sv_exec_path (void)
 {
   int status = 0;
 
-  char *exec_path = builtin_string_variable ("EXEC_PATH");
-  if (exec_path)
+  string exec_path = builtin_string_variable ("EXEC_PATH");
+
+  if (exec_path.empty ())
     {
-      char *arch_dir = octave_arch_lib_dir ();
-      char *bin_dir = octave_bin_dir ();
+      gripe_invalid_value_specified ("EXEC_PATH");
+      status = -1;
+    }
+  else
+    {
+      string arch_dir = octave_arch_lib_dir ();
+      string bin_dir = octave_bin_dir ();
 
-      int len = strlen (arch_dir) + strlen (bin_dir) + strlen (SEPCHAR_STR);
+      int len = arch_dir.length () + bin_dir.length () + strlen (SEPCHAR_STR);
 
       static char *putenv_cmd = 0;
 
       delete [] putenv_cmd;
 
       putenv_cmd = 0;
 
-      int eplen = strlen (exec_path);
+      int eplen = exec_path.length ();
 
       if (eplen > 0)
 	{
 	  int prepend = (exec_path[0] == ':');
 	  int append = (eplen > 1 && exec_path[eplen-1] == ':');
 
 	  if (prepend)
 	    {
 	      if (append)
 		{
 		  putenv_cmd = new char [2 * len + eplen + 6];
 		  sprintf (putenv_cmd,
 			   "PATH=%s" SEPCHAR_STR "%s%s%s" SEPCHAR_STR "%s",
-			   arch_dir, bin_dir, exec_path, arch_dir, bin_dir);
+			   arch_dir.c_str (), bin_dir.c_str (),
+			   exec_path.c_str (), arch_dir.c_str (),
+			   bin_dir.c_str ());
 		}
 	      else
 		{
 		  putenv_cmd = new char [len + eplen + 6];
 		  sprintf (putenv_cmd,
 			   "PATH=%s" SEPCHAR_STR "%s%s",
-			   arch_dir, bin_dir, exec_path);
+			   arch_dir.c_str (), bin_dir.c_str (),
+			   exec_path.c_str ());
 		}
 	    }
 	  else
 	    {
 	      if (append)
 		{
 		  putenv_cmd = new char [len + eplen + 6];
 		  sprintf (putenv_cmd,
 			   "PATH=%s%s" SEPCHAR_STR "%s",
-			   exec_path, arch_dir, bin_dir);
+			   exec_path.c_str (), arch_dir.c_str (),
+			   bin_dir.c_str ());
 		}
 	      else
 		{
 		  putenv_cmd = new char [len + eplen + 6];
-		  sprintf (putenv_cmd, "PATH=%s", exec_path);
+		  sprintf (putenv_cmd, "PATH=%s", exec_path.c_str ());
 		}
 	    }
 	}
       else
 	{
 	  putenv_cmd = new char [len+6];
-	  sprintf (putenv_cmd, "PATH=%s" SEPCHAR_STR "%s", arch_dir, bin_dir);
+	  sprintf (putenv_cmd, "PATH=%s" SEPCHAR_STR "%s",
+		   arch_dir.c_str (), bin_dir.c_str ());
 	}
 
       putenv (putenv_cmd);
     }
-  else
-    {
-      gripe_invalid_value_specified ("EXEC_PATH");
-      status = -1;
-    }
 
   return status;
 }
 
 int
 sv_gnuplot_binary (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("gnuplot_binary");
-  if (s)
-    {
-      delete [] user_pref.gnuplot_binary;
-      user_pref.gnuplot_binary = s;
-    }
-  else
+  string s = builtin_string_variable ("gnuplot_binary");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("gnuplot_binary");
       status = -1;
     }
+  else
+    user_pref.gnuplot_binary = s;
 
   return status;
 }
 
 int
 sv_history_file (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("history_file");
-  if (s)
-    {
-      delete [] user_pref.history_file;
-      user_pref.history_file = s;
-    }
-  else
+  string s = builtin_string_variable ("history_file");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("history_file");
       status = -1;
     }
+  else
+    user_pref.history_file = s;
 
   return status;
 }
 
 int
 sv_imagepath (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("IMAGEPATH");
-  if (s)
-    {
-      delete [] user_pref.imagepath;
-      user_pref.imagepath = s;
-    }
-  else
+  string s = builtin_string_variable ("IMAGEPATH");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("IMAGEPATH");
       status = -1;
     }
+  else
+    user_pref.imagepath = s;
 
   return status;
 }
 
 int
 sv_info_file (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("INFO_FILE");
-  if (s)
-    {
-      delete [] user_pref.info_file;
-      user_pref.info_file = s;
-    }
-  else
+  string s = builtin_string_variable ("INFO_FILE");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("INFO_FILE");
       status = -1;
     }
+  else
+    user_pref.info_file = s;
 
   return status;
 }
 
 int
 sv_info_prog (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("INFO_PROGRAM");
-  if (s)
-    {
-      delete [] user_pref.info_prog;
-      user_pref.info_prog = s;
-    }
-  else
+  string s = builtin_string_variable ("INFO_PROGRAM");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("INFO_PROGRAM");
       status = -1;
     }
+  else
+    user_pref.info_prog = s;
 
   return status;
 }
 
 int
 sv_loadpath (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("LOADPATH");
-  if (s)
-    {
-      delete [] user_pref.loadpath;
-      user_pref.loadpath = maybe_add_default_load_path (s);
-    }
-  else
+  string s = builtin_string_variable ("LOADPATH");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("LOADPATH");
       status = -1;
     }
+  else
+    user_pref.loadpath = maybe_add_default_load_path (s);
 
   return status;
 }
 
 int
 sv_pager_binary (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("PAGER");
-  if (s)
-    {
-      delete [] user_pref.pager_binary;
-      user_pref.pager_binary = s;
-    }
-  else
+  string s = builtin_string_variable ("PAGER");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("PAGER");
       status = -1;
     }
+  else
+    user_pref.pager_binary = s;
 
   return status;
 }
 
 int
 sv_ps1 (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("PS1");
-  if (s)
-    {
-      delete [] user_pref.ps1;
-      user_pref.ps1 = s;
-    }
-  else
+  string s = builtin_string_variable ("PS1");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("PS1");
       status = -1;
     }
+  else
+    user_pref.ps1 = s;
 
   return status;
 }
 
 int
 sv_ps2 (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("PS2");
-  if (s)
-    {
-      delete [] user_pref.ps2;
-      user_pref.ps2 = s;
-    }
-  else
+  string s = builtin_string_variable ("PS2");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("PS2");
       status = -1;
     }
+  else
+    user_pref.ps2 = s;
 
   return status;
 }
 
 int
 sv_ps4 (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("PS4");
-  if (s)
-    {
-      delete [] user_pref.ps4;
-      user_pref.ps4 = s;
-    }
-  else
+  string s = builtin_string_variable ("PS4");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("PS4");
       status = -1;
     }
+  else
+    user_pref.ps4 = s;
 
   return status;
 }
 
 int
 sv_pwd (void)
 {
   int status = 0;
 
-  char *s = builtin_string_variable ("PWD");
-  if (s)
-    {
-      delete [] user_pref.pwd;
-      user_pref.pwd = s;
-    }
-  else
+  string s = builtin_string_variable ("PWD");
+
+  if (s.empty ())
     {
       gripe_invalid_value_specified ("PWD");
       status = -1;
     }
+  else
+    user_pref.pwd = s;
 
   return status;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/user-prefs.h b/src/user-prefs.h
--- a/src/user-prefs.h
+++ b/src/user-prefs.h
@@ -19,16 +19,18 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_user_prefs_h)
 #define octave_user_prefs_h 1
 
+#include <string>
+
 struct user_preferences
 {
   int automatic_replot;
   int beep_on_error;
   int define_all_return_values;
   int do_fortran_indexing;
   int echo_executing_commands;
   int empty_list_elements_ok;
@@ -59,30 +61,30 @@ struct user_preferences
   int warn_comma_in_global_decl;
   int warn_divide_by_zero;
   int warn_missing_semicolon;
   int warn_function_name_clash;
   int whitespace_in_literal_matrix;
 
   char completion_append_char;
 
-  char *default_save_format;
-  char *editor;
-  char *exec_path;
-  char *gnuplot_binary;
-  char *history_file;
-  char *imagepath;
-  char *info_file;
-  char *info_prog;
-  char *loadpath;
-  char *pager_binary;
-  char *ps1;
-  char *ps2;
-  char *ps4;
-  char *pwd;
+  string default_save_format;
+  string editor;
+  string exec_path;
+  string gnuplot_binary;
+  string history_file;
+  string imagepath;
+  string info_file;
+  string info_prog;
+  string loadpath;
+  string pager_binary;
+  string ps1;
+  string ps2;
+  string ps4;
+  string pwd;
 };
 
 extern user_preferences user_pref;
 
 extern void init_user_prefs (void);
 
 extern int automatic_replot (void);
 extern int beep_on_error (void);
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -52,16 +52,17 @@ LOSE! LOSE!
 
 #ifndef HAVE_STRNCASECMP
 extern "C" int strncasecmp (const char*, const char*, size_t);
 #endif
 
 #include "SLStack.h"
 
 #include "oct-cmplx.h"
+#include "str-vec.h"
 
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "input.h"
 #include "mappers.h"
@@ -89,27 +90,30 @@ strsave (const char *s)
     return 0;
 
   int len = strlen (s);
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
+#if 0
+
 // Concatenate two strings.
 
 char *
 strconcat (const char *s, const char *t)
 {
   int len = strlen (s) + strlen (t);
   char *tmp = new char [len+1];
   strcpy (tmp, s);
   strcat (tmp, t);
   return tmp;
 }
+#endif
 
 // Throw away input until a given character is read.
 
 void
 discard_until (istream& stream, char character)
 {
   int c;
   for (;;)
@@ -159,27 +163,30 @@ read_until (istream& stream, char charac
     }
 
   return buf;
 }
 #endif
 
 // Get a temporary file name.
 
-char *
+string
 octave_tmp_file_name (void)
 {
-  static char *retval = 0;
+  string retval;
+
+  char *tmp = tempnam (0, "oct-");
 
-  if (retval)
-    free (retval);
+  if (tmp)
+    {
+      retval = tmp;
 
-  retval = tempnam (0, "oct-");
-
-  if (! retval)
+      free (tmp);
+    }
+  else
     error ("can't open temporary file!");
 
   return retval;
 }
 
 DEFUN ("octave_tmp_file_name", Foctave_tmp_file_name,
        Soctave_tmp_file_name, 10,
  "octave_tmp_file_name ()")
@@ -189,102 +196,54 @@ DEFUN ("octave_tmp_file_name", Foctave_t
   if (args.length () == 0)
     retval = octave_tmp_file_name ();
   else
     print_usage ("octave_tmp_file_name");
 
   return retval;
 }
 
-char **
-pathstring_to_vector (char *pathstring)
-{
-  static char **path = 0;
-
-  if (pathstring)
-    {
-      int nelem = 0;
-      char *tmp_path = strsave (pathstring);
-      if (*tmp_path != '\0')
-	{
-	  nelem++;
-	  char *ptr = tmp_path;
-	  while (*ptr != '\0')
-	    {
-	      if (*ptr == SEPCHAR)
-		nelem++;
-	      ptr++;
-	    }
-	}
-
-      char **foo = path;
-      while (foo && *foo)
-	delete [] *foo++;
-      delete [] path;
-
-      path = new char * [nelem+1];
-      path[nelem] = 0;
-
-      int i = 0;
-      char *ptr = tmp_path;
-      while (i < nelem)
-	{
-	  char *end = strchr (ptr, SEPCHAR);
-	  if (end)
-	    *end = '\0';
-	  string result = oct_tilde_expand (ptr);
-	  path[i] = strsave (result.c_str ());
-	  ptr = end + 1;
-	  i++;
-	}
-
-      delete [] tmp_path;
-    }
-
-  return path;
-}
-
 // Return to the main command loop in octave.cc.
 
 extern "C" void
 jump_to_top_level (void)
 {
   run_all_unwind_protects ();
 
   longjmp (toplevel, 1);
 }
 
 int
-almost_match (const char *std, const char *s, int min_match_len,
+almost_match (const string& std, const string& s, int min_match_len,
 	      int case_sens)
 {
-  int stdlen = strlen (std);
-  int slen = strlen (s);
+  int stdlen = std.length ();
+  int slen = s.length ();
 
   return (slen <= stdlen
 	  && slen >= min_match_len
 	  && (case_sens
-	      ? (strncmp (std, s, slen) == 0)
-	      : (strncasecmp (std, s, slen) == 0)));
+	      ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
+	      : (strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
 }
 
 // Ugh.
 
 int
-keyword_almost_match (const char **std, int *min_len, const char *s,
+keyword_almost_match (const char **std, int *min_len, const string& s,
 		      int min_toks_to_match, int max_toks)
 {
   int status = 0;
   int tok_count = 0;
   int toks_matched = 0;
 
-  if (! s || *s == '\0' || max_toks < 1)
+  if (s.empty () || max_toks < 1)
     return status;
 
-  char *kw = strsave (s);
+  char *kw = strsave (s.c_str ());
 
   char *t = kw;
   while (*t != '\0')
     {
       if (*t == '\t')
 	*t = ' ';
       t++;
     }
@@ -350,21 +309,21 @@ keyword_almost_match (const char **std, 
  done:
 
   delete [] kw;
   delete [] to_match;
 
   return status;
 }
 
-char **
+string_vector
 get_fcn_file_names (int& num, const char *dir, int no_suffix)
 {
   static int num_max = 256;
-  char **retval = new char * [num_max];
+  string_vector retval (num_max);
   int i = 0;
 
   DIR *dirp = opendir (dir);
   if (dirp)
     {
       struct dirent *entry;
       while ((entry = readdir (dirp)) != 0)
 	{
@@ -379,105 +338,84 @@ get_fcn_file_names (int& num, const char
 		  && entry->d_name[len-2] == 'c'
 		  && entry->d_name[len-1] == 't'))
 #else
 	  if (len > 2
 	      && entry->d_name[len-2] == '.'
 	      && entry->d_name[len-1] == 'm')
 #endif
 	    {
-	      retval[i] = strsave (entry->d_name);
+	      retval[i] = entry->d_name;
 	      if (no_suffix)
 		{
 		  if (retval[i][len-1] == 'm')
 		    retval[i][len-2] = '\0';
 		  else
 		    retval[i][len-4] = '\0';
 		}
 
 	      i++;
 
 	      if (i == num_max - 1)
 		{
-		  // Reallocate the array.  Only copy pointers, not
-		  // the strings they point to, then only delete the
-		  // original array of pointers, and not the strings
-		  // they point to.
-
 		  num_max += 256;
-		  char **tmp = new char * [num_max];
-		  for (int j = 0; j < i; j++)
-		    tmp[j] = retval[j];
-
-		  delete [] retval;
-
-		  retval = tmp;
+		  retval.resize (num_max);
 		}
 	    }
 	}
       closedir (dirp);
     }
 
-  retval[i] = 0;
   num = i;
+  retval.resize (num);
 
   return retval;
 }
 
-char **
+string_vector
 get_fcn_file_names (int& num, int no_suffix)
 {
   static int num_max = 1024;
-  char **retval = new char * [num_max];
+  string_vector retval (num_max);
   int i = 0;
 
-  char *path_elt = kpse_path_element (user_pref.loadpath);
+  char *path_elt = kpse_path_element (user_pref.loadpath.c_str ());
 
   while (path_elt)
     {
       str_llist_type *elt_dirs = kpse_element_dirs (path_elt);
 
       str_llist_elt_type *dir;
       for (dir = *elt_dirs; dir; dir = STR_LLIST_NEXT (*dir))
 	{
 	  char *elt_dir = STR_LLIST (*dir);
 
 	  if (elt_dir)
 	    {
 	      int tmp_num;
-	      char **names = get_fcn_file_names (tmp_num, elt_dir, no_suffix);
+	      string_vector names
+		= get_fcn_file_names (tmp_num, elt_dir, no_suffix);
 
 	      if (i + tmp_num >= num_max - 1)
 		{
-		  // Reallocate the array.  Only copy pointers, not
-		  // the strings they point to, then only delete the
-		  // original array of pointers, and not the strings
-		  // they point to.
-
 		  num_max += 1024;
-		  char **tmp = new char * [num_max];
-		  for (int j = 0; j < i; j++)
-		    tmp[j] = retval[j];
-
-		  delete [] retval;
-
-		  retval = tmp;
+		  retval.resize (num_max);
 		}
 
 	      int k = 0;
 	      while (k < tmp_num)
 		retval[i++] = names[k++];
 	    }
 	}
 
       path_elt = kpse_path_element (0);
     }
 
-  retval[i] = 0;
   num = i;
+  retval.resize (num);
 
   return retval;
 }
 
 // Convert X to the nearest integer value.  Should not pass NaN to
 // this function.
 
 int
@@ -507,33 +445,32 @@ all_strings (const Octave_object& args)
 {
   int n = args.length ();
   for (int i = 0; i < n; i++)
     if (! args(i).is_string ())
       return 0;
   return 1;
 }
 
-char **
-make_argv (const Octave_object& args, const char *fcn_name)
+string_vector
+make_argv (const Octave_object& args, const string& fcn_name)
 {
-  char **argv = 0;
+  string_vector argv;
+
   if (all_strings (args))
     {
       int n = args.length ();
-      argv = new char * [n + 1];
-      argv[0] = strsave (fcn_name);
+      argv.resize (n+1);
+      argv[0] = fcn_name;
+
       for (int i = 0; i < n; i++)
-	{
-	  string tstr = args(i).string_value ();
-	  argv[i+1] = strsave (tstr.c_str ());
-	}
+	argv[i+1] = args(i).string_value ();
     }
   else
-    error ("%s: expecting all arguments to be strings", fcn_name);
+    error ("%s: expecting all arguments to be strings", fcn_name.c_str ());
 
   return argv;
 }
 
 // Return non-zero if either NR or NC is zero.  Return -1 if this
 // should be considered fatal; return 1 if this is ok.
 
 int
@@ -557,31 +494,29 @@ empty_arg (const char *name, int nr, int
 	}
       else
 	is_empty = 1;
     }
 
   return is_empty;
 }
 
-// Format a list in neat columns.  Mostly stolen from GNU ls.  This
-// should maybe be in utils.cc.
+// Format a list in neat columns.  Mostly stolen from GNU ls.
 
 ostrstream&
-list_in_columns (ostrstream& os, char **list)
+list_in_columns (ostrstream& os, const string_vector& list)
 {
   // Compute the maximum name length.
 
   int max_name_length = 0;
-  int total_names = 0;
-  char **names = 0;
-  for (names = list; *names; names++)
+  int total_names = list.length ();
+
+  for (int i = 0; i < total_names; i++)
     {
-      total_names++;
-      int name_length = strlen (*names);
+      int name_length = list[i].length ();
       if (name_length > max_name_length)
 	max_name_length = name_length;
     }
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
@@ -596,29 +531,30 @@ list_in_columns (ostrstream& os, char **
   // possibly  for a short column on the right.
 
   int rows = total_names / cols + (total_names % cols != 0);
 
   // Recalculate columns based on rows.
 
   cols = total_names / rows + (total_names % rows != 0);
 
-  names = list;
   int count;
   for (int row = 0; row < rows; row++)
     {
       count = row;
       int pos = 0;
 
       // Print the next row.
 
       while (1)
 	{
-	  os << *(names + count);
-	  int name_length = strlen (*(names + count));
+	  string nm = list[count];
+
+	  os << nm;
+	  int name_length = nm.length ();
 
 	  count += rows;
 	  if (count >= total_names)
 	    break;
 
 	  int spaces_to_pad = max_name_length - name_length;
 	  for (int i = 0; i < spaces_to_pad; i++)
 	    os << " ";
@@ -627,126 +563,122 @@ list_in_columns (ostrstream& os, char **
       os << "\n";
     }
 
   return os;
 }
 
 // See if the given file is in the path.
 
-char *
-search_path_for_file (const char *path, const char *name)
+string
+search_path_for_file (const string& path, const string& name)
 {
-  char *retval = 0;
+  string retval;
 
-  char *tmp = kpse_path_search (path, name, kpathsea_true);
+  char *tmp = kpse_path_search (path.c_str (), name.c_str (),
+				kpathsea_true);
 
   if (tmp)
     {
       retval = make_absolute (tmp, the_current_working_directory);
       free (tmp);
     }
 
   return retval;
 }
 
 DEFUN ("file_in_path", Ffile_in_path, Sfile_in_path, 10,
   "file_in_path (PATH, NAME)")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("file_in_path");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "file_in_path");
+
+  if (error_state)
+    return retval;
 
   if (argc == 3)
     {
-      char *fname = search_path_for_file (argv[1], argv[2]);
+      string fname = search_path_for_file (argv[1], argv[2]);
 
-      if (fname)
+      if (fname.empty ())
+	retval = Matrix ();
+      else
 	retval = fname;
-      else
-	retval = Matrix ();
     }
   else
     print_usage ("file_in_path");
 
-  DELETE_ARGV;
-
   return retval;
 }
 
-
-char *
-file_in_path (const char *name, const char *suffix)
+string
+file_in_path (const string& name, const string& suffix)
 {
-  char *retval = 0;
+  string nm = name;
 
-  char *nm = 0;
+  if (! suffix.empty ())
+    nm.append (suffix);
 
-  if (suffix)
-    nm = strconcat (name, suffix);
-  else
-    nm = strsave (name);
-
-  if (! the_current_working_directory)
+  if (the_current_working_directory.empty ())
     get_working_directory ("file_in_path");
 
-  retval = search_path_for_file (user_pref.loadpath, nm);
-
-  delete [] nm;
-
-  return retval;
+  return search_path_for_file (user_pref.loadpath, nm);
 }
 
 // See if there is an function file in the path.  If so, return the
 // full path to the file.
 
-char *
-fcn_file_in_path (const char *name)
+string
+fcn_file_in_path (const string& name)
 {
-  if (name)
-    {
-      int len = strlen (name);
+  string retval;
 
-      if (name [len - 2] == '.' && name [len - 1] == 'm')
-	return file_in_path (name, "");
+  int len = name.length ();
+  
+  if (len > 0)
+    {
+      if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
+	retval = file_in_path (name, "");
       else
-	return file_in_path (name, ".m");
+	retval = file_in_path (name, ".m");
     }
-  else
-    return 0;
+
+  return retval;
 }
 
 // See if there is an octave file in the path.  If so, return the
 // full path to the file.
 
-char *
-oct_file_in_path (const char *name)
+string
+oct_file_in_path (const string& name)
 {
-  if (name)
-    {
-      int len = strlen (name);
+  string retval;
 
-      if (name [len - 4] == '.' && name [len - 3] == 'o'
+  int len = name.length ();
+  
+  if (len > 0)
+    {
+      if (len > 2 && name [len - 4] == '.' && name [len - 3] == 'o'
 	  && name [len - 2] == 'c' && name [len - 1] == 't')
-	return file_in_path (name, "");
+	retval = file_in_path (name, "");
       else
-	return file_in_path (name, ".oct");
+	retval = file_in_path (name, ".oct");
     }
-  else
-    return 0;
+
+  return retval;
 }
 
-char *
+const char *
 undo_string_escape (char c)
 {
-  static char retval[2];
-  retval[1] = '\0';
-
   if (! c)
-    return 0;
+    return "";
 
   switch (c)
     {
     case '\a':
       return "\\a";
 
     case '\b': // backspace
       return "\\b";
@@ -768,49 +700,46 @@ undo_string_escape (char c)
 
     case '\\': // backslash
       return "\\\\";
 
     case '"': // double quote
       return "\\\"";
 
     default:
-      retval[0] = c;
-      return retval;
+      {
+	static char retval[2];
+	retval[0] = c;
+	retval[1] = '\0';
+	return retval;
+      }
     }
 }
 
-char *
-undo_string_escapes (const char *s)
+string
+undo_string_escapes (const string& s)
 {
-  ostrstream buf;
+  string retval;
 
-  char *t;
-  while ((t = undo_string_escape (*s++)))
-    buf << t;
-  buf << ends;
+  for (size_t i = 0; i < s.length (); i++)
+    retval.append (undo_string_escape (s[i]));
 
-  return buf.str ();
+  return retval;
 }
 
 DEFUN ("undo_string_escapes", Fundo_string_escapes,
        Sundo_string_escapes, 10,
   "undo_string_escapes (STRING)")
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
-    {
-      string tstr = args(0).string_value ();
-      char *str = undo_string_escapes (tstr.c_str ());
-      retval = str;
-      delete [] str;
-    }
+    retval = undo_string_escapes (args(0).string_value ());
   else
     print_usage ("undo_string_escapes");
 
   return retval;
 }
 
 // This function was adapted from xputenv from Karl Berry's kpathsearch
 // library.
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -22,61 +22,67 @@ Software Foundation, 59 Temple Place - S
 */
 
 #if !defined (octave_utils_h)
 #define octave_utils_h 1
 
 class istream;
 class ostrstream;
 
+#include <string>
+
 class Octave_object;
+class string_vector;
 
 extern char *strsave (const char *);
+
+#if 0
 extern char *strconcat (const char *, const char *);
+#endif
 
 extern void discard_until (istream&, char);
 
 #if 0
 extern char *read_until (istream&, char);
 #endif
 
-extern char *search_path_for_file (const char *, const char *);
-extern char *file_in_path (const char *, const char *);
-extern char *fcn_file_in_path (const char *);
-extern char *oct_file_in_path (const char *);
+extern string search_path_for_file (const string&, const string&);
+extern string file_in_path (const string&, const string&);
+extern string fcn_file_in_path (const string&);
+extern string oct_file_in_path (const string&);
 
-extern char *octave_tmp_file_name (void);
-
-extern char **pathstring_to_vector (char *pathstring);
+extern string octave_tmp_file_name (void);
 
 extern "C" void jump_to_top_level (void) NORETURN;
 
-extern int almost_match (const char *std, const char *s,
+extern int almost_match (const string& std, const string& s,
 			 int min_match_len = 1, int case_sens = 1);
-extern int keyword_almost_match (const char **std, int *min_len,
-				 const char *s, int min_toks_to_match,
-				 int max_toks);
 
-extern char **get_fcn_file_names (int& ffl_len, const char *dir,
-				  int no_suffix); 
-extern char **get_fcn_file_names (int& ffl_len, int no_suffix);
+extern int
+keyword_almost_match (const char **std, int *min_len,
+		      const string& s, int min_toks_to_match,
+		      int max_toks);
+
+extern string_vector get_fcn_file_names (int& ffl_len, const char *dir,
+					 int no_suffix); 
+
+extern string_vector get_fcn_file_names (int& ffl_len, int no_suffix);
 
 extern int NINT (double x);
 extern double D_NINT (double x);
 
-extern char **make_argv (const Octave_object& args, const char *fcn_name);
+extern string_vector make_argv (const Octave_object&, const string&);
 
 extern int empty_arg (const char *name, int nr, int nc);
 
-extern ostrstream& list_in_columns (ostrstream& os, char **list);
+extern ostrstream& list_in_columns (ostrstream& os, const string_vector& list);
 
-extern char *undo_string_escape (char c);
-extern char *undo_string_escapes (const char *s);
+extern string undo_string_escapes (const string& s);
 
-extern void oct_putenv (const char *,  const char *);
+extern void oct_putenv (const char *, const char *);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -37,16 +37,18 @@ Software Foundation, 59 Temple Place - S
 #include <sys/types.h>
 #include <unistd.h>
 #endif
 
 #include <readline/readline.h>
 
 #include "fnmatch.h"
 
+#include "str-vec.h"
+
 #include "defaults.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
 #include "lex.h"
@@ -94,76 +96,73 @@ initialize_symbol_tables (void)
   curr_sym_tab = top_level_sym_tab;
 }
 
 // Attributes of variables and functions.
 
 // Is this variable a builtin?
 
 int
-is_builtin_variable (const char *name)
+is_builtin_variable (const string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_builtin_variable ());
 }
 
 // Is this a text-style function?
 
 int
-is_text_function_name (const char *s)
+is_text_function_name (const string& s)
 {
   symbol_record *sr = global_sym_tab->lookup (s);
   return (sr && sr->is_text_function ());
 }
 
 // Is this function globally in this scope?
 
 int
-is_globally_visible (const char *name)
+is_globally_visible (const string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
   return (sr && sr->is_linked_to_global ());
 }
 
 // Is this tree_constant a valid function?
 
 tree_fvc *
-is_valid_function (const tree_constant& arg, char *warn_for, int warn)
+is_valid_function (const tree_constant& arg, const string& warn_for, int warn)
 {
   tree_fvc *ans = 0;
 
-  const char *fcn_name = 0;
-
-  string tstr;
+  string fcn_name;
 
   if (arg.is_string ())
-    {
-      tstr = arg.string_value ();
-      fcn_name = tstr.c_str ();
-    }
+    fcn_name = arg.string_value ();
 
-  if (! fcn_name || error_state)
+  if (fcn_name.empty () || error_state)
     {
       if (warn)
-	error ("%s: expecting function name as argument", warn_for);
+	error ("%s: expecting function name as argument",
+	       warn_for.c_str ());
       return ans;
     }
 
   symbol_record *sr = 0;
-  if (fcn_name)
+
+  if (! fcn_name.empty ())
     sr = lookup_by_name (fcn_name);
 
   if (sr)
     ans = sr->def ();
 
   if (! sr || ! ans || ! sr->is_function ())
     {
       if (warn)
 	error ("%s: the symbol `%s' is not valid as a function",
-	       warn_for, fcn_name);
+	       warn_for.c_str (), fcn_name.c_str ());
       ans = 0;
     }
 
   return ans;
 }
 
 DEFUN ("is_global", Fis_global, Sis_global, 10,
   "is_global (X): return 1 if the string X names a global variable\n\
@@ -174,18 +173,17 @@ otherwise, return 0.")
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("is_global");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  const char *name = tstr.c_str ();
+  string name = args(0).string_value ();
 
   if (error_state)
     {
       error ("is_global: expecting string argument");
       return retval;
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
@@ -211,351 +209,299 @@ returns:\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
 
-  string tstr = args(0).string_value ();
-  char *name = strsave (tstr.c_str ());
+  string name = args(0).string_value ();
 
   if (error_state)
     {
       error ("exist: expecting string argument");
-      delete [] name;
       return retval;
     }
 
-  char *struct_elts = strchr (name, '.');
-  if (struct_elts)
+  string struct_elts;
+
+  size_t pos = name.find ('.');
+
+  if (pos != NPOS)
     {
-      *struct_elts = '\0';
-      struct_elts++;
+      struct_elts = name.substr (pos+1);
+      name = name.substr (0, pos);
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
   if (! sr)
     sr = global_sym_tab->lookup (name, 0, 0);
 
   retval = 0.0;
 
   if (sr && sr->is_variable () && sr->is_defined ())
     {
       retval = 1.0;
       tree_fvc *def = sr->def ();
-      if (struct_elts)
+
+      if (! struct_elts.empty ())
 	{
 	  retval = 0.0;
 	  if (def->is_constant ())
 	    {
 	      tree_constant *tmp = (tree_constant *) def;
-	      tree_constant ult;
-	      ult = tmp->lookup_map_element (struct_elts, 0, 1);
+
+	      tree_constant ult	= tmp->lookup_map_element (struct_elts, 0, 1);
+
 	      if (ult.is_defined ())
 		retval = 1.0;
 	    }
 	}
     }
   else if (sr && sr->is_builtin_function ())
     {
       retval = 5.0;
     }
   else if (sr && sr->is_user_function ())
     {
       retval = 2.0;
     }
   else
     {
-      char *path = fcn_file_in_path (name);
-      if (path)
+      string path = fcn_file_in_path (name);
+
+      if (path.length () > 0)
 	{
-	  delete [] path;
 	  retval = 2.0;
 	}
       else
 	{
 	  path = oct_file_in_path (name);
-	  if (path)
+
+	  if (path.length () > 0)
 	    {
-	      delete [] path;
 	      retval = 3.0;
 	    }
 	  else
 	    {
 	      struct stat buf;
-	      if (stat (name, &buf) == 0 && S_ISREG (buf.st_mode))
+	      if (stat (name.c_str (), &buf) == 0 && S_ISREG (buf.st_mode))
 		retval = 2.0;
 	    }
 	}
     }
 
-  delete [] name;
-
   return retval;
 }
 
 // XXX FIXME XXX -- should these really be here?
 
-static char *
+static string
 octave_home (void)
 {
   char *oh = getenv ("OCTAVE_HOME");
 
-  return (oh ? oh : OCTAVE_PREFIX);
+  return oh ? string (oh) : string (OCTAVE_PREFIX);
 }
 
-static char *
-subst_octave_home (char *s)
+static string
+subst_octave_home (const string& s)
 {
-  char *home = octave_home ();
-  char *prefix = OCTAVE_PREFIX;
-
-  char *retval;
-
-  if (strcmp (home, prefix) == 0)
-    retval = strsave (s);
-  else
-    {
-      int len_home = strlen (home);
-      int len_prefix = strlen (prefix);
+  string retval;
 
-      int count = 0;
-      char *ptr = s;
-      char *next = 0;
-      while ((next = strstr (ptr, prefix)))
-	{
-	  ptr = next + len_prefix;
-	  count++;
-	}
-
-      int grow_size = count * (len_home - len_prefix);
-
-      int len_s = strlen (s);
-
-      int len_retval = len_s + count * grow_size;
+  string home = octave_home ();
+  string prefix = OCTAVE_PREFIX;
 
-      retval = new char [len_retval+1];
-
-      char *p1 = s;
-      char *p2 = p1;
-      char *pdest = retval;
-
-      // Is this really a good way to do this?
-
-      while (count >= 0)
-	{
-	  p2 = strstr (p1, prefix);
+  retval = s;
 
-	  if (! p2)
-	    {
-	      memcpy (pdest, p1, strlen (p1)+1);
-	      break;
-	    }
-	  else if (p1 == p2)
-	    {
-	      memcpy (pdest, home, len_home);
-	      pdest += len_home;
-	      p1 += len_prefix;
-	      count--;
-	    }
-	  else
-	    {
-	      int len = (int) (p2 - p1);
-	      memcpy (pdest, p1, len);
-	      pdest += len;
-	      p1 += len;
-	    }
-
+  if (home != prefix)
+    {
+      int len = prefix.length ();
+      size_t start = 0;
+      while ((start = s.find (prefix)) != NPOS)
+	{
+	  retval.replace (start, len, home);
+	  start++;
 	}
     }
 
   return retval;
 }
 
-static char *
+static string
 octave_info_dir (void)
 {
-  static char *retval = subst_octave_home (OCTAVE_INFODIR);
-  return retval;
+  return subst_octave_home (OCTAVE_INFODIR);
 }
 
-char *
+string
 octave_arch_lib_dir (void)
 {
-  static char *retval = subst_octave_home (OCTAVE_ARCHLIBDIR);
-  return retval;
+  return subst_octave_home (OCTAVE_ARCHLIBDIR);
 }
 
-char *
+string
 octave_fcn_file_dir (void)
 {
-  static char *retval = subst_octave_home (OCTAVE_FCNFILEDIR);
-  return retval;
+  return subst_octave_home (OCTAVE_FCNFILEDIR);
 }
 
-char *
+string
 octave_bin_dir (void)
 {
-  static char *retval = subst_octave_home (OCTAVE_BINDIR);
-  return retval;
+  return subst_octave_home (OCTAVE_BINDIR);
 }
 
-static char *
+string
 default_pager (void)
 {
-  static char *pager_binary = 0;
-  delete [] pager_binary;
+  string pager_binary;
+
   char *pgr = getenv ("PAGER");
+
   if (pgr)
-    pager_binary = strsave (pgr);
-  else
+    pager_binary = string (pgr);
 #ifdef DEFAULT_PAGER
-    pager_binary = strsave (DEFAULT_PAGER);
-#else
-    pager_binary = strsave ("");
+  else
+    pager_binary = string (DEFAULT_PAGER);
 #endif
 
   return pager_binary;
 }
 
-// Always returns a new string.
+string
+maybe_add_default_load_path (const string& pathstring)
+{
+  string std_path = subst_octave_home (OCTAVE_FCNFILEPATH);
 
-char *
-maybe_add_default_load_path (const char *p)
-{
-  static char *std_path = subst_octave_home (OCTAVE_FCNFILEPATH);
+  string retval;
 
-  char *pathstring = strsave (p);
-
-  if (pathstring[0] == SEPCHAR)
+  if (! pathstring.empty ())
     {
-      char *tmp = pathstring;
-      pathstring = strconcat (std_path, pathstring);
-      delete [] tmp;
+      if (pathstring[0] == SEPCHAR)
+	{
+	  retval = std_path;
+	  retval.append (pathstring);
+	}
+      else
+	retval = pathstring;
+
+      if (pathstring[pathstring.length () - 1] == SEPCHAR)
+	retval.append (std_path);
     }
 
-  int tmp_len = strlen (pathstring);
-  if (pathstring[tmp_len-1] == SEPCHAR)
-    {
-      char *tmp = pathstring;
-      pathstring = strconcat (pathstring, std_path);
-      delete [] tmp;
-    }
-
-  return pathstring;
-}
-
-char *
-octave_lib_dir (void)
-{
-  static char *retval = subst_octave_home (OCTAVE_LIBDIR);
   return retval;
 }
 
-char *
+string
+octave_lib_dir (void)
+{
+  return subst_octave_home (OCTAVE_LIBDIR);
+}
+
+string
 default_exec_path (void)
 {
-  static char *exec_path_string = 0;
-  delete [] exec_path_string;
+  string exec_path_string;
+
   char *octave_exec_path = getenv ("OCTAVE_EXEC_PATH");
+
   if (octave_exec_path)
-    exec_path_string = strsave (octave_exec_path);
+    exec_path_string = string (octave_exec_path);
   else
     {
       char *shell_path = getenv ("PATH");
+
       if (shell_path)
-	exec_path_string = strconcat (":", shell_path);
-      else
-	exec_path_string = strsave ("");
+	{
+	  exec_path_string = string (":");
+	  exec_path_string.append (shell_path);
+	}
     }
+
   return exec_path_string;
 }
 
 // Handle OCTAVE_PATH from the environment like TeX handles TEXINPUTS.
 // If the path starts with `:', prepend the standard path.  If it ends
 // with `:' append the standard path.  If it begins and ends with
 // `:', do both (which is useless, but the luser asked for it...).
-//
-// This function may eventually be called more than once, so be
-// careful not to create memory leaks.
 
-char *
+string
 default_path (void)
 {
-  static char *std_path = subst_octave_home (OCTAVE_FCNFILEPATH);
-
-  static char *oct_path = getenv ("OCTAVE_PATH");
+  string std_path = subst_octave_home (OCTAVE_FCNFILEPATH);
 
-  static char *pathstring = 0;
-  delete [] pathstring;
+  char *oct_path = getenv ("OCTAVE_PATH");
 
-  return oct_path ? strsave (oct_path) : strsave (std_path);
+  return oct_path ? string (oct_path) : std_path;
 }
 
-char *
+string
 default_info_file (void)
 {
-  static char *info_file_string = 0;
-  delete [] info_file_string;
+  string info_file_string;
+
   char *oct_info_file = getenv ("OCTAVE_INFO_FILE");
+
   if (oct_info_file)
-    info_file_string = strsave (oct_info_file);
+    info_file_string = string (oct_info_file);
   else
     {
-      char *infodir = octave_info_dir ();
-      info_file_string = strconcat (infodir, "/octave.info");
+      string infodir = octave_info_dir ();
+      info_file_string = infodir.append ("/octave.info");
     }
+
   return info_file_string;
 }
 
-char *
+string
 default_info_prog (void)
 {
-  static char *info_prog_string = 0;
-  delete [] info_prog_string;
+  string info_prog_string;
+
   char *oct_info_prog = getenv ("OCTAVE_INFO_PROGRAM");
+
   if (oct_info_prog)
-    info_prog_string = strsave (oct_info_prog);
+    info_prog_string = string (oct_info_prog);
   else
     {
-      char *archdir = octave_arch_lib_dir ();
-      info_prog_string = strconcat (archdir, "/info");
+      string archdir = octave_arch_lib_dir ();
+      info_prog_string = archdir.append ("/info");
     }
+
   return info_prog_string;
 }
 
-char *
+string
 default_editor (void)
 {
-  static char *editor_string = 0;
-  delete [] editor_string;
+  string editor_string = "vi";
+
   char *env_editor = getenv ("EDITOR");
+
   if (env_editor && *env_editor)
-    editor_string = strsave (env_editor);
-  else
-    editor_string = strsave ("vi");
+    editor_string = string (env_editor);
+
   return editor_string;
 }
 
-char *
+string
 get_local_site_defaults (void)
 {
-  static char *startupdir = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
-  static char *sd = strconcat (startupdir, "/octaverc");
-  return sd;
+  string startupdir = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
+  return startupdir.append ("/octaverc");
 }
 
-char *
+string
 get_site_defaults (void)
 {
-  static char *startupdir = subst_octave_home (OCTAVE_STARTUPFILEDIR);
-  static char *sd = strconcat (startupdir, "/octaverc");
-  return sd;
+  string startupdir = subst_octave_home (OCTAVE_STARTUPFILEDIR);
+  return startupdir.append ("/octaverc");
 }
 
 // Functions for looking up variables and functions.
 
 // Is there a corresponding function file that is newer than the
 // symbol definition?
 
 static int
@@ -566,83 +512,94 @@ symbol_out_of_date (symbol_record *sr)
   if (ignore == 2)
     return 0;
 
   if (sr)
     {
       tree_fvc *ans = sr->def ();
       if (ans)
 	{
-	  char *ff = ans->fcn_file_name ();
-	  if (ff && ! (ignore && ans->is_system_fcn_file ()))
+	  string ff = ans->fcn_file_name ();
+	  if (! ff.empty () && ! (ignore && ans->is_system_fcn_file ()))
 	    {
 	      time_t tp = ans->time_parsed ();
-	      char *fname = fcn_file_in_path (ff);
+
+	      string fname = fcn_file_in_path (ff);
+
 	      int status = is_newer (fname, tp);
-	      delete [] fname;
+
 	      if (status > 0)
 		return 1;
 	    }
 	}
     }
   return 0;
 }
 
 static int
-looks_like_octave_copyright (char *s)
+looks_like_octave_copyright (const string& s)
 {
-  if (s && strncmp (s, " Copyright (C) ", 15) == 0)
+  string t = s.substr (0, 15);
+
+  if (t == " Copyright (C) ")
     {
-      s = strchr (s, '\n');
-      if (s)
+      size_t pos = s.find ('\n');
+
+      if (pos != NPOS)
 	{
-	  s++;
-	  s = strchr (s, '\n');
-	  if (s)
+	  pos = s.find ('\n', pos + 1);
+
+	  if (pos != NPOS)
 	    {
-	      s++;
-	      if (strncmp (s, " This file is part of Octave.", 29) == 0
-		  || strncmp (s, " This program is free software", 30) == 0)
+	      pos++;
+
+	      t = s.substr (pos, 29);
+
+	      if (t == " This file is part of Octave."
+		  || t == " This program is free software")
 		return 1;
 	    }
 	}
     }
   return 0;
 }
 
 // Eat whitespace and comments from FFILE, returning the text of the
 // comments read if it doesn't look like a copyright notice.  If
 // IN_PARTS, consider each block of comments separately; otherwise,
 // grab them all at once.
 
-static char *
+static string
 gobble_leading_white_space (FILE *ffile, int in_parts)
 {
-  ostrstream buf;
+  string help_txt;
 
   int first_comments_seen = 0;
   int have_help_text = 0;
   int in_comment = 0;
   int c;
+
   while ((c = getc (ffile)) != EOF)
     {
       current_input_column++;
+
       if (in_comment)
 	{
 	  if (! have_help_text)
 	    {
 	      first_comments_seen = 1;
-	      buf << (char) c;
+	      help_txt += (char) c;
 	    }
 
 	  if (c == '\n')
 	    {
 	      input_line_number++;
 	      current_input_column = 0;
 	      in_comment = 0;
+
 	      if (in_parts)
 		{
 		  if ((c = getc (ffile)) != EOF)
 		    {
 		      current_input_column--;
 		      ungetc (c, ffile);
 		      if (c == '\n')
 			break;
@@ -679,37 +636,25 @@ gobble_leading_white_space (FILE *ffile,
 	      ungetc (c, ffile);
 	      goto done;
 	    }
 	}
     }
 
  done:
 
-  buf << ends;
-  char *help_txt = buf.str ();
-
-  if (help_txt)
+  if (! help_txt.empty ())
     {
       if (looks_like_octave_copyright (help_txt)) 
-	{
-	  delete [] help_txt;
-	  help_txt = 0;
-	}
+	help_txt.resize (0);
 
-      if (in_parts && ! help_txt)
+      if (in_parts && help_txt.empty ())
 	help_txt = gobble_leading_white_space (ffile, in_parts);
     }
 
-  if (help_txt && ! *help_txt)
-    {
-      delete [] help_txt;
-      help_txt = 0;
-    }
-
   return help_txt;
 }
 
 static int
 is_function_file (FILE *ffile)
 {
   int status = 0;
 
@@ -723,24 +668,22 @@ is_function_file (FILE *ffile)
     status = 1;
 
   fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
 static int
-parse_fcn_file (int exec_script, char *ff)
+parse_fcn_file (int exec_script, const string& ff)
 {
   begin_unwind_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
 
-  assert (ff);
-
   // Open function file and parse.
 
   int old_reading_fcn_file_state = reading_fcn_file;
 
   unwind_protect_ptr (rl_instream);
   unwind_protect_ptr (ff_instream);
 
   unwind_protect_int (using_readline);
@@ -755,17 +698,17 @@ parse_fcn_file (int exec_script, char *f
 
   FILE *ffile = get_input_from_file (ff, 0);
 
   if (ffile)
     {
       // Check to see if this file defines a function or is just a
       // list of commands.
 
-      char *tmp_help_txt = gobble_leading_white_space (ffile, 0);
+      string tmp_help_txt = gobble_leading_white_space (ffile, 0);
 
       if (is_function_file (ffile))
 	{
 	  unwind_protect_int (user_pref.echo_executing_commands);
 	  unwind_protect_int (user_pref.saving_history);
 	  unwind_protect_int (reading_fcn_file);
 	  unwind_protect_int (input_from_command_line_file);
 
@@ -781,33 +724,29 @@ parse_fcn_file (int exec_script, char *f
 	  add_unwind_protect (delete_input_buffer, (void *) new_buf);
 
 	  switch_to_buffer (new_buf);
 
 	  unwind_protect_ptr (curr_sym_tab);
 
 	  reset_parser ();
 
-	  delete [] help_buf;
 	  help_buf = tmp_help_txt;
 
 	  int status = yyparse ();
 
 	  if (status != 0)
 	    {
-	      error ("parse error while reading function file %s", ff);
+	      error ("parse error while reading function file %s",
+		     ff.c_str ());
 	      global_sym_tab->clear (curr_fcn_file_name);
 	    }
 	}
       else if (exec_script)
 	{
-	  // We don't need this now.
-
-	  delete [] tmp_help_txt;
-
 	  // The value of `reading_fcn_file' will be restored to the
 	  // proper value when we unwind from this frame.
 
 	  reading_fcn_file = old_reading_fcn_file_state;
 
 	  unwind_protect_int (reading_script_file);
 	  reading_script_file = 1;
 
@@ -823,39 +762,43 @@ parse_fcn_file (int exec_script, char *f
   return script_file_executed;
 }
 
 static int
 load_fcn_from_file (symbol_record *sym_rec, int exec_script)
 {
   int script_file_executed = 0;
 
-  char *nm = sym_rec->name ();
+  string nm = sym_rec->name ();
 
   if (load_octave_oct_file (nm))
     {
       force_link_to_function (nm);
     }
   else
     {
-      char *ff = fcn_file_in_path (nm);
+      string ff = fcn_file_in_path (nm);
 
       // These are needed by yyparse.
 
+      begin_unwind_frame ("load_fcn_from_file");
+
+      unwind_protect_str (curr_fcn_file_name);
+      unwind_protect_str (curr_fcn_file_full_name);
+
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = ff;
 
-      if (ff)
-	{
-	  script_file_executed = parse_fcn_file (exec_script, ff);
-	  delete [] ff;
-	}
+      if (ff.length () > 0)
+	script_file_executed = parse_fcn_file (exec_script, ff);
 
       if (! (error_state || script_file_executed))
 	force_link_to_function (nm);
+
+      run_unwind_frame ("load_fcn_from_file");
     }
 
   return script_file_executed;
 }
 
 int
 lookup (symbol_record *sym_rec, int exec_script)
 {
@@ -884,82 +827,79 @@ lookup (symbol_record *sym_rec, int exec
 
 // Get the symbol record for the given name that is visible in the
 // current scope.  Reread any function definitions that appear to be
 // out of date.  If a function is available in a file but is not
 // currently loaded, this will load it and insert the name in the
 // current symbol table.
 
 symbol_record *
-lookup_by_name (const char *nm, int exec_script)
+lookup_by_name (const string& nm, int exec_script)
 {
   symbol_record *sym_rec = curr_sym_tab->lookup (nm, 1, 0);
 
   lookup (sym_rec, exec_script);
 
   return sym_rec;
 }
 
-char *
-get_help_from_file (const char *path)
+string
+get_help_from_file (const string& path)
 {
-  if (path && *path)
+  string retval;
+
+  if (! path.empty ())
     {
-      FILE *fptr = fopen (path, "r");
+      FILE *fptr = fopen (path.c_str (), "r");
+
       if (fptr)
 	{
-	  char *help_txt = gobble_leading_white_space (fptr, 1);
+	  retval = gobble_leading_white_space (fptr, 1);
 	  fclose (fptr);
-	  return help_txt;
 	}
     }
-  return 0;
+
+  return retval;
 }
 
 // Variable values.
 
 // Look for the given name in the global symbol table.  If it refers
 // to a string, return a new copy.  If not, return 0;
 
-char *
-builtin_string_variable (const char *name)
+string
+builtin_string_variable (const string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
-  char *retval = 0;
+  string retval;
 
   tree_fvc *defn = sr->def ();
 
   if (defn)
     {
       tree_constant val = defn->eval (0);
 
       if (! error_state && val.is_string ())
-	{
-	  string tstr = val.string_value ();
-	  const char *s = tstr.c_str ();
-
-	  if (s)
-	    retval = strsave (s);
-	}
+	retval = val.string_value ();
     }
 
   return retval;
 }
 
 // Look for the given name in the global symbol table.  If it refers
 // to a real scalar, place the value in d and return 1.  Otherwise,
 // return 0.
 
 int
-builtin_real_scalar_variable (const char *name, double& d)
+builtin_real_scalar_variable (const string& name, double& d)
 {
   int status = 0;
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
@@ -977,17 +917,17 @@ builtin_real_scalar_variable (const char
     }
 
   return status;
 }
 
 // Look for the given name in the global symbol table.
 
 tree_constant
-builtin_any_variable (const char *name)
+builtin_any_variable (const string& name)
 {
   tree_constant retval;
 
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
@@ -1007,21 +947,23 @@ builtin_any_variable (const char *name)
 // it doesn't already exist.
 
 void
 link_to_global_variable (symbol_record *sr)
 {
   if (sr->is_linked_to_global ())
     return;
 
-  symbol_record *gsr = global_sym_tab->lookup (sr->name (), 1, 0);
+  string nm = sr->name ();
+
+  symbol_record *gsr = global_sym_tab->lookup (nm, 1, 0);
 
   if (sr->is_formal_parameter ())
     {
-      error ("can't make function parameter `%s' global", sr->name ());
+      error ("can't make function parameter `%s' global", nm.c_str ());
       return;
     }
 
   // There must be a better way to do this.   XXX FIXME XXX
 
   if (sr->is_variable ())
     {
       // Would be nice not to have this cast.  XXX FIXME XXX
@@ -1078,59 +1020,59 @@ link_to_builtin_or_function (symbol_reco
 // used just after defining a function to avoid different behavior
 // depending on whether or not the function has been evaluated after
 // being defined.
 //
 // Return without doing anything if there isn't a function with the
 // given name defined in the global symbol table.
 
 void
-force_link_to_function (const char *id_name)
+force_link_to_function (const string& id_name)
 {
   symbol_record *gsr = global_sym_tab->lookup (id_name, 1, 0);
   if (gsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
       symbol_record *csr = curr_sym_tab->lookup (id_name, 1, 0);
       csr->alias (gsr);
     }
 }
 
 // Help stuff.  Shouldn't this go in help.cc?
 
 // It's not likely that this does the right thing now.  XXX FIXME XXX
 
-char **
+string_vector
 make_name_list (void)
 {
   int key_len = 0;
   int glb_len = 0;
   int top_len = 0;
   int lcl_len = 0;
   int ffl_len = 0;
 
-  char **key = 0;
-  char **glb = 0;
-  char **top = 0;
-  char **lcl = 0;
-  char **ffl = 0;
+  string_vector key;
+  string_vector glb;
+  string_vector top;
+  string_vector lcl;
+  string_vector ffl;
 
   // Each of these functions returns a new vector of pointers to new
   // strings.
 
   key = names (keyword_help (), key_len);
   glb = global_sym_tab->list (glb_len);
   top = top_level_sym_tab->list (top_len);
   if (top_level_sym_tab != curr_sym_tab)
     lcl = curr_sym_tab->list (lcl_len);
   ffl = get_fcn_file_names (ffl_len, 1);
 
   int total_len = key_len + glb_len + top_len + lcl_len + ffl_len;
 
-  char **list = new char * [total_len+1];
+  string_vector list (total_len);
 
   // Put all the symbols in one big list.  Only copy pointers, not the
   // strings they point to, then only delete the original array of
   // pointers, and not the strings they point to.
 
   int j = 0;
   int i = 0;
   for (i = 0; i < key_len; i++)
@@ -1143,38 +1085,30 @@ make_name_list (void)
     list[j++] = top[i];
 
   for (i = 0; i < lcl_len; i++)
     list[j++] = lcl[i];
 
   for (i = 0; i < ffl_len; i++)
     list[j++] = ffl[i];
 
-  list[j] = 0;
-
-  delete [] key;
-  delete [] glb;
-  delete [] top;
-  delete [] lcl;
-  delete [] ffl;
-
   return list;
 }
 
 // List variable names.
 
 static void
 print_symbol_info_line (ostrstream& output_buf, const symbol_record_info& s)
 {
   output_buf << (s.is_read_only () ? " -" : " w");
   output_buf << (s.is_eternal () ? "- " : "d ");
 #if 0
   output_buf << (s.hides_fcn () ? "f" : (s.hides_builtin () ? "F" : "-"));
 #endif
-  output_buf.form ("  %-16s", s.type_as_string ());
+  output_buf.form ("  %-16s", s.type_as_string ().c_str ());
   if (s.is_function ())
     output_buf << "      -      -";
   else
     {
       output_buf.form ("%7d", s.rows ());
       output_buf.form ("%7d", s.columns ());
     }
   output_buf << "  " << s.name () << "\n";
@@ -1190,17 +1124,17 @@ print_long_listing (ostrstream& output_b
   while (ptr->is_defined ())
     {
       print_symbol_info_line (output_buf, *ptr);
       ptr++;
     }
 }
 
 static int
-maybe_list (const char *header, char **argv, int argc,
+maybe_list (const char *header, const string_vector& argv, int argc,
 	    ostrstream& output_buf, int show_verbose, symbol_table
 	    *sym_tab, unsigned type, unsigned scope)
 {
   int count;
   int status = 0;
   if (show_verbose)
     {
       symbol_record_info *symbols;
@@ -1213,103 +1147,105 @@ maybe_list (const char *header, char **a
 
 	  print_long_listing (output_buf, symbols);
 	  status = 1;
 	}
       delete [] symbols;
     }
   else
     {
-      char **symbols = sym_tab->list (count, argv, argc, 1, type, scope);
-      if (symbols && count > 0)
+      string_vector symbols = sym_tab->list (count, argv, argc, 1,
+					     type, scope);
+      if (symbols.length () > 0 && count > 0)
 	{
 	  output_buf << "\n" << header << "\n\n";
 	  list_in_columns (output_buf, symbols);
 	  status = 1;
 	}
-      delete [] symbols;
     }
   return status;
 }
 
 DEFUN_TEXT ("document", Fdocument, Sdocument, 10,
   "document symbol string ...\n\
 \n\
 Associate a cryptic message with a variable name.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("document");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "document");
+
+  if (error_state)
+    return retval;
 
   if (argc == 3)
     {
-      char *name = argv[1];
-      char *help = argv[2];
+      string name = argv[1];
+      string help = argv[2];
 
       if (is_builtin_variable (name))
 	error ("sorry, can't redefine help for builtin variables");
       else
 	{
 	  symbol_record *sym_rec = curr_sym_tab->lookup (name, 0);
 
 	  if (sym_rec)
 	    sym_rec->document (help);
 	  else
-	    error ("document: no such symbol `%s'", name);
+	    error ("document: no such symbol `%s'", name.c_str ());
 	}
     }
   else
     print_usage ("document");
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 // XXX FIXME XXX -- this should take a list of regular expressions
 // naming the variables to look for.
 
 static Octave_object
-do_who (int argc, char **argv)
+do_who (int argc, const string_vector& argv)
 {
   Octave_object retval;
 
   int show_builtins = 0;
   int show_functions = (curr_sym_tab == top_level_sym_tab);
   int show_variables = 1;
   int show_verbose = 0;
 
-  char *my_name = argv[0];
+  string my_name = argv[0];
 
   if (argc > 1)
     {
       show_functions = 0;
       show_variables = 0;
     }
 
-  while (--argc > 0)
+  for (int i = 1; i < argc; i++)
     {
-      argv++;
-
-      if (strcmp (*argv, "-all") == 0 || strcmp (*argv, "-a") == 0)
+      if (argv[i] == "-all" || argv[i] == "-a")
 	{
 	  show_builtins++;
 	  show_functions++;
 	  show_variables++;
 	}
-      else if (strcmp (*argv, "-builtins") == 0 || strcmp (*argv, "-b") == 0)
+      else if (argv[i] == "-builtins" || argv[i] == "-b")
 	show_builtins++;
-      else if (strcmp (*argv, "-functions") == 0 || strcmp (*argv, "-f") == 0)
+      else if (argv[i] == "-functions" || argv[i] == "-f")
 	show_functions++;
-      else if (strcmp (*argv, "-long") == 0 || strcmp (*argv, "-l") == 0)
+      else if (argv[i] == "-long" || argv[i] == "-l")
 	show_verbose++;
-      else if (strcmp (*argv, "-variables") == 0 || strcmp (*argv, "-v") == 0)
+      else if (argv[i] == "-variables" || argv[i] == "-v")
 	show_variables++;
-      else if (*argv[0] == '-')
-	warning ("%s: unrecognized option `%s'", my_name, *argv);
+      else if (argv[i][0] == '-')
+	warning ("%s: unrecognized option `%s'", my_name.c_str (),
+		 argv[i].c_str ());
       else
 	break;
     }
 
   // If the user specified -l and nothing else, show variables.  If
   // evaluating this at the top level, also show functions.
 
   if (show_verbose && ! (show_builtins || show_functions || show_variables))
@@ -1367,22 +1303,25 @@ do_who (int argc, char **argv)
 DEFUN_TEXT ("who", Fwho, Swho, 10,
   "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("who");
+  int argc = args.length () + 1;
+
+  string_vector argv = make_argv (args, "who");
+
+  if (error_state)
+    return retval;
 
   retval = do_who (argc, argv);
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 DEFUN_TEXT ("whos", Fwhos, Swhos, 10,
   "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
@@ -1392,118 +1331,116 @@ character, but may not be combined.")
   int nargin = args.length ();
 
   Octave_object tmp_args;
   for (int i = nargin; i > 0; i--)
     tmp_args(i) = args(i-1);
   tmp_args(0) = "-long";
 
   int argc = tmp_args.length () + 1;
-  char **argv = make_argv (tmp_args, "whos");
+
+  string_vector argv = make_argv (tmp_args, "whos");
 
   if (error_state)
     return retval;
 
   retval = do_who (argc, argv);
 
-  while (--argc >= 0)
-    delete [] argv[argc];
-  delete [] argv;
-
   return retval;
 }
 
 // Install variables and functions in the symbol tables.
 
 void
-install_builtin_mapper (builtin_mapper_function *mf)
+install_builtin_mapper (const builtin_mapper_function& mf)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (mf->name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (mf.name, 1);
   sym_rec->unprotect ();
 
   Mapper_fcn mfcn;
-  mfcn.name = strsave (mf->name);
-  mfcn.can_return_complex_for_real_arg = mf->can_return_complex_for_real_arg;
-  mfcn.lower_limit = mf->lower_limit;
-  mfcn.upper_limit = mf->upper_limit;
-  mfcn.d_d_mapper = mf->d_d_mapper;
-  mfcn.d_c_mapper = mf->d_c_mapper;
-  mfcn.c_c_mapper = mf->c_c_mapper;
 
-  tree_builtin *def = new tree_builtin (mfcn, mf->name);
+  mfcn.name = mf.name;
+  mfcn.can_return_complex_for_real_arg = mf.can_return_complex_for_real_arg;
+  mfcn.lower_limit = mf.lower_limit;
+  mfcn.upper_limit = mf.upper_limit;
+  mfcn.d_d_mapper = mf.d_d_mapper;
+  mfcn.d_c_mapper = mf.d_c_mapper;
+  mfcn.c_c_mapper = mf.c_c_mapper;
+
+  tree_builtin *def = new tree_builtin (mfcn, mf.name);
 
   sym_rec->define (def);
 
-  sym_rec->document (mf->help_string);
+  sym_rec->document (mf.help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_function (builtin_function *f)
+install_builtin_function (const builtin_function& f)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (f->name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (f.name, 1);
   sym_rec->unprotect ();
 
-  tree_builtin *def = new tree_builtin (f->fcn, f->name);
+  tree_builtin *def = new tree_builtin (f.fcn, f.name);
 
-  sym_rec->define (def, f->is_text_fcn);
+  sym_rec->define (def, f.is_text_fcn);
 
-  sym_rec->document (f->help_string);
+  sym_rec->document (f.help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_variable (builtin_variable *v)
+install_builtin_variable (const builtin_variable& v)
 {
-  if (v->install_as_function)
-    install_builtin_variable_as_function (v->name, v->value, v->protect,
-					  v->eternal, v->help_string);
+  if (v.install_as_function)
+    install_builtin_variable_as_function (v.name, v.value, v.protect,
+					  v.eternal, v.help_string);
   else
-    bind_builtin_variable (v->name, v->value, v->protect, v->eternal,
-			   v->sv_function, v->help_string);
+    bind_builtin_variable (v.name, v.value, v.protect, v.eternal,
+			   v.sv_function, v.help_string);
 }
 
 void
-install_builtin_variable_as_function (const char *name, tree_constant *val,
+install_builtin_variable_as_function (const string& name, tree_constant *val,
 				      int protect, int eternal,
-				      const char *help)
+				      const string& help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, 1);
   sym_rec->unprotect ();
 
-  const char *tmp_help = help;
-  if (! help)
-    tmp_help = sym_rec->help ();
+  string tmp_help = help.empty () ? sym_rec->help () : help;
 
   sym_rec->define_as_fcn (val);
 
   sym_rec->document (tmp_help);
 
   if (protect)
     sym_rec->protect ();
 
   if (eternal)
     sym_rec->make_eternal ();
 }
 
 void
-alias_builtin (const char *alias, const char *name)
+alias_builtin (const string& alias, const string& name)
 {
   symbol_record *sr_name = global_sym_tab->lookup (name, 0, 0);
+
   if (! sr_name)
     panic ("can't alias to undefined name!");
 
   symbol_record *sr_alias = global_sym_tab->lookup (alias, 1, 0);
 
   if (sr_alias)
     sr_alias->alias (sr_name);
   else
-    panic ("can't find symbol record for builtin function `%s'", alias);
+    panic ("can't find symbol record for builtin function `%s'",
+	   alias.c_str ());
 }
 
 // Defining variables.
 
 #if 0
 void
 bind_nargin_and_nargout (symbol_table *sym_tab, int nargin, int nargout)
 {
@@ -1566,19 +1503,19 @@ clear_global_error_variable (void *)
 
 // Give a global variable a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_variable?  Are both
 // functions needed?
 
 void
-bind_builtin_variable (const char *varname, tree_constant *val,
+bind_builtin_variable (const string& varname, tree_constant *val,
 		       int protect, int eternal, sv_Function sv_fcn,
-		       const char *help)
+		       const string& help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
   assert (sr);
 
@@ -1594,24 +1531,23 @@ bind_builtin_variable (const char *varna
   sr->define_builtin_var (val);
 
   if (protect)
     sr->protect ();
 
   if (eternal)
     sr->make_eternal ();
 
-  if (help)
-    sr->document (help);
+  sr->document (help);
 }
 
 void
-bind_builtin_variable (const char *varname, const tree_constant& val,
+bind_builtin_variable (const string& varname, const tree_constant& val,
 		       int protect, int eternal, sv_Function sv_fcn,
-		       const char *help)
+		       const string& help)
 {
   tree_constant *tc = new tree_constant (val);
   bind_builtin_variable (varname, tc, protect, eternal, sv_fcn, help);
 }
 
 void
 install_builtin_variables (void)
 {
@@ -1924,121 +1860,113 @@ Clear symbol(s) matching a list of globb
 \n\
 If no arguments are given, clear all user-defined variables and
 functions.\n\
 \n\
 With -x, exclude the named variables")
 {
   Octave_object retval;
 
-  DEFINE_ARGV("clear");
+  int argc = args.length () + 1;
 
-  argc--;
-  argv++;
+  string_vector argv = make_argv (args, "clear");
+
+  if (error_state)
+    return retval;
 
   // Always clear the local table, but don't clear currently compiled
   // functions unless we are at the top level.  (Allowing that to
   // happen inside functions would result in pretty odd behavior...)
 
   int clear_user_functions = (curr_sym_tab == top_level_sym_tab);
 
-  if (argc == 0)
+  if (argc == 1)
     {
       curr_sym_tab->clear ();
       global_sym_tab->clear (clear_user_functions);
     }
   else
     {
       int exclusive = 0;
 
-      if (argc > 0)
+      int idx = 1;
+
+      if (argc > 1)
 	{
-	  if (strcmp (*argv, "-x") == 0)
-	    {
-	      exclusive = 1;
-	      argv++;
-	      argc--;
-	    }
+	  if (argv[idx] == "-x")
+	    exclusive = 1;
 	}
 
       int lcount = 0;
       int gcount = 0;
       int fcount = 0;
 
-      char **lvars = 0;
-      char **gvars = 0;
-      char **fcns = 0;
+      string_vector lvars;
+      string_vector gvars;
+      string_vector fcns;
 
       if (argc > 0)
 	{
 	  lvars = curr_sym_tab->list (lcount, 0, 0, 0,
 				      SYMTAB_VARIABLES,
 				      SYMTAB_LOCAL_SCOPE);
 
 	  gvars = curr_sym_tab->list (gcount, 0, 0, 0,
 				      SYMTAB_VARIABLES,
 				      SYMTAB_GLOBAL_SCOPE);
 
 	  fcns = global_sym_tab->list (fcount, 0, 0, 0,
 				       symbol_def::USER_FUNCTION,
 				       SYMTAB_ALL_SCOPES);
 	}
 
-      while (argc > 0)
+      for (int k = idx + 1; k < argc; k++)
 	{
-	  char *pat = *argv;
+	  string patstr = argv[k];
 
-	  if (pat)
+	  if (! patstr.empty ())
 	    {
+	      const char *pat = patstr.c_str ();
+
 	      int i;
 	      for (i = 0; i < lcount; i++)
 		{
-		  char *nm = lvars[i];
-		  int match = (fnmatch (pat, nm, __FNM_FLAGS) == 0);
+		  string nm = lvars[i];
+		  int match = (fnmatch (pat, nm.c_str (), __FNM_FLAGS) == 0);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    curr_sym_tab->clear (nm);
 		}
 
 	      int count;
 	      for (i = 0; i < gcount; i++)
 		{
-		  char *nm = gvars[i];
-		  int match = (fnmatch (pat, nm, __FNM_FLAGS) == 0);
+		  string nm = gvars[i];
+		  int match = (fnmatch (pat, nm.c_str (), __FNM_FLAGS) == 0);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    {
 		      count = curr_sym_tab->clear (nm);
 		      if (count > 0)
 			global_sym_tab->clear (nm, clear_user_functions);
 		    }
 		}
 
 	      for (i = 0; i < fcount; i++)
 		{
-		  char *nm = fcns[i];
-		  int match = (fnmatch (pat, nm, __FNM_FLAGS) == 0);
+		  string nm = fcns[i];
+		  int match = (fnmatch (pat, nm.c_str (), __FNM_FLAGS) == 0);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    {
 		      count = curr_sym_tab->clear (nm);
 		      global_sym_tab->clear (nm, clear_user_functions);
 		    }
 		}
 	    }
-
-	  argc--;
-	  argv++;
 	}
-
-      delete [] lvars;
-      delete [] gvars;
-      delete [] fcns;
-
     }
 
-  DELETE_ARGV;
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -25,119 +25,130 @@ Software Foundation, 59 Temple Place - S
 #define octave_variables_h 1
 
 class symbol_record;
 class symbol_table;
 
 class tree_fvc;
 class tree_constant;
 class Octave_object;
+class string_vector;
+
+#include <string>
 
 struct builtin_mapper_function;
 
 typedef int (*sv_Function)(void);
 
 struct builtin_variable
 {
-  char *name;
+  builtin_variable (const string& n, tree_constant *v, int iaf, int p,
+		    int e, sv_Function svf, const string& h)
+    : name (n), value (v), install_as_function (iaf), protect (p),
+      eternal (e), sv_function (svf), help_string (h) { }
+
+  string name;
   tree_constant *value;
   int install_as_function;
   int protect;
   int eternal;
   sv_Function sv_function;
-  char *help_string;
+  string help_string;
 };
 
 typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
 
 struct builtin_function
 {
-  char *name;
+  builtin_function (const string& n, int itf, Octave_builtin_fcn f,
+		    const string& h)
+    : name (n), is_text_fcn (itf), fcn (f), help_string (h) { }
+
+  string name;
   int is_text_fcn;
   Octave_builtin_fcn fcn;
-  char *help_string;
+  string help_string;
 };
 
 extern void initialize_symbol_tables (void);
 
 extern int lookup (symbol_record *s, int exec_script = 1);
 
-extern symbol_record *lookup_by_name (const char *nm, int exec_script = 1);
+extern symbol_record *lookup_by_name (const string& nm, int exec_script = 1);
 
-extern char *get_help_from_file (const char *f);
+extern string get_help_from_file (const string& f);
 
-extern char *builtin_string_variable (const char *);
-extern int builtin_real_scalar_variable (const char *, double&);
-extern tree_constant builtin_any_variable (const char *);
+extern string builtin_string_variable (const string&);
+extern int builtin_real_scalar_variable (const string&, double&);
+extern tree_constant builtin_any_variable (const string&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
-extern void force_link_to_function (const char *s);
+extern void force_link_to_function (const string&);
 
-extern int is_builtin_variable (const char *name);
-extern int is_text_function_name (const char *name);
-extern int is_globally_visible (const char *name);
+extern int is_builtin_variable (const string&);
+extern int is_text_function_name (const string&);
+extern int is_globally_visible (const string&);
 
-extern tree_fvc *is_valid_function (const tree_constant&, char *,
+extern tree_fvc *is_valid_function (const tree_constant&, const string&,
 				    int warn = 0); 
 
-extern char **make_name_list (void);
-
-extern void install_builtin_mapper (builtin_mapper_function *mf);
+extern string_vector make_name_list (void);
 
-extern void install_builtin_function (builtin_function *gf);
+extern void install_builtin_mapper (const builtin_mapper_function& mf);
 
-extern void install_builtin_variable (builtin_variable *v);
+extern void install_builtin_function (const builtin_function& gf);
 
-extern void install_builtin_variable_as_function (const char *name,
-						  tree_constant *val,
-						  int protect = 0,
-						  int eternal = 0,
-						  const char *help = 0);
+extern void install_builtin_variable (const builtin_variable& v);
 
-extern void alias_builtin (const char *alias, const char *name);
+extern void
+install_builtin_variable_as_function
+  (const string& name, tree_constant *val, int protect = 0,
+   int eternal = 0, const string& help = string ());
+
+extern void alias_builtin (const string& alias, const string& name);
 
 #if 0
 extern void bind_nargin_and_nargout (symbol_table *sym_tab,
 				     int nargin, int nargout);
 #endif
 
 extern void bind_ans (const tree_constant& val, int print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
-extern void bind_builtin_variable (const char *, tree_constant *,
+extern void bind_builtin_variable (const string&, tree_constant *,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
-				   const char *help = 0);
+				   const string& help = string ());
 
-extern void bind_builtin_variable (const char *, const tree_constant&,
+extern void bind_builtin_variable (const string&, const tree_constant&,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
-				   const char *help = 0);
+				   const string& help = string ());
 
 extern void install_builtin_variables (void);
 
-extern char *maybe_add_default_load_path (const char *p);
+extern string maybe_add_default_load_path (const string& p);
 
-extern char *octave_lib_dir (void);
-extern char *octave_arch_lib_dir (void);
-extern char *octave_fcn_file_dir (void);
-extern char *octave_bin_dir (void);
-extern char *default_exec_path (void);
-extern char *default_path (void);
-extern char *default_info_file (void);
-extern char *default_info_prog (void);
-extern char *default_editor (void);
-extern char *get_local_site_defaults (void);
-extern char *get_site_defaults (void);
+extern string octave_lib_dir (void);
+extern string octave_arch_lib_dir (void);
+extern string octave_fcn_file_dir (void);
+extern string octave_bin_dir (void);
+extern string default_exec_path (void);
+extern string default_path (void);
+extern string default_info_file (void);
+extern string default_info_prog (void);
+extern string default_editor (void);
+extern string get_local_site_defaults (void);
+extern string get_site_defaults (void);
 
 // Symbol table for symbols at the top level.
 extern symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 extern symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
