# HG changeset patch
# User Rik <rik@octave.org>
# Date 1402275599 25200
#      Sun Jun 08 17:59:59 2014 -0700
# Node ID 9ac2357f19bcf9076529903be61d1eff610b9b41
# Parent  c53e11fab75f1e67926dba9d41233951fdfbb3d2
doc: Replace "non-zero" with "nonzero" to match existing usage.
Replace all occurrences in both documentation and code comments.
* doc/interpreter/contrib.txi, doc/interpreter/diagperm.txi,
doc/interpreter/external.txi, doc/interpreter/sparse.txi,
doc/interpreter/stmt.txi, doc/interpreter/testfun.txi, doc/refcard/refcard.tex,
examples/mysparse.c, libinterp/corefcn/balance.cc,
libinterp/corefcn/cellfun.cc, libinterp/corefcn/data.cc,
libinterp/corefcn/filter.cc, libinterp/corefcn/find.cc,
libinterp/corefcn/kron.cc, libinterp/corefcn/ls-mat5.cc,
libinterp/corefcn/luinc.cc, libinterp/corefcn/mappers.cc,
libinterp/corefcn/oct-fstrm.cc, libinterp/corefcn/oct-fstrm.h,
libinterp/corefcn/oct-iostrm.cc, libinterp/corefcn/oct-iostrm.h,
libinterp/corefcn/oct-stdstrm.h, libinterp/corefcn/oct-strstrm.h,
libinterp/corefcn/spparms.cc, libinterp/corefcn/toplev.cc,
libinterp/corefcn/utils.cc, libinterp/dldfcn/symrcm.cc,
libinterp/octave-value/ov-bool-mat.cc, liboctave/array/CSparse.cc,
liboctave/array/Sparse.cc, liboctave/array/Sparse.h,
liboctave/array/dSparse.cc, liboctave/numeric/randmtzig.c,
liboctave/operators/Sparse-op-defs.h, scripts/help/get_first_help_sentence.m,
scripts/miscellaneous/edit.m, scripts/plot/draw/pie.m,
scripts/plot/draw/pie3.m, scripts/sparse/colperm.m, scripts/sparse/nonzeros.m,
scripts/sparse/spdiags.m, scripts/sparse/spfun.m, scripts/sparse/spones.m,
scripts/sparse/sprand.m, scripts/sparse/sprandn.m, scripts/sparse/sprandsym.m,
scripts/sparse/spstats.m, scripts/sparse/svds.m,
scripts/special-matrix/gallery.m, scripts/statistics/base/moment.m,
scripts/statistics/tests/cor_test.m:
Replace "non-zero" with "nonzero" to match existing usage.

diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -279,18 +279,20 @@ like this:
 @example
   x = max (sin (y+3), 2);
 @end example
 
 @noindent
 An exception are matrix or cell constructors:
 
 @example
+@group
   [sin(x), cos(x)]
   @{sin(x), cos(x)@}
+@end group
 @end example
 
 @noindent
 Here, putting spaces after @code{sin}, @code{cos} would result in a
 parse error.  For an indexing expression, do not put a space after the
 identifier (this differentiates indexing and function calls nicely).
 The space after a comma is not necessary if index expressions are simple,
 i.e., you may write
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -484,31 +484,28 @@ with Tikhonov regularization (ridge regr
 @node Zeros Treatment
 @section Differences in Treatment of Zero Elements
 @cindex matrix, zero elements
 
 Making diagonal and permutation matrices special matrix objects in their own
 right and the consequent usage of smarter algorithms for certain operations
 implies, as a side effect, small differences in treating zeros.
 The contents of this section apply also to sparse matrices, discussed in
-the following chapter. (@pxref{Sparse Matrices})
+the following chapter.  (@pxref{Sparse Matrices})
 
-The IEEE floating point standard defines the result of the expressions @code{0*Inf} and 
-@code{0*NaN} as @code{NaN}. This is widely agreed to be a good
-compromise.
-Numerical software dealing with structured and sparse matrices (including
-Octave) however, almost always makes a distinction between a "numerical zero"
-and an "assumed zero". 
-A "numerical zero" is a zero value occurring in a place where any floating-point
-value could occur.  It is normally stored somewhere in memory as an explicit
-value. 
-An "assumed zero", on the contrary, is a zero matrix element implied by the
-matrix structure (diagonal, triangular) or a sparsity pattern; its value is
-usually not stored explicitly anywhere, but is implied by the underlying
-data structure.
+The IEEE floating point standard defines the result of the expressions
+@code{0*Inf} and @code{0*NaN} as @code{NaN}.  This is widely agreed to be a
+good compromise.  Numerical software dealing with structured and sparse matrices
+(including Octave) however, almost always makes a distinction between a
+"numerical zero" and an "assumed zero".  A "numerical zero" is a zero value
+occurring in a place where any floating-point value could occur.  It is
+normally stored somewhere in memory as an explicit value.  An "assumed zero", on
+the contrary, is a zero matrix element implied by the matrix structure
+(diagonal, triangular) or a sparsity pattern; its value is usually not stored
+explicitly anywhere, but is implied by the underlying data structure.
 
 The primary distinction is that an assumed zero, when multiplied 
 by any number, or divided by any nonzero number,
 yields *always* a zero, even when, e.g., multiplied by @code{Inf}
 or divided by @code{NaN}.
 The reason for this behavior is that the numerical multiplication is not
 actually performed anywhere by the underlying algorithm; the result is
 just assumed to be zero.  Equivalently, one can say that the part of the
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -584,34 +584,34 @@ more similar to Octave's @code{Matrix} c
 * Creating Sparse Matrices in Oct-Files::
 * Using Sparse Matrices in Oct-Files::
 @end menu
 
 @node Array and Sparse Class Differences
 @subsubsection Array and Sparse Class Differences
 
 The number of elements in a sparse matrix is considered to be the number
-of non-zero elements rather than the product of the dimensions.  Therefore
+of nonzero elements rather than the product of the dimensions.  Therefore
 
 @example
 @group
 SparseMatrix sm;
 @dots{}
 int nel = sm.nelem ();
 @end group
 @end example
 
 @noindent
-returns the number of non-zero elements.  If the user really requires the
-number of elements in the matrix, including the non-zero elements, they
+returns the number of nonzero elements.  If the user really requires the
+number of elements in the matrix, including the nonzero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
 large matrices, where the product of the two dimensions is larger than
 the representation of an unsigned int, then @code{numel} can overflow.
 An example is @code{speye (1e6)} which will create a matrix with a million
-rows and columns, but only a million non-zero elements.  Therefore the
+rows and columns, but only a million nonzero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
 Extreme care must be take with the elem method and the @qcode{"()"} operator,
 which perform basically the same function.  The reason is that if a
 sparse object is non-const, then Octave will assume that a
@@ -702,17 +702,17 @@ passed by the user need not respect this
 data will significantly speed up creation of the sparse matrix.
 
 The disadvantage of this technique for creating a sparse matrix is
 that there is a brief time when two copies of the data exist.  For
 extremely memory constrained problems this may not be the best
 technique for creating a sparse matrix.
 
 The alternative is to first create a sparse matrix with the desired
-number of non-zero elements and then later fill those elements in.
+number of nonzero elements and then later fill those elements in.
 Sample code:
 
 @example
 @group
 int nz, nr, nc;
 nz = 4, nr = 3, nc = 4;
 SparseMatrix sm (nr, nc, nz);
 sm(0,0) = 1; sm(0,1) = 2; sm(1,3) = 3; sm(2,3) = 4;
@@ -743,17 +743,17 @@ sm(0,0) = 1; sm(0,1) = 2; sm(1,3) = 3; s
 is perfectly valid.  However, it is a very bad idea because as each new
 element is added to the sparse matrix the matrix needs to request more
 space and reallocate memory.  This is an expensive operation, that will
 significantly slow this means of creating a sparse matrix.  Furthermore,
 it is possible to create a sparse matrix with too much storage, so having
 @var{nz} greater than 4 is also valid.  The disadvantage is that the matrix
 occupies more memory than strictly needed.
 
-It is not always possible to know the number of non-zero elements prior
+It is not always possible to know the number of nonzero elements prior
 to filling a matrix.  For this reason the additional unused storage of 
 a sparse matrix can be removed after its creation with the
 @code{maybe_compress} function.  In addition, @code{maybe_compress} can
 deallocate the unused storage, but it can also remove zero elements
 from the matrix.  The removal of zero elements from the matrix is
 controlled by setting the argument of the @code{maybe_compress} function
 to be @code{true}.  However, the cost of removing the zeros is high because it
 implies re-sorting the elements.  If possible, it is better
@@ -845,17 +845,17 @@ for (int j = 1; j < nc; j++)
             ii++;
           @}
       @}
     sm.cidx(j+1) = ii;
  @}
 sm.maybe_mutate ();  // If don't know a priori the final # of nz.
 @end example
 
-Note that both increasing and decreasing the number of non-zero elements in
+Note that both increasing and decreasing the number of nonzero elements in
 a sparse matrix is expensive as it involves memory reallocation.  Also as
 parts of the matrix, though not its entirety, exist as old and new copies
 at the same time, additional memory is needed.  Therefore, if possible this
 should be avoided.
 
 @node Using Sparse Matrices in Oct-Files
 @subsubsection Using Sparse Matrices in Oct-Files
 
@@ -1602,16 +1602,17 @@ found in the file @file{mystruct.c} show
 
 @example
 @EXAMPLEFILE(mystruct.c)
 @end example
 
 An example of the behavior of this function within Octave is then
 
 @example
+@group
 a(1).f1 = "f11"; a(1).f2 = "f12"; 
 a(2).f1 = "f21"; a(2).f2 = "f22";
 b = mystruct (a);
 @result{}  field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
 b
@@ -1620,16 +1621,17 @@ b
      this
      that
 
 b(3)
 @result{} scalar structure containing the fields:
 
      this = this3
      that = that3
+@end group
 @end example
 
 @node Sparse Matrices with Mex-Files
 @subsection Sparse Matrices with Mex-Files
 
 The Octave format for sparse matrices is identical to the mex format in
 that it is a compressed column sparse format.  Also in both, sparse
 matrices are required to be two-dimensional.  The only difference is that
@@ -1648,56 +1650,56 @@ mwSize mxGetNzmax (const mxArray *ptr);
 void mxSetIr (mxArray *ptr, mwIndex *ir);
 void mxSetJc (mxArray *ptr, mwIndex *jc);
 void mxSetNzmax (mxArray *ptr, mwSize nzmax);
 @end group
 @end example
 
 @noindent
 @code{mxGetNzmax} gets the maximum number of elements that can be stored
-in the sparse matrix.  This is not necessarily the number of non-zero
+in the sparse matrix.  This is not necessarily the number of nonzero
 elements in the sparse matrix.  @code{mxGetJc} returns an array with one
 additional value than the number of columns in the sparse matrix.  The
 difference between consecutive values of the array returned by
-@code{mxGetJc} define the number of non-zero elements in each column of
+@code{mxGetJc} define the number of nonzero elements in each column of
 the sparse matrix.  Therefore,
 
 @example
 @group
 mwSize nz, n;
 mwIndex *Jc;
 mxArray *m;
 @dots{}
 n = mxGetN (m);
 Jc = mxGetJc (m);
 nz = Jc[n];
 @end group
 @end example
 
 @noindent
-returns the actual number of non-zero elements stored in the matrix in
+returns the actual number of nonzero elements stored in the matrix in
 @code{nz}.  As the arrays returned by @code{mxGetPr} and @code{mxGetPi}
-only contain the non-zero values of the matrix, we also need a pointer
-to the rows of the non-zero elements, and this is given by
+only contain the nonzero values of the matrix, we also need a pointer
+to the rows of the nonzero elements, and this is given by
 @code{mxGetIr}.  A complete example of the use of sparse matrices in
 mex-files is given by the file @file{mysparse.c} shown below.
 
 @example
 @EXAMPLEFILE(mysparse.c)
 @end example
 
 A sample usage of @code{mysparse} is
 
 @example
 @group
 sm = sparse ([1, 0; 0, pi]);
 mysparse (sm)
 @result{}
 Matrix is 2-by-2 real sparse matrix with 2 elements
-last non-zero element (2, 2) = 3.14159
+last nonzero element (2, 2) = 3.14159
 @end group
 @end example
 
 @node Calling Other Functions in Mex-Files
 @subsection Calling Other Functions in Mex-Files
 
 It is possible to call other Octave functions from within a mex-file
 using @code{mexCallMATLAB}.  An example of the use of @code{mexCallMATLAB}
@@ -1785,18 +1787,18 @@ a C++ standalone program, then it does n
 interpreter to do so.  The general rule is that, for a built-in 
 function named @code{function_name} in the interpreter, there will be
 a C++ function named @code{Ffunction_name} (note the prepended capital 
 @code{F}) accessible in the C++ API@.  The declarations for all built-in 
 functions are collected in the header file @code{builtin-defun-decls.h}.
 This feature should be used with care as the list of built-in functions can
 change.  No guarantees can be made that a function that is currently built in
 won't be implemented as a .m file or as a dynamically linked function in the
-future.  An example of how to call built-in functions from C++ can be seen in the
-code
+future.  An example of how to call built-in functions from C++ can be seen in
+the code
 
 @example
 @EXAMPLEFILE(standalonebuiltin.cc)
 @end example
 
 @noindent
 which, again, is compiled and run as a standalone application with
 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -39,23 +39,23 @@
 The size of mathematical problems that can be treated at any particular
 time is generally limited by the available computing resources.  Both,
 the speed of the computer and its available memory place limitation on
 the problem size. 
 
 There are many classes of mathematical problems which give rise to
 matrices, where a large number of the elements are zero.  In this case
 it makes sense to have a special matrix type to handle this class of
-problems where only the non-zero elements of the matrix are
+problems where only the nonzero elements of the matrix are
 stored.  Not only does this reduce the amount of memory to store the
 matrix, but it also means that operations on this type of matrix can
 take advantage of the a priori knowledge of the positions of the
-non-zero elements to accelerate their calculations.
+nonzero elements to accelerate their calculations.
 
-A matrix type that stores only the non-zero elements is generally called
+A matrix type that stores only the nonzero elements is generally called
 sparse.  It is the purpose of this document to discuss the basics of the
 storage and creation of sparse matrices and the fundamental operations
 on them.
 
 @menu
 * Storage of Sparse Matrices::
 * Creating Sparse Matrices::
 * Information::
@@ -76,61 +76,61 @@ of the methods have in common is that th
 and storage given a priori knowledge of the particular class of problems
 that will be solved.  A good summary of the available techniques for storing
 sparse matrix is given by Saad @footnote{Y. Saad "SPARSKIT: A basic toolkit
 for sparse matrix computation", 1994,
 @url{http://www-users.cs.umn.edu/~saad/software/SPARSKIT/paper.ps}}.
 With full matrices, knowledge of the point of an element of the matrix
 within the matrix is implied by its position in the computers memory. 
 However, this is not the case for sparse matrices, and so the positions
-of the non-zero elements of the matrix must equally be stored. 
+of the nonzero elements of the matrix must equally be stored. 
 
 An obvious way to do this is by storing the elements of the matrix as
 triplets, with two elements being their position in the array 
 (rows and column) and the third being the data itself.  This is conceptually
 easy to grasp, but requires more storage than is strictly needed.
 
 The storage technique used within Octave is the compressed column
 format.  It is similar to the Yale format.
 @footnote{@url{http://en.wikipedia.org/wiki/Sparse_matrix#Yale_format}}
 In this format the position of each element in a row and the data are
 stored as previously.  However, if we assume that all elements in the
 same column are stored adjacent in the computers memory, then we only
-need to store information on the number of non-zero elements in each
+need to store information on the number of nonzero elements in each
 column, rather than their positions.  Thus assuming that the matrix has
-more non-zero elements than there are columns in the matrix, we win in
+more nonzero elements than there are columns in the matrix, we win in
 terms of the amount of memory used.
 
 In fact, the column index contains one more element than the number of
 columns, with the first element always being zero.  The advantage of
 this is a simplification in the code, in that there is no special case
 for the first or last columns.  A short example, demonstrating this in
 C is.
 
 @example
 @group
   for (j = 0; j < nc; j++)
     for (i = cidx(j); i < cidx(j+1); i++)
-       printf ("non-zero element (%i,%i) is %d\n", 
+       printf ("nonzero element (%i,%i) is %d\n", 
            ridx(i), j, data(i));
 @end group
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix.  Consider the matrix
 
 @example
 @group
     1   2   0  0
     0   0   0  3
     0   0   0  4
 @end group
 @end example
 
-The non-zero elements of this matrix are
+The nonzero elements of this matrix are
 
 @example
 @group
    (1, 1)  @result{} 1
    (1, 2)  @result{} 2
    (2, 4)  @result{} 3
    (3, 4)  @result{} 4
 @end group
@@ -314,17 +314,17 @@ for a full description of the techniques
 @subsection Finding Information about Sparse Matrices
 
 There are a number of functions that allow information concerning
 sparse matrices to be obtained.  The most basic of these is
 @dfn{issparse} that identifies whether a particular Octave object is
 in fact a sparse matrix.
 
 Another very basic function is @dfn{nnz} that returns the number of
-non-zero entries there are in a sparse matrix, while the function
+nonzero entries there are in a sparse matrix, while the function
 @dfn{nzmax} returns the amount of storage allocated to the sparse
 matrix.  Note that Octave tends to crop unused memory at the first
 opportunity for sparse objects.  There are some cases of user created
 sparse objects where the value returned by @dfn{nzmax} will not be
 the same as @dfn{nnz}, but in general they will give the same
 result.  The function @dfn{spstats} returns some basic statistics on
 the columns of a sparse matrix including the number of elements, the
 mean and the variance of each column.
@@ -371,31 +371,31 @@ a = matrix_type (tril (sprandn (1024, ..
 This allows the cost of determining the matrix type to be
 avoided.  However, incorrectly defining the matrix type will result in
 incorrect results from solutions of linear equations, and so it is
 entirely the responsibility of the user to correctly identify the
 matrix type
 
 There are several graphical means of finding out information about
 sparse matrices.  The first is the @dfn{spy} command, which displays
-the structure of the non-zero elements of the
+the structure of the nonzero elements of the
 matrix.  @xref{fig:spmatrix}, for an example of the use of
 @dfn{spy}.  More advanced graphical information can be obtained with the
 @dfn{treeplot}, @dfn{etreeplot} and @dfn{gplot} commands.
 
 @float Figure,fig:spmatrix
 @center @image{spmatrix,4in}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 One use of sparse matrices is in graph theory, where the
 interconnections between nodes are represented as an adjacency
 matrix.  That is, if the i-th node in a graph is connected to the j-th
 node.  Then the ij-th node (and in the case of undirected graphs the
-@nospell{ji-th} node) of the sparse adjacency matrix is non-zero.  If each node
+@nospell{ji-th} node) of the sparse adjacency matrix is nonzero.  If each node
 is then associated with a set of coordinates, then the @dfn{gplot}
 command can be used to graphically display the interconnections
 between nodes.
 
 As a trivial example of the use of @dfn{gplot} consider the example,
 
 @example
 @group
@@ -504,19 +504,19 @@ supplied with these functions within Oct
 details.
 
 @node Return Types of Operators and Functions
 @subsubsection Return Types of Operators and Functions
 
 The two basic reasons to use sparse matrices are to reduce the memory 
 usage and to not have to do calculations on zero elements.  The two are
 closely related in that the computation time on a sparse matrix operator
-or function is roughly linear with the number of non-zero elements.
+or function is roughly linear with the number of nonzero elements.
 
-Therefore, there is a certain density of non-zero elements of a matrix 
+Therefore, there is a certain density of nonzero elements of a matrix 
 where it no longer makes sense to store it as a sparse matrix, but rather
 as a full matrix.  For this reason operators and functions that have a 
 high probability of returning a full matrix will always return one.  For
 example adding a scalar constant to a sparse matrix will almost always
 make it a full matrix, and so the example,
 
 @example
 @group
@@ -625,17 +625,17 @@ stored.  In certain cases the sign-bit o
  
 To correct this behavior would mean that zero elements with a negative
 sign-bit would need to be stored in the matrix to ensure that their 
 sign-bit was respected.  This is not done at this time, for reasons of
 efficiency, and so the user is warned that calculations where the sign-bit
 of zero is important must not be done using sparse matrices.
 
 In general any function or operator used on a sparse matrix will
-result in a sparse matrix with the same or a larger number of non-zero
+result in a sparse matrix with the same or a larger number of nonzero
 elements than the original matrix.  This is particularly true for the
 important case of sparse matrix factorizations.  The usual way to
 address this is to reorder the matrix, such that its factorization is
 sparser than the factorization of the original matrix.  That is the
 factorization of @code{L * U = P * S * Q} has sparser terms @code{L}
 and @code{U} than the equivalent factorization @code{L * U = S}.
 
 Several functions are available to reorder depending on the type of the
@@ -662,17 +662,17 @@ The original matrix had
 @ifinfo
 @ifnothtml
 43
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 598
 @end ifset
-non-zero terms, while this Cholesky@tie{}factorization has
+nonzero terms, while this Cholesky@tie{}factorization has
 @ifinfo
 @ifnothtml
 71,
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 10200,
 @end ifset
@@ -688,17 +688,17 @@ r = chol (A(q,q)); spy (r)}.  This gives
 @ifinfo
 @ifnothtml
 29
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 399
 @end ifset
-non-zero terms which is a significant improvement.
+nonzero terms which is a significant improvement.
 
 The Cholesky@tie{}factorization itself can be used to determine the
 appropriate sparsity preserving reordering of the matrix during the
 factorization, In that case this might be obtained with three return
 arguments as @code{[r, p, q] = chol (A); spy (r)}.
 
 @float Figure,fig:simplechol
 @center @image{spchol,4in}
@@ -793,17 +793,17 @@ using @sc{umfpack}.
 
 @item If the matrix is not square, or any of the previous solvers flags
 a singular or near singular matrix, find a minimum norm solution using
 @sc{cxsparse}@footnote{The @sc{cholmod}, @sc{umfpack} and @sc{cxsparse}
 packages were written by Tim Davis and are available at
 @url{http://www.cise.ufl.edu/research/sparse/}}.
 @end enumerate
 
-The band density is defined as the number of non-zero values in the band
+The band density is defined as the number of nonzero values in the band
 divided by the total number of values in the full band.  The banded
 matrix solvers can be entirely disabled by using @dfn{spparms} to set
 @code{bandden} to 1 (i.e., @code{spparms ("bandden", 1)}).
 
 The QR@tie{}solver factorizes the problem with a Dulmage-Mendelsohn
 decomposition, to separate the problem into blocks that can be treated
 as over-determined, multiple well determined blocks, and a final
 over-determined block.  For matrices with blocks of strongly connected
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -78,20 +78,20 @@ endif
 @end example
 
 @noindent
 @var{condition} is an expression that controls what the rest of the
 statement will do.  The @var{then-body} is executed only if
 @var{condition} is true.
 
 The condition in an @code{if} statement is considered true if its value
-is non-zero, and false if its value is zero.  If the value of the
+is nonzero, and false if its value is zero.  If the value of the
 conditional expression in an @code{if} statement is a vector or a
 matrix, it is considered true only if it is non-empty and @emph{all}
-of the elements are non-zero.
+of the elements are nonzero.
 
 The second form of an if statement looks like this:
 
 @example
 @group
 if (@var{condition})
   @var{then-body}
 else
@@ -393,20 +393,20 @@ switch (foo)
 @cindex body of a loop
 
 In programming, a @dfn{loop} means a part of a program that is (or at least can
 be) executed two or more times in succession.
 
 The @code{while} statement is the simplest looping statement in Octave.
 It repeatedly executes a statement as long as a condition is true.  As
 with the condition in an @code{if} statement, the condition in a
-@code{while} statement is considered true if its value is non-zero, and
+@code{while} statement is considered true if its value is nonzero, and
 false if its value is zero.  If the value of the conditional expression
 in a @code{while} statement is a vector or a matrix, it is considered
-true only if it is non-empty and @emph{all} of the elements are non-zero.
+true only if it is non-empty and @emph{all} of the elements are nonzero.
 
 Octave's @code{while} statement looks like this:
 
 @example
 @group
 while (@var{condition})
   @var{body}
 endwhile
@@ -458,20 +458,20 @@ simple.
 @section The do-until Statement
 @cindex @code{do-until} statement
 
 The @code{do-until} statement is similar to the @code{while} statement,
 except that it repeatedly executes a statement until a condition becomes
 true, and the test of the condition is at the end of the loop, so the
 body of the loop is always executed at least once.  As with the
 condition in an @code{if} statement, the condition in a @code{do-until}
-statement is considered true if its value is non-zero, and false if its
+statement is considered true if its value is nonzero, and false if its
 value is zero.  If the value of the conditional expression in a
 @code{do-until} statement is a vector or a matrix, it is considered 
-true only if it is non-empty and @emph{all} of the elements are non-zero.
+true only if it is non-empty and @emph{all} of the elements are nonzero.
 
 Octave's @code{do-until} statement looks like this:
 
 @example
 @group
 do
   @var{body}
 until (@var{condition})
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -292,40 +292,40 @@ in the log file but not executed.  For e
 @noindent
 The following trivial code snippet provides examples for the use of
 fail, assert, error and xtest:
 
 @example
 @group
 function output = must_be_zero (@var{input})
   if (@var{input} != 0)
-    error ("Non-zero input!")
+    error ("Nonzero input!")
   endif
   output = input;
 endfunction
 
 %!fail ("must_be_zero (1)");
 %!assert (must_be_zero (0), 0);
-%!error <Non-zero> must_be_zero (1);
+%!error <Nonzero> must_be_zero (1);
 %!xtest error ("This code generates an error");
 @end group
 @end example
 
 @noindent
 When putting this a file @file{must_be_zero.m}, and running the test, we see
 
 @example
 @group
 test must_be_zero verbose
 
 @result{}
 >>>>> /path/to/must_be_zero.m
   ***** fail ("must_be_zero (1)");
   ***** assert (must_be_zero (0), 0);
-  ***** error <Non-zero> must_be_zero (1);
+  ***** error <Nonzero> must_be_zero (1);
   ***** xtest error ("This code generates an error");
 !!!!! known failure
 This code generates an error
 PASSES 4 out of 4 tests (1 expected failures)
 @end group
 @end example
 
 @subsubheading Block type summary:
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -531,17 +531,17 @@ shiftdim ({\it arr}, {\it s})&rotate the
 circshift ({\it arr}, {\it s})&rotate the array elements.\cr
 \endsec
 
 \sec Sparse Matrices;
 sparse (...)&create a sparse matrix.\cr
 speye ({\it n)}&create sparse identity matrix.\cr
 sprand ({\it n}, {\it m}, {\it d})&sparse rand matrix of density {\it d}.\cr
 spdiags (...)&sparse generalization of {\it diag}.\cr
-nnz ({\it s})&No. non-zero elements in sparse matrix.\cr
+nnz ({\it s})&No. nonzero elements in sparse matrix.\cr
 \endsec
 
 \sec Ranges;
 {\it base} : {\it limit}\cr
 {\it base} : {\it incr} : {\it limit}\cr
 \omit\hfill\vbox{\hsize=\idnwid\rm\vskip0.75ex
   Specify a range of values beginning with {\it base\/} with no elements
   greater than {\it limit}.  If it is omitted, the default value of
diff --git a/examples/mysparse.c b/examples/mysparse.c
--- a/examples/mysparse.c
+++ b/examples/mysparse.c
@@ -27,17 +27,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       pr = mxGetPr (prhs[0]);
       pi = mxGetPi (prhs[0]);
       ir = mxGetIr (prhs[0]);
       jc = mxGetJc (prhs[0]);
 
       i = n;
       while (jc[i] == jc[i-1] && i != 0) i--;
 
-      mexPrintf ("last non-zero element (%d, %d) = (%g, %g)\n",
+      mexPrintf ("last nonzero element (%d, %d) = (%g, %g)\n",
                  ir[nz-1]+ 1, i, pr[nz-1], pi[nz-1]);
 
       v = mxCreateSparse (m, n, nz, mxCOMPLEX);
       pr2 = mxGetPr (v);
       pi2 = mxGetPi (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
 
@@ -60,17 +60,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       mexPrintf (" with %d elements\n", nz);
 
       pbr = mxGetLogicals (prhs[0]);
       ir = mxGetIr (prhs[0]);
       jc = mxGetJc (prhs[0]);
 
       i = n;
       while (jc[i] == jc[i-1] && i != 0) i--;
-      mexPrintf ("last non-zero element (%d, %d) = %d\n",
+      mexPrintf ("last nonzero element (%d, %d) = %d\n",
                  ir[nz-1]+ 1, i, pbr[nz-1]);
 
       v = mxCreateSparseLogicalMatrix (m, n, nz);
       pbr2 = mxGetLogicals (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
 
       for (i = 0; i < nz; i++)
@@ -90,17 +90,17 @@ mexFunction (int nlhs, mxArray *plhs[],
       mexPrintf (" with %d elements\n", nz);
 
       pr = mxGetPr (prhs[0]);
       ir = mxGetIr (prhs[0]);
       jc = mxGetJc (prhs[0]);
 
       i = n;
       while (jc[i] == jc[i-1] && i != 0) i--;
-      mexPrintf ("last non-zero element (%d, %d) = %g\n",
+      mexPrintf ("last nonzero element (%d, %d) = %g\n",
                  ir[nz-1]+ 1, i, pr[nz-1]);
 
       v = mxCreateSparse (m, n, nz, mxREAL);
       pr2 = mxGetPr (v);
       ir2 = mxGetIr (v);
       jc2 = mxGetJc (v);
 
       for (i = 0; i < nz; i++)
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -63,17 +63,17 @@ calculation are typically improved by ba
 \n\
 If two output values are requested, @code{balance} returns\n\
 the diagonal @var{D} and the permutation @var{P} separately as vectors.\n\
 In this case, @code{@var{DD} = eye(n)(:,@var{P}) * diag (@var{D})}, where\n\
 @math{n} is the matrix size.\n\
 \n\
 If four output values are requested, compute @code{@var{AA} =\n\
 @var{CC}*@var{A}*@var{DD}} and @code{@var{BB} = @var{CC}*@var{B}*@var{DD}},\n\
-in which @var{AA} and @var{BB} have non-zero elements of approximately the\n\
+in which @var{AA} and @var{BB} have nonzero elements of approximately the\n\
 same magnitude and @var{CC} and @var{DD} are permuted diagonal matrices as\n\
 in @var{DD} for the algebraic eigenvalue problem.\n\
 \n\
 The eigenvalue balancing option @var{opt} may be one of:\n\
 \n\
 @table @asis\n\
 @item @qcode{\"noperm\"}, @qcode{\"S\"}\n\
 Scale only; do not permute.\n\
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -314,19 +314,19 @@ number is the product of the dimensions 
 Return the size along the @var{k}-th dimension.\n\
 \n\
 @item isclass\n\
 Return 1 for elements of @var{class}.\n\
 @end table\n\
 \n\
 Additionally, @code{cellfun} accepts an arbitrary function @var{func}\n\
 in the form of an inline function, function handle, or the name of a\n\
-function (in a character string). The function can take one or more arguments,\n\
-with the inputs arguments given by @var{C}, @var{D}, etc.  Equally the\n\
-function can return one or more output arguments.  For example:\n\
+function (in a character string).  The function can take one or more\n\
+arguments, with the inputs arguments given by @var{C}, @var{D}, etc.  \n\
+Equally the function can return one or more output arguments.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"atan2\", @{1, 0@}, @{0, 1@})\n\
      @result{} [ 1.57080   0.00000 ]\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -107,21 +107,21 @@ along with Octave; see the file COPYING.
  \
   return retval
 
 DEFUN (all, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} all (@var{x})\n\
 @deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if all elements of the vector\n\
-are non-zero.\n\
+are nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether all of the elements of the\n\
-corresponding column of the matrix are non-zero.  For example:\n\
+corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 all ([2, 3; 1, 0])\n\
     @result{} [ 1, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
@@ -154,21 +154,21 @@ If the optional argument @var{dim} is su
 %!error all (1, 2, 3)
 */
 
 DEFUN (any, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} any (@var{x})\n\
 @deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if any element of the vector\n\
-is non-zero.\n\
+is nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
-corresponding column of the matrix are non-zero.  For example:\n\
+corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
  @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
@@ -1457,34 +1457,34 @@ DEFUN (prod, args, ,
 @deftypefn  {Built-in Function} {} prod (@var{x})\n\
 @deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} prod (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} prod (@dots{}, \"double\")\n\
 Product of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-The optional @qcode{\"type\"} input determines the class of the variable used for\n\
-calculations.  If the argument @qcode{\"native\"} is given, then the operation is\n\
-performed in the same type as the original argument, rather than the default double\n\
-type.\n\
+The optional @qcode{\"type\"} input determines the class of the variable\n\
+used for calculations.  If the argument @qcode{\"native\"} is given, then\n\
+the operation is performed in the same type as the original argument, rather\n\
+than the default double type.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 prod ([true, true])\n\
    @result{} 1\n\
 prod ([true, true], \"native\")\n\
    @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
-On the contrary, if @qcode{\"double\"} is given, the operation is performed in\n\
-double precision even for single precision inputs.\n\
+On the contrary, if @qcode{\"double\"} is given, the operation is performed\n\
+in double precision even for single precision inputs.\n\
 @seealso{cumprod, sum}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -2835,17 +2835,17 @@ Called with a single or no argument, siz
     }
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{n} =} nnz (@var{a})\n\
-Return the number of non-zero elements in @var{a}.\n\
+Return the number of nonzero elements in @var{a}.\n\
 @seealso{nzmax, nonzeros, find}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).nnz ();
   else
@@ -2915,39 +2915,39 @@ DEFUN (sum, args, ,
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.\n\
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-The optional @qcode{\"type\"} input determines the class of the variable used for\n\
-calculations.  If the argument @qcode{\"native\"} is given, then the operation is\n\
-performed in the same type as the original argument, rather than the default double\n\
-type.\n\
+The optional @qcode{\"type\"} input determines the class of the variable\n\
+used for calculations.  If the argument @qcode{\"native\"} is given, then\n\
+the operation is performed in the same type as the original argument, rather\n\
+than the default double type.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sum ([true, true])\n\
    @result{} 2\n\
 sum ([true, true], \"native\")\n\
    @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
 On the contrary, if @qcode{\"double\"} is given, the sum is performed in\n\
 double precision even for single precision inputs.\n\
 \n\
-For double precision inputs, the @qcode{\"extra\"} option will use a more accurate\n\
-algorithm than straightforward summation.  For single precision inputs,\n\
-@qcode{\"extra\"} is the same as @qcode{\"double\"}.  Otherwise, @qcode{\"extra\"}\n\
-has no effect.\n\
+For double precision inputs, the @qcode{\"extra\"} option will use a more\n\
+accurate algorithm than straightforward summation.  For single precision\n\
+inputs, @qcode{\"extra\"} is the same as @qcode{\"double\"}.  Otherwise,\n\
+@qcode{\"extra\"} has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -72,17 +72,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   b.resize (dim_vector (ab_len, 1), 0.0);
   if (a_len > 1)
     a.resize (dim_vector (ab_len, 1), 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T>(0.0))
     {
-      error ("filter: the first element of A must be non-zero");
+      error ("filter: the first element of A must be nonzero");
       return y;
     }
 
   dim_vector x_dims = x.dims ();
   if (dim < 0 || dim > x_dims.length ())
     {
       error ("filter: DIM must be a valid dimension");
       return y;
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -389,17 +389,17 @@ If two inputs are given, @var{n} indicat
 elements to find from the beginning of the matrix or vector.\n\
 \n\
 If three inputs are given, @var{direction} should be one of\n\
 @qcode{\"first\"} or @qcode{\"last\"}, requesting only the first or last\n\
 @var{n} indices, respectively.  However, the indices are always returned in\n\
 ascending order.\n\
 \n\
 Note that this function is particularly useful for sparse matrices, as\n\
-it extracts the non-zero elements as vectors, which can then be used to\n\
+it extracts the nonzero elements as vectors, which can then be used to\n\
 create the original matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sz = size (a);\n\
 [i, j, v] = find (a);\n\
 b = sparse (i, j, v, sz(1), sz(2));\n\
 @end group\n\
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -198,17 +198,17 @@ dispatch_kron (const octave_value& a, co
       if (b.is_diag_matrix () && a.rows () == a.columns ()
           && b.rows () == b.columns ())
         {
           // We have two diagonal matrices, the product of those will be
           // another diagonal matrix.  To do that efficiently, extract
           // the diagonals as vectors and compute the product.  That
           // will be another vector, which we then use to construct a
           // diagonal matrix object.  Note that this will fail if our
-          // digaonal matrix object is modified to allow the non-zero
+          // digaonal matrix object is modified to allow the nonzero
           // values to be stored off of the principal diagonal (i.e., if
           // diag ([1,2], 3) is modified to return a diagonal matrix
           // object instead of a full matrix object).
 
           octave_value tmp = dispatch_kron (a.diag (), b.diag ());
           retval = tmp.diag ();
         }
       else if (a.is_single_type () || b.is_single_type ())
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -646,17 +646,17 @@ read_mat5_binary_element (std::istream& 
 
   global = (flags & 0x0400) != 0; // global variable?
 
   logicalvar = (flags & 0x0200) != 0; // boolean ?
 
   arrayclass = static_cast<arrayclasstype> (flags & 0xff);
 
   int32_t tmp_nzmax;
-  read_int (is, swap, tmp_nzmax);   // max number of non-zero in sparse
+  read_int (is, swap, tmp_nzmax);   // max number of nonzero in sparse
   nzmax = tmp_nzmax;
 
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
       if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element) ||
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -44,17 +44,17 @@ DEFUN (luinc, args, nargout,
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
 Called with a second argument of @qcode{'0'}, the zero-level incomplete\n\
 LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
-where the position of the non-zero arguments correspond to the same\n\
+where the position of the nonzero arguments correspond to the same\n\
 positions as in the matrix @var{A}.\n\
 \n\
 Alternatively, the fill-in of the incomplete LU@tie{}factorization can\n\
 be controlled through the variable @var{droptol} or the structure\n\
 @var{opts}.  The @sc{umfpack} multifrontal factorization code by Tim A.\n\
 Davis is used for the incomplete LU@tie{}factorization, (availability\n\
 @url{http://www.cise.ufl.edu/research/sparse/umfpack/})\n\
 \n\
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -1881,17 +1881,17 @@ whether zero is signed, use the @code{si
 */
 
 DEFUNX ("signbit", Fsignbit, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} signbit (@var{x})\n\
 Return logical true if the value of @var{x} has its sign bit set.\n\
 Otherwise return logical false.  This behavior is consistent with the other\n\
 logical functions.  See@ref{Logical Values}.  The behavior differs from the\n\
-C language function which returns non-zero if the sign bit is set.\n\
+C language function which returns nonzero if the sign bit is set.\n\
 \n\
 This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
 allows zero to be signed.  The comparison @code{-0.0 < 0.0} is false,\n\
 but @code{signbit (-0.0)} will return a nonzero value.\n\
 @seealso{sign}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -72,17 +72,17 @@ octave_fstream::seek (off_t, int)
 
 off_t
 octave_fstream::tell (void)
 {
   error ("ftell: invalid_operation");
   return -1;
 }
 
-// Return non-zero if EOF has been reached on this stream.
+// Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_fstream::eof (void) const
 {
   return fs.eof ();
 }
 
 void
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -47,17 +47,17 @@ public:
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
 
   // Return current stream position.
 
   off_t tell (void);
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   void do_close (void);
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
diff --git a/libinterp/corefcn/oct-iostrm.cc b/libinterp/corefcn/oct-iostrm.cc
--- a/libinterp/corefcn/oct-iostrm.cc
+++ b/libinterp/corefcn/oct-iostrm.cc
@@ -40,46 +40,46 @@ octave_base_iostream::seek (off_t, int)
 
 off_t
 octave_base_iostream::tell (void)
 {
   invalid_operation ();
   return -1;
 }
 
-// Return non-zero if EOF has been reached on this stream.
+// Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_base_iostream::eof (void) const
 {
   invalid_operation ();
   return false;
 }
 
 void
 octave_base_iostream::invalid_operation (void) const
 {
   ::error ("%s: invalid operation", stream_type ());
 }
 
-// Return non-zero if EOF has been reached on this stream.
+// Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_istream::eof (void) const
 {
   return is && is->eof ();
 }
 
 octave_stream
 octave_istream::create (std::istream *arg, const std::string& n)
 {
   return octave_stream (new octave_istream (arg, n));
 }
 
-// Return non-zero if EOF has been reached on this stream.
+// Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_ostream::eof (void) const
 {
   return os && os->eof ();
 }
 
 octave_stream
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -41,17 +41,17 @@ public:
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
 
   // Return current stream position.
 
   off_t tell (void);
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
 protected:
@@ -82,17 +82,17 @@ public:
     : octave_base_iostream (n, std::ios::in,
                             oct_mach_info::native_float_format ()),
       is (arg)
   { }
 
   static octave_stream
   create (std::istream *arg = 0, const std::string& n = std::string ());
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return is; }
 
   std::ostream *output_stream (void) { return 0; }
 
 protected:
@@ -121,17 +121,17 @@ public:
     : octave_base_iostream (n, std::ios::out,
                             oct_mach_info::native_float_format ()),
       os (arg)
   { }
 
   static octave_stream
   create (std::ostream *arg, const std::string& n = std::string ());
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return os; }
 
 protected:
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -45,17 +45,17 @@ public:
 
   int seek (off_t offset, int origin)
   { return s ? s->seek (offset, origin) : -1; }
 
   // Return current stream position.
 
   off_t tell (void) { return s ? s->tell () : -1; }
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return s ? s->eof () : true; }
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
   std::istream *input_stream (void) { return (md & std::ios::in) ? s : 0; }
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -91,17 +91,17 @@ public:
           oct_mach_info::float_format ff
             = oct_mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
           oct_mach_info::float_format ff
             = oct_mach_info::native_float_format ());
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream *input_stream (void) { return &is; }
 
   std::ostream *output_stream (void) { return 0; }
 
   off_t tell (void) { return is.tellg (); }
@@ -137,17 +137,17 @@ public:
                        = oct_mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), os () { }
 
   static octave_stream
   create (std::ios::openmode arg_md = std::ios::out,
           oct_mach_info::float_format ff
             = oct_mach_info::native_float_format ());
 
-  // Return non-zero if EOF has been reached on this stream.
+  // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return &os; }
 
   std::string str (void) { return os.str (); }
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -81,17 +81,17 @@ use the sparsity preserving amd function
 \n\
 @item piv_tol\n\
 The pivot tolerance of the @sc{umfpack} solvers (default 0.1)\n\
 \n\
 @item sym_tol\n\
 The pivot tolerance of the @sc{umfpack} symmetric solvers (default 0.001)\n\
 \n\
 @item bandden\n\
-The density of non-zero elements in a banded matrix before it is treated\n\
+The density of nonzero elements in a banded matrix before it is treated\n\
 by the @sc{lapack} banded solvers (default 0.5)\n\
 \n\
 @item umfpack\n\
 Flag whether the @sc{umfpack} or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with\n\
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -610,17 +610,17 @@ main_loop (void)
                       if (quit)
                         break;
                     }
 
                   if (error_state)
                     {
                       if (! (interactive || forced_interactive))
                         {
-                          // We should exit with a non-zero status.
+                          // We should exit with a nonzero status.
                           retval = 1;
                           break;
                         }
                     }
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -233,17 +233,17 @@ keyword_almost_match (const char * const
 done:
 
   delete [] kw;
   delete [] to_match;
 
   return status;
 }
 
-// Return non-zero if either NR or NC is zero.  Return -1 if this
+// Return nonzero if either NR or NC is zero.  Return -1 if this
 // should be considered fatal; return 1 if this is ok.
 
 int
 empty_arg (const char * /* name */, octave_idx_type nr, octave_idx_type nc)
 {
   return (nr == 0 || nc == 0);
 }
 
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -317,17 +317,17 @@ find_starting_node (octave_idx_type N, c
           Q_enq (Q, N, qt, x);
         }
       else
         break;
     }
   return x.id;
 }
 
-// Calculates the node's degrees. This means counting the non-zero elements
+// Calculates the node's degrees. This means counting the nonzero elements
 // in the symmetric matrix' rows. This works for non-symmetric matrices
 // as well.
 
 static octave_idx_type
 calc_degrees (octave_idx_type N, const octave_idx_type *ridx,
               const octave_idx_type *cidx, octave_idx_type *D)
 {
   octave_idx_type max_deg = 0;
@@ -336,17 +336,17 @@ calc_degrees (octave_idx_type N, const o
     D[i] = 0;
 
   for (octave_idx_type j = 0; j < N; j++)
     {
       for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
         {
           OCTAVE_QUIT;
           octave_idx_type k = ridx[i];
-          // there is a non-zero element (k,j)
+          // there is a nonzero element (k,j)
           D[k]++;
           if (D[k] > max_deg)
             max_deg = D[k];
           // if there is no element (j,k) there is one in
           // the symmetric matrix:
           if (k != j)
             {
               bool found = false;
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -547,17 +547,17 @@ octave_bool_matrix::as_mxArray (void) co
   return retval;
 }
 
 DEFUN (logical, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} logical (@var{x})\n\
 Convert the numeric object @var{x} to logical type.\n\
 \n\
-Any non-zero values will be converted to true (1) while zero values\n\
+Any nonzero values will be converted to true (1) while zero values\n\
 will be converted to false (0).  The non-numeric value NaN cannot be\n\
 converted and will produce an error.\n\
 \n\
 Compatibility Note: Octave accepts complex values as input, whereas\n\
 @sc{matlab} issues an error.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1912,17 +1912,17 @@ SparseComplexMatrix::utsolve (MatrixType
                                i < cidx (kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2008,17 +2008,17 @@ SparseComplexMatrix::utsolve (MatrixType
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2435,17 +2435,17 @@ SparseComplexMatrix::utsolve (MatrixType
                                i < cidx (kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2531,17 +2531,17 @@ SparseComplexMatrix::utsolve (MatrixType
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2985,17 +2985,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3094,17 +3094,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3552,17 +3552,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3661,17 +3661,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4027,17 +4027,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
-                  // Count non-zeros in work vector and adjust
+                  // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4309,17 +4309,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
@@ -4337,17 +4337,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
-                  // Count non-zeros in work vector and adjust
+                  // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4729,17 +4729,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
-                  // Take a first guess that the number of non-zero terms
+                  // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -4903,17 +4903,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                         work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5296,17 +5296,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
-                  // Take a first guess that the number of non-zero terms
+                  // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -5323,17 +5323,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       if (err != 0)
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5476,17 +5476,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                         Bx[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -6071,17 +6071,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
               for (octave_idx_type i = 0; i < b_nr; i++)
                 Bz[i] = 0.;
 #else
               OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
               retval.xcidx (0) = 0;
@@ -6577,17 +6577,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               double *control = Control.fortran_vec ();
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const Complex *Ax = data ();
 
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
               retval.xcidx (0) = 0;
@@ -7775,17 +7775,17 @@ max (const Complex& c, const SparseCompl
 {
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
-  // Count the number of non-zero elements
+  // Count the number of nonzero elements
   if (xmax (c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           result.xdata (m.ridx (i) + j * nr) = xmax (c, m.data (i));
     }
   else
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -652,17 +652,17 @@ Sparse<T>::Sparse (const Array<T>& a)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
   else
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = cols ();
       octave_idx_type len = a.length ();
       octave_idx_type new_nzmx = 0;
 
-      // First count the number of non-zero terms
+      // First count the number of nonzero terms
       for (octave_idx_type i = 0; i < len; i++)
         if (a(i) != T ())
           new_nzmx++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
       octave_idx_type ii = 0;
       xcidx (0) = 0;
@@ -2422,17 +2422,17 @@ Sparse<T>::diag (octave_idx_type k) cons
         nnc -= k;
       else if (k < 0)
         nnr += k;
 
       if (nnr > 0 && nnc > 0)
         {
           octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
-          // Count the number of non-zero elements
+          // Count the number of nonzero elements
           octave_idx_type nel = 0;
           if (k > 0)
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
                 if (elem (i, i+k) != 0.)
                   nel++;
             }
           else if (k < 0)
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -237,17 +237,17 @@ public:
   // Sparsify a normal matrix
   Sparse (const Array<T>& a);
 
   virtual ~Sparse (void);
 
   Sparse<T>& operator = (const Sparse<T>& a);
 
   // Note that nzmax and capacity are the amount of storage for
-  // non-zero elements, while nnz is the actual number of non-zero
+  // nonzero elements, while nnz is the actual number of nonzero
   // terms.
   octave_idx_type nzmax (void) const { return rep->length (); }
   octave_idx_type capacity (void) const { return nzmax (); }
   octave_idx_type nnz (void) const { return rep->nnz (); }
 
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
   octave_idx_type numel (void) const
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1999,17 +1999,17 @@ SparseMatrix::utsolve (MatrixType &matty
                                i < cidx (kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2095,17 +2095,17 @@ SparseMatrix::utsolve (MatrixType &matty
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2524,17 +2524,17 @@ SparseMatrix::utsolve (MatrixType &matty
                                i < cidx (kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -2621,17 +2621,17 @@ SparseMatrix::utsolve (MatrixType &matty
                           for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3079,17 +3079,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3188,17 +3188,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3647,17 +3647,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 continue;
 
                               octave_idx_type iidx = perm[ridx (i)];
                               cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -3757,17 +3757,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                           for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
                               octave_idx_type iidx = ridx (i);
                               cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
-                  // Count non-zeros in work vector and adjust space in
+                  // Count nonzeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4124,17 +4124,17 @@ SparseMatrix::trisolve (MatrixType &matt
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
-                  // Count non-zeros in work vector and adjust
+                  // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4406,17 +4406,17 @@ SparseMatrix::trisolve (MatrixType &matt
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
@@ -4453,17 +4453,17 @@ SparseMatrix::trisolve (MatrixType &matt
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
-                  // Count non-zeros in work vector and adjust
+                  // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0. || Bz[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4847,17 +4847,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
-                  // Take a first guess that the number of non-zero terms
+                  // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -5021,17 +5021,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5468,17 +5468,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
-                  // Take a first guess that the number of non-zero terms
+                  // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -5514,17 +5514,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
 
                           err = -1;
                           break;
                         }
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5681,17 +5681,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                                  F77_CHAR_ARG_LEN (1)));
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust
+                      // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -6240,17 +6240,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const double *Ax = data ();
 
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseMatrix (b_nr, b_nc, x_nz);
 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
@@ -6737,17 +6737,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const double *Ax = data ();
 
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
-              // Take a first guess that the number of non-zero terms
+              // Take a first guess that the number of nonzero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 
@@ -7737,17 +7737,17 @@ min (double d, const SparseMatrix& m)
 {
   SparseMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
-  // Count the number of non-zero elements
+  // Count the number of nonzero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmin (d, m.data (i));
             if (tmp != 0.)
@@ -7888,17 +7888,17 @@ max (double d, const SparseMatrix& m)
 {
   SparseMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
-  // Count the number of non-zero elements
+  // Count the number of nonzero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmax (d, m.data (i));
 
diff --git a/liboctave/numeric/randmtzig.c b/liboctave/numeric/randmtzig.c
--- a/liboctave/numeric/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -244,17 +244,17 @@ oct_init_by_array (uint32_t *init_key, i
       i++;
       if (i >= MT_N)
         {
           state[0] = state[MT_N-1];
           i = 1;
         }
     }
 
-  state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
+  state[0] = 0x80000000UL; /* MSB is 1; assuring nonzero initial array */
   left = 1;
   initf = 1;
 }
 
 void
 oct_init_by_entropy (void)
 {
   uint32_t entropy[MT_N];
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -1179,17 +1179,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
       r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
-            /* Count num of non-zero elements */ \
+            /* Count num of nonzero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
                 if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
@@ -1247,17 +1247,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
       r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
-            /* Count num of non-zero elements */ \
+            /* Count num of nonzero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
                 if ((m1.elem (i, j) != LHS_ZERO) \
                     OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
@@ -1419,17 +1419,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
-            /* Count num of non-zero elements */ \
+            /* Count num of nonzero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
                 if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
@@ -1487,17 +1487,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
-            /* Count num of non-zero elements */ \
+            /* Count num of nonzero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
                 if ((m1.elem (i, j) != LHS_ZERO) \
                     OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
@@ -1925,20 +1925,20 @@ along with Octave; see the file COPYING.
           for (octave_idx_type i = 0; i < nr; i++) \
             w[i] = 0; \
           \
           OCTAVE_LOCAL_BUFFER (RET_EL_TYPE, Xcol, nr); \
           \
           retval.change_capacity (nel); \
           /* The optimal break-point as estimated from simulations */ \
           /* Note that Mergesort is O(nz log(nz)) while searching all */ \
-          /* values is O(nr), where nz here is non-zero per row of */ \
+          /* values is O(nr), where nz here is nonzero per row of */ \
           /* length nr. The test itself was then derived from the */ \
           /* simulation with random square matrices and the observation */ \
-          /* of the number of non-zero elements in the output matrix */ \
+          /* of the number of nonzero elements in the output matrix */ \
           /* it was found that the breakpoints were */ \
           /*   nr: 500  1000  2000  5000 10000 */ \
           /*   nz:   6    25    97   585  2202 */ \
           /* The below is a simplication of the 'polyfit'-ed parameters */ \
           /* to these breakpoints */ \
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
                                         (a_nc * a_nc) / 43000); \
           octave_idx_type ii = 0; \
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -23,17 +23,17 @@
 ##
 ## The first sentence is defined as the text after the function
 ## declaration until either the first period (".") or the first appearance of
 ## two consecutive newlines ("\n\n").  The text is truncated to a maximum
 ## length of @var{max_len}, which defaults to 80.
 ##
 ## The optional output argument @var{status} returns the status reported by
 ## @code{makeinfo}.  If only one output argument is requested, and @var{status}
-## is non-zero, a warning is displayed.
+## is nonzero, a warning is displayed.
 ##
 ## As an example, the first sentence of this help text is
 ##
 ## @example
 ## @group
 ## get_first_help_sentence ("get_first_help_sentence")
 ## @print{} ans = Return the first sentence of a function's help text.
 ## @end group
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} edit @var{name}
 ## @deftypefnx {Command} {} edit @var{field} @var{value}
 ## @deftypefnx {Command} {@var{value} =} edit get @var{field}
 ## Edit the named function, or change editor settings.
 ##
 ## If @code{edit} is called with the name of a file or function as
-## its argument it will be opened in the text editor defined by @code{EDITOR}.
+## its argument it will be opened in the text editor defined by @env{EDITOR}.
 ##
 ## @itemize @bullet
 ## @item
 ## If the function @var{name} is available in a file on your path and
 ## that file is modifiable, then it will be edited in place.  If it
 ## is a system function, then it will first be copied to the directory
 ## @env{HOME} (see below) and then edited.
 ## If no file is found, then the m-file
diff --git a/scripts/plot/draw/pie.m b/scripts/plot/draw/pie.m
--- a/scripts/plot/draw/pie.m
+++ b/scripts/plot/draw/pie.m
@@ -25,17 +25,17 @@
 ## Plot a 2-D pie chart.
 ##
 ## When called with a single vector argument, produce a pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
 ## element @var{x}i represents of the total sum of @var{x}:
 ## @code{pct = @var{x}(i) / sum (@var{x})}. 
 ##
 ## The optional input @var{explode} is a vector of the same length as @var{x}
-## that, if non-zero, "explodes" the slice from the pie chart.
+## that, if nonzero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
 ## 
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
diff --git a/scripts/plot/draw/pie3.m b/scripts/plot/draw/pie3.m
--- a/scripts/plot/draw/pie3.m
+++ b/scripts/plot/draw/pie3.m
@@ -26,17 +26,17 @@
 ## Plot a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}.  The size of the ith slice is the percentage that the
 ## element @var{x}i represents of the total sum of @var{x}:
 ## @code{pct = @var{x}(i) / sum (@var{x})}. 
 ##
 ## The optional input @var{explode} is a vector of the same length as @var{x}
-## that, if non-zero, "explodes" the slice from the pie chart.
+## that, if nonzero, "explodes" the slice from the pie chart.
 ##
 ## The optional input @var{labels} is a cell array of strings of the same
 ## length as @var{x} specifying the label for each slice.
 ##
 ## If the first argument @var{hax} is an axes handle, then plot into this axis,
 ## rather than the current axes returned by @code{gca}.
 ##
 ## The optional return value @var{h} is a list of graphics handles to the
diff --git a/scripts/sparse/colperm.m b/scripts/sparse/colperm.m
--- a/scripts/sparse/colperm.m
+++ b/scripts/sparse/colperm.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{p} =} colperm (@var{s})
 ## Return the column permutations such that the columns of
 ## @code{@var{s} (:, @var{p})} are ordered in terms of increase number
-## of non-zero elements.  If @var{s} is symmetric, then @var{p} is chosen
+## of nonzero elements.  If @var{s} is symmetric, then @var{p} is chosen
 ## such that @code{@var{s} (@var{p}, @var{p})} orders the rows and
-## columns with increasing number of non zeros elements.
+## columns with increasing number of nonzeros elements.
 ## @end deftypefn
 
 function p = colperm (s)
 
   if (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nonzeros (@var{s})
-## Return a vector of the non-zero values of the sparse matrix @var{s}.
+## Return a vector of the nonzero values of the sparse matrix @var{s}.
 ## @seealso{find, nnz}
 ## @end deftypefn
 
 function t = nonzeros (s)
 
   if (nargin != 1)
     print_usage ();
   endif
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{B} =} spdiags (@var{A})
 ## @deftypefnx {Function File} {[@var{B}, @var{d}] =} spdiags (@var{A})
 ## @deftypefnx {Function File} {@var{B} =} spdiags (@var{A}, @var{d})
 ## @deftypefnx {Function File} {@var{A} =} spdiags (@var{v}, @var{d}, @var{A})
 ## @deftypefnx {Function File} {@var{A} =} spdiags (@var{v}, @var{d}, @var{m}, @var{n})
 ## A generalization of the function @code{diag}.  Called with a single
-## input argument, the non-zero diagonals @var{d} of @var{A} are extracted.
+## input argument, the nonzero diagonals @var{d} of @var{A} are extracted.
 ## With two arguments the diagonals to extract are given by the vector
 ## @var{d}.
 ##
 ## The other two forms of @code{spdiags} modify the input matrix by
 ## replacing the diagonals.  They use the columns of @var{v} to replace
 ## the diagonals represented by the vector @var{d}.  If the sparse matrix
 ## @var{A} is defined then the diagonals of this matrix are replaced.
 ## Otherwise a matrix of @var{m} by @var{n} is created with the
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spfun (@var{f}, @var{S})
-## Compute @code{f(@var{S})} for the non-zero values of @var{S}.
+## Compute @code{f(@var{S})} for the nonzero values of @var{S}.
 ## This results in a sparse matrix with the same structure as
 ## @var{S}.  The function @var{f} can be passed as a string, a
 ## function handle, or an inline function.
 ## @seealso{arrayfun, cellfun, structfun}
 ## @end deftypefn
 
 function y = spfun (f, S)
 
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{r} =} spones (@var{S})
-## Replace the non-zero entries of @var{S} with ones.  This creates a
+## Replace the nonzero entries of @var{S} with ones.  This creates a
 ## sparse matrix with the same structure as @var{S}.
 ## @seealso{sparse, sprand, sprandn, sprandsym, spfun, spy}
 ## @end deftypefn
 
 function r = spones (S)
 
   if (nargin != 1)
     print_usage ();
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -25,17 +25,17 @@
 ## @deftypefnx {Function File} {} sprand (@var{s})
 ## Generate a sparse matrix with uniformly distributed random values.
 ##
 ## The size of the matrix is @var{m}x@var{n} with a density of values @var{d}.
 ## @var{d} must be between 0 and 1.  Values will be uniformly distributed on
 ## the interval (0, 1).
 ##
 ## If called with a single matrix argument, a sparse matrix is generated with
-## random values wherever the matrix @var{s} is non-zero.
+## random values wherever the matrix @var{s} is nonzero.
 ##
 ## If called with a scalar fourth argument @var{rc}, a random sparse matrix
 ## with reciprocal condition number @var{rc} is generated.  If @var{rc} is
 ## a vector, then it specifies the first singular values of the generated
 ## matrix (@code{length (@var{rc}) <= min (@var{m}, @var{n})}).
 ##
 ## @seealso{sprandn, sprandsym, rand}
 ## @end deftypefn
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -25,17 +25,17 @@
 ## @deftypefnx {Function File} {} sprandn (@var{s})
 ## Generate a sparse matrix with normally distributed random values.
 ##
 ## The size of the matrix is @var{m}x@var{n} with a density of values @var{d}.
 ## @var{d} must be between 0 and 1.  Values will be normally distributed with a
 ## mean of 0 and a variance of 1.
 ##
 ## If called with a single matrix argument, a sparse matrix is generated with
-## random values wherever the matrix @var{s} is non-zero.
+## random values wherever the matrix @var{s} is nonzero.
 ##
 ## If called with a scalar fourth argument @var{rc}, a random sparse matrix
 ## with reciprocal condition number @var{rc} is generated.  If @var{rc} is
 ## a vector, then it specifies the first singular values of the generated
 ## matrix (@code{length (@var{rc}) <= min (@var{m}, @var{n})}).
 ## 
 ## @seealso{sprand, sprandsym, randn}
 ## @end deftypefn
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} sprandsym (@var{s})
 ## Generate a symmetric random sparse matrix.
 ##
 ## The size of the matrix will be @var{n}x@var{n}, with a density of values
 ## given by @var{d}.  @var{d} must be between 0 and 1 inclusive.  Values will
 ## be normally distributed with a mean of zero and a variance of 1.
 ##
 ## If called with a single matrix argument, a random sparse matrix is generated
-## wherever the matrix @var{S} is non-zero in its lower triangular part.
+## wherever the matrix @var{S} is nonzero in its lower triangular part.
 ## @seealso{sprand, sprandn, spones, sparse}
 ## @end deftypefn
 
 function S = sprandsym (n, d)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -14,20 +14,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S})
 ## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S}, @var{j})
-## Return the stats for the non-zero elements of the sparse matrix @var{S}.
-## @var{count} is the number of non-zeros in each column, @var{mean}
-## is the mean of the non-zeros in each column, and @var{var} is the
-## variance of the non-zeros in each column.
+## Return the stats for the nonzero elements of the sparse matrix @var{S}.
+## @var{count} is the number of nonzeros in each column, @var{mean}
+## is the mean of the nonzeros in each column, and @var{var} is the
+## variance of the nonzeros in each column.
 ##
 ## Called with two input arguments, if @var{S} is the data and @var{j}
 ## is the bin number for the data, compute the stats for each bin.  In
 ## this case, bins can contain data values of zero, whereas with
 ## @code{spstats (@var{S})} the zeros may disappear.
 ## @end deftypefn
 
 function [count, mean, var] = spstats (S, j)
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -164,17 +164,17 @@ function [u, s, v, flag] = svds (A, k, s
       b_sigma = b_sigma / max_a;
     endif
 
     if (b_sigma == 0)
       ## Find the smallest eigenvalues
       ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
       ## As we are only interested in the positive eigenvalues, we have to
       ## double k and then throw out the k negative eigenvalues.
-      ## Separately, if sigma is non-zero, but smaller than the smallest
+      ## Separately, if sigma is nonzero, but smaller than the smallest
       ## singular value, ARPACK may not return k eigenvalues. However, as
       ## computation scales with k we'd like to avoid doubling k for all
       ## scalar values of sigma.
       b_k = 2 * k;
     else
       b_k = k;  # Normal case, find just the k largest eigenvalues
     endif
 
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -1209,19 +1209,19 @@ function A = gearmat (n, i = n, j = -n)
   ##         C.W. Gear, A simple set of test matrices for eigenvalue programs,
   ##         Math. Comp., 23 (1969), pp. 119-125.
 
   if (nargin < 1 || nargin > 3)
     error ("gallery: 1 to 3 arguments are required for gearmat matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for gearmat matrix.");
   elseif (! isnumeric (i) || ! isscalar (i) || i == 0 || abs (i) <= n)
-    error ("gallery: I must be a non-zero scalar, and abs (I) <= N for gearmat matrix.");
+    error ("gallery: I must be a nonzero scalar, and abs (I) <= N for gearmat matrix.");
   elseif (! isnumeric (j) || ! isscalar (j) || i == 0 || abs (j) <= n)
-    error ("gallery: J must be a non-zero scalar, and abs (J) <= N for gearmat matrix.");
+    error ("gallery: J must be a nonzero scalar, and abs (J) <= N for gearmat matrix.");
   endif
 
   A = diag (ones (n-1, 1), -1) + diag (ones (n-1, 1), 1);
   A(1, abs (i)) = sign (i);
   A(n, n+1 - abs (j)) = sign (j);
 endfunction
 
 function G = grcar (n, k = 3)
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -98,16 +98,17 @@
 ## @example
 ## @group
 ## 1/N SUM_i ( abs (x(i)) )^p
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end table
+##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
 ## If both @var{type} and @var{dim} are given they may appear in any order.
 ## @seealso{var, skewness, kurtosis}
 ## @end deftypefn
 
 ## Can easily be made to work for continuous distributions (using quad)
 ## as well, but how does the general case work?
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cor_test (@var{x}, @var{y}, @var{alt}, @var{method})
 ## Test whether two samples @var{x} and @var{y} come from uncorrelated
 ## populations.
 ##
 ## The optional argument string @var{alt} describes the alternative
-## hypothesis, and can be @qcode{"!="} or @qcode{"<>"} (non-zero),
+## hypothesis, and can be @qcode{"!="} or @qcode{"<>"} (nonzero),
 ## @qcode{">"} (greater than 0), or @qcode{"<"} (less than 0).  The
 ## default is the two-sided case.
 ##
 ## The optional argument string @var{method} specifies which
 ## correlation coefficient to use for testing.  If @var{method} is
 ## @qcode{"pearson"} (default), the (usual) Pearson's product moment
 ## correlation coefficient is used.  In this case, the data should come
 ## from a bivariate normal distribution.  Otherwise, the other two
