# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1336873184 21600
#      Sat May 12 19:39:44 2012 -0600
# Node ID 3513df68d580a8731fde5220d9dd783deacd4f91
# Parent  54ea692b8ab5421cdf95266b427151253adcedb0
# Parent  9e4ad3f1f291bb6ccdbffbb4d3053844a56d7145
maint: periodic merge of default to jit

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -59,8 +59,9 @@ a737b3fb9c4d89d3694da6b4e623aeee64b212e1
 72aebe6196414e38ef802469ff6e238f914f04c9 rc-3-6-0-0
 64d9f33313cc8c691974bcd123357e24bccbabdc rc-3-6-0-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3.6.0
 95c43fc8dbe1a07a46fefb3372df5b2309d874fd rc-3-6-1-0
 0000000000000000000000000000000000000000 release-3-2-4
 e320928eeb3aa2370b792e83dafc3e0ddecdc871 release-3-2-4
 ba4d6343524b406b0d15aee34579f80783581c54 release-3-6-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3-6-0
+f947d2922febf12dcd1fb6e21b356756ecb54e55 rc-3-6-2-0
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -337,16 +337,19 @@ includedir = @includedir@
 # have.  The default is ${prefix}/man/man1
 mandir = @mandir@
 man1dir = @man1dir@
 man1ext = @man1ext@
 
 # The full path to the default doc cache file.
 doc_cache_file = @doc_cache_file@
 
+# The full path to the default texi macros file.
+texi_macros_file_file = @texi_macros_file@
+
 # Where to install and expect the info files describing Octave..
 infodir = @infodir@
 
 # The full path to the default info file.
 infofile = @infofile@
 
 # ==================== Octave-specific directories ====================
 
@@ -630,16 +633,17 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_OCTFILEDIR%|\"${octfiledir}\"|" \
   -e "s|%OCTAVE_OCTETCDIR%|\"${octetcdir}\"|" \
   -e "s|%OCTAVE_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_OCTLIBDIR%|\"${octlibdir}\"|" \
   -e "s|%OCTAVE_STARTUPFILEDIR%|\"${startupfiledir}\"|" \
   -e "s|%OCTAVE_PREFIX%|\"${prefix}\"|" \
   -e "s|%OCTAVE_API_VERSION%|\"${api_version}\"|" \
   -e "s|%OCTAVE_RELEASE%|\"${OCTAVE_RELEASE}\"|" \
+  -e "s|%OCTAVE_TEXI_MACROS_FILE%|\"${texi_macros_file}\"|" \
   -e "s|%OCTAVE_VERSION%|\"${version}\"|"
 $(simple_move_if_change_rule)
 endef
 
 define do_subst_script_vals
 echo "making $@ from $<"
 $(SED) < $< \
   -e "s|%AWK%|${AWK}|g" \
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -113,16 +113,17 @@ AC_SUBST(sepchar)
 AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'], [Define this to be the path separator for your system, as a character constant.])
 AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"], [Define this to the path separator, as a string.])
 
 ### some defaults
 
 OCTAVE_SET_DEFAULT(man1dir, '$(mandir)/man1')
 OCTAVE_SET_DEFAULT(man1ext, '.1')
 OCTAVE_SET_DEFAULT(doc_cache_file, '$(octetcdir)/doc-cache')
+OCTAVE_SET_DEFAULT(texi_macros_file, '$(octetcdir)/macros.texi')
 OCTAVE_SET_DEFAULT(infofile, '$(infodir)/octave.info')
 OCTAVE_SET_DEFAULT(octincludedir, '$(includedir)/octave-$(version)/octave')
 OCTAVE_SET_DEFAULT(fcnfiledir, '$(datadir)/octave/$(version)/m')
 OCTAVE_SET_DEFAULT(localfcnfiledir, '$(datadir)/octave/site/m')
 OCTAVE_SET_DEFAULT(localapifcnfiledir,
   '$(datadir)/octave/site/$(api_version)/m')
 OCTAVE_SET_DEFAULT(localverfcnfiledir, '$(datadir)/octave/$(version)/site/m')
 OCTAVE_SET_DEFAULT(octetcdir, '$(datadir)/octave/$(version)/etc')
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -174,33 +174,27 @@ all-local: dvi html pdf ps doc-cache $(H
 # Prevent packaging of distribution unless all libraries 
 # necessary to create documentation are present
 dist-hook:
 	@$(GREP) '#define HAVE_COLAMD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing COLAMD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_CHOLMOD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing CHOLMOD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_UMFPACK 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing UMFPACK library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_QHULL 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing QHULL library.  Cannot package distribution!" ; exit 1; }
 
-octetc_DATA = doc-cache
+octetc_DATA = doc-cache macros.texi
 
 DOCSTRING_FILES = $(shell $(srcdir)/find-docstring-files.sh "$(top_srcdir)")
 
 doc-cache: $(DOCSTRING_FILES) mk_doc_cache.m
-	$(top_builddir)/run-octave -f -q -H $(srcdir)/mk_doc_cache.m doc-cache $(DOCSTRING_FILES) || { rm -f doc-cache; exit 1; }
-
-## Program compiled only to help build documentation.  No need to install
-noinst_PROGRAMS = munge-texi
-
-munge_texi_SOURCES = munge-texi.cc
+	$(top_builddir)/run-octave -f -q -H $(srcdir)/mk_doc_cache.m doc-cache $(srcdir)/macros.texi $(DOCSTRING_FILES) || { rm -f doc-cache; exit 1; }
 
 $(MUNGED_TEXI_SRC): $(DOCSTRING_FILES) $(munge_texi_SOURCES)
 
-%.texi: %.txi
-	@$(MAKE) $(AM_MAKEFLAGS) munge-texi$(BUILD_EXEEXT)
-	./munge-texi $(top_srcdir) $(DOCSTRING_FILES) < $< > $@-t
+%.texi: %.txi munge-texi.pl
+	$(PERL) $(srcdir)/munge-texi.pl $(top_srcdir) $(DOCSTRING_FILES) < $< > $@-t
 	mv $@-t $@
 
 contributors.texi: contributors.in
 	$(AWK) -f $(srcdir)/mkcontrib.awk $(srcdir)/contributors.in > $@-t
 	mv $@-t $@
 
 ../../AUTHORS: preface.texi contributors.texi
 	rm -f AUTHORS
@@ -248,16 +242,17 @@ EXTRA_DIST = \
   config-images.sh \
   contributors.in \
   find-docstring-files.sh \
   images \
   images.awk \
   images.mk \
   mk_doc_cache.m \
   mkcontrib.awk \
+  munge-texi.pl \
   octave.dvi \
   octave.html \
   octave.pdf \
   octave.ps \
   $(IMAGES) \
   $(IMAGES_SRC) \
   $(LOGOS) \
   $(TXI_SRC)
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -384,16 +384,18 @@ for displaying the documentation, and wh
 found.
 
 @DOCSTRING(info_file)
 
 @DOCSTRING(info_program)
 
 @DOCSTRING(makeinfo_program)
 
+@DOCSTRING(texi_macros_file)
+
 @DOCSTRING(doc_cache_file)
 
 @DOCSTRING(suppress_verbose_help_message)
 
 The following functions are principally used internally by Octave for
 generating the documentation.  They are documented here for completeness
 and because they may occasionally be useful for users.
 
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -529,16 +529,17 @@ lvalue
 lvl
 lx
 ly
 lz
 Magnus
 Mahalanobis
 makefile
 makefiles
+makeinfo
 Mandriva
 MANOVA
 manova
 Marsaglia
 Maschhoff
 matchcase
 matlab
 Matsumoto
@@ -857,16 +858,17 @@ Stepleman
 stepsize
 STFT
 STL
 stochastically
 strcmp
 stringanchors
 strncmp
 strncmpi
+strread
 struct
 structs
 subarrays
 subdirectories
 subdirectory
 subexpressions
 subfunction
 Subfunction
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -191,17 +191,17 @@ The Perl Compatible Regular Expression l
 The following external package is optional but strongly recommended:
 
 @table @asis
 @item GNU Readline
 Command-line editing library (@url{www.gnu.org/s/readline}).
 @end table
 
 If you wish to build Octave without GNU readline installed, you must use
-the @code{--disable-readline} option when running the configure script.
+the @option{--disable-readline} option when running the configure script.
 
 The following external software packages are optional but recommended:
 
 @table @asis
 @item ARPACK
 Library for the solution of large-scale eigenvalue problems
 (@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
 required to provide the functions @code{eigs} and @code{svds}.
diff --git a/doc/interpreter/macros.texi b/doc/interpreter/macros.texi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/macros.texi
@@ -0,0 +1,65 @@
+@c Copyright (C) 2012 John W. Eaton
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c 
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+@c for more details.
+@c 
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING.  If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@c FIXME -- someday, we might replace this with @backslashchar, which
+@c has been added to Texinfo.
+
+@macro xbackslashchar
+\\
+@end macro
+
+@c The following macro is used for the on-line help system, but we don't
+@c want lots of `See also: foo, bar, and baz' strings cluttering the
+@c printed manual (that information should be in the supporting text for
+@c each group of functions and variables).
+
+@macro seealso {args}
+@iftex
+@vskip 2pt
+@end iftex
+@ifnottex
+@c Texinfo @sp should work but in practice produces ugly results for HTML.
+@c A simple blank line produces the correct behavior. 
+@c @sp 1
+
+@end ifnottex
+@noindent
+@strong{See also:} \args\.
+@end macro
+
+@c The following macro marks words that aspell should ignore during
+@c spellchecking.  Within Texinfo it has no effect as it merely replaces
+@c the macro call with the argument itself.
+
+@macro nospell {arg}
+\arg\
+@end macro
+
+@c The following macro works around a situation where the Info/plain text
+@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
+@c can be confusing if the code segment itself ends with a transpose operator.
+@ifinfo
+@macro xcode{arg}
+\arg\
+@end macro
+@end ifinfo
+@ifnotinfo
+@macro xcode{arg}
+@code{\arg\}
+@end macro
+@end ifnotinfo
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -33,27 +33,30 @@ nfiles = numel (docstrings_files);
 text = cell (1, nfiles);
 for i = 1:nfiles
   file = docstrings_files{i};
   fid = fopen (file, "r");
   if (fid < 0)
     error ("unable to open %s for reading", file);
   else
     tmp = fread (fid, Inf, "*char")';
-    ## Strip off header lines
-    [~, text{i}] = strtok (tmp, doc_delim);
+    if (isempty (strfind (tmp, doc_delim)))
+      ## No delimiter, copy verbatim (this is the case for the file
+      ## containing macro definitions, for example).
+      text{i} = tmp;
+    else
+      ## Strip off header lines
+      [~, text{i}] = strtok (tmp, doc_delim);
+    endif
   endif
 endfor
 text = [text{:}, doc_delim];
 
-## Modify Octave-specific macros before passing to makeinfo
+## Strip Texinfo markers and docstring separators.
 text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
-text = regexprep (text, '@seealso *\{([^}]*)\}', "See also: $1.");
-text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
-text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
 text = strrep (text, '@', "@@");
 
 ## Write data to temporary file for input to makeinfo
 [fid, name, msg] = mkstemp ("octave_doc_XXXXXX", true);
 if (fid < 0)
   error ("%s: %s\n", name, msg);
 endif
 fwrite (fid, text, "char");
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
deleted file mode 100644
--- a/doc/interpreter/munge-texi.cc
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
-
-Copyright (C) 1999-2012 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#include <cctype>
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <map>
-
-#include <cstdlib>
-#include <cstring>
-
-static std::string top_srcdir;
-
-static const char doc_delim = '';
-
-static std::map<std::string, std::string> help_text;
-
-static void
-fatal (const std::string& msg)
-{
-  std::cerr << msg << "\n";
-  exit (1);
-}
-
-static void
-usage (void)
-{
-  std::cerr << "usage: munge-texi TOP-SRCDIR DOCSTRING-FILE < file\n";
-  exit (1);
-}
-
-static std::string
-extract_symbol_name (std::istream& is)
-{
-  std::string symbol_name;
-
-  int c;
-  while ((c = is.get ()) != EOF && c != '\n')
-    symbol_name += static_cast<char> (c);
-
-  return symbol_name;
-}
-
-static std::string
-extract_docstring (std::istream& is)
-{
-  std::string doc;
-
-  int c;
-  while ((c = is.get ()) != EOF && c != doc_delim)
-    {
-      // Expand @seealso commands to Texinfo references.
-      if (c == '@')
-        {
-          char buf[16];
-          int i = 0;
-          buf[i++] = static_cast<char> (c);
-
-          if ((   buf[i++] = static_cast<char> (is.get ())) == 's'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'e'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'e'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'a'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'l'
-              && (buf[i++] = static_cast<char> (is.get ())) == 's'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'o'
-              && (buf[i++] = static_cast<char> (is.get ())) == '{')
-            {
-              doc += "@seealso{";
-
-              bool first = true;
-
-              // process @seealso parameters
-              while ((c = is.get ()) != EOF
-                     && c != doc_delim
-                     && c != '}')
-                {
-                  // ignore whitespace and delimiters
-                  while (   c == ' '
-                         || c == '\t'
-                         || c == '\r'
-                         || c == '\n'
-                         || c == ',')
-                    {
-                      c = is.get ();
-                    }
-
-                  // test for end of @seealso
-                  if (c == '}')
-                    break;
-
-                  // get function name
-                  std::string function_name;
-                  do
-                    function_name += static_cast<char> (c);
-                  while ((c = is.get ()) != EOF
-                          && c != doc_delim
-                          && c != ' '
-                          && c != '\t'
-                          && c != '\r'
-                          && c != '\n'
-                          && c != ','
-                          && c != '}');
-                  if (first)
-                    first = false;
-                  else
-                    doc += ", ";
-
-                  if (function_name[0] == '@')
-                    function_name = "@" + function_name;
-
-                  doc += "@ref{doc-" + function_name + ",,"
-                    + function_name + "}";
-
-                  // test for end of @seealso
-                  if (c == '}')
-                    break;
-                }
-              if (c == '}')
-                doc += static_cast<char> (c);
-            }
-          else
-            {
-              for (int j = 0; j < i; j++)
-                doc += buf[j];
-            }
-        }
-      else
-        doc += static_cast<char> (c);
-    }
-  return doc;
-}
-
-static void
-skip_comments (std::ifstream& is)
-{
-  int c;
-
-  bool in_comment = false;
-
-  while ((c = is.get ()) != EOF)
-    {
-      if (c == '#')
-        in_comment = true;
-      else if (c == '\n')
-        in_comment = false;
-      else if (! (in_comment || ::isspace (c)))
-        {
-          is.putback (c);
-          break;
-        }
-    }
-}
-
-static void
-process_doc_file (const std::string& fname)
-{
-  std::ifstream infile (fname.c_str ());
-
-  if (infile)
-    {
-      skip_comments (infile);
-
-      if (infile.get () != doc_delim)
-        fatal ("invalid doc file format");
-
-      std::string symbol_name;
-
-      do
-        {
-          symbol_name = extract_symbol_name (infile);
-
-          if (! symbol_name.empty ())
-            {
-              std::string doc_string = extract_docstring (infile);
-
-              if (help_text.find (symbol_name) != help_text.end ())
-                std::cerr << "ignoring duplicate entry for "
-                          << symbol_name << "\n";
-              else
-                help_text[symbol_name] = doc_string;
-            }
-        }
-      while (! symbol_name.empty ());
-    }
-  else
-    fatal ("unable to open docfile");
-}
-
-static bool
-recover_from_macro (std::ostream& os, char *buf, int i)
-{
-  bool bol = false;
-
-  buf[i] = '\0';
-  os << buf;
-
-  if (buf[i - 1] == '\n')
-    bol = true;
-
-  return bol;
-}
-
-static void
-process_example_file (const std::string& file_name, std::ostream& os)
-{
-  std::ifstream infile (file_name.c_str ());
-
-  if (infile)
-    {
-      os << "@verbatim\n";
-
-      int c;
-      int clast = 0;
-
-      while ((c = infile.get ()) != EOF)
-        {
-          os << static_cast<char> (c);
-          clast = c;
-        }
-
-      if (clast != '\n')
-        os << "\n";
-
-      os << "@end verbatim\n";
-    }
-  else
-    fatal ("unable to open example file " + file_name);
-}
-
-static void
-process_texi_input_file (std::istream& is, std::ostream& os)
-{
-  os << "@c DO NOT EDIT!  Generated automatically by munge-texi.\n\n";
-
-  bool bol = true;
-
-  int c;
-  while ((c = is.get ()) != EOF)
-    {
-      if (bol)
-        {
-          if (c == '@')
-            {
-              char buf[16];
-              int i = 0;
-              buf[i++] = static_cast<char> (c);
-
-              buf[i++] = c = static_cast<char> (is.get ());
-
-              if (c == 'D')
-                {
-                  std::string symbol_name;
-
-                  if (   (buf[i++] = static_cast<char> (is.get ())) == 'O'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'C'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'S'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'T'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'R'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'I'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'N'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'G'
-                      && (buf[i++] = static_cast<char> (is.get ())) == '(')
-                    {
-                      while ((c = is.get ()) != EOF && c != ')')
-                        symbol_name += static_cast<char> (c);
-
-                      if (is.eof ())
-                        fatal ("end of file while reading @DOCSTRING command");
-                      else
-                        {
-                          std::string doc_string = help_text[symbol_name];
-
-                          size_t len = doc_string.length ();
-
-                          int j = 0;
-
-                          // If there is a leading comment with the file
-                          // name, copy it to the output.
-                          if (len > 1
-                              && doc_string[j] == '@'
-                              && doc_string[j+1] == 'c')
-                            {
-                              j = 2;
-                              while (doc_string[j++] != '\n')
-                                /* find eol */;
-
-                              os << doc_string.substr (0, j);
-                            }
-
-                          while (doc_string[j] == ' ')
-                            j++;
-
-                          if (doc_string.substr (j, 15) == "-*- texinfo -*-")
-                            {
-                              j += 15;
-
-                              while (isspace (doc_string[j]))
-                                j++;
-
-                              // Make `see also' references in functions
-                              // possible using @anchor{TAG} (new with
-                              // Texinfo 4.0).
-
-                              if (symbol_name[0] == '@')
-                                symbol_name = "@" + symbol_name;
-
-                              os << "@anchor{doc-" << symbol_name << "}\n";
-
-                              os << doc_string.substr (j);
-                            }
-                          else
-                            os << doc_string;
-                        }
-                    }
-                  else
-                    bol = recover_from_macro (os, buf, i);
-                }
-              else if (c == 'E')
-                {
-                  std::string file_name;
-
-                  if (   (buf[i++] = static_cast<char> (is.get ())) == 'X'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'A'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'M'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'P'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'L'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'E'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'F'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'I'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'L'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'E'
-                      && (buf[i++] = static_cast<char> (is.get ())) == '(')
-                    {
-                      while ((c = is.get ()) != EOF && c != ')')
-                        file_name += static_cast<char> (c);
-
-                      file_name = top_srcdir + "/examples/" + file_name;
-
-                      process_example_file (file_name, os);
-                    }
-                  else
-                    bol = recover_from_macro (os, buf, i);
-                }
-              else
-                bol = recover_from_macro (os, buf, i);
-            }
-          else
-            os.put (static_cast<char> (c));
-        }
-      else
-        {
-          if (c == '\n')
-            bol = true;
-
-          os.put (static_cast<char> (c));
-        }
-    }
-}
-
-int
-main (int argc, char **argv)
-{
-  int retval = 0;
-
-  if (argc > 1)
-    {
-      top_srcdir = *++argv;
-
-      while (*++argv)
-        process_doc_file (*argv);
-
-      process_texi_input_file (std::cin, std::cout);
-    }
-  else
-    {
-      usage ();
-
-      retval = 1;
-    }
-
-  return retval;
-
-}
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
new file mode 100755
--- /dev/null
+++ b/doc/interpreter/munge-texi.pl
@@ -0,0 +1,124 @@
+#!/usr/bin/perl -w
+
+# Validate program call
+die "usage: munge-texi TOP-SRCDIR DOCSTRING-FILE < file" if (@ARGV < 2);
+
+$top_srcdir = shift (@ARGV);
+
+# Constant patterns
+$doc_delim = qr/^\c_/;
+$tex_delim = qr/\Q-*- texinfo -*-\E/;
+$comment_line = qr/^\s*(?:$|#)/;
+# Pre-declare hash size for efficiency
+keys(%help_text) = 1800;
+
+################################################################################
+# Load DOCSTRINGS into memory while expanding @seealso references
+foreach $DOCSTRING_file (@ARGV)
+{
+   open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
+
+   # Skip comments
+   while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
+
+   # Validate DOCSTRING file format
+   die "invalid doc file format\n" if (! /$doc_delim/o);
+   
+   do 
+   {
+     chomp;
+     $symbol = substr ($_,1);
+     $docstring = extract_docstring ();
+     if ($help_text{$symbol})
+     {
+        warn "ignoring duplicate entry for $symbol\n";
+     }
+     else
+     {
+       $help_text{$symbol} = $docstring;
+     }
+
+   } while (! eof);
+
+}
+
+################################################################################
+# Process .txi to .texi by expanding @DOCSTRING, @EXAMPLEFILE macros
+
+# Add warning header
+print '@c DO NOT EDIT!  Generated automatically by munge-texi.',"\n\n";
+
+TXI_LINE: while (<STDIN>)
+{
+   if (/^\s*\@DOCSTRING\((\S+)\)/)
+   {
+      $func = $1;
+      $docstring = $help_text{$func};
+      if (! $docstring)
+      {
+        warn "no docstring entry for $func\n";
+        next TXI_LINE;
+      }
+
+      $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+      $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
+      print $docstring,"\n";
+
+      next TXI_LINE;
+   }
+   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
+   {
+      $fname = "$top_srcdir/examples/$1";
+      print '@verbatim',"\n";
+      open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
+      while (<EXAMPFH>) 
+      { 
+         print $_;
+         print "\n" if (eof and substr ($_, -1) ne "\n");
+      }
+      close (EXAMPFH);
+      print '@end verbatim',"\n\n";
+
+      next TXI_LINE;
+   }
+
+   # pass ordinary lines straight through to output
+   print $_;
+}
+
+
+################################################################################
+# Subroutines 
+################################################################################
+sub extract_docstring
+{
+   my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
+   
+   while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
+   {
+      # expand any @seealso references
+      if (m'^@seealso{')
+      {
+         # Join multiple lines until full macro body found
+         while (! /}/m) { $_ .= <DOCFH>; }
+
+         ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
+        
+         $func_list = $arg_list;
+         $func_list =~ s/\s+//gs;
+         $repl = "";
+         foreach $func (split (/,/, $func_list))
+         {
+            $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+            $repl .= "\@ref{doc-$func,,$func}, ";
+         }
+         substr($repl,-2) = "";   # Remove last ', ' 
+         $_ = "\@seealso{$repl}$rest_of_line";
+      }
+
+      $docstring .= $_;
+   }
+
+   return $docstring;
+}
+
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -14,56 +14,17 @@
 % 
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 \input texinfo
 @setfilename octave.info
 
-@c The following macro is used for the on-line help system, but we don't
-@c want lots of `See also: foo, bar, and baz' strings cluttering the
-@c printed manual (that information should be in the supporting text for
-@c each group of functions and variables).
-
-@macro seealso {args}
-@iftex
-@vskip 2pt
-@end iftex
-@ifnottex
-@c Texinfo @sp should work but in practice produces ugly results for HTML.
-@c A simple blank line produces the correct behavior. 
-@c @sp 1
-
-@end ifnottex
-@noindent
-@strong{See also:} \args\.
-@end macro
-
-@c The following macro marks words that aspell should ignore during
-@c spellchecking.  Within Texinfo it has no effect as it merely replaces
-@c the macro call with the argument itself.
-
-@macro nospell {arg}
-\arg\
-@end macro
-
-@c The following macro works around a situation where the Info/plain text
-@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
-@c can be confusing if the code segment itself ends with a transpose operator.
-@ifinfo
-@macro xcode{arg}
-\arg\
-@end macro
-@end ifinfo
-@ifnotinfo
-@macro xcode{arg}
-@code{\arg\}
-@end macro
-@end ifnotinfo
+@include macros.texi
 
 @ifinfo
 @format
 START-INFO-DIR-ENTRY
 * Octave: (octave).           Interactive language for numerical computations.
 
 END-INFO-DIR-ENTRY
 @end format
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -879,17 +879,18 @@ Array<T>::index (const Array<idx_vector>
     }
 
   return retval;
 }
 
 // The default fill value.  Override if you want a different one.
 
 template <class T>
-const T& Array<T>::resize_fill_value ()
+T
+Array<T>::resize_fill_value (void) const
 {
   static T zero = T ();
   return zero;
 }
 
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
@@ -1159,26 +1160,31 @@ Array<T>::assign (const idx_vector& i, c
     gripe_invalid_assignment_size ();
 }
 
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
+  bool initial_dims_all_zero = dimensions.all_zero ();
+
   // Get RHS extents, discarding singletons.
   dim_vector rhdv = rhs.dims ();
+
   // Get LHS extents, allowing Fortran indexing in the second dim.
   dim_vector dv = dimensions.redim (2);
+
   // Check for out-of-bounds and form resizing dimensions.
   dim_vector rdv;
+
   // In the special when all dimensions are zero, colons are allowed
   // to inquire the shape of RHS.  The rules are more obscure, so we
   // solve that elsewhere.
-  if (dv.all_zero ())
+  if (initial_dims_all_zero)
     rdv = zero_dims_inquire (i, j, rhdv);
   else
     {
       rdv(0) = i.extent (dv(0));
       rdv(1) = j.extent (dv(1));
     }
 
   bool isfill = rhs.numel () == 1;
@@ -1262,29 +1268,31 @@ Array<T>::assign (const Array<idx_vector
 
   // FIXME: is this dispatching necessary / desirable?
   if (ial == 1)
     assign (ia(0), rhs, rfv);
   else if (ial == 2)
     assign (ia(0), ia(1), rhs, rfv);
   else if (ial > 0)
     {
+      bool initial_dims_all_zero = dimensions.all_zero ();
+
       // Get RHS extents, discarding singletons.
       dim_vector rhdv = rhs.dims ();
 
       // Get LHS extents, allowing Fortran indexing in the second dim.
       dim_vector dv = dimensions.redim (ial);
 
       // Get the extents forced by indexing.
       dim_vector rdv;
 
       // In the special when all dimensions are zero, colons are
       // allowed to inquire the shape of RHS.  The rules are more
       // obscure, so we solve that elsewhere.
-      if (dv.all_zero ())
+      if (initial_dims_all_zero)
         rdv = zero_dims_inquire (ia, rhdv);
       else
         {
           rdv = dim_vector::alloc (ial);
           for (int i = 0; i < ial; i++)
             rdv(i) = ia(i).extent (dv(i));
         }
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -445,56 +445,79 @@ public:
   // Indexing without resizing.
 
   Array<T> index (const idx_vector& i) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j) const;
 
   Array<T> index (const Array<idx_vector>& ia) const;
 
-  static const T& resize_fill_value ();
+  virtual T resize_fill_value (void) const;
 
   // Resizing (with fill).
 
-  void resize1 (octave_idx_type n, const T& rfv = resize_fill_value ());
+  void resize1 (octave_idx_type n, const T& rfv);
+  void resize1 (octave_idx_type n) { resize1 (n, resize_fill_value ()); }
 
-  void resize (octave_idx_type n) GCC_ATTR_DEPRECATED
-    { resize1 (n); }
+  void resize (octave_idx_type n) GCC_ATTR_DEPRECATED { resize1 (n); }
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               const T& rfv = resize_fill_value ()) GCC_ATTR_DEPRECATED
+  void resize (octave_idx_type nr, octave_idx_type nc, const T& rfv) GCC_ATTR_DEPRECATED
   {
     resize2 (nr, nc, rfv);
   }
 
-  void resize (const dim_vector& dv, const T& rfv = resize_fill_value ());
+  void resize (octave_idx_type nr, octave_idx_type nc) GCC_ATTR_DEPRECATED
+  {
+    resize2 (nr, nc, resize_fill_value ());
+  }
+
+  void resize (const dim_vector& dv, const T& rfv);
+  void resize (const dim_vector& dv) { resize (dv, resize_fill_value ()); }
 
   // Indexing with possible resizing and fill
   // FIXME -- this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
-  Array<T> index (const idx_vector& i, bool resize_ok,
-                  const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
+  Array<T> index (const idx_vector& i, bool resize_ok) const
+  {
+    return index (i, resize_ok, resize_fill_value ());
+  }
 
-  Array<T> index (const idx_vector& i, const idx_vector& j,
-                  bool resize_ok, const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok, const T& rfv) const;
+  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok) const
+  {
+    return index (i, j, resize_ok, resize_fill_value ());
+  }
 
-  Array<T> index (const Array<idx_vector>& ia,
-                  bool resize_ok, const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const Array<idx_vector>& ia, bool resize_ok, const T& rfv) const;
+  Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const
+  {
+    return index (ia, resize_ok, resize_fill_value ());
+  }
 
   // Indexed assignment (always with resize & fill).
 
-  void assign (const idx_vector& i, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);
+  void assign (const idx_vector& i, const Array<T>& rhs)
+  {
+    assign (i, rhs, resize_fill_value ());
+  }
 
-  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs, const T& rfv);
+  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs)
+  {
+    assign (i, j, rhs, resize_fill_value ());
+  }
 
-  void assign (const Array<idx_vector>& ia, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const Array<idx_vector>& ia, const Array<T>& rhs, const T& rfv);
+  void assign (const Array<idx_vector>& ia, const Array<T>& rhs)
+  {
+    assign (ia, rhs, resize_fill_value ());
+  }
 
   // Deleting elements.
 
   // A(I) = [] (with a single subscript)
   void delete_elements (const idx_vector& i);
 
   // A(:,...,I,...,:) = [] (>= 2 subscripts, one of them is non-colon)
   void delete_elements (int dim, const idx_vector& i);
@@ -667,18 +690,21 @@ public:
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
 private:
 
-  void resize2 (octave_idx_type nr, octave_idx_type nc,
-                const T& rfv = resize_fill_value ());
+  void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
+  void resize2 (octave_idx_type nr, octave_idx_type nc)                
+  {
+    resize2 (nr, nc, resize_fill_value ());
+  }
 
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
 // later type derived from it and override the default non-const operator() to
 // not check for the array's uniqueness. It is, however, the user's
 // responsibility to ensure the array is actually unaliased whenever elements
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -127,18 +127,17 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (n, 1); }
 
 };
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -147,17 +147,17 @@ public:
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
-               const Complex& rfv = resize_fill_value ())
+               const Complex& rfv = Complex (0))
   {
     MArray<Complex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int force, int calc_cond) const;
 
@@ -373,19 +373,16 @@ public:
 
   ComplexRowVector column_min (Array<octave_idx_type>& index) const;
   ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexMatrix& a);
-
-  static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
-
 };
 
 extern OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API ComplexMatrix
 operator * (const ColumnVector& a, const ComplexRowVector& b);
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -130,18 +130,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
-  static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
   ComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   ComplexNDArray& changesign (void)
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -107,18 +107,17 @@ public:
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
-  void resize (octave_idx_type n,
-               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (1, n); }
 
 };
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -77,26 +77,16 @@ template <class T>
 DiagArray2<T>
 DiagArray2<T>::hermitian (T (* fcn) (const T&)) const
 {
   return DiagArray2<T> (Array<T>::template map<T> (fcn), d2, d1);
 }
 
 // A two-dimensional array with diagonal elements only.
 
-template <typename T>
-void
-DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
-{
-  if (r < 0 || r >= dim1 ())
-    gripe_index_out_of_range (2, 1, r+1, dim1 ());
-  if (c < 0 || c >= dim2 ())
-    gripe_index_out_of_range (2, 2, c+1, dim2 ());
-}
-
 template <class T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
@@ -116,8 +106,29 @@ DiagArray2<T>::array_value (void) const
 {
   Array<T> result (dims (), T (0));
 
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
   return result;
 }
+
+template <typename T>
+bool
+DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
+{
+  bool ok = true;
+
+  if (r < 0 || r >= dim1 ())
+    {
+      gripe_index_out_of_range (2, 1, r+1, dim1 ());
+      ok = false;
+    }
+
+  if (c < 0 || c >= dim2 ())
+    {
+      gripe_index_out_of_range (2, 2, c+1, dim2 ());
+      ok = false;
+    }
+
+  return ok;
+}
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -114,58 +114,76 @@ public:
     }
 
   T dgelem (octave_idx_type i) const
     { return Array<T>::elem (i); }
 
   T& dgelem (octave_idx_type i)
     { return Array<T>::elem (i); }
 
-  void check_idx (octave_idx_type r, octave_idx_type c) const;
+  T checkelem (octave_idx_type r, octave_idx_type c) const
+    {
+      return check_idx (r, c) ? elem (r, c) : T (0);
+    }
 
   T operator () (octave_idx_type r, octave_idx_type c) const
     {
 #if defined (BOUNDS_CHECKING)
-      check_idx (r, c);
+      checkelem (r, c);
+#else
+      return elem (r, c);
 #endif
-      return elem (r, c);
+    }
+
+  T& checkelem (octave_idx_type r, octave_idx_type c)
+    {
+      static T zero (0);
+      return check_idx (r, c) ? elem (r, c) : zero;
     }
 
   T& operator () (octave_idx_type r, octave_idx_type c)
     {
 #if defined (BOUNDS_CHECKING)
-      check_idx (r, c);
+      return checkelem (r, c);
+#else
+      return elem (r, c);
 #endif
-      return elem (r, c);
     }
 
   // No checking.
 
   T xelem (octave_idx_type r, octave_idx_type c) const
     {
       return (r == c) ? Array<T>::xelem (r) : T (0);
     }
 
   T& dgxelem (octave_idx_type i)
     { return Array<T>::xelem (i); }
 
   T dgxelem (octave_idx_type i) const
     { return Array<T>::xelem (i); }
 
-  void resize (octave_idx_type n, octave_idx_type m,
-               const T& rfv = Array<T>::resize_fill_value ());
+  void resize (octave_idx_type n, octave_idx_type m, const T& rfv);
+  void resize (octave_idx_type n, octave_idx_type m)
+  {
+    resize (n, m, Array<T>::resize_fill_value ());
+  }
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   Array<T> array_value (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
 
   const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T *fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
     { Array<T>::print_info (os, prefix); }
+
+private:
+
+  bool check_idx (octave_idx_type r, octave_idx_type c) const;
 };
 
 #endif
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -79,24 +79,20 @@ public:
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               bool rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, bool rfv = false)
   {
     Array<bool>::resize (dim_vector (nr, nc), rfv);
   }
-
-  static bool resize_fill_value (void) { return false; }
-
 };
 
 MM_BOOL_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 MS_BOOL_OP_DECLS (boolMatrix, bool, OCTAVE_API)
 SM_BOOL_OP_DECLS (bool, boolMatrix, OCTAVE_API)
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 
 #endif
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -91,18 +91,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   // friend std::istream& operator >> (std::istream& is, NDArray& a);
 
-  static bool resize_fill_value (void) { return false; }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   boolNDArray diag (octave_idx_type k = 0) const;
 
   boolNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -81,36 +81,32 @@ public:
   charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               char rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, char rfv = 0)
   {
     Array<char>::resize (dim_vector (nr, nc), rfv);
   }
 
   charMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
-
-  static char resize_fill_value (void) { return '\0'; }
-
 };
 
 MS_CMP_OP_DECLS (charMatrix, char, OCTAVE_API)
 MS_BOOL_OP_DECLS (charMatrix, char, OCTAVE_API)
 
 SM_CMP_OP_DECLS (char, charMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (char, charMatrix, OCTAVE_API)
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -87,18 +87,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
-  static char resize_fill_value (void) { return '\0'; }
-
   charNDArray diag (octave_idx_type k = 0) const;
 
   charNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
 NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
 NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -94,18 +94,17 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const double& rfv = Array<double>::resize_fill_value ())
+  void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (n, 1); }
 
 };
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -120,18 +120,17 @@ public:
   Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               double rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, double rfv = 0)
   {
     MArray<double>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                    int force, int calc_cond) const;
 
@@ -329,18 +328,16 @@ public:
 
   RowVector column_min (Array<octave_idx_type>& index) const;
   RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Matrix& a);
-
-  static double resize_fill_value (void) { return 0; }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API Matrix real (const ComplexMatrix& a);
 extern OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -145,18 +145,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
-  static double resize_fill_value (void) { return 0; }
-
   NDArray diag (octave_idx_type k = 0) const;
 
   NDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   NDArray& changesign (void)
     {
       MArray<double>::changesign ();
       return *this;
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -87,18 +87,17 @@ public:
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
-  void resize (octave_idx_type n,
-               const double& rfv = Array<double>::resize_fill_value ())
+  void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (1, n); }
 
 };
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -267,26 +267,21 @@ dim_vector::redim (int n) const
   int n_dims = length ();
 
   if (n_dims == n)
     return *this;
   else if (n_dims < n)
     {
       dim_vector retval = alloc (n);
 
-      int pad = 0;
       for (int i = 0; i < n_dims; i++)
-        {
-          retval.rep[i] = rep[i];
-          if (rep[i] != 0)
-            pad = 1;
-        }
+        retval.rep[i] = rep[i];
 
       for (int i = n_dims; i < n; i++)
-        retval.rep[i] = pad;
+        retval.rep[i] = 1;
 
       return retval;
     }
   else
     {
       if (n < 1) n = 1;
 
       dim_vector retval = alloc (n);
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -376,18 +376,17 @@ public:
 
   // This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1).
   // The rules are more relaxed here.
   bool hvcat (const dim_vector& dvb, int dim);
 
   // Force certain dimensionality, preserving numel ().  Missing
   // dimensions are set to 1, redundant are folded into the trailing
   // one.  If n = 1, the result is 2d and the second dim is 1
-  // (dim_vectors are always at least 2D).  If the original dimensions
-  // were all zero, the padding value is zero.
+  // (dim_vectors are always at least 2D).
 
   dim_vector redim (int n) const;
 
   dim_vector as_column (void) const
     {
       if (length () == 2 && elem (1) == 1)
         return *this;
       else
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -129,18 +129,17 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (n, 1); }
 
 };
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -152,17 +152,17 @@ public:
 
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
-               const FloatComplex& rfv = resize_fill_value ())
+               const FloatComplex& rfv = FloatComplex (0))
   {
     MArray<FloatComplex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           float& rcon, int force, int calc_cond) const;
 
@@ -378,19 +378,16 @@ public:
 
   FloatComplexRowVector column_min (Array<octave_idx_type>& index) const;
   FloatComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexMatrix& a);
-
-  static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
-
 };
 
 extern OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatColumnVector& a, const FloatComplexRowVector& b);
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -130,18 +130,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexNDArray& a);
 
-  static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
   FloatComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatComplexNDArray& changesign (void)
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -111,18 +111,17 @@ public:
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
 
-  void resize (octave_idx_type n,
-               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (1, n); }
 
 };
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -97,18 +97,17 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const float& rfv = Array<float>::resize_fill_value ())
+  void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (n, 1); }
 
 };
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -121,18 +121,17 @@ public:
   FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               float rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, float rfv = 0)
   {
     MArray<float>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                    int force, int calc_cond) const;
 
@@ -329,19 +328,16 @@ public:
 
   FloatRowVector column_min (Array<octave_idx_type>& index) const;
   FloatRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatMatrix& a);
-
-  static float resize_fill_value (void) { return 0; }
-
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatMatrix real (const FloatComplexMatrix& a);
 extern OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -142,18 +142,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
-  static float resize_fill_value (void) { return 0; }
-
   FloatNDArray diag (octave_idx_type k = 0) const;
 
   FloatNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatNDArray& changesign (void)
     {
       MArray<float>::changesign ();
       return *this;
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -88,18 +88,17 @@ public:
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
 
-  void resize (octave_idx_type n,
-               const float& rfv = Array<float>::resize_fill_value ())
+  void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (1, n); }
 
 };
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -110,19 +110,16 @@ public:
   intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
-
-  static T resize_fill_value (void) { return 0; }
-
 };
 
 // i/o
 
 template <class T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
 template <class T>
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -83,17 +83,17 @@ public:
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
-  void resize (octave_idx_type n, const std::string& rfv = resize_fill_value ())
+  void resize (octave_idx_type n, const std::string& rfv = std::string ())
   {
     Array<std::string>::resize (dim_vector (n, 1), rfv);
   }
 
   std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
 
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -40,16 +40,17 @@ d3_list=`$FIND "$d3" -type d -a ! \( \( 
 
 d1_path=`echo "$d1_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 d2_path=`echo "$d2_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 d3_path=`echo "$d3_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 
 LOADPATH="$d1_path:$d2_path:$d3_path"
 IMAGEPATH="$top_srcdir/scripts/image"
 DOCFILE="$builddir/doc/interpreter/doc-cache"
+TEXIMACROSFILE="$top_srcdir/doc/interpreter/macros.texi"
 INFOFILE="$top_srcdir/doc/interpreter/octave.info"
 
 ## Checking for string equality below with prepended x's in order to
 ## handle problems with empty strings.
 if [ $# -gt 0 ]; then
   if [ "x$1" = "x-g" ]; then
     driver="gdb --args"
     shift
@@ -65,9 +66,9 @@ if [ $# -gt 0 ]; then
     shift
   fi
 fi
 
 OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
   exec $builddir/libtool --mode=execute $driver \
     "$builddir/src/octave" --no-init-path --path="$LOADPATH" \
     --image-path="$IMAGEPATH" --doc-cache-file="$DOCFILE" \
-    --info-file="$INFOFILE" "$@"
+    --texi-macros-file="$TEXIMACROSFILE" --info-file="$INFOFILE" "$@"
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -320,31 +320,27 @@ strings/$(octave_dirstamp):
 testfun/$(octave_dirstamp):
 	$(MKDIR_P) testfun
 	: > testfun/$(octave_dirstamp)
 time/$(octave_dirstamp):
 	$(MKDIR_P) time
 	: > time/$(octave_dirstamp)
 
 if AMCOND_BUILD_DOCS
-## Program compiled only to help build documentation.  No installation needed.
-noinst_PROGRAMS = gethelp
 
-gethelp_SOURCES = gethelp.cc
-
-.DOCSTRINGS: $(FCN_FILES) $(GEN_FCN_FILES) mkdoc $(gethelp_SOURCES) Makefile
-	@$(MAKE) $(AM_MAKEFLAGS) gethelp$(BUILD_EXEEXT)
+.DOCSTRINGS: $(FCN_FILES) $(GEN_FCN_FILES) mkdoc.pl Makefile
 	if [ "x$(srcdir)" != "x." ] && [ -f $(srcdir)/DOCSTRINGS ] && [ ! -f DOCSTRINGS ]; then \
 		cp $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 		touch -r $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 	fi
 	@echo "creating .DOCSTRINGS from .m script files"
-	@$(srcdir)/mkdoc "$(srcdir)" $(FCN_FILES) -- $(GEN_FCN_FILES) > $@
+	@$(PERL) $(srcdir)/mkdoc.pl "$(srcdir)" $(FCN_FILES) -- $(GEN_FCN_FILES) > $@
 	$(top_srcdir)/build-aux/move-if-change $@ DOCSTRINGS
 	touch $@
+
 endif
 
 $(GEN_FCN_FILES) : %.m : %.in Makefile
 	@$(do_subst_config_vals)
 
 check-m-sources:
 	@echo "checking whether files in source tree are listed in module.mk files..."; \
 	for f in $$(find $(srcdir) -name '*.m'); do \
@@ -422,17 +418,17 @@ uninstall-pkg-add:
 .PHONY: uninstall-pkg-add
 
 EXTRA_DIST += \
   $(IMAGES) \
   $(FCN_FILES) \
   $(FCN_FILES_IN) \
   $(GEN_FCN_FILES) \
   DOCSTRINGS \
-  mkdoc \
+  mkdoc.pl \
   mk-pkg-add
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
   DOCSTRINGS \
   $(PKG_ADD_FILES) \
   $(DIRSTAMP_FILES) \
   $(GEN_FCN_FILES)
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
deleted file mode 100644
--- a/scripts/gethelp.cc
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-
-Copyright (C) 1999-2012 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#include <cstdio>
-
-#include <iostream>
-#include <string>
-
-static bool
-looks_like_octave_copyright (const std::string& s)
-{
-  // Perhaps someday we will want to do more here, so leave this as a
-  // separate function.
-
-  return (s.substr (0, 9) == "Copyright" || s.substr (0, 6) == "Author");
-}
-
-// Eat whitespace and comments from FFILE, returning the text of the
-// first block of comments that doesn't look like a copyright notice,
-
-static std::string
-extract_help_text (void)
-{
-  std::string help_txt;
-
-  bool first_comments_seen = false;
-  bool begin_comment = false;
-  bool have_help_text = false;
-  bool in_comment = false;
-  bool discard_space = true;
-  int c;
-
-  while ((c = std::cin.get ()) != EOF)
-    {
-      if (begin_comment)
-        {
-          if (c == '%' || c == '#')
-            continue;
-          else if (discard_space && c == ' ')
-            {
-              discard_space = false;
-              continue;
-            }
-          else
-            begin_comment = false;
-        }
-
-      if (in_comment)
-        {
-          if (! have_help_text)
-            {
-              first_comments_seen = true;
-              help_txt += static_cast<char> (c);
-            }
-
-          if (c == '\n')
-            {
-              in_comment = false;
-              discard_space = true;
-
-              if ((c = std::cin.get ()) != EOF)
-                {
-                  if (c == '\n')
-                    break;
-                }
-              else
-                break;
-            }
-        }
-      else
-        {
-          switch (c)
-            {
-            case ' ':
-            case '\t':
-              if (first_comments_seen)
-                have_help_text = true;
-              break;
-
-            case '\n':
-              if (first_comments_seen)
-                have_help_text = true;
-              continue;
-
-            case '%':
-            case '#':
-              begin_comment = true;
-              in_comment = true;
-              break;
-
-            default:
-              goto done;
-            }
-        }
-    }
-
- done:
-
-  if (! help_txt.empty ())
-    {
-      if (looks_like_octave_copyright (help_txt))
-        help_txt.resize (0);
-
-      if (help_txt.empty ())
-        help_txt = extract_help_text ();
-    }
-
-  return help_txt;
-}
-
-int
-main (int argc, char **argv)
-{
-  std::string name;
-  std::string file_name;
-
-  if (argc != 3)
-    {
-      std::cerr << "usage: gethelp name file-name\n";
-      return 1;
-    }
-  else
-    {
-      name = argv[1];
-      file_name = argv[2];
-    }
-
-  std::string help_text = extract_help_text ();
-
-  if (! help_text.empty ())
-    {
-      std::cout << "" << name << "\n"
-                << "@c " << name << " " << file_name << "\n"
-                << help_text;
-
-      if (help_text[help_text.length () - 1] != '\n')
-        std::cout << "\n";
-    }
-
-  return 0;
-}
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -89,28 +89,25 @@ function [retval, status] = __makeinfo__
   ## Formatting in m-files has an extra space at the beginning of every line.
   ## Remove these unwanted spaces if present.  First text char is "\n" delim.
   if (text(2) == " ")
     text = strrep (text, "\n ", "\n");
   endif
   ## Texinfo crashes if @end tex does not appear first on the line.
   text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
-  ## Handle @seealso macro
-  see_also_pat = '@seealso *\{(.*)\}';
-  args = regexp (text, see_also_pat, 'tokens');
-  for ii = 1:numel (args)
-    expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
-    text = regexprep (text, see_also_pat, expanded, 'once');
-  endfor
-
-  ## Handle @nospell macro
-  text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
-  ## Handle @xcode macro
-  text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
+  file = texi_macros_file ();
+  fid = fopen (file, "r");
+  if (fid < 0)
+    error ("unable to open %s for reading", file);
+  else
+    macros_text = fread (fid, Inf, "*char")';
+    text = cstrcat (macros_text, text);
+  endif
+  fclose (fid);
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
 
   ## Create the final TeXinfo input string
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -36,17 +36,17 @@
 ## The first @var{value} number of lines of @var{filename} are skipped.
 ##
 ## @item "endofline":
 ## Specify a single character or "\r\n".  If no value is given, it will be
 ## inferred from the file.  If set to "" (empty string) EOLs are ignored as
 ## delimiters.
 ## @end itemize
 ##
-## The optional input @var{n} specifes the number of data lines to read; in
+## The optional input @var{n} specifies the number of data lines to read; in
 ## this sense it differs slightly from the format repeat count in strread.
 ##
 ## @seealso{strread, load, dlmread, fscanf, textscan}
 ## @end deftypefn
 
 function varargout = textread (filename, format = "%f", varargin)
 
   BUFLENGTH = 4096;       # Read buffer to speed up processing @var{n}
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -48,19 +48,19 @@
 ## The first @var{value} number of lines of @var{fid} are skipped.
 ##
 ## @item "returnonerror":
 ## If set to numerical 1 or true (default), return normally when read errors
 ## have been encountered.  If set to 0 or false, return an error and no data.
 ## @end itemize
 ##
 ## When reading from a character string, optional input argument @var{n}
-## specifes the number of times @var{format} should be used (i.e., to limit
+## specifies the number of times @var{format} should be used (i.e., to limit
 ## the amount of data read).
-## When reading fro file, @var{n} specifes the number of data lines to read;
+## When reading fro file, @var{n} specifies the number of data lines to read;
 ## in this sense it differs slightly from the format repeat count in strread.
 ##
 ## The output @var{C} is a cell array whose length is given by the number
 ## of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
new file mode 100755
--- /dev/null
+++ b/scripts/mkdoc.pl
@@ -0,0 +1,104 @@
+#! /usr/bin/perl -w
+#
+# Copyright (C) 2012 Rik Wehbring
+#
+# This file is part of Octave.
+#
+# Octave is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3 of the License, or (at
+# your option) any later version.
+#
+# Octave is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Octave; see the file COPYING.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+## Expecting arguments in this order:
+##
+##  SRCDIR SRCDIR-FILES ... -- LOCAL-FILES ...
+
+unless (@ARGV >= 2) { die "Usage: $0 srcdir m_filename1 ..." ; }
+
+$srcdir = shift (@ARGV) . '/';
+
+print <<__END_OF_MSG__;
+### DO NOT EDIT!
+###
+### This file is generated automatically from Octave source files.
+### Edit source files directly and run make to update this file.
+
+__END_OF_MSG__
+
+MFILE: foreach $m_fname (@ARGV)
+{
+  if ($m_fname eq "--")
+  {
+    $srcdir = "./";
+    next MFILE;
+  }
+
+  $full_fname = $srcdir . $m_fname;
+  next MFILE unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
+  if ($2) {
+    $fcn = "$2$3/$4";
+  } else {
+    $fcn = $4;
+  }
+
+  @help_txt = mygethelp ($fcn, $full_fname);
+  next MFILE if ($help_txt[0] eq "");
+
+  print "$fcn\n";
+  print "\@c $fcn scripts/$m_fname\n";
+
+  foreach $_ (@help_txt)
+  {
+    s/^\s+\@/\@/ unless $in_example;
+    s/^\s+\@group/\@group/;
+    s/^\s+\@end\s+group/\@end group/;
+    $in_example = (/\s*\@example\b/ .. /\s*\@end\s+example\b/);
+    print $_;
+  }
+}
+
+################################################################################
+# Subroutines
+################################################################################
+sub mygethelp
+{
+  ($fcn, $fname) = @_[0..1]; 
+  open (FH, $fname) or return "";
+
+  do
+  {
+    @help_txt = ();
+
+    ## Advance to non-blank line
+    while (defined ($_ = <FH>) and /^\s*$/) {;}
+
+    if (! /^\s*(?:#|%)/ or eof (FH))
+    {
+      ## No comment block found.  Return empty string
+      close (FH);
+      return "";
+    }
+
+    ## Extract help text stopping when comment block ends
+    do
+    {
+      ## Remove comment characters at start of line
+      s/^\s*(?:#|%){1,2} ?//;
+      push (@help_txt, $_);
+    } until (! defined ($_ = <FH>) or ! /^\s*(?:#|%)/);
+
+  } until ($help_txt[0] !~ /^(?:Copyright|Author)/); 
+
+  close (FH);
+
+  return @help_txt;
+}
diff --git a/scripts/pkg/private/get_unsatisfied_deps.m b/scripts/pkg/private/get_unsatisfied_deps.m
--- a/scripts/pkg/private/get_unsatisfied_deps.m
+++ b/scripts/pkg/private/get_unsatisfied_deps.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc},@var{installed_pkgs_lst})
+## @deftypefn {Function File} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc}, @var{installed_pkgs_lst})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function bad_deps = get_unsatisfied_deps (desc, installed_pkgs_lst)
   bad_deps = {};
 
   ## For each dependency.
   for i = 1:length (desc.depends)
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -144,17 +144,17 @@ function [nn, xx] = hist (y, varargin)
              (chist(end,:) - sum (isnan (y)))];
   endif
 
   freq = diff (chist);
 
   if (nargin > 2 && ! ischar (varargin{iarg}))
     ## Normalise the histogram.
     norm = varargin{iarg++};
-    freq = freq / rows (y) * norm;
+    freq = freq / sum(! isnan (y)) * norm;
   endif
 
   if (nargout > 0)
     if (arg_is_vector)
       nn = freq';
       xx = x';
     else
       nn = freq;
@@ -177,16 +177,20 @@ endfunction
 %! [nn,xx] = hist ([1:4]', 3);
 %! assert (xx, [1.5,2.5,3.5]);
 %! assert (nn, [2,1,1]);
 %!test
 %! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
 %! assert (xx, [1,2,3]);
 %! assert (nn, [3,2,1]);
 %!test
+%! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3], 6);
+%! assert (xx, [1,2,3]);
+%! assert (nn, [3,2,1]);
+%!test
 %! [nn,xx] = hist ([[1:4]', [1:4]'], 3);
 %! assert (xx, [1.5;2.5;3.5]);
 %! assert (nn, [[2,1,1]',[2,1,1]']);
 %!test
 %! for n = [10, 30, 100, 1000]
 %!   assert (sum (hist ([1:n], n)), n);
 %!   assert (sum (hist ([1:n], [2:n-1])), n);
 %!   assert (sum (hist ([1:n], [1:n])), n);
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -16,32 +16,32 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a graph, or save it to a file. Both output formatted for 
+## Print a graph, or save it to a file.  Both output formatted for 
 ## printing (PDF and PostScript), and many bitmapped and vector
 ## image formats are supported.
 ##
 ## @var{h} specifies the figure handle.  If no handle is specified
 ## the handle for the current figure is used.
 ##
 ## @var{filename} defines the name of the output file.  If the
 ## file name has no suffix, one is inferred from the specified
 ## device and appended to the file name.  If no filename is
 ## specified, the output is sent to the printer.
 ##
 ## For output to a printer, to a PostScript file, or a PDF file,
 ## the paper size is specified by the figure's @code{papersize}
-## property. The location and size of the image on the page are
-## specified by the figure's @code{paperposition} property. The
+## property.  The location and size of the image on the page are
+## specified by the figure's @code{paperposition} property.  The
 ## orientation of the page is specified by the figure's
 ## @code{paperorientation} property.
 ##
 ## The width and height of images are specified by the figure's
 ## @code{paperpositon(3:4)} property values.
 ##
 ## The @code{print} command supports several @var{options}:
 ##
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/shrinkfaces.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} shrinkfaces (@var{p}, @var{sf})
+## @deftypefn  {Function File} {} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{fv}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{f}, @var{v}, @var{sf})
 ## @deftypefnx {Function File} {[@var{nf}, @var{nv}] =} shrinkfaces (@dots{})
 ##
 ## Reduce the faces area for a given patch, structure or explicit faces
 ## and points matrices by a scale factor @var{sf}.  The structure
 ## @var{fv} must contain the fields 'faces' and 'vertices'.  If the
@@ -35,34 +35,34 @@
 ## If called with one output argument, return a structure with fields
 ## 'faces', 'vertices', and 'facevertexcdata' containing the data after
 ## shrinking which can then directly be used as an input argument for the
 ## @command{patch} function.
 ##
 ## Performing the shrinking on faces which are not convex can lead to
 ## undesired results.
 ##
-## For example
+## For example,
 ##
 ## @example
 ## @group
 ## [phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
 ## tri = delaunay (phi(:), r(:));
 ## v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
 ## clf ()
 ## p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
 ## fv = shrinkfaces (p);
 ## patch (fv)
 ## axis equal
 ## grid on
 ## @end group
 ## @end example
 ##
 ## @noindent
-## draws a triangulated 3/4 circle and the corresponding shrinked
+## draws a triangulated 3/4 circle and the corresponding shrunken
 ## version.
 ## @seealso{patch}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [nf, nv] = shrinkfaces (varargin)
 
diff --git a/scripts/plot/tetramesh.m b/scripts/plot/tetramesh.m
--- a/scripts/plot/tetramesh.m
+++ b/scripts/plot/tetramesh.m
@@ -12,19 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} tetramesh (@var{T}, @var{X})
-## @deftypefnx {Function File} tetramesh (@var{T}, @var{X}, @var{C})
-## @deftypefnx {Function File} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
+## @deftypefn  {Function File} {} tetramesh (@var{T}, @var{X})
+## @deftypefnx {Function File} {} tetramesh (@var{T}, @var{X}, @var{C})
+## @deftypefnx {Function File} {} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} tetramesh (@dots{})
 ##
 ## Display the tetrahedrons defined in the m-by-4 matrix @var{T}
 ## as 3-D patches.  @var{T} is typically the output of a Delaunay triangulation
 ## of a 3-D set of points.  Every row of @var{T} contains four indices into
 ## the n-by-3 matrix @var{X} of the vertices of a tetrahedron.  Every row in
 ## @var{X} represents one point in 3-D space. 
 ##
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit to the points
-## @code{[@var{x}, @var{y}]}. If @var{n} is a logical vector, it is used
+## @code{[@var{x}, @var{y}]}.  If @var{n} is a logical vector, it is used
 ## as a mask to selectively force the corresponding polynomial
 ## coefficients to be used or ignored.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
@@ -48,17 +48,17 @@
 ## @item normr
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
 ## @end table
 ##
 ## The second output may be used by @code{polyval} to calculate the
-## statistical error limits of the predicted values. In particular, the
+## statistical error limits of the predicted values.  In particular, the
 ## standard deviation of @var{p} coefficients is given by @*
 ## @code{sqrt (diag (s.C)/s.df)*s.normr}.
 ##
 ## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -12,39 +12,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{breaks})
-## Fits a piecewise cubic spline with breaks (knots) @var{breaks} to the
+## @deftypefn {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{breaks})
+## Fit a piecewise cubic spline with breaks (knots) @var{breaks} to the
 ## noisy data, @var{x} and @var{y}.  @var{x} is a vector, and @var{y}
-## a vector or ND array.  If @var{y} is an ND array, then @var{x}(j)
-## is matched to @var{y}(:,...,:,j).
+## a vector or N-D array.  If @var{y} is an N-D array, then @var{x}(j)
+## is matched to @var{y}(:,@dots{},:,j).
 ##
-## The fitted spline is returned as a piece-wise polynomial, @var{pp}, and
+## The fitted spline is returned as a piecewise polynomial, @var{pp}, and
 ## may be evaluated using @code{ppval}.
 ##
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{p})
 ## @var{p} is a positive integer defining the number of intervals along @var{x},
-## and @var{p}+1 is the number of breaks. The number of points in each interval
+## and @var{p}+1 is the number of breaks.  The number of points in each interval
 ## differ by no more than 1.
 ##
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "periodic", @var{periodic})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "robust", @var{robust})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "beta", @var{beta})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "order", @var{order})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
 ##
 ## The optional property @var{periodic} is a logical value which specifies
 ## whether a periodic boundary condition is applied to the spline.  The
-## length of the period  is @code{max(@var{breaks})-min(@var{breaks})}.
+## length of the period is @code{max(@var{breaks})-min(@var{breaks})}.
 ## The default value is @code{false}.
 ##
 ## The optional property @var{robust} is a logical value which specifies
 ## if robust fitting is to be applied to reduce the influence of outlying
 ## data points.  Three iterations of weighted least squares are performed.
 ## Weights are computed from previous residuals.  The sensitivity of outlier
 ## identification is controlled by the property @var{beta}.  The value of
 ## @var{beta} is stricted to the range, 0 < @var{beta} < 1.  The default
@@ -60,22 +60,24 @@
 ##
 ## The optional property, @var{constaints}, is a structure specifying
 ## linear constraints on the fit.  The structure has three fields, "xc",
 ## "yc", and "cc".
 ##
 ## @table @asis
 ## @item "xc"
 ## Vector of the x-locations of the constraints.
+##
 ## @item "yc"
-## Constaining values at the locations, @var{xc}.
+## Constraining values at the locations, @var{xc}.
 ## The default is an array of zeros.
+##
 ## @item "cc"
 ## Coefficients (matrix).  The default is an array of ones.  The number of
-## rows is limited to the order of the piece-wise polynomials, @var{order}.
+## rows is limited to the order of the piecewise polynomials, @var{order}.
 ## @end table
 ##
 ## Constraints are linear combinations of derivatives of order 0 to
 ## @var{order}-1 according to
 ##
 ## @example
 ## @group
 ## @tex
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -10,17 +10,16 @@
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given
 ## or set to [] the default value 1e-6 is used.
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -13,17 +13,16 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the stabilizied Bi-conjugate gradient iterative
 ## method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -13,17 +13,16 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b}, where @var{A} is a square matrix, using the
 ## Conjugate Gradients Squared method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to []
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -92,17 +92,17 @@ Cell::Cell (const Array<std::string>& sa
   for (octave_idx_type i = 0; i < n; i++)
     dst[i] = src[i];
 }
 
 // Set size to DV, filling with [].  Then fill with as many elements of
 // SV as possible.
 
 Cell::Cell (const dim_vector& dv, const string_vector& sv, bool trim)
-  : Array<octave_value> (dv, resize_fill_value ())
+  : Array<octave_value> (dv, Matrix ())
 {
   octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
       octave_idx_type len = n > m ? m : n;
@@ -168,32 +168,30 @@ Cell::index (const octave_value_list& id
       retval = *this;
       break;
 
     case 1:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
-          retval = Array<octave_value>::index (i, resize_ok,
-                                               resize_fill_value ());
+          retval = Array<octave_value>::index (i, resize_ok, Matrix ());
       }
       break;
 
     case 2:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
           {
             idx_vector j = idx_arg(1).index_vector ();
 
             if (! error_state)
-              retval = Array<octave_value>::index (i, j, resize_ok,
-                                                    resize_fill_value ());
+              retval = Array<octave_value>::index (i, j, resize_ok, Matrix ());
           }
       }
       break;
 
     default:
       {
         Array<idx_vector> iv (dim_vector (n, 1));
 
@@ -201,18 +199,17 @@ Cell::index (const octave_value_list& id
           {
             iv(i) = idx_arg(i).index_vector ();
 
             if (error_state)
               break;
           }
 
         if (!error_state)
-          retval = Array<octave_value>::index (iv, resize_ok,
-                                                resize_fill_value ());
+          retval = Array<octave_value>::index (iv, resize_ok, Matrix ());
       }
       break;
     }
 
   return retval;
 }
 
 void
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -43,20 +43,20 @@ public:
     : Array<octave_value> (dim_vector (0, 0)) { }
 
   Cell (const octave_value& val)
     : Array<octave_value> (dim_vector (1, 1), val) { }
 
   Cell (const octave_value_list& ovl);
 
   Cell (octave_idx_type n, octave_idx_type m,
-        const octave_value& val = resize_fill_value ())
+        const octave_value& val = Matrix ())
     : Array<octave_value> (dim_vector (n, m), val) { }
 
-  Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
+  Cell (const dim_vector& dv, const octave_value& val = Matrix ())
     : Array<octave_value> (dv, val) { }
 
   Cell (const Array<octave_value>& c)
     : Array<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c, octave_idx_type nr, octave_idx_type nc)
     : Array<octave_value> (c, dim_vector (nr, nc)) { }
 
@@ -81,17 +81,17 @@ public:
 
   using Array<octave_value>::delete_elements;
 
   void delete_elements (const octave_value_list& idx);
 
   using Array<octave_value>::assign;
 
   void assign (const octave_value_list& idx, const Cell& rhs,
-               const octave_value& fill_val = resize_fill_value ());
+               const octave_value& fill_val = Matrix ());
 
   Cell reshape (const dim_vector& new_dims) const
     { return Array<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
@@ -105,17 +105,21 @@ public:
 
   Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
   Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
-  static octave_value resize_fill_value (void) { return Matrix (); }
+  octave_value resize_fill_value (void) const
+  {
+    static Matrix rfv;
+    return rfv;
+  }
 
   Cell diag (octave_idx_type k = 0) const;
 
   Cell diag (octave_idx_type m, octave_idx_type n) const;
 
   Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
   Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
   Cell xisascii (void) const { return map (&octave_value::xisascii); }
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -124,19 +124,19 @@ Called with either a sparse or full matr
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-For full matrices, if the \"lower\" flag is set only the lower triangular part\n\
-of the matrix is used for the factorization, otherwise the upper triangular\n\
-part is used.\n\
+For full matrices, if the \"lower\" flag is set only the lower triangular\n\
+part of the matrix is used for the factorization, otherwise the upper\n\
+triangular part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -618,27 +618,29 @@ using @code{inv}.\n\
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
+\n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
 if @var{op} is \"+\"\n\
 \n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'\n\
 if @var{op} is \"-\"\n\
 @end itemize\n\
 \n\
 If @var{op} is \"-\", @var{info} is set to\n\
+\n\
 @itemize\n\
 @item 0 if the downdate was successful,\n\
 \n\
 @item 1 if @var{R}'*@var{R} - @var{u}*@var{u}' is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
@@ -828,16 +830,17 @@ DEFUN_DLD (cholinsert, args, nargout,
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
+\n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
 \n\
 @item 1 if @var{A1} is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -353,17 +353,20 @@ rand (\"state\", v)\n\
 \n\
 @noindent\n\
 You may also initialize the state vector from an arbitrary vector of\n\
 length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
 available, otherwise from CPU time, wall clock time, and the current\n\
-fraction of a second.\n\
+fraction of a second.  Note that this differs from @sc{matlab}, which\n\
+always initializes the state to the same state at startup.  To obtain\n\
+behavior comparable to @sc{matlab}, initialize with a deterministic state\n\
+vector in Octave's startup files (@pxref{Startup Files}).\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
 Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and\n\
 T. Nishimura,\n\
 @cite{Mersenne Twister: A 623-dimensionally equidistributed uniform\n\
 pseudorandom number generator}, ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,\n\
 @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -5472,17 +5472,17 @@ This function and @w{@xcode{x ^ y}} are 
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x \\ y}} are equivalent.\n\
+This function and @w{@xcode{x @xbackslashchar{} y}} are equivalent.\n\
 @seealso{mrdivide, ldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
   "-*- texinfo -*-\n\
@@ -5589,17 +5589,17 @@ This function and @w{@xcode{x .^ y}} are
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x .\\ y}} are equivalent.\n\
+This function and @w{@xcode{x .@xbackslashchar{} y}} are equivalent.\n\
 @seealso{rdivide, mldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -289,16 +289,26 @@ set_default_doc_cache_file (void)
   std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
 
   std::string env_file = octave_env::getenv ("OCTAVE_DOC_CACHE_FILE");
 
   Vdoc_cache_file = env_file.empty () ? def_file : env_file;
 }
 
 static void
+set_default_texi_macros_file (void)
+{
+  std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
+
+  std::string env_file = octave_env::getenv ("OCTAVE_TEXI_MACROS_FILE");
+
+  Vtexi_macros_file = env_file.empty () ? def_file : env_file;
+}
+
+static void
 set_default_info_file (void)
 {
   std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
   std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
 
   Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
 }
@@ -388,16 +398,18 @@ install_defaults (void)
   set_default_bin_dir ();
 
   set_exec_path ();
 
   set_image_path ();
 
   set_default_doc_cache_file ();
 
+  set_default_texi_macros_file ();
+
   set_default_info_file ();
 
   set_default_info_prog ();
 
   set_default_editor ();
 
   set_local_site_defaults_file ();
 
diff --git a/src/defaults.in.h b/src/defaults.in.h
--- a/src/defaults.in.h
+++ b/src/defaults.in.h
@@ -51,16 +51,20 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_DATAROOTDIR
 #define OCTAVE_DATAROOTDIR %OCTAVE_DATAROOTDIR%
 #endif
 
 #ifndef OCTAVE_DOC_CACHE_FILE
 #define OCTAVE_DOC_CACHE_FILE %OCTAVE_DOC_CACHE_FILE%
 #endif
 
+#ifndef OCTAVE_TEXI_MACROS_FILE
+#define OCTAVE_TEXI_MACROS_FILE %OCTAVE_TEXI_MACROS_FILE%
+#endif
+
 #ifndef OCTAVE_EXEC_PREFIX
 #define OCTAVE_EXEC_PREFIX %OCTAVE_EXEC_PREFIX%
 #endif
 
 #ifndef OCTAVE_FCNFILEDIR
 #define OCTAVE_FCNFILEDIR %OCTAVE_FCNFILEDIR%
 #endif
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -66,16 +66,21 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "version.h"
 #include "quit.h"
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
 std::string Vdoc_cache_file;
 
+// Name of the file containing local Texinfo macros that are prepended
+// to doc strings before processing.
+// (--texi-macros-file)
+std::string Vtexi_macros_file;
+
 // Name of the info file specified on command line.
 // (--info-file file)
 std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 std::string Vinfo_program;
 
@@ -1286,16 +1291,40 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
+DEFUN (texi_macros_file, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} texi_macros_file ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} texi_macros_file (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} texi_macros_file (@var{new_val}, \"local\")\n\
+Query or set the internal variable that specifies the name of the\n\
+file containing Texinfo macros that are prepended to documentation strings\n\
+before they are passed to makeinfo.  The default value is \n\
+@file{@var{octave-home}/share/octave/@var{version}/etc/macros.texi},\n\
+in which @var{octave-home} is the root directory of the Octave installation,\n\
+and @var{version} is the Octave version number.\n\
+The default value may be overridden by the environment variable\n\
+@w{@env{OCTAVE_TEXI_MACROS_FILE}}, or the command line argument\n\
+@samp{--texi-macros-file NAME}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{makeinfo_program}\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
+}
+
 DEFUN (info_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} info_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
@@ -1344,17 +1373,17 @@ DEFUN (makeinfo_program, args, nargout,
 @deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
-@seealso{info_file, info_program, doc, help}\n\
+@seealso{texi_macros_file, info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -31,16 +31,21 @@ class string_vector;
 extern string_vector make_name_list (void);
 
 extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
 extern std::string Vdoc_cache_file;
 
+// Name of the file containing local Texinfo macros that are prepended
+// to doc strings before processing.
+// (--texi-macros-file)
+extern std::string Vtexi_macros_file;
+
 // Name of the info file specified on command line.
 // (--info-file file)
 extern std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 extern std::string Vinfo_program;
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -552,17 +552,17 @@ void
 octave_map::resize (const dim_vector& dv, bool fill)
 {
   octave_idx_type nf = nfields ();
   if (nf > 0)
     {
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (fill)
-            xvals[i].resize (dv, Cell::resize_fill_value ());
+            xvals[i].resize (dv, Matrix ());
           else
             xvals[i].resize (dv);
         }
     }
   else
     {
       // FIXME: Do it with a dummy array, to reuse error message.
       // Need (?) a better solution.
@@ -1155,17 +1155,17 @@ octave_map::assign (const octave_value_l
   if (! error_state && ref.dims () != dimensions)
     {
       dimensions = ref.dims ();
 
       octave_idx_type nf = nfields ();
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (&xvals[i] != &ref)
-            xvals[i].resize (dimensions, Cell::resize_fill_value ());
+            xvals[i].resize (dimensions, Matrix ());
         }
 
       optimize_dimensions ();
     }
 
   if (! error_state && &ref == &tmp)
     setfield (k, tmp);
 }
@@ -1484,17 +1484,17 @@ Octave_map::resize (const dim_vector& dv
         dimensions = dv;
       else
         {
           for (const_iterator p = begin (); p != end (); p++)
             {
               Cell tmp = contents(p);
 
               if (fill)
-                tmp.resize (dv, Cell::resize_fill_value ());
+                tmp.resize (dv, Matrix ());
               else
                 tmp.resize (dv);
 
               dimensions = dv;
 
               assign (key(p), tmp);
             }
         }
@@ -1664,17 +1664,17 @@ Octave_map::assign (const octave_value_l
 
   if (! error_state)
     {
       dim_vector tmp_dims = tmp.dims ();
 
       if (tmp_dims != dimensions)
         {
           for (iterator p = begin (); p != end (); p++)
-            contents(p).resize (tmp_dims, Cell::resize_fill_value ());
+            contents(p).resize (tmp_dims, Matrix ());
 
           dimensions = tmp_dims;
         }
 
       maybe_add_to_key_list (k);
 
       map[k] = tmp;
     }
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -86,18 +86,17 @@ public:
   octave_value& operator () (octave_idx_type n) { return elem (n); }
 
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
   octave_idx_type length (void) const { return data.length (); }
 
   bool empty (void) const { return length () == 0; }
 
-  void resize (octave_idx_type n, const octave_value& rfv
-               = Array<octave_value>::resize_fill_value ())
+  void resize (octave_idx_type n, const octave_value& rfv = octave_value ())
   {
     data.resize (dim_vector (1, n), rfv);
   }
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -145,17 +145,18 @@ static bool persist = false;
 #define INFO_PROG_OPTION 6
 #define LINE_EDITING_OPTION 7
 #define NO_INIT_FILE_OPTION 8
 #define NO_INIT_PATH_OPTION 9
 #define NO_LINE_EDITING_OPTION 10
 #define NO_SITE_FILE_OPTION 11
 #define NO_WINDOW_SYSTEM_OPTION 12
 #define PERSIST_OPTION 13
-#define TRADITIONAL_OPTION 14
+#define TEXI_MACROS_FILE_OPTION 14
+#define TRADITIONAL_OPTION 15
 struct option long_opts[] =
   {
     { "braindead",        no_argument,       0, TRADITIONAL_OPTION },
     { "debug",            no_argument,       0, 'd' },
     { "doc-cache-file",   required_argument, 0, DOC_CACHE_FILE_OPTION },
     { "echo-commands",    no_argument,       0, 'x' },
     { "eval",             required_argument, 0, EVAL_OPTION },
     { "exec-path",        required_argument, 0, EXEC_PATH_OPTION },
@@ -171,16 +172,17 @@ struct option long_opts[] =
     { "no-line-editing",  no_argument,       0, NO_LINE_EDITING_OPTION },
     { "no-site-file",     no_argument,       0, NO_SITE_FILE_OPTION },
     { "no-window-system", no_argument,       0, NO_WINDOW_SYSTEM_OPTION },
     { "norc",             no_argument,       0, 'f' },
     { "path",             required_argument, 0, 'p' },
     { "persist",          no_argument,       0, PERSIST_OPTION },
     { "quiet",            no_argument,       0, 'q' },
     { "silent",           no_argument,       0, 'q' },
+    { "texi-macros-file", required_argument, 0, TEXI_MACROS_FILE_OPTION },
     { "traditional",      no_argument,       0, TRADITIONAL_OPTION },
     { "verbose",          no_argument,       0, 'V' },
     { "version",          no_argument,       0, 'v' },
     { 0,                  0,                 0, 0 }
   };
 
 // Store the command-line options for later use.
 
@@ -529,16 +531,17 @@ Options:\n\
   --no-init-path          Don't initialize function search path.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
   --no-window-system      Disable window system, including graphics.\n\
   --norc, -f              Don't read any initialization files.\n\
   --path PATH, -p PATH    Add PATH to head of function search path.\n\
   --persist               Go interactive after --eval or reading from FILE.\n\
   --silent, -q            Don't print message at startup.\n\
+  --texi-macros-file FILE Use Texinfo macros in FILE for makeinfo command.\n\
   --traditional           Set variables for closer MATLAB compatibility.\n\
   --verbose, -V           Enable verbose output in some cases.\n\
   --version, -v           Print version number and exit.\n\
 \n\
   FILE                    Execute commands from FILE.  Exit when done\n\
                           unless --persist is also specified.\n\
 \n"
 OCTAVE_WWW_STATEMENT "\n\
@@ -806,16 +809,21 @@ octave_main (int argc, char **argv, int 
         case NO_WINDOW_SYSTEM_OPTION:
           display_info::no_window_system ();
           break;
 
         case PERSIST_OPTION:
           persist = true;
           break;
 
+        case TEXI_MACROS_FILE_OPTION:
+          if (optarg)
+            bind_internal_variable ("texi_macros_file", optarg);
+          break;
+
         case TRADITIONAL_OPTION:
           traditional = true;
           break;
 
         default:
           // getopt_long should print a message about unrecognized
           // options and return '?', which is handled above.  So if we
           // end up here, it is because there was an option but we
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -220,17 +220,17 @@ octave_complex::float_complex_array_valu
   return FloatComplexNDArray (dim_vector (1, 1), static_cast<FloatComplex> (scalar));
 }
 
 octave_value
 octave_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      ComplexNDArray retval (dv, ComplexNDArray::resize_fill_value ());
+      ComplexNDArray retval (dv, Complex (0));
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -74,17 +74,17 @@ octave_float_scalar::do_index_op (const 
   return tmp.do_index_op (idx, resize_ok);
 }
 
 octave_value
 octave_float_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      FloatNDArray retval (dv, NDArray::resize_fill_value());
+      FloatNDArray retval (dv, 0);
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -205,17 +205,17 @@ octave_float_complex::float_complex_arra
   return FloatComplexNDArray (dim_vector (1, 1), scalar);
 }
 
 octave_value
 octave_float_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      FloatComplexNDArray retval (dv, FloatComplexNDArray::resize_fill_value ());
+      FloatComplexNDArray retval (dv, FloatComplex (0));
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -330,17 +330,17 @@ octave_range::bool_array_value (bool war
   return boolNDArray (m);
 }
 
 octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
 {
   NDArray retval = array_value ();
   if (fill)
-    retval.resize (dv, NDArray::resize_fill_value ());
+    retval.resize (dv, 0);
   else
     retval.resize (dv);
   return retval;
 }
 
 octave_value
 octave_range::convert_to_str_internal (bool pad, bool force, char type) const
 {
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -89,17 +89,17 @@ octave_scalar::do_index_op (const octave
   return tmp.do_index_op (idx, resize_ok);
 }
 
 octave_value
 octave_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      NDArray retval (dv, NDArray::resize_fill_value());
+      NDArray retval (dv, 0);
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -138,17 +138,17 @@ octave_char_matrix_str::do_index_op_inte
   return retval;
 }
 
 octave_value
 octave_char_matrix_str::resize (const dim_vector& dv, bool fill) const
 {
   charNDArray retval (matrix);
   if (fill)
-    retval.resize (dv, charNDArray::resize_fill_value ());
+    retval.resize (dv, 0);
   else
     retval.resize (dv);
   return octave_value (retval, is_sq_string () ? '\'' : '"');
 }
 
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2128,16 +2128,18 @@ A(1)\n\
 %! vals = mat2cell (rand (100,1), ones (100,1), 1)';
 %! s = struct ([keys; vals]{:});
 %! t = cell2struct (vals, keys, 2);
 %! assert (s, t);
 %! assert (struct2cell (s), vals');
 %! assert (fieldnames (s), keys');
 
 %!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
+
+%!assert (cell2struct ({}, {"f"}, 3), struct ("f", {}));
 */
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -73,17 +73,17 @@ of real of complex values @var{sv}, over
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
 compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified\n\
 their values are derived from the maximum index in the vectors @var{i} and\n\
 @var{j} as given by @code{@var{m} = max (@var{i})},\n\
 @code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
-be added. See @code{accumarray} for an example of how to produce different\n\
+be added.  See @code{accumarray} for an example of how to produce different\n\
 behavior, such as taking the minimum instead.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
 @group\n\
 s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
