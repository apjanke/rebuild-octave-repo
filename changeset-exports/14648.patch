# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1337327963 -7200
#      Fri May 18 09:59:23 2012 +0200
# Branch gui
# Node ID c8d0095b374456839ea4ab6f57d77fa5ab7bf20e
# Parent  c2ca3b71cd7c4513cfe9967bfda4b116183aa7a5
# Parent  7c463e49006209079f9ca83bb6f5d0169ff9c089
maint: periodic merge with default.

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -59,8 +59,9 @@ a737b3fb9c4d89d3694da6b4e623aeee64b212e1
 72aebe6196414e38ef802469ff6e238f914f04c9 rc-3-6-0-0
 64d9f33313cc8c691974bcd123357e24bccbabdc rc-3-6-0-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3.6.0
 95c43fc8dbe1a07a46fefb3372df5b2309d874fd rc-3-6-1-0
 0000000000000000000000000000000000000000 release-3-2-4
 e320928eeb3aa2370b792e83dafc3e0ddecdc871 release-3-2-4
 ba4d6343524b406b0d15aee34579f80783581c54 release-3-6-1
 704f7895eef03008dd79848eb9da4bfb40787d73 release-3-6-0
+f947d2922febf12dcd1fb6e21b356756ecb54e55 rc-3-6-2-0
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -89,16 +89,21 @@ Summary of important user-visible change
       <none yet>
 
     The following keywords have been deprecated in Octave 3.8 and will
     be removed from Octave 3.12 (or whatever version is the second major
     release after 3.8):
 
       static
 
+ ** The colormap function now provides new options "list", "register",
+    and "unregister" to list all available colormap functions, and to
+    add or remove a function name from teh list of known colormap
+    functions.  Packages that implement extra colormaps should use these
+    commands with PKG_ADD and PKG_DEL statements.
 
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
  ** The PCRE library is now required to build Octave.  If a pre-compiled
     package does not exist for your system, you can find PCRE sources
     at http://www.pcre.org
 
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -337,16 +337,19 @@ includedir = @includedir@
 # have.  The default is ${prefix}/man/man1
 mandir = @mandir@
 man1dir = @man1dir@
 man1ext = @man1ext@
 
 # The full path to the default doc cache file.
 doc_cache_file = @doc_cache_file@
 
+# The full path to the default texi macros file.
+texi_macros_file_file = @texi_macros_file@
+
 # Where to install and expect the info files describing Octave..
 infodir = @infodir@
 
 # The full path to the default info file.
 infofile = @infofile@
 
 # ==================== Octave-specific directories ====================
 
@@ -627,16 +630,17 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_OCTFILEDIR%|\"${octfiledir}\"|" \
   -e "s|%OCTAVE_OCTETCDIR%|\"${octetcdir}\"|" \
   -e "s|%OCTAVE_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_OCTLIBDIR%|\"${octlibdir}\"|" \
   -e "s|%OCTAVE_STARTUPFILEDIR%|\"${startupfiledir}\"|" \
   -e "s|%OCTAVE_PREFIX%|\"${prefix}\"|" \
   -e "s|%OCTAVE_API_VERSION%|\"${api_version}\"|" \
   -e "s|%OCTAVE_RELEASE%|\"${OCTAVE_RELEASE}\"|" \
+  -e "s|%OCTAVE_TEXI_MACROS_FILE%|\"${texi_macros_file}\"|" \
   -e "s|%OCTAVE_VERSION%|\"${version}\"|"
 $(simple_move_if_change_rule)
 endef
 
 define do_subst_script_vals
 echo "making $@ from $<"
 $(SED) < $< \
   -e "s|%AWK%|${AWK}|g" \
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -113,16 +113,17 @@ AC_SUBST(sepchar)
 AC_DEFINE_UNQUOTED(SEPCHAR, ['$sepchar'], [Define this to be the path separator for your system, as a character constant.])
 AC_DEFINE_UNQUOTED(SEPCHAR_STR, ["$sepchar"], [Define this to the path separator, as a string.])
 
 ### some defaults
 
 OCTAVE_SET_DEFAULT(man1dir, '$(mandir)/man1')
 OCTAVE_SET_DEFAULT(man1ext, '.1')
 OCTAVE_SET_DEFAULT(doc_cache_file, '$(octetcdir)/doc-cache')
+OCTAVE_SET_DEFAULT(texi_macros_file, '$(octetcdir)/macros.texi')
 OCTAVE_SET_DEFAULT(infofile, '$(infodir)/octave.info')
 OCTAVE_SET_DEFAULT(octincludedir, '$(includedir)/octave-$(version)/octave')
 OCTAVE_SET_DEFAULT(fcnfiledir, '$(datadir)/octave/$(version)/m')
 OCTAVE_SET_DEFAULT(localfcnfiledir, '$(datadir)/octave/site/m')
 OCTAVE_SET_DEFAULT(localapifcnfiledir,
   '$(datadir)/octave/site/$(api_version)/m')
 OCTAVE_SET_DEFAULT(localverfcnfiledir, '$(datadir)/octave/$(version)/site/m')
 OCTAVE_SET_DEFAULT(octetcdir, '$(datadir)/octave/$(version)/etc')
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -174,33 +174,27 @@ all-local: dvi html pdf ps doc-cache $(H
 # Prevent packaging of distribution unless all libraries 
 # necessary to create documentation are present
 dist-hook:
 	@$(GREP) '#define HAVE_COLAMD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing COLAMD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_CHOLMOD 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing CHOLMOD library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_UMFPACK 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing UMFPACK library.  Cannot package distribution!" ; exit 1; }
 	@$(GREP) '#define HAVE_QHULL 1' $(top_builddir)/config.h > /dev/null || { echo "Documentation creation requires missing QHULL library.  Cannot package distribution!" ; exit 1; }
 
-octetc_DATA = doc-cache
+octetc_DATA = doc-cache macros.texi
 
 DOCSTRING_FILES = $(shell $(srcdir)/find-docstring-files.sh "$(top_srcdir)")
 
 doc-cache: $(DOCSTRING_FILES) mk_doc_cache.m
-	$(top_builddir)/run-octave -f -q -H $(srcdir)/mk_doc_cache.m doc-cache $(DOCSTRING_FILES) || { rm -f doc-cache; exit 1; }
-
-## Program compiled only to help build documentation.  No need to install
-noinst_PROGRAMS = munge-texi
-
-munge_texi_SOURCES = munge-texi.cc
+	$(top_builddir)/run-octave -f -q -H $(srcdir)/mk_doc_cache.m doc-cache $(srcdir)/macros.texi $(DOCSTRING_FILES) || { rm -f doc-cache; exit 1; }
 
 $(MUNGED_TEXI_SRC): $(DOCSTRING_FILES) $(munge_texi_SOURCES)
 
-%.texi: %.txi
-	@$(MAKE) $(AM_MAKEFLAGS) munge-texi$(BUILD_EXEEXT)
-	./munge-texi $(top_srcdir) $(DOCSTRING_FILES) < $< > $@-t
+%.texi: %.txi munge-texi.pl
+	$(PERL) $(srcdir)/munge-texi.pl $(top_srcdir) $(DOCSTRING_FILES) < $< > $@-t
 	mv $@-t $@
 
 contributors.texi: contributors.in
 	$(AWK) -f $(srcdir)/mkcontrib.awk $(srcdir)/contributors.in > $@-t
 	mv $@-t $@
 
 ../../AUTHORS: preface.texi contributors.texi
 	rm -f AUTHORS
@@ -248,16 +242,17 @@ EXTRA_DIST = \
   config-images.sh \
   contributors.in \
   find-docstring-files.sh \
   images \
   images.awk \
   images.mk \
   mk_doc_cache.m \
   mkcontrib.awk \
+  munge-texi.pl \
   octave.dvi \
   octave.html \
   octave.pdf \
   octave.ps \
   $(IMAGES) \
   $(IMAGES_SRC) \
   $(LOGOS) \
   $(TXI_SRC)
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -384,16 +384,18 @@ for displaying the documentation, and wh
 found.
 
 @DOCSTRING(info_file)
 
 @DOCSTRING(info_program)
 
 @DOCSTRING(makeinfo_program)
 
+@DOCSTRING(texi_macros_file)
+
 @DOCSTRING(doc_cache_file)
 
 @DOCSTRING(suppress_verbose_help_message)
 
 The following functions are principally used internally by Octave for
 generating the documentation.  They are documented here for completeness
 and because they may occasionally be useful for users.
 
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -529,16 +529,17 @@ lvalue
 lvl
 lx
 ly
 lz
 Magnus
 Mahalanobis
 makefile
 makefiles
+makeinfo
 Mandriva
 MANOVA
 manova
 Marsaglia
 Maschhoff
 matchcase
 matlab
 Matsumoto
@@ -857,16 +858,17 @@ Stepleman
 stepsize
 STFT
 STL
 stochastically
 strcmp
 stringanchors
 strncmp
 strncmpi
+strread
 struct
 structs
 subarrays
 subdirectories
 subdirectory
 subexpressions
 subfunction
 Subfunction
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -191,17 +191,17 @@ The Perl Compatible Regular Expression l
 The following external package is optional but strongly recommended:
 
 @table @asis
 @item GNU Readline
 Command-line editing library (@url{www.gnu.org/s/readline}).
 @end table
 
 If you wish to build Octave without GNU readline installed, you must use
-the @code{--disable-readline} option when running the configure script.
+the @option{--disable-readline} option when running the configure script.
 
 The following external software packages are optional but recommended:
 
 @table @asis
 @item ARPACK
 Library for the solution of large-scale eigenvalue problems
 (@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
 required to provide the functions @code{eigs} and @code{svds}.
diff --git a/doc/interpreter/macros.texi b/doc/interpreter/macros.texi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/macros.texi
@@ -0,0 +1,65 @@
+@c Copyright (C) 2012 John W. Eaton
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c 
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+@c for more details.
+@c 
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING.  If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@c FIXME -- someday, we might replace this with @backslashchar, which
+@c has been added to Texinfo.
+
+@macro xbackslashchar
+\\
+@end macro
+
+@c The following macro is used for the on-line help system, but we don't
+@c want lots of `See also: foo, bar, and baz' strings cluttering the
+@c printed manual (that information should be in the supporting text for
+@c each group of functions and variables).
+
+@macro seealso {args}
+@iftex
+@vskip 2pt
+@end iftex
+@ifnottex
+@c Texinfo @sp should work but in practice produces ugly results for HTML.
+@c A simple blank line produces the correct behavior. 
+@c @sp 1
+
+@end ifnottex
+@noindent
+@strong{See also:} \args\.
+@end macro
+
+@c The following macro marks words that aspell should ignore during
+@c spellchecking.  Within Texinfo it has no effect as it merely replaces
+@c the macro call with the argument itself.
+
+@macro nospell {arg}
+\arg\
+@end macro
+
+@c The following macro works around a situation where the Info/plain text
+@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
+@c can be confusing if the code segment itself ends with a transpose operator.
+@ifinfo
+@macro xcode{arg}
+\arg\
+@end macro
+@end ifinfo
+@ifnotinfo
+@macro xcode{arg}
+@code{\arg\}
+@end macro
+@end ifnotinfo
diff --git a/doc/interpreter/mk_doc_cache.m b/doc/interpreter/mk_doc_cache.m
--- a/doc/interpreter/mk_doc_cache.m
+++ b/doc/interpreter/mk_doc_cache.m
@@ -33,27 +33,30 @@ nfiles = numel (docstrings_files);
 text = cell (1, nfiles);
 for i = 1:nfiles
   file = docstrings_files{i};
   fid = fopen (file, "r");
   if (fid < 0)
     error ("unable to open %s for reading", file);
   else
     tmp = fread (fid, Inf, "*char")';
-    ## Strip off header lines
-    [~, text{i}] = strtok (tmp, doc_delim);
+    if (isempty (strfind (tmp, doc_delim)))
+      ## No delimiter, copy verbatim (this is the case for the file
+      ## containing macro definitions, for example).
+      text{i} = tmp;
+    else
+      ## Strip off header lines
+      [~, text{i}] = strtok (tmp, doc_delim);
+    endif
   endif
 endfor
 text = [text{:}, doc_delim];
 
-## Modify Octave-specific macros before passing to makeinfo
+## Strip Texinfo markers and docstring separators.
 text = regexprep (text, "-\\*- texinfo -\\*-[ \t]*[\r\n]*", "");
-text = regexprep (text, '@seealso *\{([^}]*)\}', "See also: $1.");
-text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
-text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
 text = strrep (text, '@', "@@");
 
 ## Write data to temporary file for input to makeinfo
 [fid, name, msg] = mkstemp ("octave_doc_XXXXXX", true);
 if (fid < 0)
   error ("%s: %s\n", name, msg);
 endif
 fwrite (fid, text, "char");
diff --git a/doc/interpreter/munge-texi.cc b/doc/interpreter/munge-texi.cc
deleted file mode 100644
--- a/doc/interpreter/munge-texi.cc
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
-
-Copyright (C) 1999-2012 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#include <cctype>
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <map>
-
-#include <cstdlib>
-#include <cstring>
-
-static std::string top_srcdir;
-
-static const char doc_delim = '';
-
-static std::map<std::string, std::string> help_text;
-
-static void
-fatal (const std::string& msg)
-{
-  std::cerr << msg << "\n";
-  exit (1);
-}
-
-static void
-usage (void)
-{
-  std::cerr << "usage: munge-texi TOP-SRCDIR DOCSTRING-FILE < file\n";
-  exit (1);
-}
-
-static std::string
-extract_symbol_name (std::istream& is)
-{
-  std::string symbol_name;
-
-  int c;
-  while ((c = is.get ()) != EOF && c != '\n')
-    symbol_name += static_cast<char> (c);
-
-  return symbol_name;
-}
-
-static std::string
-extract_docstring (std::istream& is)
-{
-  std::string doc;
-
-  int c;
-  while ((c = is.get ()) != EOF && c != doc_delim)
-    {
-      // Expand @seealso commands to Texinfo references.
-      if (c == '@')
-        {
-          char buf[16];
-          int i = 0;
-          buf[i++] = static_cast<char> (c);
-
-          if ((   buf[i++] = static_cast<char> (is.get ())) == 's'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'e'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'e'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'a'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'l'
-              && (buf[i++] = static_cast<char> (is.get ())) == 's'
-              && (buf[i++] = static_cast<char> (is.get ())) == 'o'
-              && (buf[i++] = static_cast<char> (is.get ())) == '{')
-            {
-              doc += "@seealso{";
-
-              bool first = true;
-
-              // process @seealso parameters
-              while ((c = is.get ()) != EOF
-                     && c != doc_delim
-                     && c != '}')
-                {
-                  // ignore whitespace and delimiters
-                  while (   c == ' '
-                         || c == '\t'
-                         || c == '\r'
-                         || c == '\n'
-                         || c == ',')
-                    {
-                      c = is.get ();
-                    }
-
-                  // test for end of @seealso
-                  if (c == '}')
-                    break;
-
-                  // get function name
-                  std::string function_name;
-                  do
-                    function_name += static_cast<char> (c);
-                  while ((c = is.get ()) != EOF
-                          && c != doc_delim
-                          && c != ' '
-                          && c != '\t'
-                          && c != '\r'
-                          && c != '\n'
-                          && c != ','
-                          && c != '}');
-                  if (first)
-                    first = false;
-                  else
-                    doc += ", ";
-
-                  if (function_name[0] == '@')
-                    function_name = "@" + function_name;
-
-                  doc += "@ref{doc-" + function_name + ",,"
-                    + function_name + "}";
-
-                  // test for end of @seealso
-                  if (c == '}')
-                    break;
-                }
-              if (c == '}')
-                doc += static_cast<char> (c);
-            }
-          else
-            {
-              for (int j = 0; j < i; j++)
-                doc += buf[j];
-            }
-        }
-      else
-        doc += static_cast<char> (c);
-    }
-  return doc;
-}
-
-static void
-skip_comments (std::ifstream& is)
-{
-  int c;
-
-  bool in_comment = false;
-
-  while ((c = is.get ()) != EOF)
-    {
-      if (c == '#')
-        in_comment = true;
-      else if (c == '\n')
-        in_comment = false;
-      else if (! (in_comment || ::isspace (c)))
-        {
-          is.putback (c);
-          break;
-        }
-    }
-}
-
-static void
-process_doc_file (const std::string& fname)
-{
-  std::ifstream infile (fname.c_str ());
-
-  if (infile)
-    {
-      skip_comments (infile);
-
-      if (infile.get () != doc_delim)
-        fatal ("invalid doc file format");
-
-      std::string symbol_name;
-
-      do
-        {
-          symbol_name = extract_symbol_name (infile);
-
-          if (! symbol_name.empty ())
-            {
-              std::string doc_string = extract_docstring (infile);
-
-              if (help_text.find (symbol_name) != help_text.end ())
-                std::cerr << "ignoring duplicate entry for "
-                          << symbol_name << "\n";
-              else
-                help_text[symbol_name] = doc_string;
-            }
-        }
-      while (! symbol_name.empty ());
-    }
-  else
-    fatal ("unable to open docfile");
-}
-
-static bool
-recover_from_macro (std::ostream& os, char *buf, int i)
-{
-  bool bol = false;
-
-  buf[i] = '\0';
-  os << buf;
-
-  if (buf[i - 1] == '\n')
-    bol = true;
-
-  return bol;
-}
-
-static void
-process_example_file (const std::string& file_name, std::ostream& os)
-{
-  std::ifstream infile (file_name.c_str ());
-
-  if (infile)
-    {
-      os << "@verbatim\n";
-
-      int c;
-      int clast = 0;
-
-      while ((c = infile.get ()) != EOF)
-        {
-          os << static_cast<char> (c);
-          clast = c;
-        }
-
-      if (clast != '\n')
-        os << "\n";
-
-      os << "@end verbatim\n";
-    }
-  else
-    fatal ("unable to open example file " + file_name);
-}
-
-static void
-process_texi_input_file (std::istream& is, std::ostream& os)
-{
-  os << "@c DO NOT EDIT!  Generated automatically by munge-texi.\n\n";
-
-  bool bol = true;
-
-  int c;
-  while ((c = is.get ()) != EOF)
-    {
-      if (bol)
-        {
-          if (c == '@')
-            {
-              char buf[16];
-              int i = 0;
-              buf[i++] = static_cast<char> (c);
-
-              buf[i++] = c = static_cast<char> (is.get ());
-
-              if (c == 'D')
-                {
-                  std::string symbol_name;
-
-                  if (   (buf[i++] = static_cast<char> (is.get ())) == 'O'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'C'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'S'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'T'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'R'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'I'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'N'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'G'
-                      && (buf[i++] = static_cast<char> (is.get ())) == '(')
-                    {
-                      while ((c = is.get ()) != EOF && c != ')')
-                        symbol_name += static_cast<char> (c);
-
-                      if (is.eof ())
-                        fatal ("end of file while reading @DOCSTRING command");
-                      else
-                        {
-                          std::string doc_string = help_text[symbol_name];
-
-                          size_t len = doc_string.length ();
-
-                          int j = 0;
-
-                          // If there is a leading comment with the file
-                          // name, copy it to the output.
-                          if (len > 1
-                              && doc_string[j] == '@'
-                              && doc_string[j+1] == 'c')
-                            {
-                              j = 2;
-                              while (doc_string[j++] != '\n')
-                                /* find eol */;
-
-                              os << doc_string.substr (0, j);
-                            }
-
-                          while (doc_string[j] == ' ')
-                            j++;
-
-                          if (doc_string.substr (j, 15) == "-*- texinfo -*-")
-                            {
-                              j += 15;
-
-                              while (isspace (doc_string[j]))
-                                j++;
-
-                              // Make `see also' references in functions
-                              // possible using @anchor{TAG} (new with
-                              // Texinfo 4.0).
-
-                              if (symbol_name[0] == '@')
-                                symbol_name = "@" + symbol_name;
-
-                              os << "@anchor{doc-" << symbol_name << "}\n";
-
-                              os << doc_string.substr (j);
-                            }
-                          else
-                            os << doc_string;
-                        }
-                    }
-                  else
-                    bol = recover_from_macro (os, buf, i);
-                }
-              else if (c == 'E')
-                {
-                  std::string file_name;
-
-                  if (   (buf[i++] = static_cast<char> (is.get ())) == 'X'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'A'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'M'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'P'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'L'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'E'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'F'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'I'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'L'
-                      && (buf[i++] = static_cast<char> (is.get ())) == 'E'
-                      && (buf[i++] = static_cast<char> (is.get ())) == '(')
-                    {
-                      while ((c = is.get ()) != EOF && c != ')')
-                        file_name += static_cast<char> (c);
-
-                      file_name = top_srcdir + "/examples/" + file_name;
-
-                      process_example_file (file_name, os);
-                    }
-                  else
-                    bol = recover_from_macro (os, buf, i);
-                }
-              else
-                bol = recover_from_macro (os, buf, i);
-            }
-          else
-            os.put (static_cast<char> (c));
-        }
-      else
-        {
-          if (c == '\n')
-            bol = true;
-
-          os.put (static_cast<char> (c));
-        }
-    }
-}
-
-int
-main (int argc, char **argv)
-{
-  int retval = 0;
-
-  if (argc > 1)
-    {
-      top_srcdir = *++argv;
-
-      while (*++argv)
-        process_doc_file (*argv);
-
-      process_texi_input_file (std::cin, std::cout);
-    }
-  else
-    {
-      usage ();
-
-      retval = 1;
-    }
-
-  return retval;
-
-}
diff --git a/doc/interpreter/munge-texi.pl b/doc/interpreter/munge-texi.pl
new file mode 100755
--- /dev/null
+++ b/doc/interpreter/munge-texi.pl
@@ -0,0 +1,124 @@
+#!/usr/bin/perl -w
+
+# Validate program call
+die "usage: munge-texi TOP-SRCDIR DOCSTRING-FILE < file" if (@ARGV < 2);
+
+$top_srcdir = shift (@ARGV);
+
+# Constant patterns
+$doc_delim = qr/^\c_/;
+$tex_delim = qr/\Q-*- texinfo -*-\E/;
+$comment_line = qr/^\s*(?:$|#)/;
+# Pre-declare hash size for efficiency
+keys(%help_text) = 1800;
+
+################################################################################
+# Load DOCSTRINGS into memory while expanding @seealso references
+foreach $DOCSTRING_file (@ARGV)
+{
+   open (DOCFH, $DOCSTRING_file) or die "Unable to open $DOCSTRING_file\n";
+
+   # Skip comments
+   while (defined ($_ = <DOCFH>) and /$comment_line/o) {;}
+
+   # Validate DOCSTRING file format
+   die "invalid doc file format\n" if (! /$doc_delim/o);
+   
+   do 
+   {
+     chomp;
+     $symbol = substr ($_,1);
+     $docstring = extract_docstring ();
+     if ($help_text{$symbol})
+     {
+        warn "ignoring duplicate entry for $symbol\n";
+     }
+     else
+     {
+       $help_text{$symbol} = $docstring;
+     }
+
+   } while (! eof);
+
+}
+
+################################################################################
+# Process .txi to .texi by expanding @DOCSTRING, @EXAMPLEFILE macros
+
+# Add warning header
+print '@c DO NOT EDIT!  Generated automatically by munge-texi.',"\n\n";
+
+TXI_LINE: while (<STDIN>)
+{
+   if (/^\s*\@DOCSTRING\((\S+)\)/)
+   {
+      $func = $1;
+      $docstring = $help_text{$func};
+      if (! $docstring)
+      {
+        warn "no docstring entry for $func\n";
+        next TXI_LINE;
+      }
+
+      $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+      $docstring =~ s/^$tex_delim$/\@anchor{doc-$func}/m;
+      print $docstring,"\n";
+
+      next TXI_LINE;
+   }
+   if (/^\s*\@EXAMPLEFILE\((\S+)\)/)
+   {
+      $fname = "$top_srcdir/examples/$1";
+      print '@verbatim',"\n";
+      open (EXAMPFH, $fname) or die "unable to open example file $fname\n";
+      while (<EXAMPFH>) 
+      { 
+         print $_;
+         print "\n" if (eof and substr ($_, -1) ne "\n");
+      }
+      close (EXAMPFH);
+      print '@end verbatim',"\n\n";
+
+      next TXI_LINE;
+   }
+
+   # pass ordinary lines straight through to output
+   print $_;
+}
+
+
+################################################################################
+# Subroutines 
+################################################################################
+sub extract_docstring
+{
+   my ($docstring, $arg_list, $func_list, $repl, $rest_of_line);
+   
+   while (defined ($_ = <DOCFH>) and ! /$doc_delim/o)
+   {
+      # expand any @seealso references
+      if (m'^@seealso{')
+      {
+         # Join multiple lines until full macro body found
+         while (! /}/m) { $_ .= <DOCFH>; }
+
+         ($arg_list, $rest_of_line) = m'^@seealso{(.*)}(.*)?'s;
+        
+         $func_list = $arg_list;
+         $func_list =~ s/\s+//gs;
+         $repl = "";
+         foreach $func (split (/,/, $func_list))
+         {
+            $func =~ s/^@/@@/;   # Texinfo uses @@ to produce '@'
+            $repl .= "\@ref{doc-$func,,$func}, ";
+         }
+         substr($repl,-2) = "";   # Remove last ', ' 
+         $_ = "\@seealso{$repl}$rest_of_line";
+      }
+
+      $docstring .= $_;
+   }
+
+   return $docstring;
+}
+
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -14,56 +14,17 @@
 % 
 % You should have received a copy of the GNU General Public License
 % along with Octave; see the file COPYING.  If not, see
 % <http://www.gnu.org/licenses/>.
 
 \input texinfo
 @setfilename octave.info
 
-@c The following macro is used for the on-line help system, but we don't
-@c want lots of `See also: foo, bar, and baz' strings cluttering the
-@c printed manual (that information should be in the supporting text for
-@c each group of functions and variables).
-
-@macro seealso {args}
-@iftex
-@vskip 2pt
-@end iftex
-@ifnottex
-@c Texinfo @sp should work but in practice produces ugly results for HTML.
-@c A simple blank line produces the correct behavior. 
-@c @sp 1
-
-@end ifnottex
-@noindent
-@strong{See also:} \args\.
-@end macro
-
-@c The following macro marks words that aspell should ignore during
-@c spellchecking.  Within Texinfo it has no effect as it merely replaces
-@c the macro call with the argument itself.
-
-@macro nospell {arg}
-\arg\
-@end macro
-
-@c The following macro works around a situation where the Info/plain text
-@c expansion of the @code{XXX} macro is `XXX'.  The use of the apostrophe
-@c can be confusing if the code segment itself ends with a transpose operator.
-@ifinfo
-@macro xcode{arg}
-\arg\
-@end macro
-@end ifinfo
-@ifnotinfo
-@macro xcode{arg}
-@code{\arg\}
-@end macro
-@end ifnotinfo
+@include macros.texi
 
 @ifinfo
 @format
 START-INFO-DIR-ENTRY
 * Octave: (octave).           Interactive language for numerical computations.
 
 END-INFO-DIR-ENTRY
 @end format
diff --git a/etc/HACKING b/etc/HACKING
--- a/etc/HACKING
+++ b/etc/HACKING
@@ -1,24 +1,24 @@
 -*- outline -*-
 
 This file attempts to describe the rules to use when hacking Octave.
 DO NOT put this file into the distribution.
 
 * Working from the repository
 
-These notes are intended to help people working on sources checked-out from
+These notes are intended to help people working on sources cloned from
 the savannah source code repository.
 These requirements do not apply when building from a distribution tarball.
 
 ** Requirements
 
 We've opted to keep only the highest-level sources in the repository.
 This eases our maintenance burden, (fewer merges, etc.), but imposes
-more requirements on anyone wishing to build from the just-checked-out
+more requirements on anyone wishing to build from the just-cloned
 sources.  For example, you have to use the latest stable versions of
 the maintainer tools we depend upon, including:
 
   - Autoconf <http://www.gnu.org/software/autoconf/>
   - Automake <http://www.gnu.org/software/automake/>
   - Bison <http://www.gnu.org/software/bison/>
   - Flex <http://www.gnu.org/software/flex/>
   - Git <http://git-scm.com/>
@@ -30,66 +30,63 @@ the maintainer tools we depend upon, inc
   - Perl <http://www.cpan.org/>
   - Rsync <http://samba.anu.edu.au/rsync/>
   - Tar <http://www.gnu.org/software/tar/>
 
 Only building the initial full source tree will be a bit painful.
 Later, after synchronizing from the repository, a plain `make' should
 be sufficient.
 
-** First checkout
+** First clone
 
-Obviously, if you are reading these notes, you did manage to check out
+If you are reading these notes, you may have already managed to clone
 this package from the repository.  For the record, you will find all the
 relevant information on downloading sources at:
 
   http://www.gnu.org/software/octave/download.html
 
-After checking out Octave, you will need to run the autogen.sh script:
+After cloning Octave, you will need to run the autogen.sh script:
 
   $ ./autogen.sh
 
 This script will examine the source tree and generate some Makefile
 fragments and then runs the bootstrap script.  The bootstrap script comes
 from gnulib, but is kept in the Octave source archive.  It should be
 updated from the gnulib sources as necssary.  The bootstrap script takes
-care of checking out a copy of gnulib, running the autotools, and
-generating the configure script.
+care of running the autotools and generating the configure script.
 
 If you have a copy of gnulib in some directory apart from the Octave
 source tree, then pass the name of the directory containing gnulib-tool
 to the bootstrap script using the option: 
 
   --gnulib-srcdir=DIRNAME
 
 If you have downloaded gnulib directly, DIRNAME will be the directory where
 gnulib was unpacked.  If you have installed gnulib using a package 
 manager, DIRNAME is likely to be /usr/bin or /usr/local/bin(where the
 gnulib-tool script resides).
 
 By using an external gnulib directory, you can share a single gnulib source
-tree among several projects.  Regardless of the location of the gnulib
-sources, the bootstrap script will try to update them if it appears
-that they are checked out using git.  Otherwise, it is your
-responsibility to keep the gnulib sources up to date.  They change
-frequently, so the best way to stay current is probably to use git to
-do the job.
+tree among several projects.  Since 2011, the gnulib sources are a Mercurial
+subrepository, so they will be automatically updated to the
+corresponding Mercurial revision if you update the working directory to
+a past revision not too far in the past.
 
 Additional options besides --gnulib-srcdir can be passed to autogen.sh and
 they will be forwarded without modification to the bootstrap script.
 
 Once the autogen.sh and bootstrap scripts complete successfully, you may
 run
 
   $ ./configure
   $ make
   $ make check
 
-At this point, there should be no difference between your local copy,
-and the master copy:
+At this point, there should be no difference between your working tree
+and the currently visited hg revision:
 
   $ hg diff
 
 should output no difference.
 
 ** Coding style
 
 The most important advice is to follow any conventions you detect in the
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -879,17 +879,18 @@ Array<T>::index (const Array<idx_vector>
     }
 
   return retval;
 }
 
 // The default fill value.  Override if you want a different one.
 
 template <class T>
-const T& Array<T>::resize_fill_value ()
+T
+Array<T>::resize_fill_value (void) const
 {
   static T zero = T ();
   return zero;
 }
 
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
@@ -1159,26 +1160,31 @@ Array<T>::assign (const idx_vector& i, c
     gripe_invalid_assignment_size ();
 }
 
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
+  bool initial_dims_all_zero = dimensions.all_zero ();
+
   // Get RHS extents, discarding singletons.
   dim_vector rhdv = rhs.dims ();
+
   // Get LHS extents, allowing Fortran indexing in the second dim.
   dim_vector dv = dimensions.redim (2);
+
   // Check for out-of-bounds and form resizing dimensions.
   dim_vector rdv;
+
   // In the special when all dimensions are zero, colons are allowed
   // to inquire the shape of RHS.  The rules are more obscure, so we
   // solve that elsewhere.
-  if (dv.all_zero ())
+  if (initial_dims_all_zero)
     rdv = zero_dims_inquire (i, j, rhdv);
   else
     {
       rdv(0) = i.extent (dv(0));
       rdv(1) = j.extent (dv(1));
     }
 
   bool isfill = rhs.numel () == 1;
@@ -1262,29 +1268,31 @@ Array<T>::assign (const Array<idx_vector
 
   // FIXME: is this dispatching necessary / desirable?
   if (ial == 1)
     assign (ia(0), rhs, rfv);
   else if (ial == 2)
     assign (ia(0), ia(1), rhs, rfv);
   else if (ial > 0)
     {
+      bool initial_dims_all_zero = dimensions.all_zero ();
+
       // Get RHS extents, discarding singletons.
       dim_vector rhdv = rhs.dims ();
 
       // Get LHS extents, allowing Fortran indexing in the second dim.
       dim_vector dv = dimensions.redim (ial);
 
       // Get the extents forced by indexing.
       dim_vector rdv;
 
       // In the special when all dimensions are zero, colons are
       // allowed to inquire the shape of RHS.  The rules are more
       // obscure, so we solve that elsewhere.
-      if (dv.all_zero ())
+      if (initial_dims_all_zero)
         rdv = zero_dims_inquire (ia, rhdv);
       else
         {
           rdv = dim_vector::alloc (ial);
           for (int i = 0; i < ial; i++)
             rdv(i) = ia(i).extent (dv(i));
         }
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -445,56 +445,79 @@ public:
   // Indexing without resizing.
 
   Array<T> index (const idx_vector& i) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j) const;
 
   Array<T> index (const Array<idx_vector>& ia) const;
 
-  static const T& resize_fill_value ();
+  virtual T resize_fill_value (void) const;
 
   // Resizing (with fill).
 
-  void resize1 (octave_idx_type n, const T& rfv = resize_fill_value ());
+  void resize1 (octave_idx_type n, const T& rfv);
+  void resize1 (octave_idx_type n) { resize1 (n, resize_fill_value ()); }
 
-  void resize (octave_idx_type n) GCC_ATTR_DEPRECATED
-    { resize1 (n); }
+  void resize (octave_idx_type n) GCC_ATTR_DEPRECATED { resize1 (n); }
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               const T& rfv = resize_fill_value ()) GCC_ATTR_DEPRECATED
+  void resize (octave_idx_type nr, octave_idx_type nc, const T& rfv) GCC_ATTR_DEPRECATED
   {
     resize2 (nr, nc, rfv);
   }
 
-  void resize (const dim_vector& dv, const T& rfv = resize_fill_value ());
+  void resize (octave_idx_type nr, octave_idx_type nc) GCC_ATTR_DEPRECATED
+  {
+    resize2 (nr, nc, resize_fill_value ());
+  }
+
+  void resize (const dim_vector& dv, const T& rfv);
+  void resize (const dim_vector& dv) { resize (dv, resize_fill_value ()); }
 
   // Indexing with possible resizing and fill
   // FIXME -- this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
-  Array<T> index (const idx_vector& i, bool resize_ok,
-                  const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
+  Array<T> index (const idx_vector& i, bool resize_ok) const
+  {
+    return index (i, resize_ok, resize_fill_value ());
+  }
 
-  Array<T> index (const idx_vector& i, const idx_vector& j,
-                  bool resize_ok, const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok, const T& rfv) const;
+  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok) const
+  {
+    return index (i, j, resize_ok, resize_fill_value ());
+  }
 
-  Array<T> index (const Array<idx_vector>& ia,
-                  bool resize_ok, const T& rfv = resize_fill_value ()) const;
+  Array<T> index (const Array<idx_vector>& ia, bool resize_ok, const T& rfv) const;
+  Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const
+  {
+    return index (ia, resize_ok, resize_fill_value ());
+  }
 
   // Indexed assignment (always with resize & fill).
 
-  void assign (const idx_vector& i, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);
+  void assign (const idx_vector& i, const Array<T>& rhs)
+  {
+    assign (i, rhs, resize_fill_value ());
+  }
 
-  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs, const T& rfv);
+  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs)
+  {
+    assign (i, j, rhs, resize_fill_value ());
+  }
 
-  void assign (const Array<idx_vector>& ia, const Array<T>& rhs,
-               const T& rfv = resize_fill_value ());
+  void assign (const Array<idx_vector>& ia, const Array<T>& rhs, const T& rfv);
+  void assign (const Array<idx_vector>& ia, const Array<T>& rhs)
+  {
+    assign (ia, rhs, resize_fill_value ());
+  }
 
   // Deleting elements.
 
   // A(I) = [] (with a single subscript)
   void delete_elements (const idx_vector& i);
 
   // A(:,...,I,...,:) = [] (>= 2 subscripts, one of them is non-colon)
   void delete_elements (int dim, const idx_vector& i);
@@ -667,18 +690,21 @@ public:
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
 private:
 
-  void resize2 (octave_idx_type nr, octave_idx_type nc,
-                const T& rfv = resize_fill_value ());
+  void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
+  void resize2 (octave_idx_type nr, octave_idx_type nc)                
+  {
+    resize2 (nr, nc, resize_fill_value ());
+  }
 
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
 // later type derived from it and override the default non-const operator() to
 // not check for the array's uniqueness. It is, however, the user's
 // responsibility to ensure the array is actually unaliased whenever elements
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -127,18 +127,17 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (n, 1); }
 
 };
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -147,17 +147,17 @@ public:
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
-               const Complex& rfv = resize_fill_value ())
+               const Complex& rfv = Complex (0))
   {
     MArray<Complex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   ComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int force, int calc_cond) const;
 
@@ -373,19 +373,16 @@ public:
 
   ComplexRowVector column_min (Array<octave_idx_type>& index) const;
   ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexMatrix& a);
-
-  static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
-
 };
 
 extern OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API ComplexMatrix
 operator * (const ColumnVector& a, const ComplexRowVector& b);
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -130,18 +130,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
-  static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
   ComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   ComplexNDArray& changesign (void)
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -107,18 +107,17 @@ public:
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
-  void resize (octave_idx_type n,
-               const Complex& rfv = Array<Complex>::resize_fill_value ())
+  void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<Complex>::clear (1, n); }
 
 };
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -77,26 +77,16 @@ template <class T>
 DiagArray2<T>
 DiagArray2<T>::hermitian (T (* fcn) (const T&)) const
 {
   return DiagArray2<T> (Array<T>::template map<T> (fcn), d2, d1);
 }
 
 // A two-dimensional array with diagonal elements only.
 
-template <typename T>
-void
-DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
-{
-  if (r < 0 || r >= dim1 ())
-    gripe_index_out_of_range (2, 1, r+1, dim1 ());
-  if (c < 0 || c >= dim2 ())
-    gripe_index_out_of_range (2, 2, c+1, dim2 ());
-}
-
 template <class T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
     {
       (*current_liboctave_error_handler) ("can't resize to negative dimensions");
@@ -116,8 +106,29 @@ DiagArray2<T>::array_value (void) const
 {
   Array<T> result (dims (), T (0));
 
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
   return result;
 }
+
+template <typename T>
+bool
+DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
+{
+  bool ok = true;
+
+  if (r < 0 || r >= dim1 ())
+    {
+      gripe_index_out_of_range (2, 1, r+1, dim1 ());
+      ok = false;
+    }
+
+  if (c < 0 || c >= dim2 ())
+    {
+      gripe_index_out_of_range (2, 2, c+1, dim2 ());
+      ok = false;
+    }
+
+  return ok;
+}
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -114,58 +114,76 @@ public:
     }
 
   T dgelem (octave_idx_type i) const
     { return Array<T>::elem (i); }
 
   T& dgelem (octave_idx_type i)
     { return Array<T>::elem (i); }
 
-  void check_idx (octave_idx_type r, octave_idx_type c) const;
+  T checkelem (octave_idx_type r, octave_idx_type c) const
+    {
+      return check_idx (r, c) ? elem (r, c) : T (0);
+    }
 
   T operator () (octave_idx_type r, octave_idx_type c) const
     {
 #if defined (BOUNDS_CHECKING)
-      check_idx (r, c);
+      checkelem (r, c);
+#else
+      return elem (r, c);
 #endif
-      return elem (r, c);
+    }
+
+  T& checkelem (octave_idx_type r, octave_idx_type c)
+    {
+      static T zero (0);
+      return check_idx (r, c) ? elem (r, c) : zero;
     }
 
   T& operator () (octave_idx_type r, octave_idx_type c)
     {
 #if defined (BOUNDS_CHECKING)
-      check_idx (r, c);
+      return checkelem (r, c);
+#else
+      return elem (r, c);
 #endif
-      return elem (r, c);
     }
 
   // No checking.
 
   T xelem (octave_idx_type r, octave_idx_type c) const
     {
       return (r == c) ? Array<T>::xelem (r) : T (0);
     }
 
   T& dgxelem (octave_idx_type i)
     { return Array<T>::xelem (i); }
 
   T dgxelem (octave_idx_type i) const
     { return Array<T>::xelem (i); }
 
-  void resize (octave_idx_type n, octave_idx_type m,
-               const T& rfv = Array<T>::resize_fill_value ());
+  void resize (octave_idx_type n, octave_idx_type m, const T& rfv);
+  void resize (octave_idx_type n, octave_idx_type m)
+  {
+    resize (n, m, Array<T>::resize_fill_value ());
+  }
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   Array<T> array_value (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
 
   const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T *fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
     { Array<T>::print_info (os, prefix); }
+
+private:
+
+  bool check_idx (octave_idx_type r, octave_idx_type c) const;
 };
 
 #endif
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -79,24 +79,20 @@ public:
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               bool rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, bool rfv = false)
   {
     Array<bool>::resize (dim_vector (nr, nc), rfv);
   }
-
-  static bool resize_fill_value (void) { return false; }
-
 };
 
 MM_BOOL_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 MS_BOOL_OP_DECLS (boolMatrix, bool, OCTAVE_API)
 SM_BOOL_OP_DECLS (bool, boolMatrix, OCTAVE_API)
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix, OCTAVE_API)
 
 #endif
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -91,18 +91,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   // friend std::istream& operator >> (std::istream& is, NDArray& a);
 
-  static bool resize_fill_value (void) { return false; }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   boolNDArray diag (octave_idx_type k = 0) const;
 
   boolNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -81,36 +81,32 @@ public:
   charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               char rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, char rfv = 0)
   {
     Array<char>::resize (dim_vector (nr, nc), rfv);
   }
 
   charMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
-
-  static char resize_fill_value (void) { return '\0'; }
-
 };
 
 MS_CMP_OP_DECLS (charMatrix, char, OCTAVE_API)
 MS_BOOL_OP_DECLS (charMatrix, char, OCTAVE_API)
 
 SM_CMP_OP_DECLS (char, charMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (char, charMatrix, OCTAVE_API)
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -87,18 +87,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
-  static char resize_fill_value (void) { return '\0'; }
-
   charNDArray diag (octave_idx_type k = 0) const;
 
   charNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
 NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
 NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -94,18 +94,17 @@ public:
 
   ColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const double& rfv = Array<double>::resize_fill_value ())
+  void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (n, 1); }
 
 };
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -120,18 +120,17 @@ public:
   Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               double rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, double rfv = 0)
   {
     MArray<double>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                    int force, int calc_cond) const;
 
@@ -329,18 +328,16 @@ public:
 
   RowVector column_min (Array<octave_idx_type>& index) const;
   RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Matrix& a);
-
-  static double resize_fill_value (void) { return 0; }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API Matrix real (const ComplexMatrix& a);
 extern OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -145,18 +145,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
-  static double resize_fill_value (void) { return 0; }
-
   NDArray diag (octave_idx_type k = 0) const;
 
   NDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   NDArray& changesign (void)
     {
       MArray<double>::changesign ();
       return *this;
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -87,18 +87,17 @@ public:
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
-  void resize (octave_idx_type n,
-               const double& rfv = Array<double>::resize_fill_value ())
+  void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<double>::clear (1, n); }
 
 };
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -267,26 +267,21 @@ dim_vector::redim (int n) const
   int n_dims = length ();
 
   if (n_dims == n)
     return *this;
   else if (n_dims < n)
     {
       dim_vector retval = alloc (n);
 
-      int pad = 0;
       for (int i = 0; i < n_dims; i++)
-        {
-          retval.rep[i] = rep[i];
-          if (rep[i] != 0)
-            pad = 1;
-        }
+        retval.rep[i] = rep[i];
 
       for (int i = n_dims; i < n; i++)
-        retval.rep[i] = pad;
+        retval.rep[i] = 1;
 
       return retval;
     }
   else
     {
       if (n < 1) n = 1;
 
       dim_vector retval = alloc (n);
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -376,18 +376,17 @@ public:
 
   // This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1).
   // The rules are more relaxed here.
   bool hvcat (const dim_vector& dvb, int dim);
 
   // Force certain dimensionality, preserving numel ().  Missing
   // dimensions are set to 1, redundant are folded into the trailing
   // one.  If n = 1, the result is 2d and the second dim is 1
-  // (dim_vectors are always at least 2D).  If the original dimensions
-  // were all zero, the padding value is zero.
+  // (dim_vectors are always at least 2D).
 
   dim_vector redim (int n) const;
 
   dim_vector as_column (void) const
     {
       if (length () == 2 && elem (1) == 1)
         return *this;
       else
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -129,18 +129,17 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (n, 1); }
 
 };
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -152,17 +152,17 @@ public:
 
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
-               const FloatComplex& rfv = resize_fill_value ())
+               const FloatComplex& rfv = FloatComplex (0))
   {
     MArray<FloatComplex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
                           float& rcon, int force, int calc_cond) const;
 
@@ -378,19 +378,16 @@ public:
 
   FloatComplexRowVector column_min (Array<octave_idx_type>& index) const;
   FloatComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexMatrix& a);
-
-  static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
-
 };
 
 extern OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatColumnVector& a, const FloatComplexRowVector& b);
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -130,18 +130,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexNDArray& a);
 
-  static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
-
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
   FloatComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatComplexNDArray& changesign (void)
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -111,18 +111,17 @@ public:
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
 
-  void resize (octave_idx_type n,
-               const FloatComplex& rfv = Array<FloatComplex>::resize_fill_value ())
+  void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<FloatComplex>::clear (1, n); }
 
 };
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -97,18 +97,17 @@ public:
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
-  void resize (octave_idx_type n,
-               const float& rfv = Array<float>::resize_fill_value ())
+  void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (n, 1); }
 
 };
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -121,18 +121,17 @@ public:
   FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
-  void resize (octave_idx_type nr, octave_idx_type nc,
-               float rfv = resize_fill_value ())
+  void resize (octave_idx_type nr, octave_idx_type nc, float rfv = 0)
   {
     MArray<float>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                    int force, int calc_cond) const;
 
@@ -329,19 +328,16 @@ public:
 
   FloatRowVector column_min (Array<octave_idx_type>& index) const;
   FloatRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatMatrix& a);
-
-  static float resize_fill_value (void) { return 0; }
-
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatMatrix real (const FloatComplexMatrix& a);
 extern OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -142,18 +142,16 @@ public:
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
-  static float resize_fill_value (void) { return 0; }
-
   FloatNDArray diag (octave_idx_type k = 0) const;
 
   FloatNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatNDArray& changesign (void)
     {
       MArray<float>::changesign ();
       return *this;
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -88,18 +88,17 @@ public:
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
 
-  void resize (octave_idx_type n,
-               const float& rfv = Array<float>::resize_fill_value ())
+  void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
     { Array<float>::clear (1, n); }
 
 };
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -110,19 +110,16 @@ public:
   intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions);
-
-  static T resize_fill_value (void) { return 0; }
-
 };
 
 // i/o
 
 template <class T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
 template <class T>
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -83,17 +83,17 @@ public:
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
-  void resize (octave_idx_type n, const std::string& rfv = resize_fill_value ())
+  void resize (octave_idx_type n, const std::string& rfv = std::string ())
   {
     Array<std::string>::resize (dim_vector (n, 1), rfv);
   }
 
   std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
 
   std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
 
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -40,16 +40,17 @@ d3_list=`$FIND "$d3" -type d -a ! \( \( 
 
 d1_path=`echo "$d1_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 d2_path=`echo "$d2_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 d3_path=`echo "$d3_list" | $AWK '{ t = (s $0); s = t; } END { sub (/:$/, "", s); print s; }'`
 
 LOADPATH="$d1_path:$d2_path:$d3_path"
 IMAGEPATH="$top_srcdir/scripts/image"
 DOCFILE="$builddir/doc/interpreter/doc-cache"
+TEXIMACROSFILE="$top_srcdir/doc/interpreter/macros.texi"
 INFOFILE="$top_srcdir/doc/interpreter/octave.info"
 
 ## Checking for string equality below with prepended x's in order to
 ## handle problems with empty strings.
 if [ $# -gt 0 ]; then
   if [ "x$1" = "x-g" ]; then
     driver="gdb --args"
     shift
@@ -65,9 +66,9 @@ if [ $# -gt 0 ]; then
     shift
   fi
 fi
 
 OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
   exec $builddir/libtool --mode=execute $driver \
     "$builddir/src/octave" --no-init-path --path="$LOADPATH" \
     --image-path="$IMAGEPATH" --doc-cache-file="$DOCFILE" \
-    --info-file="$INFOFILE" "$@"
+    --texi-macros-file="$TEXIMACROSFILE" --info-file="$INFOFILE" "$@"
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -320,31 +320,27 @@ strings/$(octave_dirstamp):
 testfun/$(octave_dirstamp):
 	$(MKDIR_P) testfun
 	: > testfun/$(octave_dirstamp)
 time/$(octave_dirstamp):
 	$(MKDIR_P) time
 	: > time/$(octave_dirstamp)
 
 if AMCOND_BUILD_DOCS
-## Program compiled only to help build documentation.  No installation needed.
-noinst_PROGRAMS = gethelp
 
-gethelp_SOURCES = gethelp.cc
-
-.DOCSTRINGS: $(FCN_FILES) $(GEN_FCN_FILES) mkdoc $(gethelp_SOURCES) Makefile
-	@$(MAKE) $(AM_MAKEFLAGS) gethelp$(BUILD_EXEEXT)
+.DOCSTRINGS: $(FCN_FILES) $(GEN_FCN_FILES) mkdoc.pl Makefile
 	if [ "x$(srcdir)" != "x." ] && [ -f $(srcdir)/DOCSTRINGS ] && [ ! -f DOCSTRINGS ]; then \
 		cp $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 		touch -r $(srcdir)/DOCSTRINGS DOCSTRINGS; \
 	fi
 	@echo "creating .DOCSTRINGS from .m script files"
-	@$(srcdir)/mkdoc "$(srcdir)" $(FCN_FILES) -- $(GEN_FCN_FILES) > $@
+	@$(PERL) $(srcdir)/mkdoc.pl "$(srcdir)" $(FCN_FILES) -- $(GEN_FCN_FILES) > $@
 	$(top_srcdir)/build-aux/move-if-change $@ DOCSTRINGS
 	touch $@
+
 endif
 
 $(GEN_FCN_FILES) : %.m : %.in Makefile
 	@$(do_subst_config_vals)
 
 check-m-sources:
 	@echo "checking whether files in source tree are listed in module.mk files..."; \
 	for f in $$(find $(srcdir) -name '*.m'); do \
@@ -422,17 +418,17 @@ uninstall-pkg-add:
 .PHONY: uninstall-pkg-add
 
 EXTRA_DIST += \
   $(IMAGES) \
   $(FCN_FILES) \
   $(FCN_FILES_IN) \
   $(GEN_FCN_FILES) \
   DOCSTRINGS \
-  mkdoc \
+  mkdoc.pl \
   mk-pkg-add
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
   DOCSTRINGS \
   $(PKG_ADD_FILES) \
   $(DIRSTAMP_FILES) \
   $(GEN_FCN_FILES)
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2004-2012 David Bateman
+## Copyright (C) 2012 Jordi Gutirrez Hermoso
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -16,105 +17,106 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{C} =} bitset (@var{A}, @var{n})
 ## @deftypefnx {Function File} {@var{C} =} bitset (@var{A}, @var{n}, @var{val})
 ## Set or reset bit(s) @var{n} of unsigned integers in @var{A}.
 ## @var{val} = 0 resets and @var{val} = 1 sets the bits.
-## The lowest significant bit is: @var{n} = 1
+## The lowest significant bit is: @var{n} = 1.  All variables must be the
+## same size or scalars.
 ##
 ## @example
 ## @group
 ## dec2bin (bitset (10, 1))
 ##   @result{} 1011
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
-## Liberally based on the version by Kai Habel from octave-forge
-
 function C = bitset (A, n, val)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
+  if (any (A(:) < 0))
+    error ("bitset: A must be >= 0");
+  endif
+
+  sz = size (A);
+
   if (nargin == 2)
-    val = 1;
+    val = true (sz);
   endif
 
-  if (isa (A, "double"))
-    Bmax = bitmax;
-    Amax = log2 (Bmax) + 1;
-    _conv = @double;
+  cl = class (A);
+
+  if (isfloat (A) && isreal (A))
+    Bmax = bitmax (cl);
+    Amax = log2 (Bmax);
+  elseif (isinteger (A))
+    Bmax = intmax (cl);
+    Amax = round (log2 (Bmax));
   else
-    if (isa (A, "uint8"))
-      Amax = 8;
-      _conv = @uint8;
-    elseif (isa (A, "uint16"))
-      Amax = 16;
-      _conv = @uint16;
-    elseif (isa (A, "uint32"))
-      Amax = 32;
-      _conv = @uint32;
-    elseif (isa (A, "uint64"))
-      Amax = 64;
-      _conv = @uint64;
-    elseif (isa (A, "int8"))
-      Amax = 8;
-      _conv = @int8;
-    elseif (isa (A, "int16"))
-      Amax = 16;
-      _conv = @int16;
-    elseif (isa (A, "int32"))
-      Amax = 32;
-      _conv = @int32;
-    elseif (isa (A, "int64"))
-      Amax = 64;
-      _conv = @int64;
-    else
-      error ("bitset: invalid class %s", class (A));
-    endif
-    Bmax = intmax (class (A));
+    error ("bitset: invalid class %s", cl);
   endif
 
-  m = double (n(:));
-  if (any (m < 1) || any (m > Amax))
+  if (any ((n < 1)(:)) || any ((n > Amax)(:)))
     error ("bitset: N must be in the range [1,%d]", Amax);
   endif
 
-  mask = bitshift (_conv (1), uint8 (n) - uint8 (1));
-  C = bitxor (A, bitand (A, mask));
+  mask = bitshift (cast (1, cl), uint8 (n) - uint8 (1));
+
+  on = logical (val);
+  off = !on;
 
-  if (val)
-    C = bitor (A, mask);
+  if (isscalar (mask))
+    onmask = mask;
+    offmask = mask;
+  else
+    if (! size_equal (A, n))
+      error ("bitset: N must be scalar or the same size as A");
+    endif
+    onmask = mask(on);
+    offmask = mask(off);
   endif
 
+  C = zeros (sz, cl);
+  C(on) = bitor (A(on), onmask);
+  C(off) = bitand (A(off), bitcmp (offmask));
+
 endfunction
 
 
 %!test
 %! assert (bitset ([0, 10], [3, 3]), [4, 14]);
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
-%!error bitset (0, 0)
-%!error bitset (0, 55)
-%!error bitset (int8 (0), 9)
-%!error bitset (uint8 (0), 9)
-%!error bitset (int16 (0), 17)
-%!error bitset (uint16 (0), 17)
-%!error bitset (int32 (0), 33)
-%!error bitset (uint32 (0), 33)
-%!error bitset (int64 (0), 65)
-%!error bitset (uint64 (0), 65)
+## Bug #36458
+%!assert (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]), uint8 ([0, 3; 2 5]))
 
 %!error bitset (1)
 %!error bitset (1, 2, 3, 4)
+%!error <A must be .= 0> bitset (-1, 2)
+%!error <invalid class char> bitset ("1", 2)
+%!error <N must be in the range \[1,53\]> bitset (0, 0)
+%!error <N must be in the range \[1,53\]> bitset (0, 55)
+%!error <N must be in the range \[1,8\]> bitset (uint8 (0), 0)
+%!error <N must be in the range \[1,8\]> bitset (uint8 (0), 9)
+%!error <N must be in the range \[1,7\]> bitset (int8 (0), 9)
+%!error <N must be in the range \[1,15\]> bitset (int16 (0), 17)
+%!error <N must be in the range \[1,16\]> bitset (uint16 (0), 17)
+%!error <N must be in the range \[1,31\]> bitset (int32 (0), 33)
+%!error <N must be in the range \[1,32\]> bitset (uint32 (0), 33)
+%!error <N must be in the range \[1,63\]> bitset (int64 (0), 65)
+%!error <N must be in the range \[1,64\]> bitset (uint64 (0), 65)
+%!error <N must be scalar or the same size as A> bitset (uint8 (1), [1 3])
+%!error <N must be scalar or the same size as A> bitset (uint8 (1:3), [1 3])
 
diff --git a/scripts/gethelp.cc b/scripts/gethelp.cc
deleted file mode 100644
--- a/scripts/gethelp.cc
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-
-Copyright (C) 1999-2012 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#include <cstdio>
-
-#include <iostream>
-#include <string>
-
-static bool
-looks_like_octave_copyright (const std::string& s)
-{
-  // Perhaps someday we will want to do more here, so leave this as a
-  // separate function.
-
-  return (s.substr (0, 9) == "Copyright" || s.substr (0, 6) == "Author");
-}
-
-// Eat whitespace and comments from FFILE, returning the text of the
-// first block of comments that doesn't look like a copyright notice,
-
-static std::string
-extract_help_text (void)
-{
-  std::string help_txt;
-
-  bool first_comments_seen = false;
-  bool begin_comment = false;
-  bool have_help_text = false;
-  bool in_comment = false;
-  bool discard_space = true;
-  int c;
-
-  while ((c = std::cin.get ()) != EOF)
-    {
-      if (begin_comment)
-        {
-          if (c == '%' || c == '#')
-            continue;
-          else if (discard_space && c == ' ')
-            {
-              discard_space = false;
-              continue;
-            }
-          else
-            begin_comment = false;
-        }
-
-      if (in_comment)
-        {
-          if (! have_help_text)
-            {
-              first_comments_seen = true;
-              help_txt += static_cast<char> (c);
-            }
-
-          if (c == '\n')
-            {
-              in_comment = false;
-              discard_space = true;
-
-              if ((c = std::cin.get ()) != EOF)
-                {
-                  if (c == '\n')
-                    break;
-                }
-              else
-                break;
-            }
-        }
-      else
-        {
-          switch (c)
-            {
-            case ' ':
-            case '\t':
-              if (first_comments_seen)
-                have_help_text = true;
-              break;
-
-            case '\n':
-              if (first_comments_seen)
-                have_help_text = true;
-              continue;
-
-            case '%':
-            case '#':
-              begin_comment = true;
-              in_comment = true;
-              break;
-
-            default:
-              goto done;
-            }
-        }
-    }
-
- done:
-
-  if (! help_txt.empty ())
-    {
-      if (looks_like_octave_copyright (help_txt))
-        help_txt.resize (0);
-
-      if (help_txt.empty ())
-        help_txt = extract_help_text ();
-    }
-
-  return help_txt;
-}
-
-int
-main (int argc, char **argv)
-{
-  std::string name;
-  std::string file_name;
-
-  if (argc != 3)
-    {
-      std::cerr << "usage: gethelp name file-name\n";
-      return 1;
-    }
-  else
-    {
-      name = argv[1];
-      file_name = argv[2];
-    }
-
-  std::string help_text = extract_help_text ();
-
-  if (! help_text.empty ())
-    {
-      std::cout << "" << name << "\n"
-                << "@c " << name << " " << file_name << "\n"
-                << help_text;
-
-      if (help_text[help_text.length () - 1] != '\n')
-        std::cout << "\n";
-    }
-
-  return 0;
-}
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -89,28 +89,25 @@ function [retval, status] = __makeinfo__
   ## Formatting in m-files has an extra space at the beginning of every line.
   ## Remove these unwanted spaces if present.  First text char is "\n" delim.
   if (text(2) == " ")
     text = strrep (text, "\n ", "\n");
   endif
   ## Texinfo crashes if @end tex does not appear first on the line.
   text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
-  ## Handle @seealso macro
-  see_also_pat = '@seealso *\{(.*)\}';
-  args = regexp (text, see_also_pat, 'tokens');
-  for ii = 1:numel (args)
-    expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
-    text = regexprep (text, see_also_pat, expanded, 'once');
-  endfor
-
-  ## Handle @nospell macro
-  text = regexprep (text, '@nospell *\{([^}]*)\}', "$1");
-  ## Handle @xcode macro
-  text = regexprep (text, '@xcode *\{([^}]*)\}', "$1");
+  file = texi_macros_file ();
+  fid = fopen (file, "r");
+  if (fid < 0)
+    error ("unable to open %s for reading", file);
+  else
+    macros_text = fread (fid, Inf, "*char")';
+    text = cstrcat (macros_text, text);
+  endif
+  fclose (fid);
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
 
   ## Create the final TeXinfo input string
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -81,17 +81,17 @@ function retval = doc (fname)
     ## the third and fourth arguments.  Someone should fix that.
 
     cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
                    info_program (), info_file_name, info_dir);
 
     have_fname = ! isempty (fname);
 
     if (have_fname)
-      status = system (sprintf ("%s --index-search %s", cmd, fname));
+      status = system (sprintf ("%s --index-search \"%s\"", cmd, fname));
     endif
 
     if (! (have_fname && status == 0))
       status = system (cmd);
       if (status == 127)
         warning ("unable to find info program `%s'", info_program ());
       endif
     endif
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -23,16 +23,19 @@
 ## to yellow.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "autumn");
+## PKG_DEL: colormap ("unregister", "autumn");
+
 function map = autumn (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("autumn: argument must be a scalar");
     endif
@@ -43,17 +46,17 @@ function map = autumn (n)
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
     r = ones (n, 1);
     g = [0:(n-1)]' / (n - 1);
     b = zeros (n, 1);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'autumn' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -23,42 +23,45 @@
 ## gray-blue shades.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "bone");
+## PKG_DEL: colormap ("unregister", "bone");
+
 function map = bone (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("bone: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];
+    map = [0.125, 0.125, 0.125];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 3/4) .* (7/8 * x) ...
       + (x >= 3/4) .* (11/8 * x - 3/8);
     g = (x < 3/8) .* (7/8 * x) ...
       + (x >= 3/8 & x < 3/4) .* (29/24 * x - 1/8) ...
       + (x >= 3/4) .* (7/8 * x + 1/8);
     b = (x < 3/8) .* (29/24 * x) ...
       + (x >= 3/8) .* (7/8 * x + 1/8);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'bone' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 1994-2012 John W. Eaton
+## Copyright (C) 2012 Carn Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -15,61 +16,83 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{cmap} =} colormap ()
 ## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{map})
 ## @deftypefnx {Function File} {@var{cmap} =} colormap ("default")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("list")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("register", "name")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("unregister", "name")
 ## Query or set the current colormap.
 ##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## colormap should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## must be between 0 and 1 inclusive.  The new colormap is returned.
 ##
 ## @code{colormap ("default")} restores the default colormap (the
 ## @code{jet} map with 64 entries).  The default colormap is returned.
 ##
+## @code{colormap ("list")} returns a cell array with all the available
+## colormaps.  The options `register' and `unregister' will add or remove the
+## colormap @var{name} to it.
+##
 ## With no arguments, @code{colormap} returns the current color map.
 ## @seealso{jet}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function cmap = colormap (map)
+function cmap = colormap (map, name)
 
-  if (nargin > 1)
+  if (nargin > 2)
     print_usage ();
   endif
 
+  persistent map_list = cell ();
+
   if (nargin == 1)
 
     if (ischar (map))
       if (strcmp (map, "default"))
         map = jet (64);
+      elseif (strcmp (map, "list"))
+        cmap = map_list;
+        return;
       else
         map = feval (map);
       endif
     endif
 
     if (! isempty (map))
       if (columns (map) != 3)
         error ("colormap: MAP must have 3 columns: [R,G,B]");
       endif
       if (min (min (map)) < 0 || max (max (map)) > 1)
         error ("colormap: MAP must have values in [0,1]");
       endif
       ## Set the new color map
       set (gcf (), "colormap", map);
     endif
 
+  elseif (nargin == 2)
+    if (! ischar (map) || all (! strcmp (map, {"register", "unregister"})))
+      print_usage ();
+    elseif (! ischar (name))
+      error ("colormap: to register/unregister a colormap, NAME must be a string");
+    elseif (strcmp (map, "register"))
+      map_list{end+1} = name;
+    elseif (strcmp (map, "unregister"))
+      map_list(strcmp (name, map_list)) = [];
+    endif
   endif
 
   ## Return current color map.
   if (nargout > 0 || (nargout == 0 && nargin == 0))
     cmap = get (gcf (), "colormap");
   endif
 
 endfunction
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -22,16 +22,19 @@
 ## Create color colormap.  The colormap varies from cyan to magenta.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "cool");
+## PKG_DEL: colormap ("unregister", "cool");
+
 function map = cool (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("cool: argument must be a scalar");
     endif
@@ -42,17 +45,17 @@ function map = cool (n)
   if (n == 1)
     map = [0, 1, 1];
   elseif (n > 1)
     r = [0:(n-1)]' / (n - 1);
     g = 1 - r;
     b = ones (n, 1);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'cool' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -23,16 +23,19 @@
 ## a light copper tone.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "copper");
+## PKG_DEL: colormap ("unregister", "copper");
+
 function map = copper (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("copper: argument must be a scalar");
     endif
@@ -45,17 +48,17 @@ function map = copper (n)
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 4/5) .* (5/4 * x) ...
       + (x >= 4/5);
     g = 4/5 * x;
     b = 1/2 * x;
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'copper' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -23,30 +23,39 @@
 ## and black with each index change.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "flag");
+## PKG_DEL: colormap ("unregister", "flag");
+
 function map = flag (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("flag: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  C = [1, 0, 0; 1, 1, 1; 0, 0, 1; 0, 0, 0];
-  map = C(rem (0:(n-1), 4) + 1, :);
+  if (n == 1)
+    map = [1, 0, 0];
+  elseif (n > 1)
+    C = [1, 0, 0; 1, 1, 1; 0, 0, 1; 0, 0, 0];
+    map = C(rem (0:(n-1), 4) + 1, :);
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'flag' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -23,30 +23,37 @@
 ## magenta and cyan.  This colormap is specifically designed for users of
 ## gnuplot 4.0 where these 6 colors are the allowable ones for patch objects.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, a length of 6 is assumed.  Larger values of @var{n} result
 ## in a repetition of the above colors.
 ## @seealso{colormap}
 ## @end deftypefn
 
+## PKG_ADD: colormap ("register", "gmap40");
+## PKG_DEL: colormap ("unregister", "gmap40");
+
 function map = gmap40 (n)
 
   if (nargin == 0)
     n = 6;
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("gmap40: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  C = [1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1];
-  map = C(rem (0:(n-1), 6) + 1, :);
+  if (n > 1)
+    C = [1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1];
+    map = C(rem (0:(n-1), 6) + 1, :);
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'gmap40' colormap as an image
 %! image (1:6, linspace (0, 1, 6), repmat ((1:6)', 1, 6));
 %! axis ([1, 6, 0, 1], "ticy", "xy");
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -25,31 +25,39 @@
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
+## PKG_ADD: colormap ("register", "gray");
+## PKG_DEL: colormap ("unregister", "gray");
+
 function map = gray (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("gray: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  gr = [0:(n-1)]' / (n - 1);
-
-  map = [gr, gr, gr];
+  if (n == 1)
+    map = [0, 0, 0];
+  elseif (n > 1)
+    gr = [0:(n-1)]' / (n - 1);
+    map = [gr, gr, gr];
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'gray' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -23,40 +23,43 @@
 ## red, orange, yellow, to white.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "hot");
+## PKG_DEL: colormap ("unregister", "hot");
+
 function map = hot (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("hot: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];
+    map = [1, 1, 1];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 2/5) .* (5/2 * x) ...
       + (x >= 2/5);
     g = (x >= 2/5 & x < 4/5) .* (5/2 * x - 1) ...
       + (x >= 4/5);
     b = (x >= 4/5) .* (5 * x - 4);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'hot' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -27,16 +27,19 @@
 ##
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "hsv");
+## PKG_DEL: colormap ("unregister", "hsv");
+
 function map = hsv (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("hsv: argument must be a scalar");
     endif
@@ -45,17 +48,17 @@ function map = hsv (n)
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
     hue = linspace (0, 1, n)';
     map = hsv2rgb ([hue, ones(n,1), ones(n,1)]);
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'hsv' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -23,44 +23,47 @@
 ## cyan, green, yellow, red, to dark red.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "jet");
+## PKG_DEL: colormap ("unregister", "jet");
+
 function map = jet (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("jet: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0.5];
+    map = [0, 1, 1];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x >= 3/8 & x < 5/8) .* (4 * x - 3/2) ...
       + (x >= 5/8 & x < 7/8) ...
       + (x >= 7/8) .* (-4 * x + 9/2);
     g = (x >= 1/8 & x < 3/8) .* (4 * x - 1/2) ...
       + (x >= 3/8 & x < 5/8) ...
       + (x >= 5/8 & x < 7/8) .* (-4 * x + 7/2);
     b = (x < 1/8) .* (4 * x + 1/2) ...
       + (x >= 1/8 & x < 3/8) ...
       + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'jet' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/lines.m b/scripts/image/lines.m
--- a/scripts/image/lines.m
+++ b/scripts/image/lines.m
@@ -22,31 +22,40 @@
 ## Create color colormap.  This colormap is composed of the list of colors
 ## in the current axes "ColorOrder" property.  The default is blue,
 ## green, red, cyan, pink, yellow, and gray.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
+## PKG_ADD: colormap ("register", "lines");
+## PKG_DEL: colormap ("unregister", "lines");
+
 function map = lines (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("lines: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  C = get (gca, "colororder");
-  nr = rows (C);
-  map = C(rem (0:(n-1), nr) + 1, :);
+  if (n == 1)
+    map = [0, 0, 1];
+  elseif (n > 1)
+    C = get (gca, "colororder");
+    nr = rows (C);
+    map = C(rem (0:(n-1), nr) + 1, :);
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'lines' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -25,39 +25,48 @@
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
+## PKG_ADD: colormap ("register", "ocean");
+## PKG_DEL: colormap ("unregister", "ocean");
+
 function map = ocean (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("ocean: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  cutin = fix (n/3);
+  if (n == 1)
+    map = [0, 0, 0];
+  elseif (n > 1)
+    cutin = fix (n/3);
 
-  dr = (n - 1) / cutin;
-  r = prepad ([0:dr:(n-1)], n)';
+    dr = (n - 1) / cutin;
+    r = prepad ([0:dr:(n-1)], n)';
 
-  dg = (n - 1) / (2 * cutin);
-  g = prepad ([0:dg:(n-1)], n)';
+    dg = (n - 1) / (2 * cutin);
+    g = prepad ([0:dg:(n-1)], n)';
+
+    b = [0:(n-1)]';
 
-  b = [0:(n-1)]';
-
-  map = [r, g, b] / (n - 1);
+    map = [r, g, b] / (n - 1);
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'ocean' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -23,42 +23,45 @@
 ## shades of gray-pink.  It gives a sepia tone when used on grayscale images.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "pink");
+## PKG_DEL: colormap ("unregister", "pink");
+
 function map = pink (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("pink: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];
+    map = sqrt([1/3, 1/3, 1/3]);
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 3/8) .* (14/9 * x) ...
       + (x >= 3/8) .* (2/3 * x + 1/3);
     g = (x < 3/8) .* (2/3 * x) ...
       + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3) ...
       + (x >= 3/4) .* (2/3 * x + 1/3);
     b = (x < 3/4) .* (2/3 * x) ...
       + (x >= 3/4) .* (2 * x - 1);
     map = sqrt ([r, g, b]);
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'pink' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -23,30 +23,39 @@
 ## green, blue and violet with each index change.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "prism");
+## PKG_DEL: colormap ("unregister", "prism");
+
 function map = prism (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("prism: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
-  C = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
-  map = C(rem (0:(n-1), 6) + 1, :);
+  if (n == 1)
+    map = [1 0 0];
+  elseif (n > 1)
+    C = [1, 0, 0; 1, 1/2, 0; 1, 1, 0; 0, 1, 0; 0, 0, 1; 2/3, 0, 1];
+    map = C(rem (0:(n-1), 6) + 1, :);
+  else
+    map = zeros (0, 3);
+  endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'prism' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
 %! axis ([1, 64, 0, 1], "ticy", "xy");
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -26,16 +26,19 @@
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 ## this colormap is not part of matlab, it is like the prism
 ## colormap map but with a continuous map
 
+## PKG_ADD: colormap ("register", "rainbow");
+## PKG_DEL: colormap ("unregister", "rainbow");
+
 function map = rainbow (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("rainbow: argument must be a scalar");
     endif
@@ -55,17 +58,17 @@ function map = rainbow (n)
     g = ((x < 2/5) .* (5/2 * x)
          + (x >= 2/5 & x < 3/5)
          + (x >= 3/5 & x < 4/5) .* (-5 * x + 4));
 
     b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
 
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'rainbow' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -22,16 +22,19 @@
 ## Create color colormap.  This colormap varies from magenta to yellow.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "spring");
+## PKG_DEL: colormap ("unregister", "spring");
+
 function map = spring (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("spring: argument must be a scalar");
     endif
@@ -42,17 +45,17 @@ function map = spring (n)
   if (n == 1)
     map = [1, 0, 1];
   elseif (n > 1)
     r = ones (n, 1);
     g = [0:(n-1)]' / (n - 1);
     b = 1 - g;
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'spring' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -23,16 +23,19 @@
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date:  06/03/2000
 
+## PKG_ADD: colormap ("register", "summer");
+## PKG_DEL: colormap ("unregister", "summer");
+
 function map = summer (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("summer: argument must be a scalar");
     endif
@@ -43,17 +46,17 @@ function map = summer (n)
   if (n == 1)
     map = [0, 0.5, 0.4];
   elseif (n > 1)
     r = [0:(n-1)]' / (n - 1);
     g = 0.5 + r / 2;
     b = 0.4 * ones (n, 1);
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'summer' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -22,16 +22,19 @@
 ## Create color colormap.  This colormap is completely white.
 ## The argument @var{n} should be a scalar.  If it
 ## is omitted, the length of the current colormap or 64 is assumed.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "white");
+## PKG_DEL: colormap ("unregister", "white");
+
 function map = white (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("white: argument must be a scalar");
     endif
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -22,16 +22,19 @@
 ## Create color colormap.  This colormap varies from blue to green.
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
+## PKG_ADD: colormap ("register", "winter");
+## PKG_DEL: colormap ("unregister", "winter");
+
 function map = winter (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
       error ("winter: argument must be a scalar");
     endif
@@ -42,17 +45,17 @@ function map = winter (n)
   if (n == 1)
     map = [0, 0, 1];
   elseif (n > 1)
     r = zeros (n, 1);
     g = [0:(n-1)]' / (n - 1);
     b = 1 - g / 2;
     map = [r, g, b];
   else
-    map = [];
+    map = zeros (0, 3);
   endif
 
 endfunction
 
 
 %!demo
 %! ## Show the 'winter' colormap as an image
 %! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -36,17 +36,17 @@
 ## The first @var{value} number of lines of @var{filename} are skipped.
 ##
 ## @item "endofline":
 ## Specify a single character or "\r\n".  If no value is given, it will be
 ## inferred from the file.  If set to "" (empty string) EOLs are ignored as
 ## delimiters.
 ## @end itemize
 ##
-## The optional input @var{n} specifes the number of data lines to read; in
+## The optional input @var{n} specifies the number of data lines to read; in
 ## this sense it differs slightly from the format repeat count in strread.
 ##
 ## @seealso{strread, load, dlmread, fscanf, textscan}
 ## @end deftypefn
 
 function varargout = textread (filename, format = "%f", varargin)
 
   BUFLENGTH = 4096;       # Read buffer to speed up processing @var{n}
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -48,19 +48,19 @@
 ## The first @var{value} number of lines of @var{fid} are skipped.
 ##
 ## @item "returnonerror":
 ## If set to numerical 1 or true (default), return normally when read errors
 ## have been encountered.  If set to 0 or false, return an error and no data.
 ## @end itemize
 ##
 ## When reading from a character string, optional input argument @var{n}
-## specifes the number of times @var{format} should be used (i.e., to limit
+## specifies the number of times @var{format} should be used (i.e., to limit
 ## the amount of data read).
-## When reading fro file, @var{n} specifes the number of data lines to read;
+## When reading fro file, @var{n} specifies the number of data lines to read;
 ## in this sense it differs slightly from the format repeat count in strread.
 ##
 ## The output @var{C} is a cell array whose length is given by the number
 ## of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
diff --git a/scripts/mkdoc.pl b/scripts/mkdoc.pl
new file mode 100755
--- /dev/null
+++ b/scripts/mkdoc.pl
@@ -0,0 +1,104 @@
+#! /usr/bin/perl -w
+#
+# Copyright (C) 2012 Rik Wehbring
+#
+# This file is part of Octave.
+#
+# Octave is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3 of the License, or (at
+# your option) any later version.
+#
+# Octave is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Octave; see the file COPYING.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+## Expecting arguments in this order:
+##
+##  SRCDIR SRCDIR-FILES ... -- LOCAL-FILES ...
+
+unless (@ARGV >= 2) { die "Usage: $0 srcdir m_filename1 ..." ; }
+
+$srcdir = shift (@ARGV) . '/';
+
+print <<__END_OF_MSG__;
+### DO NOT EDIT!
+###
+### This file is generated automatically from Octave source files.
+### Edit source files directly and run make to update this file.
+
+__END_OF_MSG__
+
+MFILE: foreach $m_fname (@ARGV)
+{
+  if ($m_fname eq "--")
+  {
+    $srcdir = "./";
+    next MFILE;
+  }
+
+  $full_fname = $srcdir . $m_fname;
+  next MFILE unless ( $full_fname =~ m{(.*)/(@|)([^/]*)/(.*)\.m} );
+  if ($2) {
+    $fcn = "$2$3/$4";
+  } else {
+    $fcn = $4;
+  }
+
+  @help_txt = gethelp ($fcn, $full_fname);
+  next MFILE if ($help_txt[0] eq "");
+
+  print "$fcn\n";
+  print "\@c $fcn scripts/$m_fname\n";
+
+  foreach $_ (@help_txt)
+  {
+    s/^\s+\@/\@/ unless $in_example;
+    s/^\s+\@group/\@group/;
+    s/^\s+\@end\s+group/\@end group/;
+    $in_example = (/\s*\@example\b/ .. /\s*\@end\s+example\b/);
+    print $_;
+  }
+}
+
+################################################################################
+# Subroutines
+################################################################################
+sub gethelp
+{
+  ($fcn, $fname) = @_[0..1]; 
+  open (FH, $fname) or return "";
+
+  do
+  {
+    @help_txt = ();
+
+    ## Advance to non-blank line
+    while (defined ($_ = <FH>) and /^\s*$/) {;}
+
+    if (! /^\s*(?:#|%)/ or eof (FH))
+    {
+      ## No comment block found.  Return empty string
+      close (FH);
+      return "";
+    }
+
+    ## Extract help text stopping when comment block ends
+    do
+    {
+      ## Remove comment characters at start of line
+      s/^\s*(?:#|%){1,2} ?//;
+      push (@help_txt, $_);
+    } until (! defined ($_ = <FH>) or ! /^\s*(?:#|%)/);
+
+  } until ($help_txt[0] !~ /^(?:Copyright|Author)/); 
+
+  close (FH);
+
+  return @help_txt;
+}
diff --git a/scripts/pkg/private/get_unsatisfied_deps.m b/scripts/pkg/private/get_unsatisfied_deps.m
--- a/scripts/pkg/private/get_unsatisfied_deps.m
+++ b/scripts/pkg/private/get_unsatisfied_deps.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc},@var{installed_pkgs_lst})
+## @deftypefn {Function File} {@var{bad_deps} =} get_unsatisfied_deps (@var{desc}, @var{installed_pkgs_lst})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function bad_deps = get_unsatisfied_deps (desc, installed_pkgs_lst)
   bad_deps = {};
 
   ## For each dependency.
   for i = 1:length (desc.depends)
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -35,21 +35,21 @@ function [out1, out2] = installed_packag
     global_packages = {};
   end_try_catch
   installed_pkgs_lst = {local_packages{:}, global_packages{:}};
 
   ## Eliminate duplicates in the installed package list.
   ## Locally installed packages take precedence.
   dup = [];
   for i = 1:length (installed_pkgs_lst)
-    if (find (dup, i))
+    if (any (dup == i))
       continue;
     endif
     for j = (i+1):length (installed_pkgs_lst)
-      if (find (dup, j))
+      if (any (dup == j))
         continue;
       endif
       if (strcmp (installed_pkgs_lst{i}.name, installed_pkgs_lst{j}.name))
         dup = [dup, j];
       endif
     endfor
   endfor
   if (! isempty(dup))
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -76,21 +76,21 @@ function descriptions = rebuild (prefix,
 
   if (! isempty (files))
     ## We are rebuilding for a particular package(s) so we should take
     ## care to keep the other untouched packages in the descriptions
     descriptions = {descriptions{:}, old_descriptions{:}};
 
     dup = [];
     for i = 1:length (descriptions)
-      if (find (dup, i))
+      if (any (dup == i))
         continue;
       endif
       for j = (i+1):length (descriptions)
-        if (find (dup, j))
+        if (any (dup == j))
           continue;
         endif
         if (strcmp (descriptions{i}.name, descriptions{j}.name))
           dup = [dup, j];
         endif
       endfor
     endfor
     if (! isempty (dup))
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -144,17 +144,17 @@ function [nn, xx] = hist (y, varargin)
              (chist(end,:) - sum (isnan (y)))];
   endif
 
   freq = diff (chist);
 
   if (nargin > 2 && ! ischar (varargin{iarg}))
     ## Normalise the histogram.
     norm = varargin{iarg++};
-    freq = freq / rows (y) * norm;
+    freq = freq / sum(! isnan (y)) * norm;
   endif
 
   if (nargout > 0)
     if (arg_is_vector)
       nn = freq';
       xx = x';
     else
       nn = freq;
@@ -177,16 +177,20 @@ endfunction
 %! [nn,xx] = hist ([1:4]', 3);
 %! assert (xx, [1.5,2.5,3.5]);
 %! assert (nn, [2,1,1]);
 %!test
 %! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
 %! assert (xx, [1,2,3]);
 %! assert (nn, [3,2,1]);
 %!test
+%! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3], 6);
+%! assert (xx, [1,2,3]);
+%! assert (nn, [3,2,1]);
+%!test
 %! [nn,xx] = hist ([[1:4]', [1:4]'], 3);
 %! assert (xx, [1.5;2.5;3.5]);
 %! assert (nn, [[2,1,1]',[2,1,1]']);
 %!test
 %! for n = [10, 30, 100, 1000]
 %!   assert (sum (hist ([1:n], n)), n);
 %!   assert (sum (hist ([1:n], [2:n-1])), n);
 %!   assert (sum (hist ([1:n], [1:n])), n);
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -16,32 +16,32 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} print ()
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
-## Print a graph, or save it to a file. Both output formatted for 
+## Print a graph, or save it to a file.  Both output formatted for 
 ## printing (PDF and PostScript), and many bitmapped and vector
 ## image formats are supported.
 ##
 ## @var{h} specifies the figure handle.  If no handle is specified
 ## the handle for the current figure is used.
 ##
 ## @var{filename} defines the name of the output file.  If the
 ## file name has no suffix, one is inferred from the specified
 ## device and appended to the file name.  If no filename is
 ## specified, the output is sent to the printer.
 ##
 ## For output to a printer, to a PostScript file, or a PDF file,
 ## the paper size is specified by the figure's @code{papersize}
-## property. The location and size of the image on the page are
-## specified by the figure's @code{paperposition} property. The
+## property.  The location and size of the image on the page are
+## specified by the figure's @code{paperposition} property.  The
 ## orientation of the page is specified by the figure's
 ## @code{paperorientation} property.
 ##
 ## The width and height of images are specified by the figure's
 ## @code{paperpositon(3:4)} property values.
 ##
 ## The @code{print} command supports several @var{options}:
 ##
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/shrinkfaces.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} shrinkfaces (@var{p}, @var{sf})
+## @deftypefn  {Function File} {} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{p}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{fv}, @var{sf})
 ## @deftypefnx {Function File} {@var{nfv} =} shrinkfaces (@var{f}, @var{v}, @var{sf})
 ## @deftypefnx {Function File} {[@var{nf}, @var{nv}] =} shrinkfaces (@dots{})
 ##
 ## Reduce the faces area for a given patch, structure or explicit faces
 ## and points matrices by a scale factor @var{sf}.  The structure
 ## @var{fv} must contain the fields 'faces' and 'vertices'.  If the
@@ -35,34 +35,34 @@
 ## If called with one output argument, return a structure with fields
 ## 'faces', 'vertices', and 'facevertexcdata' containing the data after
 ## shrinking which can then directly be used as an input argument for the
 ## @command{patch} function.
 ##
 ## Performing the shrinking on faces which are not convex can lead to
 ## undesired results.
 ##
-## For example
+## For example,
 ##
 ## @example
 ## @group
 ## [phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
 ## tri = delaunay (phi(:), r(:));
 ## v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
 ## clf ()
 ## p = patch ("Faces", tri, "Vertices", v, "FaceColor", "none");
 ## fv = shrinkfaces (p);
 ## patch (fv)
 ## axis equal
 ## grid on
 ## @end group
 ## @end example
 ##
 ## @noindent
-## draws a triangulated 3/4 circle and the corresponding shrinked
+## draws a triangulated 3/4 circle and the corresponding shrunken
 ## version.
 ## @seealso{patch}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [nf, nv] = shrinkfaces (varargin)
 
diff --git a/scripts/plot/tetramesh.m b/scripts/plot/tetramesh.m
--- a/scripts/plot/tetramesh.m
+++ b/scripts/plot/tetramesh.m
@@ -12,19 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} tetramesh (@var{T}, @var{X})
-## @deftypefnx {Function File} tetramesh (@var{T}, @var{X}, @var{C})
-## @deftypefnx {Function File} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
+## @deftypefn  {Function File} {} tetramesh (@var{T}, @var{X})
+## @deftypefnx {Function File} {} tetramesh (@var{T}, @var{X}, @var{C})
+## @deftypefnx {Function File} {} tetramesh (@dots{}, @var{property}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} tetramesh (@dots{})
 ##
 ## Display the tetrahedrons defined in the m-by-4 matrix @var{T}
 ## as 3-D patches.  @var{T} is typically the output of a Delaunay triangulation
 ## of a 3-D set of points.  Every row of @var{T} contains four indices into
 ## the n-by-3 matrix @var{X} of the vertices of a tetrahedron.  Every row in
 ## @var{X} represents one point in 3-D space. 
 ##
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## @deftypefnx {Function File} {[@var{p}, @var{s}, @var{mu}] =} polyfit (@var{x}, @var{y}, @var{n})
 ## Return the coefficients of a polynomial @var{p}(@var{x}) of degree
 ## @var{n} that minimizes the least-squares-error of the fit to the points
-## @code{[@var{x}, @var{y}]}. If @var{n} is a logical vector, it is used
+## @code{[@var{x}, @var{y}]}.  If @var{n} is a logical vector, it is used
 ## as a mask to selectively force the corresponding polynomial
 ## coefficients to be used or ignored.
 ##
 ## The polynomial coefficients are returned in a row vector.
 ##
 ## The optional output @var{s} is a structure containing the following fields:
 ##
 ## @table @samp
@@ -48,17 +48,17 @@
 ## @item normr
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
 ## @end table
 ##
 ## The second output may be used by @code{polyval} to calculate the
-## statistical error limits of the predicted values. In particular, the
+## statistical error limits of the predicted values.  In particular, the
 ## standard deviation of @var{p} coefficients is given by @*
 ## @code{sqrt (diag (s.C)/s.df)*s.normr}.
 ##
 ## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -12,39 +12,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{breaks})
-## Fits a piecewise cubic spline with breaks (knots) @var{breaks} to the
+## @deftypefn {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{breaks})
+## Fit a piecewise cubic spline with breaks (knots) @var{breaks} to the
 ## noisy data, @var{x} and @var{y}.  @var{x} is a vector, and @var{y}
-## a vector or ND array.  If @var{y} is an ND array, then @var{x}(j)
-## is matched to @var{y}(:,...,:,j).
+## a vector or N-D array.  If @var{y} is an N-D array, then @var{x}(j)
+## is matched to @var{y}(:,@dots{},:,j).
 ##
-## The fitted spline is returned as a piece-wise polynomial, @var{pp}, and
+## The fitted spline is returned as a piecewise polynomial, @var{pp}, and
 ## may be evaluated using @code{ppval}.
 ##
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@var{x}, @var{y}, @var{p})
 ## @var{p} is a positive integer defining the number of intervals along @var{x},
-## and @var{p}+1 is the number of breaks. The number of points in each interval
+## and @var{p}+1 is the number of breaks.  The number of points in each interval
 ## differ by no more than 1.
 ##
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "periodic", @var{periodic})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "robust", @var{robust})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "beta", @var{beta})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "order", @var{order})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
 ##
 ## The optional property @var{periodic} is a logical value which specifies
 ## whether a periodic boundary condition is applied to the spline.  The
-## length of the period  is @code{max(@var{breaks})-min(@var{breaks})}.
+## length of the period is @code{max(@var{breaks})-min(@var{breaks})}.
 ## The default value is @code{false}.
 ##
 ## The optional property @var{robust} is a logical value which specifies
 ## if robust fitting is to be applied to reduce the influence of outlying
 ## data points.  Three iterations of weighted least squares are performed.
 ## Weights are computed from previous residuals.  The sensitivity of outlier
 ## identification is controlled by the property @var{beta}.  The value of
 ## @var{beta} is stricted to the range, 0 < @var{beta} < 1.  The default
@@ -60,22 +60,24 @@
 ##
 ## The optional property, @var{constaints}, is a structure specifying
 ## linear constraints on the fit.  The structure has three fields, "xc",
 ## "yc", and "cc".
 ##
 ## @table @asis
 ## @item "xc"
 ## Vector of the x-locations of the constraints.
+##
 ## @item "yc"
-## Constaining values at the locations, @var{xc}.
+## Constraining values at the locations, @var{xc}.
 ## The default is an array of zeros.
+##
 ## @item "cc"
 ## Coefficients (matrix).  The default is an array of ones.  The number of
-## rows is limited to the order of the piece-wise polynomials, @var{order}.
+## rows is limited to the order of the piecewise polynomials, @var{order}.
 ## @end table
 ##
 ## Constraints are linear combinations of derivatives of order 0 to
 ## @var{order}-1 according to
 ##
 ## @example
 ## @group
 ## @tex
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -10,17 +10,16 @@
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicg (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicg (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the Bi-conjugate gradient iterative method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given
 ## or set to [] the default value 1e-6 is used.
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -13,17 +13,16 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} bicgstab (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} bicgstab (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b} using the stabilizied Bi-conjugate gradient iterative
 ## method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -13,17 +13,16 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-##
 ## @deftypefn  {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{M1}, @var{M2}, @var{x0})
 ## @deftypefnx {Function File} {@var{x} =} cgs (@var{A}, @var{b}, @var{rtol}, @var{maxit}, @var{P})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} cgs (@var{A}, @var{b}, @dots{})
 ## Solve @code{A x = b}, where @var{A} is a square matrix, using the
 ## Conjugate Gradients Squared method.
 ##
 ## @itemize @minus
 ## @item @var{rtol} is the relative tolerance, if not given or set to []
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -92,17 +92,17 @@ Cell::Cell (const Array<std::string>& sa
   for (octave_idx_type i = 0; i < n; i++)
     dst[i] = src[i];
 }
 
 // Set size to DV, filling with [].  Then fill with as many elements of
 // SV as possible.
 
 Cell::Cell (const dim_vector& dv, const string_vector& sv, bool trim)
-  : Array<octave_value> (dv, resize_fill_value ())
+  : Array<octave_value> (dv, Matrix ())
 {
   octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
       octave_idx_type len = n > m ? m : n;
@@ -168,32 +168,30 @@ Cell::index (const octave_value_list& id
       retval = *this;
       break;
 
     case 1:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
-          retval = Array<octave_value>::index (i, resize_ok,
-                                               resize_fill_value ());
+          retval = Array<octave_value>::index (i, resize_ok, Matrix ());
       }
       break;
 
     case 2:
       {
         idx_vector i = idx_arg(0).index_vector ();
 
         if (! error_state)
           {
             idx_vector j = idx_arg(1).index_vector ();
 
             if (! error_state)
-              retval = Array<octave_value>::index (i, j, resize_ok,
-                                                    resize_fill_value ());
+              retval = Array<octave_value>::index (i, j, resize_ok, Matrix ());
           }
       }
       break;
 
     default:
       {
         Array<idx_vector> iv (dim_vector (n, 1));
 
@@ -201,18 +199,17 @@ Cell::index (const octave_value_list& id
           {
             iv(i) = idx_arg(i).index_vector ();
 
             if (error_state)
               break;
           }
 
         if (!error_state)
-          retval = Array<octave_value>::index (iv, resize_ok,
-                                                resize_fill_value ());
+          retval = Array<octave_value>::index (iv, resize_ok, Matrix ());
       }
       break;
     }
 
   return retval;
 }
 
 void
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -43,20 +43,20 @@ public:
     : Array<octave_value> (dim_vector (0, 0)) { }
 
   Cell (const octave_value& val)
     : Array<octave_value> (dim_vector (1, 1), val) { }
 
   Cell (const octave_value_list& ovl);
 
   Cell (octave_idx_type n, octave_idx_type m,
-        const octave_value& val = resize_fill_value ())
+        const octave_value& val = Matrix ())
     : Array<octave_value> (dim_vector (n, m), val) { }
 
-  Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
+  Cell (const dim_vector& dv, const octave_value& val = Matrix ())
     : Array<octave_value> (dv, val) { }
 
   Cell (const Array<octave_value>& c)
     : Array<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c, octave_idx_type nr, octave_idx_type nc)
     : Array<octave_value> (c, dim_vector (nr, nc)) { }
 
@@ -81,17 +81,17 @@ public:
 
   using Array<octave_value>::delete_elements;
 
   void delete_elements (const octave_value_list& idx);
 
   using Array<octave_value>::assign;
 
   void assign (const octave_value_list& idx, const Cell& rhs,
-               const octave_value& fill_val = resize_fill_value ());
+               const octave_value& fill_val = Matrix ());
 
   Cell reshape (const dim_vector& new_dims) const
     { return Array<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
@@ -105,17 +105,21 @@ public:
 
   Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
   Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
-  static octave_value resize_fill_value (void) { return Matrix (); }
+  octave_value resize_fill_value (void) const
+  {
+    static Matrix rfv;
+    return rfv;
+  }
 
   Cell diag (octave_idx_type k = 0) const;
 
   Cell diag (octave_idx_type m, octave_idx_type n) const;
 
   Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
   Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
   Cell xisascii (void) const { return map (&octave_value::xisascii); }
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -124,19 +124,19 @@ Called with either a sparse or full matr
 @ifnottex\n\
 \n\
 @example\n\
 @var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-For full matrices, if the \"lower\" flag is set only the lower triangular part\n\
-of the matrix is used for the factorization, otherwise the upper triangular\n\
-part is used.\n\
+For full matrices, if the \"lower\" flag is set only the lower triangular\n\
+part of the matrix is used for the factorization, otherwise the upper\n\
+triangular part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -618,27 +618,29 @@ using @code{inv}.\n\
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
+\n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
 if @var{op} is \"+\"\n\
 \n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'\n\
 if @var{op} is \"-\"\n\
 @end itemize\n\
 \n\
 If @var{op} is \"-\", @var{info} is set to\n\
+\n\
 @itemize\n\
 @item 0 if the downdate was successful,\n\
 \n\
 @item 1 if @var{R}'*@var{R} - @var{u}*@var{u}' is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
@@ -828,16 +830,17 @@ DEFUN_DLD (cholinsert, args, nargout,
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
+\n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
 \n\
 @item 1 if @var{A1} is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
 @end itemize\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -353,17 +353,20 @@ rand (\"state\", v)\n\
 \n\
 @noindent\n\
 You may also initialize the state vector from an arbitrary vector of\n\
 length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
 available, otherwise from CPU time, wall clock time, and the current\n\
-fraction of a second.\n\
+fraction of a second.  Note that this differs from @sc{matlab}, which\n\
+always initializes the state to the same state at startup.  To obtain\n\
+behavior comparable to @sc{matlab}, initialize with a deterministic state\n\
+vector in Octave's startup files (@pxref{Startup Files}).\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
 Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and\n\
 T. Nishimura,\n\
 @cite{Mersenne Twister: A 623-dimensionally equidistributed uniform\n\
 pseudorandom number generator}, ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,\n\
 @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).\n\
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -37,266 +37,290 @@ along with Octave; see the file COPYING.
 #include "ov-int64.h"
 #include "ov-int32.h"
 #include "ov-int16.h"
 #include "ov-int8.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
-// FIXME -- could probably eliminate some code duplication by
-// clever use of templates.
+#include <functional>
+
+template <typename OP, typename T>
+octave_value
+bitopxx(const OP& op, const std::string& fname,
+        const Array<T>& x, const Array<T>& y)
+{
+  int nelx = x.numel ();
+  int nely = y.numel ();
+
+  bool is_scalar_op = (nelx == 1 || nely == 1);
+
+  dim_vector dvx = x.dims ();
+  dim_vector dvy = y.dims ();
+
+  bool is_array_op = (dvx == dvy);
+
+  octave_value retval;
+  if (is_array_op || is_scalar_op)
+    {
+      Array<T> result;
+
+      if (nelx != 1)
+        result.resize (dvx);
+      else
+        result.resize (dvy);
+
+      for (int i = 0; i < nelx; i++)
+        if (is_scalar_op)
+          for (int k = 0; k < nely; k++)
+            result(i+k) = op(x(i), y(k));
+        else
+          result(i) = op(x(i), y(i));
+
+      retval = result;
+    }
+  else
+    error ("%s: size of X and Y must match, or one operand must be a scalar",
+           fname.c_str());
+
+  return retval;
+}
 
-#define BITOPX(OP, FNAME, RET) \
-      { \
-        int nelx = x.numel (); \
-        int nely = y.numel (); \
- \
-        bool is_scalar_op = (nelx == 1 || nely == 1); \
- \
-        dim_vector dvx = x.dims (); \
-        dim_vector dvy = y.dims (); \
- \
-        bool is_array_op = (dvx == dvy); \
- \
-        if (is_array_op || is_scalar_op) \
-          { \
-            RET result; \
- \
-            if (nelx != 1) \
-              result.resize (dvx); \
-            else \
-              result.resize (dvy); \
- \
-            for (int i = 0; i < nelx; i++) \
-              if (is_scalar_op) \
-                for (int k = 0; k < nely; k++) \
-                  result(i+k) = x(i) OP y(k); \
-              else \
-                result(i) = x(i) OP y(i); \
- \
-              retval = result; \
-          } \
-        else \
-          error ("%s: size of X and Y must match, or one operand must be a scalar", FNAME); \
-      }
+// Trampoline function, instantiates the proper template above, with
+// reflective information hardwired. We can't hardwire this information
+// in Fbitxxx DEFUNs below, because at that moment, we still don't have
+// information about which integer types we need to instantiate.
+template<typename T>
+octave_value
+bitopx(const std::string& fname, const Array<T>& x, const Array<T>& y)
+{
+  if (fname == "bitand")
+    return bitopxx (std::bit_and<T>(), fname, x, y);
+  if (fname == "bitor")
+    return bitopxx (std::bit_or<T>(), fname, x, y);
+
+  //else (fname == "bitxor")
+  return bitopxx (std::bit_xor<T>(), fname, x, y);
+}
+
+octave_value
+bitop(const std::string& fname, const octave_value_list& args)
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 2)
+    {
+      if ((args(0).class_name () == octave_scalar::static_class_name ())
+          || (args(0).class_name () == octave_bool::static_class_name ())
+          || (args(1).class_name () == octave_scalar::static_class_name ())
+          || (args(1).class_name () == octave_bool::static_class_name ()))
+        {
+          bool arg0_is_int = (args(0).class_name () !=
+                              octave_scalar::static_class_name () &&
+                              args(0).class_name () !=
+                              octave_bool::static_class_name ());
+          bool arg1_is_int = (args(1).class_name () !=
+                              octave_scalar::static_class_name () &&
+                              args(1).class_name () !=
+                              octave_bool::static_class_name ());
+
+          if (! (arg0_is_int || arg1_is_int))
+            {
+              uint64NDArray x (args(0).array_value ());
+              uint64NDArray y (args(1).array_value ());
+              if (! error_state)
+                retval = bitopx (fname, x, y).array_value();
+            }
+          else
+            {
+              int p = (arg0_is_int ? 1 : 0);
+              int q = (arg0_is_int ? 0 : 1);
+
+              NDArray dx = args(p).array_value ();
 
-#define BITOP(OP, FNAME) \
- \
-  octave_value retval; \
- \
-  int nargin = args.length (); \
- \
-  if (nargin == 2) \
-    { \
-      if ((args(0).class_name () == octave_scalar::static_class_name ()) \
-          || (args(0).class_name () == octave_bool::static_class_name ()) \
-          || (args(1).class_name () == octave_scalar::static_class_name ()) \
-          || (args(1).class_name () == octave_bool::static_class_name ())) \
-        { \
-          bool arg0_is_int = (args(0).class_name () !=  \
-                              octave_scalar::static_class_name () && \
-                              args(0).class_name () != \
-                              octave_bool::static_class_name ()); \
-          bool arg1_is_int = (args(1).class_name () !=  \
-                              octave_scalar::static_class_name () && \
-                              args(1).class_name () != \
-                              octave_bool::static_class_name ()); \
-          \
-          if (! (arg0_is_int || arg1_is_int))   \
-            { \
-              uint64NDArray x (args(0).array_value ()); \
-              uint64NDArray y (args(1).array_value ()); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, uint64NDArray); \
-              retval = retval.array_value (); \
-            } \
-          else \
-            { \
-              int p = (arg0_is_int ? 1 : 0); \
-              int q = (arg0_is_int ? 0 : 1); \
- \
-              NDArray dx = args(p).array_value (); \
- \
-              if (args(q).type_id () == octave_uint64_matrix::static_type_id () \
-                  || args(q).type_id () == octave_uint64_scalar::static_type_id ()) \
-                { \
-                  uint64NDArray x (dx); \
-                  uint64NDArray y = args(q).uint64_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, uint64NDArray); \
-                 } \
-              else if (args(q).type_id () == octave_uint32_matrix::static_type_id () \
-                       || args(q).type_id () == octave_uint32_scalar::static_type_id ()) \
-                { \
-                  uint32NDArray x (dx); \
-                  uint32NDArray y = args(q).uint32_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, uint32NDArray); \
-                } \
-              else if (args(q).type_id () == octave_uint16_matrix::static_type_id () \
-                       || args(q).type_id () == octave_uint16_scalar::static_type_id ()) \
-                { \
-                  uint16NDArray x (dx); \
-                  uint16NDArray y = args(q).uint16_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, uint16NDArray); \
-                } \
-              else if (args(q).type_id () == octave_uint8_matrix::static_type_id () \
-                       || args(q).type_id () == octave_uint8_scalar::static_type_id ()) \
-                { \
-                  uint8NDArray x (dx); \
-                  uint8NDArray y = args(q).uint8_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, uint8NDArray); \
-                } \
-              else if (args(q).type_id () == octave_int64_matrix::static_type_id () \
-                       || args(q).type_id () == octave_int64_scalar::static_type_id ()) \
-                { \
-                  int64NDArray x (dx); \
-                  int64NDArray y = args(q).int64_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, int64NDArray); \
-                } \
-              else if (args(q).type_id () == octave_int32_matrix::static_type_id () \
-                       || args(q).type_id () == octave_int32_scalar::static_type_id ()) \
-                { \
-                  int32NDArray x (dx); \
-                  int32NDArray y = args(q).int32_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, int32NDArray); \
-                } \
-              else if (args(q).type_id () == octave_int16_matrix::static_type_id () \
-                       || args(q).type_id () == octave_int16_scalar::static_type_id ()) \
-                { \
-                  int16NDArray x (dx); \
-                  int16NDArray y = args(q).int16_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, int16NDArray); \
-                } \
-              else if (args(q).type_id () == octave_int8_matrix::static_type_id () \
-                       || args(q).type_id () == octave_int8_scalar::static_type_id ()) \
-                { \
-                  int8NDArray x (dx); \
-                  int8NDArray y = args(q).int8_array_value (); \
-                  if (! error_state) \
-                    BITOPX (OP, FNAME, int8NDArray); \
-                } \
-              else \
-                error ("%s: invalid operand type", FNAME); \
-            } \
-        } \
-      else if (args(0).class_name () == args(1).class_name ()) \
-        { \
-          if (args(0).type_id () == octave_uint64_matrix::static_type_id () \
-              || args(0).type_id () == octave_uint64_scalar::static_type_id ()) \
-            { \
-              uint64NDArray x = args(0).uint64_array_value (); \
-              uint64NDArray y = args(1).uint64_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, uint64NDArray); \
-            } \
-          else if (args(0).type_id () == octave_uint32_matrix::static_type_id () \
-                   || args(0).type_id () == octave_uint32_scalar::static_type_id ()) \
-            { \
-              uint32NDArray x = args(0).uint32_array_value (); \
-              uint32NDArray y = args(1).uint32_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, uint32NDArray); \
-            } \
-          else if (args(0).type_id () == octave_uint16_matrix::static_type_id () \
-                   || args(0).type_id () == octave_uint16_scalar::static_type_id ()) \
-            { \
-              uint16NDArray x = args(0).uint16_array_value (); \
-              uint16NDArray y = args(1).uint16_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, uint16NDArray); \
-            } \
-          else if (args(0).type_id () == octave_uint8_matrix::static_type_id () \
-                   || args(0).type_id () == octave_uint8_scalar::static_type_id ()) \
-            { \
-              uint8NDArray x = args(0).uint8_array_value (); \
-              uint8NDArray y = args(1).uint8_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, uint8NDArray); \
-            } \
-          else if (args(0).type_id () == octave_int64_matrix::static_type_id () \
-                   || args(0).type_id () == octave_int64_scalar::static_type_id ()) \
-            { \
-              int64NDArray x = args(0).int64_array_value (); \
-              int64NDArray y = args(1).int64_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, int64NDArray); \
-            } \
-          else if (args(0).type_id () == octave_int32_matrix::static_type_id () \
-                   || args(0).type_id () == octave_int32_scalar::static_type_id ()) \
-            { \
-              int32NDArray x = args(0).int32_array_value (); \
-              int32NDArray y = args(1).int32_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, int32NDArray); \
-            } \
-          else if (args(0).type_id () == octave_int16_matrix::static_type_id () \
-                   || args(0).type_id () == octave_int16_scalar::static_type_id ()) \
-            { \
-              int16NDArray x = args(0).int16_array_value (); \
-              int16NDArray y = args(1).int16_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, int16NDArray); \
-            } \
-          else if (args(0).type_id () == octave_int8_matrix::static_type_id () \
-                   || args(0).type_id () == octave_int8_scalar::static_type_id ()) \
-            { \
-              int8NDArray x = args(0).int8_array_value (); \
-              int8NDArray y = args(1).int8_array_value (); \
-              if (! error_state) \
-                BITOPX (OP, FNAME, int8NDArray); \
-            } \
-          else \
-            error ("%s: invalid operand type", FNAME); \
-        } \
-      else \
-        error ("%s: must have matching operand types", FNAME); \
-    } \
-  else \
-    print_usage (); \
- \
-  return retval
+              if (args(q).type_id () == octave_uint64_matrix::static_type_id ()
+                  || args(q).type_id () == octave_uint64_scalar::static_type_id ())
+                {
+                  uint64NDArray x (dx);
+                  uint64NDArray y = args(q).uint64_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_uint32_matrix::static_type_id ()
+                       || args(q).type_id () == octave_uint32_scalar::static_type_id ())
+                {
+                  uint32NDArray x (dx);
+                  uint32NDArray y = args(q).uint32_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_uint16_matrix::static_type_id ()
+                       || args(q).type_id () == octave_uint16_scalar::static_type_id ())
+                {
+                  uint16NDArray x (dx);
+                  uint16NDArray y = args(q).uint16_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_uint8_matrix::static_type_id ()
+                       || args(q).type_id () == octave_uint8_scalar::static_type_id ())
+                {
+                  uint8NDArray x (dx);
+                  uint8NDArray y = args(q).uint8_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_int64_matrix::static_type_id ()
+                       || args(q).type_id () == octave_int64_scalar::static_type_id ())
+                {
+                  int64NDArray x (dx);
+                  int64NDArray y = args(q).int64_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_int32_matrix::static_type_id ()
+                       || args(q).type_id () == octave_int32_scalar::static_type_id ())
+                {
+                  int32NDArray x (dx);
+                  int32NDArray y = args(q).int32_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_int16_matrix::static_type_id ()
+                       || args(q).type_id () == octave_int16_scalar::static_type_id ())
+                {
+                  int16NDArray x (dx);
+                  int16NDArray y = args(q).int16_array_value ();
+                  if (! error_state)
+                    retval  = bitopx (fname, x, y);
+                }
+              else if (args(q).type_id () == octave_int8_matrix::static_type_id ()
+                       || args(q).type_id () == octave_int8_scalar::static_type_id ())
+                {
+                  int8NDArray x (dx);
+                  int8NDArray y = args(q).int8_array_value ();
+                  if (! error_state)
+                    retval = bitopx (fname, x, y);
+                }
+              else
+                error ("%s: invalid operand type", fname.c_str());
+            }
+        }
+      else if (args(0).class_name () == args(1).class_name ())
+        {
+          if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
+              || args(0).type_id () == octave_uint64_scalar::static_type_id ())
+            {
+              uint64NDArray x = args(0).uint64_array_value ();
+              uint64NDArray y = args(1).uint64_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_uint32_matrix::static_type_id ()
+                   || args(0).type_id () == octave_uint32_scalar::static_type_id ())
+            {
+              uint32NDArray x = args(0).uint32_array_value ();
+              uint32NDArray y = args(1).uint32_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_uint16_matrix::static_type_id ()
+                   || args(0).type_id () == octave_uint16_scalar::static_type_id ())
+            {
+              uint16NDArray x = args(0).uint16_array_value ();
+              uint16NDArray y = args(1).uint16_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_uint8_matrix::static_type_id ()
+                   || args(0).type_id () == octave_uint8_scalar::static_type_id ())
+            {
+              uint8NDArray x = args(0).uint8_array_value ();
+              uint8NDArray y = args(1).uint8_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_int64_matrix::static_type_id ()
+                   || args(0).type_id () == octave_int64_scalar::static_type_id ())
+            {
+              int64NDArray x = args(0).int64_array_value ();
+              int64NDArray y = args(1).int64_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_int32_matrix::static_type_id ()
+                   || args(0).type_id () == octave_int32_scalar::static_type_id ())
+            {
+              int32NDArray x = args(0).int32_array_value ();
+              int32NDArray y = args(1).int32_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_int16_matrix::static_type_id ()
+                   || args(0).type_id () == octave_int16_scalar::static_type_id ())
+            {
+              int16NDArray x = args(0).int16_array_value ();
+              int16NDArray y = args(1).int16_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else if (args(0).type_id () == octave_int8_matrix::static_type_id ()
+                   || args(0).type_id () == octave_int8_scalar::static_type_id ())
+            {
+              int8NDArray x = args(0).int8_array_value ();
+              int8NDArray y = args(1).int8_array_value ();
+              if (! error_state)
+                retval = bitopx (fname, x, y);
+            }
+          else
+            error ("%s: invalid operand type", fname.c_str());
+        }
+      else
+        error ("%s: must have matching operand types", fname.c_str());
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
 
 DEFUN (bitand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
-  BITOP (&, "bitand");
+  return bitop ("bitand", args);
 }
 
 DEFUN (bitor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitor (@var{x}, @var{y})\n\
 Return the bitwise OR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
-  BITOP (|, "bitor");
+  return bitop ("bitor", args);
 }
 
 DEFUN (bitxor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitxor (@var{x}, @var{y})\n\
 Return the bitwise XOR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
-  BITOP (^, "bitxor");
+  return bitop ("bitxor", args);
 }
 
 static int64_t
 bitshift (double a, int n, int64_t mask)
 {
   // In the name of bug-for-bug compatibility.
   if (a < 0)
     return -bitshift (-a, n, mask);
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -5472,17 +5472,17 @@ This function and @w{@xcode{x ^ y}} are 
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x \\ y}} are equivalent.\n\
+This function and @w{@xcode{x @xbackslashchar{} y}} are equivalent.\n\
 @seealso{mrdivide, ldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
   "-*- texinfo -*-\n\
@@ -5589,17 +5589,17 @@ This function and @w{@xcode{x .^ y}} are
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
-This function and @w{@xcode{x .\\ y}} are equivalent.\n\
+This function and @w{@xcode{x .@xbackslashchar{} y}} are equivalent.\n\
 @seealso{rdivide, mldivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
@@ -5643,120 +5643,146 @@ At least one argument is required.\n\
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} tic ()\n\
+@deftypefnx  {Built-in Function} {@var{id} =} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
+@deftypefnx {Built-in Function} {} toc (@var{id})\n\
+@deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
-output argument sets the timer.  Subsequent calls to @code{toc}\n\
-return the number of seconds since the timer was set.  For example,\n\
+output argument sets the internal timer state.  Subsequent calls\n\
+to @code{toc} return the number of seconds since the timer was set.\n\
+For example,\n\
 \n\
 @example\n\
 @group\n\
 tic ();\n\
 # many computations later@dots{}\n\
 elapsed_time = toc ();\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 will set the variable @code{elapsed_time} to the number of seconds since\n\
 the most recent call to the function @code{tic}.\n\
 \n\
-If called with one output argument then this function returns a scalar\n\
-of type @code{uint64} and the wall-clock timer is not started.\n\
+If called with one output argument, @code{tic} returns a scalar\n\
+of type @code{uint64} that may be later passed to @code{toc}.\n\
 \n\
 @example\n\
 @group\n\
-t = tic; sleep (5); (double (tic ()) - double (t)) * 1e-6\n\
-      @result{} 5\n\
+id = tic; sleep (5); toc (id)\n\
+      @result{} 5.0010\n\
 @end group\n\
 @end example\n\
 \n\
-Nested timing with @code{tic} and @code{toc} is not supported.\n\
-Therefore @code{toc} will always return the elapsed time from the most\n\
-recent call to @code{tic}.\n\
+Calling @code{tic} and @code{toc} this way allows nested timing calls.\n\
 \n\
 If you are more interested in the CPU time that your process used, you\n\
 should use the @code{cputime} function instead.  The @code{tic} and\n\
 @code{toc} functions report the actual wall clock time that elapsed\n\
 between the calls.  This may include time spent processing other jobs or\n\
-doing nothing at all.  For example:\n\
-\n\
-@example\n\
-@group\n\
-tic (); sleep (5); toc ()\n\
-     @result{} 5\n\
-t = cputime (); sleep (5); cputime () - t\n\
-     @result{} 0\n\
-@end group\n\
-@end example\n\
-\n\
-@noindent\n\
-(This example also illustrates that the CPU timer may have a fairly\n\
-coarse resolution.)\n\
+doing nothing at all.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("tic: ignoring extra arguments");
 
   octave_time now;
 
   double tmp = now.double_value ();
 
   if (nargout > 0)
-    retval = static_cast<octave_uint64> (1e6 * tmp);
+    {
+      double ip = 0.0;
+      double frac = modf (tmp, &ip);
+      uint64_t microsecs = static_cast<uint64_t> (CLOCKS_PER_SEC * frac);
+      microsecs += CLOCKS_PER_SEC * static_cast<uint64_t> (ip);
+      retval = octave_uint64 (microsecs);
+    }
   else
     tic_toc_timestamp = tmp;
 
   return retval;
 }
 
 DEFUN (toc, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} toc ()\n\
+@deftypefnx {Built-in Function} {} toc (@var{id})\n\
+@deftypefnx {Built-in Function} {@var{val} = } toc (@dots{})\n\
 See tic.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin != 0)
-    warning ("tic: ignoring extra arguments");
-
-  if (tic_toc_timestamp < 0)
-    {
-      warning ("toc called before timer set");
-      if (nargout > 0)
-        retval = Matrix ();
-    }
+  double start_time = tic_toc_timestamp;
+
+  if (nargin > 1)
+    print_usage ();
   else
     {
-      octave_time now;
-
-      double tmp = now.double_value () - tic_toc_timestamp;
-
-      if (nargout > 0)
-        retval = tmp;
-      else
-        octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
+      if (nargin == 1)
+        {
+          octave_uint64 id = args(0).uint64_scalar_value ();
+
+          if (! error_state)
+            {
+              uint64_t val = id.value ();
+
+              start_time
+                = (static_cast<double> (val / CLOCKS_PER_SEC)
+                   + static_cast<double> (val % CLOCKS_PER_SEC) / CLOCKS_PER_SEC);
+
+              // FIXME -- should we also check to see whether the start
+              // time is after the beginning of this Octave session?
+            }
+          else
+            error ("toc: invalid ID");
+        }
+
+      if (! error_state)
+        {
+          if (start_time < 0)
+            error ("toc called before timer set");
+          else
+            {
+              octave_time now;
+
+              double tmp = now.double_value () - start_time;
+
+              if (nargout > 0)
+                retval = tmp;
+              else
+                octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
+            }
+        }
     }
 
   return retval;
 }
 
+/*
+%!shared id
+%! id = tic ();
+%!assert (isa (id, "uint64"));
+%!assert (isa (toc (id), "double"));
+*/
+
 DEFUN (cputime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
 Return the CPU time used by your Octave session.  The first output is\n\
 the total time spent executing your process and is equal to the sum of\n\
 second and third outputs, which are the number of CPU seconds spent\n\
 executing in user mode and the number of CPU seconds spent executing in\n\
 system mode, respectively.  If your system does not have a way to report\n\
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -289,16 +289,26 @@ set_default_doc_cache_file (void)
   std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
 
   std::string env_file = octave_env::getenv ("OCTAVE_DOC_CACHE_FILE");
 
   Vdoc_cache_file = env_file.empty () ? def_file : env_file;
 }
 
 static void
+set_default_texi_macros_file (void)
+{
+  std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
+
+  std::string env_file = octave_env::getenv ("OCTAVE_TEXI_MACROS_FILE");
+
+  Vtexi_macros_file = env_file.empty () ? def_file : env_file;
+}
+
+static void
 set_default_info_file (void)
 {
   std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
   std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
 
   Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
 }
@@ -388,16 +398,18 @@ install_defaults (void)
   set_default_bin_dir ();
 
   set_exec_path ();
 
   set_image_path ();
 
   set_default_doc_cache_file ();
 
+  set_default_texi_macros_file ();
+
   set_default_info_file ();
 
   set_default_info_prog ();
 
   set_default_editor ();
 
   set_local_site_defaults_file ();
 
diff --git a/src/defaults.in.h b/src/defaults.in.h
--- a/src/defaults.in.h
+++ b/src/defaults.in.h
@@ -51,16 +51,20 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_DATAROOTDIR
 #define OCTAVE_DATAROOTDIR %OCTAVE_DATAROOTDIR%
 #endif
 
 #ifndef OCTAVE_DOC_CACHE_FILE
 #define OCTAVE_DOC_CACHE_FILE %OCTAVE_DOC_CACHE_FILE%
 #endif
 
+#ifndef OCTAVE_TEXI_MACROS_FILE
+#define OCTAVE_TEXI_MACROS_FILE %OCTAVE_TEXI_MACROS_FILE%
+#endif
+
 #ifndef OCTAVE_EXEC_PREFIX
 #define OCTAVE_EXEC_PREFIX %OCTAVE_EXEC_PREFIX%
 #endif
 
 #ifndef OCTAVE_FCNFILEDIR
 #define OCTAVE_FCNFILEDIR %OCTAVE_FCNFILEDIR%
 #endif
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -66,16 +66,21 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "version.h"
 #include "quit.h"
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
 std::string Vdoc_cache_file;
 
+// Name of the file containing local Texinfo macros that are prepended
+// to doc strings before processing.
+// (--texi-macros-file)
+std::string Vtexi_macros_file;
+
 // Name of the info file specified on command line.
 // (--info-file file)
 std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 std::string Vinfo_program;
 
@@ -1286,16 +1291,40 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
+DEFUN (texi_macros_file, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} texi_macros_file ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} texi_macros_file (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} texi_macros_file (@var{new_val}, \"local\")\n\
+Query or set the internal variable that specifies the name of the\n\
+file containing Texinfo macros that are prepended to documentation strings\n\
+before they are passed to makeinfo.  The default value is \n\
+@file{@var{octave-home}/share/octave/@var{version}/etc/macros.texi},\n\
+in which @var{octave-home} is the root directory of the Octave installation,\n\
+and @var{version} is the Octave version number.\n\
+The default value may be overridden by the environment variable\n\
+@w{@env{OCTAVE_TEXI_MACROS_FILE}}, or the command line argument\n\
+@samp{--texi-macros-file NAME}.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{makeinfo_program}\n\
+@end deftypefn")
+{
+  return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
+}
+
 DEFUN (info_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} info_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
@@ -1344,17 +1373,17 @@ DEFUN (makeinfo_program, args, nargout,
 @deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
-@seealso{info_file, info_program, doc, help}\n\
+@seealso{texi_macros_file, info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -31,16 +31,21 @@ class string_vector;
 extern string_vector make_name_list (void);
 
 extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
 extern std::string Vdoc_cache_file;
 
+// Name of the file containing local Texinfo macros that are prepended
+// to doc strings before processing.
+// (--texi-macros-file)
+extern std::string Vtexi_macros_file;
+
 // Name of the info file specified on command line.
 // (--info-file file)
 extern std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
 extern std::string Vinfo_program;
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -760,18 +760,18 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
       }
   }
 
 %{
 // Metaclass query
 %}
 
 \?{IDENT}{S}* |
-\?{IDENT}.{IDENT}{S}* {
-    LEXER_DEBUG ("\?{IDENT}{S}* | \?{IDENT}.{IDENT}{S}*");
+\?{IDENT}\.{IDENT}{S}* {
+    LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
     int id_tok = handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
         lexer_flags.looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (METAQUERY);
@@ -1520,19 +1520,19 @@ is_keyword_token (const std::string& s)
 
         case case_kw:
         case elseif_kw:
         case global_kw:
         case until_kw:
           break;
 
         case end_kw:
-          if (! reading_classdef_file
-              && (inside_any_object_index ()
-                  || (lexer_flags.defining_func
+          if (inside_any_object_index ()
+              || (! reading_classdef_file
+                  && (lexer_flags.defining_func
                       && ! (lexer_flags.looking_at_return_list
                             || lexer_flags.parsed_function_name.top ()))))
             return 0;
 
           yylval.tok_val = new token (token::simple_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
 
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -1183,17 +1183,17 @@ public:
       {
         const char *ptr = str[j];
 
         size_t tmp_len = strlen (ptr);
 
         for (size_t i = 0; i < tmp_len; i++)
           cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
-        for (size_t i = tmp_len; i < nc; i++)
+        for (size_t i = tmp_len; i < static_cast<size_t>(nc); i++)
           cpr[m*i+j] = static_cast<mxChar> (' ');
       }
   }
 
   mxArray_number *dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -552,17 +552,17 @@ void
 octave_map::resize (const dim_vector& dv, bool fill)
 {
   octave_idx_type nf = nfields ();
   if (nf > 0)
     {
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (fill)
-            xvals[i].resize (dv, Cell::resize_fill_value ());
+            xvals[i].resize (dv, Matrix ());
           else
             xvals[i].resize (dv);
         }
     }
   else
     {
       // FIXME: Do it with a dummy array, to reuse error message.
       // Need (?) a better solution.
@@ -1155,17 +1155,17 @@ octave_map::assign (const octave_value_l
   if (! error_state && ref.dims () != dimensions)
     {
       dimensions = ref.dims ();
 
       octave_idx_type nf = nfields ();
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (&xvals[i] != &ref)
-            xvals[i].resize (dimensions, Cell::resize_fill_value ());
+            xvals[i].resize (dimensions, Matrix ());
         }
 
       optimize_dimensions ();
     }
 
   if (! error_state && &ref == &tmp)
     setfield (k, tmp);
 }
@@ -1421,17 +1421,17 @@ Octave_map::stringfield (const std::stri
     retval = c(0).string_value ();
 
   return retval;
 }
 
 string_vector
 Octave_map::keys (void) const
 {
-  assert (nfields () == key_list.size ());
+  assert (static_cast<size_t>(nfields ()) == key_list.size ());
 
   return string_vector (key_list);
 }
 
 Octave_map
 Octave_map::transpose (void) const
 {
   assert (ndims () == 2);
@@ -1484,17 +1484,17 @@ Octave_map::resize (const dim_vector& dv
         dimensions = dv;
       else
         {
           for (const_iterator p = begin (); p != end (); p++)
             {
               Cell tmp = contents(p);
 
               if (fill)
-                tmp.resize (dv, Cell::resize_fill_value ());
+                tmp.resize (dv, Matrix ());
               else
                 tmp.resize (dv);
 
               dimensions = dv;
 
               assign (key(p), tmp);
             }
         }
@@ -1664,17 +1664,17 @@ Octave_map::assign (const octave_value_l
 
   if (! error_state)
     {
       dim_vector tmp_dims = tmp.dims ();
 
       if (tmp_dims != dimensions)
         {
           for (iterator p = begin (); p != end (); p++)
-            contents(p).resize (tmp_dims, Cell::resize_fill_value ());
+            contents(p).resize (tmp_dims, Matrix ());
 
           dimensions = tmp_dims;
         }
 
       maybe_add_to_key_list (k);
 
       map[k] = tmp;
     }
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -86,18 +86,17 @@ public:
   octave_value& operator () (octave_idx_type n) { return elem (n); }
 
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
   octave_idx_type length (void) const { return data.length (); }
 
   bool empty (void) const { return length () == 0; }
 
-  void resize (octave_idx_type n, const octave_value& rfv
-               = Array<octave_value>::resize_fill_value ())
+  void resize (octave_idx_type n, const octave_value& rfv = octave_value ())
   {
     data.resize (dim_vector (1, n), rfv);
   }
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -145,17 +145,18 @@ static bool persist = false;
 #define INFO_PROG_OPTION 6
 #define LINE_EDITING_OPTION 7
 #define NO_INIT_FILE_OPTION 8
 #define NO_INIT_PATH_OPTION 9
 #define NO_LINE_EDITING_OPTION 10
 #define NO_SITE_FILE_OPTION 11
 #define NO_WINDOW_SYSTEM_OPTION 12
 #define PERSIST_OPTION 13
-#define TRADITIONAL_OPTION 14
+#define TEXI_MACROS_FILE_OPTION 14
+#define TRADITIONAL_OPTION 15
 struct option long_opts[] =
   {
     { "braindead",        no_argument,       0, TRADITIONAL_OPTION },
     { "debug",            no_argument,       0, 'd' },
     { "doc-cache-file",   required_argument, 0, DOC_CACHE_FILE_OPTION },
     { "echo-commands",    no_argument,       0, 'x' },
     { "eval",             required_argument, 0, EVAL_OPTION },
     { "exec-path",        required_argument, 0, EXEC_PATH_OPTION },
@@ -171,16 +172,17 @@ struct option long_opts[] =
     { "no-line-editing",  no_argument,       0, NO_LINE_EDITING_OPTION },
     { "no-site-file",     no_argument,       0, NO_SITE_FILE_OPTION },
     { "no-window-system", no_argument,       0, NO_WINDOW_SYSTEM_OPTION },
     { "norc",             no_argument,       0, 'f' },
     { "path",             required_argument, 0, 'p' },
     { "persist",          no_argument,       0, PERSIST_OPTION },
     { "quiet",            no_argument,       0, 'q' },
     { "silent",           no_argument,       0, 'q' },
+    { "texi-macros-file", required_argument, 0, TEXI_MACROS_FILE_OPTION },
     { "traditional",      no_argument,       0, TRADITIONAL_OPTION },
     { "verbose",          no_argument,       0, 'V' },
     { "version",          no_argument,       0, 'v' },
     { 0,                  0,                 0, 0 }
   };
 
 // Store the command-line options for later use.
 
@@ -529,16 +531,17 @@ Options:\n\
   --no-init-path          Don't initialize function search path.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
   --no-window-system      Disable window system, including graphics.\n\
   --norc, -f              Don't read any initialization files.\n\
   --path PATH, -p PATH    Add PATH to head of function search path.\n\
   --persist               Go interactive after --eval or reading from FILE.\n\
   --silent, -q            Don't print message at startup.\n\
+  --texi-macros-file FILE Use Texinfo macros in FILE for makeinfo command.\n\
   --traditional           Set variables for closer MATLAB compatibility.\n\
   --verbose, -V           Enable verbose output in some cases.\n\
   --version, -v           Print version number and exit.\n\
 \n\
   FILE                    Execute commands from FILE.  Exit when done\n\
                           unless --persist is also specified.\n\
 \n"
 OCTAVE_WWW_STATEMENT "\n\
@@ -806,16 +809,21 @@ octave_main (int argc, char **argv, int 
         case NO_WINDOW_SYSTEM_OPTION:
           display_info::no_window_system ();
           break;
 
         case PERSIST_OPTION:
           persist = true;
           break;
 
+        case TEXI_MACROS_FILE_OPTION:
+          if (optarg)
+            bind_internal_variable ("texi_macros_file", optarg);
+          break;
+
         case TRADITIONAL_OPTION:
           traditional = true;
           break;
 
         default:
           // getopt_long should print a message about unrecognized
           // options and return '?', which is handled above.  So if we
           // end up here, it is because there was an option but we
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -220,17 +220,17 @@ octave_complex::float_complex_array_valu
   return FloatComplexNDArray (dim_vector (1, 1), static_cast<FloatComplex> (scalar));
 }
 
 octave_value
 octave_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      ComplexNDArray retval (dv, ComplexNDArray::resize_fill_value ());
+      ComplexNDArray retval (dv, Complex (0));
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -74,17 +74,17 @@ octave_float_scalar::do_index_op (const 
   return tmp.do_index_op (idx, resize_ok);
 }
 
 octave_value
 octave_float_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      FloatNDArray retval (dv, NDArray::resize_fill_value());
+      FloatNDArray retval (dv, 0);
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -205,17 +205,17 @@ octave_float_complex::float_complex_arra
   return FloatComplexNDArray (dim_vector (1, 1), scalar);
 }
 
 octave_value
 octave_float_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      FloatComplexNDArray retval (dv, FloatComplexNDArray::resize_fill_value ());
+      FloatComplexNDArray retval (dv, FloatComplex (0));
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -330,17 +330,17 @@ octave_range::bool_array_value (bool war
   return boolNDArray (m);
 }
 
 octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
 {
   NDArray retval = array_value ();
   if (fill)
-    retval.resize (dv, NDArray::resize_fill_value ());
+    retval.resize (dv, 0);
   else
     retval.resize (dv);
   return retval;
 }
 
 octave_value
 octave_range::convert_to_str_internal (bool pad, bool force, char type) const
 {
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -89,17 +89,17 @@ octave_scalar::do_index_op (const octave
   return tmp.do_index_op (idx, resize_ok);
 }
 
 octave_value
 octave_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
-      NDArray retval (dv, NDArray::resize_fill_value());
+      NDArray retval (dv, 0);
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
   else
     {
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -138,17 +138,17 @@ octave_char_matrix_str::do_index_op_inte
   return retval;
 }
 
 octave_value
 octave_char_matrix_str::resize (const dim_vector& dv, bool fill) const
 {
   charNDArray retval (matrix);
   if (fill)
-    retval.resize (dv, charNDArray::resize_fill_value ());
+    retval.resize (dv, 0);
   else
     retval.resize (dv);
   return octave_value (retval, is_sq_string () ? '\'' : '"');
 }
 
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2128,16 +2128,18 @@ A(1)\n\
 %! vals = mat2cell (rand (100,1), ones (100,1), 1)';
 %! s = struct ([keys; vals]{:});
 %! t = cell2struct (vals, keys, 2);
 %! assert (s, t);
 %! assert (struct2cell (s), vals');
 %! assert (fieldnames (s), keys');
 
 %!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
+
+%!assert (cell2struct ({}, {"f"}, 3), struct ("f", {}));
 */
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -73,17 +73,17 @@ of real of complex values @var{sv}, over
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
 compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified\n\
 their values are derived from the maximum index in the vectors @var{i} and\n\
 @var{j} as given by @code{@var{m} = max (@var{i})},\n\
 @code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
-be added. See @code{accumarray} for an example of how to produce different\n\
+be added.  See @code{accumarray} for an example of how to produce different\n\
 behavior, such as taking the minimum instead.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
 @group\n\
 s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
