# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1471376902 14400
#      Tue Aug 16 15:48:22 2016 -0400
# Node ID 6ca3acf5fad86d2d8335fcc171cd7879d026ca77
# Parent  b67a29a960561087d5e486947e2bd937711becd3
move some new numeric classes to namespace octave::math

* aepbalance.cc, aepbalance.h, chol.cc, chol.h, gepbalance.cc,
gepbalance.h, hess.cc, hess.h, lu.cc, lu.h, qr.cc, qr.h, qrp.cc,
qrp.h, schur.cc, schur.h, sparse-chol.cc, sparse-chol.h,
sparse-dmsolve.cc,sparse-lu.cc, sparse-lu.h, sparse-qr.cc,
sparse-qr.h, svd.cc, svd.h: Move classes to namespace octave::math.

* __luinc__.cc, __qp__.cc, balance.cc, hess.cc, lu.cc, qz.cc,
schur.cc, sqrtm.cc, svd.cc, chol.cc, dmperm.cc, qr.cc, lex.h,
CMatrix.cc, CSparse.cc, dMatrix.cc, dSparse.cc, fCMatrix.cc,
fMatrix.cc, eigs-base.cc, oct-norm.cc: Update for new namespaces.

diff --git a/libinterp/corefcn/__luinc__.cc b/libinterp/corefcn/__luinc__.cc
--- a/libinterp/corefcn/__luinc__.cc
+++ b/libinterp/corefcn/__luinc__.cc
@@ -140,35 +140,35 @@ See documentation for @code{luinc}.
         Qinit(i) = i;
 
       switch (nargout)
         {
         case 0:
         case 1:
         case 2:
           {
-            sparse_lu<SparseMatrix> fact (sm, Qinit, thresh, false, true, droptol,
-                           milu, udiag);
+            octave::math::sparse_lu<SparseMatrix> fact
+              (sm, Qinit, thresh, false, true, droptol, milu, udiag);
 
             SparseMatrix P = fact.Pr ();
             SparseMatrix L = P.transpose () * fact.L ();
 
             retval(1)
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
             retval(0)
               = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
                                              sm_nr, fact.row_perm ()));
           }
           break;
 
         case 3:
           {
-            sparse_lu<SparseMatrix> fact (sm, Qinit, thresh, false, true, droptol,
-                           milu, udiag);
+            octave::math::sparse_lu<SparseMatrix> fact
+              (sm, Qinit, thresh, false, true, droptol, milu, udiag);
 
             if (vecout)
               retval(2) = fact.Pr_vec ();
             else
               retval(2) = fact.Pr_mat ();
 
             retval(1)
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
@@ -176,18 +176,18 @@ See documentation for @code{luinc}.
             retval(0)
               = octave_value (fact.L (), MatrixType (MatrixType::Lower));
           }
           break;
 
         case 4:
         default:
           {
-            sparse_lu<SparseMatrix> fact (sm, Qinit, thresh, false, false, droptol,
-                           milu, udiag);
+            octave::math::sparse_lu<SparseMatrix> fact
+              (sm, Qinit, thresh, false, false, droptol, milu, udiag);
 
             if (vecout)
               {
                 retval(3) = fact.Pc_vec ();
                 retval(2) = fact.Pr_vec ();
               }
             else
               {
@@ -215,35 +215,35 @@ See documentation for @code{luinc}.
         Qinit(i) = i;
 
       switch (nargout)
         {
         case 0:
         case 1:
         case 2:
           {
-            sparse_lu<SparseComplexMatrix> fact (sm, Qinit, thresh, false, true,
-                                  droptol, milu, udiag);
+            octave::math::sparse_lu<SparseComplexMatrix> fact
+              (sm, Qinit, thresh, false, true, droptol, milu, udiag);
 
             SparseMatrix P = fact.Pr ();
             SparseComplexMatrix L = P.transpose () * fact.L ();
 
             retval(1)
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
 
             retval(0)
               = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
                                              sm_nr, fact.row_perm ()));
           }
           break;
 
         case 3:
           {
-            sparse_lu<SparseComplexMatrix> fact (sm, Qinit, thresh, false, true,
-                                  droptol, milu, udiag);
+            octave::math::sparse_lu<SparseComplexMatrix> fact
+              (sm, Qinit, thresh, false, true, droptol, milu, udiag);
 
             if (vecout)
               retval(2) = fact.Pr_vec ();
             else
               retval(2) = fact.Pr_mat ();
 
             retval(1)
               = octave_value (fact.U (), MatrixType (MatrixType::Upper));
@@ -251,18 +251,18 @@ See documentation for @code{luinc}.
             retval(0)
               = octave_value (fact.L (), MatrixType (MatrixType::Lower));
           }
           break;
 
         case 4:
         default:
           {
-            sparse_lu<SparseComplexMatrix> fact (sm, Qinit, thresh, false, false,
-                                  droptol, milu, udiag);
+            octave::math::sparse_lu<SparseComplexMatrix> fact
+              (sm, Qinit, thresh, false, false, droptol, milu, udiag);
 
             if (vecout)
               {
                 retval(3) = fact.Pc_vec ();
                 retval(2) = fact.Pr_vec ();
               }
             else
               {
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -42,17 +42,17 @@ static Matrix
 null (const Matrix& A, octave_idx_type& rank)
 {
   Matrix retval;
 
   rank = 0;
 
   if (! A.is_empty ())
     {
-      svd<Matrix> A_svd (A);
+      octave::math::svd<Matrix> A_svd (A);
 
       DiagMatrix S = A_svd.singular_values ();
 
       ColumnVector s = S.extract_diag ();
 
       Matrix V = A_svd.right_singular_matrix ();
 
       octave_idx_type A_nr = A.rows ();
@@ -186,21 +186,21 @@ qp (const Matrix& H, const ColumnVector&
           // There are no active constraints.
 
           if (minReal > 0.0)
             {
               // Inverting the Hessian.  Using the Cholesky
               // factorization since the Hessian is positive
               // definite.
 
-              chol<Matrix> cholH (H);
+              octave::math::chol<Matrix> cholH (H);
 
               R = cholH.chol_matrix ();
 
-              Matrix Hinv = chol2inv (R);
+              Matrix Hinv = octave::math::chol2inv (R);
 
               // Computing the unconstrained step.
               // p = -Hinv * g;
 
               p = -Hinv * g;
 
               info = 0;
             }
@@ -245,32 +245,32 @@ qp (const Matrix& H, const ColumnVector&
 
           octave_idx_type pR = 0;
 
           if (dimZ > 0)
             {
               // Computing the Cholesky factorization (pR = 0 means
               // that the reduced Hessian was positive definite).
 
-              chol<Matrix> cholrH (rH, pR);
+              octave::math::chol<Matrix> cholrH (rH, pR);
               Matrix tR = cholrH.chol_matrix ();
               if (pR == 0)
                 R = tR;
             }
 
           if (pR == 0)
             {
               info = 0;
 
               // Computing the step pz.
               if (dimZ > 0)
                 {
                   // Using the Cholesky factorization to invert rH
 
-                  Matrix rHinv = chol2inv (R);
+                  Matrix rHinv = octave::math::chol2inv (R);
 
                   ColumnVector pz = -rHinv * Zt * g;
 
                   // Global step.
                   p = Z * pz;
                 }
               else
                 {
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -145,62 +145,62 @@ Generalized eigenvalue problem balancing
           noscal = a1s == "noscal" || a1s == "P";
         }
 
       // balance the AEP
       if (isfloat)
         {
           if (complex_case)
             {
-              aepbalance<FloatComplexMatrix> result (fcaa, noperm, noscal);
+              octave::math::aepbalance<FloatComplexMatrix> result (fcaa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
                 retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 retval = ovl (result.balancing_matrix (),
                               result.balanced_matrix ());
               else
                 retval = ovl (result.scaling_vector (),
                               result.permuting_vector (),
                               result.balanced_matrix ());
             }
           else
             {
-              aepbalance<FloatMatrix> result (faa, noperm, noscal);
+              octave::math::aepbalance<FloatMatrix> result (faa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
                 retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 retval = ovl (result.balancing_matrix (),
                               result.balanced_matrix ());
               else
                 retval = ovl (result.scaling_vector (),
                               result.permuting_vector (),
                               result.balanced_matrix ());
             }
         }
       else
         {
           if (complex_case)
             {
-              aepbalance<ComplexMatrix> result (caa, noperm, noscal);
+              octave::math::aepbalance<ComplexMatrix> result (caa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
                 retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 retval = ovl (result.balancing_matrix (),
                               result.balanced_matrix ());
               else
                 retval = ovl (result.scaling_vector (),
                               result.permuting_vector (),
                               result.balanced_matrix ());
             }
           else
             {
-              aepbalance<Matrix> result (aa, noperm, noscal);
+              octave::math::aepbalance<Matrix> result (aa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
                 retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 retval = ovl (result.balancing_matrix (),
                               result.balanced_matrix ());
               else
                 retval = ovl (result.scaling_vector (),
@@ -244,17 +244,17 @@ Generalized eigenvalue problem balancing
             bb = args(1).matrix_value ();
         }
 
       // balance the GEP
       if (isfloat)
         {
           if (complex_case)
             {
-              gepbalance<FloatComplexMatrix> result (fcaa, fcbb, bal_job);
+              octave::math::gepbalance<FloatComplexMatrix> result (fcaa, fcbb, bal_job);
 
               switch (nargout)
                 {
                 case 4:
                   retval(3) = result.balanced_matrix2 ();
                   // fall through
                 case 3:
                   retval(2) = result.balanced_matrix ();
@@ -269,17 +269,17 @@ Generalized eigenvalue problem balancing
                   break;
                 default:
                   error ("balance: invalid number of output arguments");
                   break;
                 }
             }
           else
             {
-              gepbalance<FloatMatrix> result (faa, fbb, bal_job);
+              octave::math::gepbalance<FloatMatrix> result (faa, fbb, bal_job);
 
               switch (nargout)
                 {
                 case 4:
                   retval(3) = result.balanced_matrix2 ();
                   // fall through
                 case 3:
                   retval(2) = result.balanced_matrix ();
@@ -297,17 +297,17 @@ Generalized eigenvalue problem balancing
                   break;
                 }
             }
         }
       else
         {
           if (complex_case)
             {
-              gepbalance<ComplexMatrix> result (caa, cbb, bal_job);
+              octave::math::gepbalance<ComplexMatrix> result (caa, cbb, bal_job);
 
               switch (nargout)
                 {
                 case 4:
                   retval(3) = result.balanced_matrix2 ();
                   // fall through
                 case 3:
                   retval(2) = result.balanced_matrix ();
@@ -322,17 +322,17 @@ Generalized eigenvalue problem balancing
                   break;
                 default:
                   error ("balance: invalid number of output arguments");
                   break;
                 }
             }
           else
             {
-              gepbalance<Matrix> result (aa, bb, bal_job);
+              octave::math::gepbalance<Matrix> result (aa, bb, bal_job);
 
               switch (nargout)
                 {
                 case 4:
                   retval(3) = result.balanced_matrix2 ();
                   // fall through
                 case 3:
                   retval(2) = result.balanced_matrix ();
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -82,56 +82,56 @@ IEEE Transactions on Automatic Control, 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
-          hess<FloatMatrix> result (tmp);
+          octave::math::hess<FloatMatrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
-          hess<FloatComplexMatrix> result (ctmp);
+          octave::math::hess<FloatComplexMatrix> result (ctmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
-          hess<Matrix> result (tmp);
+          octave::math::hess<Matrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
-          hess<ComplexMatrix> result (ctmp);
+          octave::math::hess<ComplexMatrix> result (ctmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
       else
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -32,28 +32,28 @@ along with Octave; see the file COPYING.
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <typename MT>
 static octave_value
-get_lu_l (const lu<MT>& fact)
+get_lu_l (const octave::math::lu<MT>& fact)
 {
   MT L = fact.L ();
   if (L.is_square ())
     return octave_value (L, MatrixType (MatrixType::Lower));
   else
     return L;
 }
 
 template <typename MT>
 static octave_value
-get_lu_u (const lu<MT>& fact)
+get_lu_u (const octave::math::lu<MT>& fact)
 {
   MT U = fact.U ();
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
@@ -199,17 +199,17 @@ permutation information.
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
           if (nargout < 4)
             {
               ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit(i) = i;
-              sparse_lu<SparseMatrix> fact (m, Qinit, thres, false, true);
+              octave::math::sparse_lu<SparseMatrix> fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
                 retval(0) = fact.Y ();
               else
                 {
                   retval.resize (nargout == 3 ? 3 : 2);
                   retval(1)
                     = octave_value (
@@ -233,17 +233,17 @@ permutation information.
                       else
                         retval(2) = P;
                     }
                 }
             }
           else
             {
               retval.resize (scale ? 5 : 4);
-              sparse_lu<SparseMatrix> fact (m, thres, scale);
+              octave::math::sparse_lu<SparseMatrix> fact (m, thres, scale);
 
               retval(0) = octave_value (fact.L (),
                                         MatrixType (MatrixType::Lower));
               retval(1) = octave_value (fact.U (),
                                         MatrixType (MatrixType::Upper));
 
               if (vecout)
                 {
@@ -264,17 +264,17 @@ permutation information.
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           if (nargout < 4)
             {
               ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit(i) = i;
-              sparse_lu<SparseComplexMatrix> fact (m, Qinit, thres, false, true);
+              octave::math::sparse_lu<SparseComplexMatrix> fact (m, Qinit, thres, false, true);
 
               if (nargout < 2)
                 retval(0) = fact.Y ();
               else
                 {
                   retval.resize (nargout == 3 ? 3 : 2);
                   retval(1)
                     = octave_value (
@@ -297,17 +297,17 @@ permutation information.
                       else
                         retval(2) = P;
                     }
                 }
             }
           else
             {
               retval.resize (scale ? 5 : 4);
-              sparse_lu<SparseComplexMatrix> fact (m, thres, scale);
+              octave::math::sparse_lu<SparseComplexMatrix> fact (m, thres, scale);
 
               retval(0) = octave_value (fact.L (),
                                         MatrixType (MatrixType::Lower));
               retval(1) = octave_value (fact.U (),
                                         MatrixType (MatrixType::Upper));
 
               if (vecout)
                 {
@@ -336,17 +336,17 @@ permutation information.
         return octave_value_list (3, Matrix ());
 
       if (arg.is_real_type ())
         {
           if (arg.is_single_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
-              lu<FloatMatrix> fact (m);
+              octave::math::lu<FloatMatrix> fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   retval = ovl (fact.Y ());
                   break;
 
@@ -370,17 +370,17 @@ permutation information.
                   }
                   break;
                 }
             }
           else
             {
               Matrix m = arg.matrix_value ();
 
-              lu<Matrix> fact (m);
+              octave::math::lu<Matrix> fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   retval = ovl (fact.Y ());
                   break;
 
@@ -407,17 +407,17 @@ permutation information.
             }
         }
       else if (arg.is_complex_type ())
         {
           if (arg.is_single_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
-              lu<FloatComplexMatrix> fact (m);
+              octave::math::lu<FloatComplexMatrix> fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   retval = ovl (fact.Y ());
                   break;
 
@@ -441,17 +441,17 @@ permutation information.
                   }
                   break;
                 }
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
-              lu<ComplexMatrix> fact (m);
+              octave::math::lu<ComplexMatrix> fact (m);
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   retval = ovl (fact.Y ());
                   break;
 
@@ -642,17 +642,17 @@ factorization from scratch.
       if (argl.is_single_type () || argu.is_single_type ()
           || argx.is_single_type () || argy.is_single_type ())
         {
           FloatMatrix L = argl.float_matrix_value ();
           FloatMatrix U = argu.float_matrix_value ();
           FloatMatrix x = argx.float_matrix_value ();
           FloatMatrix y = argy.float_matrix_value ();
 
-          lu<FloatMatrix> fact (L, U, P);
+          octave::math::lu<FloatMatrix> fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
             return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
           else
@@ -660,17 +660,17 @@ factorization from scratch.
         }
       else
         {
           Matrix L = argl.matrix_value ();
           Matrix U = argu.matrix_value ();
           Matrix x = argx.matrix_value ();
           Matrix y = argy.matrix_value ();
 
-          lu<Matrix> fact (L, U, P);
+          octave::math::lu<Matrix> fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
             return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
           else
@@ -683,17 +683,17 @@ factorization from scratch.
       if (argl.is_single_type () || argu.is_single_type ()
           || argx.is_single_type () || argy.is_single_type ())
         {
           FloatComplexMatrix L = argl.float_complex_matrix_value ();
           FloatComplexMatrix U = argu.float_complex_matrix_value ();
           FloatComplexMatrix x = argx.float_complex_matrix_value ();
           FloatComplexMatrix y = argy.float_complex_matrix_value ();
 
-          lu<FloatComplexMatrix> fact (L, U, P);
+          octave::math::lu<FloatComplexMatrix> fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
             return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
           else
@@ -701,17 +701,17 @@ factorization from scratch.
         }
       else
         {
           ComplexMatrix L = argl.complex_matrix_value ();
           ComplexMatrix U = argu.complex_matrix_value ();
           ComplexMatrix x = argx.complex_matrix_value ();
           ComplexMatrix y = argy.complex_matrix_value ();
 
-          lu<ComplexMatrix> fact (L, U, P);
+          octave::math::lu<ComplexMatrix> fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
             return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
           else
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -608,17 +608,17 @@ compatibility with @sc{matlab}.
   static char qz_job;
   qz_job = (nargout < 2 ? 'E' : 'S');
 
   if (complex_case)
     {
       // Complex case.
 
       // The QR decomposition of cbb.
-      qr<ComplexMatrix> cbqr (cbb);
+      octave::math::qr<ComplexMatrix> cbqr (cbb);
       // The R matrix of QR decomposition for cbb.
       cbb = cbqr.R ();
       // (Q*)caa for following work.
       caa = (cbqr.Q ().hermitian ()) * caa;
       CQ = CQ * cbqr.Q ();
 
       F77_XFCN (zgghrd, ZGGHRD,
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
@@ -674,17 +674,17 @@ compatibility with @sc{matlab}.
     }
   else
     {
 #if defined (DEBUG)
       std::cout << "qz: peforming qr decomposition of bb" << std::endl;
 #endif
 
       // Compute the QR factorization of bb.
-      qr<Matrix> bqr (bb);
+      octave::math::qr<Matrix> bqr (bb);
 
 #if defined (DEBUG)
       std::cout << "qz: qr (bb) done; now peforming qz decomposition"
                 << std::endl;
 #endif
 
       bb = bqr.R ();
 
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -174,73 +174,73 @@ in control (see @code{are} and @code{dar
   if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (nargout <= 1)
             {
-              schur<FloatMatrix> result (tmp, ord, false);
+              octave::math::schur<FloatMatrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
           else
             {
-              schur<FloatMatrix> result (tmp, ord, true);
+              octave::math::schur<FloatMatrix> result (tmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             result.schur_matrix ());
             }
         }
       else
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           if (nargout <= 1)
             {
-              schur<FloatComplexMatrix> result (ctmp, ord, false);
+              octave::math::schur<FloatComplexMatrix> result (ctmp, ord, false);
               retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
-              schur<FloatComplexMatrix> result (ctmp, ord, true);
+              octave::math::schur<FloatComplexMatrix> result (ctmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
   else
     {
       if (! force_complex && arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
           if (nargout <= 1)
             {
-              schur<Matrix> result (tmp, ord, false);
+              octave::math::schur<Matrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
           else
             {
-              schur<Matrix> result (tmp, ord, true);
+              octave::math::schur<Matrix> result (tmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             result.schur_matrix ());
             }
         }
       else
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           if (nargout <= 1)
             {
-              schur<ComplexMatrix> result (ctmp, ord, false);
+              octave::math::schur<ComplexMatrix> result (ctmp, ord, false);
               retval = ovl (mark_upper_triangular (result.schur_matrix ()));
             }
           else
             {
-              schur<ComplexMatrix> result (ctmp, ord, true);
+              octave::math::schur<ComplexMatrix> result (ctmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
 
   return retval;
 }
@@ -296,27 +296,28 @@ Note also that @var{U} and @var{T} are n
   if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       FloatMatrix u = args(0).float_matrix_value ();
       FloatMatrix t = args(1).float_matrix_value ();
 
-      schur<FloatComplexMatrix> cs
-        = rsf2csf<FloatComplexMatrix, FloatMatrix> (t, u);
+      octave::math::schur<FloatComplexMatrix> cs
+        = octave::math::rsf2csf<FloatComplexMatrix, FloatMatrix> (t, u);
 
       return ovl (cs.unitary_matrix (), cs.schur_matrix ());
     }
   else
     {
       Matrix u = args(0).matrix_value ();
       Matrix t = args(1).matrix_value ();
 
-      schur<ComplexMatrix> cs = rsf2csf<ComplexMatrix, Matrix> (t, u);
+      octave::math::schur<ComplexMatrix> cs
+        = octave::math::rsf2csf<ComplexMatrix, Matrix> (t, u);
 
       return ovl (cs.unitary_matrix (), cs.schur_matrix ());
     }
 }
 
 /*
 %!test
 %! A = [1, 1, 1, 2; 1, 2, 1, 1; 1, 1, 3, 1; -2, 1, 1, 1];
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -229,19 +229,20 @@ Mathematics, Manchester, England, Januar
       retval(2) = -1.0;
     }
 
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
     retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix,
-                         schur<FloatComplexMatrix> > (arg);
+                         octave::math::schur<FloatComplexMatrix> > (arg);
   else if (arg.is_numeric_type ())
-    retval(0) = do_sqrtm<Matrix, ComplexMatrix, schur<ComplexMatrix> > (arg);
+    retval(0) = do_sqrtm<Matrix, ComplexMatrix,
+                         octave::math::schur<ComplexMatrix> > (arg);
 
   if (nargout > 1)
     {
       // This corresponds to generic code
       //
       //   norm (s*s - x, "fro") / norm (x, "fro");
 
       octave_value s = retval(0);
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -32,29 +32,33 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static std::string Vsvd_driver = "gesvd";
 
 template <typename T>
-static typename svd<T>::Type
+static typename octave::math::svd<T>::Type
 svd_type (int nargin, int nargout)
 {
   return ((nargout == 0 || nargout == 1)
-          ? svd<T>::Type::sigma_only
-          : (nargin == 2) ? svd<T>::Type::economy : svd<T>::Type::std);
+          ? octave::math::svd<T>::Type::sigma_only
+          : ((nargin == 2)
+             ? octave::math::svd<T>::Type::economy
+             : octave::math::svd<T>::Type::std));
 }
 
 template <typename T>
-static typename svd<T>::Driver
+static typename octave::math::svd<T>::Driver
 svd_driver (void)
 {
-  return Vsvd_driver == "gesvd" ? svd<T>::Driver::GESVD : svd<T>::Driver::GESDD;
+  return (Vsvd_driver == "gesvd"
+          ? octave::math::svd<T>::Driver::GESVD
+          : octave::math::svd<T>::Driver::GESDD);
 }
 
 DEFUN (svd, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{s} =} svd (@var{A})
 @deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})
 @deftypefnx {} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})
 @cindex singular value decomposition
@@ -155,19 +159,19 @@ decomposition, eliminating the unnecessa
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (tmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-          svd<FloatMatrix> result (tmp,
-                                   svd_type<FloatMatrix> (nargin, nargout),
-                                   svd_driver<FloatMatrix> ());
+          octave::math::svd<FloatMatrix> result
+            (tmp, svd_type<FloatMatrix> (nargin, nargout),
+             svd_driver<FloatMatrix> ());
 
           FloatDiagMatrix sigma = result.singular_values ();
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
@@ -175,19 +179,19 @@ decomposition, eliminating the unnecessa
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           if (ctmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-          svd<FloatComplexMatrix> result (ctmp,
-                                          svd_type<FloatComplexMatrix> (nargin, nargout),
-                                          svd_driver<FloatComplexMatrix> ());
+          octave::math::svd<FloatComplexMatrix> result
+            (ctmp, svd_type<FloatComplexMatrix> (nargin, nargout),
+             svd_driver<FloatComplexMatrix> ());
 
           FloatDiagMatrix sigma = result.singular_values ();
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
@@ -198,19 +202,19 @@ decomposition, eliminating the unnecessa
     {
       if (arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
           if (tmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-          svd<Matrix> result (tmp,
-                              svd_type<Matrix> (nargin, nargout),
-                              svd_driver<Matrix> ());
+          octave::math::svd<Matrix> result
+            (tmp, svd_type<Matrix> (nargin, nargout),
+             svd_driver<Matrix> ());
 
           DiagMatrix sigma = result.singular_values ();
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
@@ -218,19 +222,19 @@ decomposition, eliminating the unnecessa
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           if (ctmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
-          svd<ComplexMatrix> result (ctmp,
-                                     svd_type<ComplexMatrix> (nargin, nargout),
-                                     svd_driver<ComplexMatrix> ());
+          octave::math::svd<ComplexMatrix> result
+            (ctmp, svd_type<ComplexMatrix> (nargin, nargout),
+             svd_driver<ComplexMatrix> ());
 
           DiagMatrix sigma = result.singular_values ();
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -194,17 +194,17 @@ sparse matrices.
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
       if (arg.is_real_type ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
-          sparse_chol<SparseMatrix> fact (m, info, natural, force);
+          octave::math::sparse_chol<SparseMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
@@ -219,17 +219,17 @@ sparse matrices.
             }
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-          sparse_chol<SparseComplexMatrix> fact (m, info, natural, force);
+          octave::math::sparse_chol<SparseComplexMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
@@ -253,30 +253,30 @@ sparse matrices.
       if (vecout)
         error ("chol: A must be sparse for the \"vector\" option");
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           octave_idx_type info;
 
-          chol<FloatMatrix> fact (m, info, LLt != true);
+          octave::math::chol<FloatMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           octave_idx_type info;
 
-          chol<FloatComplexMatrix> fact (m, info, LLt != true);
+          octave::math::chol<FloatComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
@@ -286,30 +286,30 @@ sparse matrices.
       if (vecout)
         error ("chol: A must be sparse for the \"vector\" option");
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           octave_idx_type info;
 
-          chol<Matrix> fact (m, info, LLt != true);
+          octave::math::chol<Matrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
           octave_idx_type info;
 
-          chol<ComplexMatrix> fact (m, info, LLt != true);
+          octave::math::chol<ComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
@@ -388,83 +388,83 @@ the Cholesky@tie{}factorization.
       if (arg.is_sparse_type ())
         {
           octave_idx_type info;
 
           if (arg.is_real_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
-              sparse_chol<SparseMatrix> chol (m, info);
+              octave::math::sparse_chol<SparseMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-              sparse_chol<SparseComplexMatrix> chol (m, info);
+              octave::math::sparse_chol<SparseComplexMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("cholinv", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               octave_idx_type info;
-              chol<FloatMatrix> chol (m, info);
+              octave::math::chol<FloatMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               octave_idx_type info;
-              chol<FloatComplexMatrix> chol (m, info);
+              octave::math::chol<FloatComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("chol", arg);
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
               octave_idx_type info;
-              chol<Matrix> chol (m, info);
+              octave::math::chol<Matrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               octave_idx_type info;
-              chol<ComplexMatrix> chol (m, info);
+              octave::math::chol<ComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("chol", arg);
         }
@@ -515,58 +515,58 @@ diagonal elements.  @code{chol2inv (@var
   else
     {
       if (arg.is_sparse_type ())
         {
           if (arg.is_real_type ())
             {
               SparseMatrix r = arg.sparse_matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix r = arg.float_matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix r = arg.float_complex_matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
 
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix r = arg.matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix r = arg.complex_matrix_value ();
 
-              retval = chol2inv (r);
+              retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
         }
     }
 
   return retval;
 }
@@ -662,34 +662,34 @@ If @var{info} is not present, an error m
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
-          chol<FloatMatrix> fact;
+          octave::math::chol<FloatMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
-          chol<FloatComplexMatrix> fact;
+          octave::math::chol<FloatComplexMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
@@ -698,33 +698,33 @@ If @var{info} is not present, an error m
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
-          chol<Matrix> fact;
+          octave::math::chol<Matrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u = argu.complex_column_vector_value ();
 
-          chol<ComplexMatrix> fact;
+          octave::math::chol<ComplexMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
@@ -853,58 +853,58 @@ If @var{info} is not present, an error m
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
-          chol<FloatMatrix> fact;
+          octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
-          chol<FloatComplexMatrix> fact;
+          octave::math::chol<FloatComplexMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
-          chol<Matrix> fact;
+          octave::math::chol<Matrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u =
             argu.complex_column_vector_value ();
 
-          chol<ComplexMatrix> fact;
+          octave::math::chol<ComplexMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   if (nargout > 1)
@@ -1088,53 +1088,53 @@ triangular, return the Cholesky@tie{}fac
 
   if (argr.is_single_type ())
     {
       if (argr.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
-          chol<FloatMatrix> fact;
+          octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-          chol<FloatComplexMatrix> fact;
+          octave::math::chol<FloatComplexMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
-          chol<Matrix> fact;
+          octave::math::chol<Matrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          chol<ComplexMatrix> fact;
+          octave::math::chol<ComplexMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   return retval;
@@ -1218,53 +1218,53 @@ triangular, return the Cholesky@tie{}fac
   if (argr.is_single_type () && argi.is_single_type ()
       && argj.is_single_type ())
     {
       if (argr.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
-          chol<FloatMatrix> fact;
+          octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-          chol<FloatComplexMatrix> fact;
+          octave::math::chol<FloatComplexMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
-          chol<Matrix> fact;
+          octave::math::chol<Matrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          chol<ComplexMatrix> fact;
+          octave::math::chol<ComplexMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   return retval;
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -29,17 +29,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 #include "oct-sparse.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
-#include "sparse-qr.h"
 
 #if defined (OCTAVE_ENABLE_64)
 #  define CXSPARSE_NAME(name) cs_dl ## name
 #else
 #  define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 #if defined (HAVE_CXSPARSE)
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -33,32 +33,32 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <typename MT>
 static octave_value
-get_qr_r (const qr<MT>& fact)
+get_qr_r (const octave::math::qr<MT>& fact)
 {
   MT R = fact.R ();
   if (R.is_square () && fact.regular ())
     return octave_value (R, MatrixType (MatrixType::Upper));
   else
     return R;
 }
 
 template <typename T>
-static typename qr<T>::type
+static typename octave::math::qr<T>::type
 qr_type (int nargin, int nargout)
 {
   return ((nargout == 0 || nargout == 1)
-          ? qr<T>::raw
-          : (nargin == 2) ? qr<T>::economy : qr<T>::std);
+          ? octave::math::qr<T>::raw
+          : (nargin == 2) ? octave::math::qr<T>::economy : octave::math::qr<T>::std);
 }
 
 // [Q, R] = qr (X):      form Q unitary and R upper triangular such
 //                        that Q * R = X
 //
 // [Q, R] = qr (X, 0):    form the economy decomposition such that if X is
 //                        m by n then only the first n columns of Q are
 //                        computed.
@@ -271,34 +271,34 @@ permutation vector instead of a permutat
 
   if (arg.is_sparse_type ())
     {
       if (nargout > 2)
         error ("qr: Permutation output is not supported for sparse input");
 
       if (is_cmplx)
         {
-          sparse_qr<SparseComplexMatrix> q (arg.sparse_complex_matrix_value ());
+          octave::math::sparse_qr<SparseComplexMatrix> q (arg.sparse_complex_matrix_value ());
 
           if (have_b)
             {
               retval = ovl (q.C (args(1).complex_matrix_value ()),
                             q.R (economy));
               if (arg.rows () < arg.columns ())
                 warning ("qr: non minimum norm solution for under-determined "
                          "problem %dx%d", arg.rows (), arg.columns ());
             }
           else if (nargout > 1)
             retval = ovl (q.Q (), q.R (economy));
           else
             retval = ovl (q.R (economy));
         }
       else
         {
-          sparse_qr<SparseMatrix> q (arg.sparse_matrix_value ());
+          octave::math::sparse_qr<SparseMatrix> q (arg.sparse_matrix_value ());
 
           if (have_b)
             {
               retval = ovl (q.C (args(1).matrix_value ()), q.R (economy));
               if (arg.rows () < arg.columns ())
                 warning ("qr: non minimum norm solution for under-determined "
                          "problem %dx%d", arg.rows (), arg.columns ());
             }
@@ -309,174 +309,174 @@ permutation vector instead of a permutat
         }
     }
   else
     {
       if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
-              qr<FloatMatrix>::type type
+              octave::math::qr<FloatMatrix>::type type
                 = qr_type<FloatMatrix> (nargin, nargout);
 
               FloatMatrix m = arg.float_matrix_value ();
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   {
-                    qr<FloatMatrix> fact (m, type);
+                    octave::math::qr<FloatMatrix> fact (m, type);
                     retval = ovl (fact.R ());
                   }
                   break;
 
                 case 2:
                   {
-                    qr<FloatMatrix> fact (m, type);
+                    octave::math::qr<FloatMatrix> fact (m, type);
                     retval = ovl (fact.Q (), get_qr_r (fact));
                     if (have_b)
                       {
                         if (is_cmplx)
                           retval(0) = fact.Q ().transpose ()
                                       * args(1).float_complex_matrix_value ();
                         else
                           retval(0) = fact.Q ().transpose ()
                                       * args(1).float_matrix_value ();
                       }
                   }
                   break;
 
                 default:
                   {
-                    qrp<FloatMatrix> fact (m, type);
+                    octave::math::qrp<FloatMatrix> fact (m, type);
 
-                    if (type == qr<FloatMatrix>::economy || vector_p)
+                    if (type == octave::math::qr<FloatMatrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else if (arg.is_complex_type ())
             {
-              qr<FloatComplexMatrix>::type type
+              octave::math::qr<FloatComplexMatrix>::type type
                 = qr_type<FloatComplexMatrix> (nargin, nargout);
 
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   {
-                    qr<FloatComplexMatrix> fact (m, type);
+                    octave::math::qr<FloatComplexMatrix> fact (m, type);
                     retval = ovl (fact.R ());
                   }
                   break;
 
                 case 2:
                   {
-                    qr<FloatComplexMatrix> fact (m, type);
+                    octave::math::qr<FloatComplexMatrix> fact (m, type);
                     retval = ovl (fact.Q (), get_qr_r (fact));
                     if (have_b)
                       retval (0) = conj (fact.Q ().transpose ())
                                    * args(1).float_complex_matrix_value ();
                   }
                   break;
 
                 default:
                   {
-                    qrp<FloatComplexMatrix> fact (m, type);
-                    if (type == qr<FloatComplexMatrix>::economy || vector_p)
+                    octave::math::qrp<FloatComplexMatrix> fact (m, type);
+                    if (type == octave::math::qr<FloatComplexMatrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
         }
       else
         {
           if (arg.is_real_type ())
             {
-              qr<Matrix>::type type = qr_type<Matrix> (nargin, nargout);
+              octave::math::qr<Matrix>::type type = qr_type<Matrix> (nargin, nargout);
 
               Matrix m = arg.matrix_value ();
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   {
-                    qr<Matrix> fact (m, type);
+                    octave::math::qr<Matrix> fact (m, type);
                     retval = ovl (fact.R ());
                   }
                   break;
 
                 case 2:
                   {
-                    qr<Matrix> fact (m, type);
+                    octave::math::qr<Matrix> fact (m, type);
                     retval = ovl (fact.Q (), get_qr_r (fact));
                     if (have_b)
                       {
                         if (is_cmplx)
                           retval(0) = fact.Q ().transpose ()
                                       * args(1).complex_matrix_value ();
                         else
                           retval(0) = fact.Q ().transpose ()
                                       * args(1).matrix_value ();
                       }
                   }
                   break;
 
                 default:
                   {
-                    qrp<Matrix> fact (m, type);
-                    if (type == qr<Matrix>::economy || vector_p)
+                    octave::math::qrp<Matrix> fact (m, type);
+                    if (type == octave::math::qr<Matrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else if (arg.is_complex_type ())
             {
-              qr<ComplexMatrix>::type type
+              octave::math::qr<ComplexMatrix>::type type
                 = qr_type<ComplexMatrix> (nargin, nargout);
 
               ComplexMatrix m = arg.complex_matrix_value ();
 
               switch (nargout)
                 {
                 case 0:
                 case 1:
                   {
-                    qr<ComplexMatrix> fact (m, type);
+                    octave::math::qr<ComplexMatrix> fact (m, type);
                     retval = ovl (fact.R ());
                   }
                   break;
 
                 case 2:
                   {
-                    qr<ComplexMatrix> fact (m, type);
+                    octave::math::qr<ComplexMatrix> fact (m, type);
                     retval = ovl (fact.Q (), get_qr_r (fact));
                     if (have_b)
                       retval (0) = conj (fact.Q ().transpose ())
                                    * args(1).complex_matrix_value ();
                   }
                   break;
 
                 default:
                   {
-                    qrp<ComplexMatrix> fact (m, type);
-                    if (type == qr<ComplexMatrix>::economy || vector_p)
+                    octave::math::qrp<ComplexMatrix> fact (m, type);
+                    if (type == octave::math::qr<ComplexMatrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else
@@ -918,58 +918,58 @@ economized (R is square).
       if (argq.is_single_type () || argr.is_single_type ()
           || argu.is_single_type () || argv.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
           FloatMatrix u = argu.float_matrix_value ();
           FloatMatrix v = argv.float_matrix_value ();
 
-          qr<FloatMatrix> fact (Q, R);
+          octave::math::qr<FloatMatrix> fact (Q, R);
           fact.update (u, v);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           Matrix Q = argq.matrix_value ();
           Matrix R = argr.matrix_value ();
           Matrix u = argu.matrix_value ();
           Matrix v = argv.matrix_value ();
 
-          qr<Matrix> fact (Q, R);
+          octave::math::qr<Matrix> fact (Q, R);
           fact.update (u, v);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
     }
   else
     {
       // complex case
       if (argq.is_single_type () || argr.is_single_type ()
           || argu.is_single_type () || argv.is_single_type ())
         {
           FloatComplexMatrix Q = argq.float_complex_matrix_value ();
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexMatrix u = argu.float_complex_matrix_value ();
           FloatComplexMatrix v = argv.float_complex_matrix_value ();
 
-          qr<FloatComplexMatrix> fact (Q, R);
+          octave::math::qr<FloatComplexMatrix> fact (Q, R);
           fact.update (u, v);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           ComplexMatrix Q = argq.complex_matrix_value ();
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexMatrix u = argu.complex_matrix_value ();
           ComplexMatrix v = argv.complex_matrix_value ();
 
-          qr<ComplexMatrix> fact (Q, R);
+          octave::math::qr<ComplexMatrix> fact (Q, R);
           fact.update (u, v);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
     }
 
   return retval;
 }
@@ -1102,32 +1102,32 @@ If @var{orient} is @qcode{"row"}, full f
       // real case
       if (argq.is_single_type () || argr.is_single_type ()
           || argx.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
           FloatMatrix x = argx.float_matrix_value ();
 
-          qr<FloatMatrix> fact (Q, R);
+          octave::math::qr<FloatMatrix> fact (Q, R);
 
           if (col)
             fact.insert_col (x, j-one);
           else
             fact.insert_row (x.row (0), j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           Matrix Q = argq.matrix_value ();
           Matrix R = argr.matrix_value ();
           Matrix x = argx.matrix_value ();
 
-          qr<Matrix> fact (Q, R);
+          octave::math::qr<Matrix> fact (Q, R);
 
           if (col)
             fact.insert_col (x, j-one);
           else
             fact.insert_row (x.row (0), j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
@@ -1140,32 +1140,32 @@ If @var{orient} is @qcode{"row"}, full f
         {
           FloatComplexMatrix Q =
             argq.float_complex_matrix_value ();
           FloatComplexMatrix R =
             argr.float_complex_matrix_value ();
           FloatComplexMatrix x =
             argx.float_complex_matrix_value ();
 
-          qr<FloatComplexMatrix> fact (Q, R);
+          octave::math::qr<FloatComplexMatrix> fact (Q, R);
 
           if (col)
             fact.insert_col (x, j-one);
           else
             fact.insert_row (x.row (0), j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           ComplexMatrix Q = argq.complex_matrix_value ();
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexMatrix x = argx.complex_matrix_value ();
 
-          qr<ComplexMatrix> fact (Q, R);
+          octave::math::qr<ComplexMatrix> fact (Q, R);
 
           if (col)
             fact.insert_col (x, j-one);
           else
             fact.insert_row (x.row (0), j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
@@ -1293,31 +1293,31 @@ If @var{orient} is @qcode{"row"}, full f
   if (argq.is_real_type () && argr.is_real_type ())
     {
       // real case
       if (argq.is_single_type () || argr.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
 
-          qr<FloatMatrix> fact (Q, R);
+          octave::math::qr<FloatMatrix> fact (Q, R);
 
           if (col)
             fact.delete_col (j-one);
           else
             fact.delete_row (j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           Matrix Q = argq.matrix_value ();
           Matrix R = argr.matrix_value ();
 
-          qr<Matrix> fact (Q, R);
+          octave::math::qr<Matrix> fact (Q, R);
 
           if (col)
             fact.delete_col (j-one);
           else
             fact.delete_row (j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
@@ -1327,31 +1327,31 @@ If @var{orient} is @qcode{"row"}, full f
       // complex case
       if (argq.is_single_type () || argr.is_single_type ())
         {
           FloatComplexMatrix Q =
             argq.float_complex_matrix_value ();
           FloatComplexMatrix R =
             argr.float_complex_matrix_value ();
 
-          qr<FloatComplexMatrix> fact (Q, R);
+          octave::math::qr<FloatComplexMatrix> fact (Q, R);
 
           if (col)
             fact.delete_col (j-one);
           else
             fact.delete_row (j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           ComplexMatrix Q = argq.complex_matrix_value ();
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          qr<ComplexMatrix> fact (Q, R);
+          octave::math::qr<ComplexMatrix> fact (Q, R);
 
           if (col)
             fact.delete_col (j-one);
           else
             fact.delete_row (j(0)-one);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
@@ -1519,52 +1519,52 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
     {
       // all real case
       if (argq.is_single_type ()
           && argr.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
 
-          qr<FloatMatrix> fact (Q, R);
+          octave::math::qr<FloatMatrix> fact (Q, R);
           fact.shift_cols (i-1, j-1);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           Matrix Q = argq.matrix_value ();
           Matrix R = argr.matrix_value ();
 
-          qr<Matrix> fact (Q, R);
+          octave::math::qr<Matrix> fact (Q, R);
           fact.shift_cols (i-1, j-1);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
     }
   else
     {
       // complex case
       if (argq.is_single_type ()
           && argr.is_single_type ())
         {
           FloatComplexMatrix Q = argq.float_complex_matrix_value ();
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-          qr<FloatComplexMatrix> fact (Q, R);
+          octave::math::qr<FloatComplexMatrix> fact (Q, R);
           fact.shift_cols (i-1, j-1);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
       else
         {
           ComplexMatrix Q = argq.complex_matrix_value ();
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          qr<ComplexMatrix> fact (Q, R);
+          octave::math::qr<ComplexMatrix> fact (Q, R);
           fact.shift_cols (i-1, j-1);
 
           retval = ovl (fact.Q (), get_qr_r (fact));
         }
     }
 
   return retval;
 }
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -720,17 +720,17 @@ namespace octave
       : base_lexer (interp_context), input_reader (this)
     { }
 
     lexer (FILE *file, interpreter *interp_context = 0)
       : base_lexer (interp_context), input_reader (file, this)
     { }
 
     lexer (const std::string& eval_string,
-                  interpreter *interp_context = 0)
+           interpreter *interp_context = 0)
       : base_lexer (interp_context), input_reader (eval_string, this)
     { }
 
     void reset (void)
     {
       input_reader.reset ();
 
       base_lexer::reset ();
@@ -784,30 +784,30 @@ namespace octave
 
     push_lexer (interpreter *interp_context = 0)
       : base_lexer (interp_context), pflag (1)
     {
       append_input ("", false);
     }
 
     push_lexer (const std::string& input,
-                       interpreter *interp_context = 0)
+                interpreter *interp_context = 0)
       : base_lexer (interp_context), pflag (1)
     {
       append_input (input, false);
     }
 
     push_lexer (bool eof, interpreter *interp_context = 0)
       : base_lexer (interp_context), pflag (1)
     {
       append_input ("", eof);
     }
 
     push_lexer (const std::string& input, bool eof,
-                       interpreter *interp_context = 0)
+                interpreter *interp_context = 0)
       : base_lexer (interp_context), pflag (1)
     {
       append_input (input, eof);
     }
 
     bool is_push_lexer (void) const { return true; }
 
     void reset (void)
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1105,17 +1105,17 @@ ComplexMatrix::inverse (MatrixType &matt
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          chol<ComplexMatrix> chol (*this, info, true, calc_cond);
+          octave::math::chol<ComplexMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
@@ -1134,17 +1134,17 @@ ComplexMatrix::inverse (MatrixType &matt
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
 {
   ComplexMatrix retval;
 
-  svd<ComplexMatrix> result (*this, svd<ComplexMatrix>::Type::economy);
+  octave::math::svd<ComplexMatrix> result (*this, octave::math::svd<ComplexMatrix>::Type::economy);
 
   DiagMatrix S = result.singular_values ();
   ComplexMatrix U = result.left_singular_matrix ();
   ComplexMatrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -3486,18 +3486,18 @@ Sylvester (const ComplexMatrix& a, const
            const ComplexMatrix& c)
 {
   ComplexMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions
 
-  schur<ComplexMatrix> as (a, "U");
-  schur<ComplexMatrix> bs (b, "U");
+  octave::math::schur<ComplexMatrix> as (a, "U");
+  octave::math::schur<ComplexMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   ComplexMatrix ua = as.unitary_matrix ();
   ComplexMatrix sch_a = as.schur_matrix ();
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1072,17 +1072,17 @@ SparseComplexMatrix::inverse (MatrixType
       MatrixType newtype = mattype.transpose ();
       ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
-          sparse_chol<SparseComplexMatrix> fact (*this, info, false);
+          octave::math::sparse_chol<SparseComplexMatrix> fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseComplexMatrix InvL = fact.L ().transpose ().
                                          tinverse (tmp_typ, info, rcond2,
                                                    true, false);
@@ -1098,17 +1098,17 @@ SparseComplexMatrix::inverse (MatrixType
       if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          sparse_lu<SparseComplexMatrix> fact (*this, Qinit, Matrix (), false, false);
+          octave::math::sparse_lu<SparseComplexMatrix> fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseComplexMatrix InvL = fact.L ().transpose ().
                                      tinverse (tmp_typ, info, rcond2,
                                                true, false);
           SparseComplexMatrix InvU = fact.U ().
                                      tinverse (tmp_typ, info, rcond2,
                                                true, false).transpose ();
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -792,17 +792,17 @@ Matrix::inverse (MatrixType &mattype, oc
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          chol<Matrix> chol (*this, info, true, calc_cond);
+          octave::math::chol<Matrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
@@ -818,17 +818,17 @@ Matrix::inverse (MatrixType &mattype, oc
     }
 
   return ret;
 }
 
 Matrix
 Matrix::pseudo_inverse (double tol) const
 {
-  svd<Matrix> result (*this, svd<Matrix>::Type::economy);
+  octave::math::svd<Matrix> result (*this, octave::math::svd<Matrix>::Type::economy);
 
   DiagMatrix S = result.singular_values ();
   Matrix U = result.left_singular_matrix ();
   Matrix V = result.right_singular_matrix ();
 
   ColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -2945,18 +2945,18 @@ Matrix
 Sylvester (const Matrix& a, const Matrix& b, const Matrix& c)
 {
   Matrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
-  schur<Matrix> as (a, "U");
-  schur<Matrix> bs (b, "U");
+  octave::math::schur<Matrix> as (a, "U");
+  octave::math::schur<Matrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   Matrix ua = as.unitary_matrix ();
   Matrix sch_a = as.schur_matrix ();
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1164,17 +1164,17 @@ SparseMatrix::inverse (MatrixType &matty
       MatrixType newtype = mattype.transpose ();
       ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
-          sparse_chol<SparseMatrix> fact (*this, info, false);
+          octave::math::sparse_chol<SparseMatrix> fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                   info, rcond2, true, false);
               ret = Q * InvL.transpose () * InvL * Q.transpose ();
@@ -1189,17 +1189,17 @@ SparseMatrix::inverse (MatrixType &matty
       if (! mattype.is_hermitian ())
         {
           octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          sparse_lu<SparseMatrix> fact (*this, Qinit, Matrix (), false, false);
+          octave::math::sparse_lu<SparseMatrix> fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                               info, rcond2, true, false);
           SparseMatrix InvU = fact.U ().tinverse (tmp_typ, info, rcond2,
                                                   true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1110,17 +1110,17 @@ FloatComplexMatrix::inverse (MatrixType 
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          chol<FloatComplexMatrix> chol (*this, info, true, calc_cond);
+          octave::math::chol<FloatComplexMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
@@ -1139,17 +1139,17 @@ FloatComplexMatrix::inverse (MatrixType 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
 {
   FloatComplexMatrix retval;
 
-  svd<FloatComplexMatrix> result (*this, svd<FloatComplexMatrix>::Type::economy);
+  octave::math::svd<FloatComplexMatrix> result (*this, octave::math::svd<FloatComplexMatrix>::Type::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatComplexMatrix U = result.left_singular_matrix ();
   FloatComplexMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -3513,18 +3513,18 @@ Sylvester (const FloatComplexMatrix& a, 
 {
   FloatComplexMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
-  schur<FloatComplexMatrix> as (a, "U");
-  schur<FloatComplexMatrix> bs (b, "U");
+  octave::math::schur<FloatComplexMatrix> as (a, "U");
+  octave::math::schur<FloatComplexMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   FloatComplexMatrix ua = as.unitary_matrix ();
   FloatComplexMatrix sch_a = as.schur_matrix ();
 
   FloatComplexMatrix ub = bs.unitary_matrix ();
   FloatComplexMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -799,17 +799,17 @@ FloatMatrix::inverse (MatrixType &mattyp
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          chol<FloatMatrix> chol (*this, info, true, calc_cond);
+          octave::math::chol<FloatMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
@@ -825,17 +825,17 @@ FloatMatrix::inverse (MatrixType &mattyp
     }
 
   return ret;
 }
 
 FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
 {
-  svd<FloatMatrix> result (*this, svd<FloatMatrix>::Type::economy);
+  octave::math::svd<FloatMatrix> result (*this, octave::math::svd<FloatMatrix>::Type::economy);
 
   FloatDiagMatrix S = result.singular_values ();
   FloatMatrix U = result.left_singular_matrix ();
   FloatMatrix V = result.right_singular_matrix ();
 
   FloatColumnVector sigma = S.extract_diag ();
 
   octave_idx_type r = sigma.numel () - 1;
@@ -2960,18 +2960,18 @@ FloatMatrix
 Sylvester (const FloatMatrix& a, const FloatMatrix& b, const FloatMatrix& c)
 {
   FloatMatrix retval;
 
   // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
-  schur<FloatMatrix> as (a, "U");
-  schur<FloatMatrix> bs (b, "U");
+  octave::math::schur<FloatMatrix> as (a, "U");
+  octave::math::schur<FloatMatrix> bs (b, "U");
 
   // Transform c to new coordinates.
 
   FloatMatrix ua = as.unitary_matrix ();
   FloatMatrix sch_a = as.schur_matrix ();
 
   FloatMatrix ub = bs.unitary_matrix ();
   FloatMatrix sch_b = bs.schur_matrix ();
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -110,16 +110,21 @@ extern "C"
 }
 
 static inline char
 get_job (bool noperm, bool noscal)
 {
   return noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <>
 aepbalance<Matrix>::aepbalance (const Matrix& a, bool noperm, bool noscal)
   : balanced_mat (a), scale (), ilo (), ihi (), job (get_job (noperm, noscal))
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
@@ -290,8 +295,11 @@ aepbalance<FloatComplexMatrix>::balancin
 
 template class aepbalance<Matrix>;
 
 template class aepbalance<FloatMatrix>;
 
 template class aepbalance<ComplexMatrix>;
 
 template class aepbalance<FloatComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/aepbalance.h b/liboctave/numeric/aepbalance.h
--- a/liboctave/numeric/aepbalance.h
+++ b/liboctave/numeric/aepbalance.h
@@ -21,16 +21,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_aepbalance_h)
 #define octave_aepbalance_h 1
 
 #include "octave-config.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename MT>
 class aepbalance
 {
 public:
 
   typedef typename MT::real_column_vector_type VT;
 
   aepbalance (void) : balanced_mat (), scale (), ilo (), ihi (), job () { }
@@ -112,9 +117,12 @@ protected:
 
   MT balanced_mat;
   VT scale;
   octave_idx_type ilo;
   octave_idx_type ihi;
   char job;
 };
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -415,16 +415,21 @@ chol2inv_internal (const FloatComplexMat
             tmp.xelem (j, i) = tmp.xelem (i, j);
     }
 
   retval = tmp;
 
   return retval;
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 T
 chol2inv (const T& r)
 {
   return chol2inv_internal (r);
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
@@ -458,17 +463,17 @@ chol<T>::update (const VT& u)
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   init (chol_mat.hermitian () * chol_mat + T (u) * T (u).hermitian (),
         true, false);
 }
 
 template <typename T>
-static bool
+bool
 singular (const T& a)
 {
   static typename T::element_type zero (0);
   for (octave_idx_type i = 0; i < a.rows (); i++)
     if (a(i,i) == zero) return true;
   return false;
 }
 
@@ -1291,8 +1296,11 @@ chol2inv<Matrix> (const Matrix& r);
 template ComplexMatrix
 chol2inv<ComplexMatrix> (const ComplexMatrix& r);
 
 template FloatMatrix
 chol2inv<FloatMatrix> (const FloatMatrix& r);
 
 template FloatComplexMatrix
 chol2inv<FloatComplexMatrix> (const FloatComplexMatrix& r);
+
+}
+}
diff --git a/liboctave/numeric/chol.h b/liboctave/numeric/chol.h
--- a/liboctave/numeric/chol.h
+++ b/liboctave/numeric/chol.h
@@ -21,16 +21,21 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_chol_h)
 #define octave_chol_h 1
 
 #include "octave-config.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 chol
 {
 public:
 
   typedef typename T::column_vector_type VT;
   typedef typename T::real_elt_type COND_T;
@@ -93,9 +98,12 @@ private:
 
   octave_idx_type init (const T& a, bool upper, bool calc_cond);
 };
 
 template <typename T>
 T
 chol2inv (const T& r);
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -297,17 +297,17 @@ vector_product (const ComplexMatrix& m, 
 
   return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  chol<Matrix> fact (b, info);
+  octave::math::chol<Matrix> fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b = bt.transpose ();
@@ -317,34 +317,34 @@ make_cholb (Matrix& b, Matrix& bt, Colum
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  sparse_chol<SparseMatrix> fact (b, info, false);
+  octave::math::sparse_chol<SparseMatrix> fact (b, info, false);
 
   if (fact.P () != 0)
     return false;
   else
     {
       b = fact.L ();
       bt = b.transpose ();
       permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
 make_cholb (ComplexMatrix& b, ComplexMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  chol<ComplexMatrix> fact (b, info);
+  octave::math::chol<ComplexMatrix> fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b = bt.hermitian ();
@@ -355,17 +355,17 @@ make_cholb (ComplexMatrix& b, ComplexMat
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
             ColumnVector& permB)
 {
   octave_idx_type info;
-  sparse_chol<SparseComplexMatrix> fact (b, info, false);
+  octave::math::sparse_chol<SparseComplexMatrix> fact (b, info, false);
 
   if (fact.P () != 0)
     return false;
   else
     {
       b = fact.L ();
       bt = b.hermitian ();
       permB = fact.perm () - 1.0;
@@ -421,17 +421,17 @@ LuAminusSigmaB (const SparseMatrix &m, c
           sigmat.xdata (i) = sigma;
           sigmat.xridx (i) = i;
           sigmat.xcidx (i+1) = i + 1;
         }
 
       AminusSigmaB -= sigmat;
     }
 
-  sparse_lu<SparseMatrix> fact (AminusSigmaB);
+  octave::math::sparse_lu<SparseMatrix> fact (AminusSigmaB);
 
   L = fact.L ();
   U = fact.U ();
   const octave_idx_type *P2 = fact.row_perm ();
   const octave_idx_type *Q2 = fact.col_perm ();
 
   for (octave_idx_type j = 0; j < n; j++)
     {
@@ -503,17 +503,17 @@ LuAminusSigmaB (const Matrix &m, const M
   else
     {
       double *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
-  lu<Matrix> fact (AminusSigmaB);
+  octave::math::lu<Matrix> fact (AminusSigmaB);
 
   L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave::numeric_limits<double>::NaN ();
@@ -585,17 +585,17 @@ LuAminusSigmaB (const SparseComplexMatri
           sigmat.xdata (i) = sigma;
           sigmat.xridx (i) = i;
           sigmat.xcidx (i+1) = i + 1;
         }
 
       AminusSigmaB -= sigmat;
     }
 
-  sparse_lu<SparseComplexMatrix> fact (AminusSigmaB);
+  octave::math::sparse_lu<SparseComplexMatrix> fact (AminusSigmaB);
 
   L = fact.L ();
   U = fact.U ();
   const octave_idx_type *P2 = fact.row_perm ();
   const octave_idx_type *Q2 = fact.col_perm ();
 
   for (octave_idx_type j = 0; j < n; j++)
     {
@@ -667,17 +667,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   else
     {
       Complex *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
-  lu<ComplexMatrix> fact (AminusSigmaB);
+  octave::math::lu<ComplexMatrix> fact (AminusSigmaB);
 
   L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave::numeric_limits<double>::NaN ();
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -98,16 +98,21 @@ extern "C"
                              F77_CMPLX* A, const F77_INT& LDA,
                              F77_CMPLX* B, const F77_INT& LDB,
                              F77_INT& ILO, F77_INT& IHI,
                              F77_REAL* LSCALE, F77_REAL* RSCALE,
                              F77_REAL* WORK, F77_INT& INFO
                              F77_CHAR_ARG_LEN_DECL);
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <>
 octave_idx_type
 gepbalance<Matrix>::init (const Matrix& a, const Matrix& b,
                           const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
@@ -371,8 +376,11 @@ gepbalance<FloatComplexMatrix>::init (co
 
 template class gepbalance<Matrix>;
 
 template class gepbalance<FloatMatrix>;
 
 template class gepbalance<ComplexMatrix>;
 
 template class gepbalance<FloatComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/gepbalance.h b/liboctave/numeric/gepbalance.h
--- a/liboctave/numeric/gepbalance.h
+++ b/liboctave/numeric/gepbalance.h
@@ -22,16 +22,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_gepbalance_h)
 #define octave_gepbalance_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 gepbalance
 {
 public:
 
   typedef typename T::real_matrix_type RT;
 
@@ -78,9 +83,12 @@ private:
   T balanced_mat;
   T balanced_mat2;
   RT balancing_mat;
   RT balancing_mat2;
 
   octave_idx_type init (const T& a, const T& b, const std::string& job);
 };
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -148,16 +148,21 @@ extern "C"
                              const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_REAL*,
                              const F77_INT&, F77_CMPLX*,
                              const F77_INT&, F77_INT&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <>
 octave_idx_type
 hess<Matrix>::init (const Matrix& a)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
@@ -398,8 +403,11 @@ hess<FloatComplexMatrix>::init (const Fl
 
   if (n > 2)
     for (octave_idx_type j = 0; j < a_nc; j++)
       for (octave_idx_type i = j+2; i < a_nr; i++)
         hess_mat.elem (i, j) = 0;
 
   return info;
 }
+
+}
+}
diff --git a/liboctave/numeric/hess.h b/liboctave/numeric/hess.h
--- a/liboctave/numeric/hess.h
+++ b/liboctave/numeric/hess.h
@@ -22,16 +22,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_hess_h)
 #define octave_hess_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 hess
 {
 public:
 
   hess (void)
     : hess_mat (), unitary_hess_mat ()
@@ -77,9 +82,12 @@ private:
 
   octave_idx_type init (const T& a);
 };
 
 template <typename T>
 extern std::ostream&
 operator << (std::ostream& os, const hess<T>& a);
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -116,16 +116,21 @@ extern "C"
   F77_FUNC (clup1up, CLUP1UP) (const F77_INT&, const F77_INT&,
                                F77_CMPLX *, const F77_INT&,
                                F77_CMPLX *, const F77_INT&,
                                F77_INT *, const F77_CMPLX *,
                                const F77_CMPLX *, F77_CMPLX *);
 #endif
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 lu<T>::lu (const T& l, const T& u,
                            const PermMatrix& p)
   : a_fact (u), l_fact (l), ipvt (p.transpose ().col_perm_vec ())
 {
   if (l.columns () != u.rows ())
     (*current_liboctave_error_handler) ("lu: dimension mismatch");
 }
@@ -877,8 +882,11 @@ lu<FloatComplexMatrix>::update_piv (cons
 
 template class lu<Matrix>;
 
 template class lu<FloatMatrix>;
 
 template class lu<ComplexMatrix>;
 
 template class lu<FloatComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/lu.h b/liboctave/numeric/lu.h
--- a/liboctave/numeric/lu.h
+++ b/liboctave/numeric/lu.h
@@ -23,16 +23,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_lu_h)
 #define octave_lu_h 1
 
 #include "octave-config.h"
 
 #include "PermMatrix.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 lu
 {
 public:
 
   typedef typename T::column_vector_type VT;
   typedef typename T::element_type ELT_T;
@@ -90,9 +95,12 @@ protected:
   Array<octave_idx_type> getp (void) const;
 
   T a_fact;
   T l_fact;
 
   Array<octave_idx_type> ipvt;
 };
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -480,17 +480,18 @@ static int max_norm_iter = 100;
 
 // version with SVD for dense matrices
 template <typename MatrixT, typename VectorT, typename R>
 R svd_matrix_norm (const MatrixT& m, R p, VectorT)
 {
   R res = 0;
   if (p == 2)
     {
-      svd<MatrixT> fact (m, svd<MatrixT>::Type::sigma_only);
+      octave::math::svd<MatrixT> fact
+        (m, octave::math::svd<MatrixT>::Type::sigma_only);
       res = fact.singular_values () (0,0);
     }
   else if (p == 1)
     res = xcolnorms (m, 1).max ();
   else if (lo_ieee_isinf (p))
     res = xrownorms (m, 1).max ();
   else if (p > 1)
     {
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -267,16 +267,21 @@ extern "C"
                              const F77_INT&, F77_CMPLX*,
                              const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_CMPLX*,
                              F77_REAL*);
 
 #endif
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 qr<T>::qr (const T& q_arg, const T& r_arg)
   : q (q_arg), r (r_arg)
 {
   octave_idx_type q_nr = q.rows ();
   octave_idx_type q_nc = q.columns ();
 
   octave_idx_type r_nr = r.rows ();
@@ -2037,8 +2042,11 @@ qr<FloatComplexMatrix>::shift_cols (octa
 
 template class qr<Matrix>;
 
 template class qr<FloatMatrix>;
 
 template class qr<ComplexMatrix>;
 
 template class qr<FloatComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/qr.h b/liboctave/numeric/qr.h
--- a/liboctave/numeric/qr.h
+++ b/liboctave/numeric/qr.h
@@ -24,16 +24,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_qr_h)
 #define octave_qr_h 1
 
 #include "octave-config.h"
 
 #include "Array.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 qr
 {
 public:
 
   typedef typename T::element_type ELT_T;
   typedef typename T::row_vector_type RV_T;
@@ -104,9 +109,12 @@ protected:
   T q;
   T r;
 
   void form (octave_idx_type n, T& afact, ELT_T *tau, type qr_type);
 };
 
 extern void warn_qrupdate_once (void);
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -59,16 +59,21 @@ extern "C"
                              F77_INT&);
   F77_RET_T
   F77_FUNC (cgeqp3, CGEQP3) (const F77_INT&, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_INT*, F77_CMPLX*, F77_CMPLX*,
                              const F77_INT&, F77_REAL*, F77_INT&);
 }
 
+namespace octave
+{
+namespace math
+{
+
 // Specialization.
 
 template <>
 void
 qrp<Matrix>::init (const Matrix& a, type qr_type)
 {
   assert (qr_type != qr<Matrix>::raw);
 
@@ -320,8 +325,11 @@ qrp<FloatComplexMatrix>::qrp (const Floa
 template <>
 FloatRowVector
 qrp<FloatComplexMatrix>::Pvec (void) const
 {
   Array<float> pa (p.col_perm_vec ());
   FloatRowVector pv (MArray<float> (pa) + 1.0f);
   return pv;
 }
+
+}
+}
diff --git a/liboctave/numeric/qrp.h b/liboctave/numeric/qrp.h
--- a/liboctave/numeric/qrp.h
+++ b/liboctave/numeric/qrp.h
@@ -24,16 +24,21 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_qrp_h)
 #define octave_qrp_h 1
 
 #include "octave-config.h"
 
 #include "PermMatrix.h"
 #include "qr.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 qrp : public qr<T>
 {
 public:
 
   typedef typename T::real_row_vector_type RV_T;
 
@@ -64,9 +69,12 @@ public:
 
   RV_T Pvec (void) const;
 
 private:
 
   PermMatrix p;
 };
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -102,16 +102,21 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (crsf2csf, CRSF2CSF) (const F77_INT&, F77_CMPLX *,
                                  F77_CMPLX *, F77_REAL *, F77_REAL *);
 }
 
+namespace octave
+{
+namespace math
+{
+
 // For real types.
 
 template <typename T>
 static octave_idx_type
 select_ana (const T& a, const T&)
 {
   return (a < 0.0);
 }
@@ -530,8 +535,11 @@ rsf2csf<FloatComplexMatrix, FloatMatrix>
 
 template class schur<ComplexMatrix>;
 
 template class schur<FloatComplexMatrix>;
 
 template class schur<FloatMatrix>;
 
 template class schur<Matrix>;
+
+}
+}
diff --git a/liboctave/numeric/schur.h b/liboctave/numeric/schur.h
--- a/liboctave/numeric/schur.h
+++ b/liboctave/numeric/schur.h
@@ -27,16 +27,21 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "fMatrix.h"
 #include "fCMatrix.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T> class schur;
 
 template <typename T>
 class
 schur
 {
 public:
 
@@ -92,9 +97,12 @@ private:
   octave_idx_type
   init (const T& a, const std::string& ord, bool calc_unitary);
 };
 
 template <typename RT, typename AT>
 extern schur<RT>
 rsf2csf (const AT& s, const AT& u);
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -29,16 +29,21 @@ along with Octave; see the file COPYING.
 #include "sparse-chol.h"
 #include "sparse-util.h"
 #include "lo-error.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
 #include "MatrixType.h"
 
+namespace octave
+{
+namespace math
+{
+
 template <typename chol_type>
 class sparse_chol<chol_type>::sparse_chol_rep
 {
 public:
 
   sparse_chol_rep (void)
     : count (1), is_pd (false), minor_p (0), perms (), cond (0)
 #if defined (HAVE_CHOLMOD)
@@ -583,8 +588,11 @@ template class sparse_chol<SparseMatrix>
 
 template class sparse_chol<SparseComplexMatrix>;
 
 template SparseMatrix
 chol2inv<SparseMatrix> (const SparseMatrix& r);
 
 template SparseComplexMatrix
 chol2inv<SparseComplexMatrix> (const SparseComplexMatrix& r);
+
+}
+}
diff --git a/liboctave/numeric/sparse-chol.h b/liboctave/numeric/sparse-chol.h
--- a/liboctave/numeric/sparse-chol.h
+++ b/liboctave/numeric/sparse-chol.h
@@ -26,16 +26,21 @@ along with Octave; see the file COPYING.
 #define octave_sparse_chol_h 1
 
 #include "octave-config.h"
 
 #include "CSparse.h"
 #include "dRowVector.h"
 #include "dSparse.h"
 
+namespace octave
+{
+namespace math
+{
+
 // If the sparse matrix classes become templated on the element type
 // (i.e., sparse_matrix<double>), then it might be best to make the
 // template parameter of this class also be the element type instead
 // of the matrix type.
 
 template <typename chol_type>
 class
 sparse_chol
@@ -91,9 +96,12 @@ chol_type
 chol2inv (const chol_type& r);
 
 // SparseComplexMatrix specialization.
 
 template <>
 sparse_chol<SparseComplexMatrix>::sparse_chol (const SparseComplexMatrix& a,
                                                octave_idx_type& info);
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -408,18 +408,17 @@ dmsolve (const ST &a, const T &b, octave
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
-          RT mtmp = qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2],
-                                                 b_nr, 0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
 
           if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[2], 0, b_nc);
@@ -438,17 +437,17 @@ dmsolve (const ST &a, const T &b, octave
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
-              mtmp = qrsolve (m, btmp2, info);
+              mtmp = octave::math::qrsolve (m, btmp2, info);
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
           if (dm->rr[1] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
                                    dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
@@ -457,18 +456,17 @@ dmsolve (const ST &a, const T &b, octave
             }
         }
 
       // Trailing under-determined block
       if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
-          RT mtmp = qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1],
-                                                 0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1], 0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
 
 #else
 
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -30,16 +30,21 @@ along with Octave; see the file COPYING.
 #include "PermMatrix.h"
 #include "dSparse.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "sparse-lu.h"
 
+namespace octave
+{
+namespace math
+{
+
 // Wrappers for SuiteSparse (formerly UMFPACK) functions that have
 // different names depending on the sparse matrix data type.
 //
 // All of these functions must be specialized to forward to the correct
 // SuiteSparse functions.
 
 template <typename T>
 void
@@ -906,8 +911,11 @@ sparse_lu<lu_type>::Pc_mat (void) const
   return PermMatrix (Q, true);
 }
 
 // Instantiations we need.
 
 template class sparse_lu<SparseMatrix>;
 
 template class sparse_lu<SparseComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/sparse-lu.h b/liboctave/numeric/sparse-lu.h
--- a/liboctave/numeric/sparse-lu.h
+++ b/liboctave/numeric/sparse-lu.h
@@ -25,16 +25,21 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_sparse_lu_h)
 #define octave_sparse_lu_h 1
 
 #include "octave-config.h"
 
 #include "MArray.h"
 #include "dSparse.h"
 
+namespace octave
+{
+namespace math
+{
+
 // If the sparse matrix classes become templated on the element type
 // (i.e., sparse_matrix<double>), then it might be best to make the
 // template parameter of this class also be the element type instead
 // of the matrix type.
 
 template <typename lu_type>
 class
 sparse_lu
@@ -108,9 +113,12 @@ protected:
   SparseMatrix Rfact;
 
   double cond;
 
   MArray<octave_idx_type> P;
   MArray<octave_idx_type> Q;
 };
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -25,16 +25,21 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "oct-sparse.h"
 #include "sparse-qr.h"
 
+namespace octave
+{
+namespace math
+{
+  
 template <typename SPARSE_T>
 class
 cxsparse_types
 {
 };
 
 template <>
 class
@@ -2299,8 +2304,11 @@ qrsolve (const SparseComplexMatrix& a, c
   return sparse_qr<SparseComplexMatrix>::solve<SparseComplexMatrix, SparseComplexMatrix> (a, b, info);
 }
 
 // Instantiations we need.
 
 template class sparse_qr<SparseMatrix>;
 
 template class sparse_qr<SparseComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/sparse-qr.h b/liboctave/numeric/sparse-qr.h
--- a/liboctave/numeric/sparse-qr.h
+++ b/liboctave/numeric/sparse-qr.h
@@ -26,16 +26,21 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "dSparse.h"
 #include "CSparse.h"
 
+namespace octave
+{
+namespace math
+{
+
 // If the sparse matrix classes become templated on the element type
 // (i.e., sparse_matrix<double>), then it might be best to make the
 // template parameter of this class also be the element type instead
 // of the matrix type.
 
 template <typename SPARSE_T>
 class
 sparse_qr
@@ -120,9 +125,12 @@ qrsolve (const SparseComplexMatrix& a, c
 
 extern SparseComplexMatrix
 qrsolve (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
          octave_idx_type& info);
 
 typedef sparse_qr<SparseMatrix> SparseQR;
 typedef sparse_qr<SparseComplexMatrix> SparseComplexQR;
 
+}
+}
+
 #endif
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -122,16 +122,21 @@ extern "C"
                              F77_CMPLX*, const F77_INT&, F77_REAL*,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_REAL*, F77_INT *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 }
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 T
 svd<T>::left_singular_matrix (void) const
 {
   if (m_type == svd::Type::sigma_only)
     (*current_liboctave_error_handler)
       ("svd: U not computed because type == svd::sigma_only");
 
@@ -489,8 +494,11 @@ svd<T>::svd (const T& a, svd::Type type,
 
 template class svd<Matrix>;
 
 template class svd<FloatMatrix>;
 
 template class svd<ComplexMatrix>;
 
 template class svd<FloatComplexMatrix>;
+
+}
+}
diff --git a/liboctave/numeric/svd.h b/liboctave/numeric/svd.h
--- a/liboctave/numeric/svd.h
+++ b/liboctave/numeric/svd.h
@@ -23,16 +23,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_svd_h)
 #define octave_svd_h 1
 
 #include "octave-config.h"
 
 #include <vector>
 
+namespace octave
+{
+namespace math
+{
+
 template <typename T>
 class
 svd
 {
 public:
 
   typedef typename T::real_diag_matrix_type DM_T;
 
@@ -103,9 +108,12 @@ private:
   void gesdd (char& jobz, octave_idx_type m, octave_idx_type n,
               P* tmp_data, octave_idx_type m1, DM_P* s_vec, P* u, P* vt,
               octave_idx_type nrow_vt1, std::vector<P>& work,
               octave_idx_type& lwork,
               octave_idx_type* iwork, octave_idx_type& info);
 
 };
 
+}
+}
+
 #endif
