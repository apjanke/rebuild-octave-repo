# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1250682479 -7200
#      Wed Aug 19 13:47:59 2009 +0200
# Node ID 1beb23d2b892a26dfd60087f598ee2a2217418b1
# Parent  8670e55078fd7a52119d9cfb8dbe637115a2c4af
optimize op= in common cases

diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -106,16 +106,31 @@ Array<T>::fill (const T& val)
       rep = new ArrayRep (length (), val);
       slice_data = rep->data;
     }
   else
     std::fill (slice_data, slice_data + slice_len, val);
 }
 
 template <class T>
+void
+Array<T>::clear (void)
+{
+  if (--rep->count <= 0)
+    delete rep;
+
+  rep = nil_rep ();
+  rep->count++; 
+  slice_data = rep->data;
+  slice_len = rep->len;
+
+  dimensions = dim_vector ();
+}
+
+template <class T>
 Array<T>
 Array<T>::squeeze (void) const
 {
   Array<T> retval = *this;
 
   if (ndims () > 2)
     {
       bool dims_changed = false;
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -233,16 +233,17 @@ public:
 
   Array (const Array<T>& a, const dim_vector& dv);
 
   virtual ~Array (void);
 
   Array<T>& operator = (const Array<T>& a);
 
   void fill (const T& val); 
+  void clear (void);
 
   octave_idx_type capacity (void) const { return slice_len; }
   octave_idx_type length (void) const { return capacity (); }
   octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
@@ -435,16 +436,18 @@ public:
   Array<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   const T *data (void) const { return slice_data; }
 
   const T *fortran_vec (void) const { return data (); }
 
   T *fortran_vec (void);
 
+  bool is_shared (void) { return rep->count > 1; }
+
   int ndims (void) const { return dimensions.length (); }
 
   void maybe_delete_dims (void);
 
   // Indexing without resizing.
 
   Array<T> index (const idx_vector& i) const;
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "Array-util.h"
 #include "CNDArray.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
+#include "MArray-defs.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 ComplexNDArray::ComplexNDArray (const charNDArray& a)
   : MArrayN<Complex> (a.dims ())
 {
@@ -1078,13 +1079,29 @@ NDS_CMP_OPS(ComplexNDArray, std::real, C
 NDS_BOOL_OPS(ComplexNDArray, Complex, 0.0)
 
 SND_CMP_OPS(Complex, std::real, ComplexNDArray, std::real)
 SND_BOOL_OPS(Complex, ComplexNDArray, 0.0)
 
 NDND_CMP_OPS(ComplexNDArray, std::real, ComplexNDArray, std::real)
 NDND_BOOL_OPS(ComplexNDArray, ComplexNDArray, 0.0)
 
+ComplexNDArray& operator *= (ComplexNDArray& a, double s)
+{
+  if (a.is_shared ())
+    return a = a * s;
+  DO_VS_OP2 (Complex, a, *=, s)
+  return a;
+}
+
+ComplexNDArray& operator /= (ComplexNDArray& a, double s)
+{
+  if (a.is_shared ())
+    return a = a / s;
+  DO_VS_OP2 (Complex, a, /=, s)
+  return a;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -168,15 +168,18 @@ NDS_BOOL_OP_DECLS (ComplexNDArray, Compl
 SND_CMP_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (Complex, ComplexNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, ComplexNDArray, Complex)
 
+extern OCTAVE_API ComplexNDArray& operator *= (ComplexNDArray& a, double s);
+extern OCTAVE_API ComplexNDArray& operator /= (ComplexNDArray& a, double s);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,31 @@
+2009-08-19  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Array.cc (Array<T>::clear): New method.
+	* Array.h: Declare it.
+	* MArray-decl.h (MARRAY_OP_ASSIGN_DECLS1, MARRAY_OP_ASSIGN_FWD_DECLS1,
+	MARRAY_OP_ASSIGN_FRIENDS1, MARRAY_OP_ASSIGN_FWD_DEFS1): New macros.
+	(MARRAY_OPS_FORWARD_DECLS, MARRAY_OPS_FRIEND_DECLS): Use them.
+	* MArray-defs.h (MARRAY_OP_ASSIGN_DEFS1): New macro.
+	(INSTANTIATE_MARRAY_FRIENDS): Use it.
+	(INSTANTIATE_MARRAY2_FRIENDS): Use it.
+	(INSTANTIATE_MARRAYN_FRIENDS): Use it.
+	* MArray.cc (operator+=, operator-=):
+	Operate out-of-place when this is shared copy.
+	(operator*=, operator/=): New operator overloads.
+	* MArray2.cc: Ditto.
+	* MArrayN.cc: Ditto.
+	* CNDArray.cc (operator *= (ComplexNDArray&, double),
+	operator /= (ComplexNDArray&, double)): New operators.
+	* CNDArray.h: Declare them.
+	* fCNDArray.cc (operator *= (FloatComplexNDArray&, double),
+	operator /= (FloatComplexNDArray&, double)): New operators.
+	* fCNDArray.h: Declare them.
+
 2009-08-17  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (LINK_DEPS): List LIBS last.
 
 2009-08-16  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dMatrix.cc, fMatrix.cc, CMatrix.cc, fCMatrix.cc: Add more tests.
 	* CMatrix.cc (xgemm): Fix vector * matrix case.
diff --git a/liboctave/MArray-decl.h b/liboctave/MArray-decl.h
--- a/liboctave/MArray-decl.h
+++ b/liboctave/MArray-decl.h
@@ -28,38 +28,56 @@ along with Octave; see the file COPYING.
   PFX API A_T<E_T>& \
   operator OP LTGT (A_T<E_T>&, const RHS_T&)
 
 // All the OP= operators that we care about.
 #define MARRAY_OP_ASSIGN_DECLS(A_T, E_T, PFX, API, LTGT, RHS_T) \
   MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
   MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T);
 
+#define MARRAY_OP_ASSIGN_DECLS1(A_T, E_T, PFX, API, LTGT, RHS_T) \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T); \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, *=, PFX, API, LTGT, RHS_T); \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, /=, PFX, API, LTGT, RHS_T);
+
 // Generate forward declarations for OP= operators.
 #define MARRAY_OP_ASSIGN_FWD_DECLS(A_T, RHS_T, API) \
   MARRAY_OP_ASSIGN_DECLS (A_T, T, template <typename T>, API, , RHS_T)
 
+#define MARRAY_OP_ASSIGN_FWD_DECLS1(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS1 (A_T, T, template <typename T>, API, , RHS_T)
+
 // Generate friend declarations for the OP= operators.
 #define MARRAY_OP_ASSIGN_FRIENDS(A_T, RHS_T, API) \
   MARRAY_OP_ASSIGN_DECLS (A_T, T, friend, API, <>, RHS_T)
 
+#define MARRAY_OP_ASSIGN_FRIENDS1(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS1 (A_T, T, friend, API, <>, RHS_T)
+
 // A function that can be used to forward OP= operations from derived
 // classes back to us.
 #define MARRAY_OP_ASSIGN_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
   inline R \
   F (X_T& x, const Y_T& y) \
   { \
     return R (F (C_X (x), C_Y (y))); \
   }
 
 // All the OP= operators that we care about forwarding.
 #define MARRAY_OP_ASSIGN_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T)
 
+#define MARRAY_OP_ASSIGN_FWD_DEFS1(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator *=, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator /=, T, C_X, X_T, C_Y, Y_T)
+
 // A macro that can be used to declare and instantiate unary operators.
 #define MARRAY_UNOP(A_T, E_T, F, PFX, API, LTGT) \
   PFX API A_T<E_T> \
   F LTGT (const A_T<E_T>&)
 
 // All the unary operators that we care about.
 #define MARRAY_UNOP_DECLS(A_T, E_T, PFX, API, LTGT) \
   MARRAY_UNOP (A_T, E_T, operator +, PFX, API, LTGT); \
@@ -177,32 +195,32 @@ along with Octave; see the file COPYING.
   MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
   MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T)
 
 // Forward declarations for the MArray operators.
 #define MARRAY_OPS_FORWARD_DECLS(A_T, API) \
   template <class T> \
   class A_T; \
  \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FWD_DECLS1 (A_T, T, API) \
   MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FWD_DECLS (A_T, API) \
   MARRAY_BINOP_FWD_DECLS (A_T, API)
 
 #define MDIAGARRAY2_OPS_FORWARD_DECLS(A_T, API) \
   template <class T> \
   class A_T; \
  \
   MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FWD_DECLS (A_T, API) \
   MDIAGARRAY2_BINOP_FWD_DECLS (A_T, API)
 
 // Friend declarations for the MArray operators.
 #define MARRAY_OPS_FRIEND_DECLS(A_T, API) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS1 (A_T, T, API) \
   MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FRIENDS (A_T, API) \
   MARRAY_BINOP_FRIENDS (A_T, API)
 
 #define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T, API) \
   MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FRIENDS (A_T, API) \
   MDIAGARRAY2_BINOP_FRIENDS (A_T, API)
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -72,16 +72,19 @@ along with Octave; see the file COPYING.
 	a_tmp[i] OP b_tmp[i]; \
     } \
   while (0)
 
 // Instantiate the OP= operators.
 #define MARRAY_OP_ASSIGN_DEFS(A_T, E_T, RHS_T, API) \
   MARRAY_OP_ASSIGN_DECLS (A_T, E_T, template, API, , RHS_T)
 
+#define MARRAY_OP_ASSIGN_DEFS1(A_T, E_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS1 (A_T, E_T, template, API, , RHS_T)
+
 // Instantiate the unary operators.
 #define MARRAY_UNOP_DEFS(A_T, E_T, API) \
   MARRAY_UNOP_DECLS (A_T, E_T, template, API, )
 
 // Instantiate the binary operators.
 #define MARRAY_BINOP_DEFS(A_T, E_T, API) \
   MARRAY_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
   MARRAY_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
@@ -91,31 +94,31 @@ along with Octave; see the file COPYING.
   MDIAGARRAY2_DAS_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
   MDIAGARRAY2_SDA_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
   MDIAGARRAY2_DADA_BINOP_DECLS (A_T, E_T, template, API, )
 
 // The following macros are for external use.
 
 // Instantiate all the MArray friends for MArray element type T.
 #define INSTANTIATE_MARRAY_FRIENDS(T, API) \
-  MARRAY_OP_ASSIGN_DEFS (MArray, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS1 (MArray, T, T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArray, T, MArray<T>, API) \
   MARRAY_UNOP_DEFS (MArray, T, API) \
   MARRAY_BINOP_DEFS (MArray, T, API)
 
 // Instantiate all the MArray2 friends for MArray2 element type T.
 #define INSTANTIATE_MARRAY2_FRIENDS(T, API) \
-  MARRAY_OP_ASSIGN_DEFS (MArray2, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS1 (MArray2, T, T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArray2, T, MArray2<T>, API) \
   MARRAY_UNOP_DEFS (MArray2, T, API) \
   MARRAY_BINOP_DEFS (MArray2, T, API)
 
 // Instantiate all the MArrayN friends for MArrayN element type T.
 #define INSTANTIATE_MARRAYN_FRIENDS(T, API) \
-  MARRAY_OP_ASSIGN_DEFS (MArrayN, T, T, API) \
+  MARRAY_OP_ASSIGN_DEFS1 (MArrayN, T, T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArrayN, T, MArrayN<T>, API) \
   MARRAY_UNOP_DEFS (MArrayN, T, API) \
   MARRAY_BINOP_DEFS (MArrayN, T, API)
 
 // Instantiate all the MDiagArray2 friends for MDiagArray2 element type T.
 #define INSTANTIATE_MDIAGARRAY2_FRIENDS(T, API) \
   MARRAY_OP_ASSIGN_DEFS (MDiagArray2, T, MDiagArray2<T>, API) \
   MARRAY_UNOP_DEFS (MDiagArray2, T, API) \
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -111,50 +111,78 @@ MArray<T>::idx_add (const idx_vector& id
 }
 
 // Element by element MArray by scalar ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a + s;
   DO_VS_OP2 (T, a, +=, s)
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator -= (MArray<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a - s;
   DO_VS_OP2 (T, a, -=, s)
   return a;
 }
 
+template <class T>
+MArray<T>&
+operator *= (MArray<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a * s;
+  DO_VS_OP2 (T, a, *=, s)
+  return a;
+}
+
+template <class T>
+MArray<T>&
+operator /= (MArray<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a / s;
+  DO_VS_OP2 (T, a, /=, s)
+  return a;
+}
+
 // Element by element MArray by MArray ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const MArray<T>& b)
 {
+  if (a.is_shared ())
+    return a = a + b;
   octave_idx_type l = a.length ();
   if (l > 0)
     {
       octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator +=", l, bl);
       else
 	DO_VV_OP2 (T, a, +=, b);
     }
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator -= (MArray<T>& a, const MArray<T>& b)
 {
+  if (a.is_shared ())
+    return a = a - b;
   octave_idx_type l = a.length ();
   if (l > 0)
     {
       octave_idx_type bl = b.length ();
       if (l != bl)
 	gripe_nonconformant ("operator -=", l, bl);
       else
 	DO_VV_OP2 (T, a, -=, b);
diff --git a/liboctave/MArray2.cc b/liboctave/MArray2.cc
--- a/liboctave/MArray2.cc
+++ b/liboctave/MArray2.cc
@@ -34,34 +34,60 @@ along with Octave; see the file COPYING.
 // Two dimensional array with math ops.
 
 // Element by element MArray2 by scalar ops.
 
 template <class T>
 MArray2<T>&
 operator += (MArray2<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a + s;
   DO_VS_OP2 (T, a, +=, s)
   return a;
 }
 
 template <class T>
 MArray2<T>&
 operator -= (MArray2<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a - s;
   DO_VS_OP2 (T, a, -=, s)
   return a;
 }
 
+template <class T>
+MArray2<T>&
+operator *= (MArray2<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a * s;
+  DO_VS_OP2 (T, a, *=, s)
+  return a;
+}
+
+template <class T>
+MArray2<T>&
+operator /= (MArray2<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a / s;
+  DO_VS_OP2 (T, a, /=, s)
+  return a;
+}
+
 // Element by element MArray2 by MArray2 ops.
 
 template <class T>
 MArray2<T>&
 operator += (MArray2<T>& a, const MArray2<T>& b)
 {
+  if (a.is_shared ())
+    return a = a + b;
   octave_idx_type r = a.rows ();
   octave_idx_type c = a.cols ();
   octave_idx_type br = b.rows ();
   octave_idx_type bc = b.cols ();
   if (r != br || c != bc)
     gripe_nonconformant ("operator +=", r, c, br, bc);
   else
     {
@@ -73,16 +99,18 @@ operator += (MArray2<T>& a, const MArray
     }
   return a;
 }
 
 template <class T>
 MArray2<T>&
 operator -= (MArray2<T>& a, const MArray2<T>& b)
 {
+  if (a.is_shared ())
+    return a = a - b;
   octave_idx_type r = a.rows ();
   octave_idx_type c = a.cols ();
   octave_idx_type br = b.rows ();
   octave_idx_type bc = b.cols ();
   if (r != br || c != bc)
     gripe_nonconformant ("operator -=", r, c, br, bc);
   else
     {
diff --git a/liboctave/MArrayN.cc b/liboctave/MArrayN.cc
--- a/liboctave/MArrayN.cc
+++ b/liboctave/MArrayN.cc
@@ -33,34 +33,60 @@ along with Octave; see the file COPYING.
 // N-dimensional array with math ops.
 
 // Element by element MArrayN by scalar ops.
 
 template <class T>
 MArrayN<T>&
 operator += (MArrayN<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a + s;
   DO_VS_OP2 (T, a, +=, s)
   return a;
 }
 
 template <class T>
 MArrayN<T>&
 operator -= (MArrayN<T>& a, const T& s)
 {
+  if (a.is_shared ())
+    return a = a - s;
   DO_VS_OP2 (T, a, -=, s)
   return a;
 }
 
+template <class T>
+MArrayN<T>&
+operator *= (MArrayN<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a * s;
+  DO_VS_OP2 (T, a, *=, s)
+  return a;
+}
+
+template <class T>
+MArrayN<T>&
+operator /= (MArrayN<T>& a, const T& s)
+{
+  if (a.is_shared ())
+    return a = a / s;
+  DO_VS_OP2 (T, a, /=, s)
+  return a;
+}
+
 // Element by element MArrayN by MArrayN ops.
 
 template <class T>
 MArrayN<T>&
 operator += (MArrayN<T>& a, const MArrayN<T>& b)
 {
+  if (a.is_shared ())
+    return a = a + b;
   octave_idx_type l = a.length ();
 
   if (l > 0)
     {
       dim_vector a_dims = a.dims ();
       dim_vector b_dims = b.dims ();
 
       if (a_dims != b_dims)
@@ -71,16 +97,18 @@ operator += (MArrayN<T>& a, const MArray
 
   return a;
 }
 
 template <class T>
 MArrayN<T>&
 operator -= (MArrayN<T>& a, const MArrayN<T>& b)
 {
+  if (a.is_shared ())
+    return a = a - b;
   octave_idx_type l = a.length ();
 
   if (l > 0)
     {
       dim_vector a_dims = a.dims ();
       dim_vector b_dims = b.dims ();
 
       if (a_dims != b_dims)
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "Array-util.h"
 #include "f77-fcn.h"
 #include "fCNDArray.h"
 #include "functor.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
+#include "MArray-defs.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
 FloatComplexNDArray::FloatComplexNDArray (const charNDArray& a)
   : MArrayN<FloatComplex> (a.dims ())
 {
@@ -1073,13 +1074,29 @@ NDS_CMP_OPS(FloatComplexNDArray, std::re
 NDS_BOOL_OPS(FloatComplexNDArray, FloatComplex, static_cast<float> (0.0))
 
 SND_CMP_OPS(FloatComplex, std::real, FloatComplexNDArray, std::real)
 SND_BOOL_OPS(FloatComplex, FloatComplexNDArray, static_cast<float> (0.0))
 
 NDND_CMP_OPS(FloatComplexNDArray, std::real, FloatComplexNDArray, std::real)
 NDND_BOOL_OPS(FloatComplexNDArray, FloatComplexNDArray, static_cast<float> (0.0))
 
+FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s)
+{
+  if (a.is_shared ())
+    return a = a * s;
+  DO_VS_OP2 (FloatComplex, a, *=, s)
+  return a;
+}
+
+FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s)
+{
+  if (a.is_shared ())
+    return a = a / s;
+  DO_VS_OP2 (FloatComplex, a, /=, s)
+  return a;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -168,15 +168,18 @@ NDS_BOOL_OP_DECLS (FloatComplexNDArray, 
 SND_CMP_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, FloatComplexNDArray, FloatComplex)
 
+extern OCTAVE_API FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s);
+extern OCTAVE_API FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,25 @@
+2009-08-17  Jaroslav Hajek  <highegg@gmail.com>
+
+	* OPERATORS/op-m-m.cc: Define and install += and -= operators.
+	* OPERATORS/op-fm-fm.cc: Ditto.
+	* OPERATORS/op-cm-cm.cc: Ditto.
+	* OPERATORS/op-fcm-fcm.cc: Ditto.
+	* OPERATORS/op-m-s.cc: Define and install +=,-=,*=,/= operators.
+	* OPERATORS/op-fm-fs.cc: Ditto.
+	* OPERATORS/op-cm-cs.cc: Ditto.
+	* OPERATORS/op-fcm-fcs.cc: Ditto.
+	* OPERATORS/op-cm-s.cc: Define and install *=,/= operators.
+	* OPERATORS/op-fcm-fs.cc: Ditto.
+	* ops.h (DEFNDASSIGNOP_OP): New macro.
+	* ov.cc (octave_value::assign (assign_op, const octave_value&)):
+	Try looking up specialized handlers if the value is not shared.
+	* ov-base-mat.h (octave_base_matrix::matrix_ref): New method.
+
 2009-08-17  Jaroslav Hajek  <highegg@gmail.com>
 
 	* oct-obj.h (octave_value_list::octave_value_list (octave_idx_type)):
 	Allow this constructor.
 
 2009-08-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/find.cc (Ffind): Reuse cached index vector when
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -158,16 +158,19 @@ DEFNDBINOP_FN (el_and, complex_matrix, c
 DEFNDBINOP_FN (el_or,  complex_matrix, complex_matrix, complex_array, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (cm_cm, complex_matrix, complex_matrix, complex_array, complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, complex_matrix, complex_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, complex_matrix, delete_elements)
 
+DEFNDASSIGNOP_OP (assign_add, complex_matrix, complex_matrix, complex_array, +=)
+DEFNDASSIGNOP_OP (assign_sub, complex_matrix, complex_matrix, complex_array, -=)
+
 CONVDECL (complex_matrix_to_float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
 
   return new octave_float_complex_matrix (FloatComplexNDArray (v.complex_array_value ()));
 }
 
 void
@@ -208,16 +211,19 @@ install_cm_cm_ops (void)
   INSTALL_CATOP (octave_complex_matrix, octave_complex_matrix, cm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_complex_matrix, assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_sq_str, null_assign);
 
+  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_matrix, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix, assign_sub);
+
   INSTALL_CONVOP (octave_complex_matrix, octave_float_complex_matrix, 
 		  complex_matrix_to_float_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/OPERATORS/op-cm-cs.cc b/src/OPERATORS/op-cm-cs.cc
--- a/src/OPERATORS/op-cm-cs.cc
+++ b/src/OPERATORS/op-cm-cs.cc
@@ -102,16 +102,21 @@ DEFBINOP (el_ldiv, complex_matrix, compl
 DEFNDBINOP_FN (el_and, complex_matrix, complex, complex_array, complex, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, complex, complex_array, complex, mx_el_or)
 
 DEFNDCATOP_FN (cm_cs, complex_matrix, complex, complex_array, complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, complex, complex, assign)
 DEFNDASSIGNOP_FN (sgl_assign, float_complex_matrix, complex, float_complex, assign)
 
+DEFNDASSIGNOP_OP (assign_add, complex_matrix, complex_scalar, complex, +=)
+DEFNDASSIGNOP_OP (assign_sub, complex_matrix, complex_scalar, complex, -=)
+DEFNDASSIGNOP_OP (assign_mul, complex_matrix, complex_scalar, complex, *=)
+DEFNDASSIGNOP_OP (assign_div, complex_matrix, complex_scalar, complex, /=)
+
 void
 install_cm_cs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex_matrix, octave_complex, add);
   INSTALL_BINOP (op_sub, octave_complex_matrix, octave_complex, sub);
   INSTALL_BINOP (op_mul, octave_complex_matrix, octave_complex, mul);
   INSTALL_BINOP (op_div, octave_complex_matrix, octave_complex, div);
   INSTALL_BINOP (op_pow, octave_complex_matrix, octave_complex, pow);
@@ -128,15 +133,20 @@ install_cm_cs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_complex, cm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_complex, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_complex, sgl_assign);
+
+  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_scalar, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_scalar, assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_complex_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_complex_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-cm-s.cc b/src/OPERATORS/op-cm-s.cc
--- a/src/OPERATORS/op-cm-s.cc
+++ b/src/OPERATORS/op-cm-s.cc
@@ -105,16 +105,19 @@ DEFBINOP (el_ldiv, complex_matrix, scala
 
 DEFNDBINOP_FN (el_and, complex_matrix, scalar, complex_array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, scalar, complex_array, scalar, mx_el_or)
 
 DEFNDCATOP_FN (cm_s, complex_matrix, scalar, complex_array, array, concat)
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, scalar, complex_array, assign)
 
+DEFNDASSIGNOP_OP (assign_mul, complex_matrix, scalar, scalar, *=)
+DEFNDASSIGNOP_OP (assign_div, complex_matrix, scalar, scalar, /=)
+
 void
 install_cm_s_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex_matrix, octave_scalar, add);
   INSTALL_BINOP (op_sub, octave_complex_matrix, octave_scalar, sub);
   INSTALL_BINOP (op_mul, octave_complex_matrix, octave_scalar, mul);
   INSTALL_BINOP (op_div, octave_complex_matrix, octave_scalar, div);
   INSTALL_BINOP (op_pow, octave_complex_matrix, octave_scalar, pow);
@@ -130,15 +133,18 @@ install_cm_s_ops (void)
   INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_scalar, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_scalar, cm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_scalar, assign);
+
+  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -184,16 +184,21 @@ DEFNDCATOP_FN (fcm_cm, float_complex_mat
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex_matrix, 
 		  float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, float_complex_matrix, complex_matrix, 
 		  float_complex_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, float_complex_matrix, delete_elements)
 
+DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, 
+                  float_complex_matrix, float_complex_array, +=)
+DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, 
+                  float_complex_matrix, float_complex_array, -=)
+
 CONVDECL (float_complex_matrix_to_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex_matrix&);
 
   return new octave_complex_matrix (ComplexNDArray (v.float_complex_array_value ()));
 }
 
 void
@@ -267,16 +272,21 @@ install_fcm_fcm_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
                     octave_null_sq_str, null_assign);
 
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_complex_matrix,
+                    octave_float_complex_matrix, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
+                    octave_float_complex_matrix, assign_sub);
+
   INSTALL_CONVOP (octave_float_complex_matrix, octave_complex_matrix, 
 		  float_complex_matrix_to_complex_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -129,16 +129,25 @@ DEFNDCATOP_FN (cm_fcs, complex_matrix, f
 DEFNDCATOP_FN (fcm_cs, float_complex_matrix, complex, 
 	       float_complex_array, float_complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex, 
 		  float_complex, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex, 
 		  complex, assign)
 
+DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, float_complex_scalar,
+                  float_complex, +=)
+DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, float_complex_scalar,
+                  float_complex, -=)
+DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_complex_scalar,
+                  float_complex, *=)
+DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_complex_scalar,
+                  float_complex, /=)
+
 void
 install_fcm_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, 
 		 octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, 
 		 octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, 
@@ -171,15 +180,24 @@ install_fcm_fcs_ops (void)
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_complex, fcm_fcs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_complex, cm_fcs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_complex, fcm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_complex, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
 		    octave_float_complex, dbl_assign);
+
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_complex_matrix,
+                    octave_float_complex_scalar, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
+                    octave_float_complex_scalar, assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
+                    octave_float_complex_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
+                    octave_float_complex_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -125,16 +125,21 @@ DEFNDCATOP_FN (cm_fs, complex_matrix, fl
 	       float_array, concat)
 
 DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array, 
 	       float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar, float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array, assign)
 
+DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_scalar,
+                  float_scalar, *=)
+DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_scalar,
+                  float_scalar, /=)
+
 void
 install_fcm_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, octave_float_scalar, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, octave_float_scalar, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, octave_float_scalar, pow);
@@ -155,15 +160,20 @@ install_fcm_fs_ops (void)
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_scalar, fcm_fs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_scalar, cm_fs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_scalar, fcm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
 		    octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
 		    octave_float_scalar, dbl_assign);
+
+  INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
+                    octave_float_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
+                    octave_float_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -160,16 +160,19 @@ DEFNDCATOP_FN (m_fm, matrix, float_matri
 DEFNDCATOP_FN (fm_m, float_matrix, matrix, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
 
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_matrix, array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, float_matrix, delete_elements)
 
+DEFNDASSIGNOP_OP (assign_add, float_matrix, float_matrix, float_array, +=)
+DEFNDASSIGNOP_OP (assign_sub, float_matrix, float_matrix, float_array, -=)
+
 CONVDECL (float_matrix_to_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
   return new octave_matrix (v.array_value ());
 }
 
 void
@@ -219,16 +222,19 @@ install_fm_fm_ops (void)
 		    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, 
 		    octave_float_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_sq_str, null_assign);
 
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_matrix, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix, assign_sub);
+
   INSTALL_CONVOP (octave_float_matrix, octave_matrix, float_matrix_to_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -117,16 +117,21 @@ DEFNDCATOP_FN (fm_fs, float_matrix, floa
 
 DEFNDCATOP_FN (m_fs, matrix, float_scalar, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_s, float_matrix, scalar, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_scalar, float_scalar, assign)
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_scalar, scalar, assign)
 
+DEFNDASSIGNOP_OP (assign_add, float_matrix, float_scalar, float_scalar, +=)
+DEFNDASSIGNOP_OP (assign_sub, float_matrix, float_scalar, float_scalar, -=)
+DEFNDASSIGNOP_OP (assign_mul, float_matrix, float_scalar, float_scalar, *=)
+DEFNDASSIGNOP_OP (assign_div, float_matrix, float_scalar, float_scalar, /=)
+
 void
 install_fm_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_scalar, mul);
   INSTALL_BINOP (op_div, octave_float_matrix, octave_float_scalar, div);
   INSTALL_BINOP (op_pow, octave_float_matrix, octave_float_scalar, pow);
@@ -145,15 +150,20 @@ install_fm_fs_ops (void)
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_scalar, fm_fs);
   INSTALL_CATOP (octave_matrix, octave_float_scalar, m_fs);
   INSTALL_CATOP (octave_float_matrix, octave_scalar, fm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_float_scalar, dbl_assign);
+
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_scalar, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_scalar, assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_float_matrix, octave_float_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_float_matrix, octave_float_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -579,16 +579,22 @@ along with Octave; see the file COPYING.
   DEFNDBINOP_FN (PFX ## _el_and, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_and) \
   DEFNDBINOP_FN (PFX ## _el_or, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_or) \
   DEFNDBINOP_FN (PFX ## _el_not_and, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_not_and) \
   DEFNDBINOP_FN (PFX ## _el_not_or,  TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_not_or)
 
 #define OCTAVE_MS_INT_ASSIGN_OPS(PFX, TM, TS, TE) \
   DEFNDASSIGNOP_FN (PFX ## _assign, TM ## matrix, TS ## scalar, TM ## scalar, assign)
 
+#define OCTAVE_MS_INT_ASSIGNEQ_OPS(PFX, TM) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_add, TM ## matrix, TM ## scalar, TM ## scalar, +=) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_sub, TM ## matrix, TM ## scalar, TM ## scalar, -=) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_mul, TM ## matrix, TM ## scalar, TM ## scalar, *=) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_div, TM ## matrix, TM ## scalar, TM ## scalar, /=)
+
 #define OCTAVE_MS_POW_OPS(T1, T2) \
 octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2  b) \
 { \
   T1 ## NDArray result (a.dims ()); \
   for (int i = 0; i < a.length (); i++) \
     { \
       OCTAVE_QUIT; \
       result (i) = pow (a(i), b);		\
@@ -654,16 +660,17 @@ octave_value elem_xpow (FloatNDArray a, 
   OCTAVE_MS_INT_CMP_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_MS_INT_CMP_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_MS_INT_BOOL_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_MS_INT_BOOL_OPS (mx, TYPE ## _, ) \
   OCTAVE_MS_INT_BOOL_OPS (mxs, , TYPE ## _) \
   OCTAVE_MS_INT_BOOL_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_MS_INT_BOOL_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_MS_INT_ASSIGN_OPS (ms, TYPE ## _, TYPE ## _, TYPE ## _) \
+  OCTAVE_MS_INT_ASSIGNEQ_OPS (mse, TYPE ## _) \
   OCTAVE_MS_INT_ASSIGN_OPS (mx, TYPE ## _, , ) \
   OCTAVE_MS_INT_ASSIGN_OPS (mfx, TYPE ## _, float_, float_)
 
 #define OCTAVE_M_INT_UNOPS(TYPE) \
   /* matrix unary ops. */ \
  \
   DEFNDUNOP_OP (m_not, TYPE ## _matrix, TYPE ## _array, !) \
   DEFNDUNOP_OP (m_uplus, TYPE ## _matrix, TYPE ## _array, /* no-op */) \
@@ -742,16 +749,20 @@ octave_value elem_xpow (FloatNDArray a, 
   DEFNDBINOP_FN (PFX ## _el_not_and, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_not_and) \
   DEFNDBINOP_FN (PFX ## _el_not_or,  T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_not_or) \
   DEFNDBINOP_FN (PFX ## _el_and_not, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_and_not) \
   DEFNDBINOP_FN (PFX ## _el_or_not,  T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_or_not)
 
 #define OCTAVE_MM_INT_ASSIGN_OPS(PFX, TLHS, TRHS, TE) \
   DEFNDASSIGNOP_FN (PFX ## _assign, TLHS ## matrix, TRHS ## matrix, TLHS ## array, assign)
 
+#define OCTAVE_MM_INT_ASSIGNEQ_OPS(PFX, TM) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_add, TM ## matrix, TM ## matrix, TM ## array, +=) \
+  DEFNDASSIGNOP_OP (PFX ## _assign_sub, TM ## matrix, TM ## matrix, TM ## array, -=)
+
 #define OCTAVE_MM_POW_OPS(T1, T2) \
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
@@ -866,16 +877,17 @@ octave_value elem_xpow (FloatNDArray a, 
   OCTAVE_MM_INT_CMP_OPS (mmfx, TYPE ## _, float_) \
   OCTAVE_MM_INT_CMP_OPS (mxm, , TYPE ## _) \
   OCTAVE_MM_INT_BOOL_OPS (mm, TYPE ## _, TYPE ## _) \
   OCTAVE_MM_INT_BOOL_OPS (mmx, TYPE ## _, ) \
   OCTAVE_MM_INT_BOOL_OPS (mxm, , TYPE ## _) \
   OCTAVE_MM_INT_BOOL_OPS (mmfx, TYPE ## _, float_) \
   OCTAVE_MM_INT_BOOL_OPS (mfxm, float_, TYPE ## _) \
   OCTAVE_MM_INT_ASSIGN_OPS (mm, TYPE ## _, TYPE ## _, TYPE ## _) \
+  OCTAVE_MM_INT_ASSIGNEQ_OPS (mme, TYPE ## _) \
   OCTAVE_MM_INT_ASSIGN_OPS (mmx, TYPE ## _, , ) \
   OCTAVE_MM_INT_ASSIGN_OPS (mmfx, TYPE ## _, float_, float_) \
   OCTAVE_MM_CONV(TYPE ## _, complex_) \
   OCTAVE_MM_CONV(TYPE ## _, float_complex_)
 
 #define OCTAVE_RE_INT_ASSIGN_OPS(TYPE) \
   DEFNDASSIGNOP_FN (TYPE ## ms_assign, matrix, TYPE ## _scalar, array, assign) \
   DEFNDASSIGNOP_FN (TYPE ## mm_assign, matrix, TYPE ## _matrix, array, assign)
@@ -1040,16 +1052,22 @@ octave_value elem_xpow (FloatNDArray a, 
   INSTALL_BINOP (op_el_and, octave_ ## T1 ## matrix, octave_ ## T2 ## scalar, PFX ## _el_and); \
   INSTALL_BINOP (op_el_or, octave_ ## T1 ## matrix, octave_ ## T2 ## scalar, PFX ## _el_or); \
   INSTALL_BINOP (op_el_not_and, octave_ ## T1 ## matrix, octave_ ## T2 ## scalar, PFX ## _el_not_and); \
   INSTALL_BINOP (op_el_not_or, octave_ ## T1 ## matrix, octave_ ## T2 ## scalar, PFX ## _el_not_or);
 
 #define OCTAVE_INSTALL_MS_INT_ASSIGN_OPS(PFX, TLHS, TRHS) \
   INSTALL_ASSIGNOP (op_asn_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign)
 
+#define OCTAVE_INSTALL_MS_INT_ASSIGNEQ_OPS(PFX, TLHS, TRHS) \
+  INSTALL_ASSIGNOP (op_add_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_add) \
+  INSTALL_ASSIGNOP (op_sub_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_sub) \
+  INSTALL_ASSIGNOP (op_mul_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_mul) \
+  INSTALL_ASSIGNOP (op_div_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## scalar, PFX ## _assign_div)
+
 #define OCTAVE_INSTALL_MS_INT_OPS(TYPE) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (msx, TYPE ## _, ) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (mxs, , TYPE ## _)	   \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (msfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MS_INT_ARITH_OPS (mfxs, float_, TYPE ## _)	   \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mx, TYPE ## _, ) \
@@ -1057,16 +1075,17 @@ octave_value elem_xpow (FloatNDArray a, 
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MS_INT_CMP_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (ms, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mx, TYPE ## _, ) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mxs, , TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MS_INT_BOOL_OPS (mfxs, float_, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (ms, TYPE ## _, TYPE ## _) \
+  OCTAVE_INSTALL_MS_INT_ASSIGNEQ_OPS (mse, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mx, TYPE ## _, ) \
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mfx, TYPE ## _, float_) \
   INSTALL_ASSIGNCONV (octave_ ## TYPE ## _matrix, octave_complex_scalar, octave_complex_matrix) \
   INSTALL_ASSIGNCONV (octave_ ## TYPE ## _matrix, octave_float_complex_scalar, octave_float_complex_matrix)
 
 #define OCTAVE_INSTALL_M_INT_UNOPS(TYPE) \
   INSTALL_UNOP (op_not, octave_ ## TYPE ## _matrix, m_not); \
   INSTALL_UNOP (op_uplus, octave_ ## TYPE ## _matrix, m_uplus); \
@@ -1103,16 +1122,20 @@ octave_value elem_xpow (FloatNDArray a, 
   INSTALL_BINOP (op_el_not_and, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_not_and); \
   INSTALL_BINOP (op_el_not_or, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_not_or); \
   INSTALL_BINOP (op_el_and_not, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_and_not); \
   INSTALL_BINOP (op_el_or_not, octave_ ## T1 ## matrix, octave_ ## T2 ## matrix, PFX ## _el_or_not);
 
 #define OCTAVE_INSTALL_MM_INT_ASSIGN_OPS(PFX, TLHS, TRHS) \
   INSTALL_ASSIGNOP (op_asn_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign)
 
+#define OCTAVE_INSTALL_MM_INT_ASSIGNEQ_OPS(PFX, TLHS, TRHS) \
+  INSTALL_ASSIGNOP (op_add_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign_add) \
+  INSTALL_ASSIGNOP (op_sub_eq, octave_ ## TLHS ## matrix, octave_ ## TRHS ## matrix, PFX ## _assign_sub)
+
 #define OCTAVE_INSTALL_MM_INT_OPS(TYPE) \
   OCTAVE_INSTALL_M_INT_UNOPS (TYPE) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mm, TYPE ##_, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mmx, TYPE ##_, ) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mxm, , TYPE ##_)	   \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mmfx, TYPE ##_, float_) \
   OCTAVE_INSTALL_MM_INT_ARITH_OPS (mfxm, float_, TYPE ##_)	   \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mm, TYPE ## _, TYPE ## _) \
@@ -1121,16 +1144,17 @@ octave_value elem_xpow (FloatNDArray a, 
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mmfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MM_INT_CMP_OPS (mfxm, float_, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mm, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mmx, TYPE ## _, ) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mxm, , TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mmfx, TYPE ## _, float_) \
   OCTAVE_INSTALL_MM_INT_BOOL_OPS (mfxm, float_, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_ASSIGN_OPS (mm, TYPE ## _, TYPE ## _) \
+  OCTAVE_INSTALL_MM_INT_ASSIGNEQ_OPS (mme, TYPE ## _, TYPE ## _) \
   OCTAVE_INSTALL_MM_INT_ASSIGN_OPS (mmx, TYPE ## _, ) \
   OCTAVE_INSTALL_MM_INT_ASSIGN_OPS (mmfx, TYPE ## _, float_) \
   INSTALL_WIDENOP (octave_ ## TYPE ## _matrix, octave_complex_matrix, TYPE ## _m_complex_m_conv) \
   INSTALL_WIDENOP (octave_ ## TYPE ## _matrix, octave_float_complex_matrix, TYPE ## _m_float_complex_m_conv) \
   INSTALL_ASSIGNCONV (octave_ ## TYPE ## _matrix, octave_complex_matrix, octave_complex_matrix) \
   INSTALL_ASSIGNCONV (octave_ ## TYPE ## _matrix, octave_float_complex_matrix, octave_float_complex_matrix)
 
 #define OCTAVE_INSTALL_RE_INT_ASSIGN_OPS(TYPE) \
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -133,16 +133,19 @@ DEFNDBINOP_FN (el_or_not,  matrix, matri
 
 DEFNDCATOP_FN (m_m, matrix, matrix, array, array, concat)
 
 DEFNDASSIGNOP_FN (assign, matrix, matrix, array, assign)
 DEFNDASSIGNOP_FN (sgl_assign, float_matrix, matrix, float_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, matrix, delete_elements)
 
+DEFNDASSIGNOP_OP (assign_add, matrix, matrix, array, +=)
+DEFNDASSIGNOP_OP (assign_sub, matrix, matrix, array, -=)
+
 CONVDECL (matrix_to_float_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_float_matrix (FloatNDArray (v.array_value ()));
 }
 
 void
@@ -188,16 +191,19 @@ install_m_m_ops (void)
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_matrix, sgl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_sq_str, null_assign);
 
+  INSTALL_ASSIGNOP (op_add_eq, octave_matrix, octave_matrix, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_matrix, octave_matrix, assign_sub);
+
   INSTALL_CONVOP (octave_matrix, octave_float_matrix, matrix_to_float_matrix);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/OPERATORS/op-m-s.cc b/src/OPERATORS/op-m-s.cc
--- a/src/OPERATORS/op-m-s.cc
+++ b/src/OPERATORS/op-m-s.cc
@@ -103,16 +103,21 @@ DEFBINOP (el_ldiv, matrix, scalar)
 DEFNDBINOP_FN (el_and, matrix, scalar, array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, matrix, scalar, array, scalar, mx_el_or)
 
 DEFNDCATOP_FN (m_s, matrix, scalar, array, array, concat)
 
 DEFNDASSIGNOP_FN (assign, matrix, scalar, scalar, assign)
 DEFNDASSIGNOP_FN (sgl_assign, float_matrix, scalar, float_scalar, assign)
 
+DEFNDASSIGNOP_OP (assign_add, matrix, scalar, scalar, +=)
+DEFNDASSIGNOP_OP (assign_sub, matrix, scalar, scalar, -=)
+DEFNDASSIGNOP_OP (assign_mul, matrix, scalar, scalar, *=)
+DEFNDASSIGNOP_OP (assign_div, matrix, scalar, scalar, /=)
+
 void
 install_m_s_ops (void)
 {
   INSTALL_BINOP (op_add, octave_matrix, octave_scalar, add);
   INSTALL_BINOP (op_sub, octave_matrix, octave_scalar, sub);
   INSTALL_BINOP (op_mul, octave_matrix, octave_scalar, mul);
   INSTALL_BINOP (op_div, octave_matrix, octave_scalar, div);
   INSTALL_BINOP (op_pow, octave_matrix, octave_scalar, pow);
@@ -135,15 +140,20 @@ install_m_s_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_matrix, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_matrix, octave_scalar, m_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_scalar, sgl_assign);
+
+  INSTALL_ASSIGNOP (op_add_eq, octave_matrix, octave_scalar, assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_matrix, octave_scalar, assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_matrix, octave_scalar, assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_matrix, octave_scalar, assign_div);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -196,16 +196,28 @@ extern void install_ops (void);
   ASSIGNOPDECL (name) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
  \
     v1.f (idx, v2.CONCAT2(e, _value) ()); \
     return octave_value (); \
   }
 
+// FIXME: the following currently doesn't handle index.
+#define DEFNDASSIGNOP_OP(name, t1, t2, f, op) \
+  ASSIGNOPDECL (name) \
+  { \
+    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+ \
+    assert (idx.empty ()); \
+    v1.matrix_ref () op v2.CONCAT2(f, _value) (); \
+ \
+    return octave_value (); \
+  }
+
 #define DEFASSIGNANYOP_FN(name, t1, f) \
   ASSIGNANYOPDECL (name) \
   { \
     CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
  \
     v1.f (idx, a2); \
     return octave_value (); \
   }
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -149,16 +149,22 @@ public:
   bool is_true (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
+  MT& matrix_ref (void)
+    {
+      clear_cached_info ();
+      return matrix;
+    }
+
 protected:
 
   MT matrix;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
     {
       delete idx_cache;
       idx_cache = idx ? new idx_vector (idx) : 0;
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1190,20 +1190,16 @@ octave_value::assign (assign_op op, cons
   octave_value retval;
 
   make_unique ();
 
   octave_value t_rhs = rhs;
 
   if (op != op_asn_eq)
     {
-      // FIXME -- only do the following stuff if we can't find
-      // a specific function to call to handle the op= operation for
-      // the types we have.
-
       octave_value t = subsref (type, idx);
 
       if (! error_state)
 	{
 	  binary_op binop = op_eq_to_binary_op (op);
 
 	  if (! error_state)
 	    t_rhs = do_binary_op (binop, t, rhs);
@@ -1231,29 +1227,51 @@ octave_value::assign (assign_op op, cons
 const octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
     // Regularize a null matrix if stored into a variable.
     operator = (rhs.storable_value ());
   else
     {
-      // FIXME -- only do the following stuff if we can't find
-      // a specific function to call to handle the op= operation for
-      // the types we have.
-
-      binary_op binop = op_eq_to_binary_op (op);
-
-      if (! error_state)
+      octave_value_typeinfo::assign_op_fcn f = 0;
+      
+      // Only attempt to operate in-place if this variable is unshared.
+      if (rep->count == 1)
+        {
+          int tthis = this->type_id ();
+          int trhs = rhs.type_id ();
+
+	  f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
+        }
+
+      if (f)
 	{
-	  octave_value t = do_binary_op (binop, *this, rhs);
-
-	  if (! error_state)
-	    operator = (t);
+	  try
+	    {
+	      f (*rep, octave_value_list (), *rhs.rep);
+	    }
+	  catch (octave_execution_exception)
+	    {
+	      gripe_library_execution_error ();
+	    }
 	}
+      else
+        {
+
+          binary_op binop = op_eq_to_binary_op (op);
+
+          if (! error_state)
+            {
+              octave_value t = do_binary_op (binop, *this, rhs);
+
+              if (! error_state)
+                operator = (t);
+            }
+        }
 
       if (error_state)
 	gripe_assign_failed_or_no_method (assign_op_as_string (op),
 					  type_name (), rhs.type_name ());
     }
 
   return *this;
 }
