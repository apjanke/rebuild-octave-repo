# HG changeset patch
# User jwe
# Date 1109657785 0
#      Tue Mar 01 06:16:25 2005 +0000
# Node ID 47e2ef7d0ad6fe60f6de78b45333a2b6eb2d7f9a
# Parent  912058eb83607118dfd5520d3d0c793669cb0a06
[project @ 2005-03-01 06:16:25 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,18 @@
+2005-02-28  John W. Eaton  <jwe@octave.org>
+
+	* octMakefile.in (DISTDIRS): Remove glob from the list.
+	(dist): No need to clean up in glob subdirectory.
+	* glob: Delete directory.
+	* Makeconf.in (GLOB_INCFLAGS, LIBGLOB): Delete.
+	(do-subst-config-vals): Don't substitute them.
+	(INCFLAGS): Remove $(GLOB_INCFLAGS) from the list.
+	* configure.in: Don't test for glob or fnmatch.
+
 2005-02-22  Shan G. Smith  <shan@cybertrails.com>
 
 	* mkoctfile.in: If not linking, then use output file name
 	specified with -o.
 
 2005-02-21  John W. Eaton  <jwe@octave.org>
 
 	* texi2dvi: Delete our private version.
diff --git a/Makeconf.in b/Makeconf.in
--- a/Makeconf.in
+++ b/Makeconf.in
@@ -86,17 +86,16 @@ FC = @FC@
 F77 = @F77@
 FFLAGS = @FFLAGS@
 FPICFLAG = @FPICFLAG@
 ALL_FFLAGS = $(FFLAGS)
 
 # cc and associated flags.
 
 DLFCN_INCFLAGS = @DLFCN_INCFLAGS@
-GLOB_INCFLAGS = @GLOB_INCFLAGS@
 
 # Clean up INCFLAGS a bit if we are not compiling in a separate
 # directory.
 ifeq ($(srcdir),.)
   TMP_IF_1 = -I.
 else
   TMP_IF_1 = -I. -I$(srcdir)
 endif
@@ -112,17 +111,17 @@ else
     -I$(TOPDIR)/liboctave \
     -I$(TOPDIR)/src \
     -I$(TOPDIR)/libcruft/misc \
     -I$(top_srcdir) \
     -I$(top_srcdir)/liboctave \
     -I$(top_srcdir)/src \
     -I$(top_srcdir)/libcruft/misc
 endif
-INCFLAGS = $(TMP_IF_1) $(TMP_IF_2) $(DLFCN_INCFLAGS) $(GLOB_INCFLAGS)
+INCFLAGS = $(TMP_IF_1) $(TMP_IF_2) $(DLFCN_INCFLAGS)
 
 LIBFLAGS = -L$(TOPDIR)
 
 DEFS = @DEFS@
 
 UGLY_DEFS = @UGLY_DEFS@
 
 CC = @CC@
@@ -173,17 +172,16 @@ SONAME_FLAGS = @SONAME_FLAGS@
 
 RDYNAMIC_FLAG = @RDYNAMIC_FLAG@
 
 RLD_FLAG = @RLD_FLAG@
 
 FLIBS = @FLIBS@
 
 LIBDLFCN = @LIBDLFCN@
-LIBGLOB = @LIBGLOB@
 LIBPLPLOT = @LIBPLPLOT@
 LIBOCTINTERP = @LIBOCTINTERP@
 LIBOCTAVE = @LIBOCTAVE@
 LIBCRUFT = @LIBCRUFT@
 LIBREADLINE = @LIBREADLINE@
 TERMLIBS = @TERMLIBS@
 
 BLAS_LIBS = @BLAS_LIBS@
@@ -425,29 +423,27 @@ echo "making $@ from $<"
   -e "s;%OCTAVE_CONF_F2C%;\"${F2C}\";" \
   -e "s;%OCTAVE_CONF_F2CFLAGS%;\"${F2CFLAGS}\";" \
   -e "s;%OCTAVE_CONF_F77%;\"${F77}\";" \
   -e "s;%OCTAVE_CONF_FC%;\"${FC}\";" \
   -e "s;%OCTAVE_CONF_FFLAGS%;\"${FFLAGS}\";" \
   -e "s;%OCTAVE_CONF_FFTW_LIBS%;\"${FFTW_LIBS}\";" \
   -e "s;%OCTAVE_CONF_FLIBS%;\"${FLIBS}\";" \
   -e "s;%OCTAVE_CONF_FPICFLAG%;\"${FPICFLAG}\";" \
-  -e "s;%OCTAVE_CONF_GLOB_INCFLAGS%;\"${GLOB_INCFLAGS}\";" \
   -e "s;%OCTAVE_CONF_INCFLAGS%;\"${INCFLAGS}\";" \
   -e "s;%OCTAVE_CONF_LD_CXX%;\"${LD_CXX}\";" \
   -e "s;%OCTAVE_CONF_LDFLAGS%;\"${LDFLAGS}\";" \
   -e "s;%OCTAVE_CONF_LD_STATIC_FLAG%;\"${LD_STATIC_FLAG}\";" \
   -e "s;%OCTAVE_CONF_LEX%;\"${LEX}\";" \
   -e "s;%OCTAVE_CONF_LEXLIB%;\"${LEXLIB}\";" \
   -e "s;%OCTAVE_CONF_LFLAGS%;\"${LFLAGS}\";" \
   -e "s;%OCTAVE_CONF_LIBCRUFT%;\"${LIBCRUFT}\";" \
   -e "s;%OCTAVE_CONF_LIBDLFCN%;\"${LIBDLFCN}\";" \
   -e "s;%OCTAVE_CONF_LIBEXT%;\"${LIBEXT}\";" \
   -e "s;%OCTAVE_CONF_LIBFLAGS%;\"${LIBFLAGS}\";" \
-  -e "s;%OCTAVE_CONF_LIBGLOB%;\"${LIBGLOB}\";" \
   -e "s;%OCTAVE_CONF_LIBOCTAVE%;\"${LIBOCTAVE}\";" \
   -e "s;%OCTAVE_CONF_LIBOCTINTERP%;\"${LIBOCTINTERP}\";" \
   -e "s;%OCTAVE_CONF_LIBPLPLOT%;\"${LIBPLPLOT}\";" \
   -e "s;%OCTAVE_CONF_LIBREADLINE%;\"${LIBREADLINE}\";" \
   -e "s;%OCTAVE_CONF_LIBS%;\"${LIBS}\";" \
   -e "s;%OCTAVE_CONF_LN_S%;\"${LN_S}\";" \
   -e "s;%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%;\"${MKOCTFILE_DL_LDFLAGS}\";" \
   -e "s;%OCTAVE_CONF_MKOCTFILE_INCFLAGS%;\"${MKOCTFILE_INCFLAGS}\";" \
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.460 $)
+AC_REVISION($Revision: 1.461 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -915,18 +915,16 @@ AC_CHECK_HEADERS(assert.h curses.h direc
 AC_LANG_PUSH(C++)
 AC_CHECK_HEADERS(sstream)
 AC_LANG_POP(C++)
 
 have_termios_h=no
 AC_CHECK_HEADERS($TERMIOS_H, have_termios_h=yes)
 AC_CHECK_HEADERS(termio.h, have_termio_h=yes, have_termio_h=no)
 AC_CHECK_HEADERS(sgtty.h, have_sgtty_h=yes, have_sgtty_h=no)
-AC_CHECK_HEADERS(glob.h, have_glob_h=yes, have_glob_h=no)
-AC_CHECK_HEADERS(fnmatch.h, have_fnmatch_h=yes, have_fnmatch_h=no)
 AC_CHECK_HEADERS(conio.h, have_conio_h=yes, have_conio_h=no)
 
 ### I'm told that termios.h is broken on NeXT systems.
 
 case "$canonical_host_type" in
   *-*-nextstep*)
     if test "$have_termios_h" = yes; then
       AC_MSG_WARN([Ignoring termios.h on NeXT systems.])
@@ -938,52 +936,16 @@ esac
 if test "$have_termios_h" = yes \
     || test "$have_termio_h" = yes \
     || test "$have_sgtty_h" = yes; then
   true
 else
   AC_MSG_WARN([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
 
-## I'm told that setting LIBGLOB to be $(TOPDIR)/glob/libglob.a causes
-## trouble on SCO systems, but setting it to be the two object files
-## avoids the problem.
-
-GLOB_DIR=glob
-if test -n "$ALLOCA"; then
-  LIBGLOB='$(TOPDIR)/glob/glob.o $(TOPDIR)/glob/fnmatch.o $(TOPDIR)/glob/alloca.o'
-else
-  LIBGLOB='$(TOPDIR)/glob/glob.o $(TOPDIR)/glob/fnmatch.o'
-fi
-GLOB_INCFLAGS='-I$(top_srcdir)/glob -I$(TOPDIR)/glob'
-if test "$have_fnmatch_h" = yes && test "$have_glob_h" = yes; then
-  AC_EGREP_CPP(yes, [#include <fnmatch.h>
-#ifdef FNM_NOESCAPE
-#ifdef FNM_FOOBAR_PATHNAME /* FIXME: delete FOOBAR_ ? */
-#ifdef FNM_PERIOD
-   yes
-#endif
-#endif
-#endif
-    ], [
-      GLOB_DIR=
-      AC_CHECK_LIB(glob, glob)
-      AC_CHECK_FUNCS(fnmatch, have_fnmatch=yes, have_fnmatch=no)
-      AC_CHECK_FUNCS(glob, have_glob=yes, have_glob=no)
-      if test "$have_fnmatch" = yes && test "$have_glob" = yes; then
-	GLOB_DIR=
-	LIBGLOB=
-	GLOB_INCFLAGS=
-      fi
-    ])
-fi
-AC_SUBST(GLOB_DIR)
-AC_SUBST(LIBGLOB)
-AC_SUBST(GLOB_INCFLAGS)
-
 ### Checks for functions and variables.
 
 AC_CHECK_FUNCS(atexit basename bcopy bzero canonicalize_file_name \
   dup2 endgrent endpwent execvp fcntl fork getcwd getegid geteuid \
   getgid getgrent getgrgid getgrnam getpgrp getpid getppid getpwent \
   getpwuid gettimeofday getuid getwd _kbhit kill link localtime_r \
   lstat memmove mkdir mkfifo mkstemp on_exit pipe poll putenv raise \
   readlink rename resolvepath rindex rmdir round select setgrent \
@@ -1359,25 +1321,18 @@ AC_SUBST(WARN_CXXFLAGS)
 ### Run configure in subdirectories.
 
 export CC
 export CXX
 export F77
 
 AC_CONFIG_SUBDIRS(scripts)
 
-# autoconf 2.50 deprecates the use of variables (e.g. $GLOB_DIR)
-# in AC_CONFIG_SUBDIRS; the following form is recommended instead:
-
-if test "x$GLOB_DIR" = xglob; then
-	AC_CONFIG_SUBDIRS(glob)
-fi
-
 if test "x$PLPLOT_DIR" = xplplot; then
-	AC_CONFIG_SUBDIRS(plplot)
+  AC_CONFIG_SUBDIRS(plplot)
 fi
 
 ### Some things to add to the bottom of config.h.
 
 AH_BOTTOM([
 #if defined (__GNUC__)
 #define GCC_ATTR_NORETURN __attribute__ ((__noreturn__))
 #define GCC_ATTR_UNUSED __attribute__ ((__unused__))
diff --git a/glob/COPYING b/glob/COPYING
deleted file mode 100644
--- a/glob/COPYING
+++ /dev/null
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) 19yy name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff --git a/glob/ChangeLog b/glob/ChangeLog
deleted file mode 100644
--- a/glob/ChangeLog
+++ /dev/null
@@ -1,43 +0,0 @@
-2003-11-12  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* alloca.c: New file, from GNU Emacs.
-	* Makefile.in (ALLOCA): New macro.
-	(libglob.a): Also include $(ALLOCA).
-
-2003-07-02  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* Makefile.in (distclean): Also remove autom4te.cache directory.
-
-2002-10-10  Paul Kienzle <pkienzle@users.sf.net>
-
-	* configure.in: Use AH_BOTTOM to maybe define WINDOWS32.
-
-2002-10-09  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* fnmatch.h, glob.h, fnmatch.c, glob.c: Update to latest GNU sources.
-
-2002-05-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* configure.in: Add AC_CONFIG_HEADERS.
-
-2002-04-03  Steven G. Johnson <stevenj@alum.mit.edu>
-
-	* configure.in: Update for autoconf 2.5x.
-
-2000-03-21  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* COPYING.LIB: Delete.
-	* COPYING: New file.  RMS says Octave should use the GPL for its
-	copy of glob.
-
-Wed Apr 16 16:21:37 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* glob.h ("C"): Check _GNU_SOURCE, not _BSD_SOURCE.
-
-Wed Mar 12 17:00:54 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* Makefile.in (install-strip): New target.
-
-Sat Oct 12 00:17:06 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* glob/Makefile.in (clean targets): Don't depend on clean.
diff --git a/glob/ChangeLog.glob b/glob/ChangeLog.glob
deleted file mode 100644
--- a/glob/ChangeLog.glob
+++ /dev/null
@@ -1,136 +0,0 @@
-2002-04-22  Paul D. Smith  <psmith@gnu.org>
-
-	* Makefile.am: Use automake 1.6.
-	Use new automake condition USE_LOCAL_GLOB to decide whether or not
-	to build the local GNU glob library or use the system one.
-
-1999-09-12  Paul D. Smith  <psmith@gnu.org>
-
-	* fnmatch.c: Last GLIBC version wouldn't compile outside of GLIBC
-	(undefined reference to internal_function).  Update to the latest
-	version
-
-1999-09-11  Paul Eggert  <eggert@twinsun.com>
-
-	* glob.h (glob): If #defining to glob64, do this before
-	declaring it, so that all declarations and uses match, and
-	do not declare glob64, to avoid a declaration clash.
-	(globfree): Likewise with globfree64.
-
-1999-09-08  Eli Zaretskii  <eliz@is.elta.co.il>
-
-	* glob.c (prefix_array) [__MSDOS__,WINDOWS32]: Keep the trailing
-	slash unless DIRNAME is just "x:/".
-
-1999-09-06  Paul D. Smith  <psmith@gnu.org>
-
-	* fnmatch.c: Update to latest version from GLIBC.
-
-1999-07-21  Paul D. Smith  <psmith@gnu.org>
-
-	* glob.c, glob.h, fnmatch.c, fnmatch.h: Update to latest version
-	from GLIBC.
-
-	* fnmatch.c (internal_fnmatch): Use K&R definition syntax, not ANSI.
-	(__strchrnul): This won't exist outside GLIBC, so create one.
-
-	* glob.c: Move getlogin{,_r} prototypes below glob.h to get __P()
-	macro.
-
-1998-08-05  Paul D. Smith  <psmith@gnu.org>
-
-	* configure.in: Remove; configuration for glob is handled by the
-	make configure.in.
-
-1998-07-29  Paul D. Smith  <psmith@gnu.org>
-
-	* glob.c, fnmatch.c: New versions from the GLIBC folks (Ulrich
-	Drepper).  Fixes a bug reported by Eli Zaretski.  Integrates
-	DOS/Windows32 support.
-
-1998-07-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
-
-	* glob.c (glob): Cast away const on assignment of pattern to dirname.
-	Cast the return type of __alloca() for traditional C compilers.
-
-1998-07-23  Paul D. Smith  <psmith@gnu.org>
-
-	* glob.c, fnmatch.c: New versions of these files from the GLIBC
-	folks (Ulrich Drepper).  Had to re-integrate some DOS/Windows
-	code.
-
-1998-07-10  Paul D. Smith  <psmith@gnu.org>
-
-	* glob.c (glob_in_dir): If no meta chars exist in PATTERN and
-	GLOB_NOCHECK is present, don't look for the file--whether it's
-	found or not, we'll always return it, so why bother searching?
-
-	Also, if we are searching and there are no meta chars, don't
-	bother trying fnmatch() if the strcmp() fails.
-
-1998-05-30  Eli Zaretskii  <eliz@is.elta.co.il>
-
-	* glob.c (glob) [__MSDOS__, WINDOWS32]: Compute the directory and
-	filename parts of the pattern correctly when it includes a drive
-	spec.  Disallow wildcards in the drive spec.  Prevent recursion
-	when dirname is of the form "d:/" or "d:".
-	(prefix_array) [__MSDOS__, WINDOWS32]: Don't append a slash to
-	"d:/" and "d:".
-
-1998-05-13  Paul D. Smith  <psmith@gnu.org>
-
-	* SMakefile, Makefile.ami, glob.c, glob.h, fnmatch.c: Updated from
-	the latest glibc version.
-
-1998-04-17  Paul D. Smith  <psmith@gnu.org>
-
-	* configure.in: Create a config.h file instead of setting things
-	on the compile line.  This is because when build.sh runs it merely
-	passes -DHAVE_CONFIG_H to the glob files, just as it does to the
-	make files.
-	* config.h.in: Created by autoheader.
-
-Tue Aug 12 10:52:34 1997  Paul D. Smith  <psmith@baynetworks.com>
-
-	* configure.in: Require autoconf 2.12.
-
-	* glob: Updates from latest GNU libc glob code.
-
-	* glob.c,glob.h,fnmatch.h: Change all WIN32 references to WINDOWS32.
-
-	* glob.h: OSF4 defines macros in such a way that GLOB_ALTDIRFUNC
-	is not defined.  Added a test to the #if which defines it if
-	_GNU_SOURCE is defined; that's set by both glob.c and GNU make.
-
-	* glob.c: SunOS4 w/ cc needs #include <stdio.h>, since assert.h
-	requires stderr but doesn't include stdio.h :-/.
-	(next_brace_sub): De-protoize function definition.
-	(glob): Cast __alloca(); on SunOS4 it uses the default return type
-	of int.
-	(glob): Irix defines getlogin_r() to return a char*; move the
-	extern for that into the _LIBC area since it isn't used except in
-	LIBC anyway.  Likewise, move extern getlogin() into the "else".
-
-Sat Jul 20 21:55:31 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
-
-	Win32 hacks from <Rob_Tulloh@tivoli.com>.
-	* posix/glob.c [WIN32]: Don't include <pwd.h>; don't use d_ino;
-	use void * for my_realloc; include <malloc.h> for alloca.
-	(glob) [WIN32]: Use "c:/users/default" for ~ if no HOME variable.
-	* posix/fnmatch.h [WIN32]: Use prototypes even if [!__STDC__].
-	* posix/glob.h: Likewise.
-
-Fri Jul 19 16:56:41 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
-
-	* posix/glob.h [!_AMIGA && !VMS]: Check this instead of just [!_AMIGA]
-	for `struct stat;' forward decl.
-
-Sat Jun 22 10:44:09 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
-
-	* posix/glob.c: Include <alloca.h> only [HAVE_ALLOCA_H], not [sparc].
-
-Fri Jun 21 00:27:51 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
-
-	* posix/fnmatch.c (fnmatch): Fix \*[*?]+ case to increment name ptr
- 	only for ?s, not for *s.  Fix from Chet Ramey.
-
diff --git a/glob/Makefile.in b/glob/Makefile.in
deleted file mode 100644
--- a/glob/Makefile.in
+++ /dev/null
@@ -1,77 +0,0 @@
-# Makefile for standalone distribution of libglob.a (fnmatch, glob).
-
-# Copyright (C) 1991, 92, 93, 94, 95 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Library General Public License
-# as published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Library General Public License for more details.
-
-# You should have received a copy of the GNU Library General Public
-# License along with this library; see the file COPYING.LIB.  If
-# not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA  02111-1307, USA.
-
-# Ultrix 2.2 make doesn't expand the value of VPATH.
-VPATH = @srcdir@
-# This must repeat the value, because configure will remove `VPATH = .'.
-srcdir = @srcdir@
-
-CC = @CC@
-CPPFLAGS = @CPPFLAGS@
-CFLAGS = @CFLAGS@
-
-# Information determined by configure.
-DEFS = @DEFS@
-
-# How to invoke ar.
-AR = @AR@
-ARFLAGS = rv
-
-ALLOCA = @ALLOCA@
-
-# How to invoke ranlib.
-RANLIB = @RANLIB@
-
-.PHONY: all
-all: libglob.a
-
-libglob.a: glob.o fnmatch.o $(ALLOCA)
-	$(AR) $(ARFLAGS) $@ glob.o fnmatch.o $(ALLOCA)
-	$(RANLIB) $@
-
-# For some reason, Unix make wants the dependencies on the source files.
-# Otherwise it refuses to use an implicit rule!
-# And, get this: it doesn't work to use $(srcdir)/foo.c!!
-glob.o: $(srcdir)/glob.h $(srcdir)/fnmatch.h glob.c
-fnmatch.o: $(srcdir)/fnmatch.h fnmatch.c
-
-.c.o:
-	$(CC) -I. -I$(srcdir) -c \
-	      $(DEFS) $(CPPFLAGS) $(CFLAGS) $< $(OUTPUT_OPTION)
-
-.PHONY: clean maintainer-clean glob-clean glob-maintainer-clean distclean
-clean glob-clean:
-	-rm -f libglob.a *.o core
-
-distclean glob-maintainer-clean: clean
-	-rm -f Makefile config.status config.cache config.h config.log
-	-rm -f TAGS tags
-	-rm -rf autom4te.cache
-
-maintainer-clean: distclean
-	-rm -f configure config.h.in
-
-realclean: distclean
-
-# For inside the C library.
-glob.tar glob.tar.Z:
-	$(MAKE) -C .. $@
-
-install install-strip:
diff --git a/glob/alloca.c b/glob/alloca.c
deleted file mode 100644
--- a/glob/alloca.c
+++ /dev/null
@@ -1,518 +0,0 @@
-/* alloca.c -- allocate automatically reclaimed memory
-   (Mostly) portable public-domain implementation -- D A Gwyn
-
-   NOTE: The canonical source of this file is maintained with gnulib.
-   Bugs can be reported to bug-gnulib@gnu.org.
-
-   This implementation of the PWB library alloca function,
-   which is used to allocate space off the run-time stack so
-   that it is automatically reclaimed upon procedure exit,
-   was inspired by discussions with J. Q. Johnson of Cornell.
-   J.Otto Tennant <jot@cray.com> contributed the Cray support.
-
-   There are some preprocessor constants that can
-   be defined when compiling for your specific system, for
-   improved efficiency; however, the defaults should be okay.
-
-   The general concept of this implementation is to keep
-   track of all alloca-allocated blocks, and reclaim any
-   that are found to be deeper in the stack than the current
-   invocation.  This heuristic does not reclaim storage as
-   soon as it becomes invalid, but it will do so eventually.
-
-   As a special case, alloca(0) reclaims storage without
-   allocating any.  It is a good idea to use alloca(0) in
-   your main control loop, etc. to force garbage collection.  */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-#ifdef HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-
-#ifdef DO_BLOCK_INPUT
-# include "lisp.h"
-# include "blockinput.h"
-#endif
-
-/* If compiling with GCC 2, this file's not needed.  */
-#if !defined (__GNUC__) || __GNUC__ < 2
-
-/* If someone has defined alloca as a macro,
-   there must be some other way alloca is supposed to work.  */
-# ifndef alloca
-
-#  ifdef emacs
-#   ifdef static
-/* actually, only want this if static is defined as ""
-   -- this is for usg, in which emacs must undefine static
-   in order to make unexec workable
-   */
-#    ifndef STACK_DIRECTION
-you
-lose
--- must know STACK_DIRECTION at compile-time
-/* Using #error here is not wise since this file should work for
-   old and obscure compilers.  */
-#    endif /* STACK_DIRECTION undefined */
-#   endif /* static */
-#  endif /* emacs */
-
-/* If your stack is a linked list of frames, you have to
-   provide an "address metric" ADDRESS_FUNCTION macro.  */
-
-#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
-long i00afunc ();
-#   define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
-#  else
-#   define ADDRESS_FUNCTION(arg) &(arg)
-#  endif
-
-#  ifdef POINTER_TYPE
-typedef POINTER_TYPE *pointer;
-#  else /* not POINTER_TYPE */
-#   if __STDC__
-typedef void *pointer;
-#   else /* not __STDC__ */
-typedef char *pointer;
-#   endif /* not __STDC__ */
-#  endif /* not POINTER_TYPE */
-
-#  ifndef NULL
-#   define NULL 0
-#  endif
-
-/* Different portions of Emacs need to call different versions of
-   malloc.  The Emacs executable needs alloca to call xmalloc, because
-   ordinary malloc isn't protected from input signals.  On the other
-   hand, the utilities in lib-src need alloca to call malloc; some of
-   them are very simple, and don't have an xmalloc routine.
-
-   Non-Emacs programs expect this to call xmalloc.
-
-   Callers below should use malloc.  */
-
-#  ifdef emacs
-#   undef malloc
-#   define malloc xmalloc
-#   ifdef EMACS_FREE
-#    define free EMACS_FREE
-#   endif
-#  endif
-extern pointer malloc ();
-
-/* Define STACK_DIRECTION if you know the direction of stack
-   growth for your system; otherwise it will be automatically
-   deduced at run-time.
-
-   STACK_DIRECTION > 0 => grows toward higher addresses
-   STACK_DIRECTION < 0 => grows toward lower addresses
-   STACK_DIRECTION = 0 => direction of growth unknown  */
-
-#  ifndef STACK_DIRECTION
-#   define STACK_DIRECTION	0	/* Direction unknown.  */
-#  endif
-
-#  if STACK_DIRECTION != 0
-
-#   define STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
-
-#  else /* STACK_DIRECTION == 0; need run-time code.  */
-
-static int stack_dir;		/* 1 or -1 once known.  */
-#   define STACK_DIR	stack_dir
-
-static void
-find_stack_direction ()
-{
-  static char *addr = NULL;	/* Address of first `dummy', once known.  */
-  auto char dummy;		/* To get stack address.  */
-
-  if (addr == NULL)
-    {				/* Initial entry.  */
-      addr = ADDRESS_FUNCTION (dummy);
-
-      find_stack_direction ();	/* Recurse once.  */
-    }
-  else
-    {
-      /* Second entry.  */
-      if (ADDRESS_FUNCTION (dummy) > addr)
-	stack_dir = 1;		/* Stack grew upward.  */
-      else
-	stack_dir = -1;		/* Stack grew downward.  */
-    }
-}
-
-#  endif /* STACK_DIRECTION == 0 */
-
-/* An "alloca header" is used to:
-   (a) chain together all alloca'ed blocks;
-   (b) keep track of stack depth.
-
-   It is very important that sizeof(header) agree with malloc
-   alignment chunk size.  The following default should work okay.  */
-
-#  ifndef	ALIGN_SIZE
-#   define ALIGN_SIZE	sizeof(double)
-#  endif
-
-typedef union hdr
-{
-  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
-  struct
-    {
-      union hdr *next;		/* For chaining headers.  */
-      char *deep;		/* For stack depth measure.  */
-    } h;
-} header;
-
-static header *last_alloca_header = NULL;	/* -> last alloca header.  */
-
-/* Return a pointer to at least SIZE bytes of storage,
-   which will be automatically reclaimed upon exit from
-   the procedure that called alloca.  Originally, this space
-   was supposed to be taken from the current stack frame of the
-   caller, but that method cannot be made to work for some
-   implementations of C, for example under Gould's UTX/32.  */
-
-pointer
-alloca (size)
-     size_t size;
-{
-  auto char probe;		/* Probes stack depth: */
-  register char *depth = ADDRESS_FUNCTION (probe);
-
-#  if STACK_DIRECTION == 0
-  if (STACK_DIR == 0)		/* Unknown growth direction.  */
-    find_stack_direction ();
-#  endif
-
-  /* Reclaim garbage, defined as all alloca'd storage that
-     was allocated from deeper in the stack than currently.  */
-
-  {
-    register header *hp;	/* Traverses linked list.  */
-
-#  ifdef DO_BLOCK_INPUT
-    BLOCK_INPUT;
-#  endif
-
-    for (hp = last_alloca_header; hp != NULL;)
-      if ((STACK_DIR > 0 && hp->h.deep > depth)
-	  || (STACK_DIR < 0 && hp->h.deep < depth))
-	{
-	  register header *np = hp->h.next;
-
-	  free ((pointer) hp);	/* Collect garbage.  */
-
-	  hp = np;		/* -> next header.  */
-	}
-      else
-	break;			/* Rest are not deeper.  */
-
-    last_alloca_header = hp;	/* -> last valid storage.  */
-
-#  ifdef DO_BLOCK_INPUT
-    UNBLOCK_INPUT;
-#  endif
-  }
-
-  if (size == 0)
-    return NULL;		/* No allocation required.  */
-
-  /* Allocate combined header + user data storage.  */
-
-  {
-    register pointer new = malloc (sizeof (header) + size);
-    /* Address of header.  */
-
-    if (new == 0)
-      abort();
-
-    ((header *) new)->h.next = last_alloca_header;
-    ((header *) new)->h.deep = depth;
-
-    last_alloca_header = (header *) new;
-
-    /* User storage begins just after header.  */
-
-    return (pointer) ((char *) new + sizeof (header));
-  }
-}
-
-#  if defined (CRAY) && defined (CRAY_STACKSEG_END)
-
-#   ifdef DEBUG_I00AFUNC
-#    include <stdio.h>
-#   endif
-
-#   ifndef CRAY_STACK
-#    define CRAY_STACK
-#    ifndef CRAY2
-/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
-struct stack_control_header
-  {
-    long shgrow:32;		/* Number of times stack has grown.  */
-    long shaseg:32;		/* Size of increments to stack.  */
-    long shhwm:32;		/* High water mark of stack.  */
-    long shsize:32;		/* Current size of stack (all segments).  */
-  };
-
-/* The stack segment linkage control information occurs at
-   the high-address end of a stack segment.  (The stack
-   grows from low addresses to high addresses.)  The initial
-   part of the stack segment linkage control information is
-   0200 (octal) words.  This provides for register storage
-   for the routine which overflows the stack.  */
-
-struct stack_segment_linkage
-  {
-    long ss[0200];		/* 0200 overflow words.  */
-    long sssize:32;		/* Number of words in this segment.  */
-    long ssbase:32;		/* Offset to stack base.  */
-    long:32;
-    long sspseg:32;		/* Offset to linkage control of previous
-				   segment of stack.  */
-    long:32;
-    long sstcpt:32;		/* Pointer to task common address block.  */
-    long sscsnm;		/* Private control structure number for
-				   microtasking.  */
-    long ssusr1;		/* Reserved for user.  */
-    long ssusr2;		/* Reserved for user.  */
-    long sstpid;		/* Process ID for pid based multi-tasking.  */
-    long ssgvup;		/* Pointer to multitasking thread giveup.  */
-    long sscray[7];		/* Reserved for Cray Research.  */
-    long ssa0;
-    long ssa1;
-    long ssa2;
-    long ssa3;
-    long ssa4;
-    long ssa5;
-    long ssa6;
-    long ssa7;
-    long sss0;
-    long sss1;
-    long sss2;
-    long sss3;
-    long sss4;
-    long sss5;
-    long sss6;
-    long sss7;
-  };
-
-#    else /* CRAY2 */
-/* The following structure defines the vector of words
-   returned by the STKSTAT library routine.  */
-struct stk_stat
-  {
-    long now;			/* Current total stack size.  */
-    long maxc;			/* Amount of contiguous space which would
-				   be required to satisfy the maximum
-				   stack demand to date.  */
-    long high_water;		/* Stack high-water mark.  */
-    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
-    long hits;			/* Number of internal buffer hits.  */
-    long extends;		/* Number of block extensions.  */
-    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
-    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
-    long stko_free;		/* Number of deallocations by $STKRETN.  */
-    long stkm_free;		/* Number of deallocations by $STKMRET.  */
-    long segments;		/* Current number of stack segments.  */
-    long maxs;			/* Maximum number of stack segments so far.  */
-    long pad_size;		/* Stack pad size.  */
-    long current_address;	/* Current stack segment address.  */
-    long current_size;		/* Current stack segment size.  This
-				   number is actually corrupted by STKSTAT to
-				   include the fifteen word trailer area.  */
-    long initial_address;	/* Address of initial segment.  */
-    long initial_size;		/* Size of initial segment.  */
-  };
-
-/* The following structure describes the data structure which trails
-   any stack segment.  I think that the description in 'asdef' is
-   out of date.  I only describe the parts that I am sure about.  */
-
-struct stk_trailer
-  {
-    long this_address;		/* Address of this block.  */
-    long this_size;		/* Size of this block (does not include
-				   this trailer).  */
-    long unknown2;
-    long unknown3;
-    long link;			/* Address of trailer block of previous
-				   segment.  */
-    long unknown5;
-    long unknown6;
-    long unknown7;
-    long unknown8;
-    long unknown9;
-    long unknown10;
-    long unknown11;
-    long unknown12;
-    long unknown13;
-    long unknown14;
-  };
-
-#    endif /* CRAY2 */
-#   endif /* not CRAY_STACK */
-
-#   ifdef CRAY2
-/* Determine a "stack measure" for an arbitrary ADDRESS.
-   I doubt that "lint" will like this much.  */
-
-static long
-i00afunc (long *address)
-{
-  struct stk_stat status;
-  struct stk_trailer *trailer;
-  long *block, size;
-  long result = 0;
-
-  /* We want to iterate through all of the segments.  The first
-     step is to get the stack status structure.  We could do this
-     more quickly and more directly, perhaps, by referencing the
-     $LM00 common block, but I know that this works.  */
-
-  STKSTAT (&status);
-
-  /* Set up the iteration.  */
-
-  trailer = (struct stk_trailer *) (status.current_address
-				    + status.current_size
-				    - 15);
-
-  /* There must be at least one stack segment.  Therefore it is
-     a fatal error if "trailer" is null.  */
-
-  if (trailer == 0)
-    abort ();
-
-  /* Discard segments that do not contain our argument address.  */
-
-  while (trailer != 0)
-    {
-      block = (long *) trailer->this_address;
-      size = trailer->this_size;
-      if (block == 0 || size == 0)
-	abort ();
-      trailer = (struct stk_trailer *) trailer->link;
-      if ((block <= address) && (address < (block + size)))
-	break;
-    }
-
-  /* Set the result to the offset in this segment and add the sizes
-     of all predecessor segments.  */
-
-  result = address - block;
-
-  if (trailer == 0)
-    {
-      return result;
-    }
-
-  do
-    {
-      if (trailer->this_size <= 0)
-	abort ();
-      result += trailer->this_size;
-      trailer = (struct stk_trailer *) trailer->link;
-    }
-  while (trailer != 0);
-
-  /* We are done.  Note that if you present a bogus address (one
-     not in any segment), you will get a different number back, formed
-     from subtracting the address of the first block.  This is probably
-     not what you want.  */
-
-  return (result);
-}
-
-#   else /* not CRAY2 */
-/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
-   Determine the number of the cell within the stack,
-   given the address of the cell.  The purpose of this
-   routine is to linearize, in some sense, stack addresses
-   for alloca.  */
-
-static long
-i00afunc (long address)
-{
-  long stkl = 0;
-
-  long size, pseg, this_segment, stack;
-  long result = 0;
-
-  struct stack_segment_linkage *ssptr;
-
-  /* Register B67 contains the address of the end of the
-     current stack segment.  If you (as a subprogram) store
-     your registers on the stack and find that you are past
-     the contents of B67, you have overflowed the segment.
-
-     B67 also points to the stack segment linkage control
-     area, which is what we are really interested in.  */
-
-  stkl = CRAY_STACKSEG_END ();
-  ssptr = (struct stack_segment_linkage *) stkl;
-
-  /* If one subtracts 'size' from the end of the segment,
-     one has the address of the first word of the segment.
-
-     If this is not the first segment, 'pseg' will be
-     nonzero.  */
-
-  pseg = ssptr->sspseg;
-  size = ssptr->sssize;
-
-  this_segment = stkl - size;
-
-  /* It is possible that calling this routine itself caused
-     a stack overflow.  Discard stack segments which do not
-     contain the target address.  */
-
-  while (!(this_segment <= address && address <= stkl))
-    {
-#    ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
-#    endif
-      if (pseg == 0)
-	break;
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      this_segment = stkl - size;
-    }
-
-  result = address - this_segment;
-
-  /* If you subtract pseg from the current end of the stack,
-     you get the address of the previous stack segment's end.
-     This seems a little convoluted to me, but I'll bet you save
-     a cycle somewhere.  */
-
-  while (pseg != 0)
-    {
-#    ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o\n", pseg, size);
-#    endif
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      result += size;
-    }
-  return (result);
-}
-
-#   endif /* not CRAY2 */
-#  endif /* CRAY */
-
-# endif /* no alloca */
-#endif /* not GCC version 2 */
diff --git a/glob/configure.bat b/glob/configure.bat
deleted file mode 100644
--- a/glob/configure.bat
+++ /dev/null
@@ -1,26 +0,0 @@
-@echo off
-echo Configuring glob for GO32
-rem This batch file assumes a unix-type "sed" program
-
-echo # Makefile generated by "configure.bat"> Makefile
-
-if exist config.sed del config.sed
-
-echo "s/@srcdir@/./					">> config.sed
-echo "s/@CC@/gcc/					">> config.sed
-echo "s/@CFLAGS@/-O2 -g/				">> config.sed
-echo "s/@CPPFLAGS@/-DHAVE_CONFIG_H -I../		">> config.sed
-echo "s/@AR@/ar/					">> config.sed
-echo "s/@RANLIB@/ranlib/				">> config.sed
-echo "s/@LDFLAGS@//					">> config.sed
-echo "s/@DEFS@//					">> config.sed
-echo "s/@ALLOCA@//					">> config.sed
-echo "s/@LIBS@//					">> config.sed
-echo "s/@LIBOBJS@//					">> config.sed
-echo "s/^Makefile *:/_Makefile:/			">> config.sed
-echo "s/^config.h *:/_config.h:/			">> config.sed
-
-sed -e "s/^\"//" -e "s/\"$//" -e "s/[ 	]*$//" config.sed > config2.sed
-sed -f config2.sed Makefile.in >> Makefile
-del config.sed
-del config2.sed
diff --git a/glob/configure.in b/glob/configure.in
deleted file mode 100644
--- a/glob/configure.in
+++ /dev/null
@@ -1,27 +0,0 @@
-dnl Process this file with autoconf to produce a configure script.
-AC_INIT
-AC_CONFIG_SRCDIR([fnmatch.c])		dnl A distinctive file to look for in srcdir.
-AC_PREREQ(2.52)			dnl Minimum Autoconf version required.
-AC_CONFIG_HEADER(config.h)
-AC_PROG_CC
-AC_CHECK_PROG(AR, ar, ar, ar)
-AC_PROG_RANLIB
-AC_PROG_CPP			dnl Later checks need this.
-dnl These two want to come early.
-AC_AIX
-AC_MINIX
-AC_ISC_POSIX
-AC_C_CONST([])
-AC_HEADER_STDC
-AC_CHECK_HEADERS(memory.h unistd.h string.h)
-AC_HEADER_DIRENT
-AC_FUNC_CLOSEDIR_VOID
-AC_FUNC_ALLOCA
-AC_FUNC_STRCOLL
-AH_BOTTOM([
-#if defined (__WIN32__) && ! defined (_POSIX_VERSION)
-#define WINDOWS32
-#endif
-])
-AC_CONFIG_FILES([Makefile])
-AC_OUTPUT
diff --git a/glob/fnmatch.c b/glob/fnmatch.c
deleted file mode 100644
--- a/glob/fnmatch.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/* Copyright (C) 1991, 92, 93, 96, 97, 98, 99 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with this library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-/* Enable GNU extensions in fnmatch.h.  */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE	1
-#endif
-
-#include <errno.h>
-#include <fnmatch.h>
-#include <ctype.h>
-
-#if HAVE_STRING_H || defined _LIBC
-# include <string.h>
-#else
-# include <strings.h>
-#endif
-
-#if defined STDC_HEADERS || defined _LIBC
-# include <stdlib.h>
-#endif
-
-/* For platform which support the ISO C amendement 1 functionality we
-   support user defined character classes.  */
-#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
-/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
-# include <wchar.h>
-# include <wctype.h>
-#endif
-
-/* Comment out all this code if we are using the GNU C Library, and are not
-   actually compiling the library itself.  This code is part of the GNU C
-   Library, but also included in many other GNU distributions.  Compiling
-   and linking in this code is a waste when using the GNU C library
-   (especially if it is a shared library).  Rather than having every GNU
-   program understand `configure --with-gnu-libc' and omit the object files,
-   it is simpler to just do this in the source for each such file.  */
-
-#if defined _LIBC || !defined __GNU_LIBRARY__
-
-
-# if defined STDC_HEADERS || !defined isascii
-#  define ISASCII(c) 1
-# else
-#  define ISASCII(c) isascii(c)
-# endif
-
-# ifdef isblank
-#  define ISBLANK(c) (ISASCII (c) && isblank (c))
-# else
-#  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
-# endif
-# ifdef isgraph
-#  define ISGRAPH(c) (ISASCII (c) && isgraph (c))
-# else
-#  define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
-# endif
-
-# define ISPRINT(c) (ISASCII (c) && isprint (c))
-# define ISDIGIT(c) (ISASCII (c) && isdigit (c))
-# define ISALNUM(c) (ISASCII (c) && isalnum (c))
-# define ISALPHA(c) (ISASCII (c) && isalpha (c))
-# define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
-# define ISLOWER(c) (ISASCII (c) && islower (c))
-# define ISPUNCT(c) (ISASCII (c) && ispunct (c))
-# define ISSPACE(c) (ISASCII (c) && isspace (c))
-# define ISUPPER(c) (ISASCII (c) && isupper (c))
-# define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
-
-# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
-
-# if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
-/* The GNU C library provides support for user-defined character classes
-   and the functions from ISO C amendement 1.  */
-#  ifdef CHARCLASS_NAME_MAX
-#   define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
-#  else
-/* This shouldn't happen but some implementation might still have this
-   problem.  Use a reasonable default value.  */
-#   define CHAR_CLASS_MAX_LENGTH 256
-#  endif
-
-#  ifdef _LIBC
-#   define IS_CHAR_CLASS(string) __wctype (string)
-#  else
-#   define IS_CHAR_CLASS(string) wctype (string)
-#  endif
-# else
-#  define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
-
-#  define IS_CHAR_CLASS(string)						      \
-   (STREQ (string, "alpha") || STREQ (string, "upper")			      \
-    || STREQ (string, "lower") || STREQ (string, "digit")		      \
-    || STREQ (string, "alnum") || STREQ (string, "xdigit")		      \
-    || STREQ (string, "space") || STREQ (string, "print")		      \
-    || STREQ (string, "punct") || STREQ (string, "graph")		      \
-    || STREQ (string, "cntrl") || STREQ (string, "blank"))
-# endif
-
-/* Avoid depending on library functions or files
-   whose names are inconsistent.  */
-
-# if !defined _LIBC && !defined getenv
-extern char *getenv ();
-# endif
-
-# ifndef errno
-extern int errno;
-# endif
-
-/* This function doesn't exist on most systems.  */
-
-# if !defined HAVE___STRCHRNUL && !defined _LIBC
-static char *
-__strchrnul (s, c)
-     const char *s;
-     int c;
-{
-  char *result = strchr (s, c);
-  if (result == NULL)
-    result = strchr (s, '\0');
-  return result;
-}
-# endif
-
-# ifndef internal_function
-/* Inside GNU libc we mark some function in a special way.  In other
-   environments simply ignore the marking.  */
-#  define internal_function
-# endif
-
-/* Match STRING against the filename pattern PATTERN, returning zero if
-   it matches, nonzero if not.  */
-static int internal_fnmatch __P ((const char *pattern, const char *string,
-				  int no_leading_period, int flags))
-     internal_function;
-static int
-internal_function
-internal_fnmatch (pattern, string, no_leading_period, flags)
-     const char *pattern;
-     const char *string;
-     int no_leading_period;
-     int flags;
-{
-  register const char *p = pattern, *n = string;
-  register unsigned char c;
-
-/* Note that this evaluates C many times.  */
-# ifdef _LIBC
-#  define FOLD(c) ((flags & FNM_CASEFOLD) ? tolower (c) : (c))
-# else
-#  define FOLD(c) ((flags & FNM_CASEFOLD) && ISUPPER (c) ? tolower (c) : (c))
-# endif
-
-  while ((c = *p++) != '\0')
-    {
-      c = FOLD (c);
-
-      switch (c)
-	{
-	case '?':
-	  if (*n == '\0')
-	    return FNM_NOMATCH;
-	  else if (*n == '/' && (flags & FNM_FILE_NAME))
-	    return FNM_NOMATCH;
-	  else if (*n == '.' && no_leading_period
-		   && (n == string
-		       || (n[-1] == '/' && (flags & FNM_FILE_NAME))))
-	    return FNM_NOMATCH;
-	  break;
-
-	case '\\':
-	  if (!(flags & FNM_NOESCAPE))
-	    {
-	      c = *p++;
-	      if (c == '\0')
-		/* Trailing \ loses.  */
-		return FNM_NOMATCH;
-	      c = FOLD (c);
-	    }
-	  if (FOLD ((unsigned char) *n) != c)
-	    return FNM_NOMATCH;
-	  break;
-
-	case '*':
-	  if (*n == '.' && no_leading_period
-	      && (n == string
-		  || (n[-1] == '/' && (flags & FNM_FILE_NAME))))
-	    return FNM_NOMATCH;
-
-	  for (c = *p++; c == '?' || c == '*'; c = *p++)
-	    {
-	      if (*n == '/' && (flags & FNM_FILE_NAME))
-		/* A slash does not match a wildcard under FNM_FILE_NAME.  */
-		return FNM_NOMATCH;
-	      else if (c == '?')
-		{
-		  /* A ? needs to match one character.  */
-		  if (*n == '\0')
-		    /* There isn't another character; no match.  */
-		    return FNM_NOMATCH;
-		  else
-		    /* One character of the string is consumed in matching
-		       this ? wildcard, so *??? won't match if there are
-		       less than three characters.  */
-		    ++n;
-		}
-	    }
-
-	  if (c == '\0')
-	    /* The wildcard(s) is/are the last element of the pattern.
-	       If the name is a file name and contains another slash
-	       this does mean it cannot match.  */
-	    return ((flags & FNM_FILE_NAME) && strchr (n, '/') != NULL
-		    ? FNM_NOMATCH : 0);
-	  else
-	    {
-	      const char *endp;
-
-	      endp = __strchrnul (n, (flags & FNM_FILE_NAME) ? '/' : '\0');
-
-	      if (c == '[')
-		{
-		  int flags2 = ((flags & FNM_FILE_NAME)
-				? flags : (flags & ~FNM_PERIOD));
-
-		  for (--p; n < endp; ++n)
-		    if (internal_fnmatch (p, n,
-					  (no_leading_period
-					   && (n == string
-					       || (n[-1] == '/'
-						   && (flags
-						       & FNM_FILE_NAME)))),
-					  flags2)
-			== 0)
-		      return 0;
-		}
-	      else if (c == '/' && (flags & FNM_FILE_NAME))
-		{
-		  while (*n != '\0' && *n != '/')
-		    ++n;
-		  if (*n == '/'
-		      && (internal_fnmatch (p, n + 1, flags & FNM_PERIOD,
-					    flags) == 0))
-		    return 0;
-		}
-	      else
-		{
-		  int flags2 = ((flags & FNM_FILE_NAME)
-				? flags : (flags & ~FNM_PERIOD));
-
-		  if (c == '\\' && !(flags & FNM_NOESCAPE))
-		    c = *p;
-		  c = FOLD (c);
-		  for (--p; n < endp; ++n)
-		    if (FOLD ((unsigned char) *n) == c
-			&& (internal_fnmatch (p, n,
-					      (no_leading_period
-					       && (n == string
-						   || (n[-1] == '/'
-						       && (flags
-							   & FNM_FILE_NAME)))),
-					      flags2) == 0))
-		      return 0;
-		}
-	    }
-
-	  /* If we come here no match is possible with the wildcard.  */
-	  return FNM_NOMATCH;
-
-	case '[':
-	  {
-	    /* Nonzero if the sense of the character class is inverted.  */
-	    static int posixly_correct;
-	    register int not;
-	    char cold;
-
-	    if (posixly_correct == 0)
-	      posixly_correct = getenv ("POSIXLY_CORRECT") != NULL ? 1 : -1;
-
-	    if (*n == '\0')
-	      return FNM_NOMATCH;
-
-	    if (*n == '.' && no_leading_period && (n == string
-						   || (n[-1] == '/'
-						       && (flags
-							   & FNM_FILE_NAME))))
-	      return FNM_NOMATCH;
-
-	    if (*n == '/' && (flags & FNM_FILE_NAME))
-	      /* `/' cannot be matched.  */
-	      return FNM_NOMATCH;
-
-	    not = (*p == '!' || (posixly_correct < 0 && *p == '^'));
-	    if (not)
-	      ++p;
-
-	    c = *p++;
-	    for (;;)
-	      {
-		unsigned char fn = FOLD ((unsigned char) *n);
-
-		if (!(flags & FNM_NOESCAPE) && c == '\\')
-		  {
-		    if (*p == '\0')
-		      return FNM_NOMATCH;
-		    c = FOLD ((unsigned char) *p);
-		    ++p;
-
-		    if (c == fn)
-		      goto matched;
-		  }
-		else if (c == '[' && *p == ':')
-		  {
-		    /* Leave room for the null.  */
-		    char str[CHAR_CLASS_MAX_LENGTH + 1];
-		    size_t c1 = 0;
-# if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
-		    wctype_t wt;
-# endif
-		    const char *startp = p;
-
-		    for (;;)
-		      {
-			if (c1 == CHAR_CLASS_MAX_LENGTH)
-			  /* The name is too long and therefore the pattern
-			     is ill-formed.  */
-			  return FNM_NOMATCH;
-
-			c = *++p;
-			if (c == ':' && p[1] == ']')
-			  {
-			    p += 2;
-			    break;
-			  }
-			if (c < 'a' || c >= 'z')
-			  {
-			    /* This cannot possibly be a character class name.
-			       Match it as a normal range.  */
-			    p = startp;
-			    c = '[';
-			    goto normal_bracket;
-			  }
-			str[c1++] = c;
-		      }
-		    str[c1] = '\0';
-
-# if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
-		    wt = IS_CHAR_CLASS (str);
-		    if (wt == 0)
-		      /* Invalid character class name.  */
-		      return FNM_NOMATCH;
-
-		    if (__iswctype (__btowc ((unsigned char) *n), wt))
-		      goto matched;
-# else
-		    if ((STREQ (str, "alnum") && ISALNUM ((unsigned char) *n))
-			|| (STREQ (str, "alpha") && ISALPHA ((unsigned char) *n))
-			|| (STREQ (str, "blank") && ISBLANK ((unsigned char) *n))
-			|| (STREQ (str, "cntrl") && ISCNTRL ((unsigned char) *n))
-			|| (STREQ (str, "digit") && ISDIGIT ((unsigned char) *n))
-			|| (STREQ (str, "graph") && ISGRAPH ((unsigned char) *n))
-			|| (STREQ (str, "lower") && ISLOWER ((unsigned char) *n))
-			|| (STREQ (str, "print") && ISPRINT ((unsigned char) *n))
-			|| (STREQ (str, "punct") && ISPUNCT ((unsigned char) *n))
-			|| (STREQ (str, "space") && ISSPACE ((unsigned char) *n))
-			|| (STREQ (str, "upper") && ISUPPER ((unsigned char) *n))
-			|| (STREQ (str, "xdigit") && ISXDIGIT ((unsigned char) *n)))
-		      goto matched;
-# endif
-		  }
-		else if (c == '\0')
-		  /* [ (unterminated) loses.  */
-		  return FNM_NOMATCH;
-		else
-		  {
-		  normal_bracket:
-		    if (FOLD (c) == fn)
-		      goto matched;
-
-		    cold = c;
-		    c = *p++;
-
-		    if (c == '-' && *p != ']')
-		      {
-			/* It is a range.  */
-			unsigned char cend = *p++;
-			if (!(flags & FNM_NOESCAPE) && cend == '\\')
-			  cend = *p++;
-			if (cend == '\0')
-			  return FNM_NOMATCH;
-
-			if (cold <= fn && fn <= FOLD (cend))
-			  goto matched;
-
-			c = *p++;
-		      }
-		  }
-
-		if (c == ']')
-		  break;
-	      }
-
-	    if (!not)
-	      return FNM_NOMATCH;
-	    break;
-
-	  matched:
-	    /* Skip the rest of the [...] that already matched.  */
-	    while (c != ']')
-	      {
-		if (c == '\0')
-		  /* [... (unterminated) loses.  */
-		  return FNM_NOMATCH;
-
-		c = *p++;
-		if (!(flags & FNM_NOESCAPE) && c == '\\')
-		  {
-		    if (*p == '\0')
-		      return FNM_NOMATCH;
-		    /* XXX 1003.2d11 is unclear if this is right.  */
-		    ++p;
-		  }
-		else if (c == '[' && *p == ':')
-		  {
-		    do
-		      if (*++p == '\0')
-			return FNM_NOMATCH;
-		    while (*p != ':' || p[1] == ']');
-		    p += 2;
-		    c = *p;
-		  }
-	      }
-	    if (not)
-	      return FNM_NOMATCH;
-	  }
-	  break;
-
-	default:
-	  if (c != FOLD ((unsigned char) *n))
-	    return FNM_NOMATCH;
-	}
-
-      ++n;
-    }
-
-  if (*n == '\0')
-    return 0;
-
-  if ((flags & FNM_LEADING_DIR) && *n == '/')
-    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
-    return 0;
-
-  return FNM_NOMATCH;
-
-# undef FOLD
-}
-
-
-int
-fnmatch (pattern, string, flags)
-     const char *pattern;
-     const char *string;
-     int flags;
-{
-  return internal_fnmatch (pattern, string, flags & FNM_PERIOD, flags);
-}
-
-#endif	/* _LIBC or not __GNU_LIBRARY__.  */
diff --git a/glob/fnmatch.h b/glob/fnmatch.h
deleted file mode 100644
--- a/glob/fnmatch.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/* Copyright (C) 1991, 92, 93, 96, 97, 98, 99 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-#ifndef	_FNMATCH_H
-#define	_FNMATCH_H	1
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#if defined __cplusplus || (defined __STDC__ && __STDC__) || defined WINDOWS32
-# if !defined __GLIBC__ || !defined __P
-#  undef	__P
-#  define __P(protos)	protos
-# endif
-#else /* Not C++ or ANSI C.  */
-# undef	__P
-# define __P(protos)	()
-/* We can get away without defining `const' here only because in this file
-   it is used only inside the prototype for `fnmatch', which is elided in
-   non-ANSI C where `const' is problematical.  */
-#endif /* C++ or ANSI C.  */
-
-#ifndef const
-# if (defined __STDC__ && __STDC__) || defined __cplusplus
-#  define __const	const
-# else
-#  define __const
-# endif
-#endif
-
-/* We #undef these before defining them because some losing systems
-   (HP-UX A.08.07 for example) define these in <unistd.h>.  */
-#undef	FNM_PATHNAME
-#undef	FNM_NOESCAPE
-#undef	FNM_PERIOD
-
-/* Bits set in the FLAGS argument to `fnmatch'.  */
-#define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
-#define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
-#define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
-
-#if !defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _GNU_SOURCE
-# define FNM_FILE_NAME	 FNM_PATHNAME	/* Preferred GNU name.  */
-# define FNM_LEADING_DIR (1 << 3)	/* Ignore `/...' after a match.  */
-# define FNM_CASEFOLD	 (1 << 4)	/* Compare without regard to case.  */
-#endif
-
-/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
-#define	FNM_NOMATCH	1
-
-/* This value is returned if the implementation does not support
-   `fnmatch'.  Since this is not the case here it will never be
-   returned but the conformance test suites still require the symbol
-   to be defined.  */
-#ifdef _XOPEN_SOURCE
-# define FNM_NOSYS	(-1)
-#endif
-
-/* Match NAME against the filename pattern PATTERN,
-   returning zero if it matches, FNM_NOMATCH if not.  */
-extern int fnmatch __P ((__const char *__pattern, __const char *__name,
-			 int __flags));
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* fnmatch.h */
diff --git a/glob/glob.c b/glob/glob.c
deleted file mode 100644
--- a/glob/glob.c
+++ /dev/null
@@ -1,1428 +0,0 @@
-/* Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with this library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* AIX requires this to be the first thing in the file.  */
-#if defined _AIX && !defined __GNUC__
- #pragma alloca
-#endif
-
-#ifdef	HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-/* Enable GNU extensions in glob.h.  */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE	1
-#endif
-
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-/* Outcomment the following line for production quality code.  */
-/* #define NDEBUG 1 */
-#include <assert.h>
-
-#include <stdio.h>		/* Needed on stupid SunOS for assert.  */
-
-
-/* Comment out all this code if we are using the GNU C Library, and are not
-   actually compiling the library itself.  This code is part of the GNU C
-   Library, but also included in many other GNU distributions.  Compiling
-   and linking in this code is a waste when using the GNU C library
-   (especially if it is a shared library).  Rather than having every GNU
-   program understand `configure --with-gnu-libc' and omit the object files,
-   it is simpler to just do this in the source for each such file.  */
-
-#define GLOB_INTERFACE_VERSION 1
-#if !defined _LIBC && defined __GNU_LIBRARY__ && __GNU_LIBRARY__ > 1
-# include <gnu-versions.h>
-# if _GNU_GLOB_INTERFACE_VERSION == GLOB_INTERFACE_VERSION
-#  define ELIDE_CODE
-# endif
-#endif
-
-#ifndef ELIDE_CODE
-
-#if defined STDC_HEADERS || defined __GNU_LIBRARY__
-# include <stddef.h>
-#endif
-
-#if defined HAVE_UNISTD_H || defined _LIBC
-# include <unistd.h>
-# ifndef POSIX
-#  ifdef _POSIX_VERSION
-#   define POSIX
-#  endif
-# endif
-#endif
-
-#if !defined _AMIGA && !defined VMS && !defined WINDOWS32
-# include <pwd.h>
-#endif
-
-#if !defined __GNU_LIBRARY__ && !defined STDC_HEADERS
-extern int errno;
-#endif
-#ifndef __set_errno
-# define __set_errno(val) errno = (val)
-#endif
-
-#ifndef	NULL
-# define NULL	0
-#endif
-
-
-#if defined HAVE_DIRENT_H || defined __GNU_LIBRARY__
-# include <dirent.h>
-# define NAMLEN(dirent) strlen((dirent)->d_name)
-#else
-# define dirent direct
-# define NAMLEN(dirent) (dirent)->d_namlen
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-# ifdef HAVE_VMSDIR_H
-#  include "vmsdir.h"
-# endif /* HAVE_VMSDIR_H */
-#endif
-
-
-/* In GNU systems, <dirent.h> defines this macro for us.  */
-#ifdef _D_NAMLEN
-# undef NAMLEN
-# define NAMLEN(d) _D_NAMLEN(d)
-#endif
-
-/* When used in the GNU libc the symbol _DIRENT_HAVE_D_TYPE is available
-   if the `d_type' member for `struct dirent' is available.  */
-#ifdef _DIRENT_HAVE_D_TYPE
-# define HAVE_D_TYPE	1
-#endif
-
-
-#if (defined POSIX || defined WINDOWS32) && !defined __GNU_LIBRARY__
-/* Posix does not require that the d_ino field be present, and some
-   systems do not provide it. */
-# define REAL_DIR_ENTRY(dp) 1
-#else
-# define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
-#endif /* POSIX */
-
-#if defined STDC_HEADERS || defined __GNU_LIBRARY__
-# include <stdlib.h>
-# include <string.h>
-# define	ANSI_STRING
-#else	/* No standard headers.  */
-
-extern char *getenv ();
-
-# ifdef HAVE_STRING_H
-#  include <string.h>
-#  define ANSI_STRING
-# else
-#  include <strings.h>
-# endif
-# ifdef	HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-
-extern char *malloc (), *realloc ();
-extern void free ();
-
-extern void qsort ();
-extern void abort (), exit ();
-
-#endif	/* Standard headers.  */
-
-#ifndef	ANSI_STRING
-
-# ifndef bzero
-extern void bzero ();
-# endif
-# ifndef bcopy
-extern void bcopy ();
-# endif
-
-# define memcpy(d, s, n)	bcopy ((s), (d), (n))
-# define strrchr	rindex
-/* memset is only used for zero here, but let's be paranoid.  */
-# define memset(s, better_be_zero, n) \
-  ((void) ((better_be_zero) == 0 ? (bzero((s), (n)), 0) : (abort(), 0)))
-#endif	/* Not ANSI_STRING.  */
-
-#if !defined HAVE_STRCOLL && !defined _LIBC
-# define strcoll	strcmp
-#endif
-
-#if !defined HAVE_MEMPCPY && __GLIBC__ - 0 == 2 && __GLIBC_MINOR__ >= 1
-# define HAVE_MEMPCPY	1
-# undef  mempcpy
-# define mempcpy(Dest, Src, Len) __mempcpy (Dest, Src, Len)
-#endif
-
-#ifndef	__GNU_LIBRARY__
-# ifdef	__GNUC__
-__inline
-# endif
-# ifndef __SASC
-#  ifdef WINDOWS32
-static void *
-#  else
-static char *
-# endif
-my_realloc (p, n)
-     char *p;
-     unsigned int n;
-{
-  /* These casts are the for sake of the broken Ultrix compiler,
-     which warns of illegal pointer combinations otherwise.  */
-  if (p == NULL)
-    return (char *) malloc (n);
-  return (char *) realloc (p, n);
-}
-# define	realloc	my_realloc
-# endif /* __SASC */
-#endif /* __GNU_LIBRARY__ */
-
-
-#if !defined __alloca && !defined __GNU_LIBRARY__
-
-# ifdef	__GNUC__
-#  undef alloca
-#  define alloca(n)	__builtin_alloca (n)
-# else	/* Not GCC.  */
-#  ifdef HAVE_ALLOCA_H
-#   include <alloca.h>
-#  else	/* Not HAVE_ALLOCA_H.  */
-#   ifndef _AIX
-#    ifdef WINDOWS32
-#     include <malloc.h>
-#    else
-extern char *alloca ();
-#    endif /* WINDOWS32 */
-#   endif /* Not _AIX.  */
-#  endif /* sparc or HAVE_ALLOCA_H.  */
-# endif	/* GCC.  */
-
-# define __alloca	alloca
-
-#endif
-
-#ifndef __GNU_LIBRARY__
-# define __stat stat
-# ifdef STAT_MACROS_BROKEN
-#  undef S_ISDIR
-# endif
-# ifndef S_ISDIR
-#  define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
-# endif
-#endif
-
-#ifdef _LIBC
-# undef strdup
-# define strdup(str) __strdup (str)
-# define sysconf(id) __sysconf (id)
-# define closedir(dir) __closedir (dir)
-# define opendir(name) __opendir (name)
-# define readdir(str) __readdir (str)
-# define getpwnam_r(name, bufp, buf, len, res) \
-   __getpwnam_r (name, bufp, buf, len, res)
-# ifndef __stat
-#  define __stat(fname, buf) __xstat (_STAT_VER, fname, buf)
-# endif
-#endif
-
-#if !(defined STDC_HEADERS || defined __GNU_LIBRARY__)
-# undef	size_t
-# define size_t	unsigned int
-#endif
-
-/* Some system header files erroneously define these.
-   We want our own definitions from <fnmatch.h> to take precedence.  */
-#ifndef __GNU_LIBRARY__
-# undef	FNM_PATHNAME
-# undef	FNM_NOESCAPE
-# undef	FNM_PERIOD
-#endif
-#include <fnmatch.h>
-
-/* Some system header files erroneously define these.
-   We want our own definitions from <glob.h> to take precedence.  */
-#ifndef __GNU_LIBRARY__
-# undef	GLOB_ERR
-# undef	GLOB_MARK
-# undef	GLOB_NOSORT
-# undef	GLOB_DOOFFS
-# undef	GLOB_NOCHECK
-# undef	GLOB_APPEND
-# undef	GLOB_NOESCAPE
-# undef	GLOB_PERIOD
-#endif
-#include <glob.h>
-
-#ifdef HAVE_GETLOGIN_R
-extern int getlogin_r __P ((char *, size_t));
-#else
-extern char *getlogin __P ((void));
-#endif
-
-static
-#if __GNUC__ - 0 >= 2
-inline
-#endif
-const char *next_brace_sub __P ((const char *begin));
-static int glob_in_dir __P ((const char *pattern, const char *directory,
-			     int flags,
-			     int (*errfunc) (const char *, int),
-			     glob_t *pglob));
-static int prefix_array __P ((const char *prefix, char **array, size_t n));
-static int collated_compare __P ((const __ptr_t, const __ptr_t));
-
-#ifdef VMS
-/* these compilers like prototypes */
-#if !defined _LIBC || !defined NO_GLOB_PATTERN_P
-int __glob_pattern_p (const char *pattern, int quote);
-#endif
-#endif
-
-/* Find the end of the sub-pattern in a brace expression.  We define
-   this as an inline function if the compiler permits.  */
-static
-#if __GNUC__ - 0 >= 2
-inline
-#endif
-const char *
-next_brace_sub (begin)
-     const char *begin;
-{
-  unsigned int depth = 0;
-  const char *cp = begin;
-
-  while (1)
-    {
-      if (depth == 0)
-	{
-	  if (*cp != ',' && *cp != '}' && *cp != '\0')
-	    {
-	      if (*cp == '{')
-		++depth;
-	      ++cp;
-	      continue;
-	    }
-	}
-      else
-	{
-	  while (*cp != '\0' && (*cp != '}' || depth > 0))
-	    {
-	      if (*cp == '}')
-		--depth;
-	      ++cp;
-	    }
-	  if (*cp == '\0')
-	    /* An incorrectly terminated brace expression.  */
-	    return NULL;
-
-	  continue;
-	}
-      break;
-    }
-
-  return cp;
-}
-
-/* Do glob searching for PATTERN, placing results in PGLOB.
-   The bits defined above may be set in FLAGS.
-   If a directory cannot be opened or read and ERRFUNC is not nil,
-   it is called with the pathname that caused the error, and the
-   `errno' value from the failing call; if it returns non-zero
-   `glob' returns GLOB_ABORTED; if it returns zero, the error is ignored.
-   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
-   Otherwise, `glob' returns zero.  */
-int
-glob (pattern, flags, errfunc, pglob)
-     const char *pattern;
-     int flags;
-     int (*errfunc) __P ((const char *, int));
-     glob_t *pglob;
-{
-  const char *filename;
-  const char *dirname;
-  size_t dirlen;
-  int status;
-  int oldcount;
-
-  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  if (flags & GLOB_BRACE)
-    {
-      const char *begin = strchr (pattern, '{');
-      if (begin != NULL)
-	{
-	  /* Allocate working buffer large enough for our work.  Note that
-	    we have at least an opening and closing brace.  */
-	  int firstc;
-	  char *alt_start;
-	  const char *p;
-	  const char *next;
-	  const char *rest;
-	  size_t rest_len;
-#ifdef __GNUC__
-	  char onealt[strlen (pattern) - 1];
-#else
-	  char *onealt = (char *) malloc (strlen (pattern) - 1);
-	  if (onealt == NULL)
-	    {
-	      if (!(flags & GLOB_APPEND))
-		globfree (pglob);
-	      return GLOB_NOSPACE;
-	    }
-#endif
-
-	  /* We know the prefix for all sub-patterns.  */
-#ifdef HAVE_MEMPCPY
-	  alt_start = mempcpy (onealt, pattern, begin - pattern);
-#else
-	  memcpy (onealt, pattern, begin - pattern);
-	  alt_start = &onealt[begin - pattern];
-#endif
-
-	  /* Find the first sub-pattern and at the same time find the
-	     rest after the closing brace.  */
-	  next = next_brace_sub (begin + 1);
-	  if (next == NULL)
-	    {
-	      /* It is an illegal expression.  */
-#ifndef __GNUC__
-	      free (onealt);
-#endif
-	      return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
-	    }
-
-	  /* Now find the end of the whole brace expression.  */
-	  rest = next;
-	  while (*rest != '}')
-	    {
-	      rest = next_brace_sub (rest + 1);
-	      if (rest == NULL)
-		{
-		  /* It is an illegal expression.  */
-#ifndef __GNUC__
-		  free (onealt);
-#endif
-		  return glob (pattern, flags & ~GLOB_BRACE, errfunc, pglob);
-		}
-	    }
-	  /* Please note that we now can be sure the brace expression
-	     is well-formed.  */
-	  rest_len = strlen (++rest) + 1;
-
-	  /* We have a brace expression.  BEGIN points to the opening {,
-	     NEXT points past the terminator of the first element, and END
-	     points past the final }.  We will accumulate result names from
-	     recursive runs for each brace alternative in the buffer using
-	     GLOB_APPEND.  */
-
-	  if (!(flags & GLOB_APPEND))
-	    {
-	      /* This call is to set a new vector, so clear out the
-		 vector so we can append to it.  */
-	      pglob->gl_pathc = 0;
-	      pglob->gl_pathv = NULL;
-	    }
-	  firstc = pglob->gl_pathc;
-
-	  p = begin + 1;
-	  while (1)
-	    {
-	      int result;
-
-	      /* Construct the new glob expression.  */
-#ifdef HAVE_MEMPCPY
-	      mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);
-#else
-	      memcpy (alt_start, p, next - p);
-	      memcpy (&alt_start[next - p], rest, rest_len);
-#endif
-
-	      result = glob (onealt,
-			     ((flags & ~(GLOB_NOCHECK|GLOB_NOMAGIC))
-			      | GLOB_APPEND), errfunc, pglob);
-
-	      /* If we got an error, return it.  */
-	      if (result && result != GLOB_NOMATCH)
-		{
-#ifndef __GNUC__
-		  free (onealt);
-#endif
-		  if (!(flags & GLOB_APPEND))
-		    globfree (pglob);
-		  return result;
-		}
-
-	      if (*next == '}')
-		/* We saw the last entry.  */
-		break;
-
-	      p = next + 1;
-	      next = next_brace_sub (p);
-	      assert (next != NULL);
-	    }
-
-#ifndef __GNUC__
-	  free (onealt);
-#endif
-
-	  if (pglob->gl_pathc != firstc)
-	    /* We found some entries.  */
-	    return 0;
-	  else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
-	    return GLOB_NOMATCH;
-	}
-    }
-
-  /* Find the filename.  */
-  filename = strrchr (pattern, '/');
-#if defined __MSDOS__ || defined WINDOWS32
-  /* The case of "d:pattern".  Since `:' is not allowed in
-     file names, we can safely assume that wherever it
-     happens in pattern, it signals the filename part.  This
-     is so we could some day support patterns like "[a-z]:foo".  */
-  if (filename == NULL)
-    filename = strchr (pattern, ':');
-#endif /* __MSDOS__ || WINDOWS32 */
-  if (filename == NULL)
-    {
-      /* This can mean two things: a simple name or "~name".  The later
-	 case is nothing but a notation for a directory.  */
-      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')
-	{
-	  dirname = pattern;
-	  dirlen = strlen (pattern);
-
-	  /* Set FILENAME to NULL as a special flag.  This is ugly but
-	     other solutions would require much more code.  We test for
-	     this special case below.  */
-	  filename = NULL;
-	}
-      else
-	{
-	  filename = pattern;
-#ifdef _AMIGA
-	  dirname = "";
-#else
-	  dirname = ".";
-#endif
-	  dirlen = 0;
-	}
-    }
-  else if (filename == pattern)
-    {
-      /* "/pattern".  */
-      dirname = "/";
-      dirlen = 1;
-      ++filename;
-    }
-  else
-    {
-      char *newp;
-      dirlen = filename - pattern;
-#if defined __MSDOS__ || defined WINDOWS32
-      if (*filename == ':'
-	  || (filename > pattern + 1 && filename[-1] == ':'))
-	{
-	  char *drive_spec;
-
-	  ++dirlen;
-	  drive_spec = (char *) __alloca (dirlen + 1);
-#ifdef HAVE_MEMPCPY
-	  *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';
-#else
-	  memcpy (drive_spec, pattern, dirlen);
-	  drive_spec[dirlen] = '\0';
-#endif
-	  /* For now, disallow wildcards in the drive spec, to
-	     prevent infinite recursion in glob.  */
-	  if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))
-	    return GLOB_NOMATCH;
-	  /* If this is "d:pattern", we need to copy `:' to DIRNAME
-	     as well.  If it's "d:/pattern", don't remove the slash
-	     from "d:/", since "d:" and "d:/" are not the same.*/
-	}
-#endif
-      newp = (char *) __alloca (dirlen + 1);
-#ifdef HAVE_MEMPCPY
-      *((char *) mempcpy (newp, pattern, dirlen)) = '\0';
-#else
-      memcpy (newp, pattern, dirlen);
-      newp[dirlen] = '\0';
-#endif
-      dirname = newp;
-      ++filename;
-
-      if (filename[0] == '\0'
-#if defined __MSDOS__ || defined WINDOWS32
-          && dirname[dirlen - 1] != ':'
-	  && (dirlen < 3 || dirname[dirlen - 2] != ':'
-	      || dirname[dirlen - 1] != '/')
-#endif
-	  && dirlen > 1)
-	/* "pattern/".  Expand "pattern", appending slashes.  */
-	{
-	  int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);
-	  if (val == 0)
-	    pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)
-			       | (flags & GLOB_MARK));
-	  return val;
-	}
-    }
-
-  if (!(flags & GLOB_APPEND))
-    {
-      pglob->gl_pathc = 0;
-      pglob->gl_pathv = NULL;
-    }
-
-  oldcount = pglob->gl_pathc;
-
-#ifndef VMS
-  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
-    {
-      if (dirname[1] == '\0' || dirname[1] == '/')
-	{
-	  /* Look up home directory.  */
-#ifdef VMS
-/* This isn't obvious, RTLs of DECC and VAXC know about "HOME" */
-          const char *home_dir = getenv ("SYS$LOGIN");
-#else
-          const char *home_dir = getenv ("HOME");
-#endif
-# ifdef _AMIGA
-	  if (home_dir == NULL || home_dir[0] == '\0')
-	    home_dir = "SYS:";
-# else
-#  ifdef WINDOWS32
-	  if (home_dir == NULL || home_dir[0] == '\0')
-            home_dir = "c:/users/default"; /* poor default */
-#  else
-#   ifdef VMS
-/* Again, this isn't obvious, if "HOME" isn't known "SYS$LOGIN" should be set */
-	  if (home_dir == NULL || home_dir[0] == '\0')
-	    home_dir = "SYS$DISK:[]";
-#   else
-	  if (home_dir == NULL || home_dir[0] == '\0')
-	    {
-	      int success;
-	      char *name;
-#   if defined HAVE_GETLOGIN_R || defined _LIBC
-	      size_t buflen = sysconf (_SC_LOGIN_NAME_MAX) + 1;
-
-	      if (buflen == 0)
-		/* `sysconf' does not support _SC_LOGIN_NAME_MAX.  Try
-		   a moderate value.  */
-		buflen = 20;
-	      name = (char *) __alloca (buflen);
-
-	      success = getlogin_r (name, buflen) >= 0;
-#   else
-	      success = (name = getlogin ()) != NULL;
-#   endif
-	      if (success)
-		{
-		  struct passwd *p;
-#   if defined HAVE_GETPWNAM_R || defined _LIBC
-		  size_t pwbuflen = sysconf (_SC_GETPW_R_SIZE_MAX);
-		  char *pwtmpbuf;
-		  struct passwd pwbuf;
-		  int save = errno;
-
-		  if (pwbuflen == -1)
-		    /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.
-		       Try a moderate value.  */
-		    pwbuflen = 1024;
-		  pwtmpbuf = (char *) __alloca (pwbuflen);
-
-		  while (getpwnam_r (name, &pwbuf, pwtmpbuf, pwbuflen, &p)
-			 != 0)
-		    {
-		      if (errno != ERANGE)
-			{
-			  p = NULL;
-			  break;
-			}
-		      pwbuflen *= 2;
-		      pwtmpbuf = (char *) __alloca (pwbuflen);
-		      __set_errno (save);
-		    }
-#   else
-		  p = getpwnam (name);
-#   endif
-		  if (p != NULL)
-		    home_dir = p->pw_dir;
-		}
-	    }
-	  if (home_dir == NULL || home_dir[0] == '\0')
-	    {
-	      if (flags & GLOB_TILDE_CHECK)
-		return GLOB_NOMATCH;
-	      else
-		home_dir = "~"; /* No luck.  */
-	    }
-#   endif /* VMS */
-#  endif /* WINDOWS32 */
-# endif
-	  /* Now construct the full directory.  */
-	  if (dirname[1] == '\0')
-	    dirname = home_dir;
-	  else
-	    {
-	      char *newp;
-	      size_t home_len = strlen (home_dir);
-	      newp = (char *) __alloca (home_len + dirlen);
-# ifdef HAVE_MEMPCPY
-	      mempcpy (mempcpy (newp, home_dir, home_len),
-		       &dirname[1], dirlen);
-# else
-	      memcpy (newp, home_dir, home_len);
-	      memcpy (&newp[home_len], &dirname[1], dirlen);
-# endif
-	      dirname = newp;
-	    }
-	}
-# if !defined _AMIGA && !defined WINDOWS32 && !defined VMS
-      else
-	{
-	  char *end_name = strchr (dirname, '/');
-	  const char *user_name;
-	  const char *home_dir;
-
-	  if (end_name == NULL)
-	    user_name = dirname + 1;
-	  else
-	    {
-	      char *newp;
-	      newp = (char *) __alloca (end_name - dirname);
-# ifdef HAVE_MEMPCPY
-	      *((char *) mempcpy (newp, dirname + 1, end_name - dirname))
-		= '\0';
-# else
-	      memcpy (newp, dirname + 1, end_name - dirname);
-	      newp[end_name - dirname - 1] = '\0';
-# endif
-	      user_name = newp;
-	    }
-
-	  /* Look up specific user's home directory.  */
-	  {
-	    struct passwd *p;
-#  if defined HAVE_GETPWNAM_R || defined _LIBC
-	    size_t buflen = sysconf (_SC_GETPW_R_SIZE_MAX);
-	    char *pwtmpbuf;
-	    struct passwd pwbuf;
-	    int save = errno;
-
-	    if (buflen == -1)
-	      /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.  Try a
-		 moderate value.  */
-	      buflen = 1024;
-	    pwtmpbuf = (char *) __alloca (buflen);
-
-	    while (getpwnam_r (user_name, &pwbuf, pwtmpbuf, buflen, &p) != 0)
-	      {
-		if (errno != ERANGE)
-		  {
-		    p = NULL;
-		    break;
-		  }
-		buflen *= 2;
-		pwtmpbuf = __alloca (buflen);
-		__set_errno (save);
-	      }
-#  else
-	    p = getpwnam (user_name);
-#  endif
-	    if (p != NULL)
-	      home_dir = p->pw_dir;
-	    else
-	      home_dir = NULL;
-	  }
-	  /* If we found a home directory use this.  */
-	  if (home_dir != NULL)
-	    {
-	      char *newp;
-	      size_t home_len = strlen (home_dir);
-	      size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-	      newp = (char *) __alloca (home_len + rest_len + 1);
-#  ifdef HAVE_MEMPCPY
-	      *((char *) mempcpy (mempcpy (newp, home_dir, home_len),
-				  end_name, rest_len)) = '\0';
-#  else
-	      memcpy (newp, home_dir, home_len);
-	      memcpy (&newp[home_len], end_name, rest_len);
-	      newp[home_len + rest_len] = '\0';
-#  endif
-	      dirname = newp;
-	    }
-	  else
-	    if (flags & GLOB_TILDE_CHECK)
-	      /* We have to regard it as an error if we cannot find the
-		 home directory.  */
-	      return GLOB_NOMATCH;
-	}
-# endif	/* Not Amiga && not WINDOWS32 && not VMS.  */
-    }
-#endif	/* Not VMS.  */
-
-  /* Now test whether we looked for "~" or "~NAME".  In this case we
-     can give the answer now.  */
-  if (filename == NULL)
-    {
-      struct stat st;
-
-      /* Return the directory if we don't check for error or if it exists.  */
-      if ((flags & GLOB_NOCHECK)
-	  || (((flags & GLOB_ALTDIRFUNC)
-	       ? (*pglob->gl_stat) (dirname, &st)
-	       : __stat (dirname, &st)) == 0
-	      && S_ISDIR (st.st_mode)))
-	{
-	  pglob->gl_pathv
-	    = (char **) realloc (pglob->gl_pathv,
-				 (pglob->gl_pathc +
-				  ((flags & GLOB_DOOFFS) ?
-				   pglob->gl_offs : 0) +
-				  1 + 1) *
-				 sizeof (char *));
-	  if (pglob->gl_pathv == NULL)
-	    return GLOB_NOSPACE;
-
-	  if (flags & GLOB_DOOFFS)
-	    while (pglob->gl_pathc < pglob->gl_offs)
-	      pglob->gl_pathv[pglob->gl_pathc++] = NULL;
-
-#if defined HAVE_STRDUP || defined _LIBC
-	  pglob->gl_pathv[pglob->gl_pathc] = strdup (dirname);
-#else
-	  {
-	    size_t len = strlen (dirname) + 1;
-	    char *dircopy = malloc (len);
-	    if (dircopy != NULL)
-	      pglob->gl_pathv[pglob->gl_pathc] = memcpy (dircopy, dirname,
-							 len);
-	  }
-#endif
-	  if (pglob->gl_pathv[pglob->gl_pathc] == NULL)
-	    {
-	      free (pglob->gl_pathv);
-	      return GLOB_NOSPACE;
-	    }
-	  pglob->gl_pathv[++pglob->gl_pathc] = NULL;
-	  pglob->gl_flags = flags;
-
-	  return 0;
-	}
-
-      /* Not found.  */
-      return GLOB_NOMATCH;
-    }
-
-  if (__glob_pattern_p (dirname, !(flags & GLOB_NOESCAPE)))
-    {
-      /* The directory name contains metacharacters, so we
-	 have to glob for the directory, and then glob for
-	 the pattern in each directory found.  */
-      glob_t dirs;
-      register int i;
-
-      status = glob (dirname,
-		     ((flags & (GLOB_ERR | GLOB_NOCHECK | GLOB_NOESCAPE))
-		      | GLOB_NOSORT | GLOB_ONLYDIR),
-		     errfunc, &dirs);
-      if (status != 0)
-	return status;
-
-      /* We have successfully globbed the preceding directory name.
-	 For each name we found, call glob_in_dir on it and FILENAME,
-	 appending the results to PGLOB.  */
-      for (i = 0; i < dirs.gl_pathc; ++i)
-	{
-	  int old_pathc;
-
-#ifdef	SHELL
-	  {
-	    /* Make globbing interruptible in the bash shell. */
-	    extern int interrupt_state;
-
-	    if (interrupt_state)
-	      {
-		globfree (&dirs);
-		globfree (&files);
-		return GLOB_ABORTED;
-	      }
-	  }
-#endif /* SHELL.  */
-
-	  old_pathc = pglob->gl_pathc;
-	  status = glob_in_dir (filename, dirs.gl_pathv[i],
-				((flags | GLOB_APPEND)
-				 & ~(GLOB_NOCHECK | GLOB_ERR)),
-				errfunc, pglob);
-	  if (status == GLOB_NOMATCH)
-	    /* No matches in this directory.  Try the next.  */
-	    continue;
-
-	  if (status != 0)
-	    {
-	      globfree (&dirs);
-	      globfree (pglob);
-	      return status;
-	    }
-
-	  /* Stick the directory on the front of each name.  */
-	  if (prefix_array (dirs.gl_pathv[i],
-			    &pglob->gl_pathv[old_pathc],
-			    pglob->gl_pathc - old_pathc))
-	    {
-	      globfree (&dirs);
-	      globfree (pglob);
-	      return GLOB_NOSPACE;
-	    }
-	}
-
-      flags |= GLOB_MAGCHAR;
-
-      /* We have ignored the GLOB_NOCHECK flag in the `glob_in_dir' calls.
-	 But if we have not found any matching entry and thie GLOB_NOCHECK
-	 flag was set we must return the list consisting of the disrectory
-	 names followed by the filename.  */
-      if (pglob->gl_pathc == oldcount)
-	{
-	  /* No matches.  */
-	  if (flags & GLOB_NOCHECK)
-	    {
-	      size_t filename_len = strlen (filename) + 1;
-	      char **new_pathv;
-	      struct stat st;
-
-	      /* This is an pessimistic guess about the size.  */
-	      pglob->gl_pathv
-		= (char **) realloc (pglob->gl_pathv,
-				     (pglob->gl_pathc +
-				      ((flags & GLOB_DOOFFS) ?
-				       pglob->gl_offs : 0) +
-				      dirs.gl_pathc + 1) *
-				     sizeof (char *));
-	      if (pglob->gl_pathv == NULL)
-		{
-		  globfree (&dirs);
-		  return GLOB_NOSPACE;
-		}
-
-	      if (flags & GLOB_DOOFFS)
-		while (pglob->gl_pathc < pglob->gl_offs)
-		  pglob->gl_pathv[pglob->gl_pathc++] = NULL;
-
-	      for (i = 0; i < dirs.gl_pathc; ++i)
-		{
-		  const char *dir = dirs.gl_pathv[i];
-		  size_t dir_len = strlen (dir);
-
-		  /* First check whether this really is a directory.  */
-		  if (((flags & GLOB_ALTDIRFUNC)
-		       ? (*pglob->gl_stat) (dir, &st) : __stat (dir, &st)) != 0
-		      || !S_ISDIR (st.st_mode))
-		    /* No directory, ignore this entry.  */
-		    continue;
-
-		  pglob->gl_pathv[pglob->gl_pathc] = malloc (dir_len + 1
-							     + filename_len);
-		  if (pglob->gl_pathv[pglob->gl_pathc] == NULL)
-		    {
-		      globfree (&dirs);
-		      globfree (pglob);
-		      return GLOB_NOSPACE;
-		    }
-
-#ifdef HAVE_MEMPCPY
-		  mempcpy (mempcpy (mempcpy (pglob->gl_pathv[pglob->gl_pathc],
-					     dir, dir_len),
-				    "/", 1),
-			   filename, filename_len);
-#else
-		  memcpy (pglob->gl_pathv[pglob->gl_pathc], dir, dir_len);
-		  pglob->gl_pathv[pglob->gl_pathc][dir_len] = '/';
-		  memcpy (&pglob->gl_pathv[pglob->gl_pathc][dir_len + 1],
-			  filename, filename_len);
-#endif
-		  ++pglob->gl_pathc;
-		}
-
-	      pglob->gl_pathv[pglob->gl_pathc] = NULL;
-	      pglob->gl_flags = flags;
-
-	      /* Now we know how large the gl_pathv vector must be.  */
-	      new_pathv = (char **) realloc (pglob->gl_pathv,
-					     ((pglob->gl_pathc + 1)
-					      * sizeof (char *)));
-	      if (new_pathv != NULL)
-		pglob->gl_pathv = new_pathv;
-	    }
-	  else
-	    return GLOB_NOMATCH;
-	}
-
-      globfree (&dirs);
-    }
-  else
-    {
-      status = glob_in_dir (filename, dirname, flags, errfunc, pglob);
-      if (status != 0)
-	return status;
-
-      if (dirlen > 0)
-	{
-	  /* Stick the directory on the front of each name.  */
-	  int ignore = oldcount;
-
-	  if ((flags & GLOB_DOOFFS) && ignore < pglob->gl_offs)
-	    ignore = pglob->gl_offs;
-
-	  if (prefix_array (dirname,
-			    &pglob->gl_pathv[ignore],
-			    pglob->gl_pathc - ignore))
-	    {
-	      globfree (pglob);
-	      return GLOB_NOSPACE;
-	    }
-	}
-    }
-
-  if (flags & GLOB_MARK)
-    {
-      /* Append slashes to directory names.  */
-      int i;
-      struct stat st;
-      for (i = oldcount; i < pglob->gl_pathc; ++i)
-	if (((flags & GLOB_ALTDIRFUNC)
-	     ? (*pglob->gl_stat) (pglob->gl_pathv[i], &st)
-	     : __stat (pglob->gl_pathv[i], &st)) == 0
-	    && S_ISDIR (st.st_mode))
-	  {
- 	    size_t len = strlen (pglob->gl_pathv[i]) + 2;
-	    char *new = realloc (pglob->gl_pathv[i], len);
- 	    if (new == NULL)
-	      {
-		globfree (pglob);
-		return GLOB_NOSPACE;
-	      }
-	    strcpy (&new[len - 2], "/");
-	    pglob->gl_pathv[i] = new;
-	  }
-    }
-
-  if (!(flags & GLOB_NOSORT))
-    {
-      /* Sort the vector.  */
-      int non_sort = oldcount;
-
-      if ((flags & GLOB_DOOFFS) && pglob->gl_offs > oldcount)
-	non_sort = pglob->gl_offs;
-
-      qsort ((__ptr_t) &pglob->gl_pathv[non_sort],
-	     pglob->gl_pathc - non_sort,
-	     sizeof (char *), collated_compare);
-    }
-
-  return 0;
-}
-
-
-/* Free storage allocated in PGLOB by a previous `glob' call.  */
-void
-globfree (pglob)
-     register glob_t *pglob;
-{
-  if (pglob->gl_pathv != NULL)
-    {
-      register int i;
-      for (i = 0; i < pglob->gl_pathc; ++i)
-	if (pglob->gl_pathv[i] != NULL)
-	  free ((__ptr_t) pglob->gl_pathv[i]);
-      free ((__ptr_t) pglob->gl_pathv);
-    }
-}
-
-
-/* Do a collated comparison of A and B.  */
-static int
-collated_compare (a, b)
-     const __ptr_t a;
-     const __ptr_t b;
-{
-  const char *const s1 = *(const char *const * const) a;
-  const char *const s2 = *(const char *const * const) b;
-
-  if (s1 == s2)
-    return 0;
-  if (s1 == NULL)
-    return 1;
-  if (s2 == NULL)
-    return -1;
-  return strcoll (s1, s2);
-}
-
-
-/* Prepend DIRNAME to each of N members of ARRAY, replacing ARRAY's
-   elements in place.  Return nonzero if out of memory, zero if successful.
-   A slash is inserted between DIRNAME and each elt of ARRAY,
-   unless DIRNAME is just "/".  Each old element of ARRAY is freed.  */
-static int
-prefix_array (dirname, array, n)
-     const char *dirname;
-     char **array;
-     size_t n;
-{
-  register size_t i;
-  size_t dirlen = strlen (dirname);
-#if defined __MSDOS__ || defined WINDOWS32
-  int sep_char = '/';
-# define DIRSEP_CHAR sep_char
-#else
-# define DIRSEP_CHAR '/'
-#endif
-
-  if (dirlen == 1 && dirname[0] == '/')
-    /* DIRNAME is just "/", so normal prepending would get us "//foo".
-       We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
-    dirlen = 0;
-#if defined __MSDOS__ || defined WINDOWS32
-  else if (dirlen > 1)
-    {
-      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')
-	/* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
-	--dirlen;
-      else if (dirname[dirlen - 1] == ':')
-	{
-	  /* DIRNAME is "d:".  Use `:' instead of `/'.  */
-	  --dirlen;
-	  sep_char = ':';
-	}
-    }
-#endif
-
-  for (i = 0; i < n; ++i)
-    {
-      size_t eltlen = strlen (array[i]) + 1;
-      char *new = (char *) malloc (dirlen + 1 + eltlen);
-      if (new == NULL)
-	{
-	  while (i > 0)
-	    free ((__ptr_t) array[--i]);
-	  return 1;
-	}
-
-#ifdef HAVE_MEMPCPY
-      {
-	char *endp = (char *) mempcpy (new, dirname, dirlen);
-	*endp++ = DIRSEP_CHAR;
-	mempcpy (endp, array[i], eltlen);
-      }
-#else
-      memcpy (new, dirname, dirlen);
-      new[dirlen] = DIRSEP_CHAR;
-      memcpy (&new[dirlen + 1], array[i], eltlen);
-#endif
-      free ((__ptr_t) array[i]);
-      array[i] = new;
-    }
-
-  return 0;
-}
-
-
-/* We must not compile this function twice.  */
-#if !defined _LIBC || !defined NO_GLOB_PATTERN_P
-/* Return nonzero if PATTERN contains any metacharacters.
-   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
-int
-__glob_pattern_p (pattern, quote)
-     const char *pattern;
-     int quote;
-{
-  register const char *p;
-  int open = 0;
-
-  for (p = pattern; *p != '\0'; ++p)
-    switch (*p)
-      {
-      case '?':
-      case '*':
-	return 1;
-
-      case '\\':
-	if (quote && p[1] != '\0')
-	  ++p;
-	break;
-
-      case '[':
-	open = 1;
-	break;
-
-      case ']':
-	if (open)
-	  return 1;
-	break;
-      }
-
-  return 0;
-}
-# ifdef _LIBC
-weak_alias (__glob_pattern_p, glob_pattern_p)
-# endif
-#endif
-
-
-/* Like `glob', but PATTERN is a final pathname component,
-   and matches are searched for in DIRECTORY.
-   The GLOB_NOSORT bit in FLAGS is ignored.  No sorting is ever done.
-   The GLOB_APPEND flag is assumed to be set (always appends).  */
-static int
-glob_in_dir (pattern, directory, flags, errfunc, pglob)
-     const char *pattern;
-     const char *directory;
-     int flags;
-     int (*errfunc) __P ((const char *, int));
-     glob_t *pglob;
-{
-  __ptr_t stream = NULL;
-
-  struct globlink
-    {
-      struct globlink *next;
-      char *name;
-    };
-  struct globlink *names = NULL;
-  size_t nfound;
-  int meta;
-  int save;
-
-#ifdef VMS
-  if (*directory == 0)
-    directory = "[]";
-#endif
-  meta = __glob_pattern_p (pattern, !(flags & GLOB_NOESCAPE));
-  if (meta == 0)
-    {
-      if (flags & (GLOB_NOCHECK|GLOB_NOMAGIC))
-	/* We need not do any tests.  The PATTERN contains no meta
-	   characters and we must not return an error therefore the
-	   result will always contain exactly one name.  */
-	flags |= GLOB_NOCHECK;
-      else
-	{
-	  /* Since we use the normal file functions we can also use stat()
-	     to verify the file is there.  */
-	  struct stat st;
-	  size_t patlen = strlen (pattern);
-	  size_t dirlen = strlen (directory);
-	  char *fullname = (char *) __alloca (dirlen + 1 + patlen + 1);
-
-# ifdef HAVE_MEMPCPY
-	  mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
-			    "/", 1),
-		   pattern, patlen + 1);
-# else
-	  memcpy (fullname, directory, dirlen);
-	  fullname[dirlen] = '/';
-	  memcpy (&fullname[dirlen + 1], pattern, patlen + 1);
-# endif
-	  if (((flags & GLOB_ALTDIRFUNC)
-	       ? (*pglob->gl_stat) (fullname, &st)
-	       : __stat (fullname, &st)) == 0)
-	    /* We found this file to be existing.  Now tell the rest
-	       of the function to copy this name into the result.  */
-	    flags |= GLOB_NOCHECK;
-	}
-
-      nfound = 0;
-    }
-  else
-    {
-      if (pattern[0] == '\0')
-	{
-	  /* This is a special case for matching directories like in
-	     "*a/".  */
-	  names = (struct globlink *) __alloca (sizeof (struct globlink));
-	  names->name = (char *) malloc (1);
-	  if (names->name == NULL)
-	    goto memory_error;
-	  names->name[0] = '\0';
-	  names->next = NULL;
-	  nfound = 1;
-	  meta = 0;
-	}
-      else
-	{
-	  stream = ((flags & GLOB_ALTDIRFUNC)
-		    ? (*pglob->gl_opendir) (directory)
-		    : (__ptr_t) opendir (directory));
-	  if (stream == NULL)
-	    {
-	      if (errno != ENOTDIR
-		  && ((errfunc != NULL && (*errfunc) (directory, errno))
-		      || (flags & GLOB_ERR)))
-		return GLOB_ABORTED;
-	      nfound = 0;
-	      meta = 0;
-	    }
-	  else
-	    {
-	      int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
-			       | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)
-#if defined _AMIGA || defined VMS
-				   | FNM_CASEFOLD
-#endif
-				   );
-	      nfound = 0;
-	      flags |= GLOB_MAGCHAR;
-
-	      while (1)
-		{
-		  const char *name;
-		  size_t len;
-		  struct dirent *d = ((flags & GLOB_ALTDIRFUNC)
-				      ? (*pglob->gl_readdir) (stream)
-				      : readdir ((DIR *) stream));
-		  if (d == NULL)
-		    break;
-		  if (! REAL_DIR_ENTRY (d))
-		    continue;
-
-#ifdef HAVE_D_TYPE
-		  /* If we shall match only directories use the information
-		     provided by the dirent call if possible.  */
-		  if ((flags & GLOB_ONLYDIR)
-		      && d->d_type != DT_UNKNOWN && d->d_type != DT_DIR)
-		    continue;
-#endif
-
-		  name = d->d_name;
-
-		  if (fnmatch (pattern, name, fnm_flags) == 0)
-		    {
-		      struct globlink *new = (struct globlink *)
-			__alloca (sizeof (struct globlink));
-		      len = NAMLEN (d);
-		      new->name = (char *) malloc (len + 1);
-		      if (new->name == NULL)
-			goto memory_error;
-#ifdef HAVE_MEMPCPY
-		      *((char *) mempcpy ((__ptr_t) new->name, name, len))
-			= '\0';
-#else
-		      memcpy ((__ptr_t) new->name, name, len);
-		      new->name[len] = '\0';
-#endif
-		      new->next = names;
-		      names = new;
-		      ++nfound;
-		    }
-		}
-	    }
-	}
-    }
-
-  if (nfound == 0 && (flags & GLOB_NOCHECK))
-    {
-      size_t len = strlen (pattern);
-      nfound = 1;
-      names = (struct globlink *) __alloca (sizeof (struct globlink));
-      names->next = NULL;
-      names->name = (char *) malloc (len + 1);
-      if (names->name == NULL)
-	goto memory_error;
-#ifdef HAVE_MEMPCPY
-      *((char *) mempcpy (names->name, pattern, len)) = '\0';
-#else
-      memcpy (names->name, pattern, len);
-      names->name[len] = '\0';
-#endif
-    }
-
-  if (nfound != 0)
-    {
-      pglob->gl_pathv
-	= (char **) realloc (pglob->gl_pathv,
-			     (pglob->gl_pathc +
-			      ((flags & GLOB_DOOFFS) ? pglob->gl_offs : 0) +
-			      nfound + 1) *
-			     sizeof (char *));
-      if (pglob->gl_pathv == NULL)
-	goto memory_error;
-
-      if (flags & GLOB_DOOFFS)
-	while (pglob->gl_pathc < pglob->gl_offs)
-	  pglob->gl_pathv[pglob->gl_pathc++] = NULL;
-
-      for (; names != NULL; names = names->next)
-	pglob->gl_pathv[pglob->gl_pathc++] = names->name;
-      pglob->gl_pathv[pglob->gl_pathc] = NULL;
-
-      pglob->gl_flags = flags;
-    }
-
-  save = errno;
-  if (stream != NULL)
-    {
-      if (flags & GLOB_ALTDIRFUNC)
-	(*pglob->gl_closedir) (stream);
-      else
-	closedir ((DIR *) stream);
-    }
-  __set_errno (save);
-
-  return nfound == 0 ? GLOB_NOMATCH : 0;
-
- memory_error:
-  {
-    int save = errno;
-    if (flags & GLOB_ALTDIRFUNC)
-      (*pglob->gl_closedir) (stream);
-    else
-      closedir ((DIR *) stream);
-    __set_errno (save);
-  }
-  while (names != NULL)
-    {
-      if (names->name != NULL)
-	free ((__ptr_t) names->name);
-      names = names->next;
-    }
-  return GLOB_NOSPACE;
-}
-
-#endif	/* Not ELIDE_CODE.  */
diff --git a/glob/glob.h b/glob/glob.h
deleted file mode 100644
--- a/glob/glob.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/* Copyright (C) 1991, 92, 95, 96, 97, 98 Free Software Foundation, Inc.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-#ifndef	_GLOB_H
-#define	_GLOB_H	1
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#undef	__ptr_t
-#if defined __cplusplus || (defined __STDC__ && __STDC__) || defined WINDOWS32
-# if !defined __GLIBC__ || !defined __P
-#  undef __P
-#  undef __PMT
-#  define __P(protos)	protos
-#  define __PMT(protos)	protos
-#  if !defined __GNUC__ || __GNUC__ < 2
-#   undef __const
-#   define __const const
-#  endif
-# endif
-# define __ptr_t	void *
-#else /* Not C++ or ANSI C.  */
-# undef	__P
-# undef __PMT
-# define __P(protos)	()
-# define __PMT(protos)	()
-# undef	__const
-# define __const
-# define __ptr_t	char *
-#endif /* C++ or ANSI C.  */
-
-/* We need `size_t' for the following definitions.  */
-#ifndef __size_t
-# if defined __GNUC__ && __GNUC__ >= 2
-typedef __SIZE_TYPE__ __size_t;
-# else
-/* This is a guess.  */
-/*hb
- *	Conflicts with DECCs aready defined type __size_t.
- *	Defining an own type with a name beginning with '__' is no good.
- *	Anyway if DECC is used and __SIZE_T is defined then __size_t is
- *	already defined (and I hope it's exactly the one we need here).
- */
-#if !(defined __DECC && defined __SIZE_T)
-typedef unsigned long int __size_t;
-#endif
-# endif
-#else
-/* The GNU CC stddef.h version defines __size_t as empty.  We need a real
-   definition.  */
-# undef __size_t
-# define __size_t size_t
-#endif
-
-/* Bits set in the FLAGS argument to `glob'.  */
-#define	GLOB_ERR	(1 << 0)/* Return on read errors.  */
-#define	GLOB_MARK	(1 << 1)/* Append a slash to each name.  */
-#define	GLOB_NOSORT	(1 << 2)/* Don't sort the names.  */
-#define	GLOB_DOOFFS	(1 << 3)/* Insert PGLOB->gl_offs NULLs.  */
-#define	GLOB_NOCHECK	(1 << 4)/* If nothing matches, return the pattern.  */
-#define	GLOB_APPEND	(1 << 5)/* Append to results of a previous call.  */
-#define	GLOB_NOESCAPE	(1 << 6)/* Backslashes don't quote metacharacters.  */
-#define	GLOB_PERIOD	(1 << 7)/* Leading `.' can be matched by metachars.  */
-
-#if (!defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _BSD_SOURCE \
-     || defined _GNU_SOURCE)
-# define GLOB_MAGCHAR	 (1 << 8)/* Set in gl_flags if any metachars seen.  */
-# define GLOB_ALTDIRFUNC (1 << 9)/* Use gl_opendir et al functions.  */
-# define GLOB_BRACE	 (1 << 10)/* Expand "{a,b}" to "a" "b".  */
-# define GLOB_NOMAGIC	 (1 << 11)/* If no magic chars, return the pattern.  */
-# define GLOB_TILDE	 (1 << 12)/* Expand ~user and ~ to home directories. */
-# define GLOB_ONLYDIR	 (1 << 13)/* Match only directories.  */
-# define GLOB_TILDE_CHECK (1 << 14)/* Like GLOB_TILDE but return an error
-				      if the user name is not available.  */
-# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
-			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
-			 GLOB_PERIOD|GLOB_ALTDIRFUNC|GLOB_BRACE|     \
-			 GLOB_NOMAGIC|GLOB_TILDE|GLOB_ONLYDIR|GLOB_TILDE_CHECK)
-#else
-# define __GLOB_FLAGS	(GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
-			 GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
-			 GLOB_PERIOD)
-#endif
-
-/* Error returns from `glob'.  */
-#define	GLOB_NOSPACE	1	/* Ran out of memory.  */
-#define	GLOB_ABORTED	2	/* Read error.  */
-#define	GLOB_NOMATCH	3	/* No matches found.  */
-#define GLOB_NOSYS	4	/* Not implemented.  */
-#ifdef _GNU_SOURCE
-/* Previous versions of this file defined GLOB_ABEND instead of
-   GLOB_ABORTED.  Provide a compatibility definition here.  */
-# define GLOB_ABEND GLOB_ABORTED
-#endif
-
-/* Structure describing a globbing run.  */
-#if !defined _AMIGA && !defined VMS /* Buggy compiler.   */
-struct stat;
-#endif
-typedef struct
-  {
-    __size_t gl_pathc;		/* Count of paths matched by the pattern.  */
-    char **gl_pathv;		/* List of matched pathnames.  */
-    __size_t gl_offs;		/* Slots to reserve in `gl_pathv'.  */
-    int gl_flags;		/* Set to FLAGS, maybe | GLOB_MAGCHAR.  */
-
-    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
-       are used instead of the normal file access functions.  */
-    void (*gl_closedir) __PMT ((void *));
-    struct dirent *(*gl_readdir) __PMT ((void *));
-    __ptr_t (*gl_opendir) __PMT ((__const char *));
-    int (*gl_lstat) __PMT ((__const char *, struct stat *));
-#if defined(VMS) && defined(__DECC) && !defined(_POSIX_C_SOURCE)
-    int (*gl_stat) __PMT ((__const char *, struct stat *, ...));
-#else
-    int (*gl_stat) __PMT ((__const char *, struct stat *));
-#endif
-  } glob_t;
-
-#ifdef _LARGEFILE64_SOURCE
-struct stat64;
-typedef struct
-  {
-    __size_t gl_pathc;
-    char **gl_pathv;
-    __size_t gl_offs;
-    int gl_flags;
-
-    /* If the GLOB_ALTDIRFUNC flag is set, the following functions
-       are used instead of the normal file access functions.  */
-    void (*gl_closedir) __PMT ((void *));
-    struct dirent64 *(*gl_readdir) __PMT ((void *));
-    __ptr_t (*gl_opendir) __PMT ((__const char *));
-    int (*gl_lstat) __PMT ((__const char *, struct stat64 *));
-    int (*gl_stat) __PMT ((__const char *, struct stat64 *));
-  } glob64_t;
-#endif
-
-#if _FILE_OFFSET_BITS == 64 && __GNUC__ < 2
-# define glob glob64
-# define globfree globfree64
-#else
-# ifdef _LARGEFILE64_SOURCE
-extern int glob64 __P ((__const char *__pattern, int __flags,
-			int (*__errfunc) (__const char *, int),
-			glob64_t *__pglob));
-
-extern void globfree64 __P ((glob64_t *__pglob));
-# endif
-#endif
-
-/* Do glob searching for PATTERN, placing results in PGLOB.
-   The bits defined above may be set in FLAGS.
-   If a directory cannot be opened or read and ERRFUNC is not nil,
-   it is called with the pathname that caused the error, and the
-   `errno' value from the failing call; if it returns non-zero
-   `glob' returns GLOB_ABEND; if it returns zero, the error is ignored.
-   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
-   Otherwise, `glob' returns zero.  */
-#if _FILE_OFFSET_BITS != 64 || __GNUC__ < 2
-extern int glob __P ((__const char *__pattern, int __flags,
-		      int (*__errfunc) (__const char *, int),
-		      glob_t *__pglob));
-
-/* Free storage allocated in PGLOB by a previous `glob' call.  */
-extern void globfree __P ((glob_t *__pglob));
-#else
-extern int glob __P ((__const char *__pattern, int __flags,
-		      int (*__errfunc) (__const char *, int),
-		      glob_t *__pglob)) __asm__ ("glob64");
-
-extern void globfree __P ((glob_t *__pglob)) __asm__ ("globfree64");
-#endif
-
-
-#ifdef _GNU_SOURCE
-/* Return nonzero if PATTERN contains any metacharacters.
-   Metacharacters can be quoted with backslashes if QUOTE is nonzero.
-
-   This function is not part of the interface specified by POSIX.2
-   but several programs want to use it.  */
-extern int glob_pattern_p __P ((__const char *__pattern, int __quote));
-#endif
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* glob.h  */
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,12 +1,16 @@
+2005-02-28  John W. Eaton  <jwe@octave.org>
+
+	* Makefile.in (LINK_DEPS): Remove -lglob from the list.
+
 2005-02-27  David Bateman  <dbateman@free.org>
 
-	* Sparse.cc (Sparse<T>::reshape): Set cidx for the N last elements in the
-	sparse matrix.
+	* Sparse.cc (Sparse<T>::reshape): Set cidx for the N last elements
+	in the sparse matrix.
 	
 2005-02-25  John W. Eaton  <jwe@octave.org>
 
 	Sparse merge.
 
 	2005-02-13  David Bateman  <dbateman@free.fr>
 
 	* CSparse.cc (SparseComplexMatrix:dsolve, SparseComplexMatrix:utsolve,
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -15,17 +15,17 @@ VPATH = @srcdir@:@srcdir@/COLAMD
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 LINK_DEPS = \
   -L../libcruft -L../glob -L. $(RLD_FLAG) \
-  $(LIBCRUFT) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBREADLINE) -lglob $(LIBS) $(FLIBS)
+  $(LIBCRUFT) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBREADLINE) $(LIBS) $(FLIBS)
 
 include $(srcdir)/COLAMD.files
 
 include $(srcdir)/UMFPACK.files
 
 MATRIX_INC := Array.h Array2.h Array3.h ArrayN.h DiagArray2.h \
 	Array-flags.h Array-util.h ArrayN-idx.h MArray-defs.h \
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
diff --git a/octMakefile.in b/octMakefile.in
--- a/octMakefile.in
+++ b/octMakefile.in
@@ -27,17 +27,17 @@ DISTFILES = $(CONF_DISTFILES) \
 	BUGS COPYING FLEX.patch INSTALL INSTALL.OCTAVE NEWS \
 	NEWS.[0-9] PROJECTS README README.Linux README.Windows \
 	README.MachTen README.kpathsea ROADMAP SENDING-PATCHES \
 	THANKS move-if-change octave-sh octave-bug.in \
 	octave-config.in install-octave.in mk-opts.pl mkinstalldirs \
 	mkoctfile.in texi2dvi ChangeLog ChangeLog.[0-9]
 
 # Complete directory trees to distribute.
-DISTDIRS = glob # plplot
+DISTDIRS = # plplot
 
 # Subdirectories in which to run `make all'.
 SUBDIRS = @PLPLOT_DIR@ @DLFCN_DIR@ @GLOB_DIR@ \
 	libcruft liboctave scripts doc examples
 
 ALL_SUBDIRS = $(SUBDIRS) src
 
 # Subdirectories in which to run `make all'.
@@ -174,18 +174,16 @@ dist: dist-info-files
 	tar xf `cat .fname`.tar
 	find `cat .fname` \( \( -name RCS -a -type d \) \
 	  -o \( -name CVS -a -type d \) -o \( -name OLD -a -type d \) \
 	  -o \( -name autom4te.cache -a -type d \) \
 	  -o -name "=*" -o -name '*~' -o -name '#*#' -o -name config.log \
 	  -o -name config.status -o -name config.cache -o -name stamp-h \
 	  -o -name klibtool.config -o -name stamp-auto \
 	  -o -name c-auto.h \) -print | xargs rm -rf
-	find `cat .fname`/glob -name Makefile | xargs rm -f
-	find `cat .fname`/glob -name config.h | xargs rm -f
 	rm -f `cat .fname`/test/octave.test/*.m
 	chmod -R a+rwX `cat .fname`
 	tar cf `cat .fname`.tar `cat .fname`
 	rm -rf `cat .fname`
 	gzip --best --stdout `cat .fname`.tar > `cat .fname`.tar.gz
 	bzip2 --best --stdout `cat .fname`.tar > `cat .fname`.tar.bz2
 	date -u > md5sum
 	md5sum `cat .fname`.tar.gz `cat .fname`.tar.bz2 >> md5sum
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,16 @@
+2005-02-28  John W. Eaton  <jwe@octave.org>
+
+	* toplev.cc (octave_config_info): Remove LIBGLOB and GLOB_INCFLAGS
+	from the list.
+	* oct-conf.h.in (OCTAVE_CONF_LIBGLOB, OCTAVE_CONF_GLOB_INCFLAGS):
+	Delete.
+	* Makefile.in (OCTAVE_LIBS): Remove $(LIBGLOB) from the list.
+
 2005-02-25  John W. Eaton  <jwe@octave.org>
 
 	Sparse merge.
 
 	2005-02-25  John W. Eaton  <jwe@octave.org>
 
 	* DLD-SRC/rand.cc (Frand): Accept "state" as an alias for "seed".
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -231,17 +231,17 @@ VAR_FILES := $(patsubst %.cc, %, $(VAR_1
 
 DOC_FILES := $(sort $(DEF_FILES) $(patsubst %, %.df, $(VAR_FILES)))
 
 OCTAVE_LFLAGS = -L$(TOPDIR)/liboctave -L$(TOPDIR)/libcruft \
   -L$(TOPDIR)/src $(RLD_FLAG)
 
 OCTAVE_LIBS = $(LIBOCTINTERP) $(LIBOCTAVE) \
   $(SPECIAL_MATH_LIB) $(LIBCRUFT) \
-  $(LIBPLPLOT) $(LIBGLOB) $(LIBDLFCN)
+  $(LIBPLPLOT) $(LIBDLFCN)
 
 OCTINTERP_LINK_DEPS = \
   -L../liboctave $(LIBOCTAVE) -L../libcruft $(LIBCRUFT) $(LIBS) $(FLIBS)
 
 OCT_LINK_DEPS = \
   -L../libcruft $(LIBCRUFT) -L../liboctave $(LIBOCTAVE) \
   -L. $(LIBOCTINTERP) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBS) $(FLIBS)
 
diff --git a/src/oct-conf.h.in b/src/oct-conf.h.in
--- a/src/oct-conf.h.in
+++ b/src/oct-conf.h.in
@@ -143,20 +143,16 @@ Software Foundation, 59 Temple Place - S
 #ifndef OCTAVE_CONF_FLIBS
 #define OCTAVE_CONF_FLIBS %OCTAVE_CONF_FLIBS%
 #endif
 
 #ifndef OCTAVE_CONF_FPICFLAG
 #define OCTAVE_CONF_FPICFLAG %OCTAVE_CONF_FPICFLAG%
 #endif
 
-#ifndef OCTAVE_CONF_GLOB_INCFLAGS
-#define OCTAVE_CONF_GLOB_INCFLAGS %OCTAVE_CONF_GLOB_INCFLAGS%
-#endif
-
 #ifndef OCTAVE_CONF_INCFLAGS
 #define OCTAVE_CONF_INCFLAGS %OCTAVE_CONF_INCFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_LDFLAGS
 #define OCTAVE_CONF_LDFLAGS %OCTAVE_CONF_LDFLAGS%
 #endif
 
@@ -191,20 +187,16 @@ Software Foundation, 59 Temple Place - S
 #ifndef OCTAVE_CONF_LIBEXT
 #define OCTAVE_CONF_LIBEXT %OCTAVE_CONF_LIBEXT%
 #endif
 
 #ifndef OCTAVE_CONF_LIBFLAGS
 #define OCTAVE_CONF_LIBFLAGS %OCTAVE_CONF_LIBFLAGS%
 #endif
 
-#ifndef OCTAVE_CONF_LIBGLOB
-#define OCTAVE_CONF_LIBGLOB %OCTAVE_CONF_LIBGLOB%
-#endif
-
 #ifndef OCTAVE_CONF_LIBOCTAVE
 #define OCTAVE_CONF_LIBOCTAVE %OCTAVE_CONF_LIBOCTAVE%
 #endif
 
 #ifndef OCTAVE_CONF_LIBOCTINTERP
 #define OCTAVE_CONF_LIBOCTINTERP %OCTAVE_CONF_LIBOCTINTERP%
 #endif
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -662,29 +662,27 @@ specified option.\n\
       "F2C", OCTAVE_CONF_F2C,
       "F2CFLAGS", OCTAVE_CONF_F2CFLAGS,
       "F77", OCTAVE_CONF_F77,
       "FC", OCTAVE_CONF_FC,
       "FFLAGS", OCTAVE_CONF_FFLAGS,
       "FFTW_LIBS", OCTAVE_CONF_FFTW_LIBS,
       "FLIBS", OCTAVE_CONF_FLIBS,
       "FPICFLAG", OCTAVE_CONF_FPICFLAG,
-      "GLOB_INCFLAGS", OCTAVE_CONF_GLOB_INCFLAGS,
       "INCFLAGS", OCTAVE_CONF_INCFLAGS,
       "LDFLAGS", OCTAVE_CONF_LDFLAGS,
       "LD_CXX", OCTAVE_CONF_LD_CXX,
       "LD_STATIC_FLAG", OCTAVE_CONF_LD_STATIC_FLAG,
       "LEX", OCTAVE_CONF_LEX,
       "LEXLIB", OCTAVE_CONF_LEXLIB,
       "LFLAGS", OCTAVE_CONF_LFLAGS,
       "LIBCRUFT", OCTAVE_CONF_LIBCRUFT,
       "LIBDLFCN", OCTAVE_CONF_LIBDLFCN,
       "LIBEXT", OCTAVE_CONF_LIBEXT,
       "LIBFLAGS", OCTAVE_CONF_LIBFLAGS,
-      "LIBGLOB", OCTAVE_CONF_LIBGLOB,
       "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE,
       "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP,
       "LIBPLPLOT", OCTAVE_CONF_LIBPLPLOT,
       "LIBREADLINE", OCTAVE_CONF_LIBREADLINE,
       "LIBS", OCTAVE_CONF_LIBS,
       "LN_S", OCTAVE_CONF_LN_S,
       "MKOCTFILE_INCFLAGS", OCTAVE_CONF_MKOCTFILE_INCFLAGS,
       "MKOCTFILE_LFLAGS", OCTAVE_CONF_MKOCTFILE_LFLAGS,
