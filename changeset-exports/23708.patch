# HG changeset patch
# User Rik <rik@octave.org>
# Date 1498580648 25200
#      Tue Jun 27 09:24:08 2017 -0700
# Node ID 750e42a35adc243dd892fee4545cbebfc4543f31
# Parent  b132881f9affbc1f61c0a905861c34209579bfda
Use imag, real, arg from std library for Complex types.


* lo-mappers.h (imag, real, arg): Delete overloaded functions from octave::math namespace.
Add comment about why overload for conj must remain (different behavior desired
than prototype under C++).

* ls-mat4.cc, ls-mat5.cc, mgorth.cc, ov-cx-mat.cc, ov-cx-sparse.cc,
ov-float.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-re-mat.cc, ov-re-sparse.cc,
ov-scalar.cc, CMatrix.cc, CSparse.cc, MatrixType.cc, dMatrix.cc, dSparse.cc,
fCMatrix.cc, fMatrix.cc, chol.cc, eigs-base.cc:
Replace calls to octave::math::XXX with std::XXX for imag, real, and arg.

diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -499,23 +499,23 @@ save_mat_binary_data (std::ostream& os, 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp[i] = octave::math::real (m.data (i));
+            dtmp[i] = std::real (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp[i] = octave::math::imag (m.data (i));
+            dtmp[i] = std::imag (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           os.write (reinterpret_cast<const char *> (&ds), 8);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2005,43 +2005,43 @@ int
 save_mat5_array_length (const Complex *val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (double, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = octave::math::real (val[i]);
+    tmp[i] = std::real (val[i]);
 
   ret = save_mat5_array_length (tmp, nel, save_as_floats);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = octave::math::imag (val[i]);
+    tmp[i] = std::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_array_length (const FloatComplex *val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (float, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = octave::math::real (val[i]);
+    tmp[i] = std::real (val[i]);
 
   ret = save_mat5_array_length (tmp, nel, save_as_floats);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = octave::math::imag (val[i]);
+    tmp[i] = std::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_element_length (const octave_value& tc, const std::string& name,
@@ -2448,22 +2448,22 @@ save_mat5_binary_element (std::ostream& 
           octave_idx_type nc = m.cols ();
 
           write_mat5_sparse_index_vector (os, m.ridx (), nnz);
           write_mat5_sparse_index_vector (os, m.cidx (), nc + 1);
 
           NDArray buf (dim_vector (nnz, 1));
 
           for (octave_idx_type i = 0; i < nnz; i++)
-            buf (i) = octave::math::real (m.data (i));
+            buf (i) = std::real (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
 
           for (octave_idx_type i = 0; i < nnz; i++)
-            buf (i) = octave::math::imag (m.data (i));
+            buf (i) = std::imag (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
         }
       else
         {
           const SparseMatrix m = tc.sparse_matrix_value ();
           octave_idx_type nnz = m.nnz ();
           octave_idx_type nc = m.cols ();
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -39,17 +39,17 @@ do_mgorth (ColumnVector& x, const Matrix
   for (octave_idx_type j = 0; j < Vc; j++)
     {
       ColumnVector Vcj = V.column (j);
       h(j) = RowVector (Vcj.hermitian ()) * x;
       x -= h(j) * Vcj;
     }
 
   h(Vc) = xnorm (x);
-  if (octave::math::real (h(Vc)) > 0)
+  if (std::real (h(Vc)) > 0)
     x /= h(Vc);
 }
 
 DEFUN (mgorth, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})
 Orthogonalize a given column vector @var{x} with respect to a set of
 orthonormal vectors comprising the columns of @var{v} using the modified
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -110,33 +110,33 @@ octave_complex_matrix::double_value (boo
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  return octave::math::real (matrix(0, 0));
+  return std::real (matrix(0, 0));
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  return octave::math::real (matrix(0, 0));
+  return std::real (matrix(0, 0));
 }
 
 NDArray
 octave_complex_matrix::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
@@ -239,17 +239,17 @@ octave_complex_matrix::char_array_value 
     warn_implicit_conversion ("Octave:num-to-str",
                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(octave::math::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_complex_matrix::float_complex_array_value (bool) const
 {
@@ -729,18 +729,18 @@ octave_complex_matrix::as_mxArray (void)
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
   mwSize nel = numel ();
 
   const Complex *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     {
-      pr[i] = octave::math::real (p[i]);
-      pi[i] = octave::math::imag (p[i]);
+      pr[i] = std::real (p[i]);
+      pi[i] = std::imag (p[i]);
     }
 
   return retval;
 }
 
 octave_value
 octave_complex_matrix::map (unary_mapper_t umap) const
 {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -113,17 +113,17 @@ octave_sparse_complex_matrix::double_val
   // FIXME: maybe this should be a function, valid_as_scalar()
   if (isempty ())
     err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "complex sparse matrix", "real scalar");
 
-  return octave::math::real (matrix(0, 0));
+  return std::real (matrix(0, 0));
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
@@ -173,17 +173,17 @@ octave_sparse_complex_matrix::char_array
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
           retval(matrix.ridx (i) + nr * j) =
-            static_cast<char>(octave::math::real (matrix.data (i)));
+            static_cast<char>(std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -356,18 +356,18 @@ octave_float_scalar::map (unary_mapper_t
 
 #define SCALAR_MAPPER(UMAP, FCN)              \
     case umap_ ## UMAP:                       \
       return octave_value (FCN (scalar))
 
     SCALAR_MAPPER (abs, ::fabsf);
     SCALAR_MAPPER (acos, octave::math::rc_acos);
     SCALAR_MAPPER (acosh, octave::math::rc_acosh);
-    SCALAR_MAPPER (angle, octave::math::arg);
-    SCALAR_MAPPER (arg, octave::math::arg);
+    SCALAR_MAPPER (angle, std::arg);
+    SCALAR_MAPPER (arg, std::arg);
     SCALAR_MAPPER (asin, octave::math::rc_asin);
     SCALAR_MAPPER (asinh, octave::math::asinh);
     SCALAR_MAPPER (atan, ::atanf);
     SCALAR_MAPPER (atanh, octave::math::rc_atanh);
     SCALAR_MAPPER (erf, octave::math::erf);
     SCALAR_MAPPER (erfinv, octave::math::erfinv);
     SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
     SCALAR_MAPPER (erfc, octave::math::erfc);
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -98,33 +98,33 @@ octave_float_complex_matrix::double_valu
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  return octave::math::real (matrix(0, 0));
+  return std::real (matrix(0, 0));
 }
 
 float
 octave_float_complex_matrix::float_value (bool force_conversion) const
 {
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  return octave::math::real (matrix(0, 0));
+  return std::real (matrix(0, 0));
 }
 
 Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
@@ -213,17 +213,17 @@ octave_float_complex_matrix::char_array_
     warn_implicit_conversion ("Octave:num-to-str",
                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(octave::math::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_float_complex_matrix::float_complex_array_value (bool) const
 {
@@ -681,18 +681,18 @@ octave_float_complex_matrix::as_mxArray 
   float *pi = static_cast<float *> (retval->get_imag_data ());
 
   mwSize nel = numel ();
 
   const FloatComplex *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     {
-      pr[i] = octave::math::real (p[i]);
-      pi[i] = octave::math::imag (p[i]);
+      pr[i] = std::real (p[i]);
+      pi[i] = std::imag (p[i]);
     }
 
   return retval;
 }
 
 octave_value
 octave_float_complex_matrix::map (unary_mapper_t umap) const
 {
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -796,18 +796,18 @@ octave_float_matrix::map (unary_mapper_t
       return octave_value (matrix.map<TYPE> (FCN))
 
 #define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)      \
     case umap_ ## UMAP:                       \
       return do_rc_map (matrix, FCN)
 
     RC_ARRAY_MAPPER (acos, FloatComplex, octave::math::rc_acos);
     RC_ARRAY_MAPPER (acosh, FloatComplex, octave::math::rc_acosh);
-    ARRAY_MAPPER (angle, float, octave::math::arg);
-    ARRAY_MAPPER (arg, float,octave::math ::arg);
+    ARRAY_MAPPER (angle, float, std::arg);
+    ARRAY_MAPPER (arg, float, std::arg);
     RC_ARRAY_MAPPER (asin, FloatComplex, octave::math::rc_asin);
     ARRAY_MAPPER (asinh, float, octave::math::asinh);
     ARRAY_MAPPER (atan, float, ::atanf);
     RC_ARRAY_MAPPER (atanh, FloatComplex, octave::math::rc_atanh);
     ARRAY_MAPPER (erf, float, octave::math::erf);
     ARRAY_MAPPER (erfinv, float, octave::math::erfinv);
     ARRAY_MAPPER (erfcinv, float, octave::math::erfcinv);
     ARRAY_MAPPER (erfc, float, octave::math::erfc);
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -922,18 +922,18 @@ octave_matrix::map (unary_mapper_t umap)
       return octave_value (matrix.map<TYPE> (FCN))
 
 #define RC_ARRAY_MAPPER(UMAP, TYPE, FCN)      \
     case umap_ ## UMAP:                       \
       return do_rc_map (matrix, FCN)
 
     RC_ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
     RC_ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
-    ARRAY_MAPPER (angle, double, octave::math::arg);
-    ARRAY_MAPPER (arg, double,octave::math ::arg);
+    ARRAY_MAPPER (angle, double, std::arg);
+    ARRAY_MAPPER (arg, double,std::arg);
     RC_ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
     ARRAY_MAPPER (asinh, double, octave::math::asinh);
     ARRAY_MAPPER (atan, double, ::atan);
     RC_ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
     ARRAY_MAPPER (erf, double, octave::math::erf);
     ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
     ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
     ARRAY_MAPPER (erfc, double, octave::math::erfc);
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -900,18 +900,18 @@ octave_sparse_matrix::map (unary_mapper_
     ARRAY_METHOD_MAPPER (abs, abs);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN)                 \
     case umap_ ## UMAP:                               \
       return octave_value (matrix.map<TYPE> (FCN))
 
     ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
     ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
-    ARRAY_MAPPER (angle, double, octave::math::arg);
-    ARRAY_MAPPER (arg, double,octave::math ::arg);
+    ARRAY_MAPPER (angle, double, std::arg);
+    ARRAY_MAPPER (arg, double,std::arg);
     ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
     ARRAY_MAPPER (asinh, double, octave::math::asinh);
     ARRAY_MAPPER (atan, double, ::atan);
     ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
     ARRAY_MAPPER (erf, double, octave::math::erf);
     ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
     ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
     ARRAY_MAPPER (erfc, double, octave::math::erfc);
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -377,18 +377,18 @@ octave_scalar::map (unary_mapper_t umap)
 
 #define SCALAR_MAPPER(UMAP, FCN)              \
     case umap_ ## UMAP:                       \
       return octave_value (FCN (scalar))
 
     SCALAR_MAPPER (abs, ::fabs);
     SCALAR_MAPPER (acos, octave::math::rc_acos);
     SCALAR_MAPPER (acosh, octave::math::rc_acosh);
-    SCALAR_MAPPER (angle, octave::math::arg);
-    SCALAR_MAPPER (arg,octave::math ::arg);
+    SCALAR_MAPPER (angle, std::arg);
+    SCALAR_MAPPER (arg, std::arg);
     SCALAR_MAPPER (asin, octave::math::rc_asin);
     SCALAR_MAPPER (asinh, octave::math::asinh);
     SCALAR_MAPPER (atan, ::atan);
     SCALAR_MAPPER (atanh, octave::math::rc_atanh);
     SCALAR_MAPPER (erf, octave::math::erf);
     SCALAR_MAPPER (erfinv, octave::math::erfinv);
     SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
     SCALAR_MAPPER (erfc, octave::math::erfc);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -834,17 +834,17 @@ ComplexMatrix::finverse (MatrixType& mat
   F77_INT tmp_info = 0;
 
   F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork,
                              tmp_info));
 
   info = tmp_info;
 
-  lwork = static_cast<F77_INT> (octave::math::real (z(0)));
+  lwork = static_cast<F77_INT> (std::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   Complex *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
@@ -2532,28 +2532,28 @@ ComplexMatrix::lssolve (const ComplexMat
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           const F77_INT lworkaround = 4*m + m*m + addend;
 
-          if (octave::math::real (work(0)) < lworkaround)
+          if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
           F77_INT lworkaround = 2*m + m*nrhs;
 
-          if (octave::math::real (work(0)) < lworkaround)
+          if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
@@ -2725,17 +2725,17 @@ ComplexMatrix::lssolve (const ComplexCol
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
 
       info = tmp_info;
       rank = tmp_rank;
 
-      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<F77_INT> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m,
                                  F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, tmp_rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
@@ -2989,17 +2989,17 @@ bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      if (octave::math::imag (elem (i, j)) != 0.0)
+      if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3008,17 +3008,17 @@ bool
 ComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
-      if (octave::math::imag (elem (i, j)) != 0.0)
+      if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3659,28 +3659,28 @@ min (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
+          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (octave::math::real (a(i, j)),
-                                              octave::math::real (b(i, j)));
+            result(i, j) = octave::math::min (std::real (a(i, j)),
+                                              std::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3731,31 +3731,31 @@ max (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
+          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       // FIXME: is it so much faster?
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (octave::math::real (a(i, j)),
-                                                octave::math::real (b(i, j)));
+              result(i, j) = octave::math::max (std::real (a(i, j)),
+                                                std::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -3656,36 +3656,36 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = octave::math::real (data (ii++));
+                  D[j] = std::real (data (ii++));
                   DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = octave::math::real (data (ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
                 for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
                     if (ridx (i) == j)
-                      D[j] = octave::math::real (data (i));
+                      D[j] = std::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
           F77_INT b_nr = octave::to_f77_int (b.rows ());
           F77_INT b_nc = octave::to_f77_int (b.cols ());
 
@@ -3982,36 +3982,36 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = octave::math::real (data (ii++));
+                  D[j] = std::real (data (ii++));
                   DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = octave::math::real (data (ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
                 for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
                     if (ridx (i) == j)
-                      D[j] = octave::math::real (data (i));
+                      D[j] = std::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
           F77_INT b_nr = octave::to_f77_int (b.rows ());
           F77_INT b_nc = octave::to_f77_int (b.cols ());
 
@@ -7332,18 +7332,18 @@ SparseComplexMatrix::all_elements_are_re
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
-  max_val = octave::math::real (data (0));
-  min_val = octave::math::real (data (0));
+  max_val = std::real (data (0));
+  min_val = std::real (data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
 
       double r_val = val.real ();
       double i_val = val.imag ();
 
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -502,19 +502,19 @@ MatrixType::MatrixType (const MSparse<T>
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
                   if (a.ridx (i) == j)
                     {
                       T d = a.data (i);
-                      is_herm = (octave::math::real (d) > 0.0
-                                 && octave::math::imag (d) == 0.0);
-                      diag(j) = octave::math::real (d);
+                      is_herm = (std::real (d) > 0.0
+                                 && std::imag (d) == 0.0);
+                      diag(j) = std::real (d);
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1822,18 +1822,18 @@ stack_complex_matrix (const ComplexMatri
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
   Matrix retval (m, 2*n);
   const Complex *cmd = cm.data ();
   double *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      rd[i] = octave::math::real (cmd[i]);
-      rd[nel+i] = octave::math::imag (cmd[i]);
+      rd[i] = std::real (cmd[i]);
+      rd[nel+i] = std::imag (cmd[i]);
     }
   return retval;
 }
 
 static ComplexMatrix
 unstack_complex_matrix (const Matrix& sm)
 {
   octave_idx_type m = sm.rows ();
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -557,17 +557,17 @@ real (const SparseComplexMatrix& a)
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data (i) = octave::math::real (a.data (i));
+      r.data (i) = std::real (a.data (i));
       r.ridx (i) = a.ridx (i);
     }
 
   r.maybe_compress (true);
   return r;
 }
 
 SparseMatrix
@@ -578,17 +578,17 @@ imag (const SparseComplexMatrix& a)
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data (i) = octave::math::imag (a.data (i));
+      r.data (i) = std::imag (a.data (i));
       r.ridx (i) = a.ridx (i);
     }
 
   r.maybe_compress (true);
   return r;
 }
 
 /*
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -837,17 +837,17 @@ FloatComplexMatrix::finverse (MatrixType
   F77_INT tmp_info = 0;
 
   F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_CMPLX_ARG (z.fortran_vec ()), lwork,
                              tmp_info));
 
   info = tmp_info;
 
-  lwork = static_cast<F77_INT> (octave::math::real (z(0)));
+  lwork = static_cast<F77_INT> (std::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   FloatComplex *pz = z.fortran_vec ();
 
   info = 0;
   tmp_info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
@@ -2553,28 +2553,28 @@ FloatComplexMatrix::lssolve (const Float
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           const F77_INT lworkaround = 4*m + m*m + addend;
 
-          if (octave::math::real (work(0)) < lworkaround)
+          if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
           F77_INT lworkaround = 2*m + m*nrhs;
 
-          if (octave::math::real (work(0)) < lworkaround)
+          if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       anorm = xnorm (*this, 1);
 
       if (octave::math::isinf (anorm) || octave::math::isnan (anorm))
         {
           rcon = 0.0;
           octave::warn_singular_matrix ();
@@ -2749,17 +2749,17 @@ FloatComplexMatrix::lssolve (const Float
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, tmp_rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, tmp_info));
 
       info = tmp_info;
       rank = tmp_rank;
 
-      lwork = static_cast<F77_INT> (octave::math::real (work(0)));
+      lwork = static_cast<F77_INT> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<F77_INT> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m,
                                  F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, tmp_rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
@@ -3016,17 +3016,17 @@ bool
 FloatComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      if (octave::math::imag (elem (i, j)) != 0.0)
+      if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3035,17 +3035,17 @@ bool
 FloatComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
-      if (octave::math::imag (elem (i, j)) != 0.0)
+      if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3685,28 +3685,28 @@ min (const FloatComplexMatrix& a, const 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
+          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (octave::math::real (a(i, j)),
-                                              octave::math::real (b(i, j)));
+            result(i, j) = octave::math::min (std::real (a(i, j)),
+                                              std::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3757,30 +3757,30 @@ max (const FloatComplexMatrix& a, const 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
+          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (octave::math::real (a(i, j)),
-                                                octave::math::real (b(i, j)));
+              result(i, j) = octave::math::max (std::real (a(i, j)),
+                                                std::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1840,18 +1840,18 @@ stack_complex_matrix (const FloatComplex
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
   FloatMatrix retval (m, 2*n);
   const FloatComplex *cmd = cm.data ();
   float *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      rd[i] = octave::math::real (cmd[i]);
-      rd[nel+i] = octave::math::imag (cmd[i]);
+      rd[i] = std::real (cmd[i]);
+      rd[nel+i] = std::imag (cmd[i]);
     }
   return retval;
 }
 
 static FloatComplexMatrix
 unstack_complex_matrix (const FloatMatrix& sm)
 {
   octave_idx_type m = sm.rows ();
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -328,17 +328,17 @@ namespace octave
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       if (singular (chol_mat))
         info = 2;
-      else if (math::imag (u(j)) != zero)
+      else if (std::imag (u(j)) != zero)
         info = 3;
       else
         {
           T a = chol_mat.hermitian () * chol_mat;
           T a1 (n+1, n+1);
           for (octave_idx_type k = 0; k < n+1; k++)
             for (octave_idx_type l = 0; l < n+1; l++)
               {
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -1699,17 +1699,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
             }
 
           eig_vec.resize (n, k);
           F77_INT i = 0;
           while (i < k)
             {
               F77_INT off1 = i * n;
               F77_INT off2 = (i+1) * n;
-              if (octave::math::imag (eig_val(i)) == 0)
+              if (std::imag (eig_val(i)) == 0)
                 {
                   for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
@@ -2053,17 +2053,17 @@ EigsRealNonSymmetricMatrixShift (const M
             }
 
           eig_vec.resize (n, k);
           F77_INT i = 0;
           while (i < k)
             {
               F77_INT off1 = i * n;
               F77_INT off2 = (i+1) * n;
-              if (octave::math::imag (eig_val(i)) == 0)
+              if (std::imag (eig_val(i)) == 0)
                 {
                   for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
@@ -2344,17 +2344,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
             }
 
           eig_vec.resize (n, k);
           F77_INT i = 0;
           while (i < k)
             {
               F77_INT off1 = i * n;
               F77_INT off2 = (i+1) * n;
-              if (octave::math::imag (eig_val(i)) == 0)
+              if (std::imag (eig_val(i)) == 0)
                 {
                   for (F77_INT j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -75,89 +75,55 @@ namespace octave
     extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
 
     extern OCTAVE_API Complex asin (const Complex& x);
     extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
 
     inline Complex atan (const Complex& x) { return std::atan (x); }
     inline FloatComplex atan (const FloatComplex& x) { return std::atan (x); }
 
-    // C++ now provides versions of the following functions for arguments of
-    // type std::complex<T> and T.  But some compilers (I'm looking at you,
-    // clang) apparently don't get this right yet...  So we provide our own
-    // wrappers for real-valued arguments.
-
-    inline double arg (double x) { return signbit (x) ? M_PI : 0; }
-    inline float arg (float x)
-    {
-      return signbit (x) ? static_cast<float> (M_PI) : 0;
-    }
-
-    template <typename T>
-    T
-    arg (const std::complex<T>& x)
-    {
-      return std::arg (x);
-    }
-
+    // The C++ standard would normally return a std::complex value for conj
+    // even when the input is fully real.  Octave overrides this. 
     inline double conj (double x) { return x; }
     inline float conj (float x) { return x; }
 
     template <typename T>
     std::complex<T>
     conj (const std::complex<T>& x)
     {
       return std::conj (x);
     }
 
-    inline double imag (double) { return 0; }
-    inline float imag (float) { return 0; }
-
-    template <typename T>
-    T
-    imag (const std::complex<T>& x)
-    {
-      return std::imag (x);
-    }
-
-    inline double real (double x) { return x; }
-    inline float real (float x) { return x; }
-
-    template <typename T>
-    T
-    real (const std::complex<T>& x)
-    {
-      return std::real (x);
-    }
-
     inline double log2 (double x) { return std::log2 (x); }
     inline float log2 (float x) { return std::log2f (x); }
 
     extern OCTAVE_API Complex log2 (const Complex& x);
     extern OCTAVE_API FloatComplex log2 (const FloatComplex& x);
 
     extern OCTAVE_API double log2 (double x, int& exp);
     extern OCTAVE_API float log2 (float x, int& exp);
 
     extern OCTAVE_API Complex log2 (const Complex& x, int& exp);
     extern OCTAVE_API FloatComplex log2 (const FloatComplex& x, int& exp);
 
     inline double exp2 (double x) { return std::exp2 (x); }
     inline float exp2 (float x) { return std::exp2f (x); }
 
+    // FIXME: Is ceil actually acceptably defined for complex values?
     inline double ceil (double x) { return std::ceil (x); }
     inline float ceil (float x) { return ::ceilf (x); }
 
     template <typename T>
     std::complex<T>
     ceil (const std::complex<T>& x)
     {
       return std::complex<T> (ceil (std::real (x)), ceil (std::imag (x)));
     }
 
+    // FIXME: Is trunc actually acceptably defined for complex values?
     inline double trunc (double x) { return std::trunc (x); }
     inline float trunc (float x) { return std::truncf (x); }
 
     template <typename T>
     std::complex<T>
     trunc (const std::complex<T>& x)
     {
       return std::complex<T> (trunc (std::real (x)), trunc (std::imag (x)));
@@ -169,26 +135,28 @@ namespace octave
 
     template <typename T>
     std::complex<T>
     fix (const std::complex<T>& x)
     {
       return trunc (x);
     }
 
+    // FIXME: Do we need this alias for floor?
     inline double floor (double x) { return std::floor (x); }
     inline float floor (float x) { return std::floor (x); }
 
     template <typename T>
     std::complex<T>
     floor (const std::complex<T>& x)
     {
       return std::complex<T> (floor (std::real (x)), floor (std::imag (x)));
     }
 
+    // FIXME: Do we need this alias for round?
     inline double round (double x) { return std::round (x); }
     inline float round (float x) { return std::roundf (x); }
 
     template <typename T>
     std::complex<T>
     round (const std::complex<T>& x)
     {
       return std::complex<T> (round (std::real (x)), round (std::imag (x)));
@@ -227,26 +195,28 @@ namespace octave
     extern OCTAVE_API float frexp (float x, int *expptr);
 
     inline bool isnan (bool) { return false; }
     inline bool isnan (char) { return false; }
 
     inline bool isnan (double x) { return std::isnan (x); }
     inline bool isnan (float x) { return std::isnan (x); }
 
+    // FIXME: Do we need the isnan overload for complex?
     template <typename T>
     bool
     isnan (const std::complex<T>& x)
     {
       return (isnan (std::real (x)) || isnan (std::imag (x)));
     }
 
     inline bool isfinite (double x) { return std::isfinite (x); }
     inline bool isfinite (float x) { return std::isfinite (x); }
 
+    // FIXME: Do we need isfinite overload for complex?
     template <typename T>
     bool
     isfinite (const std::complex<T>& x)
     {
       return (isfinite (std::real (x)) && isfinite (std::imag (x)));
     }
 
     OCTAVE_DEPRECATED (4.4, "use 'math::isfinite' instead")
@@ -260,26 +230,28 @@ namespace octave
     finite (const std::complex<T>& x)
     {
       return math::isfinite (x);
     }
 
     inline bool isinf (double x) { return std::isinf (x); }
     inline bool isinf (float x) { return std::isinf (x); }
 
+    // FIXME: Do we need isinf overload for complex?
     template <typename T>
     bool
     isinf (const std::complex<T>& x)
     {
       return (isinf (std::real (x)) || isinf (std::imag (x)));
     }
 
     // Some useful tests, that are commonly repeated.
     // Test for a finite integer.
 
+    // FIXME: Benchmark whether trunc might be faster than round here.
     inline bool isinteger (double x) { return isfinite (x) && x == round (x); }
     inline bool isinteger (float x) { return isfinite (x) && x == round (x); }
 
     inline double
     signum (double x)
     {
       double tmp = 0.0;
 
@@ -550,35 +522,35 @@ inline FloatComplex asin (const FloatCom
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::atan' instead")
 inline Complex atan (const Complex& x) { return octave::math::atan (x); }
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::atan' instead")
 inline FloatComplex atan (const FloatComplex& x)
 {
   return octave::math::atan (x);
 }
 
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::arg' instead")
-inline double arg (double x) { return octave::math::arg (x); }
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::arg' instead")
-inline float arg (float x) { return octave::math::arg (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::arg' instead")
+inline double arg (double x) { return std::arg (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::arg' instead")
+inline float arg (float x) { return std::arg (x); }
 
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::conj' instead")
 inline double conj (double x) { return x; }
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::conj' instead")
 inline float conj (float x) { return x; }
 
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::imag' instead")
-inline double imag (double x) { return octave::math::imag (x); }
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::imag' instead")
-inline float imag (float x) { return octave::math::imag (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::imag' instead")
+inline double imag (double x) { return std::imag (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::imag' instead")
+inline float imag (float x) { return std::imag (x); }
 
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::real' instead")
-inline double real (double x) { return octave::math::real (x); }
-OCTAVE_DEPRECATED (4.2, "use 'octave::math::real' instead")
-inline float real (float x) { return octave::math::real (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::real' instead")
+inline double real (double x) { return std::real (x); }
+OCTAVE_DEPRECATED (4.2, "use 'std::real' instead")
+inline float real (float x) { return std::real (x); }
 
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::log2' instead")
 inline double xlog2 (double x) { return octave::math::log2 (x); }
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::log2' instead")
 inline float xlog2 (float x) { return octave::math::log2 (x); }
 
 OCTAVE_DEPRECATED (4.2, "use 'octave::math::log2' instead")
 inline Complex xlog2 (const Complex& x) { return octave::math::log2 (x); }
