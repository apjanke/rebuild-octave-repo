# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1203716643 18000
#      Fri Feb 22 16:44:03 2008 -0500
# Node ID b166043585a87263340b2ce69b5c159d9791aac8
# Parent  3bf53d7f9d399d9d004569a18428f9b1f53b25a7
use 0 instead of NULL

diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1118,24 +1118,24 @@ SparseComplexMatrix::determinant (octave
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
 				     reinterpret_cast<const double *> (Ax), 
-				     NULL, 1, control);
+				     0, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic) 
-	(nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), NULL, 
-	 NULL, &Symbolic, control, info);
+	(nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0, 
+	 0, &Symbolic, control, info);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexMatrix::determinant symbolic factorization failed");
 
 	  UMFPACK_ZNAME (report_status) (control, status);
 	  UMFPACK_ZNAME (report_info) (control, info);
@@ -1145,17 +1145,17 @@ SparseComplexMatrix::determinant (octave
       else
 	{
 	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
 	  status
 	    = UMFPACK_ZNAME (numeric) (Ap, Ai,
 				       reinterpret_cast<const double *> (Ax),
-				       NULL, Symbolic, &Numeric, control, info) ;
+				       0, Symbolic, &Numeric, control, info) ;
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  rcond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
 		("SparseComplexMatrix::determinant numeric factorization failed");
@@ -1168,17 +1168,17 @@ SparseComplexMatrix::determinant (octave
 	  else
 	    {
 	      UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
 	      Complex d[2];
 	      double d_exponent;
 
 	      status = UMFPACK_ZNAME (get_determinant) 
-		(reinterpret_cast<double *> (&d[0]), NULL, &d_exponent,
+		(reinterpret_cast<double *> (&d[0]), 0, &d_exponent,
 		 Numeric, info);
 	      d[1] = d_exponent;
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexMatrix::determinant error calculating determinant");
 		  
@@ -5464,24 +5464,24 @@ SparseComplexMatrix::factorize (octave_i
   const octave_idx_type *Ap = cidx ();
   const octave_idx_type *Ai = ridx ();
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
 				 reinterpret_cast<const double *> (Ax),
-				 NULL, 1, control);
+				 0, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 				     reinterpret_cast<const double *> (Ax), 
-				     NULL, NULL, &Symbolic, control, info);
+				     0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_ZNAME (report_status) (control, status);
@@ -5489,17 +5489,17 @@ SparseComplexMatrix::factorize (octave_i
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-				   reinterpret_cast<const double *> (Ax), NULL, 
+				   reinterpret_cast<const double *> (Ax), 0, 
 				   Symbolic, &Numeric, control, info) ;
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
 	rcond = Info (UMFPACK_RCOND);
       else
 	rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
@@ -5576,17 +5576,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -5601,17 +5601,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_COMPLEX;
@@ -5731,33 +5731,33 @@ SparseComplexMatrix::fsolve (MatrixType 
 	      Complex *Xx = retval.fortran_vec ();
 
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
 					     Ai,
 					     reinterpret_cast<const double *> (Ax), 
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (&Xx[iidx]), 
-					     NULL,
+					     0,
 					     &Bx[iidx], Bz, Numeric, 
 					     control, info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
 					     Ai,
 					     reinterpret_cast<const double *> (Ax), 
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (&Xx[iidx]), 
-					     NULL,
+					     0,
 					     reinterpret_cast<const double *> (Bz),
-					     NULL, Numeric, 
+					     0, Numeric, 
 					     control, info);
 #endif
 
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
@@ -5819,17 +5819,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -5844,17 +5844,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_COMPLEX;
@@ -5868,17 +5868,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
 	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
-	  B->nz = NULL;
+	  B->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
 	  B->dtype = CHOLMOD_DOUBLE;
 	  B->stype = 0;
 	  B->xtype = CHOLMOD_REAL;
@@ -6002,32 +6002,32 @@ SparseComplexMatrix::fsolve (MatrixType 
 
 #ifdef UMFPACK_SEPARATE_SPLIT
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
 					     Ai,
 					     reinterpret_cast<const double *> (Ax),
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (Xx),
-					     NULL, 
+					     0, 
 					     Bx, Bz, Numeric, control, 
 					     info);
 #else
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bz[i] = b.elem (i, j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
 					     reinterpret_cast<const double *> (Ax),
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (Xx),
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (Bz),
-					     NULL,
+					     0,
 					     Numeric, control, 
 					     info);
 #endif
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
@@ -6110,17 +6110,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -6135,17 +6135,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_COMPLEX;
@@ -6258,21 +6258,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 	      retval.resize (b_nr, b_nc);
 	      Complex *Xx = retval.fortran_vec ();
 	      
 	      for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
 		{
 		  status = 
 		    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
 				      reinterpret_cast<const double *> (Ax), 
-				      NULL,
+				      0,
 				      reinterpret_cast<double *> (&Xx[iidx]), 
-				      NULL,
+				      0,
 				      reinterpret_cast<const double *> (&Bx[iidx]), 
-				      NULL, Numeric, control, info);
+				      0, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
 		      UMFPACK_ZNAME (report_status) (control, status);
 		      
@@ -6332,17 +6332,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -6357,17 +6357,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_COMPLEX;
@@ -6381,17 +6381,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
 	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
-	  B->nz = NULL;
+	  B->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
 	  B->dtype = CHOLMOD_DOUBLE;
 	  B->stype = 0;
 	  B->xtype = CHOLMOD_COMPLEX;
@@ -6506,21 +6506,21 @@ SparseComplexMatrix::fsolve (MatrixType 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    Bx[i] = b (i,j);
 
 		  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
 					     Ai,
 					     reinterpret_cast<const double *> (Ax),
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (Xx),
-					     NULL,
+					     0,
 					     reinterpret_cast<double *> (Bx),
-					     NULL, Numeric, control, info);
+					     0, Numeric, control, info);
 		  
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexMatrix::solve solve failed");
 
 		      UMFPACK_ZNAME (report_status) (control, status);
 		  
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,14 @@
+2008-02-22  John W. Eaton  <jwe@octave.org>
+
+	* CSparse.cc, SparseCmplxLU.cc, SparsedbleLU.cc, dSparse.cc,
+	file-ops.cc, oct-group.cc, oct-shlib.cc, sparse-base-chol.h,
+	sparse-dmsolve.cc: Use 0 instead of NULL.
+
 2008-02-22  David Bateman  <dbateman@free.fr>
 
 	* boolSparse.cc (SparseBoolMatrix SparseBoolMatrix::diag 
 	(octave_idx_type) const): New method.
 	* boolSparse.h (SparseBoolMatrix SparseBoolMatrix::diag 
 	(octave_idx_type) const): Declare it.
 
 	* base-lu.h (lu_type Y (void) const): New method to return
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -90,24 +90,24 @@ SparseComplexLU::SparseComplexLU (const 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
   const octave_idx_type *Ai = a.ridx ();
   const Complex *Ax = a.data ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
 				 reinterpret_cast<const double *> (Ax),
-				 NULL, 1, control);
+				 0, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 					  reinterpret_cast<const double *> (Ax),
-					  NULL, NULL,
+					  0, 0,
 					  &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
       UMFPACK_ZNAME (report_status) (control, status);
@@ -117,17 +117,17 @@ SparseComplexLU::SparseComplexLU (const 
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
 					reinterpret_cast<const double *> (Ax),
-					NULL, Symbolic, &Numeric, control,
+					0, Symbolic, &Numeric, control,
 					info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
@@ -193,19 +193,19 @@ SparseComplexLU::SparseComplexLU (const 
 	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      octave_idx_type *q = Q.fortran_vec ();
 
 	      octave_idx_type do_recip;
 	      status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
 						    reinterpret_cast<double *> (Ltx),
-						    NULL, Up, Uj,
+						    0, Up, Uj,
 						    reinterpret_cast <double *> (Ux),
-						    NULL, p, q, NULL, NULL,
+						    0, p, q, 0, 0,
 						    &do_recip, Rx, Numeric);
 
 	      UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
 		    ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
@@ -218,22 +218,22 @@ SparseComplexLU::SparseComplexLU (const 
 
 		  if (do_recip)
 		    for (octave_idx_type i = 0; i < nr; i++)
 		      Rx[i] = 1.0 / Rx[i];
 
 		  UMFPACK_ZNAME (report_matrix) (nr, n_inner,
 					    Lfact.cidx (), Lfact.ridx (), 
 					    reinterpret_cast<double *> (Lfact.data()), 
-					    NULL, 1, control);
+					    0, 1, control);
 
 		  UMFPACK_ZNAME (report_matrix) (n_inner, nc,
 					    Ufact.cidx (), Ufact.ridx (), 
 					    reinterpret_cast<double *> (Ufact.data()), 
-					    NULL, 1, control);
+					    0, 1, control);
 		  UMFPACK_ZNAME (report_perm) (nr, p, control);
 		  UMFPACK_ZNAME (report_perm) (nc, q, control);
 		}
 
 	      UMFPACK_ZNAME (report_info) (control, info);
 	    }
 	}
     }
@@ -306,17 +306,17 @@ SparseComplexLU::SparseComplexLU (const 
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-				reinterpret_cast<const double *> (Ax), NULL,
+				reinterpret_cast<const double *> (Ax), 0,
 				1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
@@ -324,17 +324,17 @@ SparseComplexLU::SparseComplexLU (const 
       do {
 	OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
 	for (octave_idx_type i = 0; i < nc; i++)
 	  qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
 	status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
 				       reinterpret_cast<const double *> (Ax),
-				       NULL, qinit, &Symbolic, control, 
+				       0, qinit, &Symbolic, control, 
 				       info);
       } while (0);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
@@ -344,17 +344,17 @@ SparseComplexLU::SparseComplexLU (const 
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 	}
       else
 	{
 	  UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
 	  void *Numeric;
 	  status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
-				       reinterpret_cast<const double *> (Ax), NULL,
+				       reinterpret_cast<const double *> (Ax), 0,
 				       Symbolic, &Numeric, control, info) ;
 	  UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
 	  cond = Info (UMFPACK_RCOND);
 
 	  if (status < 0)
 	    {
 	      (*current_liboctave_error_handler) 
@@ -421,19 +421,19 @@ SparseComplexLU::SparseComplexLU (const 
 
 		  Q.resize (nc);
 		  octave_idx_type *q = Q.fortran_vec ();
 
 		  octave_idx_type do_recip;
 		  status = 
 		    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
 					    reinterpret_cast<double *> (Ltx),
-					    NULL, Up, Uj,
+					    0, Up, Uj,
 					    reinterpret_cast<double *> (Ux), 
-					    NULL, p, q, NULL, NULL, 
+					    0, p, q, 0, 0, 
 					    &do_recip, Rx, Numeric) ;
 
 		  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseComplexLU::SparseComplexLU extracting LU factors failed");
@@ -447,23 +447,23 @@ SparseComplexLU::SparseComplexLU (const 
 		      if (do_recip)
 			for (octave_idx_type i = 0; i < nr; i++)
 			  Rx[i] = 1.0 / Rx[i];
 
 		      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
 						Lfact.cidx (), 
 						Lfact.ridx (), 
 						reinterpret_cast<double *> (Lfact.data()), 
-						NULL, 1, control);
+						0, 1, control);
 
 		      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
 						Ufact.cidx (), 
 						Ufact.ridx (), 
 						reinterpret_cast<double *> (Ufact.data()), 
-						NULL, 1, control);
+						0, 1, control);
 		      UMFPACK_ZNAME (report_perm) (nr, p, control);
 		      UMFPACK_ZNAME (report_perm) (nc, q, control);
 		    }
 
 		  UMFPACK_ZNAME (report_info) (control, info);
 		}
 	    }
 	}
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -92,17 +92,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   const octave_idx_type *Ai = a.ridx ();
   const double *Ax = a.data ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, NULL,
+  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
 				     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	    ("SparseLU::SparseLU symbolic factorization failed");
 
       UMFPACK_DNAME (report_status) (control, status);
@@ -185,17 +185,17 @@ SparseLU::SparseLU (const SparseMatrix& 
 	      P.resize (nr);
 	      octave_idx_type *p = P.fortran_vec ();
 
 	      Q.resize (nc);
 	      octave_idx_type *q = Q.fortran_vec ();
 
 	      octave_idx_type do_recip;
 	      status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
-					       Up, Uj, Ux, p, q, NULL,
+					       Up, Uj, Ux, p, q, 0,
 					       &do_recip, Rx, 
 					       Numeric) ;
 
 	      UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 	      if (status < 0)
 		{
 		  (*current_liboctave_error_handler) 
@@ -402,17 +402,17 @@ SparseLU::SparseLU (const SparseMatrix& 
 		  octave_idx_type *p = P.fortran_vec ();
 
 		  Q.resize (nc);
 		  octave_idx_type *q = Q.fortran_vec ();
 
 		  octave_idx_type do_recip;
 		  status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
 						   Ltx, Up, Uj, Ux, p, q, 
-						   NULL, &do_recip, 
+						   0, &do_recip, 
 						   Rx, Numeric) ;
 
 		  UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
 		  if (status < 0)
 		    {
 		      (*current_liboctave_error_handler) 
 			("SparseLU::SparseLU extracting LU factors failed");
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -1196,17 +1196,17 @@ SparseMatrix::determinant (octave_idx_ty
       const double *Ax = data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, 
-					 Ax, NULL, &Symbolic, control, info);
+					 Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
 	{
 	  (*current_liboctave_error_handler) 
 	    ("SparseMatrix::determinant symbolic factorization failed");
 
 	  UMFPACK_DNAME (report_status) (control, status);
 	  UMFPACK_DNAME (report_info) (control, info);
@@ -5647,17 +5647,17 @@ SparseMatrix::factorize (octave_idx_type
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, NULL,
+  int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
 				     &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler) 
 	("SparseMatrix::solve symbolic factorization failed");
       err = -1;
 
@@ -5753,17 +5753,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -5778,17 +5778,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_REAL;
@@ -5969,17 +5969,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -5994,17 +5994,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_REAL;
@@ -6018,17 +6018,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
 	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
-	  B->nz = NULL;
+	  B->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
 	  B->dtype = CHOLMOD_DOUBLE;
 	  B->stype = 0;
 	  B->xtype = CHOLMOD_REAL;
@@ -6231,17 +6231,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -6256,17 +6256,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_REAL;
@@ -6465,17 +6465,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  // Setup initial parameters
 	  CHOLMOD_NAME(start) (cm);
 	  cm->prefer_zomplex = false;
 
 	  double spu = octave_sparse_params::get_key ("spumoni");
 	  if (spu == 0.)
 	    {
 	      cm->print = -1;
-	      cm->print_function = NULL;
+	      cm->print_function = 0;
 	    }
 	  else
 	    {
 	      cm->print = static_cast<int> (spu) + 2;
 	      cm->print_function =&SparseCholPrint;
 	    }
 
 	  cm->error_handler = &SparseCholError;
@@ -6490,17 +6490,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
 	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
-	  A->nz = NULL;
+	  A->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
 	  A->dtype = CHOLMOD_DOUBLE;
 	  A->stype = 1;
 	  A->xtype = CHOLMOD_REAL;
@@ -6514,17 +6514,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
 	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
-	  B->nz = NULL;
+	  B->nz = 0;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
 	  B->dtype = CHOLMOD_DOUBLE;
 	  B->stype = 0;
 	  B->xtype = CHOLMOD_COMPLEX;
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -462,17 +462,17 @@ extern int errno;
 #elif defined (__WIN32__)
 
   int n = 1024;
 
   std::string win_path (n, '\0');
 
   while (true)
     {
-      int status = GetFullPathName (name.c_str (), n, &win_path[0], NULL);
+      int status = GetFullPathName (name.c_str (), n, &win_path[0], 0);
 
       if (status == 0)
         break;
       else if (status < n)
         {
           win_path.resize (status);
 	  retval = win_path;
 	  break;
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -187,17 +187,17 @@ octave_group::octave_group (void *p, std
 
 #if defined (HAVE_GR_PASSWD)
       gr_passwd = gr->gr_passwd;
 #endif
 
       gr_gid = gr->gr_gid;
 
       // FIXME -- maybe there should be a string_vector
-      // constructor that takes a NULL terminated list of C
+      // constructor that takes a NUL terminated list of C
       // strings.
 
       const char * const *tmp = gr->gr_mem;
 
       int k = 0;
       while (*tmp++)
 	k++;
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -459,17 +459,17 @@ void
 octave_w32_shlib::open (const std::string& f)
 {
   if (! is_open ())
     {
       file = f;
 
       handle = LoadLibrary (file.c_str ());
 
-      if (handle != NULL)
+      if (handle)
 	stamp_time ();
       else
 	{
 	  DWORD lastError = GetLastError ();
 	  char *msg;
 
 	  switch (lastError)
 	    {
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -35,17 +35,17 @@ template <class chol_type, class chol_el
 class
 sparse_base_chol
 {
 protected:
 #ifdef HAVE_CHOLMOD
   class sparse_base_chol_rep
   {
   public:
-    sparse_base_chol_rep (void) : count (1), Lsparse (NULL), 
+    sparse_base_chol_rep (void) : count (1), Lsparse (0), 
 				  is_pd (false), minor_p (0) { }
 
     sparse_base_chol_rep (const chol_type& a, 
 			  const bool natural) : count (1)
       { init (a, natural); }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info, 
 			  const bool natural) : count (1)
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -375,17 +375,17 @@ dmsolve (const ST &a, const T &b, octave
   else if (nr == 0 || nc == 0 || b_nc == 0)
     retval = RT (nc, b_nc, 0.0);
   else
     {
       octave_idx_type nnz_remaining = a.nnz ();
       CXSPARSE_DNAME () csm;
       csm.m = nr;
       csm.n = nc;
-      csm.x = NULL;
+      csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
       csm.p = const_cast<octave_idx_type *>(a.cidx ());
       csm.i = const_cast<octave_idx_type *>(a.ridx ());
 
 #if defined(CS_VER) && (CS_VER >= 2)
@@ -407,38 +407,38 @@ dmsolve (const ST &a, const T &b, octave
 
       // Leading over-determined block
       if (dm->rr [2] < nr && dm->cc [3] < nc)
 	{
 	  ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc, 
 				  nnz_remaining, true);
 	  nnz_remaining -= m.nnz();
 	  RT mtmp = 
-	    qrsolve (m, dmsolve_extract (btmp, NULL, NULL, dm->rr[2], b_nr, 0,
+	    qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
 					 b_nc), info);
 	  dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
 	  if (dm->rr [2] > 0 && !info)
 	    {
 	      m = dmsolve_extract (a, pinv, q, 0, dm->rr [2], 
 				   dm->cc [3], nc, nnz_remaining, true);
 	      nnz_remaining -= m.nnz();
-	      RT ctmp = dmsolve_extract (btmp, NULL, NULL, 0, 
+	      RT ctmp = dmsolve_extract (btmp, 0, 0, 0, 
 					 dm->rr[2], 0, b_nc);
 	      btmp.insert (ctmp - m * mtmp, 0, 0);
 	    }
 	}
       
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
 	{
 	  ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
 				  dm->cc [2], dm->cc [3], nnz_remaining, false);
 	  nnz_remaining -= m.nnz();
-	  RT btmp2 = dmsolve_extract (btmp, NULL, NULL, dm->rr [1], dm->rr [2], 
+	  RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2], 
 				      0, b_nc);
 	  double rcond = 0.0;
 	  MatrixType mtyp (MatrixType::Full);
 	  RT mtmp = m.solve (mtyp, btmp2, info, rcond, 
 			     solve_singularity_warning, false);	
 	  if (info != 0)
 	    {
 	      info = 0;
@@ -446,29 +446,29 @@ dmsolve (const ST &a, const T &b, octave
 	    }
 
 	  dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
 	  if (dm->rr [1] > 0 && !info)
 	    {
 	      m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
 				   dm->cc [3], nnz_remaining, true);
 	      nnz_remaining -= m.nnz();
-	      RT ctmp = dmsolve_extract (btmp, NULL, NULL, 0,
+	      RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
 					 dm->rr[1], 0, b_nc);
 	      btmp.insert (ctmp - m * mtmp, 0, 0);
 	    }
 	}
 
       // Trailing under-determined block
       if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
 	{
 	  ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0, 
 				  dm->cc [2], nnz_remaining, true);
 	  RT mtmp = 
-	    qrsolve (m, dmsolve_extract(btmp, NULL, NULL, 0, dm->rr [1] , 0, 
+	    qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0, 
 					b_nc), info);
 	  dmsolve_insert (retval, mtmp, q, 0, 0);
 	}
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,16 @@
+2008-02-22  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/colamd.cc,
+	DLD-FUNCTIONS/convhulln.cc, DLD-FUNCTIONS/dmperm.cc,
+	DLD-FUNCTIONS/qz.cc, DLD-FUNCTIONS/regexp.cc,
+	DLD-FUNCTIONS/symbfact.cc, zfstream.h, zfstream.cc:
+	Use 0 instead of NULL.
+
 2008-02-22  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/chol.c (Fchol, Fcholinv, Fchol2iinv): Treat 
 	sparse matrices. Add the "lower" and "vector" flags.
 	* DLD-FUNCTIONS/inv.c (Finv): Treat sparse matrices.
 	* DLD-FUNCTION/sparse.cc (static bool is_sparse (const
 	octave_value&)): Remove and use arg.is_sparse_type () instead.
 	(Fspcumprod, Fspcumsum, Fspprod, spsum, spsumsq, spdiag): Remove.
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -281,17 +281,17 @@ colamd, symamd, and other related orderi
 		CCOLAMD_NAME (_report) (stats) ;
 		error ("ccolamd: internal error!");
 		return retval;
 	      }
 	}
       else
 	{
 	  // Order the columns (destroys A)
-	  if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, NULL))
+	  if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
 	    {
 	      CCOLAMD_NAME (_report) (stats) ;
 	      error ("ccolamd: internal error!");
 	      return retval;
 	    }
 	}
 
       // return the permutation vector
@@ -516,17 +516,17 @@ colamd, symamd, and other related orderi
 		CSYMAMD_NAME (_report) (stats) ;
 		error ("symamd: internal error!") ;
 		return retval;
 	      }
 	}
       else
 	{
 	  if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
-				&calloc, &free, NULL, -1))
+				&calloc, &free, 0, -1))
 	    {
 	      CSYMAMD_NAME (_report) (stats) ;
 	      error ("symamd: internal error!") ;
 	      return retval;
 	    }
 	}
 
       // return the permutation vector
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -713,17 +713,17 @@ permutations on the tree.\n\
 
       if (is_sym)
 	{
 	  if (n_row != n_col)
 	    {
 	      error ("etree: matrix is marked as symmetric, but not square");
 	      return retval;
 	    }
-	  symetree (ridx, cidx, etree, NULL, n_col);
+	  symetree (ridx, cidx, etree, 0, n_col);
 	}
       else
 	{
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
 
 	  for (octave_idx_type i = 0; i < n_col; i++)
 	    {
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -116,17 +116,17 @@ are \"s Qci Tcv\".\n\n\
   boolT ismalloc = False;
 
   OCTAVE_LOCAL_BUFFER (char, flags, 250);
 
   // hmm, lots of options for qhull here
   // QJ guarantees that the output will be triangles
   snprintf (flags, 250, "qhull QJ %s", options.c_str ());
 
-  if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, NULL, stderr)) 
+  if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, 0, stderr)) 
     {
       // If you want some debugging information replace the NULL
       // pointer with stdout
 
       vertexT *vertex, **vertexp;
       facetT *facet;
       setT *vertices;
       unsigned int nf = qh num_facets;
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -59,17 +59,17 @@ dmperm_internal (bool rank, const octave
   octave_value_list retval;
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
   CXSPARSE_NAME () csm;
   csm.m = nr;
   csm.n = nc;
-  csm.x = NULL;
+  csm.x = 0;
   csm.nz = -1;
 
   if (arg.is_real_type ())
     {
       m = arg.sparse_matrix_value ();
       csm.nzmax = m.nnz();
       csm.p = m.xcidx ();
       csm.i = m.xridx ();
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -614,17 +614,17 @@ Order of output arguments was selected f
       else
 	{
 #ifdef DEBUG_SORT
 	  std::cout << "qz: ordering eigenvalues: ord_job = " << ord_job[0] << std::endl;
 #endif
 
 	  // declared static to avoid vfork/long jump compiler complaints
 	  static sort_function sort_test;
-	  sort_test = NULL;
+	  sort_test = 0;
 
 	  switch (ord_job[0])
 	    {
 	    case 'S':
 	      sort_test = &fin;
 	      break;
 
 	    case 'B':
@@ -843,17 +843,17 @@ Order of output arguments was selected f
 	}
     }
 
   // right, left eigenvector matrices
   if (nargout >= 5)
     {
       char side = (nargout == 5 ? 'R' : 'B');	// which side to compute?
       char howmny = 'B';  // compute all of them and backtransform
-      octave_idx_type *select = NULL; // dummy pointer; select is not used.
+      octave_idx_type *select = 0; // dummy pointer; select is not used.
       octave_idx_type m;
 
       if (complex_case)
 	{
 	  error ("complex type not yet implemented");
 	  return retval;
 	}
       else
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -254,51 +254,51 @@ octregexp_list (const octave_value_list 
       const char *err;
       int erroffset;
       std::string buf_str = buf.str ();
       re = pcre_compile (buf_str.c_str (),
 			 (case_insensitive ? PCRE_CASELESS : 0) |
 			 (dotexceptnewline ? 0 : PCRE_DOTALL) |
 			 (lineanchors ? PCRE_MULTILINE : 0) |
 			 (freespacing ? PCRE_EXTENDED : 0),
-			 &err, &erroffset, NULL);
+			 &err, &erroffset, 0);
     
-      if (re == NULL) {
+      if (re == 0) {
 	error("%s: %s at position %d of expression", nm.c_str(), 
 	      err, erroffset);
 	return 0;
       }
 
       int subpatterns;
       int namecount;
       int nameentrysize;
       char *nametable;
       int idx = 0;
 
-      pcre_fullinfo(re, NULL, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
-      pcre_fullinfo(re, NULL, PCRE_INFO_NAMECOUNT, &namecount);
-      pcre_fullinfo(re, NULL, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
-      pcre_fullinfo(re, NULL, PCRE_INFO_NAMETABLE, &nametable);
+      pcre_fullinfo(re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
+      pcre_fullinfo(re, 0, PCRE_INFO_NAMECOUNT, &namecount);
+      pcre_fullinfo(re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
+      pcre_fullinfo(re, 0, PCRE_INFO_NAMETABLE, &nametable);
 
       OCTAVE_LOCAL_BUFFER(int, ovector, (subpatterns+1)*3);
       OCTAVE_LOCAL_BUFFER(int, nidx, namecount);
 
       for (int i = 0; i < namecount; i++)
 	{
 	  // Index of subpattern in first two bytes MSB first of name.
 	  // Extract index.
 	  nidx[i] = (static_cast<int>(nametable[i*nameentrysize])) << 8 |
 	    static_cast<int>(nametable[i*nameentrysize+1]);
 	}
 
       while(true)
 	{
 	  OCTAVE_QUIT;
 
-	  int matches = pcre_exec(re, NULL, buffer.c_str(), 
+	  int matches = pcre_exec(re, 0, buffer.c_str(), 
 				  buffer.length(), idx, 
 				  (idx ? PCRE_NOTBOL : 0),
 				  ovector, (subpatterns+1)*3);
 
 	  if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
 	    {
 	      error ("%s: internal error calling pcre_exec", nm.c_str());
 	      pcre_free(re);
@@ -370,17 +370,17 @@ octregexp_list (const octave_value_list 
 
       pcre_free(re);
 #else
       regex_t compiled;
       int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED | 
 		      (case_insensitive ? REG_ICASE : 0));
       if (err)
 	{
-	  int len = regerror(err, &compiled, NULL, 0);
+	  int len = regerror(err, &compiled, 0, 0);
 	  OCTAVE_LOCAL_BUFFER (char, errmsg, len);
 	  regerror(err, &compiled, errmsg, len);
 	  error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
 		pattern.c_str());
 	  regfree(&compiled);
 	  return 0;
 	}
 
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -104,34 +104,34 @@ factorization as determined by @var{typ}
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
 
   double spu = octave_sparse_params::get_key ("spumoni");
   if (spu == 0.)
     {
       cm->print = -1;
-      cm->print_function = NULL;
+      cm->print_function = 0;
     }
   else
     {
       cm->print = static_cast<int> (spu) + 2;
       cm->print_function =&SparseCholPrint;
     }
 
   cm->error_handler = &SparseCholError;
   cm->complex_divide = CHOLMOD_NAME(divcomplex);
   cm->hypotenuse = CHOLMOD_NAME(hypot);
 
   double dummy;
   cholmod_sparse Astore;
   cholmod_sparse *A = &Astore;
   A->packed = true;
   A->sorted = true;
-  A->nz = NULL;
+  A->nz = 0;
 #ifdef IDX_TYPE_LONG
   A->itype = CHOLMOD_LONG;
 #else
   A->itype = CHOLMOD_INT;
 #endif
   A->dtype = CHOLMOD_DOUBLE;
   A->stype = 1;
   A->x = &dummy;
@@ -217,44 +217,44 @@ factorization as determined by @var{typ}
       CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
       if (cm->status < CHOLMOD_OK)
 	{
 	  error("matrix corrupted");
 	  goto symbfact_error;
 	}
 
-      if (CHOLMOD_NAME(postorder) (Parent, n, NULL, Post, cm) != n)
+      if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
 	{
 	  error("postorder failed");
 	  goto symbfact_error;
 	}
 
-      CHOLMOD_NAME(rowcolcounts) (Alo, NULL, 0, Parent, Post, NULL,
+      CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
 				  ColCount, First, Level, cm);
 
       if (cm->status < CHOLMOD_OK)
 	{
 	  error("matrix corrupted");
 	  goto symbfact_error;
 	}
 
       if (nargout > 4)
 	{
 	  cholmod_sparse *A1, *A2;
 
 	  if (A->stype == 1)
 	    {
 	      A1 = A;
-	      A2 = NULL;
+	      A2 = 0;
 	    }
 	  else if (A->stype == -1)
 	    {
 	      A1 = F;
-	      A2 = NULL;
+	      A2 = 0;
 	    }
 	  else if (coletree)
 	    {
 	      A1 = F;
 	      A2 = A;
 	    }
 	  else
 	    {
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -42,18 +42,18 @@ along with Octave; see the file COPYING.
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS) 
 #define SMALLBUFSIZE 1
 
 /*****************************************************************************/
 
 // Default constructor
 gzfilebuf::gzfilebuf()
-: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),
-  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)
+: file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
+  buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
   this->disable_buffer();
 }
 
 // Destructor
 gzfilebuf::~gzfilebuf()
 {
@@ -76,81 +76,81 @@ gzfilebuf::setcompression(int comp_level
 
 // Open gzipped file
 gzfilebuf*
 gzfilebuf::open(const char *name,
                 std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open())
-    return NULL;
+    return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
+    return 0;
 
   // Build mode string for gzopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (!this->open_mode(mode, char_mode))
-    return NULL;
+    return 0;
 
   // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == NULL)
-    return NULL;
+  if ((file = gzopen(name, char_mode)) == 0)
+    return 0;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
 gzfilebuf::attach(int fd,
                   std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open())
-    return NULL;
+    return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
+    return 0;
 
   // Build mode string for gzdopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (!this->open_mode(mode, char_mode))
-    return NULL;
+    return 0;
 
   // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == NULL)
-    return NULL;
+  if ((file = gzdopen(fd, char_mode)) == 0)
+    return 0;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer();
   io_mode = mode;
   own_fd = false;
   return this;
 }
 
 // Close gzipped file
 gzfilebuf*
 gzfilebuf::close()
 {
   // Fail immediately if no file is open
   if (!this->is_open())
-    return NULL;
+    return 0;
   // Assume success
   gzfilebuf* retval = this;
   // Attempt to sync and close gzipped file
   if (this->sync() == -1)
-    retval = NULL;
+    retval = 0;
   if (gzclose(file) < 0)
-    retval = NULL;
+    retval = 0;
   // File is now gone anyway (postcondition [27.8.1.3.8])
-  file = NULL;
+  file = 0;
   own_fd = false;
   // Destroy internal buffer if it exists
   this->disable_buffer();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
@@ -346,26 +346,26 @@ gzfilebuf::overflow(int_type c)
 
 // Assign new buffer
 std::streambuf*
 gzfilebuf::setbuf(char_type* p,
                   std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
   if (this->sync() == -1)
-    return NULL;
+    return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
   // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
   if (!p || !n)
   {
     // Replace existing buffer (if any) with small internal buffer
     this->disable_buffer();
-    buffer = NULL;
+    buffer = 0;
     buffer_size = 0;
     own_buffer = true;
     this->enable_buffer();
   }
   else
   {
     // Replace existing buffer (if any) with external buffer
     this->disable_buffer();
@@ -431,17 +431,17 @@ gzfilebuf::disable_buffer()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
   {
     // Preserve unbuffered status by zeroing size
     if (!this->pbase())
       buffer_size = 0;
     delete[] buffer;
-    buffer = NULL;
+    buffer = 0;
     this->setg(0, 0, 0);
     this->setp(0, 0);
   }
   else
   {
     // Reset buffer pointers to initial state if external buffer exists
     this->setg(buffer, buffer, buffer);
     if (buffer)
@@ -505,32 +505,32 @@ gzfilebuf::seekpos(pos_type sp, std::ios
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzifstream::gzifstream()
-: std::istream(NULL), sb()
+: std::istream(0), sb()
 { this->init(&sb); }
 
 // Initialize stream buffer and open file
 gzifstream::gzifstream(const char* name,
                        std::ios_base::openmode mode)
-: std::istream(NULL), sb()
+: std::istream(0), sb()
 {
   this->init(&sb);
   this->open(name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzifstream::gzifstream(int fd,
                        std::ios_base::openmode mode)
-: std::istream(NULL), sb()
+: std::istream(0), sb()
 {
   this->init(&sb);
   this->attach(fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzifstream::open(const char* name,
@@ -560,32 +560,32 @@ gzifstream::close()
   if (!sb.close())
     this->setstate(std::ios_base::failbit);
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzofstream::gzofstream()
-: std::ostream(NULL), sb()
+: std::ostream(0), sb()
 { this->init(&sb); }
 
 // Initialize stream buffer and open file
 gzofstream::gzofstream(const char* name,
                        std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
+: std::ostream(0), sb()
 {
   this->init(&sb);
   this->open(name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzofstream::gzofstream(int fd,
                        std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
+: std::ostream(0), sb()
 {
   this->init(&sb);
   this->attach(fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzofstream::open(const char* name,
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -78,17 +78,17 @@ public:
   setcompression(int comp_level,
                  int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() const { return (file != NULL); }
+  is_open() const { return (file != 0); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
