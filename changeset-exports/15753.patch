# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1354944285 18000
#      Sat Dec 08 00:24:45 2012 -0500
# Node ID 6e39fe7992d9b3539dde299a2a9d9c1c4f336910
# Parent  f96faf028d90ffb6fb84f1145ffb6dc749456e0b
style fixes and copyright update for java files

* ClassHelper.java, DlgListener.java, JDialogBox.java,
Matrix.java, OctClassLoader.java, Octave.java, OctaveReference.java,
TeXcode.java, TeXtranslator.java:
Use Octave copyright text.  Style fixes.

diff --git a/scripts/java/org/octave/ClassHelper.java b/scripts/java/org/octave/ClassHelper.java
--- a/scripts/java/org/octave/ClassHelper.java
+++ b/scripts/java/org/octave/ClassHelper.java
@@ -1,955 +1,946 @@
-/* Copyright (C) 2007 Michael Goffioul
- **
- ** This program is free software; you can redistribute it and/or modify
- ** it under the terms of the GNU General Public License as published by
- ** the Free Software Foundation; either version 2 of the License, or
- ** (at your option) any later version.
- **
- ** This program is distributed in the hope that it will be useful,
- ** but WITHOUT ANY WARRANTY; without even the implied warranty of
- ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- ** GNU General Public License for more details.
- **
- ** You should have received a copy of the GNU General Public License
- ** along with this program; If not, see <http://www.gnu.org/licenses/>.
- */
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
 
 package org.octave;
 
 import java.lang.reflect.*;
 
 public class ClassHelper
 {
-   private static OctClassLoader loader;
+  private static OctClassLoader loader;
 
-   static
-   {
-      ClassLoader l = ClassHelper.class.getClassLoader ();
-      loader = ( l instanceof OctClassLoader ? ( OctClassLoader ) l :
-                 new OctClassLoader ( l ) );
-   }
+  static
+  {
+    ClassLoader l = ClassHelper.class.getClassLoader ();
+    loader = (l instanceof OctClassLoader ? (OctClassLoader) l :
+              new OctClassLoader (l));
+  }
 
 
-   /**
-    * Add the given path to the classpath.
-    * @param name String - path to addd to the classpath
-    * @return boolean - true if the given path exists and was added to the classpath.
-    * @throws Exception
-    */
-   public static boolean addClassPath ( String name )
-      throws Exception
-   {
-      boolean found = false;
-      java.io.File f = new java.io.File ( name );
-      if ( f.exists () )
+  /**
+   * Add the given path to the classpath.
+   * @param name String - path to addd to the classpath
+   * @return boolean - true if the given path exists and was added to the classpath.
+   * @throws Exception
+   */
+  public static boolean addClassPath (String name)
+    throws Exception
+  {
+    boolean found = false;
+    java.io.File f = new java.io.File (name);
+    if (f.exists ())
       {
-         loader.addClassPath ( name );
-         found = true;
+        loader.addClassPath (name);
+        found = true;
       }
-      return ( found );
-   }
+    return (found);
+  }
 
 
-   // new -MH-
-   /**
-    *
-    * @param name String - path to remove from classpath.
-    * @return boolean - true if the given path existed in the classpath before it was removed.
-    * @throws Exception
-    */
-   public static boolean removeClassPath ( String name )
-      throws Exception
-   {
-      boolean found = false;
-      java.io.File f = new java.io.File ( name );
-      java.net.URL urlToRemove = f.toURI ().toURL ();
-      // save urls in current class path
-      java.net.URL[] urls = loader.getURLs ();
+  // new -MH-
+  /**
+   *
+   * @param name String - path to remove from classpath.
+   * @return boolean - true if the given path existed in the classpath before it was removed.
+   * @throws Exception
+   */
+  public static boolean removeClassPath (String name)
+    throws Exception
+  {
+    boolean found = false;
+    java.io.File f = new java.io.File (name);
+    java.net.URL urlToRemove = f.toURI ().toURL ();
+    // save urls in current class path
+    java.net.URL[] urls = loader.getURLs ();
 
-      // create a completely new class loader because java.net.URLClassLoader has no removeClassPath() method
-      ClassLoader l = ClassHelper.class.getClassLoader ();
-      loader = ( l instanceof OctClassLoader ? ( OctClassLoader ) l :
-                 new OctClassLoader ( l ) );
+    // create a completely new class loader because java.net.URLClassLoader has no removeClassPath() method
+    ClassLoader l = ClassHelper.class.getClassLoader ();
+    loader = (l instanceof OctClassLoader ? (OctClassLoader) l :
+              new OctClassLoader (l));
 
-      // add the previous urls back, except for the one
-      for ( int i = 0; i < urls.length; i++ )
+    // add the previous urls back, except for the one
+    for (int i = 0; i < urls.length; i++)
       {
-         java.net.URL url = urls[i];
-         if ( !url.equals ( urlToRemove ) )
-         {
-            loader.addURL ( url );
-         }
-         else
-         {
+        java.net.URL url = urls[i];
+        if (!url.equals (urlToRemove))
+          {
+            loader.addURL (url);
+          }
+        else
+          {
             // path to remove
             found = true;
-         }
+          }
       }
 
-      return ( found );
-   }
+    return (found);
+  }
 
 
-   public static String getClassPath ()
-   {
-      StringBuffer buf = new StringBuffer ();
-      String pathSep = System.getProperty ( "path.separator" );
-      java.net.URL[] urls = loader.getURLs ();
+  public static String getClassPath ()
+  {
+    StringBuffer buf = new StringBuffer ();
+    String pathSep = System.getProperty ("path.separator");
+    java.net.URL[] urls = loader.getURLs ();
 
-      for ( int i = 0; i < urls.length; i++ )
+    for (int i = 0; i < urls.length; i++)
       {
-         try
-         {
-            java.io.File f = new java.io.File ( urls[i].toURI () );
-            if ( buf.length () > 0 )
-            {
-               buf.append ( pathSep );
-            }
-            buf.append ( f.toString () );
-         }
-         catch ( java.net.URISyntaxException ex )
-         {}
+        try
+          {
+            java.io.File f = new java.io.File (urls[i].toURI ());
+            if (buf.length () > 0)
+              {
+                buf.append (pathSep);
+              }
+            buf.append (f.toString ());
+          }
+        catch (java.net.URISyntaxException ex)
+          {}
       }
-      return buf.toString ();
-   }
+    return buf.toString ();
+  }
 
 
-   // new -MH-
-   // return list of methods for given class name
-   public static String getMethods ( String classname )
-      throws ClassNotFoundException
-   {
-      return ( getMethods ( Class.forName ( classname ) ) );
-   }
+  // new -MH-
+  // return list of methods for given class name
+  public static String getMethods (String classname)
+    throws ClassNotFoundException
+  {
+    return (getMethods (Class.forName (classname)));
+  }
 
 
-   // new -MH-
-   // return list of methods for given class instance
-   public static String getMethods ( Object obj )
-      throws ClassNotFoundException
-   {
-      return ( getMethods ( obj.getClass () ) );
-   }
+  // new -MH-
+  // return list of methods for given class instance
+  public static String getMethods (Object obj)
+    throws ClassNotFoundException
+  {
+    return (getMethods (obj.getClass ()));
+  }
 
 
-   // new -MH-
-   // return list of methods for given class
-   public static String getMethods ( Class klass )
-   {
-      StringBuffer sb = new StringBuffer ();
+  // new -MH-
+  // return list of methods for given class
+  public static String getMethods (Class klass)
+  {
+    StringBuffer sb = new StringBuffer ();
 
-      Method theMethod[] = klass.getMethods ();
-      for ( int i = 0; i < theMethod.length; i++ )
+    Method theMethod[] = klass.getMethods ();
+    for (int i = 0; i < theMethod.length; i++)
       {
-         if ( i > 0 )
-         {
-            sb.append ( ";" );
-         }
-         sb.append ( theMethod[i].getReturnType ().getCanonicalName () );
-         sb.append ( " " );
-         sb.append ( theMethod[i].getName () );
-         sb.append ( "(" );
+        if (i > 0)
+          {
+            sb.append (";");
+          }
+        sb.append (theMethod[i].getReturnType ().getCanonicalName ());
+        sb.append (" ");
+        sb.append (theMethod[i].getName ());
+        sb.append ("(");
 
-         Class theParameter[] = theMethod[i].getParameterTypes ();
-         for ( int j = 0; j < theParameter.length; j++ )
-         {
-            if ( j > 0 )
-            {
-               sb.append ( ", " );
-            }
-            sb.append ( theParameter[j].getCanonicalName () );
-         }
-         sb.append ( ")" );
+        Class theParameter[] = theMethod[i].getParameterTypes ();
+        for (int j = 0; j < theParameter.length; j++)
+          {
+            if (j > 0)
+              {
+                sb.append (", ");
+              }
+            sb.append (theParameter[j].getCanonicalName ());
+          }
+        sb.append (")");
 
-         Class theExceptions[] = theMethod[i].getExceptionTypes ();
-         if ( theExceptions.length > 0 )
-         {
-            sb.append ( " throws " );
-            for ( int j = 0; j < theExceptions.length; j++ )
-            {
-               if ( j > 0 )
-               {
-                  sb.append ( ", " );
-               }
-               sb.append ( theExceptions[j].getCanonicalName () );
-            }
-         }
+        Class theExceptions[] = theMethod[i].getExceptionTypes ();
+        if (theExceptions.length > 0)
+          {
+            sb.append (" throws ");
+            for (int j = 0; j < theExceptions.length; j++)
+              {
+                if (j > 0)
+                  {
+                    sb.append (", ");
+                  }
+                sb.append (theExceptions[j].getCanonicalName ());
+              }
+          }
       }
 
-      return ( sb.toString () );
-   }
+    return (sb.toString ());
+  }
 
 
-   // new -MH-
-   // return list of fields for given class
-   public static String getFields ( Class klass )
-   {
-      StringBuffer sb = new StringBuffer ();
+  // new -MH-
+  // return list of fields for given class
+  public static String getFields (Class klass)
+  {
+    StringBuffer sb = new StringBuffer ();
 
-      Field theField[] = klass.getFields ();
-      for ( int i = 0; i < theField.length; i++ )
+    Field theField[] = klass.getFields ();
+    for (int i = 0; i < theField.length; i++)
       {
-         if ( i > 0 )
-         {
-            sb.append ( ";" );
-         }
-         sb.append ( theField[i].toString () );
+        if (i > 0)
+          {
+            sb.append (";");
+          }
+        sb.append (theField[i].toString ());
       }
 
-      return ( sb.toString () );
-   }
+    return (sb.toString ());
+  }
 
 
-   // new -MH-
-   // return list of fields for given class name
-   public static String getFields ( String classname )
-      throws ClassNotFoundException
-   {
-      return ( getFields ( Class.forName ( classname ) ) );
-   }
+  // new -MH-
+  // return list of fields for given class name
+  public static String getFields (String classname)
+    throws ClassNotFoundException
+  {
+    return (getFields (Class.forName (classname)));
+  }
 
 
-   // new -MH-
-   // return list of fields for given class instance
-   public static String getFields ( Object obj )
-      throws ClassNotFoundException
-   {
-      return ( getFields ( obj.getClass () ) );
-   }
+  // new -MH-
+  // return list of fields for given class instance
+  public static String getFields (Object obj)
+    throws ClassNotFoundException
+  {
+    return (getFields (obj.getClass ()));
+  }
 
 
-   public static Method findMethod ( Class cls, String name, Class[] argTypes )
-   {
-      try
+  public static Method findMethod (Class cls, String name, Class[] argTypes)
+  {
+    try
       {
-         return cls.getMethod ( name, argTypes );
+        return cls.getMethod (name, argTypes);
       }
-      catch ( Exception e )
+    catch (Exception e)
       {
-         Method[] mList = cls.getMethods ();
-         Method m;
-         for ( int i = 0; i < mList.length; i++ )
-         {
+        Method[] mList = cls.getMethods ();
+        Method m;
+        for (int i = 0; i < mList.length; i++)
+          {
             m = mList[i];
-            if ( m.getName ().equals ( name ) &&
-                 m.getParameterTypes ().length == argTypes.length &&
-                 isCallableFrom ( m, argTypes ) )
-            {
-               return m;
-            }
-         }
-         return null;
+            if (m.getName ().equals (name)
+                && m.getParameterTypes ().length == argTypes.length
+                && isCallableFrom (m, argTypes))
+              {
+                return m;
+              }
+          }
+        return null;
       }
-   }
+  }
 
 
-   public static Constructor findConstructor ( Class cls, Class[] argTypes )
-   {
-      try
+  public static Constructor findConstructor (Class cls, Class[] argTypes)
+  {
+    try
       {
-         return cls.getConstructor ( argTypes );
+        return cls.getConstructor (argTypes);
       }
-      catch ( Exception e )
+    catch (Exception e)
       {
-         Constructor[] cList = cls.getConstructors ();
-         //System.out.println("# constructors: " + cList.length);
-         Constructor c;
-         for ( int i = 0; i < cList.length; i++ )
-         {
+        Constructor[] cList = cls.getConstructors ();
+        //System.out.println("# constructors: " + cList.length);
+        Constructor c;
+        for (int i = 0; i < cList.length; i++)
+          {
             //System.out.println("Considering constructor: " + cList[i]);
             c = cList[i];
-            if ( c.getParameterTypes ().length == argTypes.length &&
-                 isCallableFrom ( c, argTypes ) )
-            {
-               return c;
-            }
-         }
-         return null;
+            if (c.getParameterTypes ().length == argTypes.length
+                && isCallableFrom (c, argTypes))
+              {
+                return c;
+              }
+          }
+        return null;
       }
-   }
+  }
 
 
-   private static Object invokeMethod ( Method m, Object target, Object[] args )
-      throws Exception
-   {
-      try
+  private static Object invokeMethod (Method m, Object target, Object[] args)
+    throws Exception
+  {
+    try
       {
-         return m.invoke ( target, args );
+        return m.invoke (target, args);
       }
-      catch ( IllegalAccessException ex )
+    catch (IllegalAccessException ex)
       {
-         String mName = m.getName ();
-         Class[] pTypes = m.getParameterTypes ();
-         Class currClass = target.getClass ();
+        String mName = m.getName ();
+        Class[] pTypes = m.getParameterTypes ();
+        Class currClass = target.getClass ();
 
-         while ( currClass != null )
-         {
+        while (currClass != null)
+          {
             try
-            {
-               Method meth = currClass.getMethod ( mName, pTypes );
-               if ( !meth.equals ( m ) )
-               {
-                  return meth.invoke ( target, args );
-               }
-            }
-            catch ( NoSuchMethodException ex2 )
-            {}
-            catch ( IllegalAccessException ex2 )
-            {}
+              {
+                Method meth = currClass.getMethod (mName, pTypes);
+                if (!meth.equals (m))
+                  {
+                    return meth.invoke (target, args);
+                  }
+              }
+            catch (NoSuchMethodException ex2)
+              {}
+            catch (IllegalAccessException ex2)
+              {}
 
             Class[] ifaceList = currClass.getInterfaces ();
-            for ( int i = 0; i < ifaceList.length; i++ )
-            {
-               try
-               {
-                  Method meth = ifaceList[i].getMethod ( mName, pTypes );
-                  return meth.invoke ( target, args );
-               }
-               catch ( NoSuchMethodException ex2 )
-               {}
-               catch ( IllegalAccessException ex2 )
-               {}
-            }
+            for (int i = 0; i < ifaceList.length; i++)
+              {
+                try
+                  {
+                    Method meth = ifaceList[i].getMethod (mName, pTypes);
+                    return meth.invoke (target, args);
+                  }
+                catch (NoSuchMethodException ex2)
+                  {}
+                catch (IllegalAccessException ex2)
+                  {}
+              }
 
             currClass = currClass.getSuperclass ();
-         }
+          }
 
-         throw ex;
+        throw ex;
       }
-   }
+  }
 
 
-   public static Object invokeMethod ( Object target, String name,
-                                       Object[] args, Class[] argTypes )
-      throws Throwable
-   {
-      Method m = findMethod ( target.getClass (), name, argTypes );
-      if ( m != null )
+  public static Object invokeMethod (Object target, String name,
+                                     Object[] args, Class[] argTypes)
+    throws Throwable
+  {
+    Method m = findMethod (target.getClass (), name, argTypes);
+    if (m != null)
       {
-         try
-         {
-            Object result = invokeMethod ( m, target,
-                                           castArguments ( args, argTypes,
-               m.getParameterTypes () ) );
+        try
+          {
+            Object result = invokeMethod (m, target,
+                                          castArguments (args, argTypes,
+                                                         m.getParameterTypes ()));
             return result;
-         }
-         catch ( InvocationTargetException ex )
-         {
+          }
+        catch (InvocationTargetException ex)
+          {
             throw ex.getCause ();
-         }
+          }
       }
-      else
+    else
       {
-         throw new NoSuchMethodException ( name );
+        throw new NoSuchMethodException (name);
       }
-   }
+  }
 
 
-   public static Object invokeStaticMethod ( String cls, String name,
-                                             Object[] args, Class[] argTypes )
-      throws Throwable
-   {
-      Method m = findMethod ( Class.forName ( cls, true, loader ), name,
-                              argTypes );
-      if ( m != null )
+  public static Object invokeStaticMethod (String cls, String name,
+                                           Object[] args, Class[] argTypes)
+    throws Throwable
+  {
+    Method m = findMethod (Class.forName (cls, true, loader), name,
+                           argTypes);
+    if (m != null)
       {
-         try
-         {
-            Object result = m.invoke ( null,
-                                       castArguments ( args, argTypes,
-               m.getParameterTypes () ) );
+        try
+          {
+            Object result = m.invoke (null,
+                                      castArguments (args, argTypes,
+                                                     m.getParameterTypes ()));
             return result;
-         }
-         catch ( InvocationTargetException ex )
-         {
+          }
+        catch (InvocationTargetException ex)
+          {
             throw ex.getCause ();
-         }
+          }
       }
-      else
+    else
       {
-         throw new NoSuchMethodException ( name );
+        throw new NoSuchMethodException (name);
       }
-   }
+  }
 
 
-   public static Object invokeConstructor ( String cls, Object[] args,
-                                            Class[] argTypes )
-      throws Throwable
-   {
-      Constructor c = findConstructor ( Class.forName ( cls, true, loader ),
-                                        argTypes );
-      if ( c != null )
+  public static Object invokeConstructor (String cls, Object[] args,
+                                          Class[] argTypes)
+    throws Throwable
+  {
+    Constructor c = findConstructor (Class.forName (cls, true, loader),
+                                     argTypes);
+    if (c != null)
       {
-         try
-         {
-            Object result = c.newInstance ( castArguments ( args, argTypes,
-               c.getParameterTypes () ) );
+        try
+          {
+            Object result = c.newInstance (castArguments (args, argTypes,
+                                                          c.getParameterTypes ()));
             return result;
-         }
-         catch ( InvocationTargetException ex )
-         {
+          }
+        catch (InvocationTargetException ex)
+          {
             throw ex.getCause ();
-         }
+          }
       }
-      else
+    else
       {
-         throw new NoSuchMethodException ( cls );
+        throw new NoSuchMethodException (cls);
       }
-   }
+  }
 
 
-   public static Object getField ( Object target, String name )
-      throws Throwable
-   {
-      try
+  public static Object getField (Object target, String name)
+    throws Throwable
+  {
+    try
       {
-         Field f = target.getClass ().getField ( name );
-         return f.get ( target );
+        Field f = target.getClass ().getField (name);
+        return f.get (target);
       }
-      catch ( NoSuchFieldException ex )
+    catch (NoSuchFieldException ex)
       {
-         try
-         {
-            return invokeMethod ( target, name, new Object[0], new Class[0] );
-         }
-         catch ( NoSuchMethodException ex2 )
-         {
+        try
+          {
+            return invokeMethod (target, name, new Object[0], new Class[0]);
+          }
+        catch (NoSuchMethodException ex2)
+          {
             throw ex;
-         }
+          }
       }
-   }
+  }
 
 
-   public static Object getStaticField ( String cls, String name )
-      throws Throwable
-   {
-      try
+  public static Object getStaticField (String cls, String name)
+    throws Throwable
+  {
+    try
       {
-         Field f = Class.forName ( cls, true, loader ).getField ( name );
-         return f.get ( null );
+        Field f = Class.forName (cls, true, loader).getField (name);
+        return f.get (null);
       }
-      catch ( NoSuchFieldException ex )
+    catch (NoSuchFieldException ex)
       {
-         try
-         {
-            return invokeStaticMethod ( cls, name, new Object[0], new Class[0] );
-         }
-         catch ( NoSuchMethodException ex2 )
-         {
+        try
+          {
+            return invokeStaticMethod (cls, name, new Object[0], new Class[0]);
+          }
+        catch (NoSuchMethodException ex2)
+          {
             throw ex;
-         }
+          }
       }
-   }
+  }
 
 
-   public static void setField ( Object target, String name, Object value )
-      throws Exception
-   {
-      Field f = target.getClass ().getField ( name );
-      f.set ( target, castArgument ( value, value.getClass (), f.getType () ) );
-   }
+  public static void setField (Object target, String name, Object value)
+    throws Exception
+  {
+    Field f = target.getClass ().getField (name);
+    f.set (target, castArgument (value, value.getClass (), f.getType ()));
+  }
 
 
-   public static void setStaticField ( String cls, String name, Object value )
-      throws Exception
-   {
-      Field f = Class.forName ( cls, true, loader ).getField ( name );
-      f.set ( null, castArgument ( value, value.getClass (), f.getType () ) );
-   }
+  public static void setStaticField (String cls, String name, Object value)
+    throws Exception
+  {
+    Field f = Class.forName (cls, true, loader).getField (name);
+    f.set (null, castArgument (value, value.getClass (), f.getType ()));
+  }
 
 
-   private static boolean isCallableFrom ( Method m, Class[] argTypes )
-   {
-      Class[] expTypes = m.getParameterTypes ();
-      for ( int i = 0; i < argTypes.length; i++ )
+  private static boolean isCallableFrom (Method m, Class[] argTypes)
+  {
+    Class[] expTypes = m.getParameterTypes ();
+    for (int i = 0; i < argTypes.length; i++)
       {
-         if ( !isCallableFrom ( expTypes[i], argTypes[i] ) )
-         {
+        if (!isCallableFrom (expTypes[i], argTypes[i]))
+          {
             return false;
-         }
+          }
       }
-      return true;
-   }
+    return true;
+  }
 
 
-   private static boolean isCallableFrom ( Constructor c, Class[] argTypes )
-   {
-      Class[] expTypes = c.getParameterTypes ();
-      for ( int i = 0; i < argTypes.length; i++ )
+  private static boolean isCallableFrom (Constructor c, Class[] argTypes)
+  {
+    Class[] expTypes = c.getParameterTypes ();
+    for (int i = 0; i < argTypes.length; i++)
       {
-         if ( !isCallableFrom ( expTypes[i], argTypes[i] ) )
-         {
+        if (!isCallableFrom (expTypes[i], argTypes[i]))
+          {
             return false;
-         }
+          }
       }
-      return true;
-   }
+    return true;
+  }
 
 
-   private static boolean isCallableFrom ( Class expCls, Class argCls )
-   {
-      //System.out.println("isCallableFrom: "+expCls.getCanonicalName() + " <=? " + argCls.getCanonicalName());
-      if ( argCls == null )
+  private static boolean isCallableFrom (Class expCls, Class argCls)
+  {
+    //System.out.println("isCallableFrom: "+expCls.getCanonicalName() + " <=? " + argCls.getCanonicalName());
+    if (argCls == null)
       {
-         return!expCls.isPrimitive ();
+        return!expCls.isPrimitive ();
       }
-      else if ( expCls.isAssignableFrom ( argCls ) )
+    else if (expCls.isAssignableFrom (argCls))
       {
-         return true;
+        return true;
       }
-      else if ( ( isNumberClass ( expCls ) || isBooleanClass ( expCls ) ) &&
-                isNumberClass ( argCls ) )
+    else if ((isNumberClass (expCls) || isBooleanClass (expCls))
+             && isNumberClass (argCls))
       {
-         return true;
+        return true;
       }
-      else if ( isCharClass ( expCls ) && argCls.equals ( Character.class ) )
+    else if (isCharClass (expCls) && argCls.equals (Character.class))
       {
-         /*
+        /*
           modified into a more strict check to avoid char to string matching
           to avoid matching method signatureslike
           java_method(char) with octave_call('a String')
           Date: 28-08-2010
           Author: Martin Hepperle
-          */
-         return true;
+        */
+        return true;
       }
-      else if ( isStringClass ( expCls ) && argCls.equals ( String.class ) )
+    else if (isStringClass (expCls) && argCls.equals (String.class))
       {
-         /*
+        /*
           added for strict String to String matching
           java_method(String) with octave_call('a String')
           but not
           java_method(char) with octave_call('a String')
           Date: 28-08-2010
           Author: Martin Hepperle
-          */
-         return true;
+        */
+        return true;
       }
-      else if ( expCls.isArray () && argCls.isArray () &&
-                isCallableFrom ( expCls.getComponentType (),
-                                 argCls.getComponentType () ) )
+    else if (expCls.isArray () && argCls.isArray ()
+             && isCallableFrom (expCls.getComponentType (),
+                                argCls.getComponentType ()))
       {
-         return true;
+        return true;
       }
-      else if ( expCls.equals ( Object.class ) && argCls.isPrimitive () )
+    else if (expCls.equals (Object.class) && argCls.isPrimitive ())
       {
-         return true;
+        return true;
       }
-      else
+    else
       {
-         return false;
+        return false;
       }
-   }
+  }
 
 
-   private static boolean isNumberClass ( Class cls )
-   {
-      return (
-         cls.equals ( Integer.TYPE ) ||
-         cls.equals ( Integer.class ) ||
-         cls.equals ( Short.TYPE ) ||
-         cls.equals ( Short.class ) ||
-         cls.equals ( Long.TYPE ) ||
-         cls.equals ( Long.class ) ||
-         cls.equals ( Float.TYPE ) ||
-         cls.equals ( Float.class ) ||
-         cls.equals ( Double.TYPE ) ||
-         cls.equals ( Double.class )
-         );
-   }
+  private static boolean isNumberClass (Class cls)
+  {
+    return (cls.equals (Integer.TYPE) || cls.equals (Integer.class)
+            || cls.equals (Short.TYPE) || cls.equals (Short.class)
+            || cls.equals (Long.TYPE) || cls.equals (Long.class)
+            || cls.equals (Float.TYPE) || cls.equals (Float.class)
+            || cls.equals (Double.TYPE) || cls.equals (Double.class));
+  }
 
 
-   private static boolean isBooleanClass ( Class cls )
-   {
-      return (
-         cls.equals ( Boolean.class ) ||
-         cls.equals ( Boolean.TYPE )
-         );
-   }
+  private static boolean isBooleanClass (Class cls)
+  {
+    return (cls.equals (Boolean.class) || cls.equals (Boolean.TYPE));
+  }
 
 
-   private static boolean isCharClass ( Class cls )
-   {
-      return (
-         cls.equals ( Character.class ) ||
-         cls.equals ( Character.TYPE )
-         );
-   }
+  private static boolean isCharClass (Class cls)
+  {
+    return (cls.equals (Character.class) || cls.equals (Character.TYPE));
+  }
 
 
-   /**
-    * Check whether the supplied class is a String class.
-    *
-    * Added for more strict char/string mathicng of method signatures
-    * Date: 28-08-2010
-    * Author: Martin Hepperle
-    * @param cls Class - the class to check
-    * @return boolean - true if clas is of class java.lang.String
-    */
-   private static boolean isStringClass ( Class cls )
-   {
-      return (
-         cls.equals ( String.class )
-         );
-   }
+  /**
+   * Check whether the supplied class is a String class.
+   *
+   * Added for more strict char/string mathicng of method signatures
+   * Date: 28-08-2010
+   * Author: Martin Hepperle
+   * @param cls Class - the class to check
+   * @return boolean - true if clas is of class java.lang.String
+   */
+  private static boolean isStringClass (Class cls)
+  {
+    return (
+            cls.equals (String.class)
+            );
+  }
 
 
-   private static Object[] castArguments ( Object[] args, Class[] argTypes,
-                                           Class[] expTypes )
-   {
-      for ( int i = 0; i < args.length; i++ )
+  private static Object[] castArguments (Object[] args, Class[] argTypes,
+                                         Class[] expTypes)
+  {
+    for (int i = 0; i < args.length; i++)
       {
-         args[i] = castArgument ( args[i], argTypes[i], expTypes[i] );
+        args[i] = castArgument (args[i], argTypes[i], expTypes[i]);
       }
-      return args;
-   }
+    return args;
+  }
 
 
-   private static Object castArgument ( Object obj, Class type, Class expType )
-   {
-      // System.out.println("expType:"+expType.getCanonicalName() + " <= type:" + type.getCanonicalName());
-      if ( type == null || expType.isAssignableFrom ( type ) )
+  private static Object castArgument (Object obj, Class type, Class expType)
+  {
+    // System.out.println("expType:"+expType.getCanonicalName() + " <= type:" + type.getCanonicalName());
+    if (type == null || expType.isAssignableFrom (type))
       {
-         return obj;
+        return obj;
       }
-      else if ( isNumberClass ( expType ) )
+    else if (isNumberClass (expType))
       {
-         if ( expType.equals ( Integer.TYPE ) || expType.equals ( Integer.class ) )
-         {
-            return new Integer ( ( ( Number ) obj ).intValue () );
-         }
-         else if ( expType.equals ( Double.TYPE ) || expType.equals ( Double.class ) )
-         {
-            return new Double ( ( ( Number ) obj ).doubleValue () );
-         }
-         else if ( expType.equals ( Short.TYPE ) || expType.equals ( Short.class ) )
-         {
-            return new Short ( ( ( Number ) obj ).shortValue () );
-         }
-         else if ( expType.equals ( Long.TYPE ) || expType.equals ( Long.class ) )
-         {
-            return new Long ( ( ( Number ) obj ).longValue () );
-         }
+        if (expType.equals (Integer.TYPE) || expType.equals (Integer.class))
+          {
+            return new Integer (((Number) obj).intValue ());
+          }
+        else if (expType.equals (Double.TYPE) || expType.equals (Double.class))
+          {
+            return new Double (((Number) obj).doubleValue ());
+          }
+        else if (expType.equals (Short.TYPE) || expType.equals (Short.class))
+          {
+            return new Short (((Number) obj).shortValue ());
+          }
+        else if (expType.equals (Long.TYPE) || expType.equals (Long.class))
+          {
+            return new Long (((Number) obj).longValue ());
+          }
       }
-      else if ( isBooleanClass ( expType ) )
+    else if (isBooleanClass (expType))
       {
-         return new Boolean ( ( ( Number ) obj ).intValue () != 0 );
+        return new Boolean (((Number) obj).intValue () != 0);
       }
-      else if ( isCharClass ( expType ) )
+    else if (isCharClass (expType))
       {
-         String s = obj.toString ();
-         if ( s.length () != 1 )
-         {
-            throw new ClassCastException ( "cannot cast " + s + " to character" );
-         }
-         return new Character ( s.charAt ( 0 ) );
+        String s = obj.toString ();
+        if (s.length () != 1)
+          {
+            throw new ClassCastException ("cannot cast " + s + " to character");
+          }
+        return new Character (s.charAt (0));
       }
-      else if ( expType.isArray () && type.isArray () )
+    else if (expType.isArray () && type.isArray ())
       {
-         return castArray ( obj, type.getComponentType (),
-                            expType.getComponentType () );
+        return castArray (obj, type.getComponentType (),
+                          expType.getComponentType ());
       }
-      else if ( type.isPrimitive () )
+    else if (type.isPrimitive ())
       {
-         return obj;
+        return obj;
       }
-      return null;
-   }
+    return null;
+  }
 
 
-   private static Object castArray ( Object obj, Class elemType,
-                                     Class elemExpType )
-   {
-      int len = Array.getLength ( obj );
-      Object result = Array.newInstance ( elemExpType, len );
-      for ( int i = 0; i < len; i++ )
+  private static Object castArray (Object obj, Class elemType,
+                                   Class elemExpType)
+  {
+    int len = Array.getLength (obj);
+    Object result = Array.newInstance (elemExpType, len);
+    for (int i = 0; i < len; i++)
       {
-         Array.set ( result, i,
-                     castArgument ( Array.get ( obj, i ), elemType, elemExpType ) );
+        Array.set (result, i,
+                   castArgument (Array.get (obj, i), elemType, elemExpType));
       }
-      return result;
-   }
+    return result;
+  }
 
 
-   private static int getArrayClassNDims ( Class cls )
-   {
-      if ( cls != null && cls.isArray () )
+  private static int getArrayClassNDims (Class cls)
+  {
+    if (cls != null && cls.isArray ())
       {
-         return ( 1 + getArrayClassNDims ( cls.getComponentType () ) );
+        return (1 + getArrayClassNDims (cls.getComponentType ()));
       }
-      else
+    else
       {
-         return 0;
+        return 0;
       }
-   }
+  }
 
 
-   private static Class getArrayElemClass ( Class cls )
-   {
-      if ( cls.isArray () )
+  private static Class getArrayElemClass (Class cls)
+  {
+    if (cls.isArray ())
       {
-         return getArrayElemClass ( cls.getComponentType () );
+        return getArrayElemClass (cls.getComponentType ());
       }
-      else
+    else
       {
-         return cls;
+        return cls;
       }
-   }
+  }
 
 
-   private static Object getArrayElements ( Object array, int[][] idx,
-                                            int offset,
-                                            int ndims, Class elemType )
-   {
-      if ( offset >= ndims )
+  private static Object getArrayElements (Object array, int[][] idx,
+                                          int offset,
+                                          int ndims, Class elemType)
+  {
+    if (offset >= ndims)
       {
-         Object elem = Array.get ( array, idx[offset][0] );
-         if ( offset < idx.length - 1 )
-         {
-            return getArrayElements ( elem, idx, offset + 1, ndims, elemType );
-         }
-         else
-         {
+        Object elem = Array.get (array, idx[offset][0]);
+        if (offset < idx.length - 1)
+          {
+            return getArrayElements (elem, idx, offset + 1, ndims, elemType);
+          }
+        else
+          {
             return elem;
-         }
+          }
       }
-      else
+    else
       {
-         Class compType = elemType.getComponentType ();
-         Object retval = Array.newInstance ( compType, idx[offset].length );
-         for ( int i = 0; i < idx[offset].length; i++ )
-         {
-            Object elem = Array.get ( array, idx[offset][i] );
-            if ( offset < idx.length - 1 )
-            {
-               elem = getArrayElements ( elem, idx, offset + 1, ndims, compType );
-            }
-            Array.set ( retval, i, elem );
-         }
-         return retval;
+        Class compType = elemType.getComponentType ();
+        Object retval = Array.newInstance (compType, idx[offset].length);
+        for (int i = 0; i < idx[offset].length; i++)
+          {
+            Object elem = Array.get (array, idx[offset][i]);
+            if (offset < idx.length - 1)
+              {
+                elem = getArrayElements (elem, idx, offset + 1, ndims, compType);
+              }
+            Array.set (retval, i, elem);
+          }
+        return retval;
       }
-   }
+  }
 
 
-   public static Object arraySubsref ( Object obj, int[][] idx )
-      throws Exception
-   {
-      if ( !obj.getClass ().isArray () )
+  public static Object arraySubsref (Object obj, int[][] idx)
+    throws Exception
+  {
+    if (!obj.getClass ().isArray ())
       {
-         throw new IllegalArgumentException ( "not a Java array" );
+        throw new IllegalArgumentException ("not a Java array");
       }
 
-      if ( idx.length == 1 )
+    if (idx.length == 1)
       {
-         if ( idx[0].length == 1 )
-         {
-            return Array.get ( obj, idx[0][0] );
-         }
-         else
-         {
-            Object retval = Array.newInstance ( obj.getClass ().
-                                                getComponentType (),
-                                                idx[0].length );
-            for ( int i = 0; i < idx[0].length; i++ )
-            {
-               Array.set ( retval, i, Array.get ( obj, idx[0][i] ) );
-            }
+        if (idx[0].length == 1)
+          {
+            return Array.get (obj, idx[0][0]);
+          }
+        else
+          {
+            Object retval = Array.newInstance (obj.getClass ().
+                                               getComponentType (),
+                                               idx[0].length);
+            for (int i = 0; i < idx[0].length; i++)
+              {
+                Array.set (retval, i, Array.get (obj, idx[0][i]));
+              }
             return retval;
-         }
+          }
       }
-      else
+    else
       {
-         int[] dims = new int[idx.length];
-         for ( int i = 0; i < idx.length; i++ )
-         {
+        int[] dims = new int[idx.length];
+        for (int i = 0; i < idx.length; i++)
+          {
             dims[i] = idx[i].length;
-         }
+          }
 
-         if ( dims.length != getArrayClassNDims ( obj.getClass () ) )
-         {
-            throw new IllegalArgumentException ( "index size mismatch" );
-         }
+        if (dims.length != getArrayClassNDims (obj.getClass ()))
+          {
+            throw new IllegalArgumentException ("index size mismatch");
+          }
 
-         /* resolve leading singletons */
-         Object theObj = obj;
-         int offset = 0;
-         while ( dims[offset] == 1 )
-         {
-            theObj = Array.get ( theObj, idx[offset][0] );
+        /* resolve leading singletons */
+        Object theObj = obj;
+        int offset = 0;
+        while (dims[offset] == 1)
+          {
+            theObj = Array.get (theObj, idx[offset][0]);
             offset = offset + 1;
-            if ( offset >= dims.length )
-            {
-               return theObj;
-            }
-         }
-         if ( offset > 0 )
-         {
+            if (offset >= dims.length)
+              {
+                return theObj;
+              }
+          }
+        if (offset > 0)
+          {
             int[][] new_idx = new int[idx.length - offset][];
-            System.arraycopy ( idx, offset, new_idx, 0, idx.length - offset );
-            return arraySubsref ( theObj, new_idx );
-         }
+            System.arraycopy (idx, offset, new_idx, 0, idx.length - offset);
+            return arraySubsref (theObj, new_idx);
+          }
 
-         /* chop trailing singletons */
-         int ndims = dims.length;
-         while ( ndims > 1 && dims[ndims - 1] == 1 )
-         {
+        /* chop trailing singletons */
+        int ndims = dims.length;
+        while (ndims > 1 && dims[ndims - 1] == 1)
+          {
             ndims--;
-         }
+          }
 
-         /* create result array */
-         Class elemClass = theObj.getClass ();
-         for ( int i = 0; i <= ( dims.length - ndims ); i++ )
-         {
+        /* create result array */
+        Class elemClass = theObj.getClass ();
+        for (int i = 0; i <= (dims.length - ndims); i++)
+          {
             elemClass = elemClass.getComponentType ();
-         }
-         Object retval = Array.newInstance ( elemClass, dims[0] );
+          }
+        Object retval = Array.newInstance (elemClass, dims[0]);
 
-         /* fill-in array */
-         for ( int i = 0; i < idx[0].length; i++ )
-         {
-            Object elem = getArrayElements ( Array.get ( theObj, idx[0][i] ),
-                                             idx, 1, ndims, elemClass );
-            Array.set ( retval, i, elem );
-         }
+        /* fill-in array */
+        for (int i = 0; i < idx[0].length; i++)
+          {
+            Object elem = getArrayElements (Array.get (theObj, idx[0][i]),
+                                            idx, 1, ndims, elemClass);
+            Array.set (retval, i, elem);
+          }
 
-         return retval;
+        return retval;
       }
-   }
+  }
 
 
-   private static Object setArrayElements ( Object array, int[][] idx,
-                                            int offset, int ndims, Object rhs )
-      throws Exception
-   {
-      if ( offset >= ndims )
+  private static Object setArrayElements (Object array, int[][] idx,
+                                          int offset, int ndims, Object rhs)
+    throws Exception
+  {
+    if (offset >= ndims)
       {
-         if ( offset < idx.length - 1 )
-         {
-            setArrayElements ( Array.get ( array, idx[offset][0] ), idx,
-                               offset + 1, ndims, rhs );
-         }
-         else
-         {
-            Array.set ( array, idx[offset][0], rhs );
-         }
-         return array;
+        if (offset < idx.length - 1)
+          {
+            setArrayElements (Array.get (array, idx[offset][0]), idx,
+                              offset + 1, ndims, rhs);
+          }
+        else
+          {
+            Array.set (array, idx[offset][0], rhs);
+          }
+        return array;
       }
-      else
+    else
       {
-         for ( int i = 0; i < idx[offset].length; i++ )
-         {
-            if ( offset < idx.length - 1 )
-            {
-               setArrayElements ( Array.get ( array, idx[offset][i] ), idx,
-                                  offset + 1, ndims, Array.get ( rhs, i ) );
-            }
+        for (int i = 0; i < idx[offset].length; i++)
+          {
+            if (offset < idx.length - 1)
+              {
+                setArrayElements (Array.get (array, idx[offset][i]), idx,
+                                  offset + 1, ndims, Array.get (rhs, i));
+              }
             else
-            {
-               Array.set ( array, idx[offset][i], Array.get ( rhs, i ) );
-            }
-         }
-         return array;
+              {
+                Array.set (array, idx[offset][i], Array.get (rhs, i));
+              }
+          }
+        return array;
       }
-   }
+  }
 
 
-   public static Object arraySubsasgn ( Object obj, int[][] idx, Object rhs )
-      throws Exception
-   {
-      if ( !obj.getClass ().isArray () )
+  public static Object arraySubsasgn (Object obj, int[][] idx, Object rhs)
+    throws Exception
+  {
+    if (!obj.getClass ().isArray ())
       {
-         throw new IllegalArgumentException ( "not a Java array" );
+        throw new IllegalArgumentException ("not a Java array");
       }
 
-      if ( idx.length == 1 )
+    if (idx.length == 1)
       {
-         if ( idx[0].length == 1 )
-         {
-            Array.set ( obj, idx[0][0], rhs );
-         }
-         else
-         {
-            for ( int i = 0; i < idx[0].length; i++ )
-            {
-               Array.set ( obj, idx[0][i], Array.get ( rhs, i ) );
-            }
-         }
-         return obj;
+        if (idx[0].length == 1)
+          {
+            Array.set (obj, idx[0][0], rhs);
+          }
+        else
+          {
+            for (int i = 0; i < idx[0].length; i++)
+              {
+                Array.set (obj, idx[0][i], Array.get (rhs, i));
+              }
+          }
+        return obj;
       }
-      else
+    else
       {
-         int[] dims = new int[idx.length];
-         for ( int i = 0; i < idx.length; i++ )
-         {
+        int[] dims = new int[idx.length];
+        for (int i = 0; i < idx.length; i++)
+          {
             dims[i] = idx[i].length;
-         }
+          }
 
-         if ( dims.length != getArrayClassNDims ( obj.getClass () ) )
-         {
-            throw new IllegalArgumentException ( "index size mismatch" );
-         }
+        if (dims.length != getArrayClassNDims (obj.getClass ()))
+          {
+            throw new IllegalArgumentException ("index size mismatch");
+          }
 
-         /* resolve leading singletons */
-         Object theObj = obj;
-         int offset = 0;
-         while ( dims[offset] == 1 && offset < ( dims.length - 1 ) )
-         {
-            theObj = Array.get ( theObj, idx[offset][0] );
+        /* resolve leading singletons */
+        Object theObj = obj;
+        int offset = 0;
+        while (dims[offset] == 1 && offset < (dims.length - 1))
+          {
+            theObj = Array.get (theObj, idx[offset][0]);
             offset = offset + 1;
-         }
-         if ( offset > 0 )
-         {
+          }
+        if (offset > 0)
+          {
             int[][] new_idx = new int[idx.length - offset][];
-            System.arraycopy ( idx, offset, new_idx, 0, idx.length - offset );
-            arraySubsasgn ( theObj, new_idx, rhs );
+            System.arraycopy (idx, offset, new_idx, 0, idx.length - offset);
+            arraySubsasgn (theObj, new_idx, rhs);
             return obj;
-         }
+          }
 
-         /* chop trailing singletons */
-         int ndims = dims.length;
-         while ( ndims > 1 && dims[ndims - 1] == 1 )
-         {
+        /* chop trailing singletons */
+        int ndims = dims.length;
+        while (ndims > 1 && dims[ndims - 1] == 1)
+          {
             ndims--;
-         }
+          }
 
-         for ( int i = 0; i < idx[0].length; i++ )
-         {
-            setArrayElements ( Array.get ( theObj, idx[0][i] ), idx, 1, ndims,
-                               Array.get ( rhs, i ) );
-         }
+        for (int i = 0; i < idx[0].length; i++)
+          {
+            setArrayElements (Array.get (theObj, idx[0][i]), idx, 1, ndims,
+                              Array.get (rhs, i));
+          }
 
-         return obj;
+        return obj;
       }
-   }
+  }
 
 
-   public static Object createArray ( Object cls, int[] dims )
-      throws Exception
-   {
-      Class theClass;
-      if ( cls instanceof Class )
+  public static Object createArray (Object cls, int[] dims)
+    throws Exception
+  {
+    Class theClass;
+    if (cls instanceof Class)
       {
-         theClass = ( Class ) cls;
+        theClass = (Class) cls;
       }
-      else if ( cls instanceof String )
+    else if (cls instanceof String)
       {
-         theClass = Class.forName ( ( String ) cls, true, loader );
+        theClass = Class.forName ((String) cls, true, loader);
       }
-      else
+    else
       {
-         throw new IllegalArgumentException ( "invalid class specification " +
-                                              cls );
+        throw new IllegalArgumentException ("invalid class specification " +
+                                            cls);
       }
 
-      return Array.newInstance ( theClass, dims );
-   }
+    return Array.newInstance (theClass, dims);
+  }
 
 
-   public static Object createArray ( Object cls, int length )
-      throws Exception
-   {
-      return createArray ( cls, new int[]
-                           {length} );
-   }
-
+  public static Object createArray (Object cls, int length)
+    throws Exception
+  {
+    return createArray (cls, new int[] {length});
+  }
 }
diff --git a/scripts/java/org/octave/DlgListener.java b/scripts/java/org/octave/DlgListener.java
--- a/scripts/java/org/octave/DlgListener.java
+++ b/scripts/java/org/octave/DlgListener.java
@@ -1,159 +1,164 @@
 /*
- ** Copyright (C) 2010 Martin Hepperle
- **
- ** This program is free software; you can redistribute it and/or modify
- ** it under the terms of the GNU General Public License as published by
- ** the Free Software Foundation; either version 2 of the License, or
- ** (at your option) any later version.
- **
- ** This program is distributed in the hope that it will be useful,
- ** but WITHOUT ANY WARRANTY; without even the implied warranty of
- ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- ** GNU General Public License for more details.
- **
- ** You should have received a copy of the GNU General Public License
- ** along with this program; If not, see <http://www.gnu.org/licenses/>.
- */
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
 
 package org.octave;
 
 import java.awt.event.*;
 import javax.swing.*;
 
 /**
  * <p>Implements button click actions for dialog box functions</p>
  *
  * <p>Copyright (c) 2010 Martin Hepperle</p>
  *
  * @author Martin Hepperle
  * @version 1.0
  */
 public class DlgListener
-   extends WindowAdapter implements ActionListener, KeyListener
+  extends WindowAdapter implements ActionListener, KeyListener
 {
-   // the parent frame of the dialog
-   JDialogBox m_Parent;
+  // the parent frame of the dialog
+  JDialogBox m_Parent;
 
-   public DlgListener ( JDialogBox d )
-   {
-      m_Parent = d;
-   }
+  public DlgListener (JDialogBox d)
+  {
+    m_Parent = d;
+  }
 
 
-   //
-   // --- extension of the WindowAdapter class ---
-   //
-   /**
-    * Called when the user clicks the close button on the window frame.
-    *
-    * @param e WindowEvent
-    */
-   public void windowClosing ( WindowEvent e )
-   {
-      m_Parent.closeDialog ( JDialogBox.CLOSE_CANCEL );
-   }
+  //
+  // --- extension of the WindowAdapter class ---
+  //
+  /**
+   * Called when the user clicks the close button on the window frame.
+   *
+   * @param e WindowEvent
+   */
+  public void windowClosing (WindowEvent e)
+  {
+    m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
+  }
 
-   public void windowOpened( WindowEvent e )
-   {
-      m_Parent.setFocus();
-   }
+  public void windowOpened(WindowEvent e)
+  {
+    m_Parent.setFocus();
+  }
 
 
-   //
-   // --- implementation of the ActionListener interface ---
-   //
-   /**
-    * Called when the user clicks a button in the dialog.
-    * Closes the dialog when either a button with an
-    * action command OK, CANCEL or NO is pressed.
-    *
-    * @param e ActionEvent
-    */
-   public void actionPerformed ( ActionEvent e )
-   {
-      if ( e.getActionCommand ().equals ( "OK" ) )
+  //
+  // --- implementation of the ActionListener interface ---
+  //
+  /**
+   * Called when the user clicks a button in the dialog.
+   * Closes the dialog when either a button with an
+   * action command OK, CANCEL or NO is pressed.
+   *
+   * @param e ActionEvent
+   */
+  public void actionPerformed (ActionEvent e)
+  {
+    if (e.getActionCommand ().equals ("OK"))
       {
-         m_Parent.closeDialog ( JDialogBox.CLOSE_OK );
+        m_Parent.closeDialog (JDialogBox.CLOSE_OK);
       }
-      else if ( e.getActionCommand ().equals ( "CANCEL" ) )
+    else if (e.getActionCommand ().equals ("CANCEL"))
       {
-         m_Parent.closeDialog ( JDialogBox.CLOSE_CANCEL );
+        m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
       }
-      else if ( e.getActionCommand ().equals ( "NO" ) )
+    else if (e.getActionCommand ().equals ("NO"))
       {
-         m_Parent.closeDialog ( JDialogBox.CLOSE_NO );
+        m_Parent.closeDialog (JDialogBox.CLOSE_NO);
       }
-      else if ( e.getActionCommand ().equals ( "SELALL" ) )
+    else if (e.getActionCommand ().equals ("SELALL"))
       {
-         m_Parent.SelectAll ();
+        m_Parent.SelectAll ();
       }
-   }
+  }
 
 
-   //
-   // --- implementation of the KeyListener interface ---
-   //
-   /**
-    * Closes the dialog when the ENTER or ESCAPE keys are released.
-    *
-    * @param e KeyEvent
-    */
-   public void keyTyped ( KeyEvent e )
-   {
-      if ( e.getKeyCode () == KeyEvent.VK_ESCAPE )
+  //
+  // --- implementation of the KeyListener interface ---
+  //
+  /**
+   * Closes the dialog when the ENTER or ESCAPE keys are released.
+   *
+   * @param e KeyEvent
+   */
+  public void keyTyped (KeyEvent e)
+  {
+    if (e.getKeyCode () == KeyEvent.VK_ESCAPE)
       {
-         m_Parent.closeDialog ( JDialogBox.CLOSE_CANCEL );
+        m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
       }
-   }
+  }
 
 
-   /**
-    * @param e KeyEvent
-    */
-   public void keyPressed ( KeyEvent e )
-   {
-      if ( e.getSource ().getClass ().equals ( JTextArea.class ) )
+  /**
+   * @param e KeyEvent
+   */
+  public void keyPressed (KeyEvent e)
+  {
+    if (e.getSource ().getClass ().equals (JTextArea.class))
       {
-         JTextArea ta = ( JTextArea ) e.getSource ();
-         if ( e.getKeyCode () == KeyEvent.VK_ENTER )
-         {
+        JTextArea ta = (JTextArea) e.getSource ();
+        if (e.getKeyCode () == KeyEvent.VK_ENTER)
+          {
             char c[] = ta.getText ().toCharArray ();
             int nLines = 1;
-            for ( int i = 0; i < c.length; i++ )
-            {
-               if ( c[i] == '\n' )
-               {
-                  nLines++;
-               }
-            }
+            for (int i = 0; i < c.length; i++)
+              {
+                if (c[i] == '\n')
+                  {
+                    nLines++;
+                  }
+              }
 
-            if ( nLines >= ta.getRows () )
-            {
-               e.consume ();
-            }
-         }
-         else if ( e.getKeyCode () == KeyEvent.VK_TAB )
-         {
+            if (nLines >= ta.getRows ())
+              {
+                e.consume ();
+              }
+          }
+        else if (e.getKeyCode () == KeyEvent.VK_TAB)
+          {
             e.consume ();
 
-            if ( ( e.getModifiersEx () & KeyEvent.SHIFT_DOWN_MASK ) ==
-                 KeyEvent.SHIFT_DOWN_MASK )
-            {
-               ta.transferFocusBackward();
-            }
+            if ((e.getModifiersEx () & KeyEvent.SHIFT_DOWN_MASK) ==
+                KeyEvent.SHIFT_DOWN_MASK)
+              {
+                ta.transferFocusBackward();
+              }
             else
-            {
-               ta.transferFocus ();
-            }
-         }
+              {
+                ta.transferFocus ();
+              }
+          }
       }
-   }
+  }
 
 
-   /**
-    * @param e KeyEvent
-    */
-   public void keyReleased ( KeyEvent e )
-   {
-   }
+  /**
+   * @param e KeyEvent
+   */
+  public void keyReleased (KeyEvent e)
+  {
+  }
 }
diff --git a/scripts/java/org/octave/JDialogBox.java b/scripts/java/org/octave/JDialogBox.java
--- a/scripts/java/org/octave/JDialogBox.java
+++ b/scripts/java/org/octave/JDialogBox.java
@@ -1,24 +1,29 @@
- /*
-  ** Copyright (C) 2010 Martin Hepperle
-  **
-  ** This program is free software; you can redistribute it and/or modify
-  ** it under the terms of the GNU General Public License as published by
-  ** the Free Software Foundation; either version 2 of the License, or
-  ** (at your option) any later version.
-  **
-  ** This program is distributed in the hope that it will be useful,
-  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
-  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  ** GNU General Public License for more details.
-  **
-  ** You should have received a copy of the GNU General Public License
-  ** along with this program; If not, see <http://www.gnu.org/licenses/>.
-  */
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
 
 package org.octave;
 
 import java.net.*;
 import java.util.*;
 
 import java.awt.*;
 import javax.swing.*;
@@ -36,951 +41,951 @@ import javax.swing.*;
  *
  * <p>Copyright (c) 2010 Martin Hepperle</p>
  *
  * @author Martin Hepperle
  * @version 1.0
  */
 public class JDialogBox
 {
-   public static final int CLOSE_OK = 1;
-   public static final int CLOSE_NO = 2;
-   public static final int CLOSE_CANCEL = 3;
+  public static final int CLOSE_OK = 1;
+  public static final int CLOSE_NO = 2;
+  public static final int CLOSE_CANCEL = 3;
 
-   // dialog type
-   public static int FLAG_LABEL = 1;
-   public static int FLAG_TEXT = 2;
-   public static int FLAG_INPUT = 4;
-   public static int FLAG_LIST = 8;
-   // icon selection
-   public static int FLAG_QUESTION = 32;
-   public static int FLAG_ERROR = 64;
-   public static int FLAG_WARNING = 128;
-   public static int FLAG_INFORMATION = 256;
+  // dialog type
+  public static int FLAG_LABEL = 1;
+  public static int FLAG_TEXT = 2;
+  public static int FLAG_INPUT = 4;
+  public static int FLAG_LIST = 8;
+  // icon selection
+  public static int FLAG_QUESTION = 32;
+  public static int FLAG_ERROR = 64;
+  public static int FLAG_WARNING = 128;
+  public static int FLAG_INFORMATION = 256;
 
-   public static int DLG_QUEST = FLAG_QUESTION | FLAG_TEXT;
-   public static int DLG_INPUT = FLAG_QUESTION | FLAG_INPUT;
-   public static int DLG_LIST = FLAG_QUESTION | FLAG_LIST;
+  public static int DLG_QUEST = FLAG_QUESTION | FLAG_TEXT;
+  public static int DLG_INPUT = FLAG_QUESTION | FLAG_INPUT;
+  public static int DLG_LIST = FLAG_QUESTION | FLAG_LIST;
 
-   private final static String m_OK = "OK";
-   private final static String m_Yes = "Yes";
-   private final static String m_No = "No";
-   private final static String m_Cancel = "Cancel";
+  private final static String m_OK = "OK";
+  private final static String m_Yes = "Yes";
+  private final static String m_No = "No";
+  private final static String m_Cancel = "Cancel";
 
-   private JButton m_ButtonNO;
-   private JButton m_ButtonOK;
-   private JButton m_ButtonCANCEL;
-   private JButton m_Focus;
-   private JTextArea m_TextField[];
-   private JList m_List;
-   private JFrame m_ParentFrame;
-   private int m_CloseMethod;
+  private JButton m_ButtonNO;
+  private JButton m_ButtonOK;
+  private JButton m_ButtonCANCEL;
+  private JButton m_Focus;
+  private JTextArea m_TextField[];
+  private JList m_List;
+  private JFrame m_ParentFrame;
+  private int m_CloseMethod;
 
-   // ------------------------------------
-   // implementation of listdlg function
-   // ------------------------------------
+  // ------------------------------------
+  // implementation of listdlg function
+  // ------------------------------------
 
-   /**
-    *
-    * @param listcell String[] - a array of strings, one for each list entry
-    * @param selmode String
-    * @param sizecell Object[]
-    * @param initialcell Object[]
-    * @param name String
-    * @param promptcell String[]
-    * @param okstring String
-    * @param cancelstring String
-    * @return String[]
-    */
-   public static int[] listdlg ( String[] listcell,
-                                 String selmode,
-                                 Object[] sizecell,
-                                 Object[] initialcell,
-                                 String name,
-                                 String[] promptcell,
-                                 String okstring,
-                                 String cancelstring )
-   {
-      JDialogBox d = new JDialogBox ();
-      d.genericdlg ( promptcell, listcell, name, selmode,
-                     DLG_LIST,
-                     sizecell, initialcell, okstring, null, cancelstring );
-      return ( d.getSelectedIndices () );
-   }
+  /**
+   *
+   * @param listcell String[] - a array of strings, one for each list entry
+   * @param selmode String
+   * @param sizecell Object[]
+   * @param initialcell Object[]
+   * @param name String
+   * @param promptcell String[]
+   * @param okstring String
+   * @param cancelstring String
+   * @return String[]
+   */
+  public static int[] listdlg (String[] listcell,
+                               String selmode,
+                               Object[] sizecell,
+                               Object[] initialcell,
+                               String name,
+                               String[] promptcell,
+                               String okstring,
+                               String cancelstring)
+  {
+    JDialogBox d = new JDialogBox ();
+    d.genericdlg (promptcell, listcell, name, selmode,
+                  DLG_LIST,
+                  sizecell, initialcell, okstring, null, cancelstring);
+    return (d.getSelectedIndices ());
+  }
 
 
-   // ------------------------------------
-   // implementation of inputdlg function
-   // -------------------------------------
+  // ------------------------------------
+  // implementation of inputdlg function
+  // -------------------------------------
 
-   /**
-    * Implements a variation of the inputdlg function.
-    *
-    * @param prompt String[] - an array of text strings to be used as labels.
-    * @param title String - a text string to be used to label the dialog caption.
-    * @param RowsCols int - defines the width of the text fields in columns.
-    * @param defaults Object[] - an array of text strings or numbers to be
-    * placed into the text fields as default values.
-    * @return String[] - an array of text strings containing the content of the
-    * text fields.
-    */
-   public static String[] inputdlg ( String[] prompt,
-                                     String title,
-                                     Object[] RowsCols,
-                                     Object[] defaults )
-   {
-      JDialogBox d = new JDialogBox ();
-      d.genericdlg ( prompt, null, title, "on",
-                     FLAG_INPUT | FLAG_QUESTION,
-                     RowsCols, defaults, m_OK, null, m_Cancel );
-      return ( d.getInput () );
-   }
+  /**
+   * Implements a variation of the inputdlg function.
+   *
+   * @param prompt String[] - an array of text strings to be used as labels.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @param RowsCols int - defines the width of the text fields in columns.
+   * @param defaults Object[] - an array of text strings or numbers to be
+   * placed into the text fields as default values.
+   * @return String[] - an array of text strings containing the content of the
+   * text fields.
+   */
+  public static String[] inputdlg (String[] prompt,
+                                   String title,
+                                   Object[] RowsCols,
+                                   Object[] defaults)
+  {
+    JDialogBox d = new JDialogBox ();
+    d.genericdlg (prompt, null, title, "on",
+                  FLAG_INPUT | FLAG_QUESTION,
+                  RowsCols, defaults, m_OK, null, m_Cancel);
+    return (d.getInput ());
+  }
 
 
-   /**
-    * Extract the current content from the text fields of an inputdlg.
-    *
-    * @return String[] - the text contained in the fields of an inputdlg.
-    * null if the dialog was cancelled.
-    */
-   private String[] getInput ()
-   {
-      String s[] = null;
+  /**
+   * Extract the current content from the text fields of an inputdlg.
+   *
+   * @return String[] - the text contained in the fields of an inputdlg.
+   * null if the dialog was cancelled.
+   */
+  private String[] getInput ()
+  {
+    String s[] = null;
 
-      if ( m_CloseMethod == CLOSE_OK )
+    if (m_CloseMethod == CLOSE_OK)
       {
-         s = new String[m_TextField.length];
+        s = new String[m_TextField.length];
 
-         for ( int i = 0; i < s.length; i++ )
-         {
-            s[i] = new String ( m_TextField[i].getText () );
-         }
+        for (int i = 0; i < s.length; i++)
+          {
+            s[i] = new String (m_TextField[i].getText ());
+          }
       }
 
-      return ( s );
-   }
+    return (s);
+  }
 
 
-   private String getResult ()
-   {
-      String s = null;
+  private String getResult ()
+  {
+    String s = null;
 
-      if ( m_CloseMethod == CLOSE_OK )
+    if (m_CloseMethod == CLOSE_OK)
       {
-         s = m_ButtonOK.getText ();
+        s = m_ButtonOK.getText ();
       }
-      else if ( m_CloseMethod == CLOSE_CANCEL )
+    else if (m_CloseMethod == CLOSE_CANCEL)
       {
-         s = m_ButtonCANCEL.getText ();
+        s = m_ButtonCANCEL.getText ();
       }
-      else
+    else
       {
-         s = m_ButtonNO.getText ();
+        s = m_ButtonNO.getText ();
       }
 
-      return ( s );
-   }
+    return (s);
+  }
 
 
-   /**
-    * Extract the current content from the text fields of an inputdlg.
-    *
-    * @return String[] - the text contained in the fields of an inputdlg.
-    * null if the dialog was cancelled.
-    */
-   private String[] getSelection ()
-   {
-      String s[] = null;
+  /**
+   * Extract the current content from the text fields of an inputdlg.
+   *
+   * @return String[] - the text contained in the fields of an inputdlg.
+   * null if the dialog was cancelled.
+   */
+  private String[] getSelection ()
+  {
+    String s[] = null;
 
-      if ( m_CloseMethod == CLOSE_OK )
+    if (m_CloseMethod == CLOSE_OK)
       {
-         int selection[] = m_List.getSelectedIndices ();
+        int selection[] = m_List.getSelectedIndices ();
 
-         s = new String[selection.length];
+        s = new String[selection.length];
 
-         for ( int i = 0; i < s.length; i++ )
-         {
+        for (int i = 0; i < s.length; i++)
+          {
 
-            // s[i] = new String ( Integer.toString(selection[i]) );
-            s[i] = ( m_List.getSelectedValues ()[i] ).toString ();
-         }
+            // s[i] = new String (Integer.toString(selection[i]));
+            s[i] = (m_List.getSelectedValues ()[i]).toString ();
+          }
       }
 
-      return ( s );
-   }
+    return (s);
+  }
 
 
-   private int[] getSelectedIndices ()
-   {
-      int s[] = null;
+  private int[] getSelectedIndices ()
+  {
+    int s[] = null;
 
-      if ( m_CloseMethod == CLOSE_OK )
+    if (m_CloseMethod == CLOSE_OK)
       {
-         s = m_List.getSelectedIndices ();
-         for ( int i = 0; i < s.length; i++ )
-         {
+        s = m_List.getSelectedIndices ();
+        for (int i = 0; i < s.length; i++)
+          {
 
             // translate to 1 based indices
             s[i] = s[i] + 1;
-         }
+          }
       }
 
-      return ( s );
-   }
+    return (s);
+  }
 
 
-   public void SelectAll ()
-   {
-      if ( null != m_List )
+  public void SelectAll ()
+  {
+    if (null != m_List)
       {
-         m_List.setSelectionInterval ( 0, m_List.getModel ().getSize () - 1 );
+        m_List.setSelectionInterval (0, m_List.getModel ().getSize () - 1);
       }
-   }
+  }
 
 
-   // -------------------------------------
-   // implementation of helpdlg function
-   // -------------------------------------
+  // -------------------------------------
+  // implementation of helpdlg function
+  // -------------------------------------
 
-   /**
-    * Implements a simple helpdlg with default text and caption. Not very useful.
-    *
-    * Octave > helpdlg('helpstring','title')
-    *
-    * Called via helpdlg.m.
-    *
-    * @param helpstring String - a message string to be presented to the user.
-    * The string can have embedded newline (\n) characters to break the message
-    * into multiple lines.
-    * @param title String - a text string to be used to label the dialog caption.
-    * @return int - always 1
-    */
-   public static int helpdlg ( String helpstring, String title )
-   {
-      JDialogBox d = new JDialogBox ();
-      String s[] = new String[1];
-      s[0] = helpstring;
-      return ( d.genericdlg ( s, null, title, "on",
-                              FLAG_TEXT | FLAG_INFORMATION, null, null,
-                              m_OK, null, m_Cancel ) );
-   }
+  /**
+   * Implements a simple helpdlg with default text and caption. Not very useful.
+   *
+   * Octave > helpdlg('helpstring','title')
+   *
+   * Called via helpdlg.m.
+   *
+   * @param helpstring String - a message string to be presented to the user.
+   * The string can have embedded newline (\n) characters to break the message
+   * into multiple lines.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @return int - always 1
+   */
+  public static int helpdlg (String helpstring, String title)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = helpstring;
+    return (d.genericdlg (s, null, title, "on",
+                          FLAG_TEXT | FLAG_INFORMATION, null, null,
+                          m_OK, null, m_Cancel));
+  }
 
 
-   // -------------------------------------
-   // implementation of emptydlg function
-   // -------------------------------------
+  // -------------------------------------
+  // implementation of emptydlg function
+  // -------------------------------------
 
-   /**
-    * Implements a simple helpdlg with default text and caption. Not very useful.
-    *
-    * Octave > emptydlg('messagestring','title')
-    *
-    * Called via dlgbox.m.
-    *
-    * @param messagestring String - a message string to be presented to the user.
-    * The string can have embedded newline (\n) characters to break the message
-    * into multiple lines.
-    * @param title String - a text string to be used to label the dialog caption.
-    * @return int - always 1
-    */
-   public static int emptydlg ( String helpstring, String title )
-   {
-      JDialogBox d = new JDialogBox ();
-      String s[] = new String[1];
-      s[0] = helpstring;
-      return ( d.genericdlg ( s, null, title, "on",
-                              FLAG_TEXT, null, null,
-                              m_OK, null, m_Cancel ) );
-   }
+  /**
+   * Implements a simple helpdlg with default text and caption. Not very useful.
+   *
+   * Octave > emptydlg('messagestring','title')
+   *
+   * Called via dlgbox.m.
+   *
+   * @param messagestring String - a message string to be presented to the user.
+   * The string can have embedded newline (\n) characters to break the message
+   * into multiple lines.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @return int - always 1
+   */
+  public static int emptydlg (String helpstring, String title)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = helpstring;
+    return (d.genericdlg (s, null, title, "on",
+                          FLAG_TEXT, null, null,
+                          m_OK, null, m_Cancel));
+  }
 
 
-   // -------------------------------------------
-   // implementation of questdlg related functions
-   // -------------------------------------------
+  // -------------------------------------------
+  // implementation of questdlg related functions
+  // -------------------------------------------
 
-   /**
-    * Implements a simple questdlg with default text and caption. Not very useful.
-    *
-    * @param question String - the question to be presented
-    * @param title String - the caption
-    * @param options String[] - 'str1', 'str2', 'str3', 'default'
-    * @return String - the caption of the button pressed by the user
-    */
-   public static String questdlg ( String question,
-                                   String title,
-                                   String[] options )
-   {
-      JDialogBox d = new JDialogBox ();
-      String s[] = new String[1];
-      s[0] = question;
-      d.genericdlg ( s, options, title, "on",
-                     DLG_QUEST, null, null,
-                     options[0], options[1], options[2] );
-      return ( d.getResult () );
-   }
+  /**
+   * Implements a simple questdlg with default text and caption. Not very useful.
+   *
+   * @param question String - the question to be presented
+   * @param title String - the caption
+   * @param options String[] - 'str1', 'str2', 'str3', 'default'
+   * @return String - the caption of the button pressed by the user
+   */
+  public static String questdlg (String question,
+                                 String title,
+                                 String[] options)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = question;
+    d.genericdlg (s, options, title, "on",
+                  DLG_QUEST, null, null,
+                  options[0], options[1], options[2]);
+    return (d.getResult ());
+  }
 
 
-   // -------------------------------------
-   // implementation of errordlg function
-   // -------------------------------------
+  // -------------------------------------
+  // implementation of errordlg function
+  // -------------------------------------
 
-   /**
-    * Implements a simple errordlg with default text and caption. Not very useful.
-    *
-    * @param errorstring String - the error message to display.
-    * @param dlgname String - the caption of the dialog box.
-    * @return int - always 1
-    */
-   public static int errordlg ( String errorstring, String dlgname )
-   {
-      JDialogBox d = new JDialogBox ();
-      String s[] = new String[1];
-      s[0] = errorstring;
-      return ( d.genericdlg ( s, null, dlgname, "on", FLAG_TEXT | FLAG_ERROR,
-                              null, null,
-                              m_OK, null, m_Cancel ) );
-   }
+  /**
+   * Implements a simple errordlg with default text and caption. Not very useful.
+   *
+   * @param errorstring String - the error message to display.
+   * @param dlgname String - the caption of the dialog box.
+   * @return int - always 1
+   */
+  public static int errordlg (String errorstring, String dlgname)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = errorstring;
+    return (d.genericdlg (s, null, dlgname, "on", FLAG_TEXT | FLAG_ERROR,
+                          null, null,
+                          m_OK, null, m_Cancel));
+  }
 
 
-   // -------------------------------------------
-   // implementation of warndlg related functions
-   // -------------------------------------------
+  // -------------------------------------------
+  // implementation of warndlg related functions
+  // -------------------------------------------
 
-   /**
-    * Implements a simple warndlg with default text and caption. Not very useful.
-    *
-    * Called via warndlg.m.
-    *
-    * @param errorstring String - the message to be presented to the user.
-    * @param dlgname String - the caption of the dialog box.
-    * @return int - always 1
-    */
-   public static int warndlg ( String errorstring, String dlgname )
-   {
-      JDialogBox d = new JDialogBox ();
-      String s[] = new String[1];
-      s[0] = errorstring;
-      return ( d.genericdlg ( s, null, dlgname, "on", FLAG_TEXT | FLAG_WARNING,
-                              null, null,
-                              m_OK, null, m_Cancel ) );
-   }
+  /**
+   * Implements a simple warndlg with default text and caption. Not very useful.
+   *
+   * Called via warndlg.m.
+   *
+   * @param errorstring String - the message to be presented to the user.
+   * @param dlgname String - the caption of the dialog box.
+   * @return int - always 1
+   */
+  public static int warndlg (String errorstring, String dlgname)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = errorstring;
+    return (d.genericdlg (s, null, dlgname, "on", FLAG_TEXT | FLAG_WARNING,
+                          null, null,
+                          m_OK, null, m_Cancel));
+  }
 
 
-   // -------------------------------------
-   // generic dlg function
-   // -------------------------------------
-   /**
-    * A generic dialog creation and display function.
-    *
-    * @param message String[]
-    * @param list String[]
-    * @param caption String
-    * @param on String
-    * @param flag int
-    * @param RowsCols Object[]
-    * @param defaults Object[]
-    * @param okstring String
-    * @param nostring String
-    * @param cancelstring String
-    * @return int
-    */
-   public int genericdlg ( String message[],
-                           String list[],
-                           String caption,
-                           String on,
-                           int flag,
-                           Object[] RowsCols,
-                           Object[] defaults,
-                           String okstring,
-                           String nostring,
-                           String cancelstring )
-   {
-      TeXtranslator theTranslator = new TeXtranslator ();
-      setSystemLnF ( true );
+  // -------------------------------------
+  // generic dlg function
+  // -------------------------------------
+  /**
+   * A generic dialog creation and display function.
+   *
+   * @param message String[]
+   * @param list String[]
+   * @param caption String
+   * @param on String
+   * @param flag int
+   * @param RowsCols Object[]
+   * @param defaults Object[]
+   * @param okstring String
+   * @param nostring String
+   * @param cancelstring String
+   * @return int
+   */
+  public int genericdlg (String message[],
+                         String list[],
+                         String caption,
+                         String on,
+                         int flag,
+                         Object[] RowsCols,
+                         Object[] defaults,
+                         String okstring,
+                         String nostring,
+                         String cancelstring)
+  {
+    TeXtranslator theTranslator = new TeXtranslator ();
+    setSystemLnF (true);
 
-      caption = theTranslator.replace ( caption );
+    caption = theTranslator.replace (caption);
 
-      m_ButtonNO = null;
-      m_ButtonOK = null;
-      m_ButtonCANCEL = null;
+    m_ButtonNO = null;
+    m_ButtonOK = null;
+    m_ButtonCANCEL = null;
 
-      // create a modal dialog with an empty frame as its parent
-      m_ParentFrame = new JFrame ();
+    // create a modal dialog with an empty frame as its parent
+    m_ParentFrame = new JFrame ();
 
-      // --- trick to bring dialog to the front
-      // In Windows, the dialog is not brought to the foreground, but hidden
-      // behind the Octave window as long as the parent frame is not visible.
-      // To avoid that the frame is visible, we move it outside of the screen.
-      m_ParentFrame.setBounds ( Toolkit.getDefaultToolkit ().getScreenSize ().
-                                width + 100,
-                                Toolkit.getDefaultToolkit ().getScreenSize ().
-                                height + 100, 1, 1 );
-      m_ParentFrame.setVisible ( true );
-      //-- end of trick
+    // --- trick to bring dialog to the front
+    // In Windows, the dialog is not brought to the foreground, but hidden
+    // behind the Octave window as long as the parent frame is not visible.
+    // To avoid that the frame is visible, we move it outside of the screen.
+    m_ParentFrame.setBounds (Toolkit.getDefaultToolkit ().getScreenSize ().
+                             width + 100,
+                             Toolkit.getDefaultToolkit ().getScreenSize ().
+                             height + 100, 1, 1);
+    m_ParentFrame.setVisible (true);
+    //-- end of trick
 
-      JDialog dlg;
-      dlg = new JDialog ( m_ParentFrame );
-      dlg.setTitle ( caption );
+    JDialog dlg;
+    dlg = new JDialog (m_ParentFrame);
+    dlg.setTitle (caption);
 
-      dlg.setModal ( true );
-      dlg.setDefaultCloseOperation ( JDialog.DISPOSE_ON_CLOSE );
+    dlg.setModal (true);
+    dlg.setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
 
-      DlgListener theListener = new DlgListener ( this );
+    DlgListener theListener = new DlgListener (this);
 
-      Container d = dlg.getContentPane ();
-      d.setLayout ( new BorderLayout ( 8, 8 ) );
+    Container d = dlg.getContentPane ();
+    d.setLayout (new BorderLayout (8, 8));
 
-      // spacer
-      d.add ( new JLabel ( " " ), BorderLayout.NORTH );
-      d.add ( new JLabel ( "  " ), BorderLayout.EAST );
+    // spacer
+    d.add (new JLabel (" "), BorderLayout.NORTH);
+    d.add (new JLabel ("  "), BorderLayout.EAST);
 
-      JPanel p = new JPanel ();
+    JPanel p = new JPanel ();
 
-      if ( FLAG_LABEL == ( FLAG_LABEL & flag ) )
+    if (FLAG_LABEL == (FLAG_LABEL & flag))
       {
-         // a single line label
-         JLabel l = new JLabel ( theTranslator.replace ( message[0] ) );
-         p.add ( l );
+        // a single line label
+        JLabel l = new JLabel (theTranslator.replace (message[0]));
+        p.add (l);
       }
-      else if ( FLAG_TEXT == ( FLAG_TEXT & flag ) )
+    else if (FLAG_TEXT == (FLAG_TEXT & flag))
       {
-         String msg = theTranslator.replace ( message[0] );
-         // a multi-line text display for helpdlg
-         StringTokenizer st = new StringTokenizer ( msg, "\n" );
+        String msg = theTranslator.replace (message[0]);
+        // a multi-line text display for helpdlg
+        StringTokenizer st = new StringTokenizer (msg, "\n");
 
-         int nRows = ( null == RowsCols ) ? 1 :
-                     Integer.parseInt ( RowsCols[0].toString () );
-         nRows = Math.max ( nRows, st.countTokens () );
-         int nCols = Math.max ( 1, msg.length () / nRows );
+        int nRows = (null == RowsCols) ? 1 :
+          Integer.parseInt (RowsCols[0].toString ());
+        nRows = Math.max (nRows, st.countTokens ());
+        int nCols = Math.max (1, msg.length () / nRows);
 
-         p.setLayout ( new GridLayout ( message.length, 1 ) );
-         JTextArea ta = new JTextArea ( msg, nRows, nCols );
-         ta.setEditable ( false );
-         ta.setFocusable ( false );
-         ta.setOpaque ( false );
-         // replace ugly monospaced font
-         ta.setFont ( p.getFont () );
-         p.add ( ta );
+        p.setLayout (new GridLayout (message.length, 1));
+        JTextArea ta = new JTextArea (msg, nRows, nCols);
+        ta.setEditable (false);
+        ta.setFocusable (false);
+        ta.setOpaque (false);
+        // replace ugly monospaced font
+        ta.setFont (p.getFont ());
+        p.add (ta);
       }
-      else if ( FLAG_INPUT == ( FLAG_INPUT & flag ) )
+    else if (FLAG_INPUT == (FLAG_INPUT & flag))
       {
-         // a multi label/textfield entry dialog for inputdlg
-         GridBagConstraints gbc = new GridBagConstraints ();
-         gbc.insets.top = 4;
-         gbc.insets.left = 8;
-         gbc.gridx = 0;
-         gbc.anchor = GridBagConstraints.NORTHWEST;
+        // a multi label/textfield entry dialog for inputdlg
+        GridBagConstraints gbc = new GridBagConstraints ();
+        gbc.insets.top = 4;
+        gbc.insets.left = 8;
+        gbc.gridx = 0;
+        gbc.anchor = GridBagConstraints.NORTHWEST;
 
-         p.setLayout ( new GridBagLayout () );
-         m_TextField = new JTextArea[message.length];
+        p.setLayout (new GridBagLayout ());
+        m_TextField = new JTextArea[message.length];
 
-         // default values
-         int nRows = 1;
-         int nCols = 10;
+        // default values
+        int nRows = 1;
+        int nCols = 10;
 
-         for ( int i = 0; i < message.length; i++ )
-         {
-            String msg = theTranslator.replace ( message[i] );
-            JLabel l = new JLabel ( msg );
-            l.setHorizontalAlignment ( Label.LEFT );
+        for (int i = 0; i < message.length; i++)
+          {
+            String msg = theTranslator.replace (message[i]);
+            JLabel l = new JLabel (msg);
+            l.setHorizontalAlignment (Label.LEFT);
             gbc.gridy = 2 * i;
-            p.add ( l, gbc );
+            p.add (l, gbc);
             /**
              * @todo CHECK handling of RowsCols for inputdlg
              */
-            if ( RowsCols != null )
-            {
-               if ( RowsCols.length == 2 * message.length )
-               {
-                  nRows = Integer.parseInt ( RowsCols[i].toString () );
-                  nCols = Integer.parseInt ( RowsCols[RowsCols.length / 2 +
-                                             i].toString () );
-               }
-            }
+            if (RowsCols != null)
+              {
+                if (RowsCols.length == 2 * message.length)
+                  {
+                    nRows = Integer.parseInt (RowsCols[i].toString ());
+                    nCols = Integer.parseInt (RowsCols[RowsCols.length / 2 +
+                                                       i].toString ());
+                  }
+              }
 
-            m_TextField[i] = new JTextArea ( "", Math.max ( nRows, 1 ), nCols );
+            m_TextField[i] = new JTextArea ("", Math.max (nRows, 1), nCols);
             // avoid resizing
-            m_TextField[i].setPreferredSize ( new Dimension ( Math.max ( nRows,
-               1 ), nCols ) );
-            m_TextField[i].setAutoscrolls ( false );
-            m_TextField[i].setFont ( p.getFont () );
-            m_TextField[i].setBorder ( new javax.swing.border.EtchedBorder () );
-            m_TextField[i].addKeyListener ( theListener );
+            m_TextField[i].setPreferredSize (new Dimension (Math.max (nRows,
+                                                                      1), nCols));
+            m_TextField[i].setAutoscrolls (false);
+            m_TextField[i].setFont (p.getFont ());
+            m_TextField[i].setBorder (new javax.swing.border.EtchedBorder ());
+            m_TextField[i].addKeyListener (theListener);
 
             gbc.gridy = 2 * i + 1;
-            p.add ( m_TextField[i], gbc );
-         }
+            p.add (m_TextField[i], gbc);
+          }
 
-         if ( defaults != null )
-         {
-            if ( defaults.length == message.length )
-            {
-               for ( int i = 0; i < message.length; i++ )
-               {
-                  String def = theTranslator.replace ( defaults[i].toString () );
-                  m_TextField[i].setText ( def );
-               }
-            }
-         }
+        if (defaults != null)
+          {
+            if (defaults.length == message.length)
+              {
+                for (int i = 0; i < message.length; i++)
+                  {
+                    String def = theTranslator.replace (defaults[i].toString ());
+                    m_TextField[i].setText (def);
+                  }
+              }
+          }
       }
-      else if ( DLG_LIST == ( DLG_LIST & flag ) )
+    else if (DLG_LIST == (DLG_LIST & flag))
       {
-         GridBagConstraints gbc = new GridBagConstraints ();
-         gbc.insets.top = 4;
-         gbc.insets.left = 8;
-         gbc.gridx = 0;
-         gbc.anchor = GridBagConstraints.NORTHWEST;
+        GridBagConstraints gbc = new GridBagConstraints ();
+        gbc.insets.top = 4;
+        gbc.insets.left = 8;
+        gbc.gridx = 0;
+        gbc.anchor = GridBagConstraints.NORTHWEST;
 
-         p.setLayout ( new GridBagLayout () );
+        p.setLayout (new GridBagLayout ());
 
-         for ( int i = 0; i < message.length; i++ )
-         {
+        for (int i = 0; i < message.length; i++)
+          {
             // a single line label
-            String msg = theTranslator.replace ( message[i] );
-            JLabel l = new JLabel ( msg );
+            String msg = theTranslator.replace (message[i]);
+            JLabel l = new JLabel (msg);
             gbc.gridy = i;
-            p.add ( l, gbc );
-         }
+            p.add (l, gbc);
+          }
 
-         String lst[] = new String[list.length];
+        String lst[] = new String[list.length];
 
-         for ( int i = 0; i < list.length; i++ )
-         {
-            lst[i] = theTranslator.replace ( list[i] );
-         }
-         m_List = new JList ( lst );
+        for (int i = 0; i < list.length; i++)
+          {
+            lst[i] = theTranslator.replace (list[i]);
+          }
+        m_List = new JList (lst);
 
-         // replace ugly monospaced font
-         m_List.setFont ( p.getFont () );
+        // replace ugly monospaced font
+        m_List.setFont (p.getFont ());
 
-         m_List.setMinimumSize ( new Dimension ( Math.max ( 1,
-            Integer.parseInt ( RowsCols[0].toString () ) ),
-                                                 Math.max ( 1,
-            Integer.parseInt ( RowsCols[1].toString () ) ) ) );
-         m_List.setPreferredSize ( new Dimension ( Math.max ( 1,
-            Integer.parseInt ( RowsCols[1].toString () ) ),
-            Math.max ( 1,
-                       Integer.parseInt ( RowsCols[0].toString () ) ) ) );
-         m_List.setBorder ( new javax.swing.border.EtchedBorder () );
+        m_List.setMinimumSize (new Dimension (Math.max (1,
+                                                        Integer.parseInt (RowsCols[0].toString ())),
+                                              Math.max (1,
+                                                        Integer.parseInt (RowsCols[1].toString ()))));
+        m_List.setPreferredSize (new Dimension (Math.max (1,
+                                                          Integer.parseInt (RowsCols[1].toString ())),
+                                                Math.max (1,
+                                                          Integer.parseInt (RowsCols[0].toString ()))));
+        m_List.setBorder (new javax.swing.border.EtchedBorder ());
 
-         gbc.gridy = message.length;
-         gbc.fill = GridBagConstraints.HORIZONTAL;
-         p.add ( m_List, gbc );
+        gbc.gridy = message.length;
+        gbc.fill = GridBagConstraints.HORIZONTAL;
+        p.add (m_List, gbc);
 
-         if ( on.toLowerCase ().equals ( "single" ) )
-         {
+        if (on.toLowerCase ().equals ("single"))
+          {
             // single selection list
-            m_List.setSelectionMode ( ListSelectionModel.SINGLE_SELECTION );
+            m_List.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
 
-            m_List.setSelectedIndex ( Integer.parseInt (
-               defaults[0].toString () ) - 1 );
-         }
-         else
-         {
+            m_List.setSelectedIndex (Integer.parseInt (
+                                                       defaults[0].toString ()) - 1);
+          }
+        else
+          {
             // multiple selection possible
-            m_List.setSelectionMode ( ListSelectionModel.
-                                      MULTIPLE_INTERVAL_SELECTION );
+            m_List.setSelectionMode (ListSelectionModel.
+                                     MULTIPLE_INTERVAL_SELECTION);
 
             int selection[] = new int[defaults.length];
-            for ( int i = 0; i < defaults.length; i++ )
-            {
-               selection[i] = Integer.parseInt ( defaults[i].toString () ) - 1;
-            }
-            m_List.setSelectedIndices ( selection );
+            for (int i = 0; i < defaults.length; i++)
+              {
+                selection[i] = Integer.parseInt (defaults[i].toString ()) - 1;
+              }
+            m_List.setSelectedIndices (selection);
 
-            JButton b = new JButton ( "Select All" );
-            b.setActionCommand ( "SELALL" );
-            b.addActionListener ( theListener );
+            JButton b = new JButton ("Select All");
+            b.setActionCommand ("SELALL");
+            b.addActionListener (theListener);
             gbc.gridy = message.length + 1;
             gbc.fill = GridBagConstraints.HORIZONTAL;
-            p.add ( b, gbc );
-         }
+            p.add (b, gbc);
+          }
 
       }
 
-      // prepare icon, if any
-      String sIconFile = null;
-      String sIconResource = null;
-      Icon theIcon = null;
+    // prepare icon, if any
+    String sIconFile = null;
+    String sIconResource = null;
+    Icon theIcon = null;
 
-      if ( FLAG_ERROR == ( FLAG_ERROR & flag ) )
+    if (FLAG_ERROR == (FLAG_ERROR & flag))
       {
-         sIconFile = "images/error.png";
-         // Java for Windows
-         sIconResource = "OptionPane.errorIcon";
-         // Java for Linux does not offer these standard icons...
+        sIconFile = "images/error.png";
+        // Java for Windows
+        sIconResource = "OptionPane.errorIcon";
+        // Java for Linux does not offer these standard icons...
       }
-      else if ( FLAG_WARNING == ( FLAG_WARNING & flag ) )
+    else if (FLAG_WARNING == (FLAG_WARNING & flag))
       {
-         sIconFile = "images/warning.png";
-         // Java for Windows
-         sIconResource = "OptionPane.warningIcon";
-         // Java for Linux does not offer these standard icons...
+        sIconFile = "images/warning.png";
+        // Java for Windows
+        sIconResource = "OptionPane.warningIcon";
+        // Java for Linux does not offer these standard icons...
       }
-      else if ( FLAG_QUESTION == ( FLAG_QUESTION & flag ) )
+    else if (FLAG_QUESTION == (FLAG_QUESTION & flag))
       {
-         sIconFile = "images/question.png";
-         // Java for Windows
-         sIconResource = "OptionPane.questionIcon";
-         // Java for Linux does not offer these standard icons...
+        sIconFile = "images/question.png";
+        // Java for Windows
+        sIconResource = "OptionPane.questionIcon";
+        // Java for Linux does not offer these standard icons...
       }
-      else if ( FLAG_INFORMATION == ( FLAG_INFORMATION & flag ) )
+    else if (FLAG_INFORMATION == (FLAG_INFORMATION & flag))
       {
-         sIconFile = "images/information.png";
-         // Java for Windows
-         sIconResource = "OptionPane.informationIcon";
-         // Java for Linux does not offer these standard icons...
+        sIconFile = "images/information.png";
+        // Java for Windows
+        sIconResource = "OptionPane.informationIcon";
+        // Java for Linux does not offer these standard icons...
       }
 
-      // first try to find the UIManager specific icon to fit look and feel
-      // Note: the Windows XP look and feel offers 50 icons.
-      if ( sIconResource != null )
+    // first try to find the UIManager specific icon to fit look and feel
+    // Note: the Windows XP look and feel offers 50 icons.
+    if (sIconResource != null)
       {
-         UIDefaults df = UIManager.getLookAndFeelDefaults ();
-         theIcon = df.getIcon ( sIconResource );
+        UIDefaults df = UIManager.getLookAndFeelDefaults ();
+        theIcon = df.getIcon (sIconResource);
       }
 
-      // fallback on bitmap image resource if icon was not found
-      if ( theIcon == null &&
-           sIconFile != null )
+    // fallback on bitmap image resource if icon was not found
+    if (theIcon == null &&
+        sIconFile != null)
       {
-         URL theResource = JDialogBox.class.getResource ( sIconFile );
-         if ( theResource != null )
-         {
-            theIcon = new ImageIcon ( theResource );
-         }
+        URL theResource = JDialogBox.class.getResource (sIconFile);
+        if (theResource != null)
+          {
+            theIcon = new ImageIcon (theResource);
+          }
       }
 
-      if ( theIcon != null )
+    if (theIcon != null)
       {
-         // dummy panel to provide space around icon
-         JPanel pi = new JPanel ( new GridLayout ( 1, 3 ) );
-         pi.add ( new JLabel () );
-         pi.add ( new JLabel ( theIcon ) );
-         pi.add ( new JLabel () );
-         d.add ( pi, BorderLayout.WEST );
+        // dummy panel to provide space around icon
+        JPanel pi = new JPanel (new GridLayout (1, 3));
+        pi.add (new JLabel ());
+        pi.add (new JLabel (theIcon));
+        pi.add (new JLabel ());
+        d.add (pi, BorderLayout.WEST);
 
-         // use Octave icon if available. otherwise use dialog icon
-         Icon theOctaveIcon = getOctaveIcon ();
-         prepareFrameIcon ( m_ParentFrame,
-                            theOctaveIcon == null ? theIcon : theOctaveIcon );
+        // use Octave icon if available. otherwise use dialog icon
+        Icon theOctaveIcon = getOctaveIcon ();
+        prepareFrameIcon (m_ParentFrame,
+                          theOctaveIcon == null ? theIcon : theOctaveIcon);
       }
 
-      d.add ( p, BorderLayout.CENTER );
+    d.add (p, BorderLayout.CENTER);
 
-      // button bar (2 rows of 3 columns each
+    // button bar (2 rows of 3 columns each
 
-      p = new JPanel ();
-      p.setLayout ( new java.awt.GridLayout ( 2, 3 ) );
+    p = new JPanel ();
+    p.setLayout (new java.awt.GridLayout (2, 3));
 
-      // spacer row
-      p.add ( new JLabel () );
-      p.add ( new JLabel () );
-      p.add ( new JLabel () );
+    // spacer row
+    p.add (new JLabel ());
+    p.add (new JLabel ());
+    p.add (new JLabel ());
 
-      if ( DLG_QUEST == ( DLG_QUEST & flag ) )
+    if (DLG_QUEST == (DLG_QUEST & flag))
       {
-         // questdlg with empty option[2]: only two buttons
-         if ( nostring.length () < 1 )
-         {
+        // questdlg with empty option[2]: only two buttons
+        if (nostring.length () < 1)
+          {
             // spacer: left
-            p.add ( new JLabel () );
-         }
+            p.add (new JLabel ());
+          }
       }
-      else
+    else
       {
-         // spacer: left
-         p.add ( new JLabel () );
+        // spacer: left
+        p.add (new JLabel ());
       }
 
-      m_ButtonOK = new JButton ( theTranslator.replace ( okstring ) );
-      m_ButtonOK.setActionCommand ( "OK" );
-      m_ButtonOK.addActionListener ( theListener );
-      m_Focus = m_ButtonOK;
-      p.add ( m_ButtonOK );
+    m_ButtonOK = new JButton (theTranslator.replace (okstring));
+    m_ButtonOK.setActionCommand ("OK");
+    m_ButtonOK.addActionListener (theListener);
+    m_Focus = m_ButtonOK;
+    p.add (m_ButtonOK);
 
-      if ( DLG_QUEST == ( DLG_QUEST & flag ) )
+    if (DLG_QUEST == (DLG_QUEST & flag))
       {
-         // questdlg with empty option[2]: only two buttons
-         if ( nostring.length () > 01 )
-         {
+        // questdlg with empty option[2]: only two buttons
+        if (nostring.length () > 01)
+          {
             // questdlg has three buttons
-            m_ButtonNO = new JButton ( theTranslator.replace ( nostring ) );
-            m_ButtonNO.setActionCommand ( "NO" );
-            m_ButtonNO.addActionListener ( theListener );
-            p.add ( m_ButtonNO );
-            if ( DLG_QUEST == ( DLG_QUEST & flag ) )
-            {
-               // select default button
-               if ( list[3].equals ( nostring ) )
-               {
-                  m_Focus = m_ButtonNO;
-               }
-            }
-         }
+            m_ButtonNO = new JButton (theTranslator.replace (nostring));
+            m_ButtonNO.setActionCommand ("NO");
+            m_ButtonNO.addActionListener (theListener);
+            p.add (m_ButtonNO);
+            if (DLG_QUEST == (DLG_QUEST & flag))
+              {
+                // select default button
+                if (list[3].equals (nostring))
+                  {
+                    m_Focus = m_ButtonNO;
+                  }
+              }
+          }
       }
 
-      if ( DLG_INPUT == ( DLG_INPUT & flag ) ||
-           DLG_LIST == ( DLG_LIST & flag ) ||
-           DLG_QUEST == ( DLG_QUEST & flag ) )
+    if (DLG_INPUT == (DLG_INPUT & flag) ||
+        DLG_LIST == (DLG_LIST & flag) ||
+        DLG_QUEST == (DLG_QUEST & flag))
       {
-         m_ButtonCANCEL = new JButton ( theTranslator.replace ( cancelstring ) );
-         m_ButtonCANCEL.setActionCommand ( "CANCEL" );
-         m_ButtonCANCEL.addActionListener ( theListener );
-         p.add ( m_ButtonCANCEL );
-         if ( DLG_QUEST == ( DLG_QUEST & flag ) )
-         {
+        m_ButtonCANCEL = new JButton (theTranslator.replace (cancelstring));
+        m_ButtonCANCEL.setActionCommand ("CANCEL");
+        m_ButtonCANCEL.addActionListener (theListener);
+        p.add (m_ButtonCANCEL);
+        if (DLG_QUEST == (DLG_QUEST & flag))
+          {
             // select default button
-            if ( list[3].equals ( cancelstring ) )
-            {
-               m_Focus = m_ButtonCANCEL;
-            }
-         }
+            if (list[3].equals (cancelstring))
+              {
+                m_Focus = m_ButtonCANCEL;
+              }
+          }
       }
-      else
+    else
       {
-         // spacer: right
-         p.add ( new JLabel () );
+        // spacer: right
+        p.add (new JLabel ());
       }
 
-      d.add ( p, BorderLayout.SOUTH );
-      dlg.pack ();
+    d.add (p, BorderLayout.SOUTH);
+    dlg.pack ();
 
-      dlg.addWindowListener ( theListener );
+    dlg.addWindowListener (theListener);
 
-      if ( on.equals ( "on" ) )
+    if (on.equals ("on"))
       {
-         m_ParentFrame.setAlwaysOnTop ( true );
+        m_ParentFrame.setAlwaysOnTop (true);
       }
 
-      // center dialog on screen
-      Dimension dlgSize = dlg.getSize ();
-      Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
+    // center dialog on screen
+    Dimension dlgSize = dlg.getSize ();
+    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
 
-      dlg.setLocation ( ( screenSize.width - dlgSize.width ) / 2,
-                        ( screenSize.height - dlgSize.height ) / 2 );
+    dlg.setLocation ((screenSize.width - dlgSize.width) / 2,
+                     (screenSize.height - dlgSize.height) / 2);
 
-      dlg.setVisible ( true );
-      dlg.requestFocus ();
+    dlg.setVisible (true);
+    dlg.requestFocus ();
 
-      m_ParentFrame.setVisible ( false );
+    m_ParentFrame.setVisible (false);
 
-      return ( 1 );
-   }
+    return (1);
+  }
 
 
-   /**
-    *
-    * @return Icon - null if icon was not found
-    */
-   private Icon getOctaveIcon ()
-   {
-      Icon theIcon = null;
-      URL theResource = JDialogBox.class.getResource ( "images/octave.png" );
-      if ( theResource != null )
+  /**
+   *
+   * @return Icon - null if icon was not found
+   */
+  private Icon getOctaveIcon ()
+  {
+    Icon theIcon = null;
+    URL theResource = JDialogBox.class.getResource ("images/octave.png");
+    if (theResource != null)
       {
-         theIcon = new ImageIcon ( theResource );
+        theIcon = new ImageIcon (theResource);
       }
-      return theIcon;
-   }
+    return theIcon;
+  }
 
 
-   /**
-    * Replace the standard Java frame icon with an Octave Icon.
-    *
-    * @param theFrame Frame - the Frame to decorate
-    * @param theIcon Icon - the icon to use if octave icon is not found.
-    */
-   private void prepareFrameIcon ( Frame theFrame, Icon theIcon )
-   {
-      // prepare icon for upper left corner of Frame window
-      // maybe there is a simpler way to achieve this
-      int w = theIcon.getIconWidth ();
-      int h = theIcon.getIconHeight ();
-      // Frame must be made displayable by packing it for createImage() to succeed
-      theFrame.pack ();
-      Image theImage = theFrame.createImage ( w, h );
-      theIcon.paintIcon ( theFrame, theImage.getGraphics (), 0, 0 );
-      theFrame.setIconImage ( theImage );
-   }
+  /**
+   * Replace the standard Java frame icon with an Octave Icon.
+   *
+   * @param theFrame Frame - the Frame to decorate
+   * @param theIcon Icon - the icon to use if octave icon is not found.
+   */
+  private void prepareFrameIcon (Frame theFrame, Icon theIcon)
+  {
+    // prepare icon for upper left corner of Frame window
+    // maybe there is a simpler way to achieve this
+    int w = theIcon.getIconWidth ();
+    int h = theIcon.getIconHeight ();
+    // Frame must be made displayable by packing it for createImage() to succeed
+    theFrame.pack ();
+    Image theImage = theFrame.createImage (w, h);
+    theIcon.paintIcon (theFrame, theImage.getGraphics (), 0, 0);
+    theFrame.setIconImage (theImage);
+  }
 
 
-   /**
-    * Select Look and Feel
-    *
-    * @param bSystemLnF boolean - if true, the current systesm Look&Feel is used,
-    * otherwise the Swing/Metal cross platform Look&Feel is used.
-    */
-   private void setSystemLnF ( boolean bSystemLnF )
-   {
-      try
+  /**
+   * Select Look and Feel
+   *
+   * @param bSystemLnF boolean - if true, the current systesm Look&Feel is used,
+   * otherwise the Swing/Metal cross platform Look&Feel is used.
+   */
+  private void setSystemLnF (boolean bSystemLnF)
+  {
+    try
       {
-         if ( bSystemLnF )
-         {
+        if (bSystemLnF)
+          {
             // switch from Swing LnF to local system LnF
-            UIManager.setLookAndFeel ( UIManager.
-                                       getSystemLookAndFeelClassName () );
-         }
-         else
-         {
+            UIManager.setLookAndFeel (UIManager.
+                                      getSystemLookAndFeelClassName ());
+          }
+        else
+          {
             // use Swing LnF
-            UIManager.setLookAndFeel ( UIManager.
-                                       getCrossPlatformLookAndFeelClassName () );
-         }
+            UIManager.setLookAndFeel (UIManager.
+                                      getCrossPlatformLookAndFeelClassName ());
+          }
       }
-      catch ( Exception exception )
+    catch (Exception exception)
       {
-         exception.printStackTrace ();
+        exception.printStackTrace ();
       }
-   }
+  }
 
 
-   /**
-    * Called when the dialog is closed. Allows for specific cleanup actions.
-    *
-    * @param closeMethod int - OctaveDialog.CLOSE_OK, OctaveDialog.CLOSE_CANCEL
-    */
-   public void closeDialog ( int closeMethod )
-   {
-      m_CloseMethod = closeMethod;
-      m_ParentFrame.dispose ();
-   }
+  /**
+   * Called when the dialog is closed. Allows for specific cleanup actions.
+   *
+   * @param closeMethod int - OctaveDialog.CLOSE_OK, OctaveDialog.CLOSE_CANCEL
+   */
+  public void closeDialog (int closeMethod)
+  {
+    m_CloseMethod = closeMethod;
+    m_ParentFrame.dispose ();
+  }
 
 
-   public void setFocus ()
-   {
-      if ( null != m_Focus )
+  public void setFocus ()
+  {
+    if (null != m_Focus)
       {
-         m_Focus.requestFocus ();
-         m_ParentFrame.getRootPane ().setDefaultButton ( m_Focus );
-         m_ParentFrame.setAlwaysOnTop ( true );
+        m_Focus.requestFocus ();
+        m_ParentFrame.getRootPane ().setDefaultButton (m_Focus);
+        m_ParentFrame.setAlwaysOnTop (true);
       }
-   }
+  }
 
 
-   /**
-    * Tests the dialogs
-    *
-    * @param args String[] - not used.
-    */
-   public static void main ( String[] args )
-   {
-      TeXtranslator t = new TeXtranslator();
+  /**
+   * Tests the dialogs
+   *
+   * @param args String[] - not used.
+   */
+  public static void main (String[] args)
+  {
+    TeXtranslator t = new TeXtranslator();
 
-      if(false)
+    if (false)
       {
-         // find out key names of icon UI resources
-         UIDefaults df = UIManager.getLookAndFeelDefaults ();
+        // find out key names of icon UI resources
+        UIDefaults df = UIManager.getLookAndFeelDefaults ();
 
-         for ( Enumeration e = df.keys (); e.hasMoreElements (); )
-         {
+        for (Enumeration e = df.keys (); e.hasMoreElements ();)
+          {
             String s = e.nextElement ().toString ();
 
-            if ( s.toLowerCase ().contains ( "icon" ) )
-            {
-               System.out.println ( s );
-            }
-         }
+            if (s.toLowerCase ().contains ("icon"))
+              {
+                System.out.println (s);
+              }
+          }
       }
 
-      try
+    try
       {
-         Class[] argTypes = new Class[1];
-         argTypes[0] = String.class;
+        Class[] argTypes = new Class[1];
+        argTypes[0] = String.class;
 
-         java.lang.reflect.Constructor c = ClassHelper.findConstructor ( java.lang.StringBuffer.class,
-                                                       argTypes );
-         Object argValues[] = new Object[1];
-         argValues[0] = new String("initial value");
-         Object sb = c.newInstance(argValues);
-         System.out.println(sb.toString());
+        java.lang.reflect.Constructor c = ClassHelper.findConstructor (java.lang.StringBuffer.class,
+                                                                       argTypes);
+        Object argValues[] = new Object[1];
+        argValues[0] = new String("initial value");
+        Object sb = c.newInstance(argValues);
+        System.out.println(sb.toString());
 
-         ClassHelper.invokeMethod(sb,"append",argValues,argTypes);
-         System.out.println(sb.toString());
+        ClassHelper.invokeMethod(sb,"append",argValues,argTypes);
+        System.out.println(sb.toString());
 
-         argValues = new Object[2];
-         argTypes = new Class[2];
-         argTypes[0] =  Integer.class;
-         argTypes[1] = String.class;
-         argValues[0] = new Integer(0);
-         argValues[1] = new String("inserted");
+        argValues = new Object[2];
+        argTypes = new Class[2];
+        argTypes[0] =  Integer.class;
+        argTypes[1] = String.class;
+        argValues[0] = new Integer(0);
+        argValues[1] = new String("inserted");
 
-         ClassHelper.invokeMethod(sb,"insert",argValues,argTypes);
-         System.out.println(sb.toString());
+        ClassHelper.invokeMethod(sb,"insert",argValues,argTypes);
+        System.out.println(sb.toString());
       }
-      catch ( Throwable e )
+    catch (Throwable e)
       {}
 
-      if ( true )
+    if (true)
       {
-         return;
+        return;
       }
 
-      helpdlg ( "If you need help\nyou should ask for help\nif someone is around\notherwise you are on your own.",
-                "Information" );
+    helpdlg ("If you need help\nyou should ask for help\nif someone is around\notherwise you are on your own.",
+             "Information");
 
-      String[] options = new String[4];
-      options[0] = "Yeah \\vartheta is too low";
-      options[1] = "Maybe";
-      options[2] = "Nay \\vartheta is too high";
-      options[3] = "Maybe";
+    String[] options = new String[4];
+    options[0] = "Yeah \\vartheta is too low";
+    options[1] = "Maybe";
+    options[2] = "Nay \\vartheta is too high";
+    options[3] = "Maybe";
 
-      System.out.println ( questdlg ( "Is it too cold?", "Temperature", options ) );
+    System.out.println (questdlg ("Is it too cold?", "Temperature", options));
 
-      // test variants of errordlg
-      // does not affect layering of dialog
-      errordlg ( "Background error!", "Error" );
+    // test variants of errordlg
+    // does not affect layering of dialog
+    errordlg ("Background error!", "Error");
 
-      // test variants of helpdlg
+    // test variants of helpdlg
 
-      // test variants of inputdlg
-      String prompt[] = new String[2];
-      prompt[0] = "Question 1";
-      prompt[1] = "Question 2";
-      String defaults[] = new String[2];
-      defaults[0] = "1.1";
-      defaults[1] = "2.2";
-      String title = "Enter values";
+    // test variants of inputdlg
+    String prompt[] = new String[2];
+    prompt[0] = "Question 1";
+    prompt[1] = "Question 2";
+    String defaults[] = new String[2];
+    defaults[0] = "1.1";
+    defaults[1] = "2.2";
+    String title = "Enter values";
 
-      Integer rc[] = new Integer[2 * 2];
-      rc[0] = new Integer ( 1 );
-      rc[1] = new Integer ( 2 );
-      rc[2] = new Integer ( 10 );
-      rc[3] = new Integer ( 20 );
+    Integer rc[] = new Integer[2 * 2];
+    rc[0] = new Integer (1);
+    rc[1] = new Integer (2);
+    rc[2] = new Integer (10);
+    rc[3] = new Integer (20);
 
-      inputdlg ( prompt, title, rc, defaults );
+    inputdlg (prompt, title, rc, defaults);
 
-      String listcell[] = new String[4];
-      listcell[0] = "a \\alpha";
-      listcell[1] = "b \\beta";
-      listcell[2] = "c \\gamma";
-      listcell[3] = "d \\delta";
+    String listcell[] = new String[4];
+    listcell[0] = "a \\alpha";
+    listcell[1] = "b \\beta";
+    listcell[2] = "c \\gamma";
+    listcell[3] = "d \\delta";
 
-      Integer size[] = new Integer[2];
-      size[0] = new Integer ( 80 );
-      size[1] = new Integer ( 100 );
+    Integer size[] = new Integer[2];
+    size[0] = new Integer (80);
+    size[1] = new Integer (100);
 
-      Integer initial[] = new Integer[2];
-      initial[0] = new Integer ( 4 );
-      initial[1] = new Integer ( 2 );
+    Integer initial[] = new Integer[2];
+    initial[0] = new Integer (4);
+    initial[1] = new Integer (2);
 
-      String promptcell[] = new String[2];
-      promptcell[0] = "Select something";
-      promptcell[1] = "(or even more than one thing)";
+    String promptcell[] = new String[2];
+    promptcell[0] = "Select something";
+    promptcell[1] = "(or even more than one thing)";
 
-      int idx[] = listdlg ( listcell,
-                            "Multiple",
-                            size,
-                            initial,
-                            "name",
-                            promptcell,
-                            "okstring",
-                            "cancelstring" );
+    int idx[] = listdlg (listcell,
+                         "Multiple",
+                         size,
+                         initial,
+                         "name",
+                         promptcell,
+                         "okstring",
+                         "cancelstring");
 
-      if ( idx != null )
+    if (idx != null)
       {
-         for ( int i = 0; i < idx.length; i++ )
-         {
-            System.out.println ( idx[i] );
-         }
+        for (int i = 0; i < idx.length; i++)
+          {
+            System.out.println (idx[i]);
+          }
       }
-   }
+  }
 }
diff --git a/scripts/java/org/octave/Matrix.java b/scripts/java/org/octave/Matrix.java
--- a/scripts/java/org/octave/Matrix.java
+++ b/scripts/java/org/octave/Matrix.java
@@ -1,355 +1,361 @@
-/* Copyright (C) 2007 Michael Goffioul
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; If not, see <http://www.gnu.org/licenses/>.
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
 */
 
 package org.octave;
 
 import java.nio.*;
 import java.text.DecimalFormat;
 
 public class Matrix
 {
-	private int[] dims;
-	private Buffer data;
-	private Object cache = null;
+  private int[] dims;
+  private Buffer data;
+  private Object cache = null;
 
-	public Matrix()
-	{
-		this(new double[0], new int[] {0, 0});
-	}
+  public Matrix ()
+  {
+    this (new double[0], new int[] {0, 0});
+  }
 
-	public Matrix(double[] data)
-	{
-		this(data, new int[] {1, data.length});
-	}
+  public Matrix (double[] data)
+  {
+    this (data, new int[] {1, data.length});
+  }
 
-	public Matrix(double[][] data)
-	{
-		int m = data.length;
-		int n = (m > 0 ? data[0].length : 0);
-		int idx = 0;
-		double[] buf = new double[m*n];
+  public Matrix (double[][] data)
+  {
+    int m = data.length;
+    int n = (m > 0 ? data[0].length : 0);
+    int idx = 0;
+    double[] buf = new double[m*n];
 		
-		for (int j=0; j<n; j++)
-			for (int i=0; i<m; i++)
-				buf[idx++] = data[i][j];
-		this.data = DoubleBuffer.wrap(buf);
-		this.dims = new int[] {m, n};
-		this.cache = data;
-	}
+    for (int j = 0; j < n; j++)
+      for (int i = 0; i < m; i++)
+        buf[idx++] = data[i][j];
+    this.data = DoubleBuffer.wrap(buf);
+    this.dims = new int[] {m, n};
+    this.cache = data;
+  }
 
-	public Matrix(double[][][] data)
-	{
-		int m = data.length;
-		int n = (m > 0 ? data[0].length : 0);
-		int p = (n > 0 ? data[0][0].length : 0);
-		int idx = 0;
-		double[] buf = new double[m*n*p];
+  public Matrix (double[][][] data)
+  {
+    int m = data.length;
+    int n = (m > 0 ? data[0].length : 0);
+    int p = (n > 0 ? data[0][0].length : 0);
+    int idx = 0;
+    double[] buf = new double[m*n*p];
 
-		for (int k=0; k<p; k++)
-			for (int j=0; j<n; j++)
-				for (int i=0; i<m; i++)
-					buf[idx++] = data[i][j][k];
-		this.data = DoubleBuffer.wrap(buf);
-		this.dims = new int[] {m, n, p};
-		this.cache = data;
-	}
+    for (int k = 0; k < p; k++)
+      for (int j = 0; j < n; j++)
+        for (int i = 0; i < m; i++)
+          buf[idx++] = data[i][j][k];
+    this.data = DoubleBuffer.wrap(buf);
+    this.dims = new int[] {m, n, p};
+    this.cache = data;
+  }
 
-	public Matrix(double[] data, int[] dims)
-	{
-		this.dims = dims;
-		this.data = DoubleBuffer.wrap(data);
-	}
+  public Matrix (double[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = DoubleBuffer.wrap(data);
+  }
 
-	public Matrix(byte[] data, int[] dims)
-	{
-		this.dims = dims;
-		this.data = ByteBuffer.wrap(data);
-	}
+  public Matrix (byte[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = ByteBuffer.wrap(data);
+  }
 
-	public Matrix(int[] data, int[] dims)
-	{
-		this.dims = dims;
-		this.data = IntBuffer.wrap(data);
-	}
+  public Matrix (int[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = IntBuffer.wrap(data);
+  }
 
-	public double[] toDouble()
-	{
-		if (data instanceof DoubleBuffer)
-			return ((DoubleBuffer)data).array();
-		else
-			throw new ClassCastException("matrix is not of type `double'");
-	}
+  public double[] toDouble ()
+  {
+    if (data instanceof DoubleBuffer)
+      return ((DoubleBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `double'");
+  }
 
-	public byte[] toByte()
-	{
-		if (data instanceof ByteBuffer)
-			return ((ByteBuffer)data).array();
-		else
-			throw new ClassCastException("matrix is not of type `byte'");
-	}
+  public byte[] toByte ()
+  {
+    if (data instanceof ByteBuffer)
+      return ((ByteBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `byte'");
+  }
 
-	public int[] toInt()
-	{
-		if (data instanceof IntBuffer)
-			return ((IntBuffer)data).array();
-		else
-			throw new ClassCastException("matrix is not of type `integer'");
-	}
+  public int[] toInt ()
+  {
+    if (data instanceof IntBuffer)
+      return ((IntBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `integer'");
+  }
 
-	public int getNDims()
-	{
-		return (dims == null ? 0 : dims.length);
-	}
+  public int getNDims ()
+  {
+    return (dims == null ? 0 : dims.length);
+  }
 
-	public int getDim(int index)
-	{
-		return (dims == null || index < 0 || index >= dims.length ? -1 : dims[index]);
-	}
+  public int getDim (int index)
+  {
+    return (dims == null || index < 0 || index >= dims.length ? -1 : dims[index]);
+  }
 
-	public int[] getDims()
-	{
-		return dims;
-	}
+  public int[] getDims ()
+  {
+    return dims;
+  }
 
-	public String getClassName()
-	{
-		if (data instanceof DoubleBuffer)
-			return "double";
-		else if (data instanceof IntBuffer)
-			return "integer";
-		else if (data instanceof ByteBuffer)
-			return "byte";
-		else
-			return "unknown";
-	}
+  public String getClassName ()
+  {
+    if (data instanceof DoubleBuffer)
+      return "double";
+    else if (data instanceof IntBuffer)
+      return "integer";
+    else if (data instanceof ByteBuffer)
+      return "byte";
+    else
+      return "unknown";
+  }
 
-	public String toString()
-	{
-		if (dims == null || data == null)
-			return "null";
+  public String toString ()
+  {
+    if (dims == null || data == null)
+      return "null";
 
-		String s = "";
+    String s = "";
 
-		if (dims.length == 2 && dims[0] == 1 && dims[1] <= 5)
-		{
-			if (data instanceof DoubleBuffer)
-			{
-				DoubleBuffer b = (DoubleBuffer)data;
-				DecimalFormat fmt = new DecimalFormat("0.0000 ");
-				for (int i=0; i<b.capacity(); i++)
-					s += fmt.format(b.get(i));
-			}
-			else if (data instanceof IntBuffer)
-			{
-				IntBuffer b = (IntBuffer)data;
-				for (int i=0; i<b.capacity(); i++)
-					s += (Integer.toString(b.get(i)) + " ");
-			}
-			else if (data instanceof ByteBuffer)
-			{
-				ByteBuffer b = (ByteBuffer)data;
-				for (int i=0; i<b.capacity(); i++)
-					s += (Byte.toString(b.get(i)) + " ");
-			}
-			s = ("[ " + s + "]");
-		}
-		else if (dims.length == 2 && dims[0] == 0 && dims[1] == 0)
-			s = "[ ]";
-		else
-		{
-			for (int i=0; i<dims.length; i++)
-				if (i == 0)
-					s = Integer.toString(dims[i]);
-				else
-					s += (" by " + Integer.toString(dims[i]));
-			s = ("[ (" + s + ") array of " + getClassName() + " ]");
-		}
+    if (dims.length == 2 && dims[0] == 1 && dims[1] <= 5)
+      {
+        if (data instanceof DoubleBuffer)
+          {
+            DoubleBuffer b = (DoubleBuffer)data;
+            DecimalFormat fmt = new DecimalFormat ("0.0000 ");
+            for (int i = 0; i < b.capacity (); i++)
+              s += fmt.format (b.get (i));
+          }
+        else if (data instanceof IntBuffer)
+          {
+            IntBuffer b = (IntBuffer)data;
+            for (int i = 0; i < b.capacity (); i++)
+              s += (Integer.toString (b.get (i)) + " ");
+          }
+        else if (data instanceof ByteBuffer)
+          {
+            ByteBuffer b = (ByteBuffer)data;
+            for (int i = 0; i < b.capacity (); i++)
+              s += (Byte.toString (b.get (i)) + " ");
+          }
+        s = ("[ " + s + "]");
+      }
+    else if (dims.length == 2 && dims[0] == 0 && dims[1] == 0)
+      s = "[ ]";
+    else
+      {
+        for (int i = 0; i < dims.length; i++)
+          if (i == 0)
+            s = Integer.toString (dims[i]);
+          else
+            s += (" by " + Integer.toString (dims[i]));
+        s = ("[ (" + s + ") array of " + getClassName () + " ]");
+      }
 
-		return s;
-	}
+    return s;
+  }
 
-	public static Object ident(Object o)
-	{
-		System.out.println(o);
-		return o;
-	}
+  public static Object ident (Object o)
+  {
+    System.out.println (o);
+    return o;
+  }
 
-	public boolean equals(Object value)
-	{
-		if (value instanceof Matrix)
-		{
-			Matrix m = (Matrix)value;
-			if (!java.util.Arrays.equals(dims, m.dims))
-				return false;
-			return data.equals(m.data);
-		}
-		else
-			return false;
-	}
+  public boolean equals (Object value)
+  {
+    if (value instanceof Matrix)
+      {
+        Matrix m = (Matrix)value;
+        if (!java.util.Arrays.equals (dims, m.dims))
+          return false;
+        return data.equals (m.data);
+      }
+    else
+      return false;
+  }
 
-	public boolean isEmpty()
-	{
-		return (data == null || dims == null || data.capacity() == 0);
-	}
+  public boolean isEmpty ()
+  {
+    return (data == null || dims == null || data.capacity () == 0);
+  }
 
-	public boolean isVector()
-	{
-		return (dims.length == 1 ||
-			(dims.length == 2 && (dims[0] == 1 || dims[1] == 1 ||
-					      (dims[0] == 0 && dims[1] == 0))));
-	}
+  public boolean isVector ()
+  {
+    return (dims.length == 1 ||
+            (dims.length == 2 && (dims[0] == 1 || dims[1] == 1 ||
+                                  (dims[0] == 0 && dims[1] == 0))));
+  }
 
-	public int getLength()
-	{
-		return data.capacity();
-	}
+  public int getLength ()
+  {
+    return data.capacity ();
+  }
 
-	public double[] asDoubleVector()
-	{
-		if (data instanceof DoubleBuffer)
-			return toDouble();
-		else
-			System.out.println("Warning: invalid conversion to double vector");
-		return null;
-	}
+  public double[] asDoubleVector ()
+  {
+    if (data instanceof DoubleBuffer)
+      return toDouble ();
+    else
+      System.out.println ("Warning: invalid conversion to double vector");
+    return null;
+  }
 
-	public double[][] asDoubleMatrix()
-	{
-		if (cache != null)
-		{
-			try { return (double[][])cache; }
-			catch (ClassCastException e) { }
-		}
+  public double[][] asDoubleMatrix ()
+  {
+    if (cache != null)
+      {
+        try { return (double[][])cache; }
+        catch (ClassCastException e) { }
+      }
 
-		if (data instanceof DoubleBuffer && dims.length == 2)
-		{
-			double[][] m = new double[dims[0]][dims[1]];
-			double[] data = ((DoubleBuffer)this.data).array();
-			int idx = 0;
-			if (data.length > 0)
-				for (int j=0; j<m[0].length; j++)
-					for (int i=0; i<m.length; i++)
-						m[i][j] = data[idx++];
-			cache = m;
-			return m;
-		}
-		else
-			System.out.println("Warning: invalid conversion to double matrix");
+    if (data instanceof DoubleBuffer && dims.length == 2)
+      {
+        double[][] m = new double[dims[0]][dims[1]];
+        double[] data = ((DoubleBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int j = 0; j < m[0].length; j++)
+            for (int i = 0; i < m.length; i++)
+              m[i][j] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to double matrix");
 
-		return null;
-	}
+    return null;
+  }
 	
-	public double[][][] asDoubleMatrix3()
-	{
-		if (cache != null)
-		{
-			try { return (double[][][])cache; }
-			catch (ClassCastException e) { }
-		}
+  public double[][][] asDoubleMatrix3 ()
+  {
+    if (cache != null)
+      {
+        try { return (double[][][])cache; }
+        catch (ClassCastException e) { }
+      }
 
-		if (data instanceof DoubleBuffer && dims.length == 3)
-		{
-			double[][][] m = new double[dims[0]][dims[1]][dims[2]];
-			double[] data = ((DoubleBuffer)this.data).array();
-			int idx = 0;
-			if (data.length > 0)
-				for (int k=0; k<dims[2]; k++)
-					for (int j=0; j<dims[1]; j++)
-						for (int i=0; i<dims[0]; i++)
-							m[i][j][k] = data[idx++];
-			cache = m;
-			return m;
-		}
-		else
-			System.out.println("Warning: invalid conversion to double array");
+    if (data instanceof DoubleBuffer && dims.length == 3)
+      {
+        double[][][] m = new double[dims[0]][dims[1]][dims[2]];
+        double[] data = ((DoubleBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int k = 0; k < dims[2]; k++)
+            for (int j = 0; j < dims[1]; j++)
+              for (int i = 0; i < dims[0]; i++)
+                m[i][j][k] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to double array");
 
-		return null;
-	}
+    return null;
+  }
 
-	public int[][] asIntMatrix()
-	{
-		if (cache != null)
-		{
-			try { return (int[][])cache; }
-			catch (ClassCastException e) { }
-		}
+  public int[][] asIntMatrix ()
+  {
+    if (cache != null)
+      {
+        try { return (int[][])cache; }
+        catch (ClassCastException e) { }
+      }
 
-		if (data instanceof IntBuffer && dims.length == 2)
-		{
-			int[][] m = new int[dims[0]][dims[1]];
-			int[] data = ((IntBuffer)this.data).array();
-			int idx = 0;
-			if (data.length > 0)
-				for (int j=0; j<m[0].length; j++)
-					for (int i=0; i<m.length; i++)
-						m[i][j] = data[idx++];
-			cache = m;
-			return m;
-		}
-		else
-			System.out.println("Warning: invalid conversion to integer matrix");
+    if (data instanceof IntBuffer && dims.length == 2)
+      {
+        int[][] m = new int[dims[0]][dims[1]];
+        int[] data = ((IntBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int j = 0; j < m[0].length; j++)
+            for (int i = 0; i < m.length; i++)
+              m[i][j] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to integer matrix");
 
-		return null;
-	}
+    return null;
+  }
 
-	public double minValue()
-	{
-		double val = Double.POSITIVE_INFINITY;
+  public double minValue ()
+  {
+    double val = Double.POSITIVE_INFINITY;
 
-		if (data instanceof DoubleBuffer)
-		{
-			double[] buf = ((DoubleBuffer)data).array();
-			for (int i=0; i<buf.length; i++)
-				if (buf[i] < val)
-					val = buf[i];
-		}
-		else if (data instanceof ByteBuffer)
-		{
-			byte[] buf = ((ByteBuffer)data).array();
-			for (int i=0; i<buf.length; i++)
-				if (buf[i] < val)
-					val = buf[i];
-		}
-		else
-			System.out.println("Warning: cannot compute min value for array of type `" + getClassName() + "'");
+    if (data instanceof DoubleBuffer)
+      {
+        double[] buf = ((DoubleBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] < val)
+            val = buf[i];
+      }
+    else if (data instanceof ByteBuffer)
+      {
+        byte[] buf = ((ByteBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] < val)
+            val = buf[i];
+      }
+    else
+      System.out.println ("Warning: cannot compute min value for array of type `" + getClassName () + "'");
 
-		return val;
-	}
+    return val;
+  }
 
-	public double maxValue()
-	{
-		double val = Double.NEGATIVE_INFINITY;
+  public double maxValue ()
+  {
+    double val = Double.NEGATIVE_INFINITY;
 
-		if (data instanceof DoubleBuffer)
-		{
-			double[] buf = ((DoubleBuffer)data).array();
-			for (int i=0; i<buf.length; i++)
-				if (buf[i] > val)
-					val = buf[i];
-		}
-		else if (data instanceof ByteBuffer)
-		{
-			byte[] buf = ((ByteBuffer)data).array();
-			for (int i=0; i<buf.length; i++)
-				if (buf[i] > val)
-					val = buf[i];
-		}
-		else
-			System.out.println("Warning: cannot compute max value for array of type `" + getClassName() + "'");
+    if (data instanceof DoubleBuffer)
+      {
+        double[] buf = ((DoubleBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] > val)
+            val = buf[i];
+      }
+    else if (data instanceof ByteBuffer)
+      {
+        byte[] buf = ((ByteBuffer)data).array ();
+        for (int i = 0; i <buf.length; i++)
+          if (buf[i] > val)
+            val = buf[i];
+      }
+    else
+      System.out.println ("Warning: cannot compute max value for array of type `" + getClassName () + "'");
 
-		return val;
-	}
+    return val;
+  }
 }
diff --git a/scripts/java/org/octave/OctClassLoader.java b/scripts/java/org/octave/OctClassLoader.java
--- a/scripts/java/org/octave/OctClassLoader.java
+++ b/scripts/java/org/octave/OctClassLoader.java
@@ -1,68 +1,74 @@
-/* Copyright (C) 2007 Michael Goffioul
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; If not, see <http://www.gnu.org/licenses/>.
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
 */
 
 package org.octave;
 
 import java.io.File;
 
 public class OctClassLoader extends java.net.URLClassLoader
 {
   public OctClassLoader ()
-    {
-      super (new java.net.URL[0]);
-    }
+  {
+    super (new java.net.URL[0]);
+  }
 
   public OctClassLoader (ClassLoader parent)
-    {
-      super (new java.net.URL[0], parent);
-    }
+  {
+    super (new java.net.URL[0], parent);
+  }
 
   protected Class findClass (String name) throws ClassNotFoundException
-    {
-      //System.out.println ("Looking for class " + name);
-      return super.findClass (name);
-    }
+  {
+    //System.out.println ("Looking for class " + name);
+    return super.findClass (name);
+  }
 
   protected String findLibrary (String libname)
-    {
-      // Look dynamically into java.library.path, because Sun VM does
-      // not do it (seems to cache initial java.library.path instead)
+  {
+    // Look dynamically into java.library.path, because Sun VM does
+    // not do it (seems to cache initial java.library.path instead)
 
-      String[] paths = System.getProperty ("java.library.path").split (File.pathSeparator);
+    String[] paths = System.getProperty ("java.library.path").split (File.pathSeparator);
 
-      libname = System.mapLibraryName (libname);
-      for (int i=0; i<paths.length; i++)
-        {
-          File f = new File (paths[i], libname);
-          if (f.exists ())
-            return f.getAbsolutePath();
-        }
+    libname = System.mapLibraryName (libname);
+    for (int i = 0; i < paths.length; i++)
+      {
+        File f = new File (paths[i], libname);
+        if (f.exists ())
+          return f.getAbsolutePath ();
+      }
 
-      return null;
-    }
+    return null;
+  }
 
   public void addClassPath (String name) throws Exception
-    {
-      java.io.File f = new java.io.File (name);
-      addURL (f.toURI ().toURL ());
-    }
+  {
+    java.io.File f = new java.io.File (name);
+    addURL (f.toURI ().toURL ());
+  }
 
   // new -MH-
   public void addURL (java.net.URL url)
-    {
-      super.addURL (url);
-    }
+  {
+    super.addURL (url);
+  }
 }
diff --git a/scripts/java/org/octave/Octave.java b/scripts/java/org/octave/Octave.java
--- a/scripts/java/org/octave/Octave.java
+++ b/scripts/java/org/octave/Octave.java
@@ -1,214 +1,220 @@
-/* Copyright (C) 2007 Michael Goffioul
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; If not, see <http://www.gnu.org/licenses/>.
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
 */
 
 package org.octave;
 
 import java.util.*;
 
 public class Octave
 {
   private static Object notifyObject = null;
   private static Object[] args = null;
-  private static LinkedList invokeList = new LinkedList();
-  private static LinkedList waitList = new LinkedList();
+  private static LinkedList invokeList = new LinkedList ();
+  private static LinkedList waitList = new LinkedList ();
 
   public native static boolean call (String name, Object[] argin, Object[] argout);
-  public native static void doInvoke(int ID, Object[] args);
-  public native static void doEvalString(String cmd);
-  public native static boolean needThreadedInvokation();
+  public native static void doInvoke (int ID, Object[] args);
+  public native static void doEvalString (String cmd);
+  public native static boolean needThreadedInvokation ();
 
-  public static void checkPendingAction()
-    {
-      if (notifyObject != null)
-        {
-          synchronized(notifyObject)
-            {
-              if (notifyObject instanceof OctaveReference)
-                doInvoke(((OctaveReference)notifyObject).getID(), args);
-              else if (notifyObject instanceof String)
-                doEvalString((String)notifyObject);
-              notifyObject.notifyAll();
-            }
-          notifyObject = null;
-          args = null;
-        }
+  public static void checkPendingAction ()
+  {
+    if (notifyObject != null)
+      {
+        synchronized (notifyObject)
+          {
+            if (notifyObject instanceof OctaveReference)
+              doInvoke (((OctaveReference)notifyObject).getID (), args);
+            else if (notifyObject instanceof String)
+              doEvalString ((String)notifyObject);
+            notifyObject.notifyAll ();
+          }
+        notifyObject = null;
+        args = null;
+      }
 
-      Object obj;
-      Object[] objArgs;
+    Object obj;
+    Object[] objArgs;
 
-      while (true)
-        {
-          obj = null;
-          objArgs = null;
+    while (true)
+      {
+        obj = null;
+        objArgs = null;
 
-          synchronized (invokeList)
-            {
-              if (invokeList.size() > 0)
-                {
-                  obj = invokeList.remove();
-                  if (obj instanceof OctaveReference)
-                    objArgs = (Object[])invokeList.remove();
-                }
-            }
+        synchronized (invokeList)
+          {
+            if (invokeList.size () > 0)
+              {
+                obj = invokeList.remove ();
+                if (obj instanceof OctaveReference)
+                  objArgs = (Object[])invokeList.remove ();
+              }
+          }
 
-          if (obj != null)
-            {
-              if (obj instanceof Runnable)
-                ((Runnable)obj).run();
-              else if (obj instanceof OctaveReference)
-                doInvoke(((OctaveReference)obj).getID(), objArgs);
-              else if (obj instanceof String)
-                doEvalString((String)obj);
-            }
-          else
-            break;
-        }
-      /*
-      synchronized(invokeList)
-        {
-          while (invokeList.size() > 0)
-            {
-              Object obj = invokeList.remove();
-	      if (obj instanceof Runnable)
-                ((Runnable)obj).run();
-              if (obj instanceof OctaveReference)
-                {
-                  Object[] objArgs = (Object[])invokeList.remove();
-                  doInvoke(((OctaveReference)obj).getID(), objArgs);
-                }
-              else if (obj instanceof String)
-                doEvalString((String)obj);
-            }
-        }
-        */
-    }
+        if (obj != null)
+          {
+            if (obj instanceof Runnable)
+              ((Runnable)obj).run ();
+            else if (obj instanceof OctaveReference)
+              doInvoke (((OctaveReference)obj).getID (), objArgs);
+            else if (obj instanceof String)
+              doEvalString ((String)obj);
+          }
+        else
+          break;
+      }
+    /*
+      synchronized (invokeList)
+      {
+      while (invokeList.size () > 0)
+      {
+      Object obj = invokeList.remove ();
+      if (obj instanceof Runnable)
+      ((Runnable)obj).run ();
+      if (obj instanceof OctaveReference)
+      {
+      Object[] objArgs = (Object[])invokeList.remove ();
+      doInvoke (((OctaveReference)obj).getID (), objArgs);
+      }
+      else if (obj instanceof String)
+      doEvalString ((String)obj);
+      }
+      }
+    */
+  }
 
-  private static void checkWaitState()
-    {
-      if (waitList.size() > 0)
-        {
-          Object wObj = waitList.getFirst();
-          synchronized (wObj)
-            {
-              wObj.notifyAll();
-            }
-        }
-    }
+  private static void checkWaitState ()
+  {
+    if (waitList.size () > 0)
+      {
+        Object wObj = waitList.getFirst ();
+        synchronized (wObj)
+          {
+            wObj.notifyAll ();
+          }
+      }
+  }
 
-  public static void invokeAndWait(OctaveReference ref, Object[] invokeArgs)
-    {
-      if (needThreadedInvokation())
+  public static void invokeAndWait (OctaveReference ref, Object[] invokeArgs)
+  {
+    if (needThreadedInvokation ())
+      {
+        synchronized (ref)
+          {
+            notifyObject = ref;
+            args = invokeArgs;
+            try { checkWaitState (); ref.wait (); }
+            catch (InterruptedException e) {}
+          }
+      }
+    else
+      doInvoke (ref.getID (), invokeArgs);
+  }
+
+  public static void evalAndWait (String cmd)
+  {
+    if (needThreadedInvokation ())
+      {
+        synchronized (cmd)
+          {
+            notifyObject = cmd;
+            args = null;
+            try { checkWaitState (); cmd.wait (); }
+            catch (InterruptedException e) {}
+          }
+      }
+    else
+      doEvalString (cmd);
+  }
+
+  public static void invokeLater (Runnable r)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
         {
-          synchronized(ref)
-            {
-              notifyObject = ref;
-              args = invokeArgs;
-              try { checkWaitState(); ref.wait(); }
-              catch (InterruptedException e) {}
-            }
+          invokeList.add (r);
+          checkWaitState ();
         }
-      else
-        doInvoke(ref.getID(), invokeArgs);
-    }
+    else
+      r.run ();
+  }
 
-  public static void evalAndWait(String cmd)
-    {
-      if (needThreadedInvokation())
+  public static void invokeLater (OctaveReference ref, Object[] invokeArgs)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
         {
-          synchronized(cmd)
-            {
-              notifyObject = cmd;
-              args = null;
-              try { checkWaitState(); cmd.wait(); }
-              catch (InterruptedException e) {}
-            }
+          invokeList.add (ref);
+          invokeList.add (invokeArgs);
+          checkWaitState ();
         }
-      else
-        doEvalString(cmd);
-    }
+    else
+      doInvoke (ref.getID (), invokeArgs);
+  }
 
-  public static void invokeLater(Runnable r)
-    {
-      if (needThreadedInvokation())
-        synchronized(invokeList)
-          {
-            invokeList.add(r);
-            checkWaitState();
-          }
-      else
-        r.run();
-    }
+  public static void evalLater (String cmd)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
+        {
+          invokeList.add (cmd);
+          checkWaitState ();
+        }
+    else
+      doEvalString (cmd);
+  }
 
-  public static void invokeLater(OctaveReference ref, Object[] invokeArgs)
-    {
-      if (needThreadedInvokation())
-        synchronized(invokeList)
+  public static void waitFor (Object wObj)
+  {
+    waitList.add (0, wObj);
+    synchronized (wObj)
+      {
+        while (waitList.size () > 0 && waitList.getFirst () == wObj)
           {
-            invokeList.add(ref);
-            invokeList.add(invokeArgs);
-            checkWaitState();
+            try { wObj.wait (); }
+            catch (InterruptedException e) {}
+            checkPendingAction ();
           }
-      else
-        doInvoke(ref.getID(), invokeArgs);
-    }
-
-  public static void evalLater(String cmd)
-    {
-      if (needThreadedInvokation())
-        synchronized(invokeList)
-          {
-            invokeList.add(cmd);
-            checkWaitState();
-          }
-      else
-        doEvalString(cmd);
-    }
+      }
+  }
 
-  public static void waitFor(Object wObj)
-    {
-      waitList.add(0, wObj);
-      synchronized (wObj)
+  public static void endWaitFor (Object obj)
+  {
+    boolean isCurrentWaitObject = (waitList.size () > 0 && waitList.getFirst () == obj);
+
+    waitList.remove (obj);
+    if (needThreadedInvokation () && isCurrentWaitObject)
+      synchronized (obj)
         {
-          while (waitList.size() > 0 && waitList.getFirst() == wObj)
-            {
-              try { wObj.wait(); }
-              catch (InterruptedException e) {}
-              checkPendingAction();
-            }
+          obj.notifyAll ();
         }
-    }
-
-  public static void endWaitFor(Object obj)
-    {
-      boolean isCurrentWaitObject = (waitList.size() > 0 && waitList.getFirst() == obj);
-
-      waitList.remove(obj);
-	  if (needThreadedInvokation() && isCurrentWaitObject)
-        synchronized (obj)
-          {
-            obj.notifyAll();
-          }
-    }
+  }
 
   public static Object do_test (String name, Object arg0) throws Exception
-    {
-      Object[] argin = new Object[] { arg0 };
-	  Object[] argout = new Object[1];
-      if (call (name, argin, argout))
-        return argout[0];
-      throw new Exception ("octave call failed");
-    }
+  {
+    Object[] argin = new Object[] { arg0 };
+    Object[] argout = new Object[1];
+    if (call (name, argin, argout))
+      return argout[0];
+    throw new Exception ("octave call failed");
+  }
 }
diff --git a/scripts/java/org/octave/OctaveReference.java b/scripts/java/org/octave/OctaveReference.java
--- a/scripts/java/org/octave/OctaveReference.java
+++ b/scripts/java/org/octave/OctaveReference.java
@@ -1,58 +1,64 @@
-/* Copyright (C) 2007 Michael Goffioul
-**
-** This program is free software; you can redistribute it and/or modify
-** it under the terms of the GNU General Public License as published by
-** the Free Software Foundation; either version 2 of the License, or
-** (at your option) any later version.
-**
-** This program is distributed in the hope that it will be useful,
-** but WITHOUT ANY WARRANTY; without even the implied warranty of
-** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-** GNU General Public License for more details.
-**
-** You should have received a copy of the GNU General Public License
-** along with this program; If not, see <http://www.gnu.org/licenses/>.
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
 */
 
 package org.octave;
 
 public class OctaveReference
 {
-	private int ID;
+  private int ID;
 
-	public OctaveReference(int ID)
-	{
-		this.ID = ID;
-	}
+  public OctaveReference (int ID)
+  {
+    this.ID = ID;
+  }
 
-	private native static void doFinalize(int ID);
+  private native static void doFinalize (int ID);
 
-	protected void finalize() throws Throwable
-	{
-		doFinalize(this.ID);
-	}
+  protected void finalize () throws Throwable
+  {
+    doFinalize (this.ID);
+  }
 
-	public String toString()
-	{
-		return ("<octave reference " + this.ID + ">");
-	}
+  public String toString ()
+  {
+    return ("<octave reference " + this.ID + ">");
+  }
 
-	public int getID()
-	{
-		return this.ID;
-	}
+  public int getID ()
+  {
+    return this.ID;
+  }
 
-	public Object invoke(Object[] args)
-	{
-		//System.out.println("OctaveReference::invoke");
-		Octave.doInvoke(this.ID, args);
-		return null;
-	}
+  public Object invoke (Object[] args)
+  {
+    //System.out.println ("OctaveReference::invoke");
+    Octave.doInvoke (this.ID, args);
+    return null;
+  }
 
-	public synchronized Object invokeAndWait(Object[] args)
-	{
-		//System.out.println("OctaveReference::invokeandWait");
-		Octave.invokeAndWait(this, args);
-		return null;
-	}
+  public synchronized Object invokeAndWait (Object[] args)
+  {
+    //System.out.println ("OctaveReference::invokeandWait");
+    Octave.invokeAndWait (this, args);
+    return null;
+  }
 }
diff --git a/scripts/java/org/octave/TeXcode.java b/scripts/java/org/octave/TeXcode.java
--- a/scripts/java/org/octave/TeXcode.java
+++ b/scripts/java/org/octave/TeXcode.java
@@ -1,35 +1,37 @@
-/**
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; If not, see <http://www.gnu.org/licenses/>.
- *
- * A class to hold a TeX character code -> Unicode translation pair.
- *
- * <p>Copyright (c) 2010 Martin Hepperle</p>
- *
- * @author Martin Hepperle
- * @version 1.0
- */
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// A class to hold a TeX character code -> Unicode translation pair.
+
 package org.octave;
 
 public class TeXcode
 {
-   protected String tex;
-   protected char ucode;
+  protected String tex;
+  protected char ucode;
 
-   public TeXcode ( String t, char u )
-   {
-      tex = t;
-      ucode = u;
-   }
+  public TeXcode (String t, char u)
+  {
+    tex = t;
+    ucode = u;
+  }
 }
diff --git a/scripts/java/org/octave/TeXtranslator.java b/scripts/java/org/octave/TeXtranslator.java
--- a/scripts/java/org/octave/TeXtranslator.java
+++ b/scripts/java/org/octave/TeXtranslator.java
@@ -1,264 +1,262 @@
-/**
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; If not, see <http://www.gnu.org/licenses/>.
- *
- *
- * A primitive TeX character translator.
- * Provides methods to translate a subset of TeX symbol strings
- * into their aequivalent Unicode representation.
- *
- * Note that not all Unicode character sets contain all these characters.
- * Suitable Windows fonts are e.g.:<br>
- * - Lucida Sans Unicode<br>
- * - Arial Unicode MS<br>
- * - MS Mincho<br>
- *
- * <p>Copyright (c) 2010 Martin Hepperle</p>
- *
- * @author Martin Hepperle
- * @version 1.0
- */
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// A primitive TeX character translator.  Provides methods to translate
+// a subset of TeX symbol strings into their aequivalent Unicode
+// representation.
+//
+// Note that not all Unicode character sets contain all these characters.
+// Suitable Windows fonts are e.g.:
+//   - Lucida Sans Unicode
+//   - Arial Unicode MS
+//   - MS Mincho
+
 package org.octave;
 
 public class TeXtranslator
 {
-   private TeXcode m_texTable[] =
-      {
+  private TeXcode m_texTable[] =
+    {
       // lower case
-      new TeXcode ( "alpha", '\u03B1' ),
-      new TeXcode ( "beta", '\u03B2' ),
-      new TeXcode ( "gamma", '\u03B3' ),
-      new TeXcode ( "delta", '\u03B4' ),
-      new TeXcode ( "epsilon", '\u03B5' ),
-      new TeXcode ( "zeta", '\u03B6' ),
-      new TeXcode ( "eta", '\u03B7' ),
-      new TeXcode ( "theta", '\u03B8' ),
-      new TeXcode ( "vartheta", '\u03D1' ),
-      new TeXcode ( "iota", '\u03B9' ),
-      new TeXcode ( "kappa", '\u03BA' ),
-      new TeXcode ( "lambda", '\u03BB' ),
-      new TeXcode ( "mu", '\u03BC' ),
-      new TeXcode ( "nu", '\u03BD' ),
-      new TeXcode ( "xi", '\u03BE' ),
-      new TeXcode ( "pi", '\u03C0' ),
-      new TeXcode ( "rho", '\u03C1' ),
-      new TeXcode ( "sigma", '\u03C3' ),
-      new TeXcode ( "varsigma", '\u03C2' ),
-      new TeXcode ( "tau", '\u03C4' ),
-      new TeXcode ( "phi", '\u03C6' ),
-      new TeXcode ( "chi", '\u03C7' ),
-      new TeXcode ( "psi", '\u03C8' ),
-      new TeXcode ( "omega", '\u03C9' ),
-      new TeXcode ( "upsilon", '\u03C5' ),
+      new TeXcode ("alpha", '\u03B1'),
+      new TeXcode ("beta", '\u03B2'),
+      new TeXcode ("gamma", '\u03B3'),
+      new TeXcode ("delta", '\u03B4'),
+      new TeXcode ("epsilon", '\u03B5'),
+      new TeXcode ("zeta", '\u03B6'),
+      new TeXcode ("eta", '\u03B7'),
+      new TeXcode ("theta", '\u03B8'),
+      new TeXcode ("vartheta", '\u03D1'),
+      new TeXcode ("iota", '\u03B9'),
+      new TeXcode ("kappa", '\u03BA'),
+      new TeXcode ("lambda", '\u03BB'),
+      new TeXcode ("mu", '\u03BC'),
+      new TeXcode ("nu", '\u03BD'),
+      new TeXcode ("xi", '\u03BE'),
+      new TeXcode ("pi", '\u03C0'),
+      new TeXcode ("rho", '\u03C1'),
+      new TeXcode ("sigma", '\u03C3'),
+      new TeXcode ("varsigma", '\u03C2'),
+      new TeXcode ("tau", '\u03C4'),
+      new TeXcode ("phi", '\u03C6'),
+      new TeXcode ("chi", '\u03C7'),
+      new TeXcode ("psi", '\u03C8'),
+      new TeXcode ("omega", '\u03C9'),
+      new TeXcode ("upsilon", '\u03C5'),
       // upper case
-      new TeXcode ( "Gamma", '\u0393' ),
-      new TeXcode ( "Delta", '\u0394' ),
-      new TeXcode ( "Theta", '\u0398' ),
-      new TeXcode ( "Lambda", '\u039B' ),
-      new TeXcode ( "Pi", '\u03A0' ),
-      new TeXcode ( "Xi", '\u039E' ),
-      new TeXcode ( "Sigma", '\u03A3' ),
-      new TeXcode ( "Upsilon", '\u03A5' ),
-      new TeXcode ( "Phi", '\u03A6' ),
-      new TeXcode ( "Psi", '\u03A8' ),
-      new TeXcode ( "Omega", '\u03A9' ),
+      new TeXcode ("Gamma", '\u0393'),
+      new TeXcode ("Delta", '\u0394'),
+      new TeXcode ("Theta", '\u0398'),
+      new TeXcode ("Lambda", '\u039B'),
+      new TeXcode ("Pi", '\u03A0'),
+      new TeXcode ("Xi", '\u039E'),
+      new TeXcode ("Sigma", '\u03A3'),
+      new TeXcode ("Upsilon", '\u03A5'),
+      new TeXcode ("Phi", '\u03A6'),
+      new TeXcode ("Psi", '\u03A8'),
+      new TeXcode ("Omega", '\u03A9'),
       // complex
-      new TeXcode ( "Im", '\u2111' ),
-      new TeXcode ( "Re", '\u211c' ),
+      new TeXcode ("Im", '\u2111'),
+      new TeXcode ("Re", '\u211c'),
       // special
-      new TeXcode ( "leq", '\u2264' ),
-      new TeXcode ( "geq", '\u2265' ),
-      new TeXcode ( "neq", '\u2260' ),
-      new TeXcode ( "pm", '\u00B1' ),
-      new TeXcode ( "infty", '\u221E' ),
-      new TeXcode ( "partial", '\u2202' ),
-      new TeXcode ( "approx", '\u2248' ),
-      new TeXcode ( "circ", '\u2218' ),
-      new TeXcode ( "bullet", '\u2022' ),
-      new TeXcode ( "times", '\u00D7' ),
-      new TeXcode ( "sim", '\u007E' ),
-      new TeXcode ( "nabla", '\u2207' ),
-      new TeXcode ( "ldots", '\u2026' ),
-      new TeXcode ( "exists", '\u2203' ),
-      new TeXcode ( "neg", '\u00AC' ),
-      new TeXcode ( "aleph", '\u2135' ),
-      new TeXcode ( "forall", '\u2200' ),
-      new TeXcode ( "cong", '\u2245' ),
-      new TeXcode ( "wp", '\u2118' ),
-      new TeXcode ( "propto", '\u221D' ),
-      new TeXcode ( "otimes", '\u2297' ),
-      new TeXcode ( "oplus", '\u2295' ),
-      new TeXcode ( "oslash", '\u2298' ),
-      new TeXcode ( "cap", '\u2229' ),
-      new TeXcode ( "cup", '\u222A' ),
-      new TeXcode ( "ni", '\u220B' ),
-      new TeXcode ( "in", '\u2208' ),
-      new TeXcode ( "div", '\u00F7' ),
-      new TeXcode ( "equiv", '\u2261' ),
-      new TeXcode ( "int", '\u222B' ),
-      new TeXcode ( "perp", '\u22A5' ),
-      new TeXcode ( "wedge", '\u2227' ),
-      new TeXcode ( "vee", '\u2228' ),
+      new TeXcode ("leq", '\u2264'),
+      new TeXcode ("geq", '\u2265'),
+      new TeXcode ("neq", '\u2260'),
+      new TeXcode ("pm", '\u00B1'),
+      new TeXcode ("infty", '\u221E'),
+      new TeXcode ("partial", '\u2202'),
+      new TeXcode ("approx", '\u2248'),
+      new TeXcode ("circ", '\u2218'),
+      new TeXcode ("bullet", '\u2022'),
+      new TeXcode ("times", '\u00D7'),
+      new TeXcode ("sim", '\u007E'),
+      new TeXcode ("nabla", '\u2207'),
+      new TeXcode ("ldots", '\u2026'),
+      new TeXcode ("exists", '\u2203'),
+      new TeXcode ("neg", '\u00AC'),
+      new TeXcode ("aleph", '\u2135'),
+      new TeXcode ("forall", '\u2200'),
+      new TeXcode ("cong", '\u2245'),
+      new TeXcode ("wp", '\u2118'),
+      new TeXcode ("propto", '\u221D'),
+      new TeXcode ("otimes", '\u2297'),
+      new TeXcode ("oplus", '\u2295'),
+      new TeXcode ("oslash", '\u2298'),
+      new TeXcode ("cap", '\u2229'),
+      new TeXcode ("cup", '\u222A'),
+      new TeXcode ("ni", '\u220B'),
+      new TeXcode ("in", '\u2208'),
+      new TeXcode ("div", '\u00F7'),
+      new TeXcode ("equiv", '\u2261'),
+      new TeXcode ("int", '\u222B'),
+      new TeXcode ("perp", '\u22A5'),
+      new TeXcode ("wedge", '\u2227'),
+      new TeXcode ("vee", '\u2228'),
       // sets
-      new TeXcode ( "supseteq", '\u2287' ),
-      new TeXcode ( "supset", '\u2283' ),
-      new TeXcode ( "subseteq", '\u2286' ),
-      new TeXcode ( "subset", '\u2282' ),
+      new TeXcode ("supseteq", '\u2287'),
+      new TeXcode ("supset", '\u2283'),
+      new TeXcode ("subseteq", '\u2286'),
+      new TeXcode ("subset", '\u2282'),
       // cards
-      new TeXcode ( "clubsuit", '\u2663' ),
-      new TeXcode ( "spadesuit", '\u2660' ),
-      new TeXcode ( "heartsuit", '\u2665' ),
-      new TeXcode ( "diamondsuit", '\u2666' ),
-      new TeXcode ( "copyright", '\u00A9' ),
+      new TeXcode ("clubsuit", '\u2663'),
+      new TeXcode ("spadesuit", '\u2660'),
+      new TeXcode ("heartsuit", '\u2665'),
+      new TeXcode ("diamondsuit", '\u2666'),
+      new TeXcode ("copyright", '\u00A9'),
       // arrows
-      new TeXcode ( "leftarrow", '\u2190' ),
-      new TeXcode ( "uparrow", '\u2191' ),
-      new TeXcode ( "rightarrow", '\u2192' ),
-      new TeXcode ( "downarrow", '\u2193' ),
-      new TeXcode ( "leftrightarrow", '\u2194' ),
-      new TeXcode ( "updownarrow", '\u2195' ),
-   };
+      new TeXcode ("leftarrow", '\u2190'),
+      new TeXcode ("uparrow", '\u2191'),
+      new TeXcode ("rightarrow", '\u2192'),
+      new TeXcode ("downarrow", '\u2193'),
+      new TeXcode ("leftrightarrow", '\u2194'),
+      new TeXcode ("updownarrow", '\u2195'),
+    };
 
    public TeXtranslator ()
    {
-      /* DEBUG: output table to file
-      try
-      {
-         java.io.PrintWriter pwTeX = new java.io.PrintWriter ( "z:/tex.txt",
-            "UTF-8" );
-         java.io.PrintWriter pwHTML = new java.io.PrintWriter ( "z:/html.txt",
-            "UTF-8" );
-         java.io.PrintWriter pwOctave = new java.io.PrintWriter ( "z:/octave.txt",
-            "UTF-8" );
-         pwOctave.print ( "msgbox ( [" );
+     /* DEBUG: output table to file
+     try
+       {
+         java.io.PrintWriter pwTeX = new java.io.PrintWriter ("z:/tex.txt", "UTF-8");
+         java.io.PrintWriter pwHTML = new java.io.PrintWriter ("z:/html.txt", "UTF-8");
+         java.io.PrintWriter pwOctave = new java.io.PrintWriter ("z:/octave.txt", "UTF-8");
+         pwOctave.print ("msgbox ( [");
          int i = 0;
-         for ( int k = 0; k < m_texTable.length; k++ )
-         {
-            if ( i++ == 0 )
-            {
-               pwTeX.print ( "@item " );
-               pwHTML.print ( "@item " );
-               pwOctave.print ( "          '" );
-            }
-            else
-            {
-               pwTeX.print ( "@tab " );
-               pwHTML.print ( "@tab " );
-               pwOctave.print ( "   " );
-            }
-            pwTeX.println ( "\\" + m_texTable[k].tex );
-            pwTeX.println ( "@tab '@math{\\" + m_texTable[k].tex + "}'" );
-            pwHTML.println ( "\\" + m_texTable[k].tex );
-            pwHTML.println ( "@tab '" + m_texTable[k].ucode + "'" );
-            pwOctave.print ( "\\\\" + m_texTable[k].tex+" " );
-            pwOctave.print ( " = ''\\" + m_texTable[k].tex + " ''" );
-            if ( i == 3 )
-            {
-               pwTeX.println ( "@c ----------" );
-               pwHTML.println ( "@c ----------" );
-               pwOctave.println ( "', 10, ..." );
-               i=0;
-            }
-            else
-            {
-               pwTeX.println ( "@tab" );
-               pwHTML.println ( "@tab" );
-               pwOctave.print ( "   " );
-            }
-         }
-         pwOctave.print ( "']);" );
+         for (int k = 0; k < m_texTable.length; k++)
+           {
+             if (i++ == 0)
+               {
+                 pwTeX.print ("@item ");
+                 pwHTML.print ("@item ");
+                 pwOctave.print ("          '");
+               }
+             else
+               {
+                 pwTeX.print ("@tab ");
+                 pwHTML.print ("@tab ");
+                 pwOctave.print ("   ");
+               }
+             pwTeX.println ("\\" + m_texTable[k].tex);
+             pwTeX.println ("@tab '@math{\\" + m_texTable[k].tex + "}'");
+             pwHTML.println ("\\" + m_texTable[k].tex);
+             pwHTML.println ("@tab '" + m_texTable[k].ucode + "'");
+             pwOctave.print ("\\\\" + m_texTable[k].tex+" ");
+             pwOctave.print (" = ''\\" + m_texTable[k].tex + " ''");
+             if (i == 3)
+               {
+                 pwTeX.println ("@c ----------");
+                 pwHTML.println ("@c ----------");
+                 pwOctave.println ("', 10, ...");
+                 i=0;
+               }
+             else
+               {
+                 pwTeX.println ("@tab");
+                 pwHTML.println ("@tab");
+                 pwOctave.print ("   ");
+               }
+           }
+         pwOctave.print ("']);");
          pwTeX.close ();
          pwHTML.close ();
          pwOctave.close ();
-      }
-      catch ( Exception e )
-      {
+       }
+     catch (Exception e)
+       {
          ;
-      }
+       }
       /* */
    }
 
 
-   /*
-      NOT YET TRANSLATED
-     o
-     rfloor
-     lceil
-     lfloor
-     cdot
-     prime
-     0
-     rceil
-     surd
-     mid
-     varpi
-     langle
-     rangle
-    */
+  /*
+    NOT YET TRANSLATED
+    o
+    rfloor
+    lceil
+    lfloor
+    cdot
+    prime
+    0
+    rceil
+    surd
+    mid
+    varpi
+    langle
+    rangle
+  */
 
-   public String replace ( String s )
-   {
-      StringBuffer sb = new StringBuffer ( s );
-      // append trailing blank
-      sb.append ( ' ' );
+  public String replace (String s)
+  {
+    StringBuffer sb = new StringBuffer (s);
+    // append trailing blank
+    sb.append (' ');
 
-      int i = 0;
-      do
+    int i = 0;
+    do
       {
-         /* 26 08 2010 MH szatt search at index i */
-         i = sb.indexOf ( "\\", i );
-         if ( i > -1 )
-         {
-            int j = sb.indexOf ( " ", i );
-            if ( j > i )
-            {
-               String token = sb.substring ( i + 1, j );
+        // 26 08 2010 MH szatt search at index i
+        i = sb.indexOf ("\\", i);
+        if (i > -1)
+          {
+            int j = sb.indexOf (" ", i);
+            if (j > i)
+              {
+                String token = sb.substring (i + 1, j);
 
-               for ( int k = 0; k < m_texTable.length; k++ )
-               {
-                  if ( m_texTable[k].tex.equals ( token ) )
+                for (int k = 0; k < m_texTable.length; k++)
                   {
-                     sb.replace ( i, j + 1,
-                                  Character.toString ( m_texTable[k].ucode ) );
-                     break;
+                    if (m_texTable[k].tex.equals (token))
+                      {
+                        sb.replace (i, j + 1,
+                                    Character.toString (m_texTable[k].ucode));
+                        break;
+                      }
                   }
-               }
-               if ( sb.charAt ( i ) == '\\' )
-               {
-                  // backslash sztill there: not found
-                  if ( sb.charAt ( i + 1 ) == 'n' )
-                  {
-                     // newline
-                     sb.replace ( i, i + 2, "\n" );
-                  }
-                  else if ( sb.charAt ( i + 1 ) == '\\' )
+                if (sb.charAt (i) == '\\')
                   {
-                     // backslash
-                     sb.replace ( i, i + 2, "\\" );
+                    // backslash sztill there: not found
+                    if (sb.charAt (i + 1) == 'n')
+                      {
+                        // newline
+                        sb.replace (i, i + 2, "\n");
+                      }
+                    else if (sb.charAt (i + 1) == '\\')
+                      {
+                        // backslash
+                        sb.replace (i, i + 2, "\\");
+                      }
                   }
-               }
-               /* 26 08 2010 MH
-                advance i to avoid deadlock in case of incorrect escape
-                sequences like \\\\alpha (double backslash) or
-                \\bogus (unknown escape sequence)
-                */
-               i++;
-            }
-         }
+
+                // 26 08 2010 MH
+                // advance i to avoid deadlock in case of incorrect escape
+                // sequences like \\\\alpha (double backslash) or
+                // \\bogus (unknown escape sequence)
+                i++;
+              }
+          }
       }
-      while ( i > -1 );
-      // finall: remove trailing blank
-      return ( sb.substring ( 0, sb.length () - 1 ).toString () );
-   }
+    while (i > -1);
+    // finall: remove trailing blank
+    return (sb.substring (0, sb.length () - 1).toString ());
+  }
 }
