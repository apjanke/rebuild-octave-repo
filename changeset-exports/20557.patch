# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444091839 14400
#      Mon Oct 05 20:37:19 2015 -0400
# Node ID b10432a40432297c1c97f39ec1bb410307d0241d
# Parent  4bed806ee3d46878babfa79138ac97a88e8220f7
eliminate more simple uses of error_state

* dasrt.cc, debug.cc, find.cc, gammainc.cc, matrix_type.cc,
ov-usr-fcn.cc, pt-assign.cc, pt-binop.cc:
Eliminate simple uses of error_state.

diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -443,37 +443,34 @@ parameters for @code{dasrt}.\n\
               dasrt_f = extract_function (f_arg, "dasrt", fcn_name, fname,
                                           "; endfunction");
               break;
 
             case 2:
               {
                 string_vector tmp = args(0).all_strings ();
 
-                if (! error_state)
-                  {
-                    fcn_name = unique_symbol_name ("__dasrt_fcn__");
-                    fname = "function y = ";
-                    fname.append (fcn_name);
-                    fname.append (" (x, xdot, t) y = ");
-                    dasrt_f = extract_function (tmp(0), "dasrt", fcn_name,
-                                                fname, "; endfunction");
+                fcn_name = unique_symbol_name ("__dasrt_fcn__");
+                fname = "function y = ";
+                fname.append (fcn_name);
+                fname.append (" (x, xdot, t) y = ");
+                dasrt_f = extract_function (tmp(0), "dasrt", fcn_name,
+                                            fname, "; endfunction");
 
-                    if (dasrt_f)
-                      {
-                        jac_name = unique_symbol_name ("__dasrt_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, xdot, t, cj) jac = ");
-                        dasrt_j = extract_function (tmp(1), "dasrt", jac_name,
-                                                    jname, "; endfunction");
+                if (dasrt_f)
+                  {
+                    jac_name = unique_symbol_name ("__dasrt_jac__");
+                    jname = "function jac = ";
+                    jname.append (jac_name);
+                    jname.append (" (x, xdot, t, cj) jac = ");
+                    dasrt_j = extract_function (tmp(1), "dasrt", jac_name,
+                                                jname, "; endfunction");
 
-                        if (! dasrt_j)
-                          dasrt_f = 0;
-                      }
+                    if (! dasrt_j)
+                      dasrt_f = 0;
                   }
               }
               break;
 
             default:
               DASRT_ABORT1
                 ("first arg should be a string or 2-element string array");
             }
@@ -555,34 +552,31 @@ parameters for @code{dasrt}.\n\
   else
     output = dae.integrate (out_times);
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
-  if (! error_state)
-    {
-      std::string msg = dae.error_message ();
+  std::string msg = dae.error_message ();
 
-      retval(4) = msg;
-      retval(3) = static_cast<double> (dae.integration_state ());
+  retval(4) = msg;
+  retval(3) = static_cast<double> (dae.integration_state ());
 
-      if (dae.integration_ok ())
-        {
-          retval(2) = output.times ();
-          retval(1) = output.deriv ();
-          retval(0) = output.state ();
-        }
-      else
-        {
-          retval(2) = Matrix ();
-          retval(1) = Matrix ();
-          retval(0) = Matrix ();
+  if (dae.integration_ok ())
+    {
+      retval(2) = output.times ();
+      retval(1) = output.deriv ();
+      retval(0) = output.state ();
+    }
+  else
+    {
+      retval(2) = Matrix ();
+      retval(1) = Matrix ();
+      retval(0) = Matrix ();
 
-          if (nargout < 4)
-            error ("dasrt: %s", msg.c_str ());
-        }
+      if (nargout < 4)
+        error ("dasrt: %s", msg.c_str ());
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -205,25 +205,21 @@ parse_dbfunction_params (const char *who
   if (args.length () == 0)
     return;
 
   if (args(0).is_string ())
     {
       // string could be function name or line number
       int isint = atoi (args(0).string_value ().c_str ());
 
-      if (error_state)
-        return;
-
       if (isint == 0)
         {
           // It was a function name
           symbol_name = args(0).string_value ();
-          if (error_state)
-            return;
+
           idx = 1;
         }
       else
         {
           // It was a line number.  Need to get function name from debugger.
           if (Vdebugging)
             {
               symbol_name = get_user_code ()->name ();
@@ -245,39 +241,31 @@ parse_dbfunction_params (const char *who
   else
     error ("%s: invalid parameter specified", who);
 
   for (int i = idx; i < nargin; i++)
     {
       if (args(i).is_string ())
         {
           int line = atoi (args(i).string_value ().c_str ());
-          if (error_state)
-            break;
+
           lines[list_idx++] = line;
         }
       else if (args(i).is_map ())
         octave_stdout << who << ": skipping struct input" << std::endl;
       else
         {
           const NDArray arg = args(i).array_value ();
 
-          if (error_state)
-            break;
-
           for (octave_idx_type j = 0; j < arg.numel (); j++)
             {
               int line = static_cast<int> (arg.elem (j));
-              if (error_state)
-                break;
+
               lines[list_idx++] = line;
             }
-
-          if (error_state)
-            break;
         }
     }
 }
 
 bool
 bp_table::instance_ok (void)
 {
   bool retval = true;
@@ -672,18 +660,17 @@ Octave will set the real breakpoint at t
   std::string symbol_name;
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbstop", args, symbol_name, lines);
 
   if (lines.size () == 0)
     lines[0] = 1;
 
-  if (! error_state)
-    retval = bp_table::add_breakpoint (symbol_name, lines);
+  retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbclear @var{func}\n\
 @deftypefnx {Command} {} dbclear @var{func} @var{line}\n\
@@ -726,20 +713,17 @@ files.\n\
 
   int nargin = args.length ();
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
 
   if (nargin == 1 && symbol_name == "all")
     bp_table::remove_all_breakpoints ();
   else
-    {
-      if (! error_state)
-        bp_table::remove_breakpoint (symbol_name, lines);
-    }
+    bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbstatus ()\n\
 @deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus ()\n\
@@ -968,144 +952,141 @@ numbers.\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
-  if (! error_state)
+  switch (nargin)
     {
-      switch (nargin)
-        {
-        case 0: // dbtype
-          dbg_fcn = get_user_code ();
+    case 0: // dbtype
+      dbg_fcn = get_user_code ();
+
+      if (dbg_fcn)
+        do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                   0, std::numeric_limits<int>::max ());
+      else
+        error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
+
+      break;
+
+    case 1: // (dbtype start:end) || (dbtype func) || (dbtype lineno)
+      {
+        std::string arg = argv[1];
+
+        size_t ind = arg.find (':');
+
+        if (ind != std::string::npos)  // (dbtype start:end)
+          {
+            dbg_fcn = get_user_code ();
+
+            if (dbg_fcn)
+              {
+                std::string start_str = arg.substr (0, ind);
+                std::string end_str = arg.substr (ind + 1);
+
+                int start, end;
+                start = atoi (start_str.c_str ());
+                if (end_str == "end")
+                  end = std::numeric_limits<int>::max ();
+                else
+                  end = atoi (end_str.c_str ());
 
-          if (dbg_fcn)
-            do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                       0, std::numeric_limits<int>::max ());
-          else
-            error ("dbtype: must be inside a user function to give no arguments to dbtype\n");
+                if (std::min (start, end) <= 0)
+                  {
+                    error ("dbtype: start and end lines must be >= 1\n");
+                    break;
+                  }
 
-          break;
+                if (start <= end)
+                  do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                             start, end);
+                else
+                  error ("dbtype: start line must be less than end line\n");
+              }
+          }
+        else  // (dbtype func) || (dbtype lineno)
+          {
+            int line = atoi (arg.c_str ());
 
-        case 1: // (dbtype start:end) || (dbtype func) || (dbtype lineno)
-          {
-            std::string arg = argv[1];
+            if (line == 0)  // (dbtype func)
+              {
+                dbg_fcn = get_user_code (arg);
 
-            size_t ind = arg.find (':');
+                if (dbg_fcn)
+                  do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                             0, std::numeric_limits<int>::max ());
+                else
+                  error ("dbtype: function <%s> not found\n", arg.c_str ());
+              }
+            else  // (dbtype lineno)
+              {
+                if (line <= 0)
+                  {
+                    error ("dbtype: start and end lines must be >= 1\n");
+                    break;
+                  }
 
-            if (ind != std::string::npos)  // (dbtype start:end)
-              {
                 dbg_fcn = get_user_code ();
 
                 if (dbg_fcn)
-                  {
-                    std::string start_str = arg.substr (0, ind);
-                    std::string end_str = arg.substr (ind + 1);
-
-                    int start, end;
-                    start = atoi (start_str.c_str ());
-                    if (end_str == "end")
-                      end = std::numeric_limits<int>::max ();
-                    else
-                      end = atoi (end_str.c_str ());
-
-                    if (std::min (start, end) <= 0)
-                      {
-                        error ("dbtype: start and end lines must be >= 1\n");
-                        break;
-                      }
-
-                    if (start <= end)
-                      do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                                 start, end);
-                    else
-                      error ("dbtype: start line must be less than end line\n");
-                  }
-              }
-            else  // (dbtype func) || (dbtype lineno)
-              {
-                int line = atoi (arg.c_str ());
-
-                if (line == 0)  // (dbtype func)
-                  {
-                    dbg_fcn = get_user_code (arg);
-
-                    if (dbg_fcn)
-                      do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                                 0, std::numeric_limits<int>::max ());
-                    else
-                      error ("dbtype: function <%s> not found\n", arg.c_str ());
-                  }
-                else  // (dbtype lineno)
-                  {
-                    if (line <= 0)
-                      {
-                        error ("dbtype: start and end lines must be >= 1\n");
-                        break;
-                      }
-
-                    dbg_fcn = get_user_code ();
-
-                    if (dbg_fcn)
-                      do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                                 line, line);
-                  }
+                  do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                             line, line);
               }
           }
-          break;
-
-        case 2: // (dbtype func start:end) || (dbtype func start)
-          dbg_fcn = get_user_code (argv[1]);
+      }
+      break;
 
-          if (dbg_fcn)
-            {
-              std::string arg = argv[2];
-              int start, end;
-              size_t ind = arg.find (':');
-
-              if (ind != std::string::npos)
-                {
-                  std::string start_str = arg.substr (0, ind);
-                  std::string end_str = arg.substr (ind + 1);
+    case 2: // (dbtype func start:end) || (dbtype func start)
+      dbg_fcn = get_user_code (argv[1]);
 
-                  start = atoi (start_str.c_str ());
-                  if (end_str == "end")
-                    end = std::numeric_limits<int>::max ();
-                  else
-                    end = atoi (end_str.c_str ());
-                }
-              else
-                {
-                  start = atoi (arg.c_str ());
-                  end = start;
-                }
+      if (dbg_fcn)
+        {
+          std::string arg = argv[2];
+          int start, end;
+          size_t ind = arg.find (':');
 
-              if (std::min (start, end) <= 0)
-                {
-                  error ("dbtype: start and end lines must be >= 1\n");
-                  break;
-                }
+          if (ind != std::string::npos)
+            {
+              std::string start_str = arg.substr (0, ind);
+              std::string end_str = arg.substr (ind + 1);
 
-              if (start <= end)
-                do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
-                           start, end);
+              start = atoi (start_str.c_str ());
+              if (end_str == "end")
+                end = std::numeric_limits<int>::max ();
               else
-                error ("dbtype: start line must be less than end line\n");
+                end = atoi (end_str.c_str ());
             }
           else
-            error ("dbtype: function <%s> not found\n", argv[1].c_str ());
+            {
+              start = atoi (arg.c_str ());
+              end = start;
+            }
 
-          break;
+          if (std::min (start, end) <= 0)
+            {
+              error ("dbtype: start and end lines must be >= 1\n");
+              break;
+            }
 
-        default:
-          error ("dbtype: expecting zero, one, or two arguments\n");
+          if (start <= end)
+            do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
+                       start, end);
+          else
+            error ("dbtype: start line must be less than end line\n");
         }
+      else
+        error ("dbtype: function <%s> not found\n", argv[1].c_str ());
+
+      break;
+
+    default:
+      error ("dbtype: expecting zero, one, or two arguments\n");
     }
 
   return retval;
 }
 
 DEFUN (dblist, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dblist\n\
@@ -1195,17 +1176,17 @@ do_dbstack (const octave_value_list& arg
   octave_idx_type len = args.length ();
 
   // dbstack accepts up to 2 arguments.
 
   if (len == 1 || len == 2)
     {
       int n = 0;
 
-      for (octave_idx_type i = 0; i < len && ! error_state; i++)
+      for (octave_idx_type i = 0; i < len; i++)
         {
           octave_value arg = args(i);
 
           if (arg.is_string ())
             {
               std::string s_arg = arg.string_value ();
 
               // Skip "-completenames", octave returns full names anyway.
@@ -1213,83 +1194,80 @@ do_dbstack (const octave_value_list& arg
               if (s_arg == "-completenames")
                 continue;
 
               n = atoi (s_arg.c_str ());
             }
           else
             n = arg.int_value ();
 
-          if (! error_state && n <= 0)
+          if (n <= 0)
             error ("dbstack: N must be a non-negative integer");
         }
 
       if (n > 0)
         nskip = n;
     }
   else if (len)
     print_usage ();
 
-  if (! error_state)
+  if (nargout == 0)
     {
-      if (nargout == 0)
+      octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
+      octave_idx_type nframes_to_display = stk.numel ();
+
+      if (nframes_to_display > 0)
         {
-          octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
-          octave_idx_type nframes_to_display = stk.numel ();
+          octave_preserve_stream_state stream_state (os);
 
-          if (nframes_to_display > 0)
-            {
-              octave_preserve_stream_state stream_state (os);
-
-              os << "stopped in:\n\n";
+          os << "stopped in:\n\n";
 
-              Cell names = stk.contents ("name");
-              Cell files = stk.contents ("file");
-              Cell lines = stk.contents ("line");
+          Cell names = stk.contents ("name");
+          Cell files = stk.contents ("file");
+          Cell lines = stk.contents ("line");
 
-              bool show_top_level = true;
+          bool show_top_level = true;
 
-              size_t max_name_len = 0;
+          size_t max_name_len = 0;
 
-              for (octave_idx_type i = 0; i < nframes_to_display; i++)
-                {
-                  std::string name = names(i).string_value ();
+          for (octave_idx_type i = 0; i < nframes_to_display; i++)
+            {
+              std::string name = names(i).string_value ();
 
-                  max_name_len = std::max (name.length (), max_name_len);
-                }
+              max_name_len = std::max (name.length (), max_name_len);
+            }
 
-              for (octave_idx_type i = 0; i < nframes_to_display; i++)
-                {
-                  std::string name = names(i).string_value ();
-                  std::string file = files(i).string_value ();
-                  int line = lines(i).int_value ();
+          for (octave_idx_type i = 0; i < nframes_to_display; i++)
+            {
+              std::string name = names(i).string_value ();
+              std::string file = files(i).string_value ();
+              int line = lines(i).int_value ();
 
-                  if (show_top_level && i == curr_frame)
-                    show_top_level = false;
+              if (show_top_level && i == curr_frame)
+                show_top_level = false;
 
-                  os << (i == curr_frame ? "  --> " : "      ")
-                     << std::setw (max_name_len) << name
-                     << " at line " << line
-                     << " [" << file << "]"
-                     << std::endl;
-                }
-
-              if (show_top_level)
-                os << "  --> top level" << std::endl;
+              os << (i == curr_frame ? "  --> " : "      ")
+                 << std::setw (max_name_len) << name
+                 << " at line " << line
+                 << " [" << file << "]"
+                 << std::endl;
             }
+
+          if (show_top_level)
+            os << "  --> top level" << std::endl;
         }
-      else
-        {
-          octave_map stk = octave_call_stack::backtrace (nskip,
-                                                         curr_frame,
-                                                         false);
+    }
+  else
+    {
+      octave_map stk = octave_call_stack::backtrace (nskip,
+                                                     curr_frame,
+                                                     false);
 
-          retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
-          retval(0) = stk;
-        }
+      retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
+      retval(0) = stk;
     }
 
   return retval;
 }
 
 // A function that can be easily called from a debugger print the Octave
 // stack.  This can be useful for finding what line of code the
 // interpreter is currently executing when the debugger is stopped in
@@ -1362,24 +1340,21 @@ do_dbupdown (const octave_value_list& ar
           std::string s_arg = arg.string_value ();
 
           n = atoi (s_arg.c_str ());
         }
       else
         n = args(0).int_value ();
     }
 
-  if (! error_state)
-    {
-      if (who == "dbup")
-        n = -n;
+  if (who == "dbup")
+    n = -n;
 
-      if (! octave_call_stack::goto_frame_relative (n, true))
-        error ("%s: invalid stack frame", who.c_str ());
-    }
+  if (! octave_call_stack::goto_frame_relative (n, true))
+    error ("%s: invalid stack frame", who.c_str ());
 }
 
 DEFUN (dbup, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbup\n\
 @deftypefnx {Command} {} dbup @var{n}\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 \n\
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -419,73 +419,64 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
     {
       direction = 0;
 
       std::string s_arg = args(2).string_value ();
 
-      if (! error_state)
-        {
-          if (s_arg == "first")
-            direction = 1;
-          else if (s_arg == "last")
-            direction = -1;
-        }
+      if (s_arg == "first")
+        direction = 1;
+      else if (s_arg == "last")
+        direction = -1;
 
       if (direction == 0)
         {
           error ("find: DIRECTION must be \"first\" or \"last\"");
           return retval;
         }
     }
 
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     {
       if (arg.is_sparse_type ())
         {
           SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout,
-                                            n_to_find, direction);
+          retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
           // matrix. Try to reuse the possibly cached index vector.
 
           // No need to catch index_exception, since arg is bool.
           // Out-of-range errors have already set pos, and will be
           // caught later.
 
           retval(0) = arg.index_vector ().unmask ();
         }
       else
         {
           boolNDArray v = arg.bool_array_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout,
-                                            n_to_find, direction);
+          retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
     }
   else if (arg.is_integer_type ())
     {
 #define DO_INT_BRANCH(INTT) \
       else if (arg.is_ ## INTT ## _type ()) \
         { \
           INTT ## NDArray v = arg.INTT ## _array_value (); \
-          \
-          if (! error_state) \
-            retval = find_nonzero_elem_idx (v, nargout, \
-                                            n_to_find, direction);\
+ \
+          retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction); \
         }
 
       if (false)
         ;
       DO_INT_BRANCH (int8)
       DO_INT_BRANCH (int16)
       DO_INT_BRANCH (int32)
       DO_INT_BRANCH (int64)
@@ -497,77 +488,65 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
         panic_impossible ();
     }
   else if (arg.is_sparse_type ())
     {
       if (arg.is_real_type ())
         {
           SparseMatrix v = arg.sparse_matrix_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout,
-                                            n_to_find, direction);
+          retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout,
-                                            n_to_find, direction);
+          retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else
         gripe_wrong_type_arg ("find", arg);
     }
   else if (arg.is_perm_matrix ())
     {
       PermMatrix P = arg.perm_matrix_value ();
 
-      if (! error_state)
-        retval = find_nonzero_elem_idx (P, nargout, n_to_find, direction);
+      retval = find_nonzero_elem_idx (P, nargout, n_to_find, direction);
     }
   else if (arg.is_string ())
     {
       charNDArray chnda = arg.char_array_value ();
 
-      if (! error_state)
-        retval = find_nonzero_elem_idx (chnda, nargout, n_to_find, direction);
+      retval = find_nonzero_elem_idx (chnda, nargout, n_to_find, direction);
     }
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (nda, nargout, n_to_find,
-                                            direction);
+          retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
-          if (! error_state)
-            retval = find_nonzero_elem_idx (cnda, nargout, n_to_find,
-                                            direction);
+          retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
         }
     }
   else if (arg.is_real_type ())
     {
       NDArray nda = arg.array_value ();
 
-      if (! error_state)
-        retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
+      retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
     }
   else if (arg.is_complex_type ())
     {
       ComplexNDArray cnda = arg.complex_array_value ();
 
-      if (! error_state)
-        retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
+      retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
     }
   else
     gripe_wrong_type_arg ("find", arg);
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -94,123 +94,97 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
           else if (s != "lower")
             error ("gammainc: third argument must be \"lower\" or \"upper\"");
         }
       else
         error ("gammainc: third argument must be \"lower\" or \"upper\"");
 
     }
 
-  if (!error_state && nargin >= 2  && nargin <= 3)
-    {
-      octave_value x_arg = args(0);
-      octave_value a_arg = args(1);
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
 
-      // FIXME: Can we make a template version of the duplicated code below
-      if (x_arg.is_single_type () || a_arg.is_single_type ())
-        {
-          if (x_arg.is_scalar_type ())
-            {
-              float x = x_arg.float_value ();
+  octave_value x_arg = args(0);
+  octave_value a_arg = args(1);
 
-              if (! error_state)
-                {
-                  if (a_arg.is_scalar_type ())
-                    {
-                      float a = a_arg.float_value ();
+  // FIXME: Can we make a template version of the duplicated code below
+  if (x_arg.is_single_type () || a_arg.is_single_type ())
+    {
+      if (x_arg.is_scalar_type ())
+        {
+          float x = x_arg.float_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a)
-                                       : 1.0f - gammainc (x, a);
-                    }
-                  else
-                    {
-                      FloatNDArray a = a_arg.float_array_value ();
+          if (a_arg.is_scalar_type ())
+            {
+              float a = a_arg.float_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a)
-                                       : 1.0f - gammainc (x, a);
-                    }
-                }
+              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
             }
           else
             {
-              FloatNDArray x = x_arg.float_array_value ();
-
-              if (! error_state)
-                {
-                  if (a_arg.is_scalar_type ())
-                    {
-                      float a = a_arg.float_value ();
+              FloatNDArray a = a_arg.float_array_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a)
-                                       : 1.0f - gammainc (x, a);
-                    }
-                  else
-                    {
-                      FloatNDArray a = a_arg.float_array_value ();
-
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a)
-                                       : 1.0f - gammainc (x, a);
-                    }
-                }
+              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
             }
         }
       else
         {
-          if (x_arg.is_scalar_type ())
-            {
-              double x = x_arg.double_value ();
-
-              if (! error_state)
-                {
-                  if (a_arg.is_scalar_type ())
-                    {
-                      double a = a_arg.double_value ();
+          FloatNDArray x = x_arg.float_array_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
-                    }
-                  else
-                    {
-                      NDArray a = a_arg.array_value ();
+          if (a_arg.is_scalar_type ())
+            {
+              float a = a_arg.float_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
-                    }
-                }
+              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
             }
           else
             {
-              NDArray x = x_arg.array_value ();
-
-              if (! error_state)
-                {
-                  if (a_arg.is_scalar_type ())
-                    {
-                      double a = a_arg.double_value ();
+              FloatNDArray a = a_arg.float_array_value ();
 
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
-                    }
-                  else
-                    {
-                      NDArray a = a_arg.array_value ();
-
-                      if (! error_state)
-                        retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
-                    }
-                }
+              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
             }
         }
     }
   else
-    print_usage ();
+    {
+      if (x_arg.is_scalar_type ())
+        {
+          double x = x_arg.double_value ();
+
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
+
+              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+            }
+          else
+            {
+              NDArray a = a_arg.array_value ();
+
+              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+            }
+        }
+      else
+        {
+          NDArray x = x_arg.array_value ();
+
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
+
+              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+            }
+          else
+            {
+              NDArray a = a_arg.array_value ();
+
+              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+            }
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! a = [.5 .5 .5 .5 .5];
 %! x = [0 1 2 3 4];
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -152,35 +152,31 @@ LU@tie{}factorization.  Once the matrix 
               if (args(0).is_complex_type ())
                 {
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp)
                     {
                       SparseComplexMatrix m =
                         args(0).sparse_complex_matrix_value ();
-                      if (!error_state)
-                        {
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
+
+                      mattyp = MatrixType (m);
+                      args(0).matrix_type (mattyp);
                     }
                 }
               else
                 {
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp)
                     {
                       SparseMatrix m = args(0).sparse_matrix_value ();
-                      if (!error_state)
-                        {
-                          mattyp = MatrixType (m);
-                          args(0).matrix_type (mattyp);
-                        }
+
+                      mattyp = MatrixType (m);
+                      args(0).matrix_type (mattyp);
                     }
                 }
 
               int typ = mattyp.type ();
 
               if (typ == MatrixType::Diagonal)
                 retval = octave_value ("Diagonal");
               else if (typ == MatrixType::Permuted_Diagonal)
@@ -275,64 +271,56 @@ LU@tie{}factorization.  Once the matrix 
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
                     error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
-                  if (! error_state)
+                  if (nargin == 3
+                      && (str_typ == "upper" || str_typ == "lower"))
                     {
-                      if (nargin == 3
-                          && (str_typ == "upper" || str_typ == "lower"))
+                      const ColumnVector perm =
+                        ColumnVector (args(2).vector_value ());
+
+                      if (error_state)
+                        error ("matrix_type: Invalid permutation vector PERM");
+                      else
                         {
-                          const ColumnVector perm =
-                            ColumnVector (args(2).vector_value ());
+                          octave_idx_type len = perm.numel ();
+                          dim_vector dv = args(0).dims ();
 
-                          if (error_state)
+                          if (len != dv(0))
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
-                              octave_idx_type len = perm.numel ();
-                              dim_vector dv = args(0).dims ();
+                              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                              if (len != dv(0))
-                                error ("matrix_type: Invalid permutation vector PERM");
-                              else
-                                {
-                                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                              for (octave_idx_type i = 0; i < len; i++)
+                                p[i] = static_cast<octave_idx_type>
+                                  (perm (i))
+                                  - 1;
 
-                                  for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type>
-                                           (perm (i))
-                                           - 1;
-
-                                  mattyp.mark_as_permuted (len, p);
-                                }
+                              mattyp.mark_as_permuted (len, p);
                             }
                         }
-                      else if (nargin != 2
-                               && str_typ != "banded positive definite"
-                               && str_typ != "banded")
-                        error ("matrix_type: Invalid number of arguments");
+                    }
+                  else if (nargin != 2
+                           && str_typ != "banded positive definite"
+                           && str_typ != "banded")
+                    error ("matrix_type: Invalid number of arguments");
 
-                      if (! error_state)
-                        {
-                          // Set the matrix type
-                          if (args(0).is_complex_type ())
-                            retval =
-                              octave_value (args(0).sparse_complex_matrix_value (),
-                                            mattyp);
-                          else
-                            retval
-                              = octave_value (args(0).sparse_matrix_value (),
-                                              mattyp);
-                        }
-                    }
+                  // Set the matrix type
+                  if (args(0).is_complex_type ())
+                    retval = octave_value (args(0).sparse_complex_matrix_value (),
+                                           mattyp);
+                  else
+                    retval = octave_value (args(0).sparse_matrix_value (),
+                                           mattyp);
                 }
             }
         }
       else
         {
           if (nargin == 1)
             {
               MatrixType mattyp;
@@ -342,56 +330,48 @@ LU@tie{}factorization.  Once the matrix 
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp)
                     {
                       if (args(0).is_single_type ())
                         {
                           FloatComplexMatrix m;
                           m = args(0).float_complex_matrix_value ();
-                          if (!error_state)
-                            {
-                              mattyp = MatrixType (m);
-                              args(0).matrix_type (mattyp);
-                            }
+
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
                         }
                       else
                         {
                           ComplexMatrix m = args(0).complex_matrix_value ();
-                          if (!error_state)
-                            {
-                              mattyp = MatrixType (m);
-                              args(0).matrix_type (mattyp);
-                            }
+
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
                         }
                     }
                 }
               else
                 {
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp)
                     {
                       if (args(0).is_single_type ())
                         {
                           FloatMatrix m = args(0).float_matrix_value ();
-                          if (!error_state)
-                            {
-                              mattyp = MatrixType (m);
-                              args(0).matrix_type (mattyp);
-                            }
+
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
                         }
                       else
                         {
                           Matrix m = args(0).matrix_value ();
-                          if (!error_state)
-                            {
-                              mattyp = MatrixType (m);
-                              args(0).matrix_type (mattyp);
-                            }
+
+                          mattyp = MatrixType (m);
+                          args(0).matrix_type (mattyp);
                         }
                     }
                 }
 
               int typ = mattyp.type ();
 
               if (typ == MatrixType::Upper)
                 retval = octave_value ("Upper");
@@ -445,75 +425,65 @@ LU@tie{}factorization.  Once the matrix 
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
                     error ("matrix_type: Unknown matrix type %s",
                            str_typ.c_str ());
 
-                  if (! error_state)
+                  if (nargin == 3 && (str_typ == "upper"
+                                      || str_typ == "lower"))
                     {
-                      if (nargin == 3 && (str_typ == "upper"
-                                          || str_typ == "lower"))
+                      const ColumnVector perm =
+                        ColumnVector (args(2).vector_value ());
+
+                      if (error_state)
+                        error ("matrix_type: Invalid permutation vector PERM");
+                      else
                         {
-                          const ColumnVector perm =
-                            ColumnVector (args(2).vector_value ());
+                          octave_idx_type len = perm.numel ();
+                          dim_vector dv = args(0).dims ();
 
-                          if (error_state)
+                          if (len != dv(0))
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
-                              octave_idx_type len = perm.numel ();
-                              dim_vector dv = args(0).dims ();
+                              OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                              if (len != dv(0))
-                                error ("matrix_type: Invalid permutation vector PERM");
-                              else
-                                {
-                                  OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                              for (octave_idx_type i = 0; i < len; i++)
+                                p[i] = static_cast<octave_idx_type>
+                                  (perm (i))
+                                  - 1;
 
-                                  for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type>
-                                           (perm (i))
-                                           - 1;
-
-                                  mattyp.mark_as_permuted (len, p);
-                                }
+                              mattyp.mark_as_permuted (len, p);
                             }
                         }
-                      else if (nargin != 2)
-                        error ("matrix_type: Invalid number of arguments");
+                    }
+                  else if (nargin != 2)
+                    error ("matrix_type: Invalid number of arguments");
 
-                      if (! error_state)
-                        {
-                          // Set the matrix type
-                          if (args(0).is_single_type ())
-                            {
-                              if (args(0).is_complex_type ())
-                                retval = octave_value
-                                         (args(0).float_complex_matrix_value (),
-                                          mattyp);
-                              else
-                                retval = octave_value
-                                         (args(0).float_matrix_value (),
-                                          mattyp);
-                            }
-                          else
-                            {
-                              if (args(0).is_complex_type ())
-                                retval = octave_value
-                                         (args(0).complex_matrix_value (),
-                                          mattyp);
-                              else
-                                retval = octave_value
-                                         (args(0).matrix_value (),
-                                          mattyp);
-                            }
-                        }
+                  // Set the matrix type
+                  if (args(0).is_single_type ())
+                    {
+                      if (args(0).is_complex_type ())
+                        retval = octave_value (args(0).float_complex_matrix_value (),
+                                               mattyp);
+                      else
+                        retval = octave_value (args(0).float_matrix_value (),
+                                               mattyp);
+                    }
+                  else
+                    {
+                      if (args(0).is_complex_type ())
+                        retval = octave_value (args(0).complex_matrix_value (),
+                                               mattyp);
+                      else
+                        retval = octave_value (args(0).matrix_value (),
+                                               mattyp);
                     }
                 }
             }
         }
     }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -125,53 +125,50 @@ octave_user_script::subsref (const std::
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
                                        const octave_value_list& args)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  if (! error_state)
+  if (args.length () == 0 && nargout == 0)
     {
-      if (args.length () == 0 && nargout == 0)
+      if (cmd_list)
         {
-          if (cmd_list)
-            {
-              frame.protect_var (call_depth);
-              call_depth++;
+          frame.protect_var (call_depth);
+          call_depth++;
 
-              if (call_depth < Vmax_recursion_depth)
-                {
-                  octave_call_stack::push (this);
+          if (call_depth < Vmax_recursion_depth)
+            {
+              octave_call_stack::push (this);
 
-                  frame.add_fcn (octave_call_stack::pop);
+              frame.add_fcn (octave_call_stack::pop);
 
-                  frame.protect_var (tree_evaluator::statement_context);
-                  tree_evaluator::statement_context = tree_evaluator::script;
+              frame.protect_var (tree_evaluator::statement_context);
+              tree_evaluator::statement_context = tree_evaluator::script;
 
-                  BEGIN_PROFILER_BLOCK (octave_user_script)
+              BEGIN_PROFILER_BLOCK (octave_user_script)
 
-                  cmd_list->accept (*current_evaluator);
+                cmd_list->accept (*current_evaluator);
 
-                  END_PROFILER_BLOCK
+              END_PROFILER_BLOCK
 
-                  if (tree_return_command::returning)
-                    tree_return_command::returning = 0;
+                if (tree_return_command::returning)
+                  tree_return_command::returning = 0;
 
-                  if (tree_break_command::breaking)
-                    tree_break_command::breaking--;
-                }
-              else
-                error ("max_recursion_depth exceeded");
+              if (tree_break_command::breaking)
+                tree_break_command::breaking--;
             }
+          else
+            error ("max_recursion_depth exceeded");
         }
-      else
-        error ("invalid call to script %s", file_name.c_str ());
     }
+  else
+    error ("invalid call to script %s", file_name.c_str ());
 
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
@@ -471,19 +468,16 @@ octave_user_function::do_multi_index_op 
 
 octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
                                          const octave_value_list& _args,
                                          const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   if (! cmd_list)
     return retval;
 
   // If this function is a classdef constructor, extract the first input
   // argument, which must be the partially constructed object instance.
 
   octave_value_list args (_args);
   octave_value_list ret_args;
@@ -531,33 +525,25 @@ octave_user_function::do_multi_index_op 
       symbol_table::push_context ();
 
       frame.add_fcn (symbol_table::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
-    {
-      param_list->define_from_arg_vector (args);
-      if (error_state)
-        return retval;
-    }
+    param_list->define_from_arg_vector (args);
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
     {
       if (ret_list)
-        {
-          ret_list->define_from_arg_vector (ret_args);
-          if (error_state)
-            return retval;
-        }
+        ret_list->define_from_arg_vector (ret_args);
       else
         {
           error ("%s: invalid classdef constructor, no output argument defined",
                  dispatch_class ().c_str ());
           return retval;
         }
     }
 
@@ -631,19 +617,16 @@ octave_user_function::do_multi_index_op 
     print_code_function_trailer ();
 
   if (tree_return_command::returning)
     tree_return_command::returning = 0;
 
   if (tree_break_command::breaking)
     tree_break_command::breaking--;
 
-  if (error_state)
-    return retval;
-
   // Copy return values out.
 
   if (ret_list && ! is_special_expr ())
     {
       ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
       Cell varargout;
 
@@ -655,18 +638,17 @@ octave_user_function::do_multi_index_op 
             {
               varargout = varargout_varval.cell_value ();
 
               if (error_state)
                 error ("expecting varargout to be a cell array object");
             }
         }
 
-      if (! error_state)
-        retval = ret_list->convert_to_const_vector (nargout, varargout);
+      retval = ret_list->convert_to_const_vector (nargout, varargout);
     }
 
   return retval;
 }
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
@@ -798,21 +780,18 @@ octave_user_function::bind_automatic_var
 
 void
 octave_user_function::restore_warning_states (void)
 {
   octave_value val = symbol_table::varval (".saved_warning_states.");
 
   if (val.is_defined ())
     {
-      // Don't use the usual approach of attempting to extract a value
-      // and then checking error_state since this code might be
-      // executing when error_state is already set.  But do fail
-      // spectacularly if .saved_warning_states. is not an octave_map
-      // (or octave_scalar_map) object.
+      // Fail spectacularly if .saved_warning_states. is not an
+      // octave_map (or octave_scalar_map) object.
 
       if (! val.is_map ())
         panic_impossible ();
 
       octave_map m = val.map_value ();
 
       Cell ids = m.contents ("identifier");
       Cell states = m.contents ("state");
@@ -1118,32 +1097,30 @@ element-by-element and a logical array i
           Matrix ignored;
           octave_value tmp = symbol_table::varval (".ignored.");
           if (tmp.is_defined ())
             ignored = tmp.matrix_value ();
 
           if (args(0).is_scalar_type ())
             {
               double k = args(0).double_value ();
-              if (! error_state)
-                retval = isargout1 (nargout1, ignored, k);
+
+              retval = isargout1 (nargout1, ignored, k);
             }
           else if (args(0).is_numeric_type ())
             {
               const NDArray ka = args(0).array_value ();
-              if (! error_state)
-                {
-                  boolNDArray r (ka.dims ());
-                  for (octave_idx_type i = 0;
-                       i < ka.numel () && ! error_state;
-                       i++)
-                    r(i) = isargout1 (nargout1, ignored, ka(i));
 
-                  retval = r;
-                }
+              boolNDArray r (ka.dims ());
+              for (octave_idx_type i = 0;
+                   i < ka.numel () && ! error_state;
+                   i++)
+                r(i) = isargout1 (nargout1, ignored, ka(i));
+
+              retval = r;
             }
           else
             gripe_wrong_type_arg ("isargout", args(0));
         }
       else
         error ("isargout: invalid call at top level");
     }
   else
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -72,88 +72,75 @@ tree_simple_assignment::rvalue (int narg
   return retval;
 }
 
 octave_value
 tree_simple_assignment::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   if (rhs)
     {
       octave_value rhs_val = rhs->rvalue1 ();
 
-      if (! error_state)
+      if (rhs_val.is_undefined ())
         {
-          if (rhs_val.is_undefined ())
+          error ("value on right hand side of assignment is undefined");
+          return retval;
+        }
+      else
+        {
+          if (rhs_val.is_cs_list ())
             {
-              error ("value on right hand side of assignment is undefined");
-              return retval;
-            }
-          else
-            {
-              if (rhs_val.is_cs_list ())
-                {
-                  const octave_value_list lst = rhs_val.list_value ();
+              const octave_value_list lst = rhs_val.list_value ();
 
-                  if (! lst.empty ())
-                    rhs_val = lst(0);
-                  else
-                    {
-                      error ("invalid number of elements on RHS of assignment");
-                      return retval;
-                    }
+              if (! lst.empty ())
+                rhs_val = lst(0);
+              else
+                {
+                  error ("invalid number of elements on RHS of assignment");
+                  return retval;
                 }
+            }
 
-              try
-                {
-                  octave_lvalue ult = lhs->lvalue ();
+          try
+            {
+              octave_lvalue ult = lhs->lvalue ();
 
-                  if (ult.numel () != 1)
-                    gripe_nonbraced_cs_list_assignment ();
-
-                  if (! error_state)
-                    {
-                      ult.assign (etype, rhs_val);
+              if (ult.numel () != 1)
+                gripe_nonbraced_cs_list_assignment ();
 
-                      if (! error_state)
-                        {
-                          if (etype == octave_value::op_asn_eq)
-                            retval = rhs_val;
-                          else
-                            retval = ult.value ();
+              ult.assign (etype, rhs_val);
 
-                          if (print_result ()
-                              && tree_evaluator::statement_printing_enabled ())
-                            {
-                              // We clear any index here so that we can
-                              // get the new value of the referenced
-                              // object below, instead of the indexed
-                              // value (which should be the same as the
-                              // right hand side value).
+              if (etype == octave_value::op_asn_eq)
+                retval = rhs_val;
+              else
+                retval = ult.value ();
 
-                              ult.clear_index ();
+              if (print_result ()
+                  && tree_evaluator::statement_printing_enabled ())
+                {
+                  // We clear any index here so that we can
+                  // get the new value of the referenced
+                  // object below, instead of the indexed
+                  // value (which should be the same as the
+                  // right hand side value).
 
-                              octave_value lhs_val = ult.value ();
+                  ult.clear_index ();
 
-                              if (! error_state)
-                                lhs_val.print_with_name (octave_stdout,
-                                                         lhs->name ());
-                            }
-                        }
-                    }
+                  octave_value lhs_val = ult.value ();
+
+                  lhs_val.print_with_name (octave_stdout,
+                                           lhs->name ());
                 }
-              catch (index_exception& e)
-                {       // problems with range, invalid index type etc.
-                  e.set_var (lhs->name ());
-                  (*current_liboctave_error_with_id_handler) (e.id(), e.err());
-                }
+            }
+          catch (index_exception& e)
+            {       // problems with range, invalid index type etc.
+              e.set_var (lhs->name ());
+              (*current_liboctave_error_with_id_handler) (e.id(), e.err());
             }
         }
     }
 
   return retval;
 }
 
 std::string
@@ -214,43 +201,34 @@ tree_multi_assignment::rvalue1 (int narg
 // FIXME: this works, but it would look a little better if
 // it were broken up into a couple of separate functions.
 
 octave_value_list
 tree_multi_assignment::rvalue (int)
 {
   octave_value_list retval;
 
-  if (error_state)
-    return retval;
-
   if (rhs)
     {
       std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
 
-      if (error_state)
-        return retval;
-
       octave_idx_type n_out = 0;
 
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list.begin ();
            p != lvalue_list.end ();
            p++)
         n_out += p->numel ();
 
       // The following trick is used to keep rhs_val constant.
       const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
       const octave_value_list rhs_val = (rhs_val1.length () == 1
                                          && rhs_val1(0).is_cs_list ()
                                          ? rhs_val1(0).list_value ()
                                          : rhs_val1);
 
-      if (error_state)
-        return retval;
-
       octave_idx_type k = 0;
 
       octave_idx_type n = rhs_val.length ();
 
       // To avoid copying per elements and possible optimizations, we
       // postpone joining the final values.
       std::list<octave_value_list> retval_list;
 
@@ -298,38 +276,35 @@ tree_multi_assignment::rvalue (int)
               if (k + nel <= n)
                 {
                   // This won't do a copy.
                   octave_value_list ovl  = rhs_val.slice (k, nel);
 
                   ult.assign (octave_value::op_asn_eq,
                               octave_value (ovl, true));
 
-                  if (! error_state)
-                    {
-                      retval_list.push_back (ovl);
+                  retval_list.push_back (ovl);
 
-                      k += nel;
-                    }
+                  k += nel;
                 }
               else
                 error ("some elements undefined in return list");
             }
           else
             {
               if (k < n)
                 {
                   ult.assign (octave_value::op_asn_eq, rhs_val(k));
 
                   if (ult.is_black_hole ())
                     {
                       k++;
                       continue;
                     }
-                  else if (! error_state)
+                  else
                     {
                       retval_list.push_back (rhs_val(k));
 
                       k++;
                     }
                 }
               else
                 {
@@ -353,43 +328,34 @@ tree_multi_assignment::rvalue (int)
                       k++;
                       continue;
                     }
                   else
                     error ("element number %d undefined in return list", k+1);
                 }
             }
 
-          if (error_state)
-            break;
-          else if (print_result ()
-                   && tree_evaluator::statement_printing_enabled ())
+          if (print_result ()
+              && tree_evaluator::statement_printing_enabled ())
             {
               // We clear any index here so that we can get
               // the new value of the referenced object below,
               // instead of the indexed value (which should be
               // the same as the right hand side value).
 
               ult.clear_index ();
 
               octave_value lhs_val = ult.value ();
 
-              if (! error_state)
-                lhs_val.print_with_name (octave_stdout,
-                                         lhs_elt->name ());
+              lhs_val.print_with_name (octave_stdout, lhs_elt->name ());
             }
-
-          if (error_state)
-            break;
-
         }
 
       // Concatenate return values.
       retval = retval_list;
-
     }
 
   return retval;
 }
 
 /*
 %!function varargout = f ()
 %!  varargout{1} = nargout;
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -64,95 +64,81 @@ tree_binary_expression::matlab_style_sho
   braindead_shortcircuit_warning_issued = true;
 }
 
 octave_value
 tree_binary_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   if (Vdo_braindead_shortcircuit_evaluation
       && eligible_for_braindead_shortcircuit)
     {
       if (op_lhs)
         {
           octave_value a = op_lhs->rvalue1 ();
 
-          if (! error_state)
+          if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
             {
-              if (a.ndims () == 2 && a.rows () == 1 && a.columns () == 1)
+              bool result = false;
+
+              bool a_true = a.is_true ();
+
+              if (a_true)
                 {
-                  bool result = false;
-
-                  bool a_true = a.is_true ();
-
-                  if (! error_state)
+                  if (etype == octave_value::op_el_or)
                     {
-                      if (a_true)
-                        {
-                          if (etype == octave_value::op_el_or)
-                            {
-                              matlab_style_short_circuit_warning ("|");
-                              result = true;
-                              goto done;
-                            }
-                        }
-                      else
-                        {
-                          if (etype == octave_value::op_el_and)
-                            {
-                              matlab_style_short_circuit_warning ("&");
-                              goto done;
-                            }
-                        }
-
-                      if (op_rhs)
-                        {
-                          octave_value b = op_rhs->rvalue1 ();
-
-                          if (! error_state)
-                            result = b.is_true ();
-                        }
-
-                    done:
-
-                      if (! error_state)
-                        return octave_value (result);
+                      matlab_style_short_circuit_warning ("|");
+                      result = true;
+                      goto done;
                     }
                 }
+              else
+                {
+                  if (etype == octave_value::op_el_and)
+                    {
+                      matlab_style_short_circuit_warning ("&");
+                      goto done;
+                    }
+                }
+
+              if (op_rhs)
+                {
+                  octave_value b = op_rhs->rvalue1 ();
+
+                  result = b.is_true ();
+                }
+
+            done:
+
+              return octave_value (result);
             }
         }
     }
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
-      if (! error_state && a.is_defined () && op_rhs)
+      if (a.is_defined () && op_rhs)
         {
           octave_value b = op_rhs->rvalue1 ();
 
-          if (! error_state && b.is_defined ())
+          if (b.is_defined ())
             {
               BEGIN_PROFILER_BLOCK (tree_binary_expression)
 
               // Note: The profiler does not catch the braindead
               // short-circuit evaluation code above, but that should be
               // ok. The evaluation of operands and the operator itself
               // is entangled and it's not clear where to start/stop
               // timing the operator to make it reasonable.
 
               retval = ::do_binary_op (etype, a, b);
 
-              if (error_state)
-                retval = octave_value ();
-
               END_PROFILER_BLOCK
             }
         }
     }
 
   return retval;
 }
 
@@ -198,64 +184,53 @@ tree_boolean_expression::rvalue (int nar
   return retval;
 }
 
 octave_value
 tree_boolean_expression::rvalue1 (int)
 {
   octave_value retval;
 
-  if (error_state)
-    return retval;
-
   bool result = false;
 
   // This evaluation is not caught by the profiler, since we can't find
   // a reasonable place where to time. Note that we don't want to
   // include evaluation of LHS or RHS into the timing, but this is
   // entangled together with short-circuit evaluation here.
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue1 ();
 
-      if (! error_state)
+      bool a_true = a.is_true ();
+
+      if (a_true)
         {
-          bool a_true = a.is_true ();
-
-          if (! error_state)
+          if (etype == bool_or)
             {
-              if (a_true)
-                {
-                  if (etype == bool_or)
-                    {
-                      result = true;
-                      goto done;
-                    }
-                }
-              else
-                {
-                  if (etype == bool_and)
-                    goto done;
-                }
-
-              if (op_rhs)
-                {
-                  octave_value b = op_rhs->rvalue1 ();
-
-                  if (! error_state)
-                    result = b.is_true ();
-                }
-
-            done:
-
-              if (! error_state)
-                retval = octave_value (result);
+              result = true;
+              goto done;
             }
         }
+      else
+        {
+          if (etype == bool_and)
+            goto done;
+        }
+
+      if (op_rhs)
+        {
+          octave_value b = op_rhs->rvalue1 ();
+
+          result = b.is_true ();
+        }
+
+    done:
+
+      retval = octave_value (result);
     }
 
   return retval;
 }
 
 std::string
 tree_boolean_expression::oper (void) const
 {
