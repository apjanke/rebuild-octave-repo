# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453170486 28800
#      Mon Jan 18 18:28:06 2016 -0800
# Node ID e39e05d907885bb5089420d426ded73afbe8859c
# Parent  52af4092f863674c86ae796baf1066625379fd83
Switch gripe_XXX to either err_XXX or warn_XXX naming scheme.

* libinterp/corefcn/errwarn.h, libinterp/corefcn/errwarn.cc: New header and .cc
file with common errors and warnings for libinterp.

* libinterp/corefcn/module.mk: Add errwarn.h, errwarn.cc to build system.

* liboctave/util/lo-array-errwarn.h, liboctave/util/lo-array-errwarn.cc: New
header and .cc file with common errors and warnings for liboctave.

* liboctave/util/module.mk: Add lo-array-errwarn.h, lo-array-errwarn.cc to
build system.

* lo-array-gripes.h: #include "lo-array-errwarn.h" for access to class
index_exception.  Remove const char *error_id_XXX prototypes.

* lo-array-gripes.cc: Remove const char *error_id_XXX initializations.
Remove index_exception method definitions.



* Cell.cc, __pchip_deriv__.cc, __qp__.cc, balance.cc, betainc.cc, cellfun.cc,
daspk.cc, dasrt.cc, dassl.cc, data.cc, debug.cc, defaults.cc, det.cc,
dirfns.cc, eig.cc, fft.cc, fft2.cc, fftn.cc, find.cc, gammainc.cc, gcd.cc,
getgrent.cc, getpwent.cc, graphics.in.h, help.cc, hess.cc, hex2num.cc,
input.cc, inv.cc, jit-typeinfo.cc, load-save.cc, lookup.cc, ls-hdf5.cc,
ls-mat-ascii.cc, ls-mat4.cc, ls-mat5.cc, ls-oct-binary.cc, ls-oct-text.cc,
lsode.cc, lu.cc, luinc.cc, max.cc, mgorth.cc, oct-hist.cc, oct-procbuf.cc,
oct-stream.cc, oct.h, pager.cc, pinv.cc, pr-output.cc, quad.cc, qz.cc, rand.cc,
rcond.cc, regexp.cc, schur.cc, sparse-xdiv.cc, sparse-xpow.cc, sparse.cc,
spparms.cc, sqrtm.cc, str2double.cc, strfind.cc, strfns.cc, sub2ind.cc, svd.cc,
sylvester.cc, syscalls.cc, typecast.cc, utils.cc, variables.cc, xdiv.cc,
xnorm.cc, xpow.cc, __eigs__.cc, __glpk__.cc, __magick_read__.cc,
__osmesa_print__.cc, audiodevinfo.cc, audioread.cc, chol.cc, dmperm.cc,
fftw.cc, qr.cc, symbfact.cc, symrcm.cc, ov-base-diag.cc, ov-base-int.cc,
ov-base-mat.cc, ov-base-scalar.cc, ov-base-sparse.cc, ov-base.cc,
ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc, ov-builtin.cc, ov-cell.cc,
ov-ch-mat.cc, ov-class.cc, ov-complex.cc, ov-complex.h, ov-cs-list.cc,
ov-cx-diag.cc, ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-float.cc, ov-float.h, ov-flt-complex.cc, ov-flt-complex.h,
ov-flt-cx-diag.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-int16.cc,
ov-int32.cc, ov-int64.cc, ov-int8.cc, ov-intx.h, ov-mex-fcn.cc, ov-perm.cc,
ov-range.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-scalar.h,
ov-str-mat.cc, ov-struct.cc, ov-type-conv.h, ov-uint16.cc, ov-uint32.cc,
ov-uint64.cc, ov-uint8.cc, ov-usr-fcn.cc, ov.cc, op-b-b.cc, op-b-bm.cc,
op-b-sbm.cc, op-bm-b.cc, op-bm-bm.cc, op-bm-sbm.cc, op-cdm-cdm.cc, op-cell.cc,
op-chm.cc, op-class.cc, op-cm-cm.cc, op-cm-cs.cc, op-cm-m.cc, op-cm-s.cc,
op-cm-scm.cc, op-cm-sm.cc, op-cs-cm.cc, op-cs-cs.cc, op-cs-m.cc, op-cs-s.cc,
op-cs-scm.cc, op-cs-sm.cc, op-dm-dm.cc, op-dm-scm.cc, op-dm-sm.cc,
op-dms-template.cc, op-double-conv.cc, op-fcdm-fcdm.cc, op-fcdm-fdm.cc,
op-fcm-fcm.cc, op-fcm-fcs.cc, op-fcm-fm.cc, op-fcm-fs.cc, op-fcn.cc,
op-fcs-fcm.cc, op-fcs-fcs.cc, op-fcs-fm.cc, op-fcs-fs.cc, op-fdm-fdm.cc,
op-float-conv.cc, op-fm-fcm.cc, op-fm-fcs.cc, op-fm-fm.cc, op-fm-fs.cc,
op-fs-fcm.cc, op-fs-fcs.cc, op-fs-fm.cc, op-fs-fs.cc, op-i16-i16.cc,
op-i32-i32.cc, op-i64-i64.cc, op-i8-i8.cc, op-int-concat.cc, op-int-conv.cc,
op-int.h, op-m-cm.cc, op-m-cs.cc, op-m-m.cc, op-m-s.cc, op-m-scm.cc,
op-m-sm.cc, op-pm-pm.cc, op-pm-scm.cc, op-pm-sm.cc, op-range.cc, op-s-cm.cc,
op-s-cs.cc, op-s-m.cc, op-s-s.cc, op-s-scm.cc, op-s-sm.cc, op-sbm-b.cc,
op-sbm-bm.cc, op-sbm-sbm.cc, op-scm-cm.cc, op-scm-cs.cc, op-scm-m.cc,
op-scm-s.cc, op-scm-scm.cc, op-scm-sm.cc, op-sm-cm.cc, op-sm-cs.cc, op-sm-m.cc,
op-sm-s.cc, op-sm-scm.cc, op-sm-sm.cc, op-str-m.cc, op-str-s.cc, op-str-str.cc,
op-struct.cc, op-ui16-ui16.cc, op-ui32-ui32.cc, op-ui64-ui64.cc, op-ui8-ui8.cc,
ops.h, lex.ll, pt-assign.cc, pt-eval.cc, pt-idx.cc, pt-loop.cc, pt-mat.cc,
pt-stmt.cc, Array-util.cc, Array-util.h, Array.cc, CColVector.cc,
CDiagMatrix.cc, CMatrix.cc, CNDArray.cc, CRowVector.cc, CSparse.cc,
DiagArray2.cc, MDiagArray2.cc, MSparse.cc, PermMatrix.cc, Range.cc, Sparse.cc,
dColVector.cc, dDiagMatrix.cc, dMatrix.cc, dNDArray.cc, dRowVector.cc,
dSparse.cc, fCColVector.cc, fCDiagMatrix.cc, fCMatrix.cc, fCNDArray.cc,
fCRowVector.cc, fColVector.cc, fDiagMatrix.cc, fMatrix.cc, fNDArray.cc,
fRowVector.cc, idx-vector.cc, CmplxGEPBAL.cc, dbleGEPBAL.cc, fCmplxGEPBAL.cc,
floatGEPBAL.cc, Sparse-diag-op-defs.h, Sparse-op-defs.h, Sparse-perm-op-defs.h,
mx-inlines.cc, mx-op-defs.h, oct-binmap.h:
Replace 'include "gripes.h"' with 'include "errwarn.h".  Change all gripe_XXX
to err_XXX or warn_XXX or errwarn_XXX.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "idx-vector.h"
 
 #include "Cell.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 
 Cell::Cell (const octave_value_list& ovl)
   : Array<octave_value> (ovl.cell_value ())
 {
 }
 
 Cell::Cell (const string_vector& sv, bool trim)
@@ -270,17 +270,17 @@ Cell::delete_elements (const octave_valu
         }
 
   Array<octave_value>::delete_elements (ra_idx);
 }
 
 octave_idx_type
 Cell::nnz (void) const
 {
-  gripe_wrong_type_arg ("nnz", "cell array");
+  err_wrong_type_arg ("nnz", "cell array");
   return -1;
 }
 
 /*
 %!error <wrong type argument 'cell array'> nnz ({0, 1, 2})
 %!error <wrong type argument 'cell array'> nnz (cell ())
 %!error <wrong type argument 'cell array'> nnz ({"foo", "bar"})
 */
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dpchim, DPCHIM) (const octave_idx_type& n, const double *x,
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "dbleCHOL.h"
 #include "dbleSVD.h"
 #include "mx-m-dm.h"
 #include "EIG.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "pr-output.h"
 #include "utils.h"
 
 static Matrix
 null (const Matrix& A, octave_idx_type& rank)
 {
   Matrix retval;
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "fCmplxGEPBAL.h"
 #include "dbleGEPBAL.h"
 #include "floatGEPBAL.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "f77-fcn.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (balance, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{AA} =} balance (@var{A})\n\
 @deftypefnx {} {@var{AA} =} balance (@var{A}, @var{opt})\n\
 @deftypefnx {} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
@@ -100,17 +100,17 @@ Generalized eigenvalue problem balancing
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
-    gripe_square_matrix_required ("balance");
+    err_square_matrix_required ("balance");
 
   bool isfloat = args(0).is_single_type ()
                  || (! AEPcase && args(1).is_single_type ());
 
   bool complex_case = args(0).is_complex_type ()
                       || (! AEPcase && args(1).is_complex_type ());
 
   // Extract argument 1 parameter for both AEP and GEP.
@@ -219,17 +219,17 @@ Generalized eigenvalue problem balancing
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
         bal_job = "B";
       else
         bal_job = args(2).xstring_value ("balance: OPT argument must be a string");
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
-        gripe_nonconformant ();
+        err_nonconformant ();
 
       Matrix bb;
       ComplexMatrix cbb;
       FloatMatrix fbb;
       FloatComplexMatrix fcbb;
 
       if (isfloat)
         {
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 
 DEFUN (betainc, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Compute the regularized incomplete Beta function.\n\
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun.h"
 #include "parse.h"
 #include "variables.h"
 #include "unwind-prot.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "toplev.h"
 #include "utils.h"
 
 #include "ov-bool.h"
 #include "ov-class.h"
 #include "ov-colon.h"
 #include "ov-complex.h"
 #include "ov-float.h"
@@ -1826,17 +1826,17 @@ num2cell ([1,2;3,4],1)\n\
     }
   else if (array.is_object ())
     retval = do_object2cell (array, dimv);
   else if (array.is_map ())
     retval = do_num2cell (array.map_value (), dimv);
   else if (array.is_cell ())
     retval = do_num2cell (array.cell_value (), dimv);
   else
-    gripe_wrong_type_arg ("num2cell", array);
+    err_wrong_type_arg ("num2cell", array);
 
   return retval;
 }
 
 /*
 %!assert (num2cell ([1,2;3,4]), {1,2;3,4})
 %!assert (num2cell ([1,2;3,4], 1), {[1;3],[2;4]})
 %!assert (num2cell ([1,2;3,4], 2), {[1,2];[3,4]})
@@ -2160,17 +2160,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
       BTYP_BRANCH (uint64, uint64_array);
 
       BTYP_BRANCH (cell, cell);
       BTYP_BRANCH (struct, map);
 
 #undef BTYP_BRANCH
 
     case btyp_func_handle:
-      gripe_wrong_type_arg ("mat2cell", a);
+      err_wrong_type_arg ("mat2cell", a);
       break;
 
     default:
       retval = do_mat2cell (a, d, nargin-1);
       break;
     }
 
   return retval;
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASPK.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -76,17 +76,17 @@ daspk_user_function (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "daspk");
+          err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied function");
@@ -94,20 +94,20 @@ daspk_user_function (const ColumnVector&
             }
 
           retval = tmp(0).vector_value ();
 
           if (tlen > 1)
             ires = tmp(1).idx_type_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("daspk");
+            err_user_supplied_eval ("daspk");
         }
       else
-        gripe_user_supplied_eval ("daspk");
+        err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 Matrix
 daspk_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
                      double t, double cj)
@@ -128,35 +128,35 @@ daspk_user_jacobian (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "daspk");
+          err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("daspk");
+            err_user_supplied_eval ("daspk");
         }
       else
-        gripe_user_supplied_eval ("daspk");
+        err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 DEFUN (daspk, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <string>
 
 #include "DASRT.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
@@ -76,34 +76,34 @@ dasrt_user_f (const ColumnVector& x, con
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_f->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "dasrt");
+          err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
           retval = tmp(0).vector_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("dasrt");
+            err_user_supplied_eval ("dasrt");
         }
       else
-        gripe_user_supplied_eval ("dasrt");
+        err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static ColumnVector
 dasrt_user_cf (const ColumnVector& x, double t)
 {
@@ -119,34 +119,34 @@ dasrt_user_cf (const ColumnVector& x, do
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_cf->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "dasrt");
+          err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_cf_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
               warned_cf_imaginary = true;
             }
 
           retval = tmp(0).vector_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("dasrt");
+            err_user_supplied_eval ("dasrt");
         }
       else
-        gripe_user_supplied_eval ("dasrt");
+        err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static Matrix
 dasrt_user_j (const ColumnVector& x, const ColumnVector& xdot,
               double t, double cj)
@@ -167,35 +167,35 @@ dasrt_user_j (const ColumnVector& x, con
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_j->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "dasrt");
+          err_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("dasrt");
+            err_user_supplied_eval ("dasrt");
         }
       else
-        gripe_user_supplied_eval ("dasrt");
+        err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 DEFUN (dasrt, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASSL.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -76,17 +76,17 @@ dassl_user_function (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "dassl");
+          err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied function");
@@ -94,20 +94,20 @@ dassl_user_function (const ColumnVector&
             }
 
           retval = tmp(0).vector_value ();
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("dassl");
+            err_user_supplied_eval ("dassl");
         }
       else
-        gripe_user_supplied_eval ("dassl");
+        err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 Matrix
 dassl_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
                      double t, double cj)
@@ -128,35 +128,35 @@ dassl_user_jacobian (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "dassl");
+          err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("dassl");
+            err_user_supplied_eval ("dassl");
         }
       else
-        gripe_user_supplied_eval ("dassl");
+        err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 DEFUN (dassl, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 #include "quit.h"
 #include "mx-base.h"
 #include "oct-binmap.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-class.h"
 #include "ov-float.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
@@ -224,20 +224,20 @@ and @var{x}.\n\
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
-    gripe_wrong_type_arg ("atan2", args(0));
+    err_wrong_type_arg ("atan2", args(0));
 
   if (! args(1).is_numeric_type ())
-    gripe_wrong_type_arg ("atan2", args(1));
+    err_wrong_type_arg ("atan2", args(1));
 
   if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("atan2: not defined for complex numbers");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = atan2f (args(0).float_value (), args(1).float_value ());
@@ -334,19 +334,19 @@ and @var{x}.\n\
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
   octave_value arg0 = x;
   octave_value arg1 = y;
   if (! arg0.is_numeric_type ())
-    gripe_wrong_type_arg ("hypot", arg0);
+    err_wrong_type_arg ("hypot", arg0);
   else if (! arg1.is_numeric_type ())
-    gripe_wrong_type_arg ("hypot", arg1);
+    err_wrong_type_arg ("hypot", arg1);
   else
     {
       if (arg0.is_complex_type ())
         arg0 = arg0.abs ();
       if (arg1.is_complex_type ())
         arg1 = arg1.abs ();
 
       if (arg0.is_single_type () || arg1.is_single_type ())
@@ -543,17 +543,17 @@ and @var{e} is an integer.  If\n\
       ComplexNDArray f;
       ComplexNDArray x = args(0).complex_array_value ();
       // FIXME: should E be an int value?
       NDArray e;
       map_2_xlog2 (x, f, e);
       retval = ovl (f, e);
     }
   else
-    gripe_wrong_type_arg ("log2", args(0));
+    err_wrong_type_arg ("log2", args(0));
 
   return retval;
 }
 
 /*
 %!assert (log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2])
 %!assert (log2 (Inf), Inf)
 %!assert (isnan (log2 (NaN)))
@@ -610,20 +610,20 @@ periodic, @code{mod} is a better choice.
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
-    gripe_wrong_type_arg ("rem", args(0));
+    err_wrong_type_arg ("rem", args(0));
 
   if (! args(1).is_numeric_type ())
-    gripe_wrong_type_arg ("rem", args(1));
+    err_wrong_type_arg ("rem", args(1));
 
   if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rem: not defined for complex numbers");
 
   if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
@@ -791,20 +791,20 @@ negative numbers or when the values are 
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
-    gripe_wrong_type_arg ("mod", args(0));
+    err_wrong_type_arg ("mod", args(0));
 
   if (! args(1).is_numeric_type ())
-    gripe_wrong_type_arg ("mod", args(1));
+    err_wrong_type_arg ("mod", args(1));
 
   if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("mod: not defined for complex numbers");
 
   if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
@@ -1034,17 +1034,17 @@ negative numbers or when the values are 
           else if (arg.is_real_type ()) \
             { \
               NDArray tmp = arg.array_value (); \
 \
               retval = tmp.FCN (dim); \
             } \
           else \
             { \
-              gripe_wrong_type_arg (#FCN, arg); \
+              err_wrong_type_arg (#FCN, arg); \
               return retval; \
             } \
         } \
       else if (arg.is_bool_type ()) \
         { \
           boolNDArray tmp = arg.bool_array_value (); \
 \
           retval = tmp.FCN (dim); \
@@ -1074,17 +1074,17 @@ negative numbers or when the values are 
       else if (arg.is_complex_type ()) \
         { \
           ComplexNDArray tmp = arg.complex_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
       else \
         { \
-          gripe_wrong_type_arg (#FCN, arg); \
+          err_wrong_type_arg (#FCN, arg); \
           return retval; \
         } \
     } \
  \
   return retval
 
 #define DATA_REDUCTION(FCN) \
  \
@@ -1142,17 +1142,17 @@ negative numbers or when the values are 
         { \
           ComplexNDArray tmp = arg.complex_array_value (); \
 \
           retval = tmp.FCN (dim); \
         } \
     } \
   else \
     { \
-      gripe_wrong_type_arg (#FCN, arg); \
+      err_wrong_type_arg (#FCN, arg); \
       return retval; \
     } \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cumprod (@var{x})\n\
@@ -1316,17 +1316,17 @@ See @code{sum} for an explanation of the
           if (isnative)
             retval = cs != 0.0;
           else
             retval = cs;
         }
       break;
 
     default:
-      gripe_wrong_type_arg ("cumsum", arg);
+      err_wrong_type_arg ("cumsum", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (cumsum ([1, 2, 3]), [1, 3, 6])
 %!assert (cumsum ([-1; -2; -3]), [-1; -3; -6])
@@ -1603,17 +1603,17 @@ in double precision even for single prec
         }
       else if (isnative)
         retval = arg.bool_array_value ().all (dim);
       else
         retval = NDArray (arg.bool_array_value ().all (dim));
       break;
 
     default:
-      gripe_wrong_type_arg ("prod", arg);
+      err_wrong_type_arg ("prod", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (prod ([1, 2, 3]), 6)
 %!assert (prod ([-1; -2; -3]), -6)
@@ -2028,18 +2028,18 @@ do_cat (const octave_value_list& xargs, 
           else
             retval = do_single_type_concat<FloatComplexNDArray> (args, dim);
         }
       else if (result_type == "char")
         {
           char type = all_dq_strings_p ? '"' : '\'';
 
           if (! all_strings_p)
-            gripe_implicit_conversion ("Octave:num-to-str",
-                                       "numeric", result_type);
+            warn_implicit_conversion ("Octave:num-to-str",
+                                      "numeric", result_type);
           else
             maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
           charNDArray result = do_single_type_concat<charNDArray> (args, dim);
 
           retval = octave_value (result, type);
         }
       else if (result_type == "logical")
@@ -3090,17 +3090,17 @@ inputs, @qcode{\"extra\"} is the same as
         }
       else if (isnative)
         retval = arg.bool_array_value ().any (dim);
       else
         retval = arg.bool_array_value ().sum (dim);
       break;
 
     default:
-      gripe_wrong_type_arg ("sum", arg);
+      err_wrong_type_arg ("sum", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (sum ([1, 2, 3]), 6)
 %!assert (sum ([-1; -2; -3]), -6)
@@ -5636,17 +5636,17 @@ compute the norms of each column and ret
       if (str == "fro")
         p_arg = octave_value (2);
       else if (str == "inf")
         p_arg = octave_Inf;
       else
         error ("norm: unrecognized option: %s", str.c_str ());
     }
   else if (! p_arg.is_scalar_type ())
-    gripe_wrong_type_arg ("norm", p_arg, true);
+    err_wrong_type_arg ("norm", p_arg);
 
   octave_value retval;
 
   switch (strflag)
     {
     case sfmatrix:
       retval = xnorm (x_arg, p_arg);
       break;
@@ -6924,17 +6924,17 @@ the ratio K/M is small; otherwise, it ma
           MAKE_INT_BRANCH (uint16);
           MAKE_INT_BRANCH (uint32);
           MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
         default:
           if (argx.is_cellstr ())
             retval = argx.cellstr_value ().nth_element (n, dim);
           else
-            gripe_wrong_type_arg ("nth_element", argx);
+            err_wrong_type_arg ("nth_element", argx);
         }
     }
   catch (const index_exception& e)
     {
       index_error ("nth_element: invalid N value %s. %s",
                    e.idx (), e.details ());
     }
 
@@ -7010,17 +7010,17 @@ Undocumented internal function.\n\
           if (vals.is_complex_type ())
             retval = do_accumarray_sum (idx,
                                         vals.complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.array_value (), n);
         }
       else
-        gripe_wrong_type_arg ("accumarray", vals);
+        err_wrong_type_arg ("accumarray", vals);
     }
   catch (const index_exception& e)
     {
       index_error ("__accumarray_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
@@ -7121,17 +7121,17 @@ do_accumarray_minmax_fun (const octave_v
 #undef MAKE_INT_BRANCH
 
         case btyp_bool:
           retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
                                          zero.bool_value ());
           break;
 
         default:
-          gripe_wrong_type_arg ("accumarray", vals);
+          err_wrong_type_arg ("accumarray", vals);
         }
     }
   catch (const index_exception& e)
     {
       index_error ("do_accumarray_minmax_fun: invalid index %s. %s",
                    e.idx (), e.details ());
     }
 
@@ -7230,17 +7230,17 @@ Undocumented internal function.\n\
         {
           if (vals.is_complex_type ())
             retval = do_accumdim_sum (idx, vals.complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
         }
       else
-        gripe_wrong_type_arg ("accumdim", vals);
+        err_wrong_type_arg ("accumdim", vals);
     }
   catch (const index_exception& e)
     {
       index_error ("__accumdim_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
@@ -7721,17 +7721,17 @@ endfor\n\
       BTYP_BRANCH (uint32, uint32_array);
       BTYP_BRANCH (uint64, uint64_array);
 
       BTYP_BRANCH (cell, cell);
       //BTYP_BRANCH (struct, map);//FIXME
 #undef BTYP_BRANCH
 
     default:
-      gripe_wrong_type_arg ("repelems", x);
+      err_wrong_type_arg ("repelems", x);
     }
 
   return retval;
 }
 
 DEFUN (base64_encode, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{s} =} base64_encode (@var{x})\n\
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "help.h"
 #include "input.h"
 #include "pager.h"
 #include "octave-link.h"
 #include "ovl.h"
 #include "utils.h"
 #include "parse.h"
 #include "symtab.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "octave-preserve-stream-state.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn.h"
 #include "ov-struct.h"
 #include "pt-pr-code.h"
 #include "pt-bp.h"
 #include "pt-eval.h"
@@ -725,17 +725,17 @@ current function.\n\
     {
       if (args(0).is_string ())
         {
           symbol_name = args(0).string_value ();
           fcn_list(0) = symbol_name;
           bp_list = bp_table::get_breakpoint_list (fcn_list);
         }
       else
-        gripe_wrong_type_arg ("dbstatus", args(0));
+        err_wrong_type_arg ("dbstatus", args(0));
     }
   else
     {
       if (Vdebugging)
         {
           octave_user_code *dbg_fcn = get_user_code ();
           if (dbg_fcn)
             {
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "error.h"
 #include "file-ops.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "help.h"
 #include "input.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "ov.h"
 #include "parse.h"
 #include "toplev.h"
 #include "unwind-prot.h"
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "DET.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "ops.h"
 
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-flt-cx-mat.h"
@@ -77,17 +77,17 @@ For that, use any of the condition numbe
 
   int arg_is_empty = empty_arg ("det", nr, nc);
   if (arg_is_empty < 0)
     return ovl ();
   if (arg_is_empty > 0)
     return octave_value (1.0);
 
   if (nr != nc)
-    gripe_square_matrix_required ("det");
+    err_square_matrix_required ("det");
 
   octave_value_list retval (2);
 
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (nargout <= 1)
@@ -221,17 +221,17 @@ For that, use any of the condition numbe
               ComplexDET det = m.determinant (mtype, info, rcond);
               retval(0) = info == -1 ? Complex (0.0) : det.value ();
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else
-        gripe_wrong_type_arg ("det", arg);
+        err_wrong_type_arg ("det", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (det ([1, 2; 3, 4]), -2, 10*eps)
 %!assert (det (single ([1, 2; 3, 4])), single (-2), 10*eps ("single"))
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "pathsearch.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "dir-ops.h"
 #include "dirfns.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "load-path.h"
 #include "octave-link.h"
 #include "ovl.h"
 #include "pager.h"
 #include "procstream.h"
 #include "sysdep.h"
 #include "toplev.h"
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "EIG.h"
 #include "fEIG.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (eig, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{lambda} =} eig (@var{A})\n\
 @deftypefnx {} {@var{lambda} =} eig (@var{A}, @var{B})\n\
 @deftypefnx {} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
@@ -69,17 +69,17 @@ The eigenvalues returned by @code{eig} a
   int arg_is_empty = empty_arg ("eig", nr_a, nc_a);
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (! arg_a.is_double_type () && ! arg_a.is_single_type ())
     {
-      gripe_wrong_type_arg ("eig", arg_a);
+      err_wrong_type_arg ("eig", arg_a);
       return retval;
     }
 
   if (nargin == 2)
     {
       arg_b = args(1);
       nr_b = arg_b.rows ();
       nc_b = arg_b.columns ();
@@ -87,26 +87,26 @@ The eigenvalues returned by @code{eig} a
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return ovl (2, Matrix ());
 
       if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
         {
-          gripe_wrong_type_arg ("eig", arg_b);
+          err_wrong_type_arg ("eig", arg_b);
           return retval;
         }
     }
 
   if (nr_a != nc_a)
-    gripe_square_matrix_required ("eig");
+    err_square_matrix_required ("eig");
 
   if (nargin == 2 && nr_b != nc_b)
-    gripe_square_matrix_required ("eig");
+    err_square_matrix_required ("eig");
 
   Matrix tmp_a, tmp_b;
   ComplexMatrix ctmp_a, ctmp_b;
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
   if (arg_a.is_single_type ())
     {
diff --git a/libinterp/corefcn/errwarn.cc b/libinterp/corefcn/errwarn.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/errwarn.cc
@@ -0,0 +1,333 @@
+/*
+
+Copyright (C) 2016 Rik Wehbring
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "defun.h"
+#include "error.h"
+#include "errwarn.h"
+#include "ovl.h"
+#include "utils.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Alphabetized list of common errors and warnings.
+////////////////////////////////////////////////////////////////////////////////
+
+void
+err_2_or_3_dim_plot (void)
+{
+  error ("plot: can only plot in 2 or 3 dimensions");
+}
+
+void
+err_data_conversion (const char *from, const char *to)
+{
+  error ("unable to convert from %s to %s format", from, to);
+}
+
+void
+err_disabled_feature (const std::string& fcn, const std::string& feature,
+                      const std::string& pkg /*="Octave"*/)
+{
+  error ("%s: support for %s was unavailable or disabled when %s was built",
+         fcn.c_str (), feature.c_str (), pkg.c_str ());
+}
+
+void
+err_indexed_cs_list (void)
+{
+  error ("a cs-list cannot be further indexed");
+}
+
+void
+err_invalid_conversion (const std::string& from, const std::string& to)
+{
+  error ("invalid conversion from %s to %s", from.c_str (), to.c_str ());
+}
+
+void
+err_invalid_inquiry_subscript (void)
+{
+  error ("invalid dimension inquiry of a non-existent value");
+}
+
+void
+err_nonbraced_cs_list_assignment (void)
+{
+  error ("invalid assignment to cs-list outside multiple assignment");
+}
+
+void
+err_nonconformant (void)
+{
+  error ("nonconformant matrices");
+}
+
+void
+err_nonconformant (octave_idx_type r1, octave_idx_type c1,
+                   octave_idx_type r2, octave_idx_type c2)
+{
+  error ("nonconformant matrices (op1 is %dx%d, op2 is %dx%d)",
+         r1, c1, r2, c2);
+}
+
+void
+err_not_implemented (const char *fcn)
+{
+  error ("%s: not implemented", fcn);
+}
+
+void
+err_range_invalid (void)
+{
+  error ("range constant used in invalid context");
+}
+
+void
+err_square_matrix_required (const char *name)
+{
+  error ("%s: argument must be a square matrix", name);
+}
+
+void
+err_string_invalid (void)
+{
+  error ("std::string constant used in invalid context");
+}
+
+void
+err_unrecognized_data_fmt (const char *name)
+{
+  error ("%s: unrecognized data format requested", name);
+}
+
+void
+err_unrecognized_float_fmt (void)
+{
+  error ("unrecognized floating point format requested");
+}
+
+void
+err_user_returned_invalid (const char *name)
+{
+  error ("%s: user-supplied function returned invalid value", name);
+}
+
+void
+err_user_supplied_eval (const char *name)
+{
+  octave_execution_exception e;
+
+  err_user_supplied_eval (e, name);
+}
+
+void
+err_user_supplied_eval (octave_execution_exception& e, const char *name)
+{
+  error (e, "%s: evaluation of user-supplied function failed", name);
+}
+
+void
+err_wrong_type_arg (const char *name, const char *s)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, name, s);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e,
+                    const char *name, const char *s)
+{
+  error (e, "%s: wrong type argument '%s'", name, s);
+}
+
+void
+err_wrong_type_arg (const char *name, const std::string& s)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, name, s.c_str ());
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e,
+                    const char *name, const std::string& s)
+{
+  err_wrong_type_arg (e, name, s.c_str ());
+}
+
+void
+err_wrong_type_arg (const char *name, const octave_value& tc)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, name, tc);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e,
+                    const char *name, const octave_value& tc)
+{
+  std::string type = tc.type_name ();
+
+  err_wrong_type_arg (e, name, type);
+}
+
+void
+err_wrong_type_arg (const std::string& name, const octave_value& tc)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, name, tc);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e,
+                    const std::string& name, const octave_value& tc)
+{
+  err_wrong_type_arg (e, name.c_str (), tc);
+}
+
+void
+err_wrong_type_arg (const char *s)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, s);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e, const char *s)
+{
+  error (e, "wrong type argument '%s'", s);
+}
+
+void
+err_wrong_type_arg (const std::string& s)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, s);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e, const std::string& s)
+{
+  err_wrong_type_arg (e, s.c_str ());
+}
+
+void
+err_wrong_type_arg (const octave_value& tc)
+{
+  octave_execution_exception e;
+
+  err_wrong_type_arg (e, tc);
+}
+
+void
+err_wrong_type_arg (octave_execution_exception& e, const octave_value& tc)
+{
+  std::string type = tc.type_name ();
+
+  err_wrong_type_arg (e, type);
+}
+
+void
+err_wrong_type_arg_for_binary_op (const octave_value& op)
+{
+  std::string type = op.type_name ();
+  error ("invalid operand '%s' for binary operator", type.c_str ());
+}
+
+void
+err_wrong_type_arg_for_unary_op (const octave_value& op)
+{
+  std::string type = op.type_name ();
+  error ("invalid operand '%s' for unary operator", type.c_str ());
+}
+
+void
+warn_complex_cmp (void)
+{
+  warning_with_id ("Octave:language-extension",
+                   "comparing complex numbers is not supported in Matlab");
+}
+
+void
+warn_data_file_in_path (const std::string& fcn, const std::string& file)
+{
+  warning_with_id ("Octave:data-file-in-path",
+                   "%s: '%s' found by searching load path",
+                   fcn.c_str (), file.c_str ());
+}
+
+void
+warn_divide_by_zero (void)
+{
+  warning_with_id ("Octave:divide-by-zero", "division by zero");
+}
+
+void
+warn_empty_arg (const char *name)
+{
+  warning ("%s: argument is empty matrix", name);
+}
+
+void
+warn_implicit_conversion (const char *id, const char *from, const char *to)
+{
+  warning_with_id (id, "implicit conversion from %s to %s", from, to);
+}
+
+void
+warn_implicit_conversion (const std::string& id,
+                          const std::string& from, const std::string& to)
+{
+  warning_with_id (id.c_str (),
+                   "implicit conversion from %s to %s",
+                   from.c_str (), to.c_str ());
+}
+
+void
+warn_invalid_value_specified (const char *name)
+{
+  warning ("invalid value specified for '%s'", name);
+}
+
+void
+warn_logical_conversion (void)
+{
+  warning_with_id ("Octave:logical-conversion",
+                   "value not equal to 1 or 0 converted to logical 1");
+}
+
+void
+warn_wrong_type_arg (const char *name, const octave_value& tc)
+{
+  std::string type = tc.type_name ();
+
+  warning ("%s: wrong type argument '%s'", name, type.c_str ());
+}
+
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/errwarn.h
@@ -0,0 +1,175 @@
+/*
+
+Copyright (C) 2016 Rik Wehbring
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_errwarn_h)
+#define octave_errwarn_h 1
+
+#include <string>
+
+#include "lo-array-errwarn.h"
+
+class octave_value;
+class octave_execution_exception;
+
+////////////////////////////////////////////////////////////////////////////////
+// Alphabetized list of common errors and warnings.
+////////////////////////////////////////////////////////////////////////////////
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_2_or_3_dim_plot (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_data_conversion (const char *from, const char *to);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_disabled_feature (const std::string& fcn,
+                           const std::string& feature,
+                           const std::string& pkg="Octave");
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_indexed_cs_list (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_invalid_conversion (const std::string& from, const std::string& to);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_invalid_inquiry_subscript (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_nonbraced_cs_list_assignment (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_nonconformant (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_nonconformant (octave_idx_type r1, octave_idx_type c1,
+                        octave_idx_type r2, octave_idx_type c2);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_not_implemented (const char *);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_range_invalid (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_square_matrix_required (const char *name);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_string_invalid (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_unrecognized_data_fmt (const char *name);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_unrecognized_float_fmt (void);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_user_returned_invalid (const char *name);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_user_supplied_eval (const char *name);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_user_supplied_eval (octave_execution_exception& e, const char *name);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const char *name, const char *s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e,
+                         const char *name, const char *s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const char *name, const std::string& s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e,
+                         const char *name, const std::string& s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const char *name, const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e,
+                         const char *name, const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const std::string& name, const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e,
+                         const std::string& name, const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const char *s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e, const char *s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const std::string& s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (octave_execution_exception& e, const std::string& s);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg (const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern 
+void err_wrong_type_arg (octave_execution_exception& e, const octave_value& tc);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg_for_binary_op (const octave_value& op);
+
+OCTAVE_NORETURN OCTINTERP_API extern
+void err_wrong_type_arg_for_unary_op (const octave_value& op);
+
+OCTINTERP_API extern
+void warn_complex_cmp (void);
+
+OCTINTERP_API extern
+void warn_data_file_in_path (const std::string& fcn, const std::string& file);
+
+OCTINTERP_API extern
+void warn_divide_by_zero (void);
+
+OCTINTERP_API extern
+void warn_empty_arg (const char *name);
+
+OCTINTERP_API extern
+void warn_implicit_conversion (const char *id,
+                               const char *from, const char *to);
+
+OCTINTERP_API extern
+void warn_implicit_conversion (const std::string& id,
+                               const std::string& from, const std::string& to);
+
+OCTINTERP_API extern
+void warn_invalid_value_specified (const char *name);
+
+OCTINTERP_API extern
+void warn_logical_conversion (void);
+
+OCTINTERP_API extern
+void warn_wrong_type_arg (const char *name, const octave_value& tc);
+
+#endif
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 #if defined (HAVE_FFTW)
 #define FFTSRC "@sc{fftw}"
 #else
 #define FFTSRC "@sc{fftpack}"
 #endif
@@ -140,17 +140,17 @@ do_fft (const octave_value_list &args, c
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
         }
       else
-        gripe_wrong_type_arg (fcn, arg);
+        err_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (fft ([]), [])
 %!assert (fft (zeros (10,0)), zeros (10,0))
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
 #define FFTSRC "@sc{fftw}"
 #else
@@ -128,17 +128,17 @@ do_fft2 (const octave_value_list &args, 
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
         }
       else
-        gripe_wrong_type_arg (fcn, arg);
+        err_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fft2, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fft2 (@var{A})\n\
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
 #define FFTSRC "@sc{fftw}"
 #else
@@ -114,17 +114,17 @@ do_fftn (const octave_value_list &args, 
       else if (arg.is_complex_type ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
         }
       else
-        gripe_wrong_type_arg (fcn, arg);
+        err_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 DEFUN (fftn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fftn (@var{A})\n\
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 
 // Find at most N_TO_FIND nonzero elements in NDA.  Search forward if
 // DIRECTION is 1, backward if it is -1.  NARGOUT is the number of
 // output arguments.  If N_TO_FIND is -1, find all nonzero elements.
 
 template <typename T>
 octave_value_list
@@ -477,17 +477,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else
-        gripe_wrong_type_arg ("find", arg);
+        err_wrong_type_arg ("find", arg);
     }
   else if (arg.is_perm_matrix ())
     {
       PermMatrix P = arg.perm_matrix_value ();
 
       retval = find_nonzero_elem_idx (P, nargout, n_to_find, direction);
     }
   else if (arg.is_string ())
@@ -519,17 +519,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
     }
   else if (arg.is_complex_type ())
     {
       ComplexNDArray cnda = arg.complex_array_value ();
 
       retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
     }
   else
-    gripe_wrong_type_arg ("find", arg);
+    err_wrong_type_arg ("find", arg);
 
   return retval;
 }
 
 /*
 %!assert (find (char ([0, 97])), 2)
 %!assert (find ([1, 0, 1, 0, 1]), [1, 3, 5])
 %!assert (find ([1; 0; 3; 0; 1]), [1; 3; 5])
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (gammainc, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} gammainc (@var{x}, @var{a})\n\
 @deftypefnx {} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
 @deftypefnx {} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -331,17 +331,17 @@ do_extended_gcd (const octave_value& a, 
     {
       NDA aa = octave_value_extract<NDA> (a);
       NDA bb = octave_value_extract<NDA> (b);
 
       dim_vector dv = aa.dims ();
       if (aa.numel () == 1)
         dv = bb.dims ();
       else if (bb.numel () != 1 && bb.dims () != dv)
-        gripe_nonconformant ("gcd", a.dims (), b.dims ());
+        err_nonconformant ("gcd", a.dims (), b.dims ());
 
       NDA gg (dv), xx (dv), yy (dv);
 
       const T *aptr = aa.fortran_vec ();
       const T *bptr = bb.fortran_vec ();
 
       bool inca = aa.numel () != 1;
       bool incb = bb.numel () != 1;
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-group.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "ovl.h"
 #include "utils.h"
 
 // Group file functions.  (Why not?)
 
 static octave_value
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-passwd.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "ovl.h"
 #include "utils.h"
 
 // Password file functions.  (Why not?)
 
 static octave_value
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include <list>
 #include <map>
 #include <set>
 #include <sstream>
 #include <string>
 
 #include "caseless-str.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-handle.h"
 #include "oct-map.h"
 #include "oct-mutex.h"
 #include "oct-refcount.h"
 #include "ov.h"
 #include "txt-eng-ft.h"
 
 // FIXME: maybe this should be a configure option?
@@ -2796,17 +2796,17 @@ public:
   }
 
   virtual void defaults (void) const
   {
     if (! valid_object ())
       error ("base_graphics_object::default: invalid graphics object");
 
     std::string msg = (type () + "::defaults");
-    gripe_not_implemented (msg.c_str ());
+    err_not_implemented (msg.c_str ());
   }
 
   virtual base_properties& get_properties (void)
   {
     static base_properties properties;
     error ("base_graphics_object::get_properties: invalid graphics object");
   }
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 #include "oct-locbuf.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "help.h"
 #include "input.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxHESS.h"
 #include "dbleHESS.h"
 #include "fCmplxHESS.h"
 #include "floatHESS.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (hess, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{H} =} hess (@var{A})\n\
 @deftypefnx {} {[@var{P}, @var{H}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
@@ -75,17 +75,17 @@ IEEE Transactions on Automatic Control, 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (nr != nc)
-    gripe_square_matrix_required ("hess");
+    err_square_matrix_required ("hess");
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
@@ -134,17 +134,17 @@ IEEE Transactions on Automatic Control, 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
       else
         {
-          gripe_wrong_type_arg ("hess", arg);
+          err_wrong_type_arg ("hess", arg);
         }
     }
 
   return retval;
 }
 
 /*
 %!test
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (hex2num, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{n} =} hex2num (@var{s})\n\
 @deftypefnx {} {@var{n} =} hex2num (@var{s}, @var{class})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "debug.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "help.h"
 #include "hook-fcn.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave-link.h"
 #include "oct-map.h"
 #include "oct-hist.h"
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
@@ -69,17 +69,17 @@ sparse matrix if possible.\n\
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
   if (nr != nc)
-    gripe_square_matrix_required ("inverse");
+    err_square_matrix_required ("inverse");
 
   octave_value result;
   octave_idx_type info;
   double rcond = 0.0;
   float frcond = 0.0;
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
@@ -178,17 +178,17 @@ sparse matrix if possible.\n\
               ComplexMatrix m = arg.complex_matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
         }
       else
-        gripe_wrong_type_arg ("inv", arg);
+        err_wrong_type_arg ("inv", arg);
     }
 
   octave_value_list retval (nargout > 1 ? 2 : 1);
 
   retval(0) = result;
   if (nargout > 1)
     retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
 
@@ -201,17 +201,17 @@ sparse matrix if possible.\n\
     }
   else
     {
       volatile double xrcond = rcond;
       rcond_plus_one_eq_one = xrcond + 1.0 == 1.0;
     }
 
   if (nargout < 2 && (info == -1 || rcond_plus_one_eq_one))
-    gripe_singular_matrix (isfloat ? frcond : rcond);
+    errwarn_singular_matrix (isfloat ? frcond : rcond);
 
   return retval;
 }
 
 /*
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -208,34 +208,34 @@ octave_jit_cast_any_complex (Complex c)
 {
   if (c.imag () == 0)
     return new octave_scalar (c.real ());
   else
     return new octave_complex (c);
 }
 
 extern "C" void
-octave_jit_gripe_nan_to_logical_conversion (void)
+octave_jit_err_nan_to_logical_conversion (void)
 {
-  gripe_nan_to_logical_conversion ();
+  err_nan_to_logical_conversion ();
 }
 
 extern "C" void
 octave_jit_ginvalid_index (void)
 {
-  // FIXME: 0-argument form of gripe_invalid_index removed in cset dd6345fd8a97
+  // FIXME: 0-argument form of err_invalid_index removed in cset dd6345fd8a97
   //        Report -1 as the bad index for all occurrences.
-  gripe_invalid_index (-1);
+  err_invalid_index (-1);
 }
 
 extern "C" void
 octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                          octave_idx_type ext)
 {
-  gripe_index_out_of_range (nd, dim, iext, ext);
+  err_index_out_of_range (nd, dim, iext, ext);
 }
 
 extern "C" jit_matrix
 octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                 double value)
 {
   NDArray *array = mat->array;
   if (array->numel () < index)
@@ -381,17 +381,17 @@ octave_jit_complex_mul (Complex lhs, Com
   return lhs * rhs;
 }
 
 extern "C" Complex
 octave_jit_complex_div (Complex lhs, Complex rhs)
 {
   // see src/OPERATORS/op-cs-cs.cc
   if (rhs == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return lhs / rhs;
 }
 
 // FIXME: CP form src/xpow.cc
 static inline int
 xisint (double x)
 {
@@ -1228,17 +1228,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
   add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
   add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
   add_binary_fcmp (scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
   add_binary_fcmp (scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
   add_binary_fcmp (scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
-  jit_function gripe_div0 = create_external (JIT_FN (gripe_divide_by_zero), 0);
+  jit_function gripe_div0 = create_external (JIT_FN (warn_divide_by_zero), 0);
   gripe_div0.mark_can_error ();
 
   // divide is annoying because it might error
   fn = create_internal ("octave_jit_div_scalar_scalar", scalar, scalar, scalar);
   fn.mark_can_error ();
 
   llvm::BasicBlock *body = fn.new_block ();
   builder.SetInsertPoint (body);
@@ -1503,17 +1503,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     fn.do_return (builder, ret);
   }
   for_index_fn.add_overload (fn);
 
   // logically true
   logically_true_fn.stash_name ("logically_true");
 
   jit_function gripe_nantl
-    = create_external (JIT_FN (octave_jit_gripe_nan_to_logical_conversion), 0);
+    = create_external (JIT_FN (octave_jit_err_nan_to_logical_conversion), 0);
   gripe_nantl.mark_can_error ();
 
   fn = create_internal ("octave_jit_logically_true_scalar", boolean, scalar);
   fn.mark_can_error ();
 
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -51,17 +51,17 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-path.h"
 #include "load-save.h"
 #include "oct-hdf5.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
@@ -391,17 +391,17 @@ do_load (std::istream& stream, const std
 
         case LS_MAT5_BINARY:
         case LS_MAT7_BINARY:
           name = read_mat5_binary_element (stream, orig_fname, swap,
                                            global, tc);
           break;
 
         default:
-          gripe_unrecognized_data_fmt ("load");
+          err_unrecognized_data_fmt ("load");
           break;
         }
 
       if (stream.eof () || name.empty ())
         break;
       else
         {
           if (! tc.is_defined ())
@@ -942,17 +942,17 @@ do_save (std::ostream& os, const octave_
       save_mat5_binary_element (os, tc, name, global, false, save_as_floats);
       break;
 
     case LS_MAT7_BINARY:
       save_mat5_binary_element (os, tc, name, global, true, save_as_floats);
       break;
 
     default:
-      gripe_unrecognized_data_fmt ("save");
+      err_unrecognized_data_fmt ("save");
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 
 #include "dNDArray.h"
 #include "CNDArray.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 
 static
 bool
 contains_char (const std::string& str, char c)
 {
   return (str.find (c) != std::string::npos
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-save.h"
 #include "oct-hdf5.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "lex.h"
 #include "load-save.h"
 #include "ls-ascii-helper.h"
 #include "ls-mat-ascii.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-save.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
@@ -574,12 +574,13 @@ save_mat_binary_data (std::ostream& os, 
       ComplexMatrix m_cmplx = tc.complex_matrix_value ();
       Matrix m = ::real (m_cmplx);
       std::streamsize n_bytes = 8 * static_cast<std::streamsize> (len);
       os.write (reinterpret_cast<const char *> (m.data ()), n_bytes);
       m = ::imag (m_cmplx);
       os.write (reinterpret_cast<const char *> (m.data ()), n_bytes);
     }
   else
-    gripe_wrong_type_arg ("save", tc, false);
+    // FIXME: Should this just error out rather than warn?
+    warn_wrong_type_arg ("save", tc);
 
   return ! os.fail ();
 }
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "str-vec.h"
 #include "file-stat.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-save.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "ov-class.h"
 #include "ov-fcn-inline.h"
 #include "pager.h"
@@ -2374,17 +2374,18 @@ save_mat5_binary_element (std::ostream& 
   else if (tc.is_map ())
     flags |= MAT_FILE_STRUCT_CLASS;
   else if (tc.is_cell ())
     flags |= MAT_FILE_CELL_CLASS;
   else if (tc.is_inline_function () || tc.is_object ())
     flags |= MAT_FILE_OBJECT_CLASS;
   else
     {
-      gripe_wrong_type_arg ("save", tc, false);
+      // FIXME: Should this just error out rather than warn?
+      warn_wrong_type_arg ("save", tc);
       goto error_cleanup;
     }
 
   os.write (reinterpret_cast<char *> (&flags), 4);
   // Matlab seems to have trouble reading files that have nzmax == 0 at
   // this point in the file.
   if (nnz_32 == 0)
     nnz_32 = 1;
@@ -2667,17 +2668,18 @@ save_mat5_binary_element (std::ostream& 
                                                          save_as_floats);
                 if (! retval2)
                   goto error_cleanup;
               }
           }
       }
     }
   else
-    gripe_wrong_type_arg ("save", tc, false);
+    // FIXME: Should this just error out rather than warn?
+    warn_wrong_type_arg ("save", tc);
 
 skip_to_next:
   return true;
 
 // FIXME: With short-circuiting error(), no need for goto in code
 error_cleanup:
   error ("save: error while writing '%s' to MAT file", name.c_str ());
 
diff --git a/libinterp/corefcn/ls-oct-binary.cc b/libinterp/corefcn/ls-oct-binary.cc
--- a/libinterp/corefcn/ls-oct-binary.cc
+++ b/libinterp/corefcn/ls-oct-binary.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-save.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 #include "oct-time.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-save.h"
 #include "ls-ascii-helper.h"
 #include "ls-oct-text.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <iomanip>
 #include <iostream>
 
 #include "LSODE.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
@@ -73,34 +73,34 @@ lsode_user_function (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "lsode");
+          err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
           retval = tmp(0).xvector_value ("lsode: expecting user supplied function to return numeric vector");
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("lsode");
+            err_user_supplied_eval ("lsode");
         }
       else
-        gripe_user_supplied_eval ("lsode");
+        err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 Matrix
 lsode_user_jacobian (const ColumnVector& x, double t)
 {
@@ -115,34 +115,34 @@ lsode_user_jacobian (const ColumnVector&
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "lsode");
+          err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).xmatrix_value ("lsode: expecting user supplied jacobian function to return numeric array");
 
           if (retval.is_empty ())
-            gripe_user_supplied_eval ("lsode");
+            err_user_supplied_eval ("lsode");
         }
       else
-        gripe_user_supplied_eval ("lsode");
+        err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 DEFUN (lsode, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "dbleLU.h"
 #include "fCmplxLU.h"
 #include "floatLU.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <class MT>
 static octave_value
 get_lu_l (const base_lu<MT>& fact)
@@ -325,17 +325,17 @@ information.\n\
                 }
 
               if (scale)
                 retval(4) = fact.R ();
             }
 
         }
       else
-        gripe_wrong_type_arg ("lu", arg);
+        err_wrong_type_arg ("lu", arg);
     }
   else
     {
       if (arg_is_empty < 0)
         return ovl ();
       else if (arg_is_empty > 0)
         return octave_value_list (3, Matrix ());
 
@@ -477,17 +477,17 @@ information.\n\
                       retval = ovl (get_lu_l (fact), get_lu_u (fact),
                                     fact.P ());
                   }
                   break;
                 }
             }
         }
       else
-        gripe_wrong_type_arg ("lu", arg);
+        err_wrong_type_arg ("lu", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert(lu ([1, 2; 3, 4]), [3, 4; 1/3, 2/3], eps);
 
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "oct-map.h"
 
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <class ArrayType>
 static octave_value_list
@@ -326,17 +326,17 @@ do_minmax_body (const octave_value_list&
 
 #undef MAKE_INT_BRANCH
 
         case btyp_bool:
           retval = do_minmax_red_op<boolNDArray> (arg, nargout, dim, ismin);
           break;
 
         default:
-          gripe_wrong_type_arg (func, arg);
+          err_wrong_type_arg (func, arg);
         }
     }
   else
     {
       octave_value argx = args(0);
       octave_value argy = args(1);
       builtin_type_t xtyp = argx.builtin_type ();
       builtin_type_t ytyp = argy.builtin_type ();
@@ -961,17 +961,17 @@ do_cumminmax_body (const octave_value_li
         retval = do_cumminmax_red_op<int8NDArray> (arg, nargout, dim,
                                                    ismin);
         if (retval.length () > 0)
           retval(0) = retval(0).bool_array_value ();
       }
       break;
 
     default:
-      gripe_wrong_type_arg (func, arg);
+      err_wrong_type_arg (func, arg);
     }
 
   return retval;
 }
 
 DEFUN (cummin, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cummin (@var{x})\n\
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-norm.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 template <class ColumnVector, class Matrix, class RowVector>
 static void
 do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h)
 {
   octave_idx_type Vc = V.columns ();
   h = RowVector (Vc + 1);
   for (octave_idx_type j = 0; j < Vc; j++)
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -29,16 +29,17 @@ COREFCN_INC = \
   libinterp/corefcn/debug.h \
   libinterp/corefcn/defun-dld.h \
   libinterp/corefcn/defun-int.h \
   libinterp/corefcn/defun.h \
   libinterp/corefcn/dirfns.h \
   libinterp/corefcn/display.h \
   libinterp/corefcn/dynamic-ld.h \
   libinterp/corefcn/error.h \
+  libinterp/corefcn/errwarn.h \
   libinterp/corefcn/event-queue.h \
   libinterp/corefcn/file-io.h \
   libinterp/corefcn/gl-render.h \
   libinterp/corefcn/gl2ps-renderer.h \
   libinterp/corefcn/gripes.h \
   libinterp/corefcn/help.h \
   libinterp/corefcn/hook-fcn.h \
   libinterp/corefcn/input.h \
@@ -138,16 +139,17 @@ COREFCN_SRC = \
   libinterp/corefcn/dirfns.cc \
   libinterp/corefcn/display.cc \
   libinterp/corefcn/dlmread.cc \
   libinterp/corefcn/dot.cc \
   libinterp/corefcn/dynamic-ld.cc \
   libinterp/corefcn/eig.cc \
   libinterp/corefcn/ellipj.cc \
   libinterp/corefcn/error.cc \
+  libinterp/corefcn/errwarn.cc \
   libinterp/corefcn/fft.cc \
   libinterp/corefcn/fft2.cc \
   libinterp/corefcn/fftn.cc \
   libinterp/corefcn/file-io.cc \
   libinterp/corefcn/filter.cc \
   libinterp/corefcn/find.cc \
   libinterp/corefcn/gammainc.cc \
   libinterp/corefcn/gcd.cc \
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -51,17 +51,17 @@ Software Foundation, Inc.
 #include "octave-link.h"
 #include "oct-env.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "oct-hist.h"
 #include "ovl.h"
 #include "pager.h"
 #include "parse.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "toplev.h"
@@ -157,17 +157,17 @@ do_history (const octave_value_list& arg
         {
           limit = arg.int_value ();
           if (limit < 0)
             limit = -limit;
           continue;
         }
       else
         {
-          gripe_wrong_type_arg ("history", arg);
+          err_wrong_type_arg ("history", arg);
           return hlist;
         }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
             {
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "oct-procbuf.h"
 #include "oct-syscalls.h"
 #include "sysdep.h"
 #include "variables.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "utils.h"
 
 #ifndef SHELL_PATH
 #define SHELL_PATH "/bin/sh"
 #endif
 
 // This class is based on the procbuf class from libg++, written by
 // Per Bothner, Copyright (C) 1993 Free Software Foundation.
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
 
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "ovl.h"
 #include "toplev.h"
 #include "utils.h"
 
 // Programming Note: There are two very different error functions used
@@ -2177,17 +2177,17 @@ public:
       curr_state (ok)
   {
     for (octave_idx_type i = 0; i < values.length (); i++)
       {
         octave_value val = values(i);
 
         if (val.is_map () || val.is_cell () || val.is_object ())
           {
-            gripe_wrong_type_arg (who, val);
+            err_wrong_type_arg (who, val);
             break;
           }
       }
   }
 
   ~printf_value_cache (void) { }
 
   // Get the current value as a double and advance the internal pointer.
diff --git a/libinterp/corefcn/oct.h b/libinterp/corefcn/oct.h
--- a/libinterp/corefcn/oct.h
+++ b/libinterp/corefcn/oct.h
@@ -30,16 +30,16 @@ along with Octave; see the file COPYING.
 
 #include <config.h>
 
 #include "Matrix.h"
 
 #include "oct-locbuf.h"
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "help.h"
 #include "ovl.h"
 #include "pager.h"
 #include "utils.h"
 #include "variables.h"
 
 #endif
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "cmd-edit.h"
 #include "oct-env.h"
 #include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "ovl.h"
 #include "pager.h"
 #include "procstream.h"
 #include "sighandlers.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
@@ -124,17 +124,17 @@ where @code{sigma_max (@var{x})} is the 
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else
-        gripe_wrong_type_arg ("pinv", arg);
+        err_wrong_type_arg ("pinv", arg);
     }
   else
     {
       double tol = 0.0;
       if (nargin == 2)
         tol = args(1).double_value ();
 
       if (tol < 0.0)
@@ -148,17 +148,17 @@ where @code{sigma_max (@var{x})} is the 
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else
-        gripe_wrong_type_arg ("pinv", arg);
+        err_wrong_type_arg ("pinv", arg);
     }
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
 %! a = reshape (rand*[1:16], 4, 4);  # Rank 2 matrix
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "mach-info.h"
 #include "oct-cmplx.h"
 #include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-stream.h"
 #include "octave-preserve-stream-state.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <iomanip>
 #include <iostream>
 
 #include "Quad.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "pager.h"
 #include "ovl.h"
 #include "ov-fcn.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "Quad-opts.cc"
@@ -70,31 +70,31 @@ quad_user_function (double x)
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "quad");
+          err_user_supplied_eval (e, "quad");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("quad: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
             }
 
           retval = tmp(0).xdouble_value ("quad: expecting user supplied function to return numeric value");
         }
       else
-        gripe_user_supplied_eval ("quad");
+        err_user_supplied_eval ("quad");
     }
 
   return retval;
 }
 
 float
 quad_float_user_function (float x)
 {
@@ -108,32 +108,32 @@ quad_float_user_function (float x)
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "quad");
+          err_user_supplied_eval (e, "quad");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("quad: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
             }
 
           retval = tmp(0).xfloat_value ("quad: expecting user supplied function to return numeric value");
 
         }
       else
-        gripe_user_supplied_eval ("quad");
+        err_user_supplied_eval ("quad");
     }
 
   return retval;
 }
 
 DEFUN (quad, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #include "CmplxQR.h"
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-math.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
 #endif
 #include "symtab.h"
@@ -455,43 +455,43 @@ compatibility with @sc{matlab}.\n\
 #endif
 
   octave_value_list retval;
 
   int arg_is_empty = empty_arg ("qz", nn, args(0).columns ());
 
   if (arg_is_empty < 0)
     {
-      gripe_empty_arg ("qz: parameter 1", 0);
+      warn_empty_arg ("qz: parameter 1");
       return retval;
     }
   else if (arg_is_empty > 0)
     {
-      gripe_empty_arg ("qz: parameter 1; continuing", 0);
+      warn_empty_arg ("qz: parameter 1; continuing");
       return octave_value_list (2, Matrix ());
     }
   else if (args(0).columns () != nn)
-    gripe_square_matrix_required ("qz");
+    err_square_matrix_required ("qz");
 
   // Argument 1: dimensions look good; get the value.
   Matrix aa;
   ComplexMatrix caa;
 
   if (args(0).is_complex_type ())
     caa = args(0).complex_matrix_value ();
   else
     aa = args(0).matrix_value ();
 
 #ifdef DEBUG
   std::cout << "qz: check argument 2" << std::endl;
 #endif
 
   // Extract argument 2 (bb, or cbb if complex).
   if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
-    gripe_nonconformant ();
+    err_nonconformant ();
 
   Matrix bb;
   ComplexMatrix cbb;
 
   if (args(1).is_complex_type ())
     cbb = args(1).complex_matrix_value ();
   else
     bb = args(1).matrix_value ();
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 
 #include "f77-fcn.h"
 #include "lo-mappers.h"
 #include "oct-rand.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
 %!shared __random_statistical_tests__
 %! ## Flag whether the statistical tests should be run in "make check" or not
@@ -204,17 +204,17 @@ do_rand (const octave_value_list& args, 
                 octave_idx_type elt = iv(i);
                 dims(i) = elt >=0 ? elt : 0;
               }
 
             goto gen_matrix;
           }
         else
           {
-            gripe_wrong_type_arg ("rand", tmp);
+            err_wrong_type_arg ("rand", tmp);
             return retval;
           }
       }
       break;
 
     default:
       {
         octave_value tmp = args(idx);
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (rcond, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{c} =} rcond (@var{A})\n\
 Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.\n\
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "lo-regexp.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "Cell.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "utils.h"
 
 // Replace backslash escapes in a string with the real values.  We need
 // two special functions instead of the one in utils.cc because the set
 // of escape sequences used for regexp patterns and replacement strings
 // is different from those used in the *printf functions.
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxSCHUR.h"
 #include "dbleSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "floatSCHUR.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <class Matrix>
 static octave_value
 mark_upper_triangular (const Matrix& a)
 {
   octave_value retval = a;
@@ -162,22 +162,22 @@ in control (see @code{are} and @code{dar
           return ovl ();
         }
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
-    gripe_square_matrix_required ("schur");
+    err_square_matrix_required ("schur");
 
   octave_value_list retval;
 
   if (! arg.is_numeric_type ())
-    gripe_wrong_type_arg ("schur", arg);
+    err_wrong_type_arg ("schur", arg);
   else if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (nargout <= 1)
             {
@@ -289,19 +289,19 @@ Note also that @var{U} and @var{T} are n
 @end deftypefn")
 {
   if (args.length () != 2 || nargout > 2)
     print_usage ();
 
   octave_value_list retval;
 
   if (! args(0).is_numeric_type ())
-    gripe_wrong_type_arg ("rsf2csf", args(0));
+    err_wrong_type_arg ("rsf2csf", args(0));
   else if (! args(1).is_numeric_type ())
-    gripe_wrong_type_arg ("rsf2csf", args(1));
+    err_wrong_type_arg ("rsf2csf", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
   else
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatMatrix u = args(0).float_matrix_value ();
           FloatMatrix t = args(1).float_matrix_value ();
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -23,48 +23,48 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
 
 #include "Array-util.h"
-#include "lo-array-gripes.h"
+#include "lo-array-errwarn.h"
 #include "oct-cmplx.h"
 #include "quit.h"
 #include "error.h"
 #include "lo-ieee.h"
 
 #include "dSparse.h"
 #include "dDiagMatrix.h"
 #include "CSparse.h"
 #include "CDiagMatrix.h"
 #include "oct-spparms.h"
 #include "sparse-xdiv.h"
 
 static void
 solve_singularity_warning (double rcond)
 {
-  gripe_singular_matrix (rcond);
+  errwarn_singular_matrix (rcond);
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = a.cols ();
       octave_idx_type b_nc = b.cols ();
 
-      gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
   template bool mx_leftdiv_conform (const T1&, const T2&)
 
@@ -88,17 +88,17 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
-      gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2) \
   template bool mx_div_conform (const T1&, const T2&)
 
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -414,17 +414,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       {
         if (a.data(i) < 0.0)
           {
             double btmp = b (a.ridx (i), j);
@@ -516,17 +516,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx(i), j) = std::pow (a.data (i), b(a.ridx (i), j));
@@ -656,17 +656,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           double btmp = b(a.ridx (i), j);
@@ -724,17 +724,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx (i), j) = std::pow (a.data (i),
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <cstdlib>
 #include <string>
 
 #include "variables.h"
 #include "utils.h"
 #include "pager.h"
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "quit.h"
 #include "unwind-prot.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 DEFUN (issparse, args, ,
@@ -139,17 +139,17 @@ Compressed Column Sparse (rows = 3, cols
       octave_value arg = args(0);
       if (arg.is_bool_type ())
         retval = arg.sparse_bool_matrix_value ();
       else if (arg.is_complex_type ())
         retval = arg.sparse_complex_matrix_value ();
       else if (arg.is_numeric_type ())
         retval = arg.sparse_matrix_value ();
       else
-        gripe_wrong_type_arg ("sparse", arg);
+        err_wrong_type_arg ("sparse", arg);
     }
   else if (nargin == 2)
     {
       octave_idx_type m = 0;
       octave_idx_type n = 0;
 
       get_dimensions (args(0), args(1), "sparse", m, n);
 
@@ -202,17 +202,17 @@ Compressed Column Sparse (rows = 3, cols
                                        m, n, summation, nzmax);
           else if (args(2).is_complex_type ())
             retval = SparseComplexMatrix (args(2).complex_array_value(),
                                           i, j, m, n, summation, nzmax);
           else if (args(2).is_numeric_type ())
             retval = SparseMatrix (args(2).array_value (), i, j,
                                    m, n, summation, nzmax);
           else
-            gripe_wrong_type_arg ("sparse", args(2));
+            err_wrong_type_arg ("sparse", args(2));
         }
       catch (index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
           e.set_pos_if_unset (2, k+1);
           throw;
         }
     }
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "ov.h"
 #include "pager.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #include "oct-spparms.h"
 
 DEFUN (spparms, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} { } spparms ()\n\
 @deftypefnx {} {@var{vals} =} spparms ()\n\
 @deftypefnx {} {[@var{keys}, @var{vals}] =} spparms ()\n\
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "CmplxSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-norm.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "utils.h"
 #include "xnorm.h"
 
 template <class Matrix>
 static void
 sqrtm_utri_inplace (Matrix& T)
 {
   typedef typename Matrix::element_type element_type;
@@ -216,17 +216,17 @@ Mathematics, Manchester, England, Januar
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type n = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (n != nc || arg.ndims () > 2)
-    gripe_square_matrix_required ("sqrtm");
+    err_square_matrix_required ("sqrtm");
 
   octave_value_list retval (nargout > 1 ? 3 : 1);
 
   if (nargout > 1)
     {
       // FIXME: Octave does not calculate a condition number with respect to
       //        sqrtm.  Should this return NaN instead of -1?
       retval(2) = -1.0;
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <sstream>
 #include <algorithm>
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "ov.h"
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "utils.h"
 
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static double
 single_num (std::istringstream& is)
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "ov.h"
 #include "defun.h"
 #include "unwind-prot.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "utils.h"
 
 // This allows safe indexing with char.
 // In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
 #define TABSIZE (std::numeric_limits<unsigned char>::max () + 1)
 
 // This is the quick search algorithm, as described at
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <queue>
 #include <sstream>
 
 #include "dMatrix.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ov.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 DEFUN (char, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} char (@var{x})\n\
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "Array-util.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 
 
 static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
   RowVector dimsv = val.row_vector_value (false, true);
   dim_vector dv;
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxSVD.h"
 #include "dbleSVD.h"
 #include "fCmplxSVD.h"
 #include "floatSVD.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
 DEFUN (svd, args, nargout,
@@ -267,17 +267,17 @@ decomposition, eliminating the unnecessa
               if (nargout == 0 || nargout == 1)
                 retval(0) = sigma.extract_diag ();
               else
                 retval = ovl (result.left_singular_matrix (),
                               sigma,
                               result.right_singular_matrix ());
             }
           else
-            gripe_wrong_type_arg ("svd", arg);
+            err_wrong_type_arg ("svd", arg);
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (svd ([1, 2; 2, 1]), [3; 1], sqrt (eps))
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 // Author: A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN (sylvester, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{X} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
@@ -92,21 +92,21 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
     else
       return ovl (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
     return retval;
 
   // Arguments are not empty, so check for correct dimensions.
 
   if (a_nr != a_nc)
-    gripe_square_matrix_required ("sylvester: input A");
+    err_square_matrix_required ("sylvester: input A");
   else if (b_nr != b_nc)
-    gripe_square_matrix_required ("sylvester: input B");
+    err_square_matrix_required ("sylvester: input B");
   else if (a_nr != c_nr || b_nr != c_nc)
-    gripe_nonconformant ();
+    err_nonconformant ();
 
   if (isfloat)
     {
       if (arg_a.is_complex_type ()
           || arg_b.is_complex_type ()
           || arg_c.is_complex_type ())
         {
           // Do everything in complex arithmetic;
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-syscalls.h"
 #include "oct-uname.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "lo-utils.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "sysdep.h"
 #include "utils.h"
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <limits>
 
 #include "mx-base.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 
 static dim_vector
 get_vec_dims (const dim_vector& old_dims, octave_idx_type n)
 {
   if (old_dims.length () == 2 && old_dims(0) == 1)
     return dim_vector (1, n);
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-errno.h"
 #include "oct-hist.h"
 #include "ovl.h"
 #include "ov-range.h"
 #include "pager.h"
@@ -456,17 +456,17 @@ find_data_file_in_load_path  (const std:
       if (! local_file_ok)
         {
           // Not directly found; search load path.
           std::string tmp
             = octave_env::make_absolute (load_path::find_file (fname));
 
           if (! tmp.empty ())
             {
-              gripe_data_file_in_path (fcn, tmp);
+              warn_data_file_in_path (fcn, tmp);
 
               fname = tmp;
             }
         }
     }
 
   return fname;
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "lo-regexp.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "help.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave-link.h"
 #include "octave-preserve-stream-state.h"
 #include "oct-map.h"
 #include "ovl.h"
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -37,50 +37,50 @@ along with Octave; see the file COPYING.
 #include "fMatrix.h"
 #include "fCNDArray.h"
 #include "fNDArray.h"
 #include "oct-cmplx.h"
 #include "dDiagMatrix.h"
 #include "fDiagMatrix.h"
 #include "CDiagMatrix.h"
 #include "fCDiagMatrix.h"
-#include "lo-array-gripes.h"
+#include "lo-array-errwarn.h"
 #include "quit.h"
 
 #include "error.h"
 #include "xdiv.h"
 
 static inline bool
 result_ok (octave_idx_type info)
 {
   assert (info != -1);
 
   return (info != -2);
 }
 
 static void
 solve_singularity_warning (double rcond)
 {
-  gripe_singular_matrix (rcond);
+  errwarn_singular_matrix (rcond);
 }
 
 template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols ()
                                                          : a.rows ();
       octave_idx_type b_nc = b.cols ();
 
-      gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
   template bool mx_leftdiv_conform (const T1&, const T2&, blas_trans_type)
 
@@ -96,17 +96,17 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
-      gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2) \
   template bool mx_div_conform (const T1&, const T2&)
 
@@ -398,17 +398,17 @@ xleftdiv (const ComplexMatrix& a, const 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
 solve_singularity_warning (float rcond)
 {
-  gripe_singular_matrix (rcond);
+  errwarn_singular_matrix (rcond);
 }
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatMatrix, FloatComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (FloatComplexMatrix, FloatComplexMatrix);
 
 INSTANTIATE_MX_DIV_CONFORM (FloatMatrix, FloatMatrix);
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <cfloat>
 #include <cmath>
 
 #include "oct-norm.h"
 
 #include "error.h"
 #include "xnorm.h"
 #include "ov.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 octave_value xnorm (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
@@ -86,17 +86,17 @@ octave_value xnorm (const octave_value& 
             retval = xnorm (x.complex_matrix_value (),
                             p.double_value ());
           else
             retval = xnorm (x.matrix_value (),
                             p.double_value ());
         }
     }
   else
-    gripe_wrong_type_arg ("xnorm", x, true);
+    err_wrong_type_arg ("xnorm", x);
 
   return retval;
 }
 
 octave_value xcolnorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
@@ -127,17 +127,17 @@ octave_value xcolnorms (const octave_val
             retval = xcolnorms (x.complex_matrix_value (),
                                 p.double_value ());
           else
             retval = xcolnorms (x.matrix_value (),
                                 p.double_value ());
         }
     }
   else
-    gripe_wrong_type_arg ("xcolnorms", x, true);
+    err_wrong_type_arg ("xcolnorms", x);
 
   return retval;
 }
 
 octave_value xrownorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
@@ -168,17 +168,17 @@ octave_value xrownorms (const octave_val
             retval = xrownorms (x.complex_matrix_value (),
                                 p.double_value ());
           else
             retval = xrownorms (x.matrix_value (),
                                 p.double_value ());
         }
     }
   else
-    gripe_wrong_type_arg ("xrownorms", x, true);
+    err_wrong_type_arg ("xrownorms", x);
 
   return retval;
 }
 
 octave_value xfrobnorm (const octave_value& x)
 {
   octave_value retval;
 
@@ -203,12 +203,12 @@ octave_value xfrobnorm (const octave_val
             retval = xfrobnorm (x.float_matrix_value ());
           else if (iscomplex)
             retval = xfrobnorm (x.complex_matrix_value ());
           else
             retval = xfrobnorm (x.matrix_value ());
         }
     }
   else
-    gripe_wrong_type_arg ("xfrobnorm", x, true);
+    err_wrong_type_arg ("xfrobnorm", x);
 
   return retval;
 }
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -788,17 +788,17 @@ elem_xpow (const Matrix& a, const Matrix
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double atmp = a (i, j);
         double btmp = b (i, j);
@@ -868,17 +868,17 @@ elem_xpow (const Matrix& a, const Comple
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
@@ -1006,17 +1006,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double btmp = b (i, j);
@@ -1054,17 +1054,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -1236,17 +1236,17 @@ elem_xpow (const NDArray& a, const NDArr
           NDArray xa = octave_value_extract<NDArray> (a);
           NDArray xb = octave_value_extract<NDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -1315,17 +1315,17 @@ elem_xpow (const NDArray& a, const Compl
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -1411,17 +1411,17 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       double btmp = b(i);
@@ -1458,17 +1458,17 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2150,17 +2150,17 @@ elem_xpow (const FloatMatrix& a, const F
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float atmp = a (i, j);
         float btmp = b (i, j);
@@ -2230,17 +2230,17 @@ elem_xpow (const FloatMatrix& a, const F
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
@@ -2328,17 +2328,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float btmp = b (i, j);
@@ -2376,17 +2376,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
+    err_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -2558,17 +2558,17 @@ elem_xpow (const FloatNDArray& a, const 
           FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
           FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -2637,17 +2637,17 @@ elem_xpow (const FloatNDArray& a, const 
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2733,17 +2733,17 @@ elem_xpow (const FloatComplexNDArray& a,
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       float btmp = b(i);
@@ -2780,17 +2780,17 @@ elem_xpow (const FloatComplexNDArray& a,
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        gripe_nonconformant ("operator .^", a_dims, b_dims);
+        err_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "ov.h"
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "quit.h"
 #include "variables.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "oct-map.h"
 #include "pager.h"
 #include "unwind-prot.h"
 
@@ -59,33 +59,33 @@ eigs_func (const ColumnVector &x, int &e
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "eigs");
+          err_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("eigs: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
             }
 
           retval = tmp(0).xvector_value ("eigs: evaluation of user-supplied function failed");
         }
       else
         {
           eigs_error = 1;
-          gripe_user_supplied_eval ("eigs");
+          err_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
 ComplexColumnVector
 eigs_complex_func (const ComplexColumnVector &x, int &eigs_error)
@@ -99,27 +99,27 @@ eigs_complex_func (const ComplexColumnVe
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
-          gripe_user_supplied_eval (e, "eigs");
+          err_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           retval = tmp(0).complex_vector_value ("eigs: evaluation of user-supplied function failed");
         }
       else
         {
           eigs_error = 1;
-          gripe_user_supplied_eval ("eigs");
+          err_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (__eigs__, args, nargout,
            "-*- texinfo -*-\n\
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <cfloat>
 #include <ctime>
 
 #include "lo-ieee.h"
 
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "pager.h"
 
 #if defined (HAVE_GLPK)
 
 extern "C"
 {
@@ -609,16 +609,16 @@ Undocumented internal function.\n\
     }
 
   extra.assign ("time", time);
   extra.assign ("status", status);
 
   return ovl (xmin, fmin, errnum, extra);
 
 #else
-  gripe_disabled_feature ("glpk", "GNU Linear Programming Kit");
+  err_disabled_feature ("glpk", "GNU Linear Programming Kit");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov-struct.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 
 #ifdef HAVE_MAGICK
 
 #include <Magick++.h>
 #include <clocale>
 
 // In theory, it should be enough to check the class:
 // Magick::ClassType
@@ -844,17 +844,17 @@ Use @code{imread} instead.\n\
       else
         error ("imread: reading of images with %i-bit depth is not supported",
                depth);
     }
 
   return output;
 
 #else
-  gripe_disabled_feature ("imread", "Image IO");
+  err_disabled_feature ("imread", "Image IO");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -1535,17 +1535,17 @@ Use @code{imwrite} instead.\n\
 
 #undef COMPRESS_MAGICK_IMAGE_VECTOR
 
   write_file (filename, ext, imvec);
 
   return ovl ();
 
 #else
-  gripe_disabled_feature ("imwrite", "Image IO");
+  err_disabled_feature ("imwrite", "Image IO");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -1597,17 +1597,17 @@ This is a private internal function not 
   octave_scalar_map ping = octave_scalar_map (string_vector (fields));
   ping.setfield ("rows",    octave_value (img.rows ()));
   ping.setfield ("columns", octave_value (img.columns ()));
   ping.setfield ("format",  octave_value (img.magick ()));
 
   return ovl (ping);
 
 #else
-  gripe_disabled_feature ("imfinfo", "Image IO");
+  err_disabled_feature ("imfinfo", "Image IO");
 #endif
 }
 
 #ifdef HAVE_MAGICK
 static octave_value
 magick_to_octave_value (const Magick::CompressionType& magick)
 {
   switch (magick)
@@ -2204,17 +2204,17 @@ Use @code{imfinfo} instead.\n\
     }
   else
     info.setfield ("DisposalMethod",
                    Cell (dim_vector (nFrames, 1), octave_value ("")));
 
   return ovl (info);
 
 #else
-  gripe_disabled_feature ("imfinfo", "Image IO");
+  err_disabled_feature ("imfinfo", "Image IO");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
@@ -2258,16 +2258,16 @@ Fill formats info with GraphicsMagick Co
           formats.delete_elements (idx);
           idx--;
         }
     }
 
   return ovl (formats);
 
 #else
-  gripe_disabled_feature ("imformats", "Image IO");
+  err_disabled_feature ("imformats", "Image IO");
 #endif
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/dldfcn/__osmesa_print__.cc b/libinterp/dldfcn/__osmesa_print__.cc
--- a/libinterp/dldfcn/__osmesa_print__.cc
+++ b/libinterp/dldfcn/__osmesa_print__.cc
@@ -29,17 +29,17 @@ from git://anongit.freedesktop.org/mesa/
 
 #include "oct-locbuf.h"
 #include "unwind-prot.h"
 
 #include "defun-dld.h"
 #include "gl-render.h"
 #include "gl2ps-renderer.h"
 #include "graphics.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #if defined (HAVE_OSMESA_H)
 #include "osmesa.h"
 #elif defined (HAVE_GL_OSMESA_H)
 #include "GL/osmesa.h"
 #endif
 
 #if defined (HAVE_OSMESA) && defined (HAVE_OPENGL)
@@ -83,17 +83,17 @@ Don't render text.\n\
 @end table\n\
 \n\
 The second method doesn't use gl2ps and returns a RGB image in @var{img}\n\
 instead.\n\
 \n\
 @end deftypefn")
 {
 #if ! defined (HAVE_OSMESA)
-  gripe_disabled_feature ("__osmesa_print__", "offscreen rendering");
+  err_disabled_feature ("__osmesa_print__", "offscreen rendering");
 #else
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
 
   if (nargin == 3)
     {
@@ -155,17 +155,17 @@ instead.\n\
 
       fp.set_visible ("off");
     }
 
   if (nargin == 3)
     {
       // use gl2ps
 #ifndef HAVE_GL2PS_H
-      gripe_disabled_feature ("__osmesa_print__", "gl2ps");
+      err_disabled_feature ("__osmesa_print__", "gl2ps");
 #else
       std::string file = args(1).string_value ();
       std::string term = args(2).string_value ();
 
       size_t pos_p = file.find_first_of ("|");
       size_t pos_c = file.find_first_not_of ("| ");
 
       if (pos_p == std::string::npos && pos_c == std::string::npos)
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <vector>
 
 #include "mach-info.h"
 
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-locbuf.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int32.h"
 #include "ov-struct.h"
 #include "parse.h"
 #include "unwind-prot.h"
 
@@ -401,19 +401,19 @@ recording using those parameters.\n\
         error ("audiodevinfo: please specify 0 for output and 1 for input devices");
 
       retval = 0;
     }
 
   return retval;
 
 #else
-  gripe_disabled_feature ("audiodevinfo",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("audiodevinfo",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #endif
 }
 
 /*
 %!testif HAVE_PORTAUDIO
 %! devinfo = audiodevinfo;
 %! assert (rows (devinfo.input), 1);
 %! assert (rows (devinfo.output), 1);
@@ -1807,19 +1807,19 @@ DEFUN_DLD (__recorder_audiorecorder__, a
 @deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fs}, @var{nbits}, @var{channels}, @var{id})\n\
 @deftypefnx {} {@var{recorder} =} __recorder_audiorecorder__ (@var{fcn}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_audiorecorder__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_audiorecorder__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
 
   int nargin = args.length ();
 
   audiorecorder* recorder = new audiorecorder ();
 
   if (nargin > 0)
     {
@@ -1871,222 +1871,222 @@ get_recorder (const octave_value& ov)
 DEFUN_DLD (__recorder_getaudiodata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data}} __recorder_getaudiodata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_getaudiodata__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_getaudiodata__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->getaudiodata ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_channels__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_channels__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_channels__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_channels__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_channels ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{fs} =} __recorder_get_fs__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_fs__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_fs__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_fs ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_id__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{id} =} __recorder_get_id__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_id__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_id__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_id ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_nbits__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{nbits} =} __recorder_get_nbits__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_nbits__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_nbits__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_nbits ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_sample_number__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_sample_number__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_sample_number__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_sample_number ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{tag} =} __recorder_get_tag__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_tag__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_tag__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_tag ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __recorder_get_total_samples__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_total_samples__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_total_samples__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_total_samples ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_get_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data} =} __recorder_get_userdata__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_get_userdata__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_get_userdata__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->get_userdata ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_isrecording__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_isrecording__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_isrecording__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_isrecording__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   retval = get_recorder (args(0))->isrecording ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__recorder_pause__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_pause__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_pause__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_pause__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   get_recorder (args(0))->pause ();
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_recordblocking__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_recordblocking__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_recordblocking__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_recordblocking__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   float seconds = args(1).float_value ();
   get_recorder (args(0))->recordblocking (seconds);
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_record__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __recorder_record__ (@var{recorder})\n\
 @deftypefnx {} {} __recorder_record__ (@var{recorder}, @var{seconds})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_record__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_record__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   audiorecorder *recorder = get_recorder (args(0));
 
   if (args.length () == 2)
     recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
 
   recorder->record ();
 #endif
@@ -2095,87 +2095,87 @@ Undocumented internal function.\n\
 
 DEFUN_DLD (__recorder_resume__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_resume__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_resume__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_resume__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     get_recorder (args(0))->resume ();
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_set_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_fs__ (@var{recorder}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_set_fs__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_set_fs__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_fs (args(1).int_value ());
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_set_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_tag__ (@var{recorder}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_set_tag__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_set_tag__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_tag (args(1).char_matrix_value ());
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_set_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_set_userdata__ (@var{recorder}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_set_userdata__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_set_userdata__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_recorder (args(0))->set_userdata (args(1));
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__recorder_stop__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __recorder_stop__ (@var{recorder})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__recorder_stop__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__recorder_stop__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     get_recorder (args(0))->stop ();
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_audioplayer__, args, ,
@@ -2183,19 +2183,19 @@ DEFUN_DLD (__player_audioplayer__, args,
 @deftypefn  {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs})\n\
 @deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits})\n\
 @deftypefnx {} {@var{player} =} __player_audioplayer__ (@var{y}, @var{fs}, @var{nbits}, @var{id})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_audioplayer__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_audioplayer__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
 
   int nargin = args.length ();
 
   audioplayer* recorder = new audioplayer ();
 
   if (! recorder)
     error ("__player_audioplayer__: Couldn't instantiate new audioplayer");
@@ -2252,199 +2252,199 @@ get_player (const octave_value& ov)
 DEFUN_DLD (__player_get_channels__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_channels__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_channels__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_channels__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_channels ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{fs} =} __player_get_fs__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_fs__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_fs__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_fs ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_id__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{id} =} __player_get_id__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_id__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_id__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_id ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_nbits__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{nbits} =} __player_get_nbits__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_nbits__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_nbits__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_nbits ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_sample_number__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_sample_number__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_sample_number__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_sample_number__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_sample_number ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{tag} =} __player_get_tag__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_tag__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_tag__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_tag ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_total_samples__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} __player_get_total_samples__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_total_samples__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_total_samples__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_total_samples ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_get_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{data} =} __player_get_userdata__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_get_userdata__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_get_userdata__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->get_userdata ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_isplaying__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_isplaying__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_isplaying__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_isplaying__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     retval = get_player (args(0))->isplaying ();
 #endif
   return retval;
 }
 
 DEFUN_DLD (__player_pause__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_pause__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_pause__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_pause__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     get_player (args(0))->pause ();
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_playblocking__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __player_playblocking__ (@var{player})\n\
 @deftypefnx {} {} __player_playblocking__ (@var{player}, @var{start})\n\
 @deftypefnx {} {} __player_playblocking__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_playblocking__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_playblocking__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
 
   audioplayer *player = get_player (args(0));
 
   if (args.length () == 1)
     {
       player->playblocking ();
     }
@@ -2486,19 +2486,19 @@ DEFUN_DLD (__player_play__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {} __player_play__ (@var{player})\n\
 @deftypefnx {} {} __player_play__ (@var{player}, @var{start})\n\
 @deftypefnx {} {} __player_play__ (@var{player}, [@var{start}, @var{end}])\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_play__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_play__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
 
   if (args.length () == 1)
     {
       get_player (args(0))->play ();
     }
   else if (args.length () == 2)
     {
@@ -2538,85 +2538,85 @@ Undocumented internal function.\n\
 
 DEFUN_DLD (__player_resume__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_resume__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_resume__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_resume__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     get_player (args(0))->resume ();
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_set_fs__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_fs__ (@var{player}, @var{fs})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_set_fs__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_set_fs__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_fs (args(1).int_value ());
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_set_tag__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_tag__ (@var{player}, @var{tag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_set_tag__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_set_tag__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_tag (args(1).char_matrix_value ());
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_set_userdata__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_set_userdata__ (@var{player}, @var{data})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_set_userdata__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_set_userdata__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 2)
     get_player (args(0))->set_userdata (args(1));
 #endif
   return octave_value ();
 }
 
 DEFUN_DLD (__player_stop__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {} __player_stop__ (@var{player})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifndef HAVE_PORTAUDIO
-  gripe_disabled_feature ("__player_stop__",
-                          "audio playback and recording through PortAudio",
-                          "Octave");
+  err_disabled_feature ("__player_stop__",
+                        "audio playback and recording through PortAudio",
+                        "Octave");
 #else
   if (args.length () == 1)
     get_player (args(0))->stop ();
 #endif
   return octave_value ();
 }
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 #include <map>
 
 #include "oct-locbuf.h"
 #include "unwind-prot.h"
 
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-struct.h"
 
 #ifdef HAVE_SNDFILE
 #include <sndfile.h>
 #endif
 
@@ -167,18 +167,18 @@ is stored in the audio file.\n\
         ret_audio = audio;
     }
   else
     ret_audio = audio;
 
   return ovl (ret_audio, info.samplerate);
 
 #else
-  gripe_disabled_feature ("audioread", "reading and writing sound files"
-                          " through libsndfile", "Octave");
+  err_disabled_feature ("audioread", "reading and writing sound files"
+                        " through libsndfile", "Octave");
 #endif
 }
 
 #ifdef HAVE_SNDFILE
 
 static int
 extension_to_format (const std::string& ext)
 {
@@ -272,17 +272,17 @@ Comment.\n\
   if (args(1).is_uint8_type ())
     bias = scale = std::pow (2.0, 7);
   else if (args(1).is_int16_type ())
     scale = std::pow (2.0, 15);
   else if (args(1).is_int32_type ())
     scale = std::pow (2.0, 31);
   else if (args(1).is_integer_type ())
     {
-      gripe_wrong_type_arg ("audiowrite", args(1));
+      err_wrong_type_arg ("audiowrite", args(1));
       return ovl ();
     }
 
   Matrix audio = args(1).matrix_value ();
 
   int samplerate = args(2).int_value ();
 
   std::string ext;
@@ -415,18 +415,18 @@ Comment.\n\
       offset += chunk_size;
     }
 
   // FIXME: shouldn't we return something to indicate whether the file
   // was written successfully?
   return ovl ();
 
 #else
-  gripe_disabled_feature ("audiowrite", "reading and writing sound files"
-                          " through libsndfile", "Octave");
+  err_disabled_feature ("audiowrite", "reading and writing sound files"
+                        " through libsndfile", "Octave");
 #endif
 }
 
 DEFUN_DLD (audioinfo, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {} {@var{info} =} audioinfo (@var{filename})\n\
 Return information about an audio file specified by @var{filename}.\n\
 @end deftypefn")
@@ -487,12 +487,12 @@ Return information about an audio file s
   result.assign ("BitRate", -1);
   result.assign ("Title", sf_get_string (file, SF_STR_TITLE));
   result.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
   result.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
 
   return ovl (result);
 
 #else
-  gripe_disabled_feature ("audioinfo", "reading and writing sound files"
-                          " through libsndfile", "Octave");
+  err_disabled_feature ("audioinfo", "reading and writing sound files"
+                        " through libsndfile", "Octave");
 #endif
 }
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "SparsedbleCHOL.h"
 #include "oct-spparms.h"
 #include "sparse-util.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <class CHOLT>
 static octave_value
 get_chol (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix());
@@ -236,17 +236,17 @@ sparse matrices.\n\
                 retval(0) = fact.L ();
               else
                 retval(0) = fact.R ();
             }
           else
             error ("chol: input matrix must be positive definite");
         }
       else
-        gripe_wrong_type_arg ("chol", arg);
+        err_wrong_type_arg ("chol", arg);
     }
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           octave_idx_type info;
@@ -269,17 +269,17 @@ sparse matrices.\n\
           fact = FloatComplexCHOL (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
-        gripe_wrong_type_arg ("chol", arg);
+        err_wrong_type_arg ("chol", arg);
     }
   else
     {
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           octave_idx_type info;
@@ -302,17 +302,17 @@ sparse matrices.\n\
           fact = ComplexCHOL (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
-        gripe_wrong_type_arg ("chol", arg);
+        err_wrong_type_arg ("chol", arg);
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
 %!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
@@ -372,17 +372,17 @@ the Cholesky@tie{}factorization.\n\
               SparseComplexCHOL chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
-            gripe_wrong_type_arg ("cholinv", arg);
+            err_wrong_type_arg ("cholinv", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               octave_idx_type info;
@@ -399,17 +399,17 @@ the Cholesky@tie{}factorization.\n\
               octave_idx_type info;
               FloatComplexCHOL chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
-            gripe_wrong_type_arg ("chol", arg);
+            err_wrong_type_arg ("chol", arg);
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
               octave_idx_type info;
@@ -426,17 +426,17 @@ the Cholesky@tie{}factorization.\n\
               octave_idx_type info;
               ComplexCHOL chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
-            gripe_wrong_type_arg ("chol", arg);
+            err_wrong_type_arg ("chol", arg);
         }
     }
 
   return retval;
 }
 
 /*
 %!shared A, Ainv
@@ -489,34 +489,34 @@ diagonal elements.  @code{chol2inv (@var
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
               retval = chol2inv (r);
             }
           else
-            gripe_wrong_type_arg ("chol2inv", arg);
+            err_wrong_type_arg ("chol2inv", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix r = arg.float_matrix_value ();
 
               retval = chol2inv (r);
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix r = arg.float_complex_matrix_value ();
 
               retval = chol2inv (r);
             }
           else
-            gripe_wrong_type_arg ("chol2inv", arg);
+            err_wrong_type_arg ("chol2inv", arg);
 
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix r = arg.matrix_value ();
 
@@ -524,17 +524,17 @@ diagonal elements.  @code{chol2inv (@var
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix r = arg.complex_matrix_value ();
 
               retval = chol2inv (r);
             }
           else
-            gripe_wrong_type_arg ("chol2inv", arg);
+            err_wrong_type_arg ("chol2inv", arg);
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
            "-*- texinfo -*-\n\
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 #include "oct-sparse.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 
 #include "oct-fftw.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 
 DEFUN_DLD (fftw, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{method} =} fftw (\"planner\")\n\
 @deftypefnx {} {} fftw (\"planner\", @var{method})\n\
 @deftypefnx {} {@var{wisdom} =} fftw (\"dwisdom\")\n\
 @deftypefnx {} {} fftw (\"dwisdom\", @var{wisdom})\n\
 @deftypefnx {} {} fftw (\"threads\", @var{nthreads})\n\
@@ -289,39 +289,39 @@ used per default.\n\
 
           int nthreads = args(1).int_value();
           if (nthreads < 1)
             error ("fftw: number of threads must be >=1");
 
 #if defined (HAVE_FFTW3_THREADS)
           octave_fftw_planner::threads (nthreads);
 #else
-          gripe_disabled_feature ("fftw", "multithreaded FFTW");
+          err_disabled_feature ("fftw", "multithreaded FFTW");
 #endif
 #if defined (HAVE_FFTW3F_THREADS)
           octave_float_fftw_planner::threads (nthreads);
 #else
-          gripe_disabled_feature ("fftw", "multithreaded FFTW");
+          err_disabled_feature ("fftw", "multithreaded FFTW");
 #endif
         }
       else //threads getter
 #if defined (HAVE_FFTW3_THREADS)
         retval = octave_value (octave_fftw_planner::threads());
 #else
       retval = 1;
 #endif
     }
   else
     error ("fftw: unrecognized argument");
 
   return retval;
 
 #else
 
-  gripe_disabled_feature ("fftw", "the FFTW3 planner");
+  err_disabled_feature ("fftw", "the FFTW3 planner");
 
 #endif
 }
 
 /*
 %!testif HAVE_FFTW
 %! def_method = fftw ("planner");
 %! unwind_protect
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "floatQR.h"
 #include "floatQRP.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 
 
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 template <class MT>
 static octave_value
 get_qr_r (const base_qr<MT>& fact)
 {
   MT R = fact.R ();
@@ -405,17 +405,17 @@ x = @var{R} \\ @var{C}\n\
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else
-            gripe_wrong_type_arg ("qr", arg);
+            err_wrong_type_arg ("qr", arg);
         }
     }
 
   return retval;
 }
 
 /*
 %!test
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "oct-spparms.h"
 #include "sparse-util.h"
 #include "oct-locbuf.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 DEFUN_DLD (symbfact, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
 @deftypefnx {} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
 @deftypefnx {} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
@@ -162,17 +162,17 @@ factorization as determined by @var{typ}
       A->i = a.ridx ();
       A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_COMPLEX;
 
       if (a.rows () > 0 && a.cols () > 0)
         A->x = a.data ();
     }
   else
-    gripe_wrong_type_arg ("symbfact", args(0));
+    err_wrong_type_arg ("symbfact", args(0));
 
   octave_idx_type coletree = false;
   octave_idx_type n = A->nrow;
 
   if (nargin > 1)
     {
       char ch;
       std::string str = args(1).string_value ();
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -52,17 +52,17 @@ Written by Michael Weitzel <michael.weit
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "ov.h"
 #include "defun-dld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "utils.h"
 #include "oct-locbuf.h"
 
 #include "ov-re-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "oct-sparse.h"
 
@@ -464,17 +464,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       cidx = Ac.xcidx ();
       ridx = Ac.xridx ();
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
-    gripe_square_matrix_required ("symrcm");
+    err_square_matrix_required ("symrcm");
 
   if (nr == 0 && nc == 0)
     return ovl (NDArray (dim_vector (1, 0)));
 
   // sizes of the heaps
   octave_idx_type s = 0;
 
   // head- and tail-indices for the queue
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 
 #include "ov-base-diag.h"
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "pr-output.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-stream.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 
 template <class DMT, class MT>
 octave_value
 octave_base_diag<DMT, MT>::subsref (const std::string& type,
@@ -292,94 +292,94 @@ template <class T> inline T helper_iscom
 template <class DMT, class MT>
 double
 octave_base_diag<DMT, MT>::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real scalar");
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "real scalar");
 
       retval = helper_getreal (el_type (matrix (0, 0)));
     }
   else
-    gripe_invalid_conversion (type_name (), "real scalar");
+    err_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
 
 template <class DMT, class MT>
 float
 octave_base_diag<DMT, MT>::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real scalar");
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "real scalar");
 
       retval = helper_getreal (el_type (matrix (0, 0)));
     }
   else
-    gripe_invalid_conversion (type_name (), "real scalar");
+    err_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
 
 template <class DMT, class MT>
 Complex
 octave_base_diag<DMT, MT>::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "complex scalar");
+    err_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
 
 template <class DMT, class MT>
 FloatComplex
 octave_base_diag<DMT, MT>::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "complex scalar");
+    err_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
 
 template <class DMT, class MT>
 Matrix
 octave_base_diag<DMT, MT>::matrix_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -256,17 +256,17 @@ octave_base_matrix<MT>::assign (const oc
 
               matrix.assign (idx_vec, rhs);
             }
             break;
         }
     }
   catch (const index_exception& e)
     {
-      gripe_invalid_index (e.idx (), n_idx, k+1);
+      err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <class MT>
 MatrixType
@@ -360,17 +360,17 @@ octave_base_matrix<MT>::assign (const oc
             else
               matrix.assign (idx_vec, mrhs);
           }
           break;
         }
     }
   catch (const index_exception& e)
     {
-      gripe_invalid_index (e.idx (), n_idx, k+1);
+      err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <class MT>
 void
@@ -409,17 +409,17 @@ octave_base_matrix<MT>::is_true (void) c
   dim_vector dv = matrix.dims ();
   int nel = dv.numel ();
 
   if (nel > 0)
     {
       MT t1 (matrix.reshape (dim_vector (nel, 1)));
 
       if (t1.any_element_is_nan ())
-        gripe_nan_to_logical_conversion ();
+        err_nan_to_logical_conversion ();
       else
         {
           boolNDArray t2 = t1.all ();
 
           retval = t2(0);
         }
     }
 
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -129,17 +129,17 @@ octave_base_scalar<ST>::diag (octave_idx
 
 template <class ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
   bool retval = false;
 
   if (xisnan (scalar))
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else
     retval = (scalar != ST ());
 
   return retval;
 }
 
 template <class ST>
 void
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 
 #include "boolSparse.h"
 #include "ov-base-sparse.h"
 #include "octave-preserve-stream-state.h"
 #include "pager.h"
 #include "utils.h"
 
-#include "lo-array-gripes.h"
+#include "lo-array-errwarn.h"
 
 template <class T>
 octave_value
 octave_base_sparse<T>::do_index_op (const octave_value_list& idx,
                                     bool resize_ok)
 {
   octave_value retval;
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
@@ -128,17 +128,17 @@ octave_base_value::squeeze (void) const
 {
   std::string nm = type_name ();
   error ("squeeze: invalid operation for %s type", nm.c_str ());
 }
 
 octave_value
 octave_base_value::full_value (void) const
 {
-  gripe_wrong_type_arg ("full: invalid operation for %s type", type_name ());
+  err_wrong_type_arg ("full: invalid operation for %s type", type_name ());
   return octave_value ();
 }
 
 Matrix
 octave_base_value::size (void)
 {
   const dim_vector dv = dims ();
   Matrix mdv (1, dv.length ());
@@ -209,17 +209,17 @@ octave_base_value::do_multi_index_op (in
   // Fall back.
   return do_multi_index_op (nargout, idx);
 }
 
 idx_vector
 octave_base_value::index_vector (bool /* require_integers */) const
 {
   std::string nm = "<" + type_name () + ">";
-  gripe_invalid_index (nm.c_str ());
+  err_invalid_index (nm.c_str ());
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              const octave_value& rhs)
 {
   octave_value retval;
@@ -292,65 +292,65 @@ octave_base_value::undef_subsasgn (const
   // exception is octave_class objects.
 
   return subsasgn (type, idx, rhs);
 }
 
 octave_idx_type
 octave_base_value::nnz (void) const
 {
-  gripe_wrong_type_arg ("octave_base_value::nnz ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::nnz ()", type_name ());
   return -1;
 }
 
 octave_idx_type
 octave_base_value::nzmax (void) const
 {
   return numel ();
 }
 
 octave_idx_type
 octave_base_value::nfields (void) const
 {
-  gripe_wrong_type_arg ("octave_base_value::nfields ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::nfields ()", type_name ());
   return -1;
 }
 
 octave_value
 octave_base_value::reshape (const dim_vector&) const
 {
-  gripe_wrong_type_arg ("octave_base_value::reshape ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::reshape ()", type_name ());
   return octave_value ();
 }
 
 octave_value
 octave_base_value::permute (const Array<int>&, bool) const
 {
-  gripe_wrong_type_arg ("octave_base_value::permute ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::permute ()", type_name ());
   return octave_value ();
 }
 
 octave_value
 octave_base_value::resize (const dim_vector&, bool) const
 {
-  gripe_wrong_type_arg ("octave_base_value::resize ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::resize ()", type_name ());
   return octave_value ();
 }
 
 MatrixType
 octave_base_value::matrix_type (void) const
 {
-  gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
   return MatrixType ();
 }
 
 MatrixType
 octave_base_value::matrix_type (const MatrixType&) const
 {
-  gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
   return MatrixType ();
 }
 
 octave_value
 octave_base_value::all (int) const
 {
   return 0.0;
 }
@@ -362,47 +362,47 @@ octave_base_value::any (int) const
 }
 
 octave_value
 octave_base_value::convert_to_str (bool pad, bool force, char type) const
 {
   octave_value retval = convert_to_str_internal (pad, force, type);
 
   if (! force && is_numeric_type ())
-    gripe_implicit_conversion ("Octave:num-to-str",
-                               type_name (), retval.type_name ());
+    warn_implicit_conversion ("Octave:num-to-str",
+                              type_name (), retval.type_name ());
 
   return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
 {
-  gripe_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::convert_to_str_internal ()",
+                      type_name ());
   return octave_value ();
 }
 
 void
 octave_base_value::convert_to_row_or_column_vector (void)
 {
-  gripe_wrong_type_arg
+  err_wrong_type_arg
     ("octave_base_value::convert_to_row_or_column_vector ()", type_name ());
 }
 
 void
 octave_base_value::print (std::ostream&, bool)
 {
-  gripe_wrong_type_arg ("octave_base_value::print ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::print ()", type_name ());
 }
 
 void
 octave_base_value::print_raw (std::ostream&, bool) const
 {
-  gripe_wrong_type_arg ("octave_base_value::print_raw ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::print_raw ()", type_name ());
 }
 
 bool
 octave_base_value::print_name_tag (std::ostream& os,
                                    const std::string& name) const
 {
   bool retval = false;
 
@@ -452,17 +452,17 @@ octave_base_value::print_info (std::ostr
     double d = 0.0; \
  \
     try \
       { \
         d = double_value (frc_str_conv); \
       } \
     catch (octave_execution_exception& e) \
       { \
-        gripe_wrong_type_arg (e, "octave_base_value::" #F "_value ()", type_name ()); \
+        err_wrong_type_arg (e, "octave_base_value::" #F "_value ()", type_name ()); \
       } \
  \
     if (require_int && D_NINT (d) != d) \
       error_with_cfn ("conversion of %g to " #T " value failed", d); \
     else if (d < std::numeric_limits<T>::min ()) \
       retval = std::numeric_limits<T>::min (); \
     else if (d > std::numeric_limits<T>::max ()) \
       retval = std::numeric_limits<T>::max (); \
@@ -490,160 +490,160 @@ octave_base_value::nint_value (bool frc_
   double d = 0.0;
 
   try
     {
       d = double_value (frc_str_conv);
     }
   catch (octave_execution_exception& e)
     {
-      gripe_wrong_type_arg (e, "octave_base_value::nint_value ()", type_name ());
+      err_wrong_type_arg (e, "octave_base_value::nint_value ()", type_name ());
     }
 
   if (xisnan (d))
     error ("conversion of NaN to integer value failed");
 
   return static_cast<int> (::fix (d));
 }
 
 double
 octave_base_value::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
-  gripe_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::double_value ()", type_name ());
   return retval;
 }
 
 float
 octave_base_value::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
-  gripe_wrong_type_arg ("octave_base_value::float_value ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::float_value ()", type_name ());
   return retval;
 }
 
 Cell
 octave_base_value::cell_value () const
 {
   Cell retval;
-  gripe_wrong_type_arg ("octave_base_value::cell_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::cell_value()", type_name ());
   return retval;
 }
 
 Matrix
 octave_base_value::matrix_value (bool) const
 {
   Matrix retval;
-  gripe_wrong_type_arg ("octave_base_value::matrix_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::matrix_value()", type_name ());
   return retval;
 }
 
 FloatMatrix
 octave_base_value::float_matrix_value (bool) const
 {
   FloatMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 NDArray
 octave_base_value::array_value (bool) const
 {
   FloatNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::array_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::array_value()", type_name ());
   return retval;
 }
 
 FloatNDArray
 octave_base_value::float_array_value (bool) const
 {
   FloatNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::float_array_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::float_array_value()", type_name ());
   return retval;
 }
 
 Complex
 octave_base_value::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
   Complex retval (tmp, tmp);
-  gripe_wrong_type_arg ("octave_base_value::complex_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::complex_value()", type_name ());
   return retval;
 }
 
 FloatComplex
 octave_base_value::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
   FloatComplex retval (tmp, tmp);
-  gripe_wrong_type_arg ("octave_base_value::float_complex_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_complex_value()",
+                      type_name ());
   return retval;
 }
 
 ComplexMatrix
 octave_base_value::complex_matrix_value (bool) const
 {
   ComplexMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::complex_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::complex_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 FloatComplexMatrix
 octave_base_value::float_complex_matrix_value (bool) const
 {
   FloatComplexMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_complex_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_complex_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 ComplexNDArray
 octave_base_value::complex_array_value (bool) const
 {
   ComplexNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::complex_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::complex_array_value()",
+                      type_name ());
   return retval;
 }
 
 FloatComplexNDArray
 octave_base_value::float_complex_array_value (bool) const
 {
   FloatComplexNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::float_complex_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_complex_array_value()",
+                      type_name ());
   return retval;
 }
 
 bool
 octave_base_value::bool_value (bool) const
 {
   bool retval = false;
-  gripe_wrong_type_arg ("octave_base_value::bool_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::bool_value()", type_name ());
   return retval;
 }
 
 boolMatrix
 octave_base_value::bool_matrix_value (bool) const
 {
   boolMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::bool_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::bool_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 boolNDArray
 octave_base_value::bool_array_value (bool) const
 {
   boolNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::bool_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::bool_array_value()",
+                      type_name ());
   return retval;
 }
 
 charMatrix
 octave_base_value::char_matrix_value (bool force) const
 {
   charMatrix retval;
 
@@ -653,232 +653,232 @@ octave_base_value::char_matrix_value (bo
 
   return retval;
 }
 
 charNDArray
 octave_base_value::char_array_value (bool) const
 {
   charNDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::char_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::char_array_value()",
+                      type_name ());
   return retval;
 }
 
 SparseMatrix
 octave_base_value::sparse_matrix_value (bool) const
 {
   SparseMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::sparse_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 SparseComplexMatrix
 octave_base_value::sparse_complex_matrix_value (bool) const
 {
   SparseComplexMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_complex_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::sparse_complex_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 SparseBoolMatrix
 octave_base_value::sparse_bool_matrix_value (bool) const
 {
   SparseBoolMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_bool_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::sparse_bool_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 DiagMatrix
 octave_base_value::diag_matrix_value (bool) const
 {
   DiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::diag_matrix_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::diag_matrix_value()", type_name ());
   return retval;
 }
 
 FloatDiagMatrix
 octave_base_value::float_diag_matrix_value (bool) const
 {
   FloatDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_diag_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_diag_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 ComplexDiagMatrix
 octave_base_value::complex_diag_matrix_value (bool) const
 {
   ComplexDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::complex_diag_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::complex_diag_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 FloatComplexDiagMatrix
 octave_base_value::float_complex_diag_matrix_value (bool) const
 {
   FloatComplexDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_complex_diag_matrix_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::float_complex_diag_matrix_value()",
+                      type_name ());
   return retval;
 }
 
 PermMatrix
 octave_base_value::perm_matrix_value (void) const
 {
   PermMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::perm_matrix_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::perm_matrix_value()", type_name ());
   return retval;
 }
 
 octave_int8
 octave_base_value::int8_scalar_value (void) const
 {
   octave_int8 retval;
-  gripe_wrong_type_arg ("octave_base_value::int8_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int8_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_int16
 octave_base_value::int16_scalar_value (void) const
 {
   octave_int16 retval;
-  gripe_wrong_type_arg ("octave_base_value::int16_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int16_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_int32
 octave_base_value::int32_scalar_value (void) const
 {
   octave_int32 retval;
-  gripe_wrong_type_arg ("octave_base_value::int32_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int32_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_int64
 octave_base_value::int64_scalar_value (void) const
 {
   octave_int64 retval;
-  gripe_wrong_type_arg ("octave_base_value::int64_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int64_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_uint8
 octave_base_value::uint8_scalar_value (void) const
 {
   octave_uint8 retval;
-  gripe_wrong_type_arg ("octave_base_value::uint8_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint8_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_uint16
 octave_base_value::uint16_scalar_value (void) const
 {
   octave_uint16 retval;
-  gripe_wrong_type_arg ("octave_base_value::uint16_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint16_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_uint32
 octave_base_value::uint32_scalar_value (void) const
 {
   octave_uint32 retval;
-  gripe_wrong_type_arg ("octave_base_value::uint32_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint32_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 octave_uint64
 octave_base_value::uint64_scalar_value (void) const
 {
   octave_uint64 retval;
-  gripe_wrong_type_arg ("octave_base_value::uint64_scalar_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint64_scalar_value()",
+                      type_name ());
   return retval;
 }
 
 int8NDArray
 octave_base_value::int8_array_value (void) const
 {
   int8NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::int8_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int8_array_value()",
+                      type_name ());
   return retval;
 }
 
 int16NDArray
 octave_base_value::int16_array_value (void) const
 {
   int16NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::int16_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int16_array_value()",
+                      type_name ());
   return retval;
 }
 
 int32NDArray
 octave_base_value::int32_array_value (void) const
 {
   int32NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::int32_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int32_array_value()",
+                      type_name ());
   return retval;
 }
 
 int64NDArray
 octave_base_value::int64_array_value (void) const
 {
   int64NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::int64_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::int64_array_value()",
+                      type_name ());
   return retval;
 }
 
 uint8NDArray
 octave_base_value::uint8_array_value (void) const
 {
   uint8NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::uint8_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint8_array_value()",
+                      type_name ());
   return retval;
 }
 
 uint16NDArray
 octave_base_value::uint16_array_value (void) const
 {
   uint16NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::uint16_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint16_array_value()",
+                      type_name ());
   return retval;
 }
 
 uint32NDArray
 octave_base_value::uint32_array_value (void) const
 {
   uint32NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::uint32_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint32_array_value()",
+                      type_name ());
   return retval;
 }
 
 uint64NDArray
 octave_base_value::uint64_array_value (void) const
 {
   uint64NDArray retval;
-  gripe_wrong_type_arg ("octave_base_value::uint64_array_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::uint64_array_value()",
+                      type_name ());
   return retval;
 }
 
 string_vector
 octave_base_value::string_vector_value (bool pad) const
 {
   string_vector retval;
 
@@ -908,34 +908,34 @@ octave_base_value::xstring_value (void) 
   wrong_type_arg_error ();
   return retval;
 }
 
 Array<std::string>
 octave_base_value::cellstr_value (void) const
 {
   Array<std::string> retval;
-  gripe_wrong_type_arg ("octave_base_value::cellstr_value()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::cellstr_value()",
+                      type_name ());
   return retval;
 }
 
 Range
 octave_base_value::range_value (void) const
 {
   Range retval;
-  gripe_wrong_type_arg ("octave_base_value::range_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::range_value()", type_name ());
   return retval;
 }
 
 octave_map
 octave_base_value::map_value (void) const
 {
   octave_map retval;
-  gripe_wrong_type_arg ("octave_base_value::map_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::map_value()", type_name ());
   return retval;
 }
 
 octave_scalar_map
 octave_base_value::scalar_map_value (void) const
 {
   octave_map tmp = map_value ();
 
@@ -944,233 +944,233 @@ octave_base_value::scalar_map_value (voi
 
   return octave_scalar_map (tmp.checkelem (0));
 }
 
 string_vector
 octave_base_value::map_keys (void) const
 {
   string_vector retval;
-  gripe_wrong_type_arg ("octave_base_value::map_keys()", type_name ());
+  err_wrong_type_arg ("octave_base_value::map_keys()", type_name ());
   return retval;
 }
 
 size_t
 octave_base_value::nparents (void) const
 {
   size_t retval = 0;
-  gripe_wrong_type_arg ("octave_base_value::nparents()", type_name ());
+  err_wrong_type_arg ("octave_base_value::nparents()", type_name ());
   return retval;
 }
 
 std::list<std::string>
 octave_base_value::parent_class_name_list (void) const
 {
   std::list<std::string> retval;
-  gripe_wrong_type_arg ("octave_base_value::parent_class_name_list()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::parent_class_name_list()",
+                      type_name ());
   return retval;
 }
 
 string_vector
 octave_base_value::parent_class_names (void) const
 {
   string_vector retval;
-  gripe_wrong_type_arg ("octave_base_value::parent_class_names()",
-                        type_name ());
+  err_wrong_type_arg ("octave_base_value::parent_class_names()",
+                      type_name ());
   return retval;
 }
 
 octave_function *
 octave_base_value::function_value (bool silent)
 {
   octave_function *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::function_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::function_value()",
+                        type_name ());
   return retval;
 }
 
 octave_user_function *
 octave_base_value::user_function_value (bool silent)
 {
   octave_user_function *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::user_function_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::user_function_value()",
+                        type_name ());
   return retval;
 }
 
 octave_user_script *
 octave_base_value::user_script_value (bool silent)
 {
   octave_user_script *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::user_script_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::user_script_value()",
+                        type_name ());
   return retval;
 }
 
 octave_user_code *
 octave_base_value::user_code_value (bool silent)
 {
   octave_user_code *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::user_code_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::user_code_value()",
+                        type_name ());
   return retval;
 }
 
 octave_fcn_handle *
 octave_base_value::fcn_handle_value (bool silent)
 {
   octave_fcn_handle *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::fcn_handle_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::fcn_handle_value()",
+                        type_name ());
   return retval;
 }
 
 octave_fcn_inline *
 octave_base_value::fcn_inline_value (bool silent)
 {
   octave_fcn_inline *retval = 0;
 
   if (! silent)
-    gripe_wrong_type_arg ("octave_base_value::fcn_inline_value()",
-                          type_name ());
+    err_wrong_type_arg ("octave_base_value::fcn_inline_value()",
+                        type_name ());
   return retval;
 }
 
 octave_value_list
 octave_base_value::list_value (void) const
 {
   octave_value_list retval;
-  gripe_wrong_type_arg ("octave_base_value::list_value()", type_name ());
+  err_wrong_type_arg ("octave_base_value::list_value()", type_name ());
   return retval;
 }
 
 bool
 octave_base_value::save_ascii (std::ostream&)
 {
-  gripe_wrong_type_arg ("octave_base_value::save_ascii()", type_name ());
+  err_wrong_type_arg ("octave_base_value::save_ascii()", type_name ());
   return false;
 }
 
 bool
 octave_base_value::load_ascii (std::istream&)
 {
-  gripe_wrong_type_arg ("octave_base_value::load_ascii()", type_name ());
+  err_wrong_type_arg ("octave_base_value::load_ascii()", type_name ());
   return false;
 }
 
 bool
 octave_base_value::save_binary (std::ostream&, bool&)
 {
-  gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
+  err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
   return false;
 }
 
 bool
 octave_base_value::load_binary (std::istream&, bool,
                                 oct_mach_info::float_format)
 {
-  gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
+  err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
   return false;
 }
 
 bool
 octave_base_value::save_hdf5 (octave_hdf5_id, const char *, bool)
 {
-  gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
+  err_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
 
   return false;
 }
 
 bool
 octave_base_value::load_hdf5 (octave_hdf5_id, const char *)
 {
-  gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
+  err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 
   return false;
 }
 
 int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
                           int, oct_mach_info::float_format) const
 {
-  gripe_wrong_type_arg ("octave_base_value::write()", type_name ());
+  err_wrong_type_arg ("octave_base_value::write()", type_name ());
 
   return false;
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
 {
   return 0;
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type) const
 {
-  gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
   return octave_value ();
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type, octave_idx_type) const
 {
-  gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
   return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
-  gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (Array<octave_idx_type> &,
                          octave_idx_type, sortmode) const
 {
-  gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value ();
 }
 
 sortmode
 octave_base_value::is_sorted (sortmode) const
 {
-  gripe_wrong_type_arg ("octave_base_value::is_sorted ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::is_sorted ()", type_name ());
 
   return UNSORTED;
 }
 
 Array<octave_idx_type>
 octave_base_value::sort_rows_idx (sortmode) const
 {
-  gripe_wrong_type_arg ("octave_base_value::sort_rows_idx ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::sort_rows_idx ()", type_name ());
 
   return Array<octave_idx_type> ();
 }
 
 sortmode
 octave_base_value::is_sorted_rows (sortmode) const
 {
-  gripe_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
 
   return UNSORTED;
 }
 
 
 const char *
 octave_base_value::get_umap_name (unary_mapper_t umap)
 {
@@ -1261,35 +1261,35 @@ octave_base_value::gripe_save (const cha
     ("Octave:load-save-unavailable",
      "%s: saving %s files not available in this version of Octave",
      t_name.c_str (), type);
 }
 
 void
 octave_base_value::wrong_type_arg_error (void) const
 {
-  gripe_wrong_type_arg (type_name ());
+  err_wrong_type_arg (type_name ());
 }
 
 octave_value
 octave_base_value::map (unary_mapper_t umap) const
 {
   error ("%s: not defined for %s", get_umap_name (umap), type_name ().c_str ());
 }
 
 void
 octave_base_value::lock (void)
 {
-  gripe_wrong_type_arg ("octave_base_value::lock ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::lock ()", type_name ());
 }
 
 void
 octave_base_value::unlock (void)
 {
-  gripe_wrong_type_arg ("octave_base_value::unlock ()", type_name ());
+  err_wrong_type_arg ("octave_base_value::unlock ()", type_name ());
 }
 
 void
 octave_base_value::dump (std::ostream& os) const
 {
   dim_vector dv = this->dims ();
 
   os << "class: " << this->class_name ()
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 #include <vector>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-bool.h"
@@ -93,81 +93,81 @@ octave_bool_matrix::try_narrowing_conver
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "bool matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool matrix", "real scalar");
+    err_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_bool_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "bool matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "bool matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool matrix", "real scalar");
+    err_invalid_conversion ("bool matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "bool matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool matrix", "complex scalar");
+    err_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_bool_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "bool matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "bool matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool matrix", "complex scalar");
+    err_invalid_conversion ("bool matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_bool_matrix::convert_to_str_internal (bool pad, bool force,
                                              char type) const
 {
@@ -554,17 +554,17 @@ Compatibility Note: Octave accepts compl
       if (arg.is_sparse_type ())
         retval = arg.sparse_bool_matrix_value ();
       else if (arg.is_scalar_type ())
         retval = arg.bool_value ();
       else
         retval = arg.bool_array_value ();
     }
   else
-    gripe_wrong_type_arg ("logical", arg);
+    err_wrong_type_arg ("logical", arg);
 
   return retval;
 }
 
 /*
 %!test
 %! m = eye (2) != 0;
 %! s = ! 0;
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "dim-vector.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ops.h"
 #include "oct-locbuf.h"
 
 #include "oct-hdf5.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
@@ -100,44 +100,44 @@ octave_sparse_bool_matrix::try_narrowing
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "bool sparse matrix", "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "bool sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool sparse matrix", "real scalar");
+    err_invalid_conversion ("bool sparse matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_sparse_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "bool sparse matrix", "complex scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "bool sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
+    err_invalid_conversion ("bool sparse matrix", "complex scalar");
 
   return retval;
 }
 
 octave_value
 octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force,
                                                     char type) const
 {
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "mx-base.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "oct-hdf5.h"
 #include "ovl.h"
 #include "ops.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-builtin.h"
 #include "ov.h"
 #include "profiler.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 #include "ov-scalar.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 #include "ls-hdf5.h"
 #include "ls-utils.h"
 
 // Cell is able to handle octave_value indexing by itself, so just forward
 // everything.
@@ -299,17 +299,17 @@ octave_cell::subsasgn (const std::string
                   }
                 else
                   // optimization: ignore copy still stored inside array.
                   tmp.make_unique (1);
 
                 t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
               }
             else
-              gripe_indexed_cs_list ();
+              err_indexed_cs_list ();
           }
           break;
 
         case '.':
           {
             if (! is_empty ())
               {
                 std::string nm = type_name ();
@@ -364,17 +364,17 @@ octave_cell::subsasgn (const std::string
             octave_base_matrix<Cell>::assign (idxf, tmp_cell);
           }
         else if (idxf.all_scalars ()
                  || do_index_op (idxf, true).numel () == 1)
           // Regularize a null matrix if stored into a cell.
           octave_base_matrix<Cell>::assign (idxf,
                                             Cell (t_rhs.storable_value ()));
         else
-          gripe_nonbraced_cs_list_assignment ();
+          err_nonbraced_cs_list_assignment ();
 
         count++;
         retval = octave_value (this);
       }
       break;
 
     case '.':
       {
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "mx-base.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-ch-mat.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "pr-output.h"
 
 template class octave_base_matrix<charNDArray>;
 
 idx_vector
 octave_char_matrix::index_vector (bool /* require_integers */) const
 {
   const char *p = matrix.data ();
@@ -53,117 +53,117 @@ octave_char_matrix::index_vector (bool /
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "real scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "real scalar");
+    err_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_char_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "real scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "real scalar");
+    err_invalid_conversion ("character matrix", "real scalar");
 
   return retval;
 }
 
 octave_int64
 octave_char_matrix::int64_scalar_value () const
 {
   octave_int64 retval = 0;
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "int64 scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "int64 scalar");
 
       retval = octave_int64 (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "int64 scalar");
+    err_invalid_conversion ("character matrix", "int64 scalar");
 
   return retval;
 }
 
 octave_uint64
 octave_char_matrix::uint64_scalar_value () const
 {
   octave_uint64 retval = 0;
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "uint64 scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "uint64 scalar");
 
       retval = octave_uint64 (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "uint64 scalar");
+    err_invalid_conversion ("character matrix", "uint64 scalar");
 
   return retval;
 }
 
 Complex
 octave_char_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "complex scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "complex scalar");
+    err_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_char_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "character matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "character matrix", "complex scalar");
 
       retval = static_cast<unsigned char> (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("character matrix", "complex scalar");
+    err_invalid_conversion ("character matrix", "complex scalar");
 
   return retval;
 }
 
 void
 octave_char_matrix::print_raw (std::ostream& os,
                                bool pr_as_read_syntax) const
 {
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 #include "oct-locbuf.h"
 #include "lo-mappers.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "file-ops.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
@@ -235,31 +235,31 @@ octave_class::get_current_method_class (
         retval = fcn->dispatch_class ();
     }
 
   return retval;
 }
 
 OCTAVE_NORETURN static
 void
-gripe_invalid_index1 (void)
+err_invalid_index1 (void)
 {
   error ("invalid index for class");
 }
 
 OCTAVE_NORETURN static
 void
-gripe_invalid_index_for_assignment (void)
+err_invalid_index_for_assignment (void)
 {
   error ("invalid index for class assignment");
 }
 
 OCTAVE_NORETURN static
 void
-gripe_invalid_index_type (const std::string& nm, char t)
+err_invalid_index_type (const std::string& nm, char t)
 {
   error ("%s cannot be indexed with %c", nm.c_str (), t);
 }
 
 Cell
 octave_class::dotref (const octave_value_list& idx)
 {
   assert (idx.length () == 1);
@@ -404,17 +404,17 @@ octave_class::subsref (const std::string
                 Cell t = dotref (idx.front ());
 
                 retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
               }
           }
           break;
 
         case '{':
-          gripe_invalid_index_type (type_name (), type[0]);
+          err_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
           panic_impossible ();
         }
 
       // FIXME: perhaps there should be an
       // octave_value_list::next_subsref member function?  See also
@@ -464,17 +464,17 @@ octave_class::subsref (const std::string
             retval = octave_value (retval, true);
         }
       else
         {
           if (type.length () == 1 && type[0] == '(')
             retval(0) = octave_value (map.index (idx.front ()), c_name,
                                       parent_list);
           else
-            gripe_invalid_index1 ();
+            err_invalid_index1 ();
         }
     }
 
   return retval;
 }
 
 octave_value
 octave_class::numeric_conv (const Cell& val, const std::string& type)
@@ -484,17 +484,17 @@ octave_class::numeric_conv (const Cell& 
   if (val.numel () == 1)
     {
       retval = val(0);
 
       if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
         retval = octave_map ();
     }
   else
-    gripe_invalid_index_for_assignment ();
+    err_invalid_index_for_assignment ();
 
   return retval;
 }
 
 octave_value
 octave_class::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
@@ -651,17 +651,17 @@ octave_class::subsasgn_common (const oct
                 next_idx.erase (next_idx.begin ());
                 next_idx.erase (next_idx.begin ());
 
                 u.make_unique ();
 
                 t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
               }
             else
-              gripe_invalid_index_for_assignment ();
+              err_invalid_index_for_assignment ();
           }
           break;
 
         case '.':
           {
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
@@ -694,22 +694,22 @@ octave_class::subsasgn_common (const oct
                   }
                 else
                   // optimization: ignore copy still stored inside our map.
                   tmp.make_unique (1);
 
                 t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
               }
             else
-              gripe_indexed_cs_list ();
+              err_indexed_cs_list ();
           }
           break;
 
         case '{':
-          gripe_invalid_index_type (type_name (), type[0]);
+          err_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
           panic_impossible ();
         }
     }
 
   switch (type[0])
@@ -784,17 +784,17 @@ octave_class::subsasgn_common (const oct
           }
 
         count++;
         retval = octave_value (this);
       }
       break;
 
     case '{':
-      gripe_invalid_index_type (type_name (), type[0]);
+      err_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
@@ -842,17 +842,17 @@ octave_class::byte_size (void) const
 
   return retval;
 }
 
 string_vector
 octave_class::map_keys (void) const
 {
   string_vector retval;
-  gripe_wrong_type_arg ("octave_class::map_keys()", type_name ());
+  err_wrong_type_arg ("octave_class::map_keys()", type_name ());
   return retval;
 }
 
 octave_base_value *
 octave_class::find_parent_class (const std::string& parent_class_name)
 {
   octave_base_value* retval = 0;
 
@@ -1616,17 +1616,17 @@ error_cleanup:
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_class::as_mxArray (void) const
 {
-  gripe_wrong_type_arg ("octave_class::as_mxArray ()", type_name ());
+  err_wrong_type_arg ("octave_class::as_mxArray ()", type_name ());
 
   return 0;
 }
 
 bool
 octave_class::in_class_method (void)
 {
   octave_function *fcn = octave_call_stack::current ();
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "pr-output.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<Complex>;
 
@@ -145,88 +145,88 @@ octave_complex::index_vector (bool) cons
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
   double retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 float
 octave_complex::float_value (bool force_conversion) const
 {
   float retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 Matrix
 octave_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = Matrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 FloatMatrix
 octave_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = FloatMatrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 NDArray
 octave_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = NDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 FloatNDArray
 octave_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 Complex
 octave_complex::complex_value (bool) const
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <iosfwd>
 #include <string>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "error.h"
 #include "ov-base.h"
 #include "ov-cx-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
@@ -134,29 +134,29 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0 && scalar != 1.0)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return scalar != 0.0;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0 && scalar != 1.0)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 0.0);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   void increment (void) { scalar += 1.0; }
 
diff --git a/libinterp/octave-value/ov-cs-list.cc b/libinterp/octave-value/ov-cs-list.cc
--- a/libinterp/octave-value/ov-cs-list.cc
+++ b/libinterp/octave-value/ov-cs-list.cc
@@ -26,34 +26,34 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <sstream>
 
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ov-cs-list.h"
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cs_list, "cs-list", "cs-list");
 
 octave_cs_list::octave_cs_list (const Cell& c)
   : octave_base_value (), lst (c)
 {
 }
 
 octave_value
 octave_cs_list::subsref (const std::string&,
                          const std::list<octave_value_list>&)
 {
-  gripe_indexed_cs_list ();
+  err_indexed_cs_list ();
 }
 
 octave_value_list
 octave_cs_list::subsref (const std::string&,
                          const std::list<octave_value_list>&, int)
 {
-  gripe_indexed_cs_list ();
+  err_indexed_cs_list ();
 }
 
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -97,32 +97,32 @@ octave_complex_diag_matrix::try_narrowin
 }
 
 DiagMatrix
 octave_complex_diag_matrix::diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               type_name (), "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 FloatDiagMatrix
 octave_complex_diag_matrix::float_diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               type_name (), "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 ComplexDiagMatrix
 octave_complex_diag_matrix::complex_diag_matrix_value (bool) const
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
@@ -100,132 +100,132 @@ octave_complex_matrix::try_narrowing_con
 }
 
 double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
+      warn_implicit_conversion ("Octave:array-to-scalar",
                                  "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("complex matrix", "real scalar");
+    err_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
+      warn_implicit_conversion ("Octave:array-to-scalar",
                                  "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("complex matrix", "real scalar");
+    err_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 NDArray
 octave_complex_matrix::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
   retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 FloatMatrix
 octave_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
   retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
+      warn_implicit_conversion ("Octave:array-to-scalar",
                                  "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("complex matrix", "complex scalar");
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_complex_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
+      warn_implicit_conversion ("Octave:array-to-scalar",
                                  "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("complex matrix", "complex scalar");
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix);
@@ -236,31 +236,31 @@ octave_complex_matrix::float_complex_mat
 {
   return FloatComplexMatrix (ComplexMatrix (matrix));
 }
 
 boolNDArray
 octave_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 charNDArray
 octave_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
-    gripe_implicit_conversion ("Octave:num-to-str",
+    warn_implicit_conversion ("Octave:num-to-str",
                                "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
@@ -276,17 +276,17 @@ octave_complex_matrix::float_complex_arr
 }
 
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
+    warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (ComplexMatrix (matrix)));
 
   return retval;
 }
 
 SparseComplexMatrix
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-complex.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #include "oct-hdf5.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
@@ -104,42 +104,42 @@ octave_sparse_complex_matrix::try_narrow
 }
 
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex sparse matrix", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex sparse matrix", "real scalar");
 
   // FIXME: maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "complex sparse matrix", "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("complex sparse matrix", "real scalar");
+    err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex sparse matrix", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex sparse matrix", "real matrix");
 
   retval = ::real (matrix.matrix_value ());
 
   return retval;
 }
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
@@ -147,23 +147,23 @@ octave_sparse_complex_matrix::complex_va
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME: maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "complex sparse matrix", "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("complex sparse matrix", "real scalar");
+    err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_sparse_complex_matrix::complex_matrix_value (bool) const
 {
   return matrix.matrix_value ();
@@ -176,18 +176,18 @@ octave_sparse_complex_matrix::complex_ar
 }
 
 charNDArray
 octave_sparse_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
-    gripe_implicit_conversion ("Octave:num-to-str",
-                               "sparse complex matrix", "string");
+    warn_implicit_conversion ("Octave:num-to-str",
+                              "sparse complex matrix", "string");
   else
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
@@ -199,33 +199,33 @@ octave_sparse_complex_matrix::char_array
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex sparse matrix",
-                               "real sparse matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex sparse matrix",
+                              "real sparse matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 SparseBoolMatrix
 octave_sparse_complex_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool
 octave_sparse_complex_matrix::save_binary (std::ostream& os,
                                            bool&save_as_floats)
 {
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <sstream>
 #include <vector>
 
 #include "file-ops.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-pr-code.h"
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -32,17 +32,17 @@ Open Source Initiative (www.opensource.o
 #include <iostream>
 #include <sstream>
 #include <vector>
 
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-inline.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "variables.h"
 #include "parse.h"
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "data-conv.h"
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
@@ -106,17 +106,17 @@ octave_float_scalar::diag (octave_idx_ty
 }
 
 octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
-    gripe_nan_to_character_conversion ();
+    err_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ov-base.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
@@ -192,29 +192,29 @@ public:
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-flt-cx-mat.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "pr-output.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<FloatComplex>;
 
@@ -88,88 +88,88 @@ octave_float_complex::do_index_op (const
 }
 
 double
 octave_float_complex::double_value (bool force_conversion) const
 {
   double retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 float
 octave_float_complex::float_value (bool force_conversion) const
 {
   float retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real scalar");
 
   retval = std::real (scalar);
 
   return retval;
 }
 
 Matrix
 octave_float_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = Matrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = FloatMatrix (1, 1, std::real (scalar));
 
   return retval;
 }
 
 NDArray
 octave_float_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = NDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 FloatNDArray
 octave_float_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex scalar", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex scalar", "real matrix");
 
   retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
 
   return retval;
 }
 
 Complex
 octave_float_complex::complex_value (bool) const
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <iosfwd>
 #include <string>
 
 #include "lo-ieee.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "error.h"
 #include "ov-base.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
@@ -130,29 +130,29 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0f && scalar != 1.0f)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return scalar != 0.0f;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0f && scalar != 1.0f)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 1.0f);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   void increment (void) { scalar += 1.0; }
 
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -78,32 +78,32 @@ octave_float_complex_diag_matrix::try_na
 }
 
 DiagMatrix
 octave_float_complex_diag_matrix::diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               type_name (), "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 FloatDiagMatrix
 octave_float_complex_diag_matrix::float_diag_matrix_value (bool force_conversion) const
 {
   DiagMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               type_name (), "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              type_name (), "real matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
 ComplexDiagMatrix
 octave_float_complex_diag_matrix::complex_diag_matrix_value (bool) const
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
@@ -88,118 +88,118 @@ octave_float_complex_matrix::try_narrowi
 }
 
 double
 octave_float_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("complex matrix", "real scalar");
+    err_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_float_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real scalar");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real scalar");
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "complex matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
-    gripe_invalid_conversion ("complex matrix", "real scalar");
+    err_invalid_conversion ("complex matrix", "real scalar");
 
   return retval;
 }
 
 Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real matrix");
 
   retval = ::real (FloatComplexMatrix (matrix));
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real matrix");
 
   retval = ::real (FloatComplexMatrix (matrix));
 
   return retval;
 }
 
 Complex
 octave_float_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("complex matrix", "complex scalar");
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_float_complex_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "complex matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("complex matrix", "complex scalar");
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_float_complex_matrix::complex_matrix_value (bool) const
 {
   return FloatComplexMatrix (matrix);
@@ -210,32 +210,32 @@ octave_float_complex_matrix::float_compl
 {
   return FloatComplexMatrix (matrix);
 }
 
 boolNDArray
 octave_float_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return mx_el_ne (matrix, FloatComplex (0.0));
 }
 
 charNDArray
 octave_float_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
-    gripe_implicit_conversion ("Octave:num-to-str",
-                               "complex matrix", "string");
+    warn_implicit_conversion ("Octave:num-to-str",
+                              "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
@@ -250,18 +250,18 @@ octave_float_complex_matrix::float_compl
 }
 
 SparseMatrix
 octave_float_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
-    gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex matrix", "real matrix");
+    warn_implicit_conversion ("Octave:imag-to-real",
+                              "complex matrix", "real matrix");
 
   retval = SparseMatrix (::real (complex_matrix_value ()));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_float_complex_matrix::sparse_complex_matrix_value (bool) const
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
@@ -88,41 +88,41 @@ octave_float_matrix::try_narrowing_conve
 
 double
 octave_float_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "real scalar");
+    err_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_float_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "real scalar");
+    err_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_float_matrix::matrix_value (bool) const
@@ -140,43 +140,43 @@ Complex
 octave_float_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "complex scalar");
+    err_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_float_matrix::float_complex_value (bool) const
 {
   double tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "complex scalar");
+    err_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_float_matrix::complex_matrix_value (bool) const
@@ -207,19 +207,19 @@ octave_float_matrix::array_value (bool) 
 {
   return NDArray (matrix);
 }
 
 boolNDArray
 octave_float_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_float_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
@@ -285,17 +285,17 @@ octave_float_matrix::convert_to_str_inte
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       float d = matrix (i);
 
       if (xisnan (d))
-        gripe_nan_to_character_conversion ();
+        err_nan_to_character_conversion ();
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_INT16
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_INT32
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_INT64
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_INT8
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 #include "error.h"
 #include "mxarray.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-int.h"
 #include "ov-typeinfo.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 
 class
 OCTINTERP_API
 OCTAVE_VALUE_INT_MATRIX_T
   : public octave_base_int_matrix<intNDArray<OCTAVE_INT_T> >
@@ -99,42 +99,42 @@ public:
 
   double
   double_value (bool = false) const
   {
     double retval = lo_ieee_nan_value ();
 
     if (numel () > 0)
       {
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   type_name (), "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  type_name (), "real scalar");
 
         retval = matrix(0).double_value ();
       }
     else
-      gripe_invalid_conversion (type_name (), "real scalar");
+      err_invalid_conversion (type_name (), "real scalar");
 
     return retval;
 
   }
 
   float
   float_value (bool = false) const
   {
     float retval = lo_ieee_float_nan_value ();
 
     if (numel () > 0)
       {
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   type_name (), "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  type_name (), "real scalar");
 
         retval = matrix(0).float_value ();
       }
     else
-      gripe_invalid_conversion (type_name (), "real scalar");
+      err_invalid_conversion (type_name (), "real scalar");
 
     return retval;
 
   }
 
   double scalar_value (bool = false) const { return double_value (); }
 
   float float_scalar_value (bool = false) const { return float_value (); }
@@ -254,17 +254,17 @@ public:
   boolNDArray
   bool_array_value (bool warn = false) const
   {
     boolNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
 
     if (warn && matrix.any_element_not_one_or_zero ())
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     bool *vec = retval.fortran_vec ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = matrix(i).bool_value ();
 
     return retval;
   }
 
@@ -568,28 +568,28 @@ public:
     FloatComplexNDArray retval (dim_vector (1, 1));
     retval(0) = FloatComplex (scalar.float_value ());
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (warn && scalar != 0.0 && scalar != 1.0)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return scalar.bool_value ();
   }
 
   boolNDArray
   bool_array_value (bool warn = false) const
   {
     boolNDArray retval (dim_vector (1, 1));
 
     if (warn && scalar != 0.0 && scalar != 1.0)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     retval(0) = scalar.bool_value ();
 
     return retval;
   }
 
   charNDArray
   char_array_value (bool = false) const
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "oct-shlib.h"
 
 #include <defaults.h>
 #include "dynamic-ld.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov-mex-fcn.h"
 #include "ov.h"
 #include "profiler.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 #include "dim-vector.h"
 
 #include "mxarray.h"
 #include "ov-perm.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ops.h"
 #include "pr-output.h"
 
 #include "ls-oct-text.h"
 
 octave_value
 octave_perm_matrix::subsref (const std::string& type,
                              const std::list<octave_value_list>& idx)
@@ -139,81 +139,81 @@ octave_perm_matrix::is_true (void) const
 
 double
 octave_perm_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "real scalar");
+    err_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
 
 float
 octave_perm_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "real scalar");
+    err_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
 
 Complex
 octave_perm_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "complex scalar");
+    err_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_perm_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 type_name (), "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                type_name (), "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion (type_name (), "complex scalar");
+    err_invalid_conversion (type_name (), "complex scalar");
 
   return retval;
 }
 
 #define FORWARD_MATRIX_VALUE(TYPE, PREFIX) \
 TYPE \
 octave_perm_matrix::PREFIX ## _value (bool frc_str_conv) const \
 { \
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "variables.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ops.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
@@ -181,43 +181,43 @@ double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "range", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "range", "real scalar");
 
       retval = range.base ();
     }
   else
-    gripe_invalid_conversion ("range", "real scalar");
+    err_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
 
 float
 octave_range::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "range", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "range", "real scalar");
 
       retval = range.base ();
     }
   else
-    gripe_invalid_conversion ("range", "real scalar");
+    err_invalid_conversion ("range", "real scalar");
 
   return retval;
 }
 
 charNDArray
 octave_range::char_array_value (bool) const
 {
   const Matrix matrix = range.matrix_value ();
@@ -291,58 +291,58 @@ octave_range::complex_value (bool) const
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "range", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "range", "complex scalar");
 
       retval = range.base ();
     }
   else
-    gripe_invalid_conversion ("range", "complex scalar");
+    err_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_range::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "range", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "range", "complex scalar");
 
       retval = range.base ();
     }
   else
-    gripe_invalid_conversion ("range", "complex scalar");
+    err_invalid_conversion ("range", "complex scalar");
 
   return retval;
 }
 
 boolNDArray
 octave_range::bool_array_value (bool warn) const
 {
   Matrix m = range.matrix_value ();
 
   if (m.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && m.any_element_not_one_or_zero ())
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
 {
   NDArray retval = array_value ();
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
@@ -103,41 +103,41 @@ octave_matrix::try_narrowing_conversion 
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "real scalar");
+    err_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 float
 octave_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "real scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "real scalar");
+    err_invalid_conversion ("real matrix", "real scalar");
 
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_matrix::matrix_value (bool) const
@@ -155,43 +155,43 @@ Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "complex scalar");
+    err_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
 FloatComplex
 octave_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-to-scalar",
-                                 "real matrix", "complex scalar");
+      warn_implicit_conversion ("Octave:array-to-scalar",
+                                "real matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real matrix", "complex scalar");
+    err_invalid_conversion ("real matrix", "complex scalar");
 
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_matrix::complex_matrix_value (bool) const
@@ -216,19 +216,19 @@ octave_matrix::float_complex_array_value
 {
   return FloatComplexNDArray (matrix);
 }
 
 boolNDArray
 octave_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return boolNDArray (matrix);
 }
 
 charNDArray
 octave_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
@@ -387,17 +387,17 @@ octave_matrix::convert_to_str_internal (
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       double d = matrix (i);
 
       if (xisnan (d))
-        gripe_nan_to_character_conversion ();
+        err_nan_to_character_conversion ();
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 #include "oct-hdf5.h"
 #include "ls-hdf5.h"
 
 #include "ov-re-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
@@ -57,17 +57,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 idx_vector
 octave_sparse_matrix::index_vector (bool /* require_integers */) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
       std::string nm = "<" + type_name () + ">";
-      gripe_invalid_index (nm.c_str ());
+      err_invalid_index (nm.c_str ());
     }
 }
 
 octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
@@ -95,64 +95,64 @@ octave_sparse_matrix::try_narrowing_conv
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "real sparse matrix", "real scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "real sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real sparse matrix", "real scalar");
+    err_invalid_conversion ("real sparse matrix", "real scalar");
 
   return retval;
 }
 
 Complex
 octave_sparse_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME: maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
       if (numel () > 1)
-        gripe_implicit_conversion ("Octave:array-to-scalar",
-                                   "real sparse matrix", "complex scalar");
+        warn_implicit_conversion ("Octave:array-to-scalar",
+                                  "real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
-    gripe_invalid_conversion ("real sparse matrix", "complex scalar");
+    err_invalid_conversion ("real sparse matrix", "complex scalar");
 
   return retval;
 }
 
 Matrix
 octave_sparse_matrix::matrix_value (bool) const
 {
   return matrix.matrix_value ();
 }
 
 boolNDArray
 octave_sparse_matrix::bool_array_value (bool warn) const
 {
   NDArray m = matrix.matrix_value ();
 
   if (m.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && m.any_element_not_one_or_zero ())
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return boolNDArray (m);
 }
 
 charNDArray
 octave_sparse_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
@@ -183,19 +183,19 @@ octave_sparse_matrix::array_value (bool)
 {
   return NDArray (matrix.matrix_value ());
 }
 
 SparseBoolMatrix
 octave_sparse_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
-    gripe_logical_conversion ();
+    warn_logical_conversion ();
 
   return mx_el_ne (matrix, 0.0);
 }
 
 octave_value
 octave_sparse_matrix::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
@@ -219,17 +219,17 @@ octave_sparse_matrix::convert_to_str_int
         for (octave_idx_type i = matrix.cidx (j);
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
             if (xisnan (d))
-              gripe_nan_to_character_conversion ();
+              err_nan_to_character_conversion ();
             else
               {
                 int ival = NINT (d);
 
                 if (ival < 0
                     || ival > std::numeric_limits<unsigned char>::max ())
                   {
                     // FIXME: is there something better we could do?
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "data-conv.h"
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
@@ -121,17 +121,17 @@ octave_scalar::diag (octave_idx_type m, 
 }
 
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
-    gripe_nan_to_character_conversion ();
+    err_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
           // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ov-base.h"
 #include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 class octave_value_list;
 
 class tree_walker;
@@ -191,29 +191,29 @@ public:
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return scalar;
   }
 
   boolNDArray bool_array_value (bool warn = false) const
   {
     if (xisnan (scalar))
-      gripe_nan_to_logical_conversion ();
+      err_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
-      gripe_logical_conversion ();
+      warn_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "oct-locbuf.h"
 
 #include "byte-swap.h"
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ls-ascii-helper.h"
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ovl.h"
 #include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
@@ -159,17 +159,17 @@ octave_char_matrix_str::resize (const di
     retval.resize (dv);
   return octave_value (retval, is_sq_string () ? '\'' : '"');
 }
 
 #define CHAR_MATRIX_CONV(T, INIT, TNAME, FCN) \
   T retval INIT; \
  \
   if (! force_string_conv) \
-    gripe_invalid_conversion ("string", TNAME); \
+    err_invalid_conversion ("string", TNAME); \
   else \
     { \
       warning_with_id ("Octave:str-to-num", \
                        "implicit conversion from %s to %s", \
                        "string", TNAME); \
  \
       retval = octave_char_matrix::FCN (); \
     } \
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -87,23 +87,23 @@ octave_struct::dotref (const octave_valu
   else
     error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 static void
-gripe_invalid_index_for_assignment (void)
+err_invalid_index_for_assignment (void)
 {
   error ("invalid index for structure array assignment");
 }
 
 static void
-gripe_invalid_index_type (const std::string& nm, char t)
+err_invalid_index_type (const std::string& nm, char t)
 {
   error ("%s cannot be indexed with %c", nm.c_str (), t);
 }
 
 static void
 maybe_warn_invalid_field_name (const std::string& key, const char *who)
 {
   if (! valid_identifier (key))
@@ -160,17 +160,17 @@ octave_struct::subsref (const std::strin
             const Cell t = dotref (idx.front ());
 
             retval(0) = (t.numel () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
     case '{':
-      gripe_invalid_index_type (type_name (), type[0]);
+      err_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
@@ -223,17 +223,17 @@ octave_struct::subsref (const std::strin
             const Cell t = dotref (idx.front (), auto_add);
 
             retval = (t.numel () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
     case '{':
-      gripe_invalid_index_type (type_name (), type[0]);
+      err_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
   // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
@@ -337,20 +337,20 @@ octave_struct::subsasgn (const std::stri
                       // still stored inside our map.
                       tmp.make_unique (1);
 
                       t_rhs =(orig_undefined
                               ? tmp.undef_subsasgn (next_type, next_idx, rhs)
                               : tmp.subsasgn (next_type, next_idx, rhs));
                   }
                 else
-                  gripe_indexed_cs_list ();
+                  err_indexed_cs_list ();
               }
             else
-              gripe_invalid_index_for_assignment ();
+              err_invalid_index_for_assignment ();
           }
           break;
 
         case '.':
           {
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
@@ -391,22 +391,22 @@ octave_struct::subsasgn (const std::stri
                   // still stored inside our map.
                   tmp.make_unique (1);
 
                 t_rhs = (orig_undefined
                          ? tmp.undef_subsasgn (next_type, next_idx, rhs)
                          : tmp.subsasgn (next_type, next_idx, rhs));
               }
             else
-              gripe_indexed_cs_list ();
+              err_indexed_cs_list ();
           }
           break;
 
         case '{':
-          gripe_invalid_index_type (type_name (), type[0]);
+          err_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
           panic_impossible ();
         }
     }
 
   switch (type[0])
@@ -455,17 +455,17 @@ octave_struct::subsasgn (const std::stri
                   {
                     map.assign (idxf,
                                 key, Cell (t_rhs.storable_value ()));
 
                     count++;
                     retval = octave_value (this);
                   }
                 else
-                  gripe_nonbraced_cs_list_assignment ();
+                  err_nonbraced_cs_list_assignment ();
               }
           }
         else
           {
             if (t_rhs.is_map () || t_rhs.is_object ())
               {
                 octave_map rhs_map = t_rhs.xmap_value ("invalid structure assignment");
 
@@ -519,17 +519,17 @@ octave_struct::subsasgn (const std::stri
           }
 
         count++;
         retval = octave_value (this);
       }
       break;
 
     case '{':
-      gripe_invalid_index_type (type_name (), type[0]);
+      err_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
   retval.maybe_mutate ();
 
diff --git a/libinterp/octave-value/ov-type-conv.h b/libinterp/octave-value/ov-type-conv.h
--- a/libinterp/octave-value/ov-type-conv.h
+++ b/libinterp/octave-value/ov-type-conv.h
@@ -89,17 +89,17 @@ octave_type_conv_body (const octave_valu
   if (retval.is_undefined ()) \
     { \
       std::string arg_tname = arg.type_name (); \
  \
       std::string result_tname = arg.numel () == 1 \
         ? SCALAR_RESULT_T::static_type_name () \
         : MATRIX_RESULT_T::static_type_name (); \
  \
-      gripe_invalid_conversion (arg_tname, result_tname); \
+      err_invalid_conversion (arg_tname, result_tname); \
     } \
  \
   return retval;
 
 #define OCTAVE_TYPE_CONV_BODY(NAME) \
   OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
                           octave_ ## NAME ## _scalar)
 
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_UINT16
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_UINT32
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_UINT64
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <limits>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
 #if defined (HAVE_HDF5)
 #define HDF5_SAVE_TYPE H5T_NATIVE_UINT8
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
 #include "builtins.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "ovl.h"
 #include "ov-usr-fcn.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-eval.h"
 #include "pt-jit.h"
 #include "pt-jump.h"
@@ -1062,17 +1062,17 @@ element-by-element and a logical array i
 
       boolNDArray r (ka.dims ());
       for (octave_idx_type i = 0; i < ka.numel (); i++)
         r(i) = isargout1 (nargout1, ignored, ka(i));
 
       return ovl (r);
     }
   else
-    gripe_wrong_type_arg ("isargout", args(0));
+    err_wrong_type_arg ("isargout", args(0));
 
   return ovl ();
 }
 
 /*
 %!function [x, y] = try_isargout ()
 %!  if (isargout (1))
 %!    if (isargout (2))
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -78,17 +78,17 @@ along with Octave; see the file COPYING.
 #include "ov-null-mat.h"
 #include "ov-lazy-idx.h"
 #ifdef HAVE_JAVA
 #include "ov-java.h"
 #endif
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
@@ -1596,18 +1596,18 @@ make_vector_dims (const dim_vector& dv, 
 {
   dim_vector retval (dv);
   retval.chop_trailing_singletons ();
   octave_idx_type nel = dv.numel ();
 
   if (retval.length () > 2 || (retval(0) != 1 && retval(1) != 1))
     {
       if (! force_vector_conversion)
-        gripe_implicit_conversion ("Octave:array-to-vector",
-                                   my_type.c_str (), wanted_type.c_str ());
+        warn_implicit_conversion ("Octave:array-to-vector",
+                                  my_type.c_str (), wanted_type.c_str ());
       retval = dim_vector (nel, 1);
     }
 
   return retval;
 }
 
 ColumnVector
 octave_value::column_vector_value (bool force_string_conv,
diff --git a/libinterp/operators/op-b-b.cc b/libinterp/operators/op-b-b.cc
--- a/libinterp/operators/op-b-b.cc
+++ b/libinterp/operators/op-b-b.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
diff --git a/libinterp/operators/op-b-bm.cc b/libinterp/operators/op-b-bm.cc
--- a/libinterp/operators/op-b-bm.cc
+++ b/libinterp/operators/op-b-bm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
diff --git a/libinterp/operators/op-b-sbm.cc b/libinterp/operators/op-b-sbm.cc
--- a/libinterp/operators/op-b-sbm.cc
+++ b/libinterp/operators/op-b-sbm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
diff --git a/libinterp/operators/op-bm-b.cc b/libinterp/operators/op-bm-b.cc
--- a/libinterp/operators/op-bm-b.cc
+++ b/libinterp/operators/op-bm-b.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-re-sparse.h"
diff --git a/libinterp/operators/op-bm-sbm.cc b/libinterp/operators/op-bm-sbm.cc
--- a/libinterp/operators/op-bm-sbm.cc
+++ b/libinterp/operators/op-bm-sbm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool-mat.h"
 #include "boolMatrix.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
diff --git a/libinterp/operators/op-cdm-cdm.cc b/libinterp/operators/op-cdm-cdm.cc
--- a/libinterp/operators/op-cdm-cdm.cc
+++ b/libinterp/operators/op-cdm-cdm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-cell.cc b/libinterp/operators/op-cell.cc
--- a/libinterp/operators/op-cell.cc
+++ b/libinterp/operators/op-cell.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cell.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
diff --git a/libinterp/operators/op-chm.cc b/libinterp/operators/op-chm.cc
--- a/libinterp/operators/op-chm.cc
+++ b/libinterp/operators/op-chm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-ch-mat.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-typeinfo.h"
@@ -46,51 +46,51 @@ DEFUNOP (transpose, char_matrix)
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array,
                concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
 
-  gripe_implicit_conversion ("Octave:num-to-str",
-                             v2.type_name (), v1.type_name ());
+  warn_implicit_conversion ("Octave:num-to-str",
+                            v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
                        ra_idx));
 }
 
 DEFCATOP (chm_m, char_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_matrix&);
 
-  gripe_implicit_conversion ("Octave:num-to-str",
-                             v2.type_name (), v1.type_name ());
+  warn_implicit_conversion ("Octave:num-to-str",
+                            v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
                        ra_idx));
 }
 
 DEFCATOP (s_chm, scalar, char_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix&);
 
-  gripe_implicit_conversion ("Octave:num-to-str",
-                             v1.type_name (), v2.type_name ());
+  warn_implicit_conversion ("Octave:num-to-str",
+                            v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
                        ra_idx));
 }
 
 DEFCATOP (m_chm, matrix, char_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix&);
 
-  gripe_implicit_conversion ("Octave:num-to-str",
-                             v1.type_name (), v2.type_name ());
+  warn_implicit_conversion ("Octave:num-to-str",
+                            v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
                        ra_idx));
 }
 
 void
 install_chm_ops (void)
 {
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-time.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-class.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "symtab.h"
 #include "parse.h"
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -43,17 +43,17 @@ DEFNDBINOP_OP (mul, complex_matrix, comp
 
 DEFBINOP (div, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
 DEFBINOP (ldiv, complex_matrix, complex)
 {
@@ -85,17 +85,17 @@ DEFNDBINOP_OP (el_mul, complex_matrix, c
 
 DEFBINOP (el_div, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex)
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-cm-m.h"
 #include "mx-m-cm.h"
 #include "mx-cnda-nda.h"
 #include "mx-nda-cnda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-cm-s.h"
 #include "mx-cnda-s.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -46,17 +46,17 @@ DEFNDBINOP_OP (mul, complex_matrix, scal
 
 DEFBINOP (div, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
 DEFBINOP (ldiv, complex_matrix, scalar)
 {
@@ -83,17 +83,17 @@ DEFNDBINOP_OP (el_mul, complex_matrix, s
 
 DEFBINOP (el_div, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, scalar, complex_array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, scalar)
 {
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -51,17 +51,17 @@ DEFBINOP (div, complex_matrix, sparse_co
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -50,17 +50,17 @@ DEFBINOP (div, complex_matrix, sparse_ma
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
@@ -58,17 +58,17 @@ DEFBINOP_FN (pow, complex, complex_matri
 
 DEFBINOP (ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex, complex_matrix, complex, complex_array,
                     mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex, complex_matrix, complex, complex_array,
                     mx_el_le)
@@ -89,17 +89,17 @@ DEFNDBINOP_FN (el_pow, complex, complex_
 
 DEFBINOP (el_ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, complex, complex_matrix, complex, complex_array,
                mx_el_and)
 DEFNDBINOP_FN (el_or,  complex, complex_matrix, complex, complex_array,
                mx_el_or)
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 
 // unary complex scalar ops.
 
 DEFUNOP (not, complex)
 {
   CAST_UNOP_ARG (const octave_complex&);
   Complex x = v.complex_value ();
   if (xisnan (x))
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, complex, /* no-op */)
 DEFUNOP_OP (uminus, complex, -)
 DEFUNOP_OP (transpose, complex, /* no-op */)
 
@@ -72,31 +72,31 @@ DEFBINOP_OP (mul, complex, complex, *)
 
 DEFBINOP (div, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (pow, complex, complex, xpow)
 
 DEFBINOP (ldiv, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, complex, complex, <)
 DEFCMPLXCMPOP_OP (le, complex, complex, <=)
 DEFCMPLXCMPOP_OP (eq, complex, complex, ==)
 DEFCMPLXCMPOP_OP (ge, complex, complex, >=)
@@ -107,31 +107,31 @@ DEFBINOP_OP (el_mul, complex, complex, *
 
 DEFBINOP (el_div, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, complex, complex, xpow)
 
 DEFBINOP (el_ldiv, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFBINOP (el_and, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
diff --git a/libinterp/operators/op-cs-m.cc b/libinterp/operators/op-cs-m.cc
--- a/libinterp/operators/op-cs-m.cc
+++ b/libinterp/operators/op-cs-m.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-cs-nda.h"
 #include "mx-nda-cs.h"
 #include "mx-cs-nda.h"
 #include "mx-nda-cs.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -64,17 +64,17 @@ DEFBINOP_FN (pow, complex, matrix, xpow)
 
 DEFBINOP (ldiv, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex, matrix, complex, array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex, matrix, complex, array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex, matrix, complex, array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, complex, matrix, complex, array, mx_el_ge)
@@ -87,17 +87,17 @@ DEFNDBINOP_FN (el_pow, complex, matrix, 
 
 DEFBINOP (el_ldiv, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, complex, matrix, complex, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex, matrix, complex, array, mx_el_or)
 
 DEFNDCATOP_FN (cs_m, complex, matrix, complex_array, array, concat)
diff --git a/libinterp/operators/op-cs-s.cc b/libinterp/operators/op-cs-s.cc
--- a/libinterp/operators/op-cs-s.cc
+++ b/libinterp/operators/op-cs-s.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -43,31 +43,31 @@ DEFBINOP_OP (mul, complex, scalar, *)
 
 DEFBINOP (div, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (pow, complex, scalar, xpow)
 
 DEFBINOP (ldiv, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, complex, scalar, <)
 DEFCMPLXCMPOP_OP (le, complex, scalar, <=)
 DEFCMPLXCMPOP_OP (eq, complex, scalar, ==)
 DEFCMPLXCMPOP_OP (ge, complex, scalar, >=)
@@ -78,31 +78,31 @@ DEFBINOP_OP (el_mul, complex, scalar, *)
 
 DEFBINOP (el_div, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, complex, scalar, xpow)
 
 DEFBINOP (el_ldiv, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
 DEFBINOP (el_and, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -48,17 +48,17 @@ DEFBINOP (div, complex, sparse_complex_m
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
@@ -77,17 +77,17 @@ DEFBINOP (pow, complex, sparse_complex_m
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.sparse_complex_matrix_value () / d);
 }
 
 DEFBINOP_FN (lt, complex, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, complex, sparse_complex_matrix, mx_el_ge)
@@ -102,17 +102,17 @@ DEFBINOP_FN (el_pow, complex, sparse_com
 DEFBINOP (el_ldiv, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -50,17 +50,17 @@ DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
@@ -79,17 +79,17 @@ DEFBINOP (pow, complex, sparse_matrix)
 DEFBINOP (ldiv, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (lt, complex, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex, sparse_matrix, mx_el_le)
@@ -105,17 +105,17 @@ DEFBINOP_FN (el_pow, complex, sparse_mat
 DEFBINOP (el_ldiv, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_and, complex, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_matrix, mx_el_or)
diff --git a/libinterp/operators/op-dm-dm.cc b/libinterp/operators/op-dm-dm.cc
--- a/libinterp/operators/op-dm-dm.cc
+++ b/libinterp/operators/op-dm-dm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-re-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "mx-s-cm.h"
 
 #include "mx-dm-cs.h"
 #include "mx-cs-dm.h"
 
 #include "mx-m-cs.h"
 #include "mx-cs-m.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-re-sparse.h"
@@ -345,17 +345,17 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.diag_matrix_value (), typ);
@@ -367,17 +367,17 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
@@ -389,17 +389,17 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
diff --git a/libinterp/operators/op-dm-sm.cc b/libinterp/operators/op-dm-sm.cc
--- a/libinterp/operators/op-dm-sm.cc
+++ b/libinterp/operators/op-dm-sm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-re-diag.h"
 #include "ov-re-sparse.h"
 
@@ -129,17 +129,17 @@ DEFBINOP (div_sm_dm, sparse_matrix, diag
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "ops.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "xpow.h"
 #include SINCLUDE
 #include MINCLUDE
 
 // matrix by diag matrix ops.
 
 #ifndef SCALARV
 #define SCALARV SCALAR
@@ -48,17 +48,17 @@ DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, M
 #define MATRIX_VALUE CONCAT2(MATRIXV, _value)
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
 template <class T>
 static T
 gripe_if_zero (T x)
 {
   if (x == T ())
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return x;
 }
 
 DEFBINOP (dmsdiv, MATRIX, SCALAR)
 {
   CAST_BINOP_ARGS (const OCTAVE_MATRIX&, const OCTAVE_SCALAR&);
 
diff --git a/libinterp/operators/op-double-conv.cc b/libinterp/operators/op-double-conv.cc
--- a/libinterp/operators/op-double-conv.cc
+++ b/libinterp/operators/op-double-conv.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
diff --git a/libinterp/operators/op-fcdm-fcdm.cc b/libinterp/operators/op-fcdm-fcdm.cc
--- a/libinterp/operators/op-fcdm-fcdm.cc
+++ b/libinterp/operators/op-fcdm-fcdm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-fcdm-fdm.cc b/libinterp/operators/op-fcdm-fdm.cc
--- a/libinterp/operators/op-fcdm-fdm.cc
+++ b/libinterp/operators/op-fcdm-fdm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -48,17 +48,17 @@ DEFNDBINOP_OP (mul, float_complex_matrix
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
@@ -93,17 +93,17 @@ DEFNDBINOP_OP (el_mul, float_complex_mat
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex,
                float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-fcm-fm.h"
 #include "mx-fm-fcm.h"
 #include "mx-fcnda-fnda.h"
 #include "mx-fnda-fcnda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-fcnda-fs.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
@@ -51,17 +51,17 @@ DEFNDBINOP_OP (mul, float_complex_matrix
 DEFBINOP (div, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float)
 {
@@ -97,17 +97,17 @@ DEFNDBINOP_OP (el_mul, float_complex_mat
 DEFBINOP (el_div, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
diff --git a/libinterp/operators/op-fcn.cc b/libinterp/operators/op-fcn.cc
--- a/libinterp/operators/op-fcn.cc
+++ b/libinterp/operators/op-fcn.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-fcn-handle.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFBINOP (eq, fcn_handle, fcn_handle)
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -65,17 +65,17 @@ DEFBINOP_FN (pow, float_complex, float_c
 DEFBINOP (ldiv, float_complex, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&,
                    const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex,
                     float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex,
                     float_complex_array, mx_el_le)
@@ -98,17 +98,17 @@ DEFNDBINOP_FN (el_pow, float_complex, fl
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&,
                    const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_or)
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 
 // unary complex scalar ops.
 
 DEFUNOP (not, float_complex)
 {
   CAST_UNOP_ARG (const octave_float_complex&);
   FloatComplex x = v.float_complex_value ();
   if (xisnan (x))
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_complex, /* no-op */)
 DEFUNOP_OP (uminus, float_complex, -)
 DEFUNOP_OP (transpose, float_complex, /* no-op */)
 
@@ -70,31 +70,31 @@ DEFBINOP_OP (mul, float_complex, float_c
 
 DEFBINOP (div, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, float_complex, float_complex, <)
 DEFCMPLXCMPOP_OP (le, float_complex, float_complex, <=)
 DEFCMPLXCMPOP_OP (eq, float_complex, float_complex, ==)
 DEFCMPLXCMPOP_OP (ge, float_complex, float_complex, >=)
@@ -105,31 +105,31 @@ DEFBINOP_OP (el_mul, float_complex, floa
 
 DEFBINOP (el_div, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-fcs-fnda.h"
 #include "mx-fnda-fcs.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-re-mat.h"
@@ -65,17 +65,17 @@ DEFBINOP_FN (pow, float_complex, float_m
 
 DEFBINOP (ldiv, float_complex, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex,
                     float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex,
                     float_array, mx_el_le)
@@ -97,17 +97,17 @@ DEFNDBINOP_FN (el_pow, float_complex, fl
 
 DEFBINOP (el_ldiv, float_complex, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex,
                float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex,
                float_array, mx_el_or)
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
@@ -46,31 +46,31 @@ DEFBINOP_OP (mul, float_complex, float_s
 
 DEFBINOP (div, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, float_complex, float_scalar, <)
 DEFCMPLXCMPOP_OP (le, float_complex, float_scalar, <=)
 DEFCMPLXCMPOP_OP (eq, float_complex, float_scalar, ==)
 DEFCMPLXCMPOP_OP (ge, float_complex, float_scalar, >=)
@@ -81,31 +81,31 @@ DEFBINOP_OP (el_mul, float_complex, floa
 
 DEFBINOP (el_div, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
diff --git a/libinterp/operators/op-fdm-fdm.cc b/libinterp/operators/op-fdm-fdm.cc
--- a/libinterp/operators/op-fdm-fdm.cc
+++ b/libinterp/operators/op-fdm-fdm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-flt-re-mat.h"
 #include "ov-flt-re-diag.h"
 #include "ov-re-diag.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-float-conv.cc b/libinterp/operators/op-float-conv.cc
--- a/libinterp/operators/op-float-conv.cc
+++ b/libinterp/operators/op-float-conv.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-fm-fcm.h"
 #include "mx-fcm-fm.h"
 #include "mx-fnda-fcnda.h"
 #include "mx-fcnda-fnda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-fm-fcs.h"
 #include "mx-fcs-fm.h"
 #include "mx-fnda-fcs.h"
 #include "mx-fcs-fnda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
@@ -51,17 +51,17 @@ DEFNDBINOP_OP (mul, float_matrix, float_
 
 DEFBINOP (div, float_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_matrix, float_complex)
 {
@@ -95,17 +95,17 @@ DEFNDBINOP_OP (el_mul, float_matrix, flo
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array,
                float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, flaot_complex)
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -43,17 +43,17 @@ DEFNDBINOP_OP (mul, float_matrix, float_
 
 DEFBINOP (div, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_matrix, float)
 {
@@ -86,17 +86,17 @@ DEFNDBINOP_OP (el_mul, float_matrix, flo
 
 DEFBINOP (el_div, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float)
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-fs-fcm.h"
 #include "mx-fcm-fs.h"
 #include "mx-fs-fcnda.h"
 #include "mx-fcnda-fs.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
@@ -71,17 +71,17 @@ DEFBINOP_FN (pow, float_scalar, float_co
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&,
                    const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar,
                     float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar,
                     float_complex_array, mx_el_le)
@@ -104,17 +104,17 @@ DEFNDBINOP_FN (el_pow, float_scalar, flo
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&,
                    const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_or)
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
@@ -46,31 +46,31 @@ DEFBINOP_OP (mul, float_scalar, float_co
 
 DEFBINOP (div, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, float_scalar, float_complex, <)
 DEFCMPLXCMPOP_OP (le, float_scalar, float_complex, <=)
 DEFCMPLXCMPOP_OP (eq, float_scalar, float_complex, ==)
 DEFCMPLXCMPOP_OP (ge, float_scalar, float_complex, >=)
@@ -81,31 +81,31 @@ DEFBINOP_OP (el_mul, float_scalar, float
 
 DEFBINOP (el_div, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -60,17 +60,17 @@ DEFBINOP_FN (pow, float_scalar, float_ma
 
 DEFBINOP (ldiv, float_scalar, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (lt, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_le)
@@ -92,17 +92,17 @@ DEFNDBINOP_FN (el_pow, float_scalar, flo
 
 DEFBINOP (el_ldiv, float_scalar, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar,
                float_array, mx_el_or)
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 
 // scalar unary ops.
 
 DEFUNOP (not, float_scalar)
 {
   CAST_UNOP_ARG (const octave_float_scalar&);
   float x = v.float_value ();
   if (xisnan (x))
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_scalar, /* no-op */)
 DEFUNOP_OP (uminus, float_scalar, -)
 DEFUNOP_OP (transpose, float_scalar, /* no-op */)
 DEFUNOP_OP (hermitian, float_scalar, /* no-op */)
@@ -66,31 +66,31 @@ DEFBINOP_OP (mul, float_scalar, float_sc
 
 DEFBINOP (div, float_scalar, float_scalar)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_scalar)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP_OP (lt, float_scalar, float_scalar, <)
 DEFBINOP_OP (le, float_scalar, float_scalar, <=)
 DEFBINOP_OP (eq, float_scalar, float_scalar, ==)
 DEFBINOP_OP (ge, float_scalar, float_scalar, >=)
@@ -101,31 +101,31 @@ DEFBINOP_OP (el_mul, float_scalar, float
 
 DEFBINOP (el_div, float_scalar, float_scalar)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_scalar)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFSCALARBOOLOP_OP (el_and, float_scalar, float_scalar, &&)
 DEFSCALARBOOLOP_OP (el_or, float_scalar, float_scalar, ||)
 
 DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array,
diff --git a/libinterp/operators/op-i16-i16.cc b/libinterp/operators/op-i16-i16.cc
--- a/libinterp/operators/op-i16-i16.cc
+++ b/libinterp/operators/op-i16-i16.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-i16nda.h"
 
 #include "mx-i16nda-fnda.h"
 #include "mx-fnda-i16nda.h"
 
 #include "mx-i16-fnda.h"
 #include "mx-fnda-i16.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-i32-i32.cc b/libinterp/operators/op-i32-i32.cc
--- a/libinterp/operators/op-i32-i32.cc
+++ b/libinterp/operators/op-i32-i32.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-i32nda.h"
 
 #include "mx-i32nda-fnda.h"
 #include "mx-fnda-i32nda.h"
 
 #include "mx-i32-fnda.h"
 #include "mx-fnda-i32.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-i64-i64.cc b/libinterp/operators/op-i64-i64.cc
--- a/libinterp/operators/op-i64-i64.cc
+++ b/libinterp/operators/op-i64-i64.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-i64nda.h"
 
 #include "mx-i64nda-fnda.h"
 #include "mx-fnda-i64nda.h"
 
 #include "mx-i64-fnda.h"
 #include "mx-fnda-i64.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-i8-i8.cc b/libinterp/operators/op-i8-i8.cc
--- a/libinterp/operators/op-i8-i8.cc
+++ b/libinterp/operators/op-i8-i8.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-i8nda.h"
 
 #include "mx-i8nda-fnda.h"
 #include "mx-fnda-i8nda.h"
 
 #include "mx-i8-fnda.h"
 #include "mx-fnda-i8.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-int-concat.cc b/libinterp/operators/op-int-concat.cc
--- a/libinterp/operators/op-int-concat.cc
+++ b/libinterp/operators/op-int-concat.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
diff --git a/libinterp/operators/op-int-conv.cc b/libinterp/operators/op-int-conv.cc
--- a/libinterp/operators/op-int-conv.cc
+++ b/libinterp/operators/op-int-conv.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -176,56 +176,56 @@ along with Octave; see the file COPYING.
   DEFINTBINOP_OP (PFX ## _sub, T1 ## scalar, T2 ## scalar, -, T3) \
   DEFINTBINOP_OP (PFX ## _mul, T1 ## scalar, T2 ## scalar, *, T3) \
  \
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^) \
  \
   DEFBINOP (PFX ## _ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)    \
  \
   DEFBINOP (PFX ## _el_div, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v2.T2 ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _el_pow, T1 ## scalar, T2 ## scalar, xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## scalar, T2 ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
  \
     if (! v1.T1 ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     return retval; \
   }
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2) \
   DEFBINOP (PFX ## _el_and, T2, T2) \
   { \
@@ -318,17 +318,17 @@ along with Octave; see the file COPYING.
  \
   /* DEFBINOP_FN (PFX ## _pow, TS ## scalar, TM ## matrix, xpow) */ \
  \
   DEFBINOP (PFX ## _ldiv, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TS ## scalar_value () / v1.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
   DEFBINOP (PFX ## _el_div, TS ## scalar, TM ## matrix) \
   { \
@@ -340,17 +340,17 @@ along with Octave; see the file COPYING.
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TS ## scalar, TM ## matrix) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
  \
     if (! v1.TS ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
     return retval; \
   }
 
 #define OCTAVE_SM_INT_CMP_OPS(PFX, TS, TM) \
   DEFNDBINOP_FN (PFX ## _lt, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_le) \
@@ -463,17 +463,17 @@ along with Octave; see the file COPYING.
   DEFINTNDBINOP_OP (PFX ## _sub, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
  \
   DEFBINOP (PFX ## _div, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   /* DEFBINOP_FN (PFX ## _pow, TM ## matrix, TS ## scalar, xpow) */ \
  \
   /* DEFBINOP (PFX ## _ldiv, TM ## matrix, TS ## scalar) */ \
@@ -488,17 +488,17 @@ along with Octave; see the file COPYING.
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
  \
   DEFBINOP (PFX ## _el_div, TM ## matrix, TS ## scalar) \
   { \
     CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
  \
     if (! v2.TS ## scalar_value ()) \
-      gripe_divide_by_zero (); \
+      warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TM ## matrix, TS ## scalar) \
@@ -698,17 +698,17 @@ octave_value elem_xpow (FloatNDArray a, 
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           return bsxfun_pow (a, b); \
         else \
-          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+          err_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -719,17 +719,17 @@ octave_value elem_xpow (FloatNDArray a, 
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           return bsxfun_pow (a, b); \
         else \
-          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+          err_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -740,17 +740,17 @@ octave_value elem_xpow (FloatNDArray a, 
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           return bsxfun_pow (a, b); \
         else \
-          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+          err_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -761,17 +761,17 @@ octave_value elem_xpow (FloatNDArray a, 
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           return bsxfun_pow (a, b); \
         else \
-          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+          err_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -782,17 +782,17 @@ octave_value elem_xpow (FloatNDArray a, 
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
           return bsxfun_pow (a, b); \
         else \
-          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
+          err_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-m-cm.h"
 #include "mx-cm-m.h"
 #include "mx-nda-cnda.h"
 #include "mx-cnda-nda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-m-cs.h"
 #include "mx-cs-m.h"
 #include "mx-nda-cs.h"
 #include "mx-cs-nda.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
@@ -50,17 +50,17 @@ DEFNDBINOP_OP (mul, matrix, complex, arr
 
 DEFBINOP (div, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFBINOP_FN (pow, matrix, complex, xpow)
 
 DEFBINOP (ldiv, matrix, complex)
 {
@@ -87,17 +87,17 @@ DEFNDBINOP_OP (el_mul, matrix, complex, 
 
 DEFBINOP (el_div, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, matrix, complex, array, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, complex)
 {
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -44,17 +44,17 @@ DEFNDBINOP_OP (mul, matrix, scalar, arra
 
 DEFBINOP (div, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFBINOP_FN (pow, matrix, scalar, xpow)
 
 DEFBINOP (ldiv, matrix, scalar)
 {
@@ -81,17 +81,17 @@ DEFNDBINOP_OP (el_mul, matrix, scalar, a
 
 DEFBINOP (el_div, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, matrix, scalar, array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, scalar)
 {
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
@@ -51,17 +51,17 @@ DEFBINOP (div, matrix, sparse_complex_ma
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.matrix_value (),
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -50,17 +50,17 @@ DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
diff --git a/libinterp/operators/op-pm-pm.cc b/libinterp/operators/op-pm-pm.cc
--- a/libinterp/operators/op-pm-pm.cc
+++ b/libinterp/operators/op-pm-pm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-perm.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xpow.h"
diff --git a/libinterp/operators/op-pm-scm.cc b/libinterp/operators/op-pm-scm.cc
--- a/libinterp/operators/op-pm-scm.cc
+++ b/libinterp/operators/op-pm-scm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-perm.h"
 #include "ov-cx-sparse.h"
 
diff --git a/libinterp/operators/op-pm-sm.cc b/libinterp/operators/op-pm-sm.cc
--- a/libinterp/operators/op-pm-sm.cc
+++ b/libinterp/operators/op-pm-sm.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-perm.h"
 #include "ov-re-sparse.h"
 
diff --git a/libinterp/operators/op-range.cc b/libinterp/operators/op-range.cc
--- a/libinterp/operators/op-range.cc
+++ b/libinterp/operators/op-range.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-range.h"
 #include "ov-ch-mat.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-complex.h"
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "mx-s-cm.h"
 #include "mx-cm-s.h"
 #include "mx-s-cnda.h"
 #include "mx-cnda-s.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
@@ -66,17 +66,17 @@ DEFBINOP_FN (pow, scalar, complex_matrix
 
 DEFBINOP (ldiv, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, scalar, complex_matrix, scalar, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, scalar, complex_matrix, scalar, complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, scalar, complex_matrix, scalar, complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, scalar, complex_matrix, scalar, complex_array, mx_el_ge)
@@ -89,17 +89,17 @@ DEFNDBINOP_FN (el_pow, scalar, complex_m
 
 DEFBINOP (el_ldiv, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, scalar, complex_matrix, scalar, complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, complex_matrix, scalar, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (s_cm, scalar, complex_matrix, array, complex_array, concat)
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
@@ -45,31 +45,31 @@ DEFBINOP_OP (mul, scalar, complex, *)
 
 DEFBINOP (div, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (pow, scalar, complex, xpow)
 
 DEFBINOP (ldiv, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFCMPLXCMPOP_OP (lt, scalar, complex, <)
 DEFCMPLXCMPOP_OP (le, scalar, complex, <=)
 DEFCMPLXCMPOP_OP (eq, scalar, complex, ==)
 DEFCMPLXCMPOP_OP (ge, scalar, complex, >=)
@@ -80,31 +80,31 @@ DEFBINOP_OP (el_mul, scalar, complex, *)
 
 DEFBINOP (el_div, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (el_pow, scalar, complex, xpow)
 
 DEFBINOP (el_ldiv, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFBINOP (el_and, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
diff --git a/libinterp/operators/op-s-m.cc b/libinterp/operators/op-s-m.cc
--- a/libinterp/operators/op-s-m.cc
+++ b/libinterp/operators/op-s-m.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -60,17 +60,17 @@ DEFBINOP_FN (pow, scalar, matrix, xpow)
 
 DEFBINOP (ldiv, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
 
 DEFNDBINOP_FN (lt, scalar, matrix, scalar, array, mx_el_lt)
 DEFNDBINOP_FN (le, scalar, matrix, scalar, array, mx_el_le)
 DEFNDBINOP_FN (eq, scalar, matrix, scalar, array, mx_el_eq)
 DEFNDBINOP_FN (ge, scalar, matrix, scalar, array, mx_el_ge)
@@ -83,17 +83,17 @@ DEFNDBINOP_FN (el_pow, scalar, matrix, s
 
 DEFBINOP (el_ldiv, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, scalar, matrix, scalar, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, matrix, scalar, array, mx_el_or)
 
 DEFNDCATOP_FN (s_m, scalar, matrix, array, array, concat)
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 // scalar unary ops.
 
 DEFUNOP (not, scalar)
 {
   CAST_UNOP_ARG (const octave_scalar&);
   double x = v.scalar_value ();
   if (xisnan (x))
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, scalar, /* no-op */)
 DEFUNOP_OP (uminus, scalar, -)
 DEFUNOP_OP (transpose, scalar, /* no-op */)
 DEFUNOP_OP (hermitian, scalar, /* no-op */)
@@ -67,31 +67,31 @@ DEFBINOP_OP (mul, scalar, scalar, *)
 
 DEFBINOP (div, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (pow, scalar, scalar, xpow)
 
 DEFBINOP (ldiv, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
 DEFBINOP_OP (lt, scalar, scalar, <)
 DEFBINOP_OP (le, scalar, scalar, <=)
 DEFBINOP_OP (eq, scalar, scalar, ==)
 DEFBINOP_OP (ge, scalar, scalar, >=)
@@ -102,31 +102,31 @@ DEFBINOP_OP (el_mul, scalar, scalar, *)
 
 DEFBINOP (el_div, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (el_pow, scalar, scalar, xpow)
 
 DEFBINOP (el_ldiv, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
 DEFSCALARBOOLOP_OP (el_and, scalar, scalar, &&)
 DEFSCALARBOOLOP_OP (el_or, scalar, scalar, ||)
 
 DEFNDCATOP_FN (s_s, scalar, scalar, array, array, concat)
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -51,17 +51,17 @@ DEFBINOP (div, scalar, sparse_complex_ma
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.scalar_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
@@ -82,17 +82,17 @@ DEFBINOP (ldiv, scalar, sparse_complex_m
 {
   CAST_BINOP_ARGS (const octave_scalar&,
                    const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (lt, scalar, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, scalar, sparse_complex_matrix, mx_el_le)
@@ -109,17 +109,17 @@ DEFBINOP (el_ldiv, scalar, sparse_comple
 {
   CAST_BINOP_ARGS (const octave_scalar&,
                    const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
diff --git a/libinterp/operators/op-s-sm.cc b/libinterp/operators/op-s-sm.cc
--- a/libinterp/operators/op-s-sm.cc
+++ b/libinterp/operators/op-s-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -47,17 +47,17 @@ DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseMatrix (1, 1, v1.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.double_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
@@ -76,17 +76,17 @@ DEFBINOP (pow, scalar, sparse_matrix)
 DEFBINOP (ldiv, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (lt, scalar, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, scalar, sparse_matrix, mx_el_le)
@@ -102,17 +102,17 @@ DEFBINOP_FN (el_pow, scalar, sparse_matr
 DEFBINOP (el_ldiv, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  scalar, sparse_matrix, mx_el_or)
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool-mat.h"
 #include "boolMatrix.h"
 #include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
 #include "ov-re-sparse.h"
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -69,17 +69,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, c
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -48,17 +48,17 @@ DEFBINOP (div, sparse_complex_matrix, co
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
@@ -71,17 +71,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, c
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
@@ -105,17 +105,17 @@ DEFBINOP (el_div, sparse_complex_matrix,
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval =  octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
@@ -69,17 +69,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, m
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -51,17 +51,17 @@ DEFBINOP (div, sparse_complex_matrix, sc
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
@@ -79,17 +79,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
@@ -112,17 +112,17 @@ DEFBINOP (el_div, sparse_complex_matrix,
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, scalar, elem_xpow)
 
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -20,33 +20,33 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
@@ -100,17 +100,17 @@ DEFBINOP (div, sparse_complex_matrix, sp
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_complex_matrix_value (), typ);
@@ -130,17 +130,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret =
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
 #include "smx-sm-scm.h"
@@ -50,17 +50,17 @@ DEFBINOP (div, sparse_complex_matrix, sp
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_matrix_value (), typ);
@@ -80,17 +80,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -68,17 +68,17 @@ DEFBINOP (ldiv, sparse_matrix, complex_m
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (),
diff --git a/libinterp/operators/op-sm-cs.cc b/libinterp/operators/op-sm-cs.cc
--- a/libinterp/operators/op-sm-cs.cc
+++ b/libinterp/operators/op-sm-cs.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -49,17 +49,17 @@ DEFBINOP_OP (mul, sparse_matrix, complex
 DEFBINOP (div, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_matrix, complex)
 {
@@ -71,17 +71,17 @@ DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
@@ -103,17 +103,17 @@ DEFBINOP_OP (el_mul, sparse_matrix, comp
 DEFBINOP (el_div, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, complex, elem_xpow)
 
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -66,17 +66,17 @@ DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       Matrix ret = xleftdiv (v1.sparse_matrix_value (),
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -46,17 +46,17 @@ DEFBINOP_OP (mul, sparse_matrix, scalar,
 DEFBINOP (div, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_matrix, scalar)
 {
@@ -73,17 +73,17 @@ DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (SparseMatrix(1, 1, v2.scalar_value () / d));
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
@@ -105,17 +105,17 @@ DEFBINOP_OP (el_mul, sparse_matrix, scal
 DEFBINOP (el_div, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
-    gripe_divide_by_zero ();
+    warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, scalar, elem_xpow)
 
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
 #include "smx-sm-scm.h"
@@ -50,17 +50,17 @@ DEFBINOP (div, sparse_matrix, sparse_com
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (),
                                       v2.sparse_complex_matrix_value (), typ);
@@ -80,17 +80,17 @@ DEFBINOP (ldiv, sparse_matrix, sparse_co
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret =
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 #include "sparse-xpow.h"
@@ -74,17 +74,17 @@ DEFBINOP (div, sparse_matrix, sparse_mat
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseMatrix ret = xdiv (v1.sparse_matrix_value (),
                                v2.sparse_matrix_value (), typ);
@@ -103,17 +103,17 @@ DEFBINOP (ldiv, sparse_matrix, sparse_ma
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.double_value ();
 
       if (d == 0.0)
-        gripe_divide_by_zero ();
+        warn_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (),
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_matrix)
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_scalar)
diff --git a/libinterp/operators/op-str-str.cc b/libinterp/operators/op-str-str.cc
--- a/libinterp/operators/op-str-str.cc
+++ b/libinterp/operators/op-str-str.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 // string unary ops.
diff --git a/libinterp/operators/op-struct.cc b/libinterp/operators/op-struct.cc
--- a/libinterp/operators/op-struct.cc
+++ b/libinterp/operators/op-struct.cc
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-struct.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 // struct ops.
diff --git a/libinterp/operators/op-ui16-ui16.cc b/libinterp/operators/op-ui16-ui16.cc
--- a/libinterp/operators/op-ui16-ui16.cc
+++ b/libinterp/operators/op-ui16-ui16.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-ui16nda.h"
 
 #include "mx-ui16nda-fnda.h"
 #include "mx-fnda-ui16nda.h"
 
 #include "mx-ui16-fnda.h"
 #include "mx-fnda-ui16.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-ui32-ui32.cc b/libinterp/operators/op-ui32-ui32.cc
--- a/libinterp/operators/op-ui32-ui32.cc
+++ b/libinterp/operators/op-ui32-ui32.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-ui32nda.h"
 
 #include "mx-ui32nda-fnda.h"
 #include "mx-fnda-ui32nda.h"
 
 #include "mx-ui32-fnda.h"
 #include "mx-fnda-ui32.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-ui64-ui64.cc b/libinterp/operators/op-ui64-ui64.cc
--- a/libinterp/operators/op-ui64-ui64.cc
+++ b/libinterp/operators/op-ui64-ui64.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-ui64nda.h"
 
 #include "mx-ui64nda-fnda.h"
 #include "mx-fnda-ui64nda.h"
 
 #include "mx-ui64-fnda.h"
 #include "mx-fnda-ui64.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/op-ui8-ui8.cc b/libinterp/operators/op-ui8-ui8.cc
--- a/libinterp/operators/op-ui8-ui8.cc
+++ b/libinterp/operators/op-ui8-ui8.cc
@@ -61,17 +61,17 @@ along with Octave; see the file COPYING.
 #include "mx-fs-ui8nda.h"
 
 #include "mx-ui8nda-fnda.h"
 #include "mx-fnda-ui8nda.h"
 
 #include "mx-ui8-fnda.h"
 #include "mx-fnda-ui8.h"
 
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-int8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -286,27 +286,27 @@ extern void install_ops (void);
     return octave_value \
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFCMPLXCMPOP_OP(name, t1, t2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
-    gripe_warn_complex_cmp (); \
+    warn_complex_cmp (); \
     return octave_value \
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFSCALARBOOLOP_OP(name, t1, t2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     if (xisnan (v1.CONCAT2(t1, _value) ()) || xisnan (v2.CONCAT2(t2, _value) ())) \
-      gripe_nan_to_logical_conversion (); \
+      err_nan_to_logical_conversion (); \
     else \
       return octave_value \
         (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   BINOPDECL (name, a1, a2) \
   { \
@@ -381,14 +381,14 @@ extern void install_ops (void);
 #define DEFNDCATOP_FN2(name, t1, t2, tc1, tc2, e1, e2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (tc1 (v1.CONCAT2(e1, _value) ()) . f (tc2 (v2.CONCAT2(e2, _value) ()), ra_idx)); \
   }
 
 #define CATOP_NONCONFORMANT(msg) \
-  gripe_nonconformant (msg, \
+  err_nonconformant (msg, \
                        a1.rows (), a1.columns (), \
                        a2.rows (), a2.columns ()); \
   return octave_value ()
 
 #endif
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -95,17 +95,17 @@ object) relevant global values before an
 // class declarations.  We can't include oct-parse.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
 #include "Cell.h"
 #include "comment-list.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "lex.h"
 #include "ov.h"
 #include "parse.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
 #include "toplev.h"
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <set>
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-assign.h"
@@ -90,17 +90,17 @@ tree_simple_assignment::rvalue1 (int)
           rhs_val = lst(0);
         }
 
       try
         {
           octave_lvalue ult = lhs->lvalue ();
 
           if (ult.numel () != 1)
-            gripe_nonbraced_cs_list_assignment ();
+            err_nonbraced_cs_list_assignment ();
 
           ult.assign (etype, rhs_val);
 
           if (etype == octave_value::op_asn_eq)
             retval = rhs_val;
           else
             retval = ult.value ();
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include <fstream>
 #include <typeinfo>
 
 #include "debug.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "input.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "variables.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "toplev.h"
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
-#include "gripes.h"
+#include "errwarn.h"
 
 // Index expressions.
 
 tree_index_expression::tree_index_expression (int l, int c)
   : tree_expression (l, c), expr (0), args (0), type (),
     arg_nm (), dyn_field () { }
 
 tree_index_expression::tree_index_expression (tree_expression *e,
@@ -176,17 +176,17 @@ static inline octave_value_list
 make_value_list (tree_argument_list *args, const string_vector& arg_nm,
                  const octave_value *object, bool rvalue = true)
 {
   octave_value_list retval;
 
   if (args)
     {
       if (rvalue && object && args->has_magic_end () && object->is_undefined ())
-        gripe_invalid_inquiry_subscript ();
+        err_invalid_inquiry_subscript ();
       else
         retval = args->convert_to_const_vector (object);
     }
 
   octave_idx_type n = retval.length ();
 
   if (n > 0)
     retval.stash_name_tags (arg_nm);
@@ -362,32 +362,32 @@ tree_index_expression::rvalue (int nargo
                   octave_value_list tmp_list
                     =tmp.subsref (type.substr (tmpi, i-tmpi), idx, nargout);
 
                   tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
                   tmpi = i;
                   idx.clear ();
 
                   if (tmp.is_cs_list ())
-                    gripe_indexed_cs_list ();
+                    err_indexed_cs_list ();
 
                   if (tmp.is_function ())
                     {
                       octave_function *fcn = tmp.function_value (true);
 
                       if (fcn && ! fcn->is_postfix_index_handled (type[i]))
                         {
                           octave_value_list empty_args;
 
                           tmp_list = tmp.do_multi_index_op (1, empty_args);
                           tmp = (tmp_list.length ()
                                  ? tmp_list(0) : octave_value ());
 
                           if (tmp.is_cs_list ())
-                            gripe_indexed_cs_list ();
+                            err_indexed_cs_list ();
                         }
                     }
                 }
               catch (index_exception& e)  // problems with index range, type etc.
                 {
                   final_index_error (e, expr);
                 }
             }
@@ -485,17 +485,17 @@ tree_index_expression::lvalue (void)
   octave_value tmp = retval.value ();
 
   octave_idx_type tmpi = 0;
   std::list<octave_value_list> tmpidx;
 
   for (int i = 0; i < n; i++)
     {
       if (retval.numel () != 1)
-        gripe_indexed_cs_list ();
+        err_indexed_cs_list ();
       else if (tmpi < i)
         {
           try
             {
               tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
             }
           catch (index_exception& e)  // problems with range, invalid type etc.
             {
@@ -528,17 +528,17 @@ tree_index_expression::lvalue (void)
         case '{':
           {
             octave_value_list tidx
               = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
             if (tmp.is_undefined ())
               {
                 if (tidx.has_magic_colon ())
-                  gripe_invalid_inquiry_subscript ();
+                  err_invalid_inquiry_subscript ();
                 else
                   tmp = Cell ();
               }
             else if (tmp.is_zero_by_zero ()
                      && (tmp.is_matrix_type () || tmp.is_string ()))
               {
                 tmp = Cell ();
               }
@@ -563,17 +563,17 @@ tree_index_expression::lvalue (void)
               {
                 octave_value_list pidx = idx.back ();
 
                 // Use octave_map, not octave_scalar_map so that the
                 // dimensions are 0x0, not 1x1.
                 if (tmp.is_undefined ())
                   {
                     if (pidx.has_magic_colon ())
-                      gripe_invalid_inquiry_subscript ();
+                      err_invalid_inquiry_subscript ();
                     else
                       tmp = octave_map ();
                   }
                 else if (autoconv)
                   tmp = octave_map ();
 
                 retval.numel (tmp.numel (pidx));
 
diff --git a/libinterp/parse-tree/pt-loop.cc b/libinterp/parse-tree/pt-loop.cc
--- a/libinterp/parse-tree/pt-loop.cc
+++ b/libinterp/parse-tree/pt-loop.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "oct-map.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-exp.h"
 #include "pt-jit.h"
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "oct-locbuf.h"
 #include "quit.h"
 
 #include "data.h"
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ovl.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-mat.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "ov.h"
@@ -955,18 +955,18 @@ tree_matrix::rvalue1 (int)
           else
             retval = do_single_type_concat<FloatComplexNDArray> (dv, tmp);
         }
       else if (result_type == "char")
         {
           char type = all_dq_strings_p ? '"' : '\'';
 
           if (! all_strings_p)
-            gripe_implicit_conversion ("Octave:num-to-str",
-                                       "numeric", result_type);
+            warn_implicit_conversion ("Octave:num-to-str",
+                                      "numeric", result_type);
           else
             maybe_warn_string_concat (all_dq_strings_p, all_sq_strings_p);
 
           charNDArray result (dv, Vstring_fill_char);
 
           single_type_concat<charNDArray> (result, tmp);
 
           retval = octave_value (result, type);
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <typeinfo>
 
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
-#include "gripes.h"
+#include "errwarn.h"
 #include "ov.h"
 #include "octave-link.h"
 #include "oct-lvalue.h"
 #include "input.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -173,69 +173,69 @@ any_ones (const Array<octave_idx_type>& 
     }
   return retval;
 }
 
 octave_idx_type
 compute_index (octave_idx_type n, const dim_vector& dims)
 {
   if (n < 0)
-    gripe_invalid_index (n, 1, 1);
+    err_invalid_index (n, 1, 1);
   if (n >= dims.numel ())
-    gripe_index_out_of_range (1, 1, n+1, dims.numel (), dims);
+    err_index_out_of_range (1, 1, n+1, dims.numel (), dims);
 
   return n;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, const dim_vector& dims)
 {
   if (i < 0)
-    gripe_invalid_index (i, 2, 1);
+    err_invalid_index (i, 2, 1);
   else if (j < 0)
-    gripe_invalid_index (j, 2, 2);
+    err_invalid_index (j, 2, 2);
   if (i >= dims(0))
-    gripe_index_out_of_range (2, 1, i+1, dims(0), dims);
+    err_index_out_of_range (2, 1, i+1, dims(0), dims);
   if (j >= dims.numel (1))
-    gripe_index_out_of_range (2, 2, j+1, dims.numel (1), dims);
+    err_index_out_of_range (2, 2, j+1, dims.numel (1), dims);
 
   return j*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims)
 {
   if (i < 0)
-    gripe_invalid_index (i, 3, 1);
+    err_invalid_index (i, 3, 1);
   else if (j < 0)
-    gripe_invalid_index (j, 3, 2);
+    err_invalid_index (j, 3, 2);
   else if (k < 0)
-    gripe_invalid_index (k, 3, 3);
+    err_invalid_index (k, 3, 3);
   if (i >= dims(0))
-    gripe_index_out_of_range (3, 1, i+1, dims(0), dims);
+    err_index_out_of_range (3, 1, i+1, dims(0), dims);
   if (j >= dims(1))
-    gripe_index_out_of_range (3, 2, j+1, dims(1), dims);
+    err_index_out_of_range (3, 2, j+1, dims(1), dims);
   if (k >= dims.numel (2))
-    gripe_index_out_of_range (3, 3, k+1, dims.numel (2), dims);
+    err_index_out_of_range (3, 3, k+1, dims.numel (2), dims);
 
   return (k*dims(1) + j)*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
   int nd = ra_idx.numel ();
   const dim_vector dv = dims.redim (nd);
   for (int d = 0; d < nd; d++)
     {
       if (ra_idx(d) < 0)
-        gripe_invalid_index (ra_idx(d), nd, d+1);
+        err_invalid_index (ra_idx(d), nd, d+1);
       if (ra_idx(d) >= dv(d))
-        gripe_index_out_of_range (nd, d+1, ra_idx(d)+1, dv(d), dims);
+        err_index_out_of_range (nd, d+1, ra_idx(d)+1, dv(d), dims);
     }
 
   return dv.compute_index (ra_idx.data ());
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
@@ -554,17 +554,17 @@ sub2ind (const dim_vector& dv, const Arr
               all_ranges = all_ranges && idx.is_range ();
               if (clen < 0)
                 clen = idx.length (n);
               else if (clen != idx.length (n))
                 (*current_liboctave_error_handler)
                   ("sub2ind: lengths of indices must match");
 
               if (idx.extent (n) > n)
-                  gripe_index_out_of_range (len, i+1, idx.extent (n), n);
+                  err_index_out_of_range (len, i+1, idx.extent (n), n);
             }
           catch (index_exception& e)
             {
               e.set_pos_if_unset (len, i+1);
               e.set_var ();
               std::string msg = e.message ();
               (*current_liboctave_error_with_id_handler)
                 (e.err_id (), msg.c_str ());
diff --git a/liboctave/array/Array-util.h b/liboctave/array/Array-util.h
--- a/liboctave/array/Array-util.h
+++ b/liboctave/array/Array-util.h
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_Array_util_h)
 #define octave_Array_util_h 1
 
 #include "Array.h"
 #include "dim-vector.h"
 #include "idx-vector.h"
-#include "lo-array-gripes.h"
+#include "lo-array-errwarn.h"
 
 extern OCTAVE_API bool index_in_bounds (const Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions);
 
 extern OCTAVE_API void increment_index (Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions,
                                         int start_dimension = 0);
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -185,19 +185,19 @@ Array<T>::compute_index (const Array<oct
 }
 
 template <class T>
 T&
 Array<T>::checkelem (octave_idx_type n)
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
-    gripe_invalid_index (n);
+    err_invalid_index (n);
   if (n >= slice_len)
-    gripe_index_out_of_range (1, 1, n+1, slice_len, dimensions);
+    err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
 template <class T>
 T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j)
 {
@@ -219,19 +219,19 @@ Array<T>::checkelem (const Array<octave_
 }
 
 template <class T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type n) const
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
-    gripe_invalid_index (n);
+    err_invalid_index (n);
   if (n >= slice_len)
-    gripe_index_out_of_range (1, 1, n+1, slice_len, dimensions);
+    err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
 template <class T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j) const
 {
@@ -255,46 +255,46 @@ Array<T>::checkelem (const Array<octave_
 
 template <class T>
 Array<T>
 Array<T>::column (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
 #ifdef BOUNDS_CHECKING
   if (k < 0 || k > dimensions.numel (1))
-    gripe_index_out_of_range (2, 2, k+1, dimensions.numel (1), dimensions);
+    err_index_out_of_range (2, 2, k+1, dimensions.numel (1), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, 1), k*r, k*r + r);
 }
 
 template <class T>
 Array<T>
 Array<T>::page (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
   octave_idx_type c = dimensions(1);
   octave_idx_type p = r*c;
 #ifdef BOUNDS_CHECKING
   if (k < 0 || k > dimensions.numel (2))
-    gripe_index_out_of_range (3, 3, k+1, dimensions.numel (2), dimensions);
+    err_index_out_of_range (3, 3, k+1, dimensions.numel (2), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, c), k*p, k*p + p);
 }
 
 template <class T>
 Array<T>
 Array<T>::linear_slice (octave_idx_type lo, octave_idx_type up) const
 {
 #ifdef BOUNDS_CHECKING
   if (lo < 0)
-    gripe_index_out_of_range (1, 1, lo+1, numel (), dimensions);
+    err_index_out_of_range (1, 1, lo+1, numel (), dimensions);
   if (up > numel ())
-    gripe_index_out_of_range (1, 1, up, numel (), dimensions);
+    err_index_out_of_range (1, 1, up, numel (), dimensions);
 #endif
   if (up < lo) up = lo;
   return Array<T> (*this, dim_vector (up - lo, 1), lo, up);
 }
 
 // Helper class for multi-d dimension permuting (generalized transpose).
 class rec_permute_helper
 {
@@ -721,17 +721,17 @@ Array<T>::index (const idx_vector& i) co
   if (i.is_colon ())
     {
       // A(:) produces a shallow copy as a column vector.
       retval = Array<T> (*this, dim_vector (n, 1));
     }
   else
     {
       if (i.extent (n) != n)
-        gripe_index_out_of_range (1, 1, i.extent (n), n, dimensions); // throws
+        err_index_out_of_range (1, 1, i.extent (n), n, dimensions); // throws
 
       // FIXME: this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // FIXME: this is for Matlab compatibility.  Matlab 2007 given
       //
       //   b = ones (3,1)
@@ -788,19 +788,19 @@ Array<T>::index (const idx_vector& i, co
   if (i.is_colon () && j.is_colon ())
     {
       // A(:,:) produces a shallow copy.
       retval = Array<T> (*this, dv);
     }
   else
     {
       if (i.extent (r) != r)
-        gripe_index_out_of_range (2, 1, i.extent (r), r, dimensions); // throws
+        err_index_out_of_range (2, 1, i.extent (r), r, dimensions); // throws
       if (j.extent (c) != c)
-        gripe_index_out_of_range (2, 2, j.extent (c), c, dimensions); // throws
+        err_index_out_of_range (2, 2, j.extent (c), c, dimensions); // throws
 
       octave_idx_type n = numel ();
       octave_idx_type il = i.length (r);
       octave_idx_type jl = j.length (c);
 
       idx_vector ii (i);
 
       if (ii.maybe_reduce (r, j, c))
@@ -850,17 +850,17 @@ Array<T>::index (const Array<idx_vector>
       // Get dimensions, allowing Fortran indexing in the last dim.
       dim_vector dv = dimensions.redim (ial);
 
       // Check for out of bounds conditions.
       bool all_colons = true;
       for (int i = 0; i < ial; i++)
         {
           if (ia(i).extent (dv(i)) != dv(i))
-            gripe_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
+            err_index_out_of_range (ial, i+1, ia(i).extent (dv(i)), dv(i), dimensions); // throws
 
           all_colons = all_colons && ia(i).is_colon ();
         }
 
 
       if (all_colons)
         {
           // A(:,:,...,:) produces a shallow copy.
@@ -926,17 +926,17 @@ Array<T>::resize1 (octave_idx_type n, co
       if (rows () == 0 || rows () == 1)
         dv = dim_vector (1, n);
       else if (columns () == 1)
         dv = dim_vector (n, 1);
       else
         invalid = true;
 
       if (invalid)
-        gripe_invalid_resize ();
+        err_invalid_resize ();
       else
         {
           octave_idx_type nx = numel ();
           if (n == nx - 1 && n > 0)
             {
               // Stack "pop" operation.
               if (rep->count == 1)
                 slice_data[slice_len-1] = T ();
@@ -975,17 +975,17 @@ Array<T>::resize1 (octave_idx_type n, co
               std::copy (data (), data () + n0, dest);
               std::fill_n (dest + n0, n1, rfv);
 
               *this = tmp;
             }
         }
     }
   else
-    gripe_invalid_resize ();
+    err_invalid_resize ();
 }
 
 template <class T>
 void
 Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r >= 0 && c >= 0 && ndims () == 2)
     {
@@ -1019,17 +1019,17 @@ Array<T>::resize2 (octave_idx_type r, oc
             }
 
           std::fill_n (dest, r * c1, rfv);
 
           *this = tmp;
         }
     }
   else
-    gripe_invalid_resize ();
+    err_invalid_resize ();
 
 }
 
 template<class T>
 void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.length ();
@@ -1043,17 +1043,17 @@ Array<T>::resize (const dim_vector& dv, 
           // Prepare for recursive resizing.
           rec_resize_helper rh (dv, dimensions.redim (dvl));
 
           // Do it.
           rh.resize_fill (data (), tmp.fortran_vec (), rfv);
           *this = tmp;
         }
       else
-        gripe_invalid_resize ();
+        err_invalid_resize ();
     }
 }
 
 template <class T>
 Array<T>
 Array<T>::index (const idx_vector& i, bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
@@ -1176,17 +1176,17 @@ Array<T>::assign (const idx_vector& i, c
         {
           if (rhl == 1)
             i.fill (rhs(0), n, fortran_vec ());
           else
             i.assign (rhs.data (), n, fortran_vec ());
         }
     }
   else
-    gripe_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
+    err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
 }
 
 // Assignment to a 2-dimensional array
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
@@ -1280,17 +1280,17 @@ Array<T>::assign (const idx_vector& i, c
                   for (octave_idx_type k = 0; k < jl; k++)
                     src += i.assign (src, r, dest + r * j.xelem (k));
                 }
             }
         }
     }
   // any empty RHS can be assigned to an empty LHS
   else if ((il != 0 && jl != 0) || (rhdv(0) != 0 && rhdv(1) != 0))
-    gripe_nonconformant ("=", il, jl, rhs.dim1 (), rhs.dim2 ());
+    err_nonconformant ("=", il, jl, rhs.dim1 (), rhs.dim2 ());
 }
 
 // Assignment to a multi-dimensional array
 template <class T>
 void
 Array<T>::assign (const Array<idx_vector>& ia,
                   const Array<T>& rhs, const T& rfv)
 {
@@ -1394,17 +1394,17 @@ Array<T>::assign (const Array<idx_vector
           lhsempty = rhsempty = false;
           for (int i = 0; i < ial; i++)
             {
               octave_idx_type l = ia(i).length (rdv(i));
               lhsempty = lhsempty || (l == 0);
               rhsempty = rhsempty || (rhdv(j++) == 0);
             }
           if (! lhsempty || ! rhsempty)
-            gripe_nonconformant ("=", dv, rhdv);
+            err_nonconformant ("=", dv, rhdv);
         }
     }
 }
 
 /*
 %!shared a
 %! a = [1 2; 3 4];
 %!error <op1 is 1x2, op2 is 1x3> a(1,:) = [1 2 3]
@@ -1419,17 +1419,17 @@ Array<T>::delete_elements (const idx_vec
   octave_idx_type n = numel ();
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
-        gripe_del_index_out_of_range (true, i.extent (n), n);
+        err_del_index_out_of_range (true, i.extent (n), n);
 
       octave_idx_type l, u;
       bool col_vec = ndims () == 2 && columns () == 1 && rows () != 1;
       if (i.is_scalar () && i(0) == n-1 && dimensions.is_vector ())
         {
           // Stack "pop" operation.
           resize1 (n-1);
         }
@@ -1466,17 +1466,17 @@ Array<T>::delete_elements (int dim, cons
   octave_idx_type n = dimensions(dim);
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
-        gripe_del_index_out_of_range (false, i.extent (n), n);
+        err_del_index_out_of_range (false, i.extent (n), n);
 
       octave_idx_type l, u;
 
       if (i.is_cont_range (n, l, u))
         {
           // Special case deleting a contiguous range.
           octave_idx_type nd = n + l - u;
           octave_idx_type dl = 1;
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -280,17 +280,17 @@ ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator +=", len, a_len);
+      err_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -302,17 +302,17 @@ ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator -=", len, a_len);
+      err_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -335,17 +335,17 @@ operator * (const ComplexMatrix& m, cons
   ComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
           if (nc == 0)
             retval.fill (0.0);
@@ -381,17 +381,17 @@ operator * (const DiagMatrix& m, const C
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
@@ -409,17 +409,17 @@ operator * (const ComplexDiagMatrix& m, 
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
@@ -437,17 +437,17 @@ operator * (const ComplexDiagMatrix& m, 
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -417,17 +417,17 @@ ComplexDiagMatrix::operator += (const Di
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
+      err_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
   if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -440,17 +440,17 @@ operator * (const ComplexDiagMatrix& a, 
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
@@ -466,17 +466,17 @@ operator * (const DiagMatrix& a, const C
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
@@ -499,17 +499,17 @@ operator * (const ComplexDiagMatrix& a, 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   ComplexDiagMatrix c (a_nr, b_nc);
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -2008,17 +2008,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2103,17 +2103,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2188,17 +2188,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -2247,17 +2247,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2275,17 +2275,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
@@ -3001,17 +3001,17 @@ ComplexMatrix::operator += (const DiagMa
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -3022,17 +3022,17 @@ ComplexMatrix::operator -= (const DiagMa
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3043,17 +3043,17 @@ ComplexMatrix::operator += (const Comple
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -3064,17 +3064,17 @@ ComplexMatrix::operator -= (const Comple
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3087,17 +3087,17 @@ ComplexMatrix::operator += (const Matrix
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -3111,17 +3111,17 @@ ComplexMatrix::operator -= (const Matrix
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -3711,17 +3711,17 @@ xgemm (const ComplexMatrix& a, const Com
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = ComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -495,17 +495,17 @@ ComplexNDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 ComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, Complex> (*this, mx_inline_not);
 }
 
 // FIXME: this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_nan (void) const
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -272,17 +272,17 @@ ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator +=", len, a_len);
+      err_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -294,17 +294,17 @@ ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator -=", len, a_len);
+      err_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
@@ -320,17 +320,17 @@ operator * (const ComplexRowVector& v, c
   ComplexRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
         retval.resize (a_nc, 0.0);
       else
         {
           // Transpose A to form A'*x == (x'*A)'
 
@@ -445,17 +445,17 @@ operator * (const ComplexRowVector& v, c
 {
   Complex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    gripe_nonconformant ("operator *", len, a_len);
+    err_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xzdotu, XZDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 // other operations
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1793,32 +1793,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2076,32 +2076,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2306,32 +2306,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2589,32 +2589,32 @@ SparseComplexMatrix::utsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2839,32 +2839,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3141,32 +3141,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3395,32 +3395,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3696,32 +3696,32 @@ SparseComplexMatrix::ltsolve (MatrixType
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3858,17 +3858,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -3955,17 +3955,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
@@ -4157,17 +4157,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4252,17 +4252,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
@@ -4421,17 +4421,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4506,17 +4506,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4539,17 +4539,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
@@ -4663,17 +4663,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4781,17 +4781,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -4814,17 +4814,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -4977,17 +4977,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5060,17 +5060,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5093,17 +5093,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5219,17 +5219,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5342,17 +5342,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
@@ -5375,17 +5375,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5528,17 +5528,17 @@ SparseComplexMatrix::factorize (octave_i
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            gripe_singular_matrix (rcond);
+            errwarn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexMatrix::solve numeric factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
@@ -5676,17 +5676,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -5927,17 +5927,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6206,17 +6206,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6436,17 +6436,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6565,17 +6565,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               if (status == UMFPACK_WARNING_singular_matrix
                   || rcond_plus_one == 1.0 || xisnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
@@ -7113,17 +7113,17 @@ SparseComplexMatrix::solve (const Comple
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
 
   SparseBoolMatrix r (nr, nc, nz2);
 
@@ -7675,17 +7675,17 @@ min (const SparseComplexMatrix& a, const
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SparseComplexMatrix
 max (const Complex& c, const SparseComplexMatrix& m)
 {
@@ -7792,17 +7792,17 @@ max (const SparseComplexMatrix& a, const
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        gripe_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
+        err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex,
                     0.0, real)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex, 0.0)
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -121,20 +121,20 @@ DiagArray2<T>::array_value (void) const
 template <typename T>
 bool
 DiagArray2<T>::check_idx (octave_idx_type r, octave_idx_type c) const
 {
   bool ok = true;
 
   if (r < 0 || r >= dim1 ())
     {
-      gripe_index_out_of_range (2, 1, r+1, dim1 (), dims ());
+      err_index_out_of_range (2, 1, r+1, dim1 (), dims ());
       ok = false;
     }
 
   if (c < 0 || c >= dim2 ())
     {
-      gripe_index_out_of_range (2, 2, c+1, dim2 (), dims ());
+      err_index_out_of_range (2, 2, c+1, dim2 (), dims ());
       ok = false;
     }
 
   return ok;
 }
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -76,17 +76,17 @@ operator * (const T& s, const MDiagArray
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
     if (a.d1 != b.d1 || a.d2 != b.d2) \
-      gripe_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
+      err_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
     return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
 // Unary MDiagArray2 ops.
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -33,17 +33,17 @@ plus_or_minus (MSparse<T>& a, const MSpa
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr != b_nr || a_nc != b_nc)
-    gripe_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
           octave_idx_type  ja = a.cidx (i);
@@ -303,17 +303,17 @@ plus_or_minus (const MSparse<T>& a, cons
                   octave_quit ();
                   r.data (idxj + a.ridx (i)) = op (a.data (i), b.data (0));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    gripe_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
@@ -424,17 +424,17 @@ product (const MSparse<T>& a, const MSpa
             {
               octave_quit ();
               r.data (i) = r.data (i) * b.data (0);
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    gripe_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
@@ -544,17 +544,17 @@ quotient (const MSparse<T>& a, const MSp
                   octave_quit ();
                   r.data (idxj + a.ridx (i)) = a.data (i) / val;
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
-    gripe_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
           octave_idx_type  ja = a.cidx (i);
           octave_idx_type  ja_max = a.cidx (i+1);
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -231,14 +231,14 @@ operator *(const PermMatrix& a, const Pe
   PermMatrix r;
 
   const Array<octave_idx_type> ia = a.col_perm_vec ();
   const Array<octave_idx_type> ib = b.col_perm_vec ();
 
   octave_idx_type n = a.columns ();
 
   if (n != b.rows ())
-    gripe_nonconformant ("operator *", n, n, b.rows (), b.rows ());
+    err_nonconformant ("operator *", n, n, b.rows (), b.rows ());
   else
     r = PermMatrix (ia.index (idx_vector (ib)), true, false);
 
   return r;
 }
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -69,17 +69,17 @@ Range::matrix_value (void) const
 
   return cache;
 }
 
 double
 Range::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= rng_numel)
-    gripe_index_out_of_range (1, 1, i+1, rng_numel);
+    err_index_out_of_range (1, 1, i+1, rng_numel);
 
   if (i == 0)
     return rng_base;
   else if (i < rng_numel - 1)
     return rng_base + i * rng_inc;
   else
     return rng_limit;
 }
@@ -132,17 +132,17 @@ Range::index (const idx_vector& i) const
 
   if (i.is_colon ())
     {
       retval = matrix_value ().reshape (dim_vector (rng_numel, 1));
     }
   else
     {
       if (i.extent (n) != n)
-        gripe_index_out_of_range (1, 1, i.extent (n), n); // throws
+        err_index_out_of_range (1, 1, i.extent (n), n); // throws
 
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // taken from Array.cc.
       if (n != 1 && rd.is_vector ())
         rd = dim_vector (1, il);
 
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -916,17 +916,17 @@ Sparse<T>::resize1 (octave_idx_type n)
     resize (1, std::max (nc, n));
   else if (nc == 0)
     resize (nr, (n + nr - 1) / nr); // Ain't it wicked?
   else if (nr == 1)
     resize (1, n);
   else if (nc == 1)
     resize (n, 1);
   else
-    gripe_invalid_resize ();
+    err_invalid_resize ();
 }
 
 template <class T>
 void
 Sparse<T>::resize (const dim_vector& dv)
 {
   octave_idx_type n = dv.length ();
 
@@ -1159,17 +1159,17 @@ Sparse<T>::delete_elements (const idx_ve
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
 
   octave_idx_type nel = numel (); // Can throw.
 
   const dim_vector idx_dims = idx.orig_dimensions ();
 
   if (idx.extent (nel) > nel)
-    gripe_del_index_out_of_range (true, idx.extent (nel), nel);
+    err_del_index_out_of_range (true, idx.extent (nel), nel);
   else if (nc == 1)
     {
       // Sparse column vector.
       const Sparse<T> tmp = *this; // constant copy to prevent COW.
 
       octave_idx_type lb, ub;
 
       if (idx.is_cont_range (nel, lb, ub))
@@ -1257,17 +1257,17 @@ Sparse<T>::delete_elements (const idx_ve
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
 
   if (idx_i.is_colon ())
     {
       // Deleting columns.
       octave_idx_type lb, ub;
       if (idx_j.extent (nc) > nc)
-        gripe_del_index_out_of_range (false, idx_j.extent (nc), nc);
+        err_del_index_out_of_range (false, idx_j.extent (nc), nc);
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           if (lb == 0 && ub == nc)
             {
               // Delete all rows and columns.
               *this = Sparse<T> (nr, 0);
             }
           else if (nz == 0)
@@ -1295,17 +1295,17 @@ Sparse<T>::delete_elements (const idx_ve
       else
         *this = index (idx_i, idx_j.complement (nc));
     }
   else if (idx_j.is_colon ())
     {
       // Deleting rows.
       octave_idx_type lb, ub;
       if (idx_i.extent (nr) > nr)
-        gripe_del_index_out_of_range (false, idx_i.extent (nr), nr);
+        err_del_index_out_of_range (false, idx_i.extent (nr), nr);
       else if (idx_i.is_cont_range (nr, lb, ub))
         {
           if (lb == 0 && ub == nr)
             {
               // Delete all rows and columns.
               *this = Sparse<T> (0, nc);
             }
           else if (nz == 0)
@@ -1426,17 +1426,17 @@ Sparse<T>::index (const idx_vector& idx,
       if (resize_ok)
         {
           octave_idx_type ext = idx.extent (nel);
           Sparse<T> tmp = *this;
           tmp.resize1 (ext);
           retval = tmp.index (idx);
         }
       else
-        gripe_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
+        err_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse
       // representation. Ok, we'll do it, but you deserve what
       // you get!!
@@ -1609,19 +1609,19 @@ Sparse<T>::index (const idx_vector& idx_
         {
           octave_idx_type ext_i = idx_i.extent (nr);
           octave_idx_type ext_j = idx_j.extent (nc);
           Sparse<T> tmp = *this;
           tmp.resize (ext_i, ext_j);
           retval = tmp.index (idx_i, idx_j);
         }
       else if (idx_i.extent (nr) > nr)
-        gripe_index_out_of_range (2, 1, idx_i.extent (nr), nr, dims ());
+        err_index_out_of_range (2, 1, idx_i.extent (nr), nr, dims ());
       else
-        gripe_index_out_of_range (2, 2, idx_j.extent (nc), nc, dims ());
+        err_index_out_of_range (2, 2, idx_j.extent (nc), nc, dims ());
     }
   else if (nr == 1 && nc == 1)
     {
       // Scalars stored as sparse matrices occupy more memory than
       // a scalar, so let's just convert the matrix to full, index,
       // and sparsify the result.
 
       retval = Sparse<T> (array_value ().index (idx_i, idx_j));
@@ -1973,17 +1973,17 @@ Sparse<T>::assign (const idx_vector& idx
     {
       rhl = idx.length (n);
       if (rhs.nnz () != 0)
         assign (idx, Sparse<T> (rhl, 1, rhs.data (0)));
       else
         assign (idx, Sparse<T> (rhl, 1));
     }
   else
-    gripe_nonconformant ("=", dim_vector(idx.length (n),1), rhs.dims());
+    err_nonconformant ("=", dim_vector(idx.length (n),1), rhs.dims());
 }
 
 template <class T>
 void
 Sparse<T>::assign (const idx_vector& idx_i,
                    const idx_vector& idx_j, const Sparse<T>& rhs)
 {
   Sparse<T> retval;
@@ -2213,17 +2213,17 @@ Sparse<T>::assign (const idx_vector& idx
       else
         assign (idx_i, idx_j, Sparse<T> (n, m));
     }
   else if (idx_i.length (nr) == m && idx_j.length (nc) == n && (n==1 || m==1))
     {
       assign (idx_i, idx_j, rhs.transpose ());
     }
   else
-    gripe_nonconformant  ("=", idx_i.length (nr), idx_j.length (nc), n, m);
+    err_nonconformant  ("=", idx_i.length (nr), idx_j.length (nc), n, m);
 }
 
 // Can't use versions of these in Array.cc due to duplication of the
 // instantiations for Array<double and Sparse<double>, etc
 template <class T>
 bool
 sparse_ascending_compare (typename ref_param<T>::type a,
                           typename ref_param<T>::type b)
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -200,17 +200,17 @@ operator * (const Matrix& m, const Colum
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
           if (nc == 0)
             retval.fill (0.0);
@@ -237,17 +237,17 @@ operator * (const DiagMatrix& m, const C
   ColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
         retval.resize (nr, 0.0);
       else
         {
           retval.resize (nr);
 
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -318,17 +318,17 @@ operator * (const DiagMatrix& a, const D
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   DiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1635,17 +1635,17 @@ Matrix::utsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1729,17 +1729,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1812,17 +1812,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -1865,17 +1865,17 @@ Matrix::fsolve (MatrixType &mattype, con
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1893,17 +1893,17 @@ Matrix::fsolve (MatrixType &mattype, con
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
@@ -2591,17 +2591,17 @@ Matrix::operator += (const DiagMatrix& a
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -2612,17 +2612,17 @@ Matrix::operator -= (const DiagMatrix& a
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3102,17 +3102,17 @@ xgemm (const Matrix& a, const Matrix& b,
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = Matrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -536,17 +536,17 @@ NDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, double> (*this, mx_inline_not);
 }
 
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
   return (neg_zero ? test_all (xnegative_sign)
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -195,17 +195,17 @@ operator * (const RowVector& v, const Ma
   RowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
         retval.resize (a_nc, 0.0);
       else
         {
           // Transpose A to form A'*x == (x'*A)'
 
@@ -318,17 +318,17 @@ operator * (const RowVector& v, const Co
 {
   double retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    gripe_nonconformant ("operator *", len, a_len);
+    err_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xddot, XDDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -757,17 +757,17 @@ atan2 (const SparseMatrix& x, const Spar
     {
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
-        gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
+        err_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
         {
           r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < x_nc ; i++)
             {
@@ -1875,32 +1875,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2158,32 +2158,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
@@ -2390,32 +2390,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2675,32 +2675,32 @@ SparseMatrix::utsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2929,32 +2929,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3230,32 +3230,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3485,32 +3485,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3788,32 +3788,32 @@ SparseMatrix::ltsolve (MatrixType &matty
           if (err != 0)
             {
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
 
           volatile double rcond_plus_one = rcond + 1.0;
 
           if (rcond_plus_one == 1.0 || xisnan (rcond))
             {
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix (rcond);
+                errwarn_singular_matrix (rcond);
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -3950,17 +3950,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4046,17 +4046,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
@@ -4248,17 +4248,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4342,17 +4342,17 @@ SparseMatrix::trisolve (MatrixType &matt
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
@@ -4532,17 +4532,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4617,17 +4617,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4650,17 +4650,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
@@ -4774,17 +4774,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -4892,17 +4892,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -4925,17 +4925,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5088,17 +5088,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5202,17 +5202,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5235,17 +5235,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5382,17 +5382,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
@@ -5526,17 +5526,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
@@ -5559,17 +5559,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                       err = -2;
 
                       if (sing_handler)
                         {
                           sing_handler (rcond);
                           mattype.mark_as_rectangular ();
                         }
                       else
-                        gripe_singular_matrix (rcond);
+                        errwarn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
@@ -5721,17 +5721,17 @@ SparseMatrix::factorize (octave_idx_type
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
-            gripe_singular_matrix (rcond);
+            errwarn_singular_matrix (rcond);
         }
       else if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseMatrix::solve numeric factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
@@ -5871,17 +5871,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6095,17 +6095,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6345,17 +6345,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -6587,17 +6587,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   err = -2;
 
                   if (sing_handler)
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
-                    gripe_singular_matrix (rcond);
+                    errwarn_singular_matrix (rcond);
 
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -7380,17 +7380,17 @@ SparseMatrix::too_large_for_float (void)
 {
   return test_any (xtoo_large_for_float);
 }
 
 SparseBoolMatrix
 SparseMatrix::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
 
   SparseBoolMatrix r (nr, nc, nz2);
 
@@ -7784,17 +7784,17 @@ min (const SparseMatrix& a, const Sparse
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
+        err_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SparseMatrix
 max (double d, const SparseMatrix& m)
 {
@@ -7934,17 +7934,17 @@ max (const SparseMatrix& a, const Sparse
     }
   else
     {
       if (a_nr == 0 || a_nc == 0)
         r.resize (a_nr, a_nc);
       else if (b_nr == 0 || b_nc == 0)
         r.resize (b_nr, b_nc);
       else
-        gripe_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
+        err_nonconformant ("max", a_nr, a_nc, b_nr, b_nc);
     }
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseMatrix, 0.0, , double, 0.0, )
 SPARSE_SMS_BOOL_OPS (SparseMatrix, double, 0.0)
 
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -283,17 +283,17 @@ FloatComplexColumnVector&
 FloatComplexColumnVector::operator += (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator +=", len, a_len);
+      err_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -305,17 +305,17 @@ FloatComplexColumnVector&
 FloatComplexColumnVector::operator -= (const FloatColumnVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator -=", len, a_len);
+      err_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -338,17 +338,17 @@ operator * (const FloatComplexMatrix& m,
   FloatComplexColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
           if (nc == 0)
             retval.fill (0.0);
@@ -383,17 +383,17 @@ operator * (const FloatDiagMatrix& m, co
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
@@ -411,17 +411,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
@@ -439,17 +439,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+      err_nonconformant ("operator *", nr, nc, a_len, 1);
       return FloatComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
 
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -421,17 +421,17 @@ FloatComplexDiagMatrix::operator += (con
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
+      err_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
   if (r == 0 || c == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -444,17 +444,17 @@ operator * (const FloatComplexDiagMatrix
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
@@ -470,17 +470,17 @@ operator * (const FloatDiagMatrix& a, co
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return FloatComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
@@ -503,17 +503,17 @@ operator * (const FloatComplexDiagMatrix
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+      err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return FloatComplexDiagMatrix ();
     }
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     return FloatComplexDiagMatrix (a_nr, a_nc, 0.0);
 
   FloatComplexDiagMatrix c (a_nr, b_nc);
 
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -2000,17 +2000,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2095,17 +2095,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -2180,17 +2180,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -2235,17 +2235,17 @@ FloatComplexMatrix::fsolve (MatrixType &
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -2263,17 +2263,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
@@ -3003,17 +3003,17 @@ FloatComplexMatrix::operator += (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -3024,17 +3024,17 @@ FloatComplexMatrix::operator -= (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3045,17 +3045,17 @@ FloatComplexMatrix::operator += (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -3066,17 +3066,17 @@ FloatComplexMatrix::operator -= (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = rows ();
   octave_idx_type a_nc = cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3089,17 +3089,17 @@ FloatComplexMatrix::operator += (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -3113,17 +3113,17 @@ FloatComplexMatrix::operator -= (const F
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -3714,17 +3714,17 @@ xgemm (const FloatComplexMatrix& a, cons
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -492,17 +492,17 @@ FloatComplexNDArray::ifourierNd (void) c
 #endif
 
 // unary operations
 
 boolNDArray
 FloatComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, FloatComplex> (*this, mx_inline_not);
 }
 
 // FIXME: this is not quite the right thing.
 
 bool
 FloatComplexNDArray::any_element_is_nan (void) const
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -273,17 +273,17 @@ FloatComplexRowVector&
 FloatComplexRowVector::operator += (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator +=", len, a_len);
+      err_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -295,17 +295,17 @@ FloatComplexRowVector&
 FloatComplexRowVector::operator -= (const FloatRowVector& a)
 {
   octave_idx_type len = numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     {
-      gripe_nonconformant ("operator -=", len, a_len);
+      err_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
   FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
@@ -321,17 +321,17 @@ operator * (const FloatComplexRowVector&
   FloatComplexRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
         retval.resize (a_nc, 0.0);
       else
         {
           // Transpose A to form A'*x == (x'*A)'
 
@@ -446,17 +446,17 @@ operator * (const FloatComplexRowVector&
 {
   FloatComplex retval (0.0, 0.0);
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    gripe_nonconformant ("operator *", len, a_len);
+    err_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xcdotu, XCDOTU) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 // other operations
 
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -199,17 +199,17 @@ operator * (const FloatMatrix& m, const 
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       retval.clear (nr);
 
       if (nr != 0)
         {
           if (nc == 0)
             retval.fill (0.0);
@@ -236,17 +236,17 @@ operator * (const FloatDiagMatrix& m, co
   FloatColumnVector retval;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   octave_idx_type a_len = a.numel ();
 
   if (nc != a_len)
-    gripe_nonconformant ("operator *", nr, nc, a_len, 1);
+    err_nonconformant ("operator *", nr, nc, a_len, 1);
   else
     {
       if (nr == 0 || nc == 0)
         retval.resize (nr, 0.0);
       else
         {
           retval.resize (nr);
 
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -318,17 +318,17 @@ operator * (const FloatDiagMatrix& a, co
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   FloatDiagMatrix c (a_nr, b_nc);
 
   octave_idx_type len = c.length ();
   octave_idx_type lenm = len < a_nc ? len : a_nc;
 
   for (octave_idx_type i = 0; i < lenm; i++)
     c.dgxelem (i) = a.dgelem (i) * b.dgelem (i);
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1647,17 +1647,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -1743,17 +1743,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -1827,17 +1827,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -1880,17 +1880,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
-                gripe_singular_matrix ();
+                errwarn_singular_matrix ();
 
               mattype.mark_as_rectangular ();
             }
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
@@ -1908,17 +1908,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
                       if (sing_handler)
                         sing_handler (rcon);
                       else
-                        gripe_singular_matrix (rcon);
+                        errwarn_singular_matrix (rcon);
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
@@ -2616,17 +2616,17 @@ FloatMatrix::operator += (const FloatDia
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) += a.elem (i, i);
 
   return *this;
 }
@@ -2637,17 +2637,17 @@ FloatMatrix::operator -= (const FloatDia
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nr || nc != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
@@ -3107,17 +3107,17 @@ xgemm (const FloatMatrix& a, const Float
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
 
   octave_idx_type b_nr = trb ? b.cols () : b.rows ();
   octave_idx_type b_nc = trb ? b.rows () : b.cols ();
 
   if (a_nc != b_nr)
-    gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
+    err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = FloatMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -496,17 +496,17 @@ FloatNDArray::ifourierNd (void) const
 #endif
 
 // unary operations
 
 boolNDArray
 FloatNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
-    gripe_nan_to_logical_conversion ();
+    err_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, float> (*this, mx_inline_not);
 }
 
 bool
 FloatNDArray::any_element_is_negative (bool neg_zero) const
 {
   return (neg_zero ? test_all (xnegative_sign)
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -195,17 +195,17 @@ operator * (const FloatRowVector& v, con
   FloatRowVector retval;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != len)
-    gripe_nonconformant ("operator *", 1, len, a_nr, a_nc);
+    err_nonconformant ("operator *", 1, len, a_nr, a_nc);
   else
     {
       if (len == 0)
         retval.resize (a_nc, 0.0);
       else
         {
           // Transpose A to form A'*x == (x'*A)'
 
@@ -318,17 +318,17 @@ operator * (const FloatRowVector& v, con
 {
   float retval = 0.0;
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
-    gripe_nonconformant ("operator *", len, a_len);
+    err_nonconformant ("operator *", len, a_len);
   else if (len != 0)
     F77_FUNC (xsdot, XSDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
 }
 
 FloatComplex
 operator * (const FloatRowVector& v, const FloatComplexColumnVector& a)
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 static void
 gripe_invalid_range (void)
 {
   (*current_liboctave_error_handler)
     ("invalid range used as index");
 }
 
 static void
-gripe_index_out_of_range (void)
+err_index_out_of_range (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_vector index out of range");
 }
 
 Array<octave_idx_type>
 idx_vector::idx_base_rep::as_array (void)
 {
@@ -74,17 +74,17 @@ idx_vector::idx_colon_rep::idx_colon_rep
     }
 }
 
 octave_idx_type
 idx_vector::idx_colon_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0)
     {
-      gripe_index_out_of_range ();
+      err_index_out_of_range ();
       return 0;
     }
   else
     return i;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_colon_rep::sort_idx (Array<octave_idx_type>&)
@@ -110,22 +110,22 @@ idx_vector::idx_range_rep::idx_range_rep
 {
   if (len < 0)
     {
       gripe_invalid_range ();
       err = true;
     }
   else if (start < 0)
     {
-      gripe_invalid_index (start);
+      err_invalid_index (start);
       err = true;
     }
   else if (step < 0 && start + (len-1)*step < 0)
     {
-      gripe_invalid_index (start + (len-1)*step);
+      err_invalid_index (start + (len-1)*step);
       err = true;
     }
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
   : start (0), len (r.numel ()), step (1)
 {
   if (len < 0)
@@ -136,42 +136,42 @@ idx_vector::idx_range_rep::idx_range_rep
   else if (len > 0)
     {
       if (r.all_elements_are_ints ())
         {
           start = static_cast<octave_idx_type> (r.base ()) - 1;
           step = static_cast<octave_idx_type> (r.inc ());
           if (start < 0)
             {
-              gripe_invalid_index (start);
+              err_invalid_index (start);
               err = true;
             }
           else if (step < 0 && start + (len - 1)*step < 0)
             {
-              gripe_invalid_index (start + (len - 1)*step);
+              err_invalid_index (start + (len - 1)*step);
               err = true;
             }
         }
       else
         {
           // find first non-integer, then gripe about it
           double b = r.base ();
           double inc = r.inc ();
-          gripe_invalid_index (b != gnulib::floor (b) ? b : b + inc);
+          err_invalid_index (b != gnulib::floor (b) ? b : b + inc);
           err = true;
         }
     }
 }
 
 octave_idx_type
 idx_vector::idx_range_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= len)
     {
-      gripe_index_out_of_range ();
+      err_index_out_of_range ();
       return 0;
     }
   else
     return start + i*step;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_range_rep::sort_uniq_clone (bool)
@@ -231,34 +231,34 @@ idx_vector::idx_range_rep::as_array (voi
 
 inline octave_idx_type
 convert_index (octave_idx_type i, bool& conv_error,
                octave_idx_type& ext)
 {
   if (i <= 0)
     {
       if (! conv_error)          // only gripe once, for things like A(-10000:0)
-        gripe_invalid_index (i-1);
+        err_invalid_index (i-1);
       conv_error = true;
     }
 
   if (ext < i)
     ext = i;
 
   return i - 1;
 }
 
 inline octave_idx_type
 convert_index (double x, bool& conv_error, octave_idx_type& ext)
 {
   octave_idx_type i = static_cast<octave_idx_type> (x);
 
   if (static_cast<double> (i) != x)
     {
-      gripe_invalid_index (x-1);
+      err_invalid_index (x-1);
       conv_error = true;
     }
 
   return convert_index (i, conv_error, ext);
 }
 
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
@@ -286,26 +286,26 @@ idx_vector::idx_scalar_rep::idx_scalar_r
   data = convert_index (x, err, dummy);
 }
 
 idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i)
   : data (i)
 {
   if (data < 0)
     {
-      gripe_invalid_index (data);
+      err_invalid_index (data);
       err = true;
     }
 }
 
 octave_idx_type
 idx_vector::idx_scalar_rep::checkelem (octave_idx_type i) const
 {
   if (i != 0)
-    gripe_index_out_of_range ();
+    err_index_out_of_range ();
 
   return data;
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_scalar_rep::sort_idx (Array<octave_idx_type>& idx)
 {
   idx.clear (1, 1);
@@ -358,17 +358,17 @@ idx_vector::idx_vector_rep::idx_vector_r
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_idx_type k = inda.xelem (i);
           if (k < 0)
             {
               if (! err)         // only report first error, in case 1000s.
-                gripe_invalid_index (k);
+                err_invalid_index (k);
               err = true;
             }
           else if (k > max)
             max = k;
         }
 
       ext = max + 1;
     }
@@ -469,17 +469,17 @@ idx_vector::idx_vector_rep::~idx_vector_
     delete [] data;
 }
 
 octave_idx_type
 idx_vector::idx_vector_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
     {
-      gripe_invalid_index (n);
+      err_invalid_index (n);
       return 0;
     }
 
   return xelem (n);
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_vector_rep::sort_uniq_clone (bool uniq)
@@ -719,17 +719,17 @@ idx_vector::idx_mask_rep::xelem (octave_
   return lste;
 }
 
 octave_idx_type
 idx_vector::idx_mask_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
     {
-      gripe_invalid_index (n);
+      err_invalid_index (n);
       return 0;
     }
 
   return xelem (n);
 }
 
 std::ostream&
 idx_vector::idx_mask_rep::print (std::ostream& os) const
diff --git a/liboctave/numeric/CmplxGEPBAL.cc b/liboctave/numeric/CmplxGEPBAL.cc
--- a/liboctave/numeric/CmplxGEPBAL.cc
+++ b/liboctave/numeric/CmplxGEPBAL.cc
@@ -68,17 +68,17 @@ ComplexGEPBALANCE::init (const ComplexMa
     {
       (*current_liboctave_error_handler)
         ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
-      gripe_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
+      err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
diff --git a/liboctave/numeric/dbleGEPBAL.cc b/liboctave/numeric/dbleGEPBAL.cc
--- a/liboctave/numeric/dbleGEPBAL.cc
+++ b/liboctave/numeric/dbleGEPBAL.cc
@@ -67,17 +67,17 @@ GEPBALANCE::init (const Matrix& a, const
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
-      gripe_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
+      err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
diff --git a/liboctave/numeric/fCmplxGEPBAL.cc b/liboctave/numeric/fCmplxGEPBAL.cc
--- a/liboctave/numeric/fCmplxGEPBAL.cc
+++ b/liboctave/numeric/fCmplxGEPBAL.cc
@@ -68,17 +68,17 @@ FloatComplexGEPBALANCE::init (const Floa
     {
       (*current_liboctave_error_handler)
         ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
-      gripe_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
+      err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
diff --git a/liboctave/numeric/floatGEPBAL.cc b/liboctave/numeric/floatGEPBAL.cc
--- a/liboctave/numeric/floatGEPBAL.cc
+++ b/liboctave/numeric/floatGEPBAL.cc
@@ -68,17 +68,17 @@ FloatGEPBALANCE::init (const FloatMatrix
     {
       (*current_liboctave_error_handler)
         ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
-      gripe_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
+      err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -31,17 +31,17 @@ RT do_mul_dm_sm (const DM& d, const SM& 
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
     {
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
+      err_nonconformant ("operator *", nr, nc, a_nr, a_nc);
       return RT ();
     }
   else
     {
       RT r (nr, a_nc, a.nnz ());
 
       octave_idx_type l = 0;
 
@@ -72,17 +72,17 @@ RT do_mul_sm_dm (const SM& a, const DM& 
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
   const octave_idx_type a_nr = a.rows ();
   const octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nc)
     {
-      gripe_nonconformant ("operator *", a_nr, a_nc, nr, nc);
+      err_nonconformant ("operator *", a_nr, a_nc, nr, nc);
       return RT ();
     }
   else
     {
 
       const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
       RT r (a_nr, nc, a.cidx (mnc));
 
@@ -182,54 +182,54 @@ RT do_commutative_add_dm_sm (const DM& d
                                  identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_add_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
-      gripe_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
+      err_nonconformant ("operator +", d.rows (), d.cols (), a.rows (), a.cols ());
       return RT ();
     }
   else
     return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename DM, typename SM>
 RT do_sub_dm_sm (const DM& d, const SM& a)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
-      gripe_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
+      err_nonconformant ("operator -", d.rows (), d.cols (), a.rows (), a.cols ());
       return RT ();
     }
   else
     return inner_do_add_sm_dm<RT> (a, d, std::negate<typename SM::element_type> (),
                                    identity_val<typename DM::element_type> ());
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_add_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
-      gripe_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
+      err_nonconformant ("operator +", a.rows (), a.cols (), d.rows (), d.cols ());
       return RT ();
     }
   else
     return do_commutative_add_dm_sm<RT> (d, a);
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_sub_sm_dm (const SM& a, const DM& d)
 {
   if (a.rows () != d.rows () || a.cols () != d.cols ())
     {
-      gripe_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
+      err_nonconformant ("operator -", a.rows (), a.cols (), d.rows (), d.cols ());
       return RT ();
     }
   else
     return inner_do_add_sm_dm<RT> (a, d,
                                    identity_val<typename SM::element_type> (),
                                    std::negate<typename DM::element_type> ());
 }
 
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -364,17 +364,17 @@ along with Octave; see the file COPYING.
                     octave_quit (); \
                     r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.data (0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
@@ -472,17 +472,17 @@ along with Octave; see the file COPYING.
               { \
                 octave_quit (); \
                 r.data (i) = r.data (i) OP m2.data (0); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
@@ -588,17 +588,17 @@ along with Octave; see the file COPYING.
                     octave_quit (); \
                     r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.elem (0,0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
         /* FIXME: Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
@@ -811,17 +811,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.maybe_compress (false); \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMSM_CMP_OP (mx_el_lt, <,  M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_le, <=, M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ge, >=, M1, Z1,   , M2, Z2,   ) \
@@ -959,17 +959,17 @@ along with Octave; see the file COPYING.
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -988,17 +988,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
       r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (F (m1, m2.matrix_value ())); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BIN_OP_2(R, F, OP, M1, M2) \
@@ -1011,17 +1011,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
       r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (do_mx_check (m1, mx_inline_all_finite<M1::element_type>)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m2_nz = m2.nnz (); \
             r = R (m2_nr, m2_nc, m2_nz); \
             for (octave_idx_type j = 0, k = 0; j < m2_nc; j++) \
@@ -1099,17 +1099,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_MSM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
   SPARSE_MSM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
@@ -1165,17 +1165,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_MSM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_MSM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -1194,17 +1194,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1.matrix_value () OP m2); \
       } \
     return r; \
   }
 
 // sm .* m preserves sparsity if m contains no Infs nor Nans.
@@ -1225,17 +1225,17 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
-      gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+      err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (SPARSE_SMM_BIN_OP_2_CHECK_ ## F(M2::element_type)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m1_nz = m1.nnz (); \
             r = R (m1_nr, m1_nc, m1_nz); \
             for (octave_idx_type j = 0, k = 0; j < m1_nc; j++) \
@@ -1312,17 +1312,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_CMP_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMM_CMP_OP (mx_el_lt, <,  M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_le, <=, M1,   , M2,   ) \
   SPARSE_SMM_CMP_OP (mx_el_ge, >=, M1,   , M2,   ) \
@@ -1378,17 +1378,17 @@ along with Octave; see the file COPYING.
                   } \
                 r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
-          gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
+          err_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
     return r; \
   }
 
 #define SPARSE_SMM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   SPARSE_SMM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
@@ -1737,17 +1737,17 @@ along with Octave; see the file COPYING.
          r.cidx (i) = m.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (nc != a_nr) \
     { \
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
+      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
       for (octave_idx_type i = 0; i < nr; i++) \
         w[i] = 0; \
@@ -1869,17 +1869,17 @@ along with Octave; see the file COPYING.
   \
   if (nr == 1 && nc == 1) \
     { \
       RET_TYPE retval = m.elem (0,0) * a; \
       return retval; \
     } \
   else if (nc != a_nr) \
     { \
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
+      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
@@ -1904,17 +1904,17 @@ along with Octave; see the file COPYING.
   \
   if (nr == 1 && nc == 1) \
     { \
       RET_TYPE retval = CONJ_OP (m.elem (0,0)) * a; \
       return retval; \
     } \
   else if (nr != a_nr) \
     { \
-      gripe_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
+      err_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nc, a_nc); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
@@ -1940,17 +1940,17 @@ along with Octave; see the file COPYING.
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
       RET_TYPE retval = m * a.elem (0,0); \
       return retval; \
     } \
   else if (nc != a_nr) \
     { \
-      gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
+      err_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
@@ -1976,17 +1976,17 @@ along with Octave; see the file COPYING.
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
       RET_TYPE retval = m * CONJ_OP (a.elem (0,0)); \
       return retval; \
     } \
   else if (nc != a_nc) \
     { \
-      gripe_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
+      err_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nr, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
diff --git a/liboctave/operators/Sparse-perm-op-defs.h b/liboctave/operators/Sparse-perm-op-defs.h
--- a/liboctave/operators/Sparse-perm-op-defs.h
+++ b/liboctave/operators/Sparse-perm-op-defs.h
@@ -58,17 +58,17 @@ SM octinternal_do_mul_colpm_sm (const oc
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
   const octave_idx_type nr = a.rows ();
   if (p.cols () != nr)
     {
-      gripe_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
+      err_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
       return SM ();
     }
 
   return octinternal_do_mul_colpm_sm (p.col_perm_vec ().data (), a);
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_rowpm (const SM& a, const octave_idx_type *prow)
@@ -144,16 +144,16 @@ SM octinternal_do_mul_sm_colpm (const SM
 }
 
 template <typename SM>
 SM octinternal_do_mul_sm_pm (const SM& a, const PermMatrix& p)
 {
   const octave_idx_type nc = a.cols ();
   if (p.rows () != nc)
     {
-      gripe_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
+      err_nonconformant ("operator *", a.rows (), a.cols (), p.rows (), p.cols ());
       return SM ();
     }
 
   return octinternal_do_mul_sm_colpm (a, p.col_perm_vec ().data ());
 }
 
 #endif
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -375,17 +375,17 @@ do_mm_binary_op (const Array<X>& x, cons
       return r;
     }
   else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
     {
-      gripe_nonconformant (opname, dx, dy);
+      err_nonconformant (opname, dx, dy);
       return Array<R> ();
     }
 }
 
 template <class R, class X, class Y>
 inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
@@ -418,17 +418,17 @@ do_mm_inplace_op (Array<R>& r, const Arr
     {
       op (r.numel (), r.fortran_vec (), x.data ());
     }
   else if (is_valid_inplace_bsxfun (opname, dr, dx))
     {
       do_inplace_bsxfun_op (r, x, op, op1);
     }
   else
-    gripe_nonconformant (opname, dr, dx);
+    err_nonconformant (opname, dr, dx);
   return r;
 }
 
 template <class R, class X>
 inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
 {
diff --git a/liboctave/operators/mx-op-defs.h b/liboctave/operators/mx-op-defs.h
--- a/liboctave/operators/mx-op-defs.h
+++ b/liboctave/operators/mx-op-defs.h
@@ -20,27 +20,27 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_mx_op_defs_h)
 #define octave_mx_op_defs_h 1
 
-#include "lo-array-gripes.h"
+#include "lo-array-errwarn.h"
 #include "mx-op-decl.h"
 #include "mx-inlines.cc"
 
 #define SNANCHK(s) \
   if (xisnan (s)) \
-    gripe_nan_to_logical_conversion ()
+    err_nan_to_logical_conversion ()
 
 #define MNANCHK(m, MT) \
   if (do_mx_check (m, mx_inline_any_nan<MT>)) \
-    gripe_nan_to_logical_conversion ()
+    err_nan_to_logical_conversion ()
 
 // vector by scalar operations.
 
 #define VS_BIN_OP(R, F, OP, V, S) \
   R \
   F (const V& v, const S& s) \
   { \
     return do_ms_binary_op<R::element_type, V::element_type, S> (v, s, OP); \
@@ -397,17 +397,17 @@ OP (const M& m, const DM& dm) \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   if (m_nr != dm_nr || m_nc != dm_nc) \
-    gripe_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc); \
+    err_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc); \
   else \
     { \
       r.resize (m_nr, m_nc); \
  \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (m); \
  \
@@ -429,17 +429,17 @@ operator * (const M& m, const DM& dm) \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   if (m_nc != dm_nr) \
-    gripe_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc); \
+    err_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc); \
   else \
     { \
       r = R (m_nr, dm_nc); \
       R::element_type *rd = r.fortran_vec (); \
       const M::element_type *md = m.data (); \
       const DM::element_type *dd = dm.data (); \
  \
       octave_idx_type len = dm.length (); \
@@ -469,17 +469,17 @@ OP (const DM& dm, const M& m) \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   if (dm_nr != m_nr || dm_nc != m_nc) \
-    gripe_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc); \
+    err_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc); \
   else \
     { \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (PREOP m); \
  \
           octave_idx_type len = dm.length (); \
  \
@@ -501,17 +501,17 @@ operator * (const DM& dm, const M& m) \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
  \
   if (dm_nc != m_nr) \
-    gripe_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc); \
+    err_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc); \
   else \
     { \
       r = R (dm_nr, m_nc); \
       R::element_type *rd = r.fortran_vec (); \
       const M::element_type *md = m.data (); \
       const DM::element_type *dd = dm.data (); \
  \
       octave_idx_type len = dm.length (); \
@@ -542,17 +542,17 @@ operator * (const DM& dm, const M& m) \
  \
     octave_idx_type dm1_nr = dm1.rows (); \
     octave_idx_type dm1_nc = dm1.cols (); \
  \
     octave_idx_type dm2_nr = dm2.rows (); \
     octave_idx_type dm2_nc = dm2.cols (); \
  \
     if (dm1_nr != dm2_nr || dm1_nc != dm2_nc) \
-      gripe_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc); \
+      err_nonconformant (#OP, dm1_nr, dm1_nc, dm2_nr, dm2_nc); \
     else \
       { \
         r.resize (dm1_nr, dm1_nc); \
  \
         if (dm1_nr > 0 && dm1_nc > 0) \
           F (dm1.length (), r.fortran_vec (), dm1.data (), dm2.data ()); \
       } \
  \
@@ -599,34 +599,34 @@ FCN (const T& a, const T& b) \
 
 #define PMM_MULTIPLY_OP(PM, M) \
 M operator * (const PM& p, const M& x) \
 { \
   octave_idx_type nr = x.rows (); \
   octave_idx_type nc = x.columns (); \
   M result; \
   if (p.columns () != nr) \
-    gripe_nonconformant ("operator *", p.rows (), p.columns (), nr, nc); \
+    err_nonconformant ("operator *", p.rows (), p.columns (), nr, nc); \
   else \
     { \
       result = M (nr, nc); \
       result.assign (p.col_perm_vec (), idx_vector::colon, x); \
     } \
   \
   return result; \
 }
 
 #define MPM_MULTIPLY_OP(M, PM) \
 M operator * (const M& x, const PM& p) \
 { \
   octave_idx_type nr = x.rows (); \
   octave_idx_type nc = x.columns (); \
   M result; \
   if (p.rows () != nc) \
-    gripe_nonconformant ("operator *", nr, nc, p.rows (), p.columns ()); \
+    err_nonconformant ("operator *", nr, nc, p.rows (), p.columns ()); \
   else \
     result = x.index (idx_vector::colon, p.col_perm_vec ()); \
   \
   return result; \
 }
 
 #define PMM_BIN_OPS(R, PM, M) \
   PMM_MULTIPLY_OP(PM, M);
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -0,0 +1,327 @@
+/*
+
+Copyright (C) 2016 Rik Wehbring
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sstream>
+
+#include "lo-array-errwarn.h"
+#include "lo-error.h"
+
+const char *error_id_nonconformant_args = "Octave:nonconformant-args";
+
+const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
+
+const char *error_id_invalid_index = "Octave:invalid-index";
+
+const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
+
+const char *warning_id_singular_matrix = "Octave:singular-matrix";
+
+void
+err_nan_to_logical_conversion (void)
+{
+  (*current_liboctave_error_handler)
+    ("invalid conversion from NaN to logical");
+}
+
+void
+err_nan_to_character_conversion (void)
+{
+  (*current_liboctave_error_handler)
+    ("invalid conversion from NaN to character");
+}
+
+void
+err_nonconformant (const char *op,
+                   octave_idx_type op1_len, octave_idx_type op2_len)
+{
+  const char *err_id = error_id_nonconformant_args;
+
+  (*current_liboctave_error_with_id_handler)
+    (err_id, "%s: nonconformant arguments (op1 len: %d, op2 len: %d)",
+     op, op1_len, op2_len);
+}
+
+void
+err_nonconformant (const char *op,
+                   octave_idx_type op1_nr, octave_idx_type op1_nc,
+                   octave_idx_type op2_nr, octave_idx_type op2_nc)
+{
+  const char *err_id = error_id_nonconformant_args;
+
+  (*current_liboctave_error_with_id_handler)
+    (err_id, "%s: nonconformant arguments (op1 is %dx%d, op2 is %dx%d)",
+     op, op1_nr, op1_nc, op2_nr, op2_nc);
+}
+
+void
+err_nonconformant (const char *op,
+                   const dim_vector& op1_dims, const dim_vector& op2_dims)
+{
+  const char *err_id = error_id_nonconformant_args;
+
+  std::string op1_dims_str = op1_dims.str ();
+  std::string op2_dims_str = op2_dims.str ();
+
+  (*current_liboctave_error_with_id_handler)
+    (err_id, "%s: nonconformant arguments (op1 is %s, op2 is %s)",
+     op, op1_dims_str.c_str (), op2_dims_str.c_str ());
+}
+
+void
+err_del_index_out_of_range (bool is1d, octave_idx_type idx,
+                            octave_idx_type ext)
+{
+  const char *err_id = error_id_index_out_of_bounds;
+
+  (*current_liboctave_error_with_id_handler)
+    (err_id, "A(%s) = []: index out of bounds: value %d out of bound %d",
+     is1d ? "I" : "..,I,..", idx, ext);
+}
+
+// Common procedures of base class index_exception, thrown whenever an
+// object is indexed incorrectly, such as by an index that is out of
+// range, negative, fractional, complex, or of a non-numeric type.
+
+std::string
+index_exception::message (void) const
+{
+  std::string msg = expression () + ": " + details ();
+  return msg.c_str ();
+}
+
+// Show the expression that caused the error, e.g.,  "A(-1,_)",
+// "A(0+1i)", "A(_,3)".  Show how many indices come before/after the
+// offending one, e.g., (<error>), (<error>,_), or (_,<error>,...[x5]...)
+
+std::string
+index_exception::expression (void) const
+{
+  std::ostringstream buf;
+
+  if (var.empty () || var == "<unknown>")
+    buf << "index ";
+  else
+    buf << var;
+
+  bool show_parens = dim > 0;
+
+  if (show_parens)
+    {
+      if (dim < 5)
+        {
+          buf << "(";
+
+          for (octave_idx_type i = 1; i < dim; i++)
+            buf << "_,";
+        }
+      else
+        buf << "(...[x" << dim - 1 << "]...";
+    }
+
+  buf << idx ();
+
+  if (show_parens)
+    {
+      if (nd - dim < 5)
+        {
+          for (octave_idx_type i = 0; i < nd - dim; i++)
+            buf << ",_";
+
+          if (nd >= dim)
+            buf << ")";
+        }
+      else
+        buf << "...[x" << nd - dim << "]...)";
+    }
+
+  return buf.str ();
+}
+
+class invalid_index : public index_exception
+{
+public:
+
+  invalid_index (const std::string& value, octave_idx_type ndim,
+                 octave_idx_type dimen)
+    : index_exception (value, ndim, dimen)
+  { }
+
+  std::string details (void) const
+  {
+#ifdef USE_64_BIT_IDX_T
+    return "subscripts must be either integers 1 to (2^63)-1 or logicals";
+#else
+    return "subscripts must be either integers 1 to (2^31)-1 or logicals";
+#endif
+  }
+
+  // ID of error to throw
+  const char *err_id (void) const
+  {
+    return error_id_invalid_index;
+  }
+};
+
+// Complain if an index is negative, fractional, or too big.
+
+void
+err_invalid_index (const std::string& idx, octave_idx_type nd,
+                   octave_idx_type dim, const std::string&)
+{
+  invalid_index e (idx, nd, dim);
+
+  throw e;
+}
+
+void
+err_invalid_index (octave_idx_type n, octave_idx_type nd,
+                   octave_idx_type dim, const std::string& var)
+{
+  std::ostringstream buf;
+  buf << n + 1;
+  err_invalid_index (buf.str (), nd, dim, var);
+}
+
+void
+err_invalid_index (double n, octave_idx_type nd, octave_idx_type dim,
+                   const std::string& var)
+{
+  std::ostringstream buf;
+  buf << n + 1;
+  err_invalid_index (buf.str (), nd, dim, var);
+}
+
+
+// Complain for read access beyond the bounds of an array.
+
+class out_of_range : public index_exception
+{
+public:
+
+  out_of_range (const std::string& value, octave_idx_type nd_in,
+                octave_idx_type dim_in)
+    : index_exception (value, nd_in, dim_in), extent (0)
+  { }
+
+  std::string details (void) const
+  {
+    std::string expl;
+
+    if (nd >= size.length ())   // if not an index slice
+      {
+        if (var != "")
+          expl = "but " + var + " has size ";
+        else
+          expl = "but object has size ";
+
+        expl = expl + size.str ('x');
+      }
+    else
+      {
+        std::ostringstream buf;
+        buf << extent;
+        expl = "out of bound " + buf.str ();
+      }
+
+    return expl;
+  }
+
+  // ID of error to throw.
+  const char *err_id (void) const
+  {
+    return error_id_index_out_of_bounds;
+  }
+
+  void set_size (const dim_vector& size_in) { size = size_in; }
+
+  void set_extent (octave_idx_type ext) { extent = ext; }
+
+private:
+
+  // Dimension of object being accessed.
+  dim_vector size;
+
+  // Length of dimension being accessed.
+  octave_idx_type extent;
+};
+
+// Complain of an index that is out of range, but we don't know matrix size
+void
+err_index_out_of_range (int nd, int dim, octave_idx_type idx,
+                        octave_idx_type ext)
+{
+  std::ostringstream buf;
+  buf << idx;
+  out_of_range e (buf.str (), nd, dim);
+
+  e.set_extent (ext);
+  // ??? Make details method give extent not size.
+  e.set_size (dim_vector (1, 1, 1, 1, 1, 1,1));
+
+  throw e;
+}
+
+// Complain of an index that is out of range
+void
+err_index_out_of_range (int nd, int dim, octave_idx_type idx,
+                        octave_idx_type ext, const dim_vector& d)
+{
+  std::ostringstream buf;
+  buf << idx;
+  out_of_range e (buf.str (), nd, dim);
+
+  e.set_extent (ext);
+  e.set_size (d);
+
+  throw e;
+}
+
+void
+err_invalid_resize (void)
+{
+  (*current_liboctave_error_with_id_handler)
+    ("Octave:invalid-resize",
+     "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element");
+}
+
+void
+errwarn_singular_matrix (double rcond)
+{
+  if (rcond == 0.0)
+    {
+      (*current_liboctave_warning_with_id_handler)
+        (warning_id_singular_matrix,
+         "matrix singular to machine precision");
+    }
+  else
+    {
+      (*current_liboctave_warning_with_id_handler)
+        (warning_id_nearly_singular_matrix,
+         "matrix singular to machine precision, rcond = %g", rcond);
+    }
+}
+
+/* Tests in test/index.tst */
diff --git a/liboctave/util/lo-array-errwarn.h b/liboctave/util/lo-array-errwarn.h
new file mode 100644
--- /dev/null
+++ b/liboctave/util/lo-array-errwarn.h
@@ -0,0 +1,167 @@
+/*
+
+Copyright (C) 2016 Rik Wehbring
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_lo_array_errwarn_h)
+#define octave_lo_array_errwarn_h 1
+
+#include "dim-vector.h"
+#include "quit.h"
+
+// Exception thrown by err_invalid_index
+// This is thrown when the invalid index is detected, at which point nd and dim
+// are usually not known.  It is caught at the place they are known, where a
+// new  err_invalid_index  is called.
+//
+// Typically, this should be caught after any call to
+// octave_value_list::index_vector()
+class index_exception : public octave_execution_exception
+{
+public:
+
+  index_exception (const std::string& index_arg, octave_idx_type nd_arg = 0,
+                   octave_idx_type dim_arg = -1, const char *var_arg = "")
+    : index (index_arg), nd (nd_arg), dim (dim_arg), var (var_arg)
+  { }
+
+  ~index_exception (void) { }
+
+  // Erroneous index value.  Called in what, and by external code
+  // (e.g., nth_element) to make a custom error message.
+  std::string idx (void) const { return index; }
+
+  // details set by subclass.
+  virtual std::string details (void) const = 0;
+
+  // ID of error to throw.
+  virtual const char *err_id (void) const = 0;
+
+  virtual std::string message (void) const;
+
+  // Position of error: dimension in error, and number of dimensions.
+  void set_pos (octave_idx_type nd_arg, octave_idx_type dim_arg)
+  {
+    nd = nd_arg;
+    dim = dim_arg;
+  }
+
+  void set_pos_if_unset (octave_idx_type nd_arg, octave_idx_type dim_arg)
+  {
+    if (nd == 0)
+      {
+        nd  = nd_arg;
+        dim = dim_arg;
+      }
+  }
+
+  // Name of variable being indexed.  eye(2)(1,1) gives "<unknown>".
+  void set_var (const std::string& var_arg = "")
+  {
+    var = var_arg;
+  }
+
+private:
+
+  // Value of invalid index.
+  std::string index;
+
+protected:
+
+  // Show what's wrong, e.g.,  A(-1,_), A(0+1i).
+  std::string expression (void) const;
+
+  // Number of dimensions of indexed object.
+  octave_idx_type nd;
+
+  // Dimension number in which invalid index occurred.
+  octave_idx_type dim;
+
+  // Name of variable being indexed.
+  std::string var;
+
+};
+
+extern OCTAVE_API const char *error_id_nonconformant_args;
+
+extern OCTAVE_API const char *error_id_index_out_of_bounds;
+
+extern OCTAVE_API const char *error_id_invalid_index;
+
+extern OCTAVE_API const char *warning_id_nearly_singular_matrix;
+
+extern OCTAVE_API const char *warning_id_singular_matrix;
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_nan_to_logical_conversion (void);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_nan_to_character_conversion (void);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_nonconformant (const char *op,
+                        octave_idx_type op1_len,
+                        octave_idx_type op2_len);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_nonconformant (const char *op,
+                        octave_idx_type op1_nr, octave_idx_type op1_nc,
+                        octave_idx_type op2_nr, octave_idx_type op2_nc);
+
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_nonconformant (const char *op, const dim_vector& op1_dims,
+                        const dim_vector& op2_dims);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_index_out_of_range (int nd, int dim,
+                             octave_idx_type iext, octave_idx_type ext,
+                             const dim_vector& d);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_index_out_of_range (int nd, int dim,
+                             octave_idx_type iext, octave_idx_type ext);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_del_index_out_of_range (bool is1d, octave_idx_type iext,
+                                 octave_idx_type ext);
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_invalid_index (double, octave_idx_type nd = 0,
+                        octave_idx_type dim = 0,
+                        const std::string& var = "");
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_invalid_index (octave_idx_type n, octave_idx_type nd = 0,
+                        octave_idx_type dim = 0,
+                        const std::string& var = "");
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_invalid_index (const std::string& idx, octave_idx_type nd = 0,
+                        octave_idx_type dim = 0,
+                        const std::string& var = "");
+
+OCTAVE_NORETURN OCTAVE_API extern
+void err_invalid_resize (void);
+
+OCTAVE_API extern
+void errwarn_singular_matrix (double rcond = 0.0);
+
+#endif
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -25,26 +25,16 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <sstream>
 
 #include "lo-array-gripes.h"
 #include "lo-error.h"
 
-const char *error_id_nonconformant_args = "Octave:nonconformant-args";
-
-const char *error_id_index_out_of_bounds = "Octave:index-out-of-bounds";
-
-const char *error_id_invalid_index = "Octave:invalid-index";
-
-const char *warning_id_nearly_singular_matrix = "Octave:nearly-singular-matrix";
-
-const char *warning_id_singular_matrix = "Octave:singular-matrix";
-
 void
 gripe_nan_to_logical_conversion (void)
 {
   (*current_liboctave_error_handler)
     ("invalid conversion from NaN to logical");
 }
 
 void
@@ -97,77 +87,16 @@ gripe_del_index_out_of_range (bool is1d,
 {
   const char *err_id = error_id_index_out_of_bounds;
 
   (*current_liboctave_error_with_id_handler)
     (err_id, "A(%s) = []: index out of bounds: value %d out of bound %d",
      is1d ? "I" : "..,I,..", idx, ext);
 }
 
-
-
-// Common procedures of base class index_exception, thrown whenever an
-// object is indexed incorrectly, such as by an index that is out of
-// range, negative, fractional, complex, or of a non-numeric type.
-
-std::string
-index_exception::message (void) const
-{
-  std::string msg = expression () + ": " + details ();
-  return msg.c_str ();
-}
-
-// Show the expression that caused the error, e.g.,  "A(-1,_)",
-// "A(0+1i)", "A(_,3)".  Show how many indices come before/after the
-// offending one, e.g., (<error>), (<error>,_), or (_,<error>,...[x5]...)
-
-std::string
-index_exception::expression (void) const
-{
-  std::ostringstream buf;
-
-  if (var.empty () || var == "<unknown>")
-    buf << "index ";
-  else
-    buf << var;
-
-  bool show_parens = dim > 0;
-
-  if (show_parens)
-    {
-      if (dim < 5)
-        {
-          buf << "(";
-
-          for (octave_idx_type i = 1; i < dim; i++)
-            buf << "_,";
-        }
-      else
-        buf << "(...[x" << dim - 1 << "]...";
-    }
-
-  buf << idx ();
-
-  if (show_parens)
-    {
-      if (nd - dim < 5)
-        {
-          for (octave_idx_type i = 0; i < nd - dim; i++)
-            buf << ",_";
-
-          if (nd >= dim)
-            buf << ")";
-        }
-      else
-        buf << "...[x" << nd - dim << "]...)";
-    }
-
-  return buf.str ();
-}
-
 class invalid_index : public index_exception
 {
 public:
 
   invalid_index (const std::string& value, octave_idx_type ndim,
                  octave_idx_type dimen)
     : index_exception (value, ndim, dimen)
   { }
diff --git a/liboctave/util/lo-array-gripes.h b/liboctave/util/lo-array-gripes.h
--- a/liboctave/util/lo-array-gripes.h
+++ b/liboctave/util/lo-array-gripes.h
@@ -18,102 +18,20 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_lo_array_gripes_h)
 #define octave_lo_array_gripes_h 1
 
+#include "lo-array-errwarn.h"
 #include "dim-vector.h"
 #include "quit.h"
 
-// Exception thrown by gripe_invalid_index
-// This is thrown when the invalid index is detected, at which point nd and dim
-// are usually not known.  It is caught at the place they are known, where a
-// new  gripe_invalid_index  is called.
-//
-// Typically, this should be caught after any call to
-// octave_value_list::index_vector()
-class index_exception : public octave_execution_exception
-{
-public:
-
-  index_exception (const std::string& index_arg, octave_idx_type nd_arg = 0,
-                   octave_idx_type dim_arg = -1, const char *var_arg = "")
-    : index (index_arg), nd (nd_arg), dim (dim_arg), var (var_arg)
-  { }
-
-  ~index_exception (void) { }
-
-  // Erroneous index value.  Called in what, and by external code
-  // (e.g., nth_element) to make a custom error message.
-  std::string idx (void) const { return index; }
-
-  // details set by subclass.
-  virtual std::string details (void) const = 0;
-
-  // ID of error to throw.
-  virtual const char *err_id (void) const = 0;
-
-  virtual std::string message (void) const;
-
-  // Position of error: dimension in error, and number of dimensions.
-  void set_pos (octave_idx_type nd_arg, octave_idx_type dim_arg)
-  {
-    nd = nd_arg;
-    dim = dim_arg;
-  }
-
-  void set_pos_if_unset (octave_idx_type nd_arg, octave_idx_type dim_arg)
-  {
-    if (nd == 0)
-      {
-        nd  = nd_arg;
-        dim = dim_arg;
-      }
-  }
-
-  // Name of variable being indexed.  eye(2)(1,1) gives "<unknown>".
-  void set_var (const std::string& var_arg = "")
-  {
-    var = var_arg;
-  }
-
-private:
-
-  // Value of invalid index.
-  std::string index;
-
-protected:
-
-  // Show what's wrong, e.g.,  A(-1,_), A(0+1i).
-  std::string expression (void) const;
-
-  // Number of dimensions of indexed object.
-  octave_idx_type nd;
-
-  // Dimension number in which invalid index occurred.
-  octave_idx_type dim;
-
-  // Name of variable being indexed.
-  std::string var;
-
-};
-
-extern OCTAVE_API const char *error_id_nonconformant_args;
-
-extern OCTAVE_API const char *error_id_index_out_of_bounds;
-
-extern OCTAVE_API const char *error_id_invalid_index;
-
-extern OCTAVE_API const char *warning_id_nearly_singular_matrix;
-
-extern OCTAVE_API const char *warning_id_singular_matrix;
-
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nan_to_logical_conversion (void);
 
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nan_to_character_conversion (void);
 
 OCTAVE_NORETURN OCTAVE_API extern void
 gripe_nonconformant (const char *op,
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -3,16 +3,17 @@ UTIL_INC = \
   liboctave/util/base-list.h \
   liboctave/util/byte-swap.h \
   liboctave/util/caseless-str.h \
   liboctave/util/cmd-edit.h \
   liboctave/util/cmd-hist.h \
   liboctave/util/data-conv.h \
   liboctave/util/functor.h \
   liboctave/util/glob-match.h \
+  liboctave/util/lo-array-errwarn.h \
   liboctave/util/lo-array-gripes.h \
   liboctave/util/lo-cutils.h \
   liboctave/util/lo-ieee.h \
   liboctave/util/lo-macros.h \
   liboctave/util/lo-math.h \
   liboctave/util/lo-traits.h \
   liboctave/util/lo-utils.h \
   liboctave/util/oct-alloc.h \
@@ -46,16 +47,17 @@ UTIL_C_SRC = \
   liboctave/util/oct-rl-edit.c \
   liboctave/util/oct-rl-hist.c
 
 UTIL_SRC = \
   liboctave/util/cmd-edit.cc \
   liboctave/util/cmd-hist.cc \
   liboctave/util/data-conv.cc \
   liboctave/util/glob-match.cc \
+  liboctave/util/lo-array-errwarn.cc \
   liboctave/util/lo-array-gripes.cc \
   liboctave/util/lo-ieee.cc \
   liboctave/util/lo-utils.cc \
   liboctave/util/oct-base64.cc \
   liboctave/util/oct-glob.cc \
   liboctave/util/oct-inttypes.cc \
   liboctave/util/oct-locbuf.cc \
   liboctave/util/oct-mutex.cc \
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -179,17 +179,17 @@ binmap (const Array<T>& xa, const Array<
         {
           bsxfun_wrapper<U, T, R, F>::set_f(fcn);
           return do_bsxfun_op (xa, ya,
                                bsxfun_wrapper<U, T, R, F>::op_mm,
                                bsxfun_wrapper<U, T, R, F>::op_sm,
                                bsxfun_wrapper<U, T, R, F>::op_ms);
         }
       else
-        gripe_nonconformant (name, xad, yad);
+        err_nonconformant (name, xad, yad);
     }
 
   octave_idx_type len = xa.numel ();
 
   const T *x = xa.data ();
   const T *y = ya.data ();
 
   Array<U> result (xa.dims ());
@@ -281,17 +281,17 @@ template <class U, class T, class R, cla
 Sparse<U>
 binmap (const Sparse<T>& xs, const Sparse<R>& ys, F fcn, const char *name)
 {
   if (xs.rows () == 1 && xs.cols () == 1)
     return binmap<U, T, R, F> (xs(0,0), ys, fcn);
   else if (ys.rows () == 1 && ys.cols () == 1)
     return binmap<U, T, R, F> (xs, ys(0,0), fcn);
   else if (xs.dims () != ys.dims ())
-    gripe_nonconformant (name, xs.dims (), ys.dims ());
+    err_nonconformant (name, xs.dims (), ys.dims ());
 
   T xzero = T ();
   R yzero = R ();
   U fz = fcn (xzero, yzero);
 
   if (fz == U ())
     {
       // Sparsity-preserving function.  Do it efficiently.
