# HG changeset patch
# User jwe
# Date 948271814 0
#      Wed Jan 19 08:50:14 2000 +0000
# Node ID e031284eea27befe6e0a6e771d6a97c49022bd81
# Parent  434790acb067ccfc285ffee13fa90788dcdaebf9
[project @ 2000-01-19 08:49:56 by jwe]

diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -30,30 +30,32 @@
 ## agree, or if either of the arguments is complex.
 ## @end deftypefn
 ## @seealso{round}
 
 ## Author: jwe
 
 function retval = rem (x, y)
 
+  usage_msg = "rem (x, y)";
+
   if (nargin != 2)
-    usage ("rem (x, y)");
+    usage (usage_msg);
   endif
 
   if (any (size (x) != size (y)) && ! (is_scalar (x) || is_scalar (y)))
     error ("rem: argument sizes must agree");
   endif
 
   ## Matlab allows complex arguments, but as far as I can tell, that's a
   ## bunch of hooey.
 
   if (any (any (imag (x))) || any (any (imag (y))))
     error ("rem: complex arguments are not allowed");
   endif
 
   if (nargin == 2)
     retval = x - y .* fix (x ./ y);
   else
-    error ("usage: rem (x, y)");
+    error (usage_msg);
   endif
 
 endfunction
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -24,17 +24,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 14 September 1994
 ## Adapted-By: jwe
 
 function y = shift (x, b)
 
   if (nargin != 2)
-    error ("usage: shift (X, b)");
+    usage ("shift (X, b)");
   endif
 
   [nr, nc] = size (x);
 
   if (nr == 0 || nc == 0)
     error ("shift: x must not be empty");
   elseif (nr == 1)
     x = x.';
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -58,20 +58,20 @@ function cmap = colormap (map)
         unwind_protect_cleanup
           default_eval_print_flag = save_default_eval_print_flag;
         end_unwind_protect
       endif
     endif
 
     if (! isempty (map))
       if (columns (map) != 3)
-        error( "colormap: map must have 3 columns: [R,G,B]." );
+        error ("colormap: map must have 3 columns: [R,G,B].");
       endif
       if (min (min (map)) < 0 || max (max (map)) > 1)
-        error( "colormap: map must have values in [0,1]." );
+        error ("colormap: map must have values in [0,1].");
       endif
       ## Set the new color map
       __current_color_map__ = map;
     endif
 
   endif
 
   ## Return current color map.
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -19,18 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} image (@var{x}, @var{zoom})
 ## Display a matrix as a color image.  The elements of @var{x} are indices
 ## into the current colormap and should have values between 1 and the
 ## length of the colormap.  If @var{zoom} is omitted, a value of 4 is
 ## assumed.
 ## @end deftypefn
-
-## SEE ALSO: imshow, imagesc, colormap.
+## @seealso{imshow, imagesc, and colormap}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function image (x, zoom)
 
   if (nargin == 0)
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -19,18 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} imagesc (@var{x}, @var{zoom})
 ## Display a scaled version of the matrix @var{x} as a color image.  The
 ## matrix is scaled so that its entries are indices into the current
 ## colormap.  The scaled matrix is returned.  If @var{zoom} is omitted, a
 ## value of 4 is assumed.
 ## @end deftypefn
-
-## SEE ALSO: image, imshow
+## @seealso{image and imshow}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function y = imagesc (x, zoom)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -29,18 +29,17 @@
 ##
 ## @code{imshow (@var{x}, @var{map})} displays an indexed image using the
 ## specified colormap.
 ##
 ## @code{imshow (@var{i}, @var{n})} displays a gray scale intensity image.
 ##
 ## @code{imshow (@var{r}, @var{g}, @var{b})} displays an RGB image.
 ## @end deftypefn
-
-## SEE ALSO: image, imagesc, colormap, gray2ind, rgb2ind.
+## @seealso{image, imagesc, colormap, gray2ind, and rgb2ind}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function imshow (a1, a2, a3)
 
   if (nargin < 0 || nargin > 3)
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -18,18 +18,17 @@
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ind2gray (@var{x}, @var{map})
 ## Convert an Octave indexed image to a gray scale intensity image.
 ## If @var{map} is omitted, the current colormap is used to determine the
 ## intensities.
 ## @end deftypefn
-
-## SEE ALSO: gray2ind, rgb2ntsc, image, colormap
+## @seealso{gray2ind, rgb2ntsc, image, and colormap}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function Y = ind2gray (X, map)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -17,18 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{g}, @var{b}] =} ind2rgb (@var{x}, @var{map})
 ## Convert an indexed image to red, green, and blue color components.
 ## If @var{map} is omitted, the current colormap is used for the conversion.
 ## @end deftypefn
-
-## SEE ALSO: rgb2ind, image, imshow, ind2gray, gray2ind.
+## @seealso{rgb2ind, image, imshow, ind2gray, and gray2ind}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (X, map)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -17,18 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} loadimage (@var{file})
 ## Load an image file and it's associated color map from the specified
 ## @var{file}.  The image must be stored in Octave's image format.
 ## @end deftypefn
-
-## SEE ALSO: saveimage, load, save
+## @seealso{saveimage, load, and save}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [img_retval, map_retval] = loadimage (filename)
 
   if (nargin != 1)
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -16,19 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{r}, @var{g}, @var{b})
 ## Convert and RGB image to an Octave indexed image.
 ## @end deftypefn
+## @seealso{ind2rgb and rgb2ntsc}
 
-## SEE ALSO: ind2rgb, rgb2ntsc.
-##
 ## Bugs: The color map may have duplicate entries.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = rgb2ind (R, G, B)
 
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -47,18 +47,17 @@
 ## The conversion to PostScript is based on pbmtolps.c, which was
 ## written by
 ##
 ##   George Phillips <phillips@cs.ubc.ca>
 ##   Department of Computer Science
 ##   University of British Columbia
 ##
 ## and is part of the portable bitmap utilities,
-
-## SEE ALSO: loadimage, save, load, colormap
+## @seealso{loadimage, save, load, and colormap}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 ## Rewritten by jwe to avoid using octoppm and pbm routines so that
 ## people who don't have the the pbm stuff installed can still use this
 ## function.
@@ -265,43 +264,43 @@ function saveimage (filename, img, img_f
     fid = fopen (filename, "w");
 
     fprintf (fid, "%%!PS-Adobe-2.0 EPSF-2.0\n");
     fprintf (fid, "%%%%Creator: Octave %s (saveimage.m)\n", OCTAVE_VERSION);
     fprintf (fid, "%%%%Title: %s\n", filename);
     fprintf (fid, "%%%%Pages: 1\n");
     fprintf (fid, "%%%%BoundingBox: %d %d %d %d\n",
              fix (llx), fix (lly), fix (urx), fix (ury));
-    fprintf (fid, "%%%%EndComments\n" );
+    fprintf (fid, "%%%%EndComments\n");
     fprintf (fid, "/readstring {\n");
     fprintf (fid, "  currentfile exch readhexstring pop\n");
     fprintf (fid, "} bind def\n");
     fprintf (fid, "/picstr %d string def\n",
              fix ((img_nr + padright) * bps / 8));
     fprintf (fid, "%%%%EndProlog\n");
     fprintf (fid, "%%%%Page: 1 1\n");
     fprintf (fid, "gsave\n");
     fprintf (fid, "%g %g translate\n", llx, lly);
     fprintf (fid, "%g %g scale\n", scols, srows);
     fprintf (fid, "%d %d %d\n", img_nr, img_nc, bps);
     fprintf (fid, "[ %d 0 0 -%d 0 %d ]\n", img_nr, img_nc, img_nc);
-    fprintf (fid, "{ picstr readstring }\n" );
-    fprintf (fid, "image\n" );
+    fprintf (fid, "{ picstr readstring }\n");
+    fprintf (fid, "image\n");
 
     img = map(img);
 
     fmt = "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x\n";
     fprintf (fid, fmt, img);
 
     if (rem (img_sz, 30) != 0)
-      fprintf (fid, "\n" );
+      fprintf (fid, "\n");
     endif
 
-    fprintf (fid, "grestore\n" );
-    fprintf (fid, "showpage\n" );
-    fprintf (fid, "%%%%Trailer\n" );
+    fprintf (fid, "grestore\n");
+    fprintf (fid, "showpage\n");
+    fprintf (fid, "%%%%Trailer\n");
     fclose (fid);
 
   else
     error ("saveimage: what happened to the image type?");
   endif
 
 endfunction
diff --git a/scripts/io/puts.m b/scripts/io/puts.m
--- a/scripts/io/puts.m
+++ b/scripts/io/puts.m
@@ -16,18 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} puts (@var{string})
 ## Write a string to the standard output with no formatting.
 ## @end deftypefn
-
-## See also: fputs, printf, fprintf
+## @seealso{fputs, printf and fprintf}
 
 ## Author: jwe
 
 function retval = puts (s)
 
   retval = -1;
 
   if (nargin == 1)
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -41,165 +41,179 @@
 ##     Applications
 ## @end deftypefn
 
 ## Author: A. Scottedward Hodel <a.s.hodel@eng.auburn.edu>
 
 function [Uret,H,nu] = krylov(A,V,k,eps1,pflg);
 
   defeps = 1e-12;
-  if(nargin < 3 | nargin > 5)
-    usage("[U,nu] = krylov(A,V,k{,eps1,pflg})")
-  elseif(nargin < 5)
+
+  if (nargin < 3 || nargin > 5)
+    usage ("[U, nu] = krylov (A, V, k, eps1, pflg)")
+  elseif (nargin < 5)
     pflg = 0;        # default permutation flag
   endif
+
   if(nargin < 4)
     eps1 = defeps;    # default tolerance parameter
   endif
-  if(isempty(eps1)) eps1 = defeps; endif
-
-  na = is_square(A);
-  if( !na ) error("A(%d x %d) must be square",rows(A),columns(A)); endif
 
-  [m,kb] = size(V);
-  if(m != na);
-    error("A(%d x %d), V(%d x %d): argument dimensions do not match", ...
-      na,na,m,kb)
+  if (isempty (eps1))
+    eps1 = defeps;
+  endif
+
+  na = is_square (A);
+  if (! na)
+    error ("A(%d x %d) must be square", rows (A), columns (A));
   endif
 
-  if( !is_scalar(k) )
-    error("krylov: third argument must be a scalar integer")
+  [m, kb] = size(V);
+  if (m != na)
+    error("A(%d x %d), V(%d x %d): argument dimensions do not match",
+	  na, na, m, kb)
   endif
 
-  Vnrm = norm(V,Inf);
+  if (! is_scalar (k))
+    error ("krylov: third argument must be a scalar integer");
+  endif
+
+  Vnrm = norm (V, Inf);
 
-  # check for trivial solution
-  if(Vnrm == 0)
-    Uret = []; nu = 0;  return;
+  ## check for trivial solution
+  if (Vnrm == 0)
+    Uret = [];
+    nu = 0;
+    return;
   endif
 
   # identify trivial null space
-  abm = max(abs([A,V]'));  nzidx = find(abm != 0);  zidx = find(abm == 0);
+  abm = max (abs ([A, V]'));
+  nzidx = find (abm != 0);
+  zidx = find (abm == 0);
 
   # set up vector of pivot points
   pivot_vec = 1:na;
 
   iter = 0;
   alpha = [];
   nh = 0;
-  while (length(alpha) < na) & (columns(V) > 0) & (iter < k)
+  while (length(alpha) < na) && (columns(V) > 0) && (iter < k)
     iter++;
 
-    # get orthogonal basis of V
+    ## get orthogonal basis of V
     jj = 1;
-    while(jj <= columns(V) & length(alpha) < na)
-      nu = length(alpha)+1;   # index of next Householder reflection
+    while (jj <= columns (V) && length (alpha) < na)
+      ## index of next Householder reflection
+      nu = length(alpha)+1;
 
       short_pv = pivot_vec(nu:na);
       q = V(:,jj);
       short_q = q(short_pv);
 
-      if(norm(short_q) < eps1)
-        # insignificant column; delete
-        nv = columns(V);
-        if(jj != nv)
-          [V(:,jj),V(:,nv)] = swap(V(:,jj),V(:,nv));
-          # FIX ME: H columns should be swapped too.  Not done since
-          # Block Hessenberg structure is lost anyway.
+      if (norm (short_q) < eps1)
+	## insignificant column; delete
+        nv = columns (V);
+        if (jj != nv)
+          [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
+	  ## XXX FIXME XXX -- H columns should be swapped too.  Not done
+	  ## since Block Hessenberg structure is lost anyway.
         endif
         V = V(:,1:(nv-1));
-        nu = nu - 1;    # one less reflection
-
+	## one less reflection
+        nu--;
       else
-        # new householder reflection
-        if(pflg)
-          # locate max magnitude element in short_q
-          asq = abs(short_q);
-          maxv = max(asq);
-          maxidx = find(asq == maxv);
+	## new householder reflection
+        if (pflg)
+          ## locate max magnitude element in short_q
+          asq = abs (short_q);
+          maxv = max (asq);
+          maxidx = find (asq == maxv);
           pivot_idx = short_pv(maxidx(1));
 
-          # see if need to change the pivot list
-          if(pivot_idx != pivot_vec(nu))
+	  ## see if need to change the pivot list
+          if (pivot_idx != pivot_vec(nu))
             swapidx = maxidx(1) + (nu-1);
-            [pivot_vec(nu),pivot_vec(swapidx)] = ...
-              swap(pivot_vec(nu),pivot_vec(swapidx));
+            [pivot_vec(nu), pivot_vec(swapidx)] = ...
+		swap (pivot_vec(nu), pivot_vec(swapidx));
           endif
         endif
 
-        # isolate portion of vector for reflection
+	## isolate portion of vector for reflection
         idx = pivot_vec(nu:na);
         jdx = pivot_vec(1:nu);
 
-        [hv,av,z] = housh(q(idx),1,0);
+        [hv, av, z] = housh (q(idx), 1, 0);
         alpha(nu) = av;
         U(idx,nu) = hv;
 
         # reduce V per the reflection
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
         if(iter > 1)
-          # FIX ME: not done correctly for block case
+	  ## XXX FIXME XXX -- not done correctly for block case
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
-        # advance to next column of V
-        jj=jj+1;
+        ## advance to next column of V
+        jj++;
       endif
     endwhile
 
-    # check for oversize V (due to full rank)
-    if( ( columns(V) > na ) & ( length(alpha) == na ) )
-      # trim to size
+    ## check for oversize V (due to full rank)
+    if ((columns (V) > na) && (length (alpha) == na))
+      ## trim to size
       V = V(:,1:na);
-    elseif( columns(V) > na )
+    elseif (columns(V) > na)
       krylov_V = V
       krylov_na = na
-      krylov_length_alpha = length(alpha)
-      error("This case should never happen; submit bug report.");
+      krylov_length_alpha = length (alpha)
+      error ("This case should never happen; submit a bug report");
     endif
 
-    if(columns(V) > 0)
-      # construct next Q and multiply
-      Q = zeros(size(V));
-      for kk=1:columns(Q)
+    if (columns (V) > 0)
+      ## construct next Q and multiply
+      Q = zeros (size (V));
+      for kk = 1:columns (Q)
         Q(pivot_vec(nu-columns(Q)+kk),kk) = 1;
       endfor
 
-      # apply Householder reflections
+      ## apply Householder reflections
       for ii = nu:-1:1
         idx = pivot_vec(ii:na);
         hv = U(idx,ii);
         av = alpha(ii);
         Q(idx,:) = Q(idx,:) - av*hv*(hv'*Q(idx,:));
       endfor
     endif
 
-    # multiply to get new vector;
+    ## multiply to get new vector;
     V = A*Q;
-    # project off of previous vectors
-    nu = length(alpha);
-    for i=1:nu
-      hv = U(:,i);  av = alpha(i);
+    ## project off of previous vectors
+    nu = length (alpha);
+    for i = 1:nu
+      hv = U(:,i);
+      av = alpha(i);
       V = V - av*hv*(hv'*V);
       H(i,nu-columns(V)+(1:columns(V))) = V(pivot_vec(i),:);
     end
 
   endwhile
 
-  # Back out complete U matrix
-  # back out U matrix ;
-  j1 = columns(U);
-  for i=j1:-1:1;
+  ## Back out complete U matrix
+  ## back out U matrix ;
+  j1 = columns (U);
+  for i = j1:-1:1;
     idx = pivot_vec(i:na);
     hv = U(idx,i);
     av = alpha(i);
-    U(:,i) = zeros(na,1);
+    U(:,i) = zeros (na, 1);
     U(idx(1),i) = 1;
     U(idx,i:j1) = U(idx,i:j1)-av*hv*(hv'*U(idx,i:j1));
   endfor
 
-  nu = length(alpha);
+  nu = length (alpha);
   Uret = U;
-  if( max(max( abs(Uret(zidx,:)) )) > 0)
-    warning("krylov: trivial null space corrupted; set pflg=1 or eps1>%e",eps1);
+  if (max (max (abs (Uret(zidx,:)))) > 0)
+    warning ("krylov: trivial null space corrupted; set pflg = 1 or eps1 > %e",
+	     eps1);
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -55,17 +55,17 @@
 ## @end deftypefn
 ## @seealso{cond and svd}
 
 ## Author: jwe
 
 function retval = norm (x, p)
 
   if (nargin < 1 || nargin > 2)
-    error ("usage: norm (x, p)");
+    usage ("norm (x, p)");
   endif
 
   if (isempty (x))
     retval = [];
     return;
   endif
 
   ## Do we have a vector or matrix as the first argument?
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -44,17 +44,17 @@
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (a, b)
 
   if (nargin != 2)
-    error ("usage: [aa, bb, q, z] = qzhess (a, b)");
+    usage ("[aa, bb, q, z] = qzhess (a, b)");
   endif
 
   [na, ma] = size (a);
   [nb, mb] = size (b);
   if (na != ma || na != nb || nb != mb)
     error ("qzhess: incompatible dimensions");
   endif
 
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -25,27 +25,29 @@
 ## @end deftypefn
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ## bar, stairs, gplot, gsplot, replot, xlabel, ylabel, and title}
 
 ## Author: jwe
 
 function grid (x)
 
+  usage_msg = "grid (\"on\" | \"off\")";
+
   if (nargin == 0)
     gset grid;
   elseif (nargin == 1)
     if (isstr (x))
       if (strcmp ("off", x))
         gset nogrid;
       elseif (strcmp ("on", x))
         gset grid;
       else
-    usage ("grid (\"on\" | \"off\")");
+    usage (usage_msg);
       endif
     else
       error ("grid: argument must be a string");
     endif
   else
-    error ("usage: grid (\"on\" | \"off\")");
+    usage (usage_msg);
   endif
 
 endfunction
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -47,18 +47,18 @@
 ##     |       .            .           .    .             .      |
 ##     |_      0            0      ...       1             0     _|
 ## @end smallexample
 ## @end ifinfo
 ##
 ## The eigenvalues of the companion matrix are equal to the roots of the
 ## polynomial.
 ## @end deftypefn
-
-## SEE ALSO: poly, roots, residue, conv, deconv, polyval, polyderiv, polyinteg
+## @seealso{poly, roots, residue, conv, deconv, polyval, polyderiv, and
+## polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -21,18 +21,17 @@
 ## @deftypefn {Function File} {} conv (@var{a}, @var{b})
 ## Convolve two vectors.
 ##
 ## @code{y = conv (a, b)} returns a vector of length equal to
 ## @code{length (a) + length (b) - 1}.
 ## If @var{a} and @var{b} are polynomial coefficient vectors, @code{conv}
 ## returns the coefficients of the product polynomial.
 ## @end deftypefn
-
-## SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg
+## @seealso{deconv, poly, roots, residue, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -23,18 +23,17 @@
 ##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
 ##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
 ## a remander polynomial of lowest order.
 ## @end deftypefn
-
-## SEE ALSO: conv, poly, roots, residue, polyval, polyderiv, polyinteg
+## @seealso{conv, poly, roots, residue, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -17,19 +17,18 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyderiv (@var{c})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by vector @var{c}.
 ## @end deftypefn
-
-## SEE ALSO: poly, polyinteg, polyreduce, roots, conv, deconv, residue,
-##           filter, polyval, polyvalm
+## @seealso{poly, polyinteg, polyreduce, roots, conv, deconv, residue,
+## filter, polyval, and polyvalm}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function q = polyderiv (p)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -19,19 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyinteg (@var{c})
 ## Return the coefficients of the integral of the polynomial whose
 ## coefficients are represented by the vector @var{c}.
 ##
 ## The constant of integration is set to zero.
 ## @end deftypefn
-
-## SEE ALSO: poly, polyderiv, polyreduce, roots, conv, deconv, residue,
-##           filter, polyval, polyvalm
+## @seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
+## filter, polyval, and polyvalm}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyinteg (p)
 
   if(nargin != 1)
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -12,62 +12,73 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} polyout (@var{c}@{, @var{x}@})
-## write formatted polynomial
+## @deftypefn {Function File} polyout (@var{c}, @var{x})
+## Write formatted polynomial
 ## @example
 ##    c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
 ## @end example
-##  to string @var{y} or to the screen (if @var{y} is omitted)
+##  and return it as a string or write it to the screen (if
+##  @var{nargout} is zero).
 ##  @var{x} defaults to the string @code{"s"}
 ## @end deftypefn
 ## @seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
 ## filter, polyderiv, and polyinteg}
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
-  if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
-    usage("[y = ] polyout(c,[x])");
+  if (nargin < 1) || (nargin > 2) || (nargout < 0) || (nargout > 1)
+    usage("polyout (c, x)");
   endif
 
-  if (!is_vector(c))
+  if (! is_vector (c))
     error("polyout: first argument must be a vector");
   endif
 
   if (nargin == 1)
     x = "s";
-  elseif( ! isstr(x) )
+  elseif (! isstr(x))
     error("polyout: second argument must be a string");
   endif
 
   n = length(c);
   if(n > 0)
     n1 = n+1;
 
-    if( imag(c(1)) )     tmp = com2str(c(1))
-    else                 tmp = num2str(c(1));       endif
+    if (imag (c(1)))
+      tmp = com2str(c(1))
+    else
+      tmp = num2str(c(1));
+    endif
 
-    for ii=2:n
-      if(real(c(ii)) < 0)     ns = " - ";    c(ii) = -c(ii);
-      else                    ns = " + ";                      endif
+    for ii = 2:n
+      if (real (c(ii)) < 0)
+	ns = " - ";
+	c(ii) = -c(ii);
+      else
+        ns = " + ";
+      endif
 
-      if( imag(c(ii)) )       nstr = sprintf("(%s)",com2str(c(ii)) );
-      else                    nstr = num2str(c(ii));           endif
+      if (imag (c(ii)))
+	nstr = sprintf ("(%s)", com2str (c(ii)));
+      else
+        nstr = num2str (c(ii));
+      endif
 
-      tmp = sprintf("%s*%s^%d%s%s",tmp,x,n1-ii,ns,nstr);
+      tmp = sprintf ("%s*%s^%d%s%s", tmp, x, n1-ii, ns, nstr);
 
     endfor
   else
     tmp = " ";
   endif
 
   if(nargout == 0)
     disp(tmp)
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -17,19 +17,18 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyreduce (@var{c})
 ## Reduces a polynomial coefficient vector to a minimum number of terms by
 ## stripping off any leading zeros.
 ## @end deftypefn
-
-## SEE ALSO: poly, roots, conv, deconv, residue, filter, polyval, polyvalm,
-##           polyderiv, polyinteg
+## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
+## polyvalm, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (p)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -22,19 +22,18 @@
 ## Evaluate a polynomial.
 ##
 ## @code{polyval (@var{c}, @var{x})} will evaluate the polynomial at the
 ## specified value of @var{x}.
 ##
 ## If @var{x} is a vector or matrix, the polynomial is evaluated at each of
 ## the elements of @var{x}.
 ## @end deftypefn
-
-## SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
-##           polyderiv, polyinteg
+## @seealso{polyvalm, poly, roots, conv, deconv, residue, filter,
+## polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -22,19 +22,18 @@
 ## Evaluate a polynomial in the matrix sense.
 ##
 ## @code{polyvalm (@var{c}, @var{x})} will evaluate the polynomial in the
 ## matrix sense, i.e. matrix multiplication is used instead of element by
 ## element multiplication as is used in polyval.
 ##
 ## The argument @var{x} must be a square matrix.
 ## @end deftypefn
-
-## SEE ALSO: polyval, poly, roots, conv, deconv, residue, filter,
-##           polyderiv, polyinteg
+## @seealso{polyval, poly, roots, conv, deconv, residue, filter,
+## polyderiv, and polyinteg)
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -95,18 +95,17 @@
 ##
 ## @example
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end example
 ## @end ifinfo
 ## @end deftypefn
-
-## SEE ALSO: poly, roots, conv, deconv, polyval, polyderiv, polyinteg
+## @seealso{poly, roots, conv, deconv, polyval, polyderiv, and polyinteg}
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [r, p, k, e] = residue (b, a, toler)
 
   ## Here's the method used to find the residues.
diff --git a/scripts/quaternion/quaternion.m b/scripts/quaternion/quaternion.m
--- a/scripts/quaternion/quaternion.m
+++ b/scripts/quaternion/quaternion.m
@@ -104,13 +104,13 @@ function [a, b, c, d] = quaternion (w, x
       usage ("w = quaterion (a, b, c, d)");
     endif
     if (! (is_scalar (w) && is_scalar (x) && is_scalar (y) && is_scalar (z)))
       error ("input values must be scalars.");
     endif
     a = [w, x, y, z];
 
   otherwise
-    error ("usage: [a, b, c, d] = quaternion (w), a = quaternion (w, x, y, z)");
+    usage ("[a, b, c, d] = quaternion (w) or a = quaternion (w, x, y, z)");
 
   endswitch
 
 endfunction
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -30,17 +30,17 @@
 ## @end example
 ## @end deftypefn
 ## @seealso{union, intersection, and complement}
 
 ## Author: jwe
 
 function y = create_set(x)
 
-  if ( nargin != 1)
+  if (nargin != 1)
     usage ("create_set(x)");
   endif
 
   if(isempty(x))
     y = [];
   else
     [nrx, ncx] = size(x);
     nelx = nrx*ncx;
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -38,37 +38,36 @@
 ## [1, y(t-1), ..., y(t-k)]
 ## @end example
 ##
 ## Optionally, one can specify the number of iterations @var{iter}, the
 ## updating factor @var{gamma}, and initial values @var{a0} and @var{b0}
 ## for the scoring algorithm.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Fit an ARCH regression model
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     usage ("arch_fit (y, X, p, ITER, gamma, a0, b0)");
   endif
 
-  if !(is_vector (y))
-    error ("arch_test:  y must be a vector");
+  if (! (is_vector (y)))
+    error ("arch_test: y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
-  elseif !(rx == T)
-    error (["arch_test:  ", ...
-            "either rows (X) == length (y), or X is a scalar"]);
+  elseif (! (rx == T))
+    error ("arch_test: either rows (X) == length (y), or X is a scalar");
   endif
 
   [T, k] = size (X);
 
   if (nargin == 7)
     a   = a0;
     b   = b0;
     e   = y - X * b;
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -28,34 +28,34 @@
 ## where e(t), given @var{y} up to time @var{t}-1, is @var{N}(0,
 ## @var{h}(@var{t})), with
 ##
 ## @example
 ## h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
 ## @end example
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Simulate an ARCH process
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Simulate an ARCH process
 
 function y = arch_rnd (a, b, T)
 
   if (nargin != 3)
     usage ("arch_rnd (a, b, T)");
   endif
 
-  if !( (min (size (a)) == 1) && (min (size (b)) == 1) )
-    error ("arch_rnd:  a and b must both be scalars or vectors");
+  if (! ((min (size (a)) == 1) && (min (size (b)) == 1)))
+    error ("arch_rnd: a and b must both be scalars or vectors");
   endif
-  if !( is_scalar (T) && (T > 0) && (rem (T, 1) == 0) )
-    error ("arch_rnd:  T must be a positive integer");
+  if (! (is_scalar (T) && (T > 0) && (rem (T, 1) == 0)))
+    error ("arch_rnd: T must be a positive integer");
   endif
 
-  if !(a(1) > 0)
-    error ("arch_rnd:  a(1) must be positive");
+  if (! (a(1) > 0))
+    error ("arch_rnd: a(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
 
   la = length (a);
   a  = reshape (a, 1, la);
   if (la == 1)
     a  = [a, 0];
     la = la + 1;
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -55,39 +55,38 @@
 ##
 ## Under the null, LM approximately has a chisquare distribution with
 ## @var{p} degrees of freedom and @var{pval} is the @var{p}-value (1
 ## minus the CDF of this distribution at LM) of the test.
 ##
 ## If no output argument is given, the @var{p}-value is displayed.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Test for conditional heteroscedascity
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Test for conditional heteroscedascity
 
 function [pval, lm] = arch_test (y, X, p)
 
   if (nargin != 3)
     error ("arch_test needs 3 input arguments");
   endif
 
-  if !(is_vector (y))
-    error ("arch_test:  y must be a vector");
+  if (! (is_vector (y)))
+    error ("arch_test: y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
-  elseif !(rx == T)
-    error (["arch_test:  ", ...
-            "either rows(X) == length(y), or X is a scalar"]);
+  elseif (! (rx == T))
+    error ("arch_test: either rows(X) == length(y), or X is a scalar");
   endif
-  if !(is_scalar(p) && (rem(p, 1) == 0) && (p > 0))
-    error ("arch_test:  p must be a positive integer.");
+  if (! (is_scalar(p) && (rem(p, 1) == 0) && (p > 0)))
+    error ("arch_test: p must be a positive integer.");
   endif
 
   [b, v_b, e] = ols (y, X);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chisquare_cdf (lm, p);
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -29,18 +29,18 @@
 ## variance @var{v}.  The function returns a vector of length @var{t}.
 ##
 ## The optional parameter @var{n} gives the number of dummy
 ## @var{x}(@var{i}) used for initialization, i.e., a sequence of length
 ## @var{t}+@var{n} is generated and @var{x}(@var{n}+1:@var{t}+@var{n})
 ## is returned.  If @var{n} is omitted, @var{n} = 100 is used. 
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Simulate an ARMA process
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   unwind_protect
     orig_listelemok = empty_list_elements_ok;
     empty_list_elements_ok = "true";
 
     if (nargin == 4)
@@ -48,22 +48,22 @@ function x = arma_rnd (a, b, v, t, n)
     elseif (nargin == 5)
       if (!is_scalar (t))
         error ("arma_rnd: n must be a scalar");
       endif
     else
       usage ("arma_rnd (a, b, v, t, n)");
     endif
 
-    if ( (min (size (a)) > 1) || (min (size (b)) > 1) )
-      error ("arma_rnd:  a and b must not be matrices");
+    if ((min (size (a)) > 1) || (min (size (b)) > 1))
+      error ("arma_rnd: a and b must not be matrices");
     endif
 
     if (!is_scalar (t))
-      error ("arma_rnd:  t must be a scalar");
+      error ("arma_rnd: t must be a scalar");
     endif
 
     ar = length (a);
     br = length (b);
 
     a = reshape (a, ar, 1);
     b = reshape (b, br, 1);
 
diff --git a/scripts/signal/autocor.m b/scripts/signal/autocor.m
--- a/scripts/signal/autocor.m
+++ b/scripts/signal/autocor.m
@@ -17,29 +17,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autocor (@var{x}, @var{h})
 ## Return the autocorrelations from lag 0 to @var{h} of vector @var{x}.
 ## If @var{h} is omitted, all autocorrelations are computed.
 ## If @var{X} is a matrix, the autocorrelations of each column are
 ## computed.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Compute autocorrelations
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Compute autocorrelations
 
 function retval = autocor (X, h)
 
   if (nargin == 1)
     retval = autocov (X);
   elseif (nargin == 2)
     retval = autocov (X, h);
   else
     usage ("autocor (X, h)");
   endif
 
   if (min (retval (1,:)) != 0)
-    retval = retval ./ ( ones (rows (retval), 1) * retval(1, :) );
+    retval = retval ./ (ones (rows (retval), 1) * retval(1,:));
   endif
 
 endfunction
 
 
 
diff --git a/scripts/signal/autocov.m b/scripts/signal/autocov.m
--- a/scripts/signal/autocov.m
+++ b/scripts/signal/autocov.m
@@ -17,18 +17,18 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autocov (@var{x}, @var{h})
 ## Return the autocovariances from lag 0 to @var{h} of vector @var{x}.
 ## If @var{h} is omitted, all autocovariances are computed.
 ## If @var{x} is a matrix, the autocovariances of each column are
 ## computed.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Compute autocovariances
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Compute autocovariances
 
 function retval = autocov (X, h)
 
   [n, c] = size (X);
 
   if (is_vector (X))
     n = length (X);
     c = 1;
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -19,27 +19,27 @@
 ## Given a time series (vector) @var{y}, return a matrix with ones in the
 ## first column and the first @var{k} lagged values of @var{y} in the
 ## other columns.  I.e., for @var{t} > @var{k}, @code{[1,
 ## @var{y}(@var{t}-1), ..., @var{y}(@var{t}-@var{k})]} is the t-th row
 ## of the result.  The resulting matrix may be used as a regressor matrix
 ## in autoregressions.
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Design matrix for autoregressions
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
     usage ("autoreg_matrix (y, k)");
   endif
 
-  if !(is_vector (y))
-    error ("autoreg_matrix:  y must be a vector");
+  if (! (is_vector (y)))
+    error ("autoreg_matrix: y must be a vector");
   endif
 
   T = length (y);
   y = reshape (y, T, 1);
   X = ones (T, k+1);
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -18,27 +18,27 @@
 ## @deftypefn {Function File} {} bartlett (@var{m})
 ## Return the filter coefficients of a Bartlett (triangular) window of
 ## length @var{m}.
 ##
 ## For a definition of the Bartlett window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Coefficients of the Bartlett (triangular) window
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
 
   if (nargin != 1)
     usage ("bartlett (m)");
   endif
 
-  if !(is_scalar (m) && (m == round (m)) && (m > 0))
-    error ("bartlett:  m has to be an integer > 0");
+  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+    error ("bartlett: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     n = fix (m / 2);
     c (1 : n+1) = 2 * (0 : n)' / m;
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -17,27 +17,27 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} blackman (@var{m})
 ## Return the filter coefficients of a Blackman window of length @var{m}.
 ##
 ## For a definition of the  Blackman window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Coefficients of the Blackman window
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Coefficients of the Blackman window
 
 function c = blackman (m)
 
   if (nargin != 1)
     usage ("blackman (m)");
   endif
 
-  if !(is_scalar (m) && (m == round (m)) && (m > 0))
-    error ("blackman:  m has to be an integer > 0");
+  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+    error ("blackman: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -31,17 +31,17 @@
 ## Adapted-By: jwe
 
 function y = detrend (x, p)
 
   if (nargin == 1)
     p = 1;
   elseif (nargin == 2)
     if (! (is_scalar (p) && p == round (p) && p >= 0))
-      error ("detrend:  p must be a nonnegative integer");
+      error ("detrend: p must be a nonnegative integer");
     endif
   else
     usage ("detrend (x, p)");
   endif
 
   [m, n] = size (x);
   if (m == 1)
     x = x';
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -30,51 +30,51 @@
 ## The estimators for all frequencies in the intervals
 ## described above is returned in @var{D}.  The value of @var{d} is
 ## simply the mean of @var{D}.
 ##
 ## Reference: Brockwell, Peter J. & Davis, Richard A. Time Series:
 ## Theory and Methods Springer 1987.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Estimate the fractional differencing parameter
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Estimate the fractional differencing parameter
 
 function [d, D] = diffpara (X, a, b)
 
   if ((nargin < 1) || (nargin > 3))
     usage ("[d, D] = diffpara (X, a, b)");
   else
-    if is_vector (X)
+    if (is_vector (X))
       n = length (X);
       k = 1;
       X = reshape (X, n, 1);
     else
       [n, k] = size(X);
     endif
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
   endif
 
-  if !(is_scalar (a) && is_scalar (b))
-    error ("diffpara:  a and b must be scalars");
+  if (! (is_scalar (a) && is_scalar (b)))
+    error ("diffpara: a and b must be scalars");
   endif
 
   D = zeros (b - a + 1, k);
 
   for l = 1:k
 
     w = 2 * pi * (1 : n-1) / n;
 
-    x = 2 * log (abs( 1 - exp (-i*w)));
+    x = 2 * log (abs (1 - exp (-i*w)));
     y = log (periodogram (X(2:n,l)));
 
     x = center (x);
     y = center (y);
 
     for m = a:b
       D(m-a+1) = - x(1:m) * y(1:m) / sumsq (x(1:m));
     endfor
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -22,69 +22,69 @@
 ## gamma_t]} from lag 0 to @var{t}, @var{oldphi} specifies the
 ## coefficients based on @var{c}(@var{t}-1) and @var{oldv} specifies the
 ## corresponding error.
 ##
 ## If @var{oldphi} and @var{oldv} are omitted, all steps from 1 to
 ## @var{t} of the algorithm are performed.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Perform one step of the Durbin-Levinson algorithm
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Perform one step of the Durbin-Levinson algorithm
 
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
 
-  if( !((nargin == 1) || (nargin == 3)) )
+  if (! ((nargin == 1) || (nargin == 3)))
     usage ("durbinlevinson (c, oldphi, oldv)");
   endif
 
-  if( columns (c) > 1 )
+  if (columns (c) > 1)
     c=c';
   endif
 
   newphi = 0;
   newv = 0;
 
   if (nargin == 3)
 
     t = length (oldphi) + 1;
 
     if (length (c) < t+1)
-      error ("durbilevinson:  c too small");
+      error ("durbilevinson: c too small");
     endif
 
     if (oldv == 0)
       error ("durbinlevinson: oldv = 0");
     endif
 
-    if (rows (oldphi) > 1 )
+    if (rows (oldphi) > 1)
       oldphi = oldphi';
     endif
 
     newphi = zeros (1, t);
-    newphi(1) = ( c(t+1) - oldphi * c(2:t) ) / oldv;
+    newphi(1) = (c(t+1) - oldphi * c(2:t)) / oldv;
     for i = 2 : t
       newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
     endfor
-    newv = ( 1 - newphi(1)^2 ) * oldv;
+    newv = (1 - newphi(1)^2) * oldv;
 
   elseif(nargin == 1)
 
     tt = length (c)-1;
     oldphi = c(2) / c(1);
-    oldv = ( 1 - oldphi^2 ) * c(1);
+    oldv = (1 - oldphi^2) * c(1);
 
     for t = 2 : tt
 
       newphi = zeros (1, t);
-      newphi(1) = ( c(t+1) - oldphi * c(2:t) ) / oldv;
+      newphi(1) = (c(t+1) - oldphi * c(2:t)) / oldv;
       for i = 2 : t
         newphi(i) = oldphi(i-1) - newphi(1) * oldphi(t-i+1);
       endfor
-      newv = ( 1 - newphi(1)^2 ) * oldv;
+      newv = (1 - newphi(1)^2) * oldv;
 
       oldv = newv;
       oldphi = newphi;
 
     endfor
 
   endif
 
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -34,29 +34,29 @@
 
 function c = fftconv (a, b, N)
 
   if (nargin < 2 || nargin > 3)
     usage ("fftconv (b, x, N)");
   endif
 
   if (! (is_vector (a) && is_vector (b)))
-    error ("fftconv:  both a and b should be vectors");
+    error ("fftconv: both a and b should be vectors");
   endif
   la = length (a);
   lb = length (b);
   if ((la == 1) || (lb == 1))
     c = a * b;
   else
     lc = la + lb - 1;
     a(lc) = 0;
     b(lc) = 0;
     if (nargin == 2)
       c = fftfilt (a, b);
     else
-      if !(is_scalar (N))
+      if (! (is_scalar (N)))
         error ("fftconv: N has to be a scalar");
       endif
       c = fftfilt (a, b, N);
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -61,17 +61,17 @@ function y = fftfilt (b, x, N)
 
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
     N    = 2^(ceil (log (l_x + l_b - 1) / log(2)));
     y    = ifft (fft (x, N) .* fft(b, N));
   else
     ## Use overlap-add method ...
-    if !(is_scalar (N))
+    if (! (is_scalar (N)))
       error ("fftfilt: N has to be a scalar");
     endif
     N = 2^(ceil (log (max ([N, l_b])) / log(2)));
     L = N - l_b + 1;
     B = fft (b, N);
     R = ceil (l_x / L);
     y = zeros (1, l_x);
     for r = 1:R;
@@ -80,17 +80,17 @@ function y = fftfilt (b, x, N)
       tmp = ifft (fft (x(lo:hi), N) .* B);
       hi  = min (lo+N-1, l_x);
       y(lo:hi) = y(lo:hi) + tmp(1:(hi-lo+1));
     endfor
   endif
 
   y = reshape (y(1:l_x), r_x, c_x);
 
-  ## Final cleanups:  if both x and b are real respectively integer, y
+  ## Final cleanups: if both x and b are real respectively integer, y
   ## should also be
 
   if (! (any (imag (x)) || any (imag (b))))
     y = real (y);
   endif
   if (! (any (x - round (x)) || any (b - round (b))))
     y = round (y);
   endif
diff --git a/scripts/signal/fractdiff.m b/scripts/signal/fractdiff.m
--- a/scripts/signal/fractdiff.m
+++ b/scripts/signal/fractdiff.m
@@ -15,29 +15,29 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fractdiff (@var{x}, @var{d})
 ## Compute the fractional differences @code{(1-@var{L})^@var{d} * @var{x}}
 ## where @var{L} denotes the lag-operator and @var{d} is greater than -1.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Compute fractional differences
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Compute fractional differences
 
 function retval = fractdiff (x, d)
 
   N = 100;
 
-  if !is_vector (x)
-    error ("fractdiff:  x must be a vector")
+  if (! is_vector (x))
+    error ("fractdiff: x must be a vector")
   endif
 
-  if !is_scalar (d)
-    error ("fractdiff:  d must be a scalar")
+  if (! is_scalar (d))
+    error ("fractdiff: d must be a scalar")
   endif
 
 
   if (d >= 1)
     for k = 1 : d
       x = x(2 : length (x)) - x(1 : length (x) - 1);
     endfor
   endif
@@ -51,13 +51,13 @@ function retval = fractdiff (x, d)
       w = real (gamma (-d+n) ./ gamma (-d) ./ gamma (n+1));
       retval = fftfilt (w, x);
       retval = retval(1 : length (x));
     else
       retval = x;
     endif
 
   else
-    error ("fractdiff:  d must be > -1");
+    error ("fractdiff: d must be > -1");
 
   endif
 
 endfunction
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -81,17 +81,17 @@ function [h, w] = freqz(b,...)
 
   la = length(a);
   a = reshape(a,1,la);
   lb = length(b);
   b = reshape(b,1,lb);
 
   k = max([la, lb]);
 
-  if( n >= k)
+  if (n >= k)
     if (strcmp(region,"whole"))
       h = fft(postpad(b,n)) ./ fft(postpad(a,n));
       w = 2*pi*[0:(n-1)]/n;
     else
       h = fft(postpad(b,2*n)) ./ fft(postpad(a,2*n));
       h = h(1:n);
       w = pi*[0:(n-1)]/n;
     endif
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -17,27 +17,27 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hamming (@var{m})
 ## Return the filter coefficients of a Hamming window of length @var{m}.
 ##
 ## For a definition of the Hamming window, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Coefficients of the Hamming window
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Coefficients of the Hamming window
 
 function c = hamming (m)
 
   if (nargin != 1)
     usage ("hamming (m)");
   endif
 
-  if !(is_scalar (m) && (m == round (m)) && (m > 0))
-    error ("hamming:  m has to be an integer > 0");
+  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+    error ("hamming: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -17,27 +17,27 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hanning (@var{m})
 ## Return the filter coefficients of a Hanning window of length @var{m}.
 ##
 ## For a definition of this window type, see e.g. A. V. Oppenheim &
 ## R. W. Schafer, "Discrete-Time Signal Processing".
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Coefficients of the Hanning window
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Coefficients of the Hanning window
 
 function c = hanning (m)
 
   if (nargin != 1)
     usage ("hanning (m)");
   endif
 
-  if !(is_scalar (m) && (m == round (m)) && (m > 0))
-    error ("hanning:  m has to be an integer > 0");
+  if (! (is_scalar (m) && (m == round (m)) && (m > 0)))
+    error ("hanning: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -16,28 +16,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hurst (@var{x})
 ## Estimate the Hurst parameter of sample @var{x} via the rescaled range
 ## statistic.  If @var{x} is a matrix, the parameter is estimated for
 ## every single column.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Estimate the Hurst parameter
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Estimate the Hurst parameter
 
 function H = hurst (x)
 
   if (nargin != 1)
     usage ("hurst (x)");
   endif
 
   if (is_scalar (x))
-    error ("hurst:  x must not be a scalar")
-  elseif is_vector (x)
+    error ("hurst: x must not be a scalar")
+  elseif (is_vector (x))
     x = reshape (x, length (x), 1);
   end
 
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
   RS = (max(w) - min(w)) ./ s;
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -16,17 +16,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} periodogram (@var{x})
 ## For a data matrix @var{x} from a sample of size @var{n}, return the
 ## periodogram.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Compute the periodogram
+## Description: Compute the periodogram
 
 function retval = periodogram (x)
 
   [r, c] = size(x);
 
   if (r == 1)
     r = c;
   endif
diff --git a/scripts/signal/rectangle_lw.m b/scripts/signal/rectangle_lw.m
--- a/scripts/signal/rectangle_lw.m
+++ b/scripts/signal/rectangle_lw.m
@@ -15,18 +15,18 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rectangle_lw (@var{n}, @var{b})
 ## Rectangular lag window. Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Rectangular lag window
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Rectangular lag window
 
 function retval = rectangle_lw (n, b)
 
   retval = zeros (n, 1);
   t = floor (1 / b);
 
   retval (1:t, 1) = ones (t, 1);
 
diff --git a/scripts/signal/rectangle_sw.m b/scripts/signal/rectangle_sw.m
--- a/scripts/signal/rectangle_sw.m
+++ b/scripts/signal/rectangle_sw.m
@@ -15,28 +15,28 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rectangle_sw (@var{n}, @var{b})
 ## Rectangular spectral window.  Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Rectangular spectral window
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Rectangular spectral window
 
 function retval = rectangle_sw (n, b)
 
   retval = zeros (n, 1);
   retval(1) = 2 / b + 1;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
-  retval(2:n) = sin( (2/b + 1) * l / 2 ) ./ sin (l / 2);
+  retval(2:n) = sin ((2/b + 1) * l / 2) ./ sin (l / 2);
 
 endfunction
 
 
 
 
 
 
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -18,18 +18,18 @@
 ## @deftypefn {Function File} {} sinetone (@var{freq}, @var{rate}, @var{sec}, @var{ampl})
 ## Return a sinetone of frequency @var{freq} with length of @var{sec}
 ## seconds at sampling rate @var{rate} and with amplitude @var{ampl}.
 ## The arguments @var{freq} and @var{ampl} may be vectors of common size.
 ##
 ## Defaults are @var{rate} = 8000, @var{sec} = 1 and @var{ampl} = 64.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Compute a sine tone
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Compute a sine tone
 
 function retval = sinetone (f, r, s, a)
 
   if (nargin == 1)
     r = 8000;
     s = 1;
     a = 64;
   elseif (nargin == 2)
@@ -38,21 +38,21 @@ function retval = sinetone (f, r, s, a)
   elseif (nargin == 3)
     a = 64;
   elseif ((nargin < 1) || (nargin > 4))
     usage ("sinetone (freq, rate, sec, ampl)");
   endif
 
   [err, f, a] = common_size (f, a);
   if (err || ! is_vector (f))
-    error ("sinetone:  freq and ampl must be vectors of common size");
+    error ("sinetone: freq and ampl must be vectors of common size");
   endif
 
-  if !(is_scalar (r) && is_scalar (s))
-    error ("sinetone:  rate and sec must be scalars");
+  if (! (is_scalar (r) && is_scalar (s)))
+    error ("sinetone: rate and sec must be scalars");
   endif
 
   n = length (f);
 
   retval = zeros (r * s, n);
   for k = 1:n
     retval (:, k) = a(k) * sin (2 * pi * (1:r*s) / r * f(k))';
   endfor
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -17,22 +17,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinewave (@var{m}, @var{n}, @var{d})
 ## Return an @var{m}-element vector with @var{i}-th element given by
 ## @code{sin (2 * pi * (@var{i}+@var{d}-1) / @var{n})}.
 ##
 ## The default value for @var{d} is 0.
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Compute a sine wave
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Compute a sine wave
 
 function x = sinewave (m, n, d)
 
   if (nargin == 2)
     d = 0;
   elseif (nargin != 3)
     usage ("sinewave (m, n, d)");
   endif
 
-  x = sin ( ((1 : m) + d - 1) * 2 * pi / n);
+  x = sin (((1 : m) + d - 1) * 2 * pi / n);
 
 endfunction
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -22,18 +22,18 @@
 ##
 ## The window name, e.g., @code{"triangle"} or @code{"rectangle"} is
 ## used to search for a function called @code{@var{win}_sw}.
 ##
 ## If @var{win} is omitted, the triangle window is used.  If @var{b} is
 ## omitted, @code{1 / sqrt (length (@var{x}))} is used.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Spectral density estimation
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Spectral density estimation
 
 function retval = spectral_adf (c, win, b)
 
   cr = length (c);
 
   if (columns (c) > 1)
     c=c';
   endif
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -21,18 +21,18 @@
 ##
 ## The window name, e.g., @code{"triangle"} or @code{"rectangle"} is
 ## used to search for a function called @code{@var{win}_sw}.
 ##
 ## If @var{win} is omitted, the triangle window is used.  If @var{b} is
 ## omitted, @code{1 / sqrt (length (@var{x}))} is used.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Spectral density estimation
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Spectral density estimation
 
 function retval = spectral_xdf (X, win, b)
 
   xr = length (X);
 
   if (columns (X) > 1)
     X = X';
   endif
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -15,18 +15,18 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spencer (@var{x})
 ## Return Spencer's 15 point moving average of every single column of
 ## @var{x}.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Apply Spencer's 15-point MA filter
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Apply Spencer's 15-point MA filter
 
 function retval = spencer (X)
 
   if (nargin != 1)
     usage ("spencer (X)");
   endif
 
   [xr, xc] = size(X);
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -43,18 +43,18 @@
 ## frequencies.
 ##
 ## @code{[@var{y}, @var{c}] = stft (@code{x}, @dots{})} returns the
 ## entire STFT-matrix @var{y} and a 3-element vector @var{c} containing
 ## the window size, increment, and window type, which is needed by the
 ## synthesis function.
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Short-term Fourier transform
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Short-term Fourier transform
 
 function [Y, c] = stft(X, win, inc, coef, w_type)
 
   ## default values of unspecified arguments
   if (nargin < 5)
     w_type = 1;
     if (nargin < 4)
       coef = 64;
@@ -69,38 +69,38 @@ function [Y, c] = stft(X, win, inc, coef
     if (isstr (w_type))
       if (strcmp (w_type, "hanning"))
         w_type = 1;
       elseif (strcmp (w_type, "hamming"))
         w_type = 2;
       elseif (strcmp (w_type, "rectangle"))
         w_type = 3;
       else
-        error (["stft:  unknown window type `", w_type, "'"])
+        error ("stft: unknown window type `%s'", w_type);
       endif
     endif
   else
     usage ("[Y, c] = stft(X, win_size, inc, num_coef, w_type)");
   endif
 
   ## check whether X is a vector
   [nr, nc] = size (X);
   if (nc != 1)
     if (nr == 1)
       X = X';
       nr = nc;
     else
-      error ("stft:  X must be a vector");
+      error ("stft: X must be a vector");
     endif
   endif
 
   num_coef = 2 * coef;
   if (win > num_coef)
     win = num_coef;
-    printf ("stft:  window size adjusted to %f\n", win);
+    printf ("stft: window size adjusted to %f\n", win);
   endif
   num_win = fix ((nr - win) / inc);
 
   ## compute the window coefficients
   if (w_type == 3)              # rectangular window
     WIN_COEF = ones (win, 1);
   elseif (w_type == 2)          # Hamming window
     WIN_COEF = hamming (win);
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -22,43 +22,43 @@
 ##
 ## The values @var{y} and @var{c} can be derived by
 ##
 ## @example
 ## [@var{y}, @var{c}] = stft (@var{x} , @dots{})
 ## @end example
 ## @end deftypefn
 
-## Author:  AW <Andreas.Weingessel@ci.tuwien.ac.at>
-## Description:  Recover a signal from its short-term Fourier transform
+## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
+## Description: Recover a signal from its short-term Fourier transform
 
 function X = synthesis (Y, c)
 
   if (nargin != 2)
     usage ("X = synthesis (Y, c)");
   endif
 
   [nr, nc] = size (c);
   if (nr * nc != 3)
-    error ("synthesis:  c must contain exactly 3 elements");
+    error ("synthesis: c must contain exactly 3 elements");
   endif
 
   ## not necessary, enables better reading
   win = c(1);
   inc = c(2);
   w_type = c(3);
 
   if (w_type == 1)
     H = hanning (win);
   elseif (w_type == 2)
     H = hamming (win);
   elseif (w_type == 3)
     H = ones (win, 1);
   else
-    error ("synthesis:  window_type must be 1, 2, or 3");
+    error ("synthesis: window_type must be 1, 2, or 3");
   endif
 
   Z = real (ifft (Y));
   st = fix ((win-inc) / 2);
   Z = Z(st:st+inc-1, :);
   H = H(st:st+inc-1);
 
   nc = columns(Z);
diff --git a/scripts/signal/triangle_lw.m b/scripts/signal/triangle_lw.m
--- a/scripts/signal/triangle_lw.m
+++ b/scripts/signal/triangle_lw.m
@@ -15,18 +15,18 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} triangle_lw (@var{n}, @var{b})
 ## Triangular lag window. Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Triangular lag window
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Triangular lag window
 
 function retval = triangle_lw (n, b)
 
   retval = 1 - (0 : n-1)' * b;
   retval = max ([retval'; (zeros (1, n))])';
 
 endfunction
 
diff --git a/scripts/signal/triangle_sw.m b/scripts/signal/triangle_sw.m
--- a/scripts/signal/triangle_sw.m
+++ b/scripts/signal/triangle_sw.m
@@ -15,28 +15,28 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} triangle_sw (@var{n}, @var{b})
 ## Triangular spectral window.  Subfunction used for spectral density
 ## estimation.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Triangular spectral window
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Triangular spectral window
 
 function retval = triangle_sw (n, b)
 
   retval = zeros(n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
-  retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2) ).^2;
+  retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2)).^2;
 
 endfunction
 
 
 
 
 
 
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -18,18 +18,18 @@
 ## @deftypefn {Function File} {[@var{a}, @var{v}] =} yulewalker (@var{c})
 ## Fit an AR (p)-model with Yule-Walker estimates given a vector @var{c}
 ## of autocovariances @code{[gamma_0, ..., gamma_p]}.
 ##
 ## Returns the AR coefficients, @var{a}, and the variance of white
 ## noise, @var{v}.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Fit AR model by Yule-Walker method
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Fit AR model by Yule-Walker method
 
 function [a, v] = yulewalker (c)
 
   p = length (c) - 1;
 
   if (columns (c) > 1)
     c = c';
   endif
diff --git a/scripts/statistics/base/cut.m b/scripts/statistics/base/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/statistics/base/cut.m
@@ -33,17 +33,17 @@
 ## Description: Cut data into intervals
 
 function group = cut (X, BREAKS)
 
   if (nargin != 2)
     usage ("cut (X, BREAKS)");
   endif
 
-  if !is_vector (X)
+  if (! is_vector (X))
     error ("cut: X must be a vector");
   endif
   if is_scalar (BREAKS)
     BREAKS = linspace (min (X), max (X), BREAKS + 1);
     BREAKS(1) = BREAKS(1) - 1;
   elseif is_vector (BREAKS)
     BREAKS = sort (BREAKS);
   else
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -41,17 +41,17 @@
 ## Description: Perform a PP-plot (probability plot)
 
 function [p, y] = ppplot (x, dist, ...)
 
   if (nargin < 1)
     usage ("ppplot (x, dist, params)");
   endif
 
-  if !is_vector (x)
+  if (! is_vector (x))
     error ("ppplot: x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   p = ((1 : n)' - 0.5) / n;
   if (nargin == 1)
     F = "stdnormal_cdf";
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -43,17 +43,17 @@
 ## Description: Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, ...)
 
   if (nargin < 1)
     usage ("qqplot (x, dist, params)");
   endif
 
-  if !(is_vector(x))
+  if (! (is_vector(x)))
     error ("qqplot: x must be a vector.");
   endif
 
   s = sort (x);
   n = length (x);
   t = ((1 : n)' - .5) / n;
   if (nargin == 1)
     f = "stdnormal_inv";
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -39,13 +39,13 @@ function y = ranks (x)
   [r, c] = size (x);
   if ((r == 1) && (c > 0))
     p = x' * ones (1, c);
     y = sum (p < p') + (sum (p == p') + 1) / 2;
   elseif (r > 1)
     o = ones (1, r);
     for i = 1 : c;
       p = x (:, i) * o;
-      y = [y, ( sum (p < p') + (sum (p == p') + 1) / 2 )'];
+      y = [y, (sum (p < p') + (sum (p == p') + 1) / 2)'];
     endfor
   endif
 
 endfunction
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -24,25 +24,25 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Cross tabulation
 
 function [t, v, w] = table (x, y)
 
   if (nargin == 1)
-    if !(is_vector (x))
+    if (! (is_vector (x)))
       error ("table: x must be a vector");
     endif
     v = values (x);
     for i = 1 : length (v)
       t(i) = sum (x == v(i) | isnan (v(i)) * isnan (x));
     endfor
   elseif (nargin == 2)
-    if !(is_vector (x) && is_vector (y) && (length (x) == length (y)))
+    if (! (is_vector (x) && is_vector (y) && (length (x) == length (y))))
       error ("table: x and y must be vectors of the same length");
     endif
     v = values (x);
     w = values (y);
     for i = 1 : length (v)
       for j = 1 : length (w)
         t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
                       (y == w(j) | isnan (w(j)) * isnan (y)));
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -24,17 +24,17 @@
 ## Description: Extract unique elements
 
 function v = values (x)
 
   if (nargin != 1)
     usage ("values (x)");
   endif
 
-  if !(is_vector (x))
+  if (! (is_vector (x)))
     error ("values: x must be a vector");
   endif
 
   i = any (isnan (x));
   x = x(find(!isnan (x)));      # HACK!
   n = length (x);
   x = reshape (x, n, 1);
   s = sort (x);
diff --git a/scripts/statistics/distributions/beta_rnd.m b/scripts/statistics/distributions/beta_rnd.m
--- a/scripts/statistics/distributions/beta_rnd.m
+++ b/scripts/statistics/distributions/beta_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Beta distribution
 
 function rnd = beta_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("beta_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("beta_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("beta_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/binomial_rnd.m b/scripts/statistics/distributions/binomial_rnd.m
--- a/scripts/statistics/distributions/binomial_rnd.m
+++ b/scripts/statistics/distributions/binomial_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binomial_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("binomial_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("binomial_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error ("binomial_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (l, scale, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("cauchy_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("cauchy_rnd: c must be a positive integer");
     endif
     [retval, l, scale] = common_size (l, scale, zeros (r, c));
     if (retval > 0)
       error ("cauchy_rnd: lambda and sigma must be scalar or of size %d by %d",
 	     r, c); 
     endif
   elseif (nargin == 2)
diff --git a/scripts/statistics/distributions/chisquare_rnd.m b/scripts/statistics/distributions/chisquare_rnd.m
--- a/scripts/statistics/distributions/chisquare_rnd.m
+++ b/scripts/statistics/distributions/chisquare_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the chi-square distribution
 
 function rnd = chisquare_rnd (n, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("chisquare_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("chisquare_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error ("chisquare_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("chisquare_rnd (n, r, c)");
diff --git a/scripts/statistics/distributions/exponential_rnd.m b/scripts/statistics/distributions/exponential_rnd.m
--- a/scripts/statistics/distributions/exponential_rnd.m
+++ b/scripts/statistics/distributions/exponential_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the exponential distribution
 
 function rnd = exponential_rnd (l, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("exponential_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("exponential_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error ("exponential_rnd: lambda must be scalar or of size %d by %d",
 	     r, c);
     endif
   elseif (nargin != 1)
diff --git a/scripts/statistics/distributions/f_rnd.m b/scripts/statistics/distributions/f_rnd.m
--- a/scripts/statistics/distributions/f_rnd.m
+++ b/scripts/statistics/distributions/f_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the F distribution
 
 function rnd = f_rnd (m, n, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("f_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("f_rnd: c must be a positive integer");
     endif
     [retval, m, n] = common_size (m, n, zeros (r, c));
     if (retval > 0)
       error ("f_rnd: m and n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, n] = common_size (m, n);
diff --git a/scripts/statistics/distributions/gamma_rnd.m b/scripts/statistics/distributions/gamma_rnd.m
--- a/scripts/statistics/distributions/gamma_rnd.m
+++ b/scripts/statistics/distributions/gamma_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamma_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("gamma_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("gamma_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("gamma_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/geometric_rnd.m b/scripts/statistics/distributions/geometric_rnd.m
--- a/scripts/statistics/distributions/geometric_rnd.m
+++ b/scripts/statistics/distributions/geometric_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 function rnd = geometric_rnd (p, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("geometric_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("geometric_rnd: c must be a positive integer");
     endif
     [retval, p] = common_size (p, zeros (r, c));
     if (retval > 0)
       error ("geometric_rnd: p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("geometric_rnd (p, r, c)");
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -44,35 +44,35 @@ function cdf = kolmogorov_smirnov_cdf (x
 
   if (nargin < 1 || nargin > 2)
     usage ("kolmogorov_smirnov_cdf (x, tol)");
   endif
 
   if (nargin == 1)
     tol = eps;
   else
-    if (!is_scalar (tol) || !(tol > 0))
+    if (! is_scalar (tol) || ! (tol > 0))
       error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
     endif
   endif
 
-  [nr, nc] = size(x);
+  [nr, nc] = size (x);
   if (min (nr, nc) == 0)
     error ("kolmogorov_smirnov_cdf: x must not be empty");
   endif
 
   n   = nr * nc;
   x   = reshape (x, 1, n);
   cdf = zeros (1, n);
   ind = find (x > 0);
   if (length (ind) > 0)
     y   = x(ind);
-    K   = ceil( sqrt( - log (tol) / 2 ) / min (y) );
+    K   = ceil (sqrt (- log (tol) / 2) / min (y));
     k   = (1:K)';
-    A   = exp( - 2 * k.^2 * y.^2 );
+    A   = exp (- 2 * k.^2 * y.^2);
     odd = find (rem (k, 2) == 1);
-    A(odd, :) = -A(odd, :);
+    A(odd,:) = -A(odd,:);
     cdf(ind) = 1 + 2 * sum (A);
   endif
 
   cdf = reshape (cdf, nr, nc);
 
 endfunction
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -24,20 +24,20 @@
 ## Description: Random deviates from the Laplace distribution
 
 function rnd = laplace_rnd (r, c)
 
   if (nargin != 2)
     usage ("laplace_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
     error ("laplace_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
     error ("laplace_rnd: c must be a positive integer");
   endif
 
   tmp = rand (r, c);
   rnd = ((tmp < 1/2) .* log (2 * tmp)
          - (tmp > 1/2) .* log (2 * (1 - tmp)));
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -24,18 +24,18 @@
 ## Description: Random deviates from the logistic distribution
 
 function rnd = logistic_rnd (r, c)
 
   if (nargin != 2)
     usage ("logistic_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
     error ("logistic_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
     error ("logistic_rnd: c must be a positive integer");
   endif
 
   rnd = - log (1 ./ rand (r, c) - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/lognormal_rnd.m b/scripts/statistics/distributions/lognormal_rnd.m
--- a/scripts/statistics/distributions/lognormal_rnd.m
+++ b/scripts/statistics/distributions/lognormal_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognormal_rnd (a, v, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("lognormal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("lognormal_rnd: c must be a positive integer");
     endif
     [retval, a, v] = common_size (a, v, zeros (r, c));
     if (retval > 0)
       error ("lognormal_rnd: a and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, v] = common_size (a, v);
diff --git a/scripts/statistics/distributions/normal_rnd.m b/scripts/statistics/distributions/normal_rnd.m
--- a/scripts/statistics/distributions/normal_rnd.m
+++ b/scripts/statistics/distributions/normal_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the normal distribution
 
 function rnd = normal_rnd (m, v, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("normal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("normal_rnd: c must be a positive integer");
     endif
     [retval, m, v] = common_size (m, v, zeros (r, c));
     if (retval > 0)
       error ("normal_rnd: m and v must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, m, v] = common_size (m, v);
diff --git a/scripts/statistics/distributions/pascal_rnd.m b/scripts/statistics/distributions/pascal_rnd.m
--- a/scripts/statistics/distributions/pascal_rnd.m
+++ b/scripts/statistics/distributions/pascal_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = pascal_rnd (n, p, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("pascal_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("pascal_rnd: c must be a positive integer");
     endif
     [retval, n, p] = common_size (n, p, zeros (r, c));
     if (retval > 0)
       error ("pascal_rnd: n and p must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, n, p] = common_size (n, p);
diff --git a/scripts/statistics/distributions/poisson_rnd.m b/scripts/statistics/distributions/poisson_rnd.m
--- a/scripts/statistics/distributions/poisson_rnd.m
+++ b/scripts/statistics/distributions/poisson_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Poisson distribution
 
 function rnd = poisson_rnd (l, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("poisson_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("poisson_rnd: c must be a positive integer");
     endif
     [retval, l] = common_size (l, zeros (r, c));
     if (retval > 0)
       error ("poisson_rnd: lambda must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("poisson_rnd (lambda, r, c)");
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -29,15 +29,15 @@ function cdf = stdnormal_cdf (x)
     usage ("stdnormal_cdf (x)");
   endif
 
   [r_x, c_x] = size (x);
   if (r_x * c_x == 0)
     error ("stdnormal_cdf: x must not be empty.");
   endif
 
-  cdf = ( ones (r_x, c_x) + erf (x / sqrt(2)) ) / 2;
+  cdf = (ones (r_x, c_x) + erf (x / sqrt (2))) / 2;
 
 endfunction
 
 
 
 
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -36,14 +36,14 @@ function pdf = stdnormal_pdf (x)
 
   k = find (isnan (x));
   if (any (k))
     pdf(k) = NaN * ones (1, length (k));
   endif
 
   k = find (!isinf (x));
   if (any (k))
-    pdf (k) = (2 * pi)^(- 1/2) * exp( - x(k) .^ 2 / 2);
+    pdf (k) = (2 * pi)^(- 1/2) * exp (- x(k) .^ 2 / 2);
   endif
 
   pdf = reshape (pdf, r, c);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -24,18 +24,18 @@
 ## Description: Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
 
   if (nargin != 2)
     usage ("stdnormal_rnd (r, c)");
   endif
 
-  if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+  if (! (is_scalar (r) && (r > 0) && (r == round (r))))
     error ("stdnormal_rnd: r must be a positive integer");
   endif
-  if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+  if (! (is_scalar (c) && (c > 0) && (c == round (c))))
     error ("stdnormal_rnd: c must be a positive integer");
   endif
 
   rnd = randn (r, c);
 
 endfunction
diff --git a/scripts/statistics/distributions/t_rnd.m b/scripts/statistics/distributions/t_rnd.m
--- a/scripts/statistics/distributions/t_rnd.m
+++ b/scripts/statistics/distributions/t_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the t distribution
 
 function rnd = t_rnd (n, r, c)
 
   if (nargin == 3)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("t_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("t_rnd: c must be a positive integer");
     endif
     [retval, n] = common_size (n, zeros (r, c));
     if (retval > 0)
       error ("t_rnd: n must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin != 1)
     usage ("t_rnd (n, r, c)");
diff --git a/scripts/statistics/distributions/uniform_rnd.m b/scripts/statistics/distributions/uniform_rnd.m
--- a/scripts/statistics/distributions/uniform_rnd.m
+++ b/scripts/statistics/distributions/uniform_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the uniform distribution
 
 function rnd = uniform_rnd (a, b, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("uniform_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("uniform_rnd: c must be a positive integer");
     endif
     [retval, a, b] = common_size (a, b, zeros (r, c));
     if (retval > 0)
       error ("uniform_rnd: a and b must be scalar or of size %d by %d", r, c);
     endif
   elseif (nargin == 2)
     [retval, a, b] = common_size (a, b);
diff --git a/scripts/statistics/distributions/weibull_rnd.m b/scripts/statistics/distributions/weibull_rnd.m
--- a/scripts/statistics/distributions/weibull_rnd.m
+++ b/scripts/statistics/distributions/weibull_rnd.m
@@ -25,20 +25,20 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = weibull_rnd (shape, scale, r, c)
 
   if (nargin == 4)
-    if (! (is_scalar (r) && (r > 0) && (r == round (r))) )
+    if (! (is_scalar (r) && (r > 0) && (r == round (r))))
       error ("weibull_rnd: r must be a positive integer");
     endif
-    if (! (is_scalar (c) && (c > 0) && (c == round (c))) )
+    if (! (is_scalar (c) && (c > 0) && (c == round (c))))
       error ("weibull_rnd: c must be a positive integer");
     endif
     [retval, shape, scale] = common_size (shape, scale, zeros (r, c));
     if (retval > 0)
       error ("weibull_rnd: alpha and sigma must be scalar or of size %d by %d",
 	     r, c);
     endif
   elseif (nargin == 2)
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -40,17 +40,17 @@ function [pval, chisq, df] = chisquare_t
     usage ("[pval, chisq, df] = chisquare_test_homogeneity (x, y, c)");
   endif
 
   if (! (is_vector(x) && is_vector(y) && is_vector(c)))
     error ("chisquare_test_homogeneity: x, y and c must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
-  if (any ( (c(2 : df) - c(1 : (df - 1))) <= 0))
+  if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
     error ("chisquare_test_homogeneity: c must be increasing");
   endif
 
   c     = [(reshape (c, 1, df)), Inf];
   l_x   = length (x);
   x     = reshape (x, l_x, 1);
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -65,23 +65,23 @@ function t = cor_test (X, Y, ALTERNATIVE
   endif
 
   if (!is_vector (X) || !is_vector (Y) || length (X) != length (Y))
     error ("cor_test: X and Y must be vectors of the same length")
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
-  elseif !isstr (ALTERNATIVE)
+  elseif (! isstr (ALTERNATIVE))
     error ("cor_test: ALTERNATIVE must be a string");
   endif
 
   if (nargin < 4)
     METHOD = "pearson";
-  elseif !isstr (METHOD)
+  elseif (! isstr (METHOD))
     error ("cor_test: METHOD must be a string");
   endif
 
   n = length (X);
   m = METHOD (1);
 
   if (m == "p")
     r = cor (X, Y);
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -35,43 +35,41 @@
 
 function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
 
   if (nargin < 3 || nargin > 4)
     usage ("[pval, f, df_num, df_den] = f_test_regression (y, X, R, r)");
   endif
 
   [T, k] = size (X);
-  if !( is_vector (y) && (length (y) == T) )
+  if (! (is_vector (y) && (length (y) == T)))
     error ("f_test_regression: y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
   [q, c_R ] = size (R);
   if (c_R != k)
-    error (["f_test_regression: ", ...
-            "R must have as many columns as X."]);
+    error ("f_test_regression: R must have as many columns as X");
   endif
 
   if (nargin == 4)
     s_r = size (r);
     if ((min (s_r) != 1) || (max (s_r) != q))
-      error (["f_test_regression: ", ...
-              "r must be a vector of length rows (R)."]);
+      error ("f_test_regression: r must be a vector of length rows (R)");
     endif
     r = reshape (r, q, 1);
   else
     r = zeros (q, 1);
   endif
 
   df_num = q;
   df_den = T - k;
 
   [b, v] = ols (y, X);
   diff   = R * b - r;
-  f      = diff' * inv (R * inv (X' * X) * R') * diff / ( q * v );
+  f      = diff' * inv (R * inv (X' * X) * R') * diff / (q * v);
   pval  = 1 - f_cdf (f, df_num, df_den);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -29,19 +29,20 @@
 ## kolmogorov_smirnov_test(x, "uniform", 2, 4)
 ## @end example
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative F
 ## != G.  In this case, the test statistic @var{ks} follows a two-sided
 ## Kolmogorov-Smirnov distribution.  If @var{alt} is @code{">"}, the
-## one-sided alternative F > G is considered, similarly for @code{"<"}.
-## In this case, the test statistic @var{ks} has a one-sided
-## Kolmogorov-Smirnov distribution.  The default is the two-sided case.
+## one-sided alternative F > G is considered.  Similarly for @code{"<"},
+## the one-sided alternative F > G is considered.  In this case, the
+## test statistic @var{ks} has a one-sided Kolmogorov-Smirnov
+## distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: One-sample Kolmogorov-Smirnov test
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -22,35 +22,36 @@
 ## @var{x} and @var{y} samples, respectively, then the null is that F ==
 ## G.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative F
 ## != G.  In this case, the test statistic @var{ks} follows a two-sided
 ## Kolmogorov-Smirnov distribution.  If @var{alt} is @code{">"}, the
-## one-sided alternative F > G is considered, similarly for @code{"<"}.
-## In this case, the test statistic @var{ks} has a one-sided
-## Kolmogorov-Smirnov distribution.  The default is the two-sided case.
+## one-sided alternative F > G is considered.  Similarly for @code{"<"},
+## the one-sided alternative F < G is considered.  In this case, the
+## test statistic @var{ks} has a one-sided Kolmogorov-Smirnov
+## distribution.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Two-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
     usage ("[pval, ks] = kolmogorov_smirnov_test_2 (x, y, tol)");
   endif
 
-  if !( is_vector (x) && is_vector (y))
+  if (! (is_vector (x) && is_vector (y)))
     error ("kolmogorov_smirnov_test_2: both x and y must be vectors.");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
     if (! isstr (alt))
       error ("kolmogorov_smirnov_test_2: alt must be a string.");
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -21,17 +21,18 @@
 ## null hypothesis that the success probabilities @var{p1} and @var{p2}
 ## are the same.  Under the null, the test statistic @var{z}
 ## approximately follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @var{p1} != @var{p2}.  If @var{alt} is @code{">"}, the one-sided
-## alternative @var{p1} > @var{p2} is used, similarly for @code{"<"}.
+## alternative @var{p1} > @var{p2} is used.  Similarly for @code{"<"},
+## the one-sided alternative @var{p1} < @var{p2} is used.
 ## The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
@@ -52,17 +53,17 @@ function [pval, z] = prop_test_2 (x1, n1
   z   = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt  = "!=";
   endif
 
-  if !isstr (alt)
+  if (! isstr (alt))
     error ("prop_test_2: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -22,18 +22,20 @@
 ## follows a binomial distribution with parameters @code{@var{n} = sum
 ## (@var{x} != @var{y})} and @var{p} = 1/2.
 ##
 ## With the optional argument @code{alt}, the alternative of interest
 ## can be selected.  If @var{alt} is @code{"!="} or @code{"<>"}, the
 ## null hypothesis is tested against the two-sided alternative PROB
 ## (@var{x} < @var{y}) != 1/2.  If @var{alt} is @code{">"}, the
 ## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 ("x is
-## stochastically greater than y") is considered, similarly for @code{"<"}.
-## The default is the two-sided case.
+## stochastically greater than y") is considered.  Similarly for
+## @code{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) < 1/2
+## ("x is stochastically less than y") is considered.  The default is
+## the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Sign test
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -21,18 +21,20 @@
 ## (@var{x}) == @var{m}}.  Under the null, the test statistic @var{t}
 ## follows a Student distribution with @code{@var{df} = length (@var{x})
 ## - 1} degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
-## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered,
-## similarly for @var{"<"}.  The default is the two-sided case.
+## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
+## Similarly for @var{"<"}, the one-sided alternative @code{mean
+## (@var{x}) < @var{m}} is considered,  The default is the two-sided
+## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Student's one-sample t test
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -22,17 +22,19 @@
 ## @var{t} follows a Student distribution with @var{df} degrees of
 ## freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != mean (@var{y})}.  If @var{alt} is @code{">"},
 ## the one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is
-## used.  Similarly for @code{"<"}.  The default is the two-sided case.
+## used.  Similarly for @code{"<"}, the one-sided alternative @code{mean
+## (@var{x}) < mean (@var{y})} is used.  The default is the two-sided
+## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Student's two-sample t test
@@ -48,17 +50,17 @@ function [pval, t, df] = t_test_2 (x, y,
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   df   = n_x + n_y - 2;
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v    = sumsq (x - mu_x) + sumsq (y - mu_y);
-  t    = (mu_x - mu_y) * sqrt ( (n_x * n_y * df) / (v * (n_x + n_y)) );
+  t    = (mu_x - mu_y) * sqrt ((n_x * n_y * df) / (v * (n_x + n_y)));
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! isstr (alt))
     error ("t_test_2: alt must be a string");
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -23,17 +23,18 @@
 ##
 ## If @var{r} is omitted, a value of 0 is assumed.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{@var{R} * @var{b} != @var{r}}.  If @var{alt} is @code{">"}, the
 ## one-sided alternative @code{@var{R} * @var{b} > @var{r}} is used.
-## Similarly for @var{"<"}.  The default is the two-sided case.
+## Similarly for @var{"<"}, the one-sided alternative @code{@var{R} *
+## @var{b} < @var{r}} is used.  The default is the two-sided case. 
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Test one linear hypothesis in linear regression model
@@ -45,32 +46,32 @@ function [pval, t, df] = t_test_regressi
     alt = "!=";
   elseif (nargin == 4)
     if (isstr (r))
       alt = r;
       r   = 0;
     else
       alt = "!=";
     endif
-  elseif !(nargin == 5)
+  elseif (! (nargin == 5))
     usage ("[pval, t, df] = t_test_regression (y, X, R, r, alt)");
   endif
 
   if (! is_scalar (r))
     error ("t_test_regression: r must be a scalar");
   elseif (! isstr (alt))
     error ("t_test_regression: alt must be a string");
   endif
 
   [T, k] = size (X);
-  if !(is_vector (y) && (length (y) == T))
+  if (! (is_vector (y) && (length (y) == T)))
     error ("t_test_regression: y must be a vector of length rows (X)");
   endif
   s      = size (R);
-  if !((max (s) == k) && (min (s) == 1))
+  if (! ((max (s) == k) && (min (s) == 1)))
     error ("t_test_regression: R must be a vector of length columns (X)");
   endif
 
   R      = reshape (R, 1, k);
   y      = reshape (y, T, 1);
   [b, v] = ols (y, X);
   df     = T - k;
   t      = (R * b - r) / sqrt (v * R * inv (X' * X) * R');
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -21,18 +21,19 @@
 ## < @var{y}).  Under the null, the test statistic @var{z} approximately
 ## follows a standard normal distribution.  Note that this test is
 ## equivalent to the Wilcoxon rank-sum test.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## PROB (@var{x} > @var{y}) != 1/2.  If @var{alt} is @code{">"}, the
-## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 is considered,
-## similarly for @code{"<"}.  The default is the two-sided case.
+## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 is considered.
+## Similarly for @code{"<"}, the one-sided alternative PROB (@var{x} >
+## @var{y}) < 1/2 is considered,  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## This implementation is still incomplete---for small sample sizes,
 ## the normal approximation is rather bad ...
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -21,17 +21,19 @@
 ## hypothesis of equal variances.  Under the null, the test statistic f
 ## follows an F-distribution with df_num and df_den degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{var (@var{x}) != var (@var{y})}.  If @var{alt} is @code{">"},
 ## the one-sided alternative @code{var (@var{x}) > var (@var{y})} is
-## used, similarly for "<".  The default is the two-sided case.
+## used.  Similarly for "<", the one-sided alternative @code{var
+## (@var{x}) > var (@var{y})} is used.  The default is the two-sided
+## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: F test to compare two variances
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -21,18 +21,19 @@
 ## perform a Welch test of the null hypothesis of equal means.
 ## Under the null, the test statistic t approximately follows a Student
 ## distribution with df degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
-## one-sided alternative mean(x) > m is considered, similarly for
-## @code{"<"}.  The default is the two-sided case.
+## one-sided alternative mean(x) > @var{m} is considered.  Similarly for
+## @code{"<"}, the one-sided alternative mean(x) < @var{m} is
+## considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Welch two-sample t test
@@ -49,17 +50,17 @@ function [pval, t, df] = welch_test (x, 
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
   v_y  = sumsq (x - mu_y) / (n_y * (n_y - 1));
   c    = v_x / (v_x + v_y);
-  df   = 1 / ( c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
+  df   = 1 / (c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! isstr (alt))
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -20,18 +20,19 @@
 ## Wilcoxon signed-rank test of the null hypothesis PROB (@var{x} >
 ## @var{y}) == 1/2.  Under the null, the test statistic @var{z}
 ## approximately follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## PROB (@var{x} > @var{y}) != 1/2.  If alt is @code{">"}, the one-sided
-## alternative PROB (@var{x} > @var{y}) > 1/2 is considered, similarly
-## for @code{"<"}.  The default is the two-sided case.
+## alternative PROB (@var{x} > @var{y}) > 1/2 is considered.  Similarly
+## for @code{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) <
+## 1/2 is considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: Wilcoxon signed-rank test
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -20,18 +20,20 @@
 ## @var{m}} for a sample @var{x} from a normal distribution with unknown
 ## mean and known variance @var{v}.  Under the null, the test statistic
 ## @var{z} follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
-## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered,
-## similarly for @code{"<"}.  The default is the two-sided case.
+## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
+## Similarly for @code{"<"}, the one-sided alternative @code{mean
+## (@var{x}) < @var{m}} is considered.  The default is the two-sided
+## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -20,18 +20,20 @@
 ## unknown means and known variances @var{v_x} and @var{v_y}, perform a
 ## Z-test of the hypothesis of equal means.  Under the null, the test
 ## statistic @var{z} follows a standard normal distribution.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != mean (@var{y})}.  If alt is @code{">"}, the
-## one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is used,
-## similarly for @code{"<"}.  The default is the two-sided case.
+## one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is used.
+## Similarly for @code{"<"}, the one-sided alternative @code{mean
+## (@var{x}) < mean (@var{y})} is used.  The default is the two-sided
+## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed
 ## along with some information.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
diff --git a/scripts/strings/com2str.m b/scripts/strings/com2str.m
--- a/scripts/strings/com2str.m
+++ b/scripts/strings/com2str.m
@@ -12,71 +12,71 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{retval} =} com2str(@var{zz}[,@var{flg}])
+## @deftypefn {Function File} {@var{retval} =} com2str(@var{zz}, @var{flg})
 ##
 ## convert complex number to a string
 ## @strong{Inputs}
 ## @table @var
 ## @item zz
 ## complex number
 ## @item flg
 ## format flag
 ## 0 (default):            -1, 0, 1,   1i,   1 + 0.5i
 ## 1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 ## @end table
 ## @end deftypefn
 
 function retval = com2str (zz, flg)
 
-  if (nargin < 1 | nargin > 2)
-    usage("com2str(zz{,flg})");
+  if (nargin < 1 || nargin > 2)
+    usage ("com2str (zz, flg)");
   endif
-  if(nargin == 1)
+  if (nargin == 1)
     flg = 0;
   endif
 
-  if( !(is_scalar(zz) & is_scalar(flg) ) )
+  if (! (is_scalar (zz) && is_scalar (flg)))
     error("com2str: arguments must be a scalar.");
   endif
 
-  if(flg != 0 & flg != 1)
-    error(["invalid flg value: ",num2str(flg)]);
+  if (flg != 0 && flg != 1)
+    error ("invalid flg value: %d", flg);
   endif
 
   sgns = "+-";
-  rz = real(zz);
-  iz = imag(zz);
-  az = abs(zz);
-  if(iz == 0)
+  rz = real (zz);
+  iz = imag (zz);
+  az = abs (zz);
+  if (iz == 0)
     ## strictly a real number
-    switch(flg)
-    case(0)
-      retval = num2str(rz);
-    case(1)
-      retval = [ sgns(1+(rz< 0))," ", num2str(abs(rz))];
+    switch (flg)
+      case(0)
+	retval = num2str (rz);
+      case(1)
+	retval = [sgns(1+(rz<0)), " ", num2str(abs(rz))];
     endswitch
-  elseif(rz == 0)
+  elseif (rz == 0)
     ## strictly an imaginary number
-    switch(flg)
-    case(0)
-      retval = num2str(iz);
-    case(1)
-      retval = [ sgns(1+(iz< 0))," ", num2str(abs(iz)),"i"];
+    switch (flg)
+      case(0)
+	retval = num2str (iz);
+      case(1)
+	retval = [sgns(1+(iz<0)), " ", num2str(abs(iz)), "i"];
     endswitch
   else
     ## complex number
     ## strictly an imaginary number
-    switch(flg)
-    case(0)
-      retval = [num2str(rz)," ",com2str(i*iz,1)];
-    case(1)
-      retval = [ sgns(1+(rz< 0))," ", num2str(abs(rz))," ",com2str(i*iz,1)];
+    switch (flg)
+      case(0)
+	retval = [num2str(rz), " ", com2str(i*iz,1)];
+      case(1)
+	retval = [sgns(1+(rz<0)), " ", num2str(abs(rz)), " ", com2str(i*iz,1)];
     endswitch
   endif
 
 endfunction
