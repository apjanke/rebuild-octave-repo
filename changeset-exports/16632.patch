# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1368039465 14400
#      Wed May 08 14:57:45 2013 -0400
# Node ID ace0f60672ec94cacaa567162627a4fbc0a92767
# Parent  c979e6db619bd2c101d845377dc1400f6dac214a
# Parent  cbaf19edc4eeb379a6ba34d0f601beddbfd3e09a
Merge in Adam's changes

diff --git a/libgui/qterminal/libqterminal/QTerminal.cc b/libgui/qterminal/libqterminal/QTerminal.cc
--- a/libgui/qterminal/libqterminal/QTerminal.cc
+++ b/libgui/qterminal/libqterminal/QTerminal.cc
@@ -36,9 +36,38 @@ QTerminal::notice_settings (const QSetti
   QString cursorType = settings->value ("terminal/cursorType","ibeam").toString ();
   bool cursorBlinking = settings->value ("terminal/cursorBlinking",true).toBool ();
   if (cursorType == "ibeam")
     setCursorType(QTerminalInterface::IBeamCursor, cursorBlinking);
   else if (cursorType == "block")
     setCursorType(QTerminalInterface::BlockCursor, cursorBlinking);
   else if (cursorType == "underline")
     setCursorType(QTerminalInterface::UnderlineCursor, cursorBlinking);
+
+  bool cursorUseForegroundColor
+    = settings->value ("terminal/cursorUseForegroundColor",true).toBool ();
+
+  // FIXME -- we shouldn't duplicate this information here and in the
+  // resource manager.
+  QList<QColor> default_colors;
+
+  default_colors << QColor(0,0,0)
+                 << QColor(255,255,255)
+                 << QColor(192,192,192)
+                 << QColor(128,128,128);
+
+  setForegroundColor
+    (settings->value ("terminal/color_f",
+                      QVariant (default_colors.at (0))).value<QColor> ());
+
+  setBackgroundColor
+    (settings->value ("terminal/color_b",
+                      QVariant (default_colors.at (1))).value<QColor> ());
+
+  setSelectionColor
+    (settings->value ("terminal/color_s",
+                      QVariant (default_colors.at (2))).value<QColor> ());
+
+  setCursorColor
+    (cursorUseForegroundColor,
+     settings->value ("terminal/color_c",
+                      QVariant (default_colors.at (3))).value<QColor> ());
 }
diff --git a/libgui/qterminal/libqterminal/QTerminalInterface.h b/libgui/qterminal/libqterminal/QTerminalInterface.h
--- a/libgui/qterminal/libqterminal/QTerminalInterface.h
+++ b/libgui/qterminal/libqterminal/QTerminalInterface.h
@@ -19,16 +19,17 @@ You should have received a copy of the G
 along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
 #ifndef QTERMINALINTERFACE_H
 #define QTERMINALINTERFACE_H
 
 #include <QWidget>
+#include <QColor>
 #include <QMenu>
 
 class QTerminalInterface : public QWidget
 {
     Q_OBJECT
 public:
     QTerminalInterface(QWidget *xparent = 0) : QWidget(xparent) {
       connect (this, SIGNAL(customContextMenuRequested(QPoint)),
@@ -56,17 +57,23 @@ public:
     };
 
     virtual void setCursorType(CursorType type, bool blinking) {
         // Provide empty default impl in order to avoid conflicts with the win impl.
         Q_UNUSED(type);
         Q_UNUSED(blinking);
     }
 
-public slots:
+    virtual void setBackgroundColor (const QColor& color) = 0;
+    virtual void setForegroundColor (const QColor& color) = 0;
+    virtual void setSelectionColor (const QColor& color) = 0;
+    virtual void setCursorColor (bool useForegroundColor,
+                                 const QColor& color) = 0;
+
+ public slots:
     virtual void copyClipboard() = 0;
     virtual void pasteClipboard() = 0;
 
     virtual void handleCustomContextMenuRequested(QPoint at) {
       _contextMenu->move (mapToGlobal(at));
       _contextMenu->show ();
     }
 
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -130,16 +130,28 @@ void QUnixTerminalImpl::setCursorType(Cu
     switch(type) {
         case UnderlineCursor: m_terminalView->setKeyboardCursorShape(TerminalView::UnderlineCursor); break;
         case BlockCursor: m_terminalView->setKeyboardCursorShape(TerminalView::BlockCursor); break;
         case IBeamCursor: m_terminalView->setKeyboardCursorShape(TerminalView::IBeamCursor); break;
     }
     m_terminalView->setBlinkingCursor(blinking);
 }
 
+// FIXME -- not sure how to make these work properly given the way the
+// Unix terminal handles colors.
+void QUnixTerminalImpl::setBackgroundColor (const QColor& color) { }
+void QUnixTerminalImpl::setForegroundColor (const QColor& color) { }
+void QUnixTerminalImpl::setSelectionColor (const QColor& color) { }
+
+void QUnixTerminalImpl::setCursorColor (bool useForegroundColor,
+                                        const QColor& color)
+{
+  m_terminalView->setKeyboardCursorColor (useForegroundColor, color);
+}
+
 void QUnixTerminalImpl::showEvent(QShowEvent *)
 {
     m_terminalView->updateImage();
     m_terminalView->repaint();
     m_terminalView->update();
 }
 
 void QUnixTerminalImpl::resizeEvent(QResizeEvent*)
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
@@ -38,16 +38,21 @@ public:
     virtual ~QUnixTerminalImpl();
 
     void setTerminalFont(const QFont &font); 
     void setSize(int h, int v);
     void sendText(const QString& text);
 
     void setCursorType(CursorType type, bool blinking);
 
+    void setBackgroundColor (const QColor& color);
+    void setForegroundColor (const QColor& color);
+    void setSelectionColor (const QColor& color);
+    void setCursorColor (bool useForegroundColor, const QColor& color);
+
 public slots:
     void copyClipboard();
     void pasteClipboard();
 
 protected:
     void showEvent(QShowEvent *);
     virtual void resizeEvent(QResizeEvent *);   
 
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -15,35 +15,40 @@ MERCHANTABILITY or FITNESS FOR A PARTICU
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 
 #include <QApplication>
+#include <QClipboard>
 #include <QColor>
 #include <QFont>
 #include <QHBoxLayout>
 #include <QPaintEvent>
 #include <QPainter>
 #include <QResizeEvent>
 #include <QScrollBar>
 #include <QtDebug>
 #include <QThread>
 #include <QTimer>
+#include <QToolTip>
+#include <QCursor>
+#include <QMessageBox>
 
 #include <fcntl.h>
 #include <io.h>
 #include <stdio.h>
 #include <stdarg.h>
 #define WIN32_LEAN_AND_MEAN
 #define _WIN32_WINNT 0x0500 
 #include <windows.h>
 #include <cstring>
+#include <limits>
 
 #include "QWinTerminalImpl.h"
 #include "QTerminalColors.h"
 
 // Uncomment to log activity to LOGFILENAME
 // #define DEBUG_QCONSOLE
 #define LOGFILENAME "QConsole.log"
 // Uncomment to create hidden console window
@@ -114,57 +119,95 @@ public:
   QRect cursorRect (void);
 
   void log (const char* fmt, ...);
 
   void closeStandardIO (int fd, DWORD stdHandleId, const char* name);
   void setupStandardIO (DWORD stdHandleId, int fd, const char* name,
                         const char* devName);
 
+  QPoint posToCell (const QPoint& pt);
+  QString getSelection (void);
+  void updateSelection (void);
+  void clearSelection (void);
+
+  QColor backgroundColor (void) const;
+  QColor foregroundColor (void) const;
+  QColor selectionColor (void) const;
+  QColor cursorColor (void) const;
+
+  void setBackgroundColor (const QColor& color);
+  void setForegroundColor (const QColor& color);
+  void setSelectionColor (const QColor& color);
+  void setCursorColor (bool useForegroundColor, const QColor& color);
+
+  void drawTextBackground (QPainter& p, int cx1, int cy1, int cx2, int cy2,
+                           int cw, int ch);
+
+  void drawSelection (QPainter& p, int cx1, int cy1, int cx2, int cy2,
+                      int cw, int ch);
+
+  void drawCursor (QPainter& p);
+
+  void drawText (QPainter& p, int cx1, int cy1, int cx2, int cy2,
+                 int cw, int ch);
+
 private:
   QWinTerminalImpl* q;
 
 private:
   QFont m_font;
-  QColor m_backgroundColor;
-  QColor m_foregroundColor;
   QString m_command;
   QConsoleColors m_colors;
   bool m_inWheelEvent;
   QString m_title;
 
   QSize m_charSize;
   QSize m_bufferSize;
   QRect m_consoleRect;
   QPoint m_cursorPos;
   bool m_cursorBlinking;
   bool m_hasBlinkingCursor;
   QTimer *m_blinkCursorTimer;
   KeyboardCursorType m_cursorType;
 
+  QPoint m_beginSelection;
+  QPoint m_endSelection;
+
+  QColor m_selectionColor;
+  QColor m_cursorColor;
+
   HANDLE m_stdOut;
   HWND m_consoleWindow;
   CHAR_INFO* m_buffer;
   CHAR_INFO* m_tmpBuffer;
   HANDLE m_process;
 
   QConsoleView* m_consoleView;
   QScrollBar* m_scrollBar;
   QTimer* m_consoleWatcher;
   QConsoleThread *m_consoleThread;
 
   // The delay in milliseconds between redrawing blinking text.
   static const int BLINK_DELAY = 500;
 };
 
+static void maybeSwapPoints (QPoint& begin, QPoint& end)
+{
+  if (end.y () < begin.y ()
+      || (end.y () == begin.y () && end.x () < begin.x ()))
+    qSwap (begin, end);
+}
+
 //////////////////////////////////////////////////////////////////////////////
 
 QConsolePrivate::QConsolePrivate (QWinTerminalImpl* parent, const QString& cmd)
   : q (parent), m_command (cmd), m_hasBlinkingCursor (true),
-    m_cursorType (BlockCursor), m_process (NULL), m_inWheelEvent (false)
+    m_cursorType (BlockCursor), m_beginSelection (0, 0),
+    m_endSelection (0, 0), m_process (NULL), m_inWheelEvent (false)
 {
   log (NULL);
 
   // Possibly detach from any existing console
   log ("Detaching from existing console (if any)...\n");
   FreeConsole ();
   log ("Closing standard IO...\n");
   closeStandardIO (0, STD_INPUT_HANDLE, "STDIN");
@@ -237,37 +280,51 @@ QConsolePrivate::QConsolePrivate (QWinTe
        m_consoleRect.left (), m_consoleRect.top (),
        m_consoleRect.right (), m_consoleRect.bottom (),
        m_consoleRect.width (), m_consoleRect.height ());
 
   wchar_t titleBuf[260];
   GetConsoleTitleW (titleBuf, sizeof (titleBuf));
   q->setWindowTitle (QString::fromWCharArray (titleBuf));
 
-  m_backgroundColor = Qt::white;
-  m_foregroundColor = Qt::black;
-  SetConsoleTextAttribute (m_stdOut, 0xF0);
-
   m_font.setFamily ("Lucida Console");
   m_font.setPointSize (9);
   m_font.setStyleHint (QFont::TypeWriter);
 
   m_buffer = m_tmpBuffer = 0;
 
   m_consoleView = new QConsoleView (parent);
   m_scrollBar = new QScrollBar (Qt::Vertical, parent);
 
   QHBoxLayout* l = new QHBoxLayout (parent);
   l->setContentsMargins (0, 0, 0, 0);
   l->setSpacing (0);
   l->addWidget (m_consoleView, 1);
   l->addWidget (m_scrollBar, 0);
 
-  m_consoleView->setPalette (QPalette (m_backgroundColor));
+  // Choose 15 (0xF) as index into the Windows console color map for the
+  // background and 0 (0x0) as the index for the foreground.  This
+  // selection corresponds to the indices used in the foregroundColor,
+  // setForegroundColor, backgroundColor, and SetBackgroundColor
+  // functions.
+
+  SetConsoleTextAttribute (m_stdOut, 0xF0);
+
+  // Defaults.
+  setBackgroundColor (Qt::white);
+  setForegroundColor (Qt::black);
+  setSelectionColor (Qt::lightGray);
+  setCursorColor (false, Qt::darkGray);
+
+  // FIXME -- should we set the palette?
+  QPalette palette (backgroundColor ());
+  m_consoleView->setPalette (palette);
+
   m_consoleView->setAutoFillBackground (true);
+
   m_consoleView->setFont (m_font);
   parent->setFocusPolicy (Qt::StrongFocus);
   parent->winId ();
 
   updateScrollBar ();
 
   m_consoleWatcher = new QTimer (parent);
   m_consoleWatcher->setInterval (10);
@@ -335,17 +392,382 @@ void QConsolePrivate::setupStandardIO (D
         log ("%s opened and assigned to file descriptor %d.\n", devName, fd);
       if (! SetStdHandle (stdHandleId, (HANDLE) _get_osfhandle (targetFd)))
         log ("Failed to re-assign %s: error=%08x.\n", name, GetLastError ());
     }
   else
     log ("Failed to open %s: errno=%d.\n", devName, errno);
 }
 
-//////////////////////////////////////////////////////////////////////////////
+QPoint QConsolePrivate::posToCell (const QPoint& p)
+{
+  return QPoint (m_consoleRect.left () + p.x () / m_charSize.width (),
+                 m_consoleRect.top () + p.y () / m_charSize.height ());
+}
+
+QString QConsolePrivate::getSelection (void)
+{
+  QString selection;
+
+  QPoint begin = m_beginSelection;
+  QPoint end = m_endSelection;
+
+  maybeSwapPoints (begin, end);
+
+  if (begin != end)
+    {
+      CHAR_INFO* buf;
+      COORD bufSize, bufCoord;
+      SMALL_RECT bufRect;
+      int nr;
+
+      nr = end.y () - begin.y () + 1;
+      buf =  new CHAR_INFO[m_bufferSize.width () * nr];
+      bufSize.X = m_bufferSize.width ();
+      bufSize.Y = nr;
+      bufCoord.X = 0;
+      bufCoord.Y = 0;
+
+      bufRect.Left = 0;
+      bufRect.Right = m_bufferSize.width ();
+      bufRect.Top = begin.y ();
+      bufRect.Bottom = end.y ();
+
+      if (ReadConsoleOutput (m_stdOut, buf, bufSize, bufCoord, &bufRect))
+        {
+          int start_pos = begin.x ();
+          int end_pos = (nr - 1) * m_bufferSize.width () + end.x ();
+          int lastNonSpace = -1;
+
+          for (int i = start_pos; i <= end_pos; i++)
+            {
+              if (i && (i % m_bufferSize.width ()) == 0)
+                {
+                  if (lastNonSpace >= 0)
+                    selection.truncate (lastNonSpace);
+                  selection.append ('\n');
+                  lastNonSpace = selection.length ();
+                }
+
+              QChar c (buf[i].Char.UnicodeChar);
+
+              selection.append (c);
+              if (! c.isSpace ())
+                lastNonSpace = selection.length ();
+            }
+
+          if (lastNonSpace >= 0)
+            selection.truncate (lastNonSpace);
+        }
+    }
+
+  return selection;
+}
+
+void QConsolePrivate::updateSelection (void)
+{
+  QPoint begin = m_beginSelection;
+  QPoint end = m_endSelection;
+
+  maybeSwapPoints (begin, end);
+
+  begin.rx () = 0;
+  end.rx () = m_consoleRect.width ();
+
+  m_consoleView->update ();
+}
+
+void QConsolePrivate::clearSelection (void)
+{
+  m_beginSelection = m_endSelection = QPoint ();
+
+  m_consoleView->update ();
+}
+
+QColor QConsolePrivate::backgroundColor (void) const
+{
+  return m_colors[15];
+}
+
+QColor QConsolePrivate::foregroundColor (void) const
+{
+  return m_colors[0];
+}
+
+QColor QConsolePrivate::selectionColor (void) const
+{
+  return m_selectionColor;
+}
+
+QColor QConsolePrivate::cursorColor (void) const
+{
+  return m_cursorColor.isValid () ? m_cursorColor : foregroundColor ();
+}
+
+void QConsolePrivate::setBackgroundColor (const QColor& color)
+{
+  m_colors[15] = color;
+}
+
+void QConsolePrivate::setForegroundColor (const QColor& color)
+{
+  m_colors[0] = color;
+}
+
+void QConsolePrivate::setSelectionColor (const QColor& color)
+{
+  m_selectionColor = color;
+}
+
+void QConsolePrivate::setCursorColor (bool useForegroundColor,
+                                      const QColor& color)
+{
+  m_cursorColor = useForegroundColor ? QColor () : color;
+}
+
+void QConsolePrivate::drawTextBackground (QPainter& p, int cx1, int cy1,
+                                          int cx2, int cy2, int cw, int ch)
+{
+  p.save ();
+
+  int ascent = p.fontMetrics ().ascent ();
+  int stride = m_consoleRect.width ();
+  int y = ascent + cy1 * ch;;
+
+  for (int j = cy1; j <= cy2; j++, y += ch)
+    {
+      int len = 0;
+      bool hasChar = false;
+      int x = cx1 * cw;
+      WORD attr = 0;
+
+      for (int i = cx1; i <= cx2; i++)
+        {
+          CHAR_INFO* ci = &(m_buffer[stride*j+i]);
+
+          if ((ci->Attributes & 0x00ff) != attr)
+            {
+              // Character attributes changed
+              if (len != 0)
+                {
+                  // String buffer not empty -> draw it
+                  if (hasChar || (attr & 0x00f0))
+                    {
+                      if (attr & 0x00f0)
+                        p.fillRect (x, y-ascent, len * cw, ch, p.brush ());
+                    }
+
+                  x += (len * cw);
+                  len = 0;
+                  hasChar = false;
+                }
+              // Update current brush and store current attributes
+              attr = (ci->Attributes & 0x00ff);
+              p.setBrush (m_colors[(attr >> 4) & 0x000f]);
+            }
+
+          // Append current character to the string buffer
+          len++;
+          if (ci->Char.UnicodeChar != L' ')
+            hasChar = true;
+        }
+
+      if (len != 0 && (hasChar || (attr & 0x00f0)))
+        {
+          // Line end reached, but string buffer not empty -> draw it
+          // No need to update s or x, they will be reset on the next
+          // for-loop iteration
+
+          if (attr & 0x00f0)
+            p.fillRect (x, y-ascent, len * cw, ch, p.brush ());
+        }
+    }
+
+  p.restore ();
+}
+
+void QConsolePrivate::drawSelection (QPainter& p, int cx1, int cy1,
+                                     int cx2, int cy2, int cw, int ch)
+{
+  p.save ();
+
+  QPoint begin = m_beginSelection;
+  QPoint end = m_endSelection;
+
+  bool haveSelection = (begin != end);
+
+  if (haveSelection)
+    maybeSwapPoints (begin, end);
+
+  int scrollOffset = m_consoleRect.top ();
+
+  begin.ry () -= scrollOffset;
+  end.ry () -= scrollOffset;
+
+  int ascent = p.fontMetrics ().ascent ();
+  int stride = m_consoleRect.width ();
+
+  int y = ascent + cy1 * ch;;
+  for (int j = cy1; j <= cy2; j++, y += ch)
+    {
+      int charsThisLine = 0;
+      int len = 0;
+      bool hasChar = false;
+      WORD attr = 0;
+
+      for (int i = cx1; i <= cx2; i++)
+        {
+          CHAR_INFO* ci = &(m_buffer[stride*j+i]);
+
+          if ((ci->Attributes & 0x00ff) != attr)
+            {
+              // Character attributes changed
+              if (len != 0)
+                {
+                  charsThisLine += len;
+                  len = 0;
+                  hasChar = false;
+                }
+
+              // Store current attributes
+              attr = (ci->Attributes & 0x00ff);
+            }
+
+          // Append current character to the string buffer
+          len++;
+          if (ci->Char.UnicodeChar != L' ')
+            hasChar = true;
+        }
+
+      if (len != 0 && (hasChar || (attr & 0x00f0)))
+        charsThisLine += len;
+
+      if (haveSelection && j >= begin.y () && j <= end.y ())
+        {
+          int selectionBegin = j == begin.y () ? begin.x (): 0;
+
+          int len = ((j == end.y () && end.x () < charsThisLine)
+                     ? end.x () - selectionBegin + 1
+                     : stride - selectionBegin);
+
+          p.fillRect (selectionBegin * cw, y-ascent, len * cw, ch,
+                      selectionColor ());
+        }
+    }
+
+  p.restore ();
+}
+
+void QConsolePrivate::drawCursor (QPainter& p)
+{
+  if (! m_cursorBlinking)
+    {
+      p.save ();
+
+      QRect rect = cursorRect ();
+      QColor color = cursorColor ();
+
+      p.setPen (color);
+
+      if (m_cursorType == QConsolePrivate::BlockCursor)
+        {
+          if (q->hasFocus ())
+            p.fillRect (rect, color);
+          else
+            {
+              // draw the cursor outline, adjusting the area so that
+              // it is draw entirely inside 'rect'
+ 
+              int penWidth = qMax (1, p.pen().width());
+ 
+              p.drawRect (rect.adjusted (penWidth/2, penWidth/2,
+                                         - penWidth/2 - penWidth%2,
+                                         - penWidth/2 - penWidth%2));
+            }
+        }
+      else if (m_cursorType == QConsolePrivate::UnderlineCursor)
+        {
+          p.drawLine (rect.left (), rect.bottom (),
+                      rect.right (), rect.bottom ());
+        }
+      else if (m_cursorType == QConsolePrivate::IBeamCursor)
+        {
+          p.drawLine (rect.left (), rect.top (),
+                      rect.left (), rect.bottom ());
+        }
+
+      p.restore ();
+    }
+}
+
+void QConsolePrivate::drawText (QPainter& p, int cx1, int cy1,
+                                int cx2, int cy2, int cw, int ch)
+{
+  p.save ();
+
+  p.setFont (m_font);
+  p.setPen (foregroundColor ());
+
+  QString s;
+  s.reserve (cx2 - cx1 + 1);
+
+  int ascent = p.fontMetrics ().ascent ();
+  int stride = m_consoleRect.width ();
+
+  int y = ascent + cy1 * ch;;
+  for (int j = cy1; j <= cy2; j++, y += ch)
+    {
+      // Reset string buffer and starting X coordinate
+      s.clear ();
+      bool hasChar = false;
+      int x = cx1 * cw;
+      WORD attr = 0;
+
+      for (int i = cx1; i <= cx2; i++)
+        {
+          CHAR_INFO* ci = &(m_buffer[stride*j+i]);
+
+          if ((ci->Attributes & 0x00ff) != attr)
+            {
+              // Character attributes changed
+              if (! s.isEmpty ())
+                {
+                  // String buffer not empty -> draw it
+                  if (hasChar || (attr & 0x00f0))
+                    p.drawText (x, y, s);
+
+                  x += (s.length () * cw);
+                  s.clear ();
+                  hasChar = false;
+                }
+              // Update current pen and store current attributes
+              attr = (ci->Attributes & 0x00ff);
+              p.setPen (m_colors[attr & 0x000f]);
+            }
+
+          // Append current character to the string buffer
+          s.append (ci->Char.UnicodeChar);
+          if (ci->Char.UnicodeChar != L' ')
+            hasChar = true;
+        }
+
+      if (! s.isEmpty () && (hasChar || (attr & 0x00f0)))
+        {
+          // Line end reached, but string buffer not empty -> draw it
+          // No need to update s or x, they will be reset on the next
+          // for-loop iteration
+
+          p.drawText (x, y, s);
+        }
+    }
+
+  p.restore ();
+}
+
+/////////////////////////////////////////////////////////////////////////////
 
 void QConsolePrivate::closeStandardIO (int fd, DWORD stdHandleId,
                                        const char* name)
 {
   if (close (fd) == -1)
     log ("Failed to close file descriptor %d: errno=%d.\n", fd, errno);
   if (! CloseHandle (GetStdHandle (stdHandleId)))
     log ("Failed to close Win32 %s: error=%08x.\n", name, GetLastError ());
@@ -379,20 +801,20 @@ void QConsolePrivate::log (const char* f
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QConsolePrivate::updateConsoleSize (bool sync)
 {
   QFontMetrics fm (m_font);
   QSize winSize = m_consoleView->size ();
 
-  m_charSize.rwidth () = fm.maxWidth ();
+  m_charSize.rwidth () = fm.averageCharWidth ();
   m_charSize.rheight () = fm.lineSpacing ();
 
-  m_consoleRect.setWidth (winSize.width () / fm.maxWidth ());
+  m_consoleRect.setWidth (winSize.width () / fm.averageCharWidth ());
   m_consoleRect.setHeight (winSize.height () / fm.lineSpacing ());
 
   m_bufferSize.rwidth () = m_consoleRect.width ();
   m_bufferSize.rheight () = qMax (m_bufferSize.height (),
                                   m_consoleRect.height ());
 
   m_consoleRect.moveLeft (0);
   if (m_consoleRect.bottom () >= m_bufferSize.height ())
@@ -748,147 +1170,71 @@ QWinTerminalImpl::QWinTerminalImpl (cons
 
 //////////////////////////////////////////////////////////////////////////////
 
 QWinTerminalImpl::~QWinTerminalImpl (void)
 {
   delete d;
 }
 
+void QWinTerminalImpl::mouseMoveEvent (QMouseEvent *event)
+{
+  d->m_endSelection = d->posToCell (event->pos ());
+
+  updateSelection ();
+}
+
+void QWinTerminalImpl::mousePressEvent (QMouseEvent *event)
+{
+  if (event->button () == Qt::LeftButton)
+    d->m_beginSelection = d->posToCell (event->pos ());
+}
+
+void QWinTerminalImpl::mouseReleaseEvent (QMouseEvent *event)
+{
+  if (event->button () == Qt::LeftButton)
+    {
+      d->m_endSelection = d->posToCell (event->pos ());
+
+      updateSelection ();
+    }
+}
+
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::viewResizeEvent (QConsoleView*, QResizeEvent*)
 {
   d->updateConsoleSize (true);
   d->grabConsoleBuffer ();
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::viewPaintEvent (QConsoleView* w, QPaintEvent* event)
 {
   QPainter p (w);
-  int cw = d->m_charSize.width (), ch = d->m_charSize.height ();
-  int ascent, stride, cx1, cy1, cx2, cy2, x, y;
-  WORD attr = 0;
-  QString s;
-  bool hasChar = false;
+
+  int cw = d->m_charSize.width ();
+  int ch = d->m_charSize.height ();
 
   QRect updateRect = event->rect ();
 
-  cx1 = updateRect.left () / cw;
-  cy1 = updateRect.top () / ch;
-  cx2 = qMin (d->m_consoleRect.width () - 1, updateRect.right () / cw);
-  cy2 = qMin (d->m_consoleRect.height () - 1, updateRect.bottom () / ch);
+  int cx1 = updateRect.left () / cw;
+  int cy1 = updateRect.top () / ch;
+  int cx2 = qMin (d->m_consoleRect.width () - 1, updateRect.right () / cw);
+  int cy2 = qMin (d->m_consoleRect.height () - 1, updateRect.bottom () / ch);
 
   if (cx1 > d->m_consoleRect.width () - 1
       || cy1 > d->m_consoleRect.height () - 1)
     return;
 
-  p.setFont (d->m_font);
-  p.setPen (d->m_foregroundColor);
-
-  ascent = p.fontMetrics ().ascent ();
-  stride = d->m_consoleRect.width ();
-
-  s.reserve (cx2 - cx1 + 1);
-  y = ascent + cy1 * ch;;
-
-  for (int j = cy1; j <= cy2; j++, y += ch)
-    {
-      // Reset string buffer and starting X coordinate
-      s.clear ();
-      hasChar = false;
-      x = cx1 * cw;
-
-      for (int i = cx1; i <= cx2; i++)
-        {
-          CHAR_INFO* ci = &(d->m_buffer[stride*j+i]);
-
-          if ((ci->Attributes & 0x00ff) != attr)
-            {
-              // Character attributes changed
-              if (! s.isEmpty ())
-                {
-                  // String buffer not empty -> draw it
-                  if (hasChar || (attr & 0x00f0))
-                    {
-                      if (attr & 0x00f0)
-                        p.fillRect (x, y-ascent, s.length () * cw, ch,
-                                    p.brush ());
-                      p.drawText (x, y, s);
-                    }
-                  x += (s.length () * cw);
-                  s.clear ();
-                  hasChar = false;
-                }
-              // Update current pen and store current attributes
-              // FIXME: what about background?
-              attr = (ci->Attributes & 0x00ff);
-              p.setPen (d->m_colors[attr & 0x000f]);
-              p.setBrush (d->m_colors[(attr >> 4) & 0x000f]);
-            }
-
-          // Append current character to the string buffer
-          s.append (ci->Char.UnicodeChar);
-          if (ci->Char.UnicodeChar != L' ')
-            hasChar = true;
-        }
-
-      if (! s.isEmpty () && (hasChar || (attr & 0x00f0)))
-        {
-          // Line end reached, but string buffer not empty -> draw it
-          // No need to update s or x, they will be reset on the next
-          // for-loop iteration
-          if (attr & 0x00f0)
-            p.fillRect (x, y-ascent, s.length () * cw, ch, p.brush ());
-          p.drawText (x, y, s);
-        }
-    }
-
-  if (! d->m_cursorBlinking)
-    {
-      QColor cursorColor = d->m_colors[7];
-      QRect cursorRect = d->cursorRect ();
-
-      p.setPen (d->m_foregroundColor);
-
-      if (d->m_cursorType == QConsolePrivate::BlockCursor)
-        {
-          if (hasFocus ())
-            {
-              p.setCompositionMode (QPainter::RasterOp_SourceXorDestination);
-
-              p.fillRect (cursorRect, cursorColor);
-            }
-          else
-            {
-              // draw the cursor outline, adjusting the area so that
-              // it is draw entirely inside 'rect'
- 
-              int penWidth = qMax (1, p.pen().width());
- 
-              p.setBrush (Qt::NoBrush);
-
-              p.drawRect (cursorRect.adjusted (penWidth/2, penWidth/2,
-                                               - penWidth/2 - penWidth%2,
-                                               - penWidth/2 - penWidth%2));
-            }
-        }
-      else if (d->m_cursorType == QConsolePrivate::UnderlineCursor)
-        {
-          p.drawLine (cursorRect.left (), cursorRect.bottom (),
-                      cursorRect.right (), cursorRect.bottom ());
-        }
-      else if (d->m_cursorType == QConsolePrivate::IBeamCursor)
-        {
-          p.drawLine (cursorRect.left (), cursorRect.top (),
-                      cursorRect.left (), cursorRect.bottom ());
-        }
-    }
+  d->drawTextBackground (p, cx1, cy1, cx2, cy2, cw, ch);
+  d->drawSelection (p, cx1, cy1, cx2, cy2, cw, ch);
+  d->drawCursor (p);
+  d->drawText (p, cx1, cy1, cx2, cy2, cw, ch);
 }
 
 void QWinTerminalImpl::blinkCursorEvent (void)
 {
   if (d->m_hasBlinkingCursor)
     d->m_cursorBlinking = ! d->m_cursorBlinking;
   else
     d->m_cursorBlinking = false;
@@ -960,16 +1306,21 @@ void QWinTerminalImpl::scrollValueChange
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::monitorConsole (void)
 {
   d->monitorConsole ();
 }
 
+void QWinTerminalImpl::updateSelection (void)
+{
+  d->updateSelection ();
+}
+
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::focusInEvent (QFocusEvent* event)
 {
   setBlinkingCursorState (true);
 
   QWidget::focusInEvent (event);
 }
@@ -1026,16 +1377,37 @@ void QWinTerminalImpl::setCursorType (Cu
     case IBeamCursor:
       d->m_cursorType = QConsolePrivate::IBeamCursor;
       break;
     }
 
   setBlinkingCursor (blinking);
 }
 
+void QWinTerminalImpl::setBackgroundColor (const QColor& color)
+{
+  d->setBackgroundColor (color);
+}
+
+void QWinTerminalImpl::setForegroundColor (const QColor& color)
+{
+  d->setForegroundColor (color);
+}
+
+void QWinTerminalImpl::setSelectionColor (const QColor& color)
+{
+  d->setSelectionColor (color);
+}
+
+void QWinTerminalImpl::setCursorColor (bool useForegroundColor,
+                                       const QColor& color)
+{
+  d->setCursorColor (useForegroundColor, color);
+}
+
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::setTerminalFont (const QFont& f)
 {
   d->m_font = f;
   d->m_consoleView->setFont (f);
   d->updateConsoleSize (true);
 }
@@ -1047,15 +1419,22 @@ void QWinTerminalImpl::setSize (int colu
   Q_UNUSED (columns);
   Q_UNUSED (lines);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::copyClipboard (void)
 {
+  QClipboard *clipboard = QApplication::clipboard ();
+
+  clipboard->setText (d->getSelection ());
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 void QWinTerminalImpl::pasteClipboard (void)
 {
+  QString text = QApplication::clipboard()->text (QClipboard::Clipboard);
+
+  if (! text.isEmpty ())
+    sendText (text);
 }
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
--- a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
@@ -25,16 +25,17 @@ along with Foobar.  If not, see <http://
 #include <QWidget>
 #include "QTerminalInterface.h"
 class QFocusEvent;
 class QKeyEvent;
 class QPainter;
 class QPaintEvent;
 class QResizeEvent;
 class QWheelEvent;
+class QPoint;
 
 class QConsolePrivate;
 class QConsoleThread;
 class QConsoleView;
 
 //////////////////////////////////////////////////////////////////////////////
 
 class QWinTerminalImpl : public QTerminalInterface
@@ -49,16 +50,21 @@ public:
   QWinTerminalImpl (const QString& cmd, QWidget* parent = 0);
   ~QWinTerminalImpl (void);
 
   void setTerminalFont (const QFont& font);
   void setSize (int columns, int lines);
   void sendText (const QString& s);
   void setCursorType (CursorType type, bool blinking);
 
+  void setBackgroundColor (const QColor& color);
+  void setForegroundColor (const QColor& color);
+  void setSelectionColor (const QColor& color);
+  void setCursorColor (bool useForegoundColor, const QColor& color);
+
 public slots:
   void copyClipboard (void);
   void pasteClipboard (void);
   void blinkCursorEvent (void);
 
 signals:
   void terminated (void);
   void titleChanged (const QString&);
@@ -69,20 +75,24 @@ protected:
   void setBlinkingCursorState (bool blink);
   void viewResizeEvent (QConsoleView*, QResizeEvent*);
   void wheelEvent (QWheelEvent*);
   void focusInEvent (QFocusEvent*);
   void focusOutEvent (QFocusEvent*);
   void keyPressEvent (QKeyEvent*);
   bool winEvent (MSG*, long*);
   virtual void start (void);
+  void mouseMoveEvent (QMouseEvent *event);
+  void mousePressEvent (QMouseEvent *event);
+  void mouseReleaseEvent (QMouseEvent *event);
 
 private slots:
   void scrollValueChanged (int value);
   void monitorConsole (void);
+  void updateSelection (void);
 
 private:
   QConsolePrivate* d;
 };
 
 //////////////////////////////////////////////////////////////////////////////
 
 #endif // __QConsole_h__
diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -44,13 +44,22 @@ color_picker::select_color ()
       _color = new_color;
       update_button ();
     }
 }
 
 // draw the button with the actual color (using a stylesheet)
 void color_picker::update_button ()
 {
-  QString css = QString("background-color: %1; border: none;" )
-                        .arg(_color.name());
+  // Is this the right place to look for a "foreground" color that would
+  // provide a reasonable border for the color swatches?
+  QWidget *p = parentWidget ();
+
+  QString bordercolor
+    = p ? p->palette().text().color().name() : QString ("#000000");
+
+  QString css = QString("background-color: %1; border: 1px solid %2;")
+                        .arg(_color.name())
+                        .arg(bordercolor);
+
   setStyleSheet(css);
   repaint ();
 }
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -158,17 +158,17 @@ MessageDialog::MessageDialog (const QStr
             erole = QMessageBox::AcceptRole;
 
           QPushButton *pbutton = addButton (qsbutton.at (i), erole);
           if (qsbutton.at (i) == defbutton)
             setDefaultButton (pbutton);
           // Make the last button the button pressed when <esc> key activated.
           if (i == N-1)
             {
-#define ACTIVE_ESCAPE true
+#define ACTIVE_ESCAPE 1
 #if ACTIVE_ESCAPE
               setEscapeButton (pbutton);
 #else
               setEscapeButton (0);
 #endif
 #undef ACTIVE_ESCAPE
             }
         }
@@ -226,17 +226,17 @@ ListDialog::ListDialog (const QStringLis
   if (! prompt.isEmpty ())
     {
       // For now, assume html-like Rich Text.  May be incompatible
       // with something down the road, but just testing capability.
       QString prompt_string;
       for (int j = 0; j < prompt.length (); j++)
         {
           if (j > 0)
-#define RICH_TEXT true
+#define RICH_TEXT 1
 #if RICH_TEXT
             prompt_string.append ("<br>");
 #else
             prompt_string.append ("\n");
 #endif
           prompt_string.append (prompt.at (j));
         }
       QLabel *plabel = new QLabel (prompt_string);
@@ -322,17 +322,17 @@ ListDialog::reject (void)
 
 
 InputDialog::InputDialog (const QStringList& prompt, const QString& title,
                           const QFloatList& nr, const QFloatList& nc,
                           const QStringList& defaults)
   : QDialog ()
 {
 
-#define LINE_EDIT_FOLLOWS_PROMPT false
+#define LINE_EDIT_FOLLOWS_PROMPT 0
 
 #if LINE_EDIT_FOLLOWS_PROMPT
     // Prompt on left followed by input on right.
     QGridLayout *promptInputLayout = new QGridLayout;
 #else
     // Prompt aligned above input.
     QVBoxLayout *promptInputLayout = new QVBoxLayout;
 #endif
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -23,33 +23,47 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "resource-manager.h"
 #include "files-dock-widget.h"
 
 #include <QApplication>
+#include <QClipboard>
 #include <QFileInfo>
 #include <QCompleter>
-#include <QSettings>
 #include <QProcess>
 #include <QDebug>
 #include <QHeaderView>
 #include <QLineEdit>
 #include <QSizePolicy>
 #include <QMenu>
 #include <QInputDialog>
 #include <QMessageBox>
 #include <QToolButton>
 #include <QUrl>
 #include <QDesktopServices>
+#include <QFileDialog>
 
 #include "load-save.h"
 
+class FileTreeViewer : public QTreeView
+{
+public:
+
+  FileTreeViewer (QWidget *p) : QTreeView (p) { }
+
+  void mousePressEvent (QMouseEvent *e)
+  {
+    if (e->button () != Qt::RightButton)
+      QTreeView::mousePressEvent (e);
+  }
+};
+
 files_dock_widget::files_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("FilesDockWidget");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("File Browser"));
   setToolTip (tr ("Browse your files."));
 
@@ -58,19 +72,16 @@ files_dock_widget::files_dock_widget (QW
   setWidget (container);
 
   connect (this, SIGNAL (open_file (const QString&)),
            parent (), SLOT (open_file (const QString&)));
 
   connect (this, SIGNAL (displayed_directory_changed (const QString&)),
            parent (), SLOT (set_current_working_directory (const QString&)));
 
-  connect (parent (), SIGNAL (settings_changed (const QSettings *)),
-           this, SLOT (notice_settings (const QSettings *)));
-
   // Create a toolbar
   _navigation_tool_bar = new QToolBar ("", container);
   _navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
   _navigation_tool_bar->setMovable (false);
 
   _current_directory = new QComboBox (_navigation_tool_bar);
   _current_directory->setToolTip (tr ("Enter the path or filename"));
   _current_directory->setEditable(true);
@@ -99,16 +110,20 @@ files_dock_widget::files_dock_widget (QW
   QMenu * popdown_menu = new QMenu();
   popdown_menu->addAction(_sync_browser_directory_action);
   popdown_menu->addAction(_sync_octave_directory_action);
   popdown_button->setMenu(popdown_menu);
   popdown_button->setPopupMode(QToolButton::InstantPopup);
   popdown_button->setDefaultAction(new QAction(QIcon(":/actions/icons/gear.png"),"", _navigation_tool_bar));
 
   popdown_menu->addSeparator();
+  popdown_menu->addAction (QIcon (":/actions/icons/search.png"),
+                           tr ("Search directory"),
+                           this, SLOT (popdownmenu_search_dir (bool)));
+  popdown_menu->addSeparator();
   popdown_menu->addAction(QIcon(":/actions/icons/filenew.png"),
                           tr ("New File"),
                           this, SLOT(popdownmenu_newfile(bool)));
   popdown_menu->addAction(QIcon(":/actions/icons/folder_new.png"),
                           tr ("New Directory"),
                           this, SLOT(popdownmenu_newdir(bool)));
 
   _navigation_tool_bar->addWidget (_current_directory);
@@ -125,17 +140,18 @@ files_dock_widget::files_dock_widget (QW
   // Create the QFileSystemModel starting in the actual directory
   QDir curr_dir;
   _file_system_model = new QFileSystemModel (this);
   _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
   QModelIndex rootPathIndex = _file_system_model->setRootPath (
                                                   curr_dir.absolutePath ());
 
   // Attach the model to the QTreeView and set the root index
-  _file_tree_view = new QTreeView (container);
+  _file_tree_view = new FileTreeViewer (container);
+  _file_tree_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
   _file_tree_view->setModel (_file_system_model);
   _file_tree_view->setRootIndex (rootPathIndex);
   _file_tree_view->setSortingEnabled (true);
   _file_tree_view->setAlternatingRowColors (true);
   _file_tree_view->setAnimated (true);
   _file_tree_view->setToolTip (tr ("Doubleclick a file to open it"));
 
   // get sort column and order as well as cloumn state (order and width)
@@ -322,16 +338,19 @@ files_dock_widget::contextmenu_requested
       QFileInfo info = _file_system_model->fileInfo(index);
 
       menu.addAction (QIcon (":/actions/icons/fileopen.png"), tr("Open"),
                      this, SLOT(contextmenu_open(bool)));
 
       menu.addAction (tr("Open in Default Application"),
                       this, SLOT (contextmenu_open_in_app (bool)));
 
+      menu.addAction (tr("Copy Selection to Clipboard"),
+                      this, SLOT (contextmenu_copy_selection (bool)));
+
       if (info.isFile () && info.suffix () == "m")
         menu.addAction (QIcon (":/actions/icons/artsbuilderexecute.png"),
                         tr("Run"), this, SLOT(contextmenu_run(bool)));
 
       if (info.isFile ())
         menu.addAction (tr("Load Data"), this, SLOT(contextmenu_load(bool)));
 
       if (info.isDir ())
@@ -382,16 +401,36 @@ files_dock_widget::contextmenu_open_in_a
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     open_item_in_app (*it);
 }
 
 void
+files_dock_widget::contextmenu_copy_selection (bool)
+{
+  QItemSelectionModel *m = _file_tree_view->selectionModel ();
+  QModelIndexList rows = m->selectedRows ();
+
+  QStringList selection;
+
+  for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+    {
+      QFileInfo info = _file_system_model->fileInfo (*it);
+
+      selection << info.fileName ();
+    }
+
+  QClipboard *clipboard = QApplication::clipboard ();
+
+  clipboard->setText (selection.join ("\n"));
+}
+
+void
 files_dock_widget::contextmenu_load (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
@@ -568,16 +607,24 @@ files_dock_widget::notice_settings (cons
   _sync_browser_directory_action->setEnabled (!_sync_octave_dir);
 
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
+files_dock_widget::popdownmenu_search_dir (bool)
+{
+  QString dir
+    = QFileDialog::getExistingDirectory (this, tr ("Set directory of file browser"));
+  process_set_current_dir (dir);
+}
+
+void
 files_dock_widget::popdownmenu_newdir (bool)
 {
       process_new_dir(_file_system_model->rootPath());
 }
 
 void
 files_dock_widget::popdownmenu_newfile (bool)
 {
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <QWidget>
 #include <QListWidget>
 #include <QFileSystemModel>
 #include <QToolBar>
 #include <QToolButton>
 #include <QVBoxLayout>
 #include <QAction>
 #include <QTreeView>
-#include <QSettings>
+#include <QMouseEvent>
 
 #include <QComboBox>
 #include "octave-dock-widget.h"
 
 /**
    \class files_dock_widget
    \brief Dock widget to display files in the current directory.
 */
@@ -81,27 +81,29 @@ public slots:
 
 private slots:
   /** context menu wanted */
   void contextmenu_requested (const QPoint& pos);
 
   /* context menu actions */
   void contextmenu_open (bool);
   void contextmenu_open_in_app (bool);
+  void contextmenu_copy_selection (bool);
   void contextmenu_run (bool);
   void contextmenu_load (bool);
   void contextmenu_rename (bool);
   void contextmenu_delete (bool);
   void contextmenu_newfile (bool);
   void contextmenu_newdir (bool);
   void contextmenu_setcurrentdir (bool);
 
   /* popdown menu options */
   void popdownmenu_newfile(bool);
   void popdownmenu_newdir(bool);
+  void popdownmenu_search_dir (bool);
 
 signals:
 
   /** Emitted, whenever the user requested to open a file. */
   void open_file (const QString& fileName);
 
   /** Emitted, whenever the currently displayed directory changed. */
   void displayed_directory_changed (const QString& dir);
diff --git a/libgui/src/icons/fileclose.png b/libgui/src/icons/fileclose.png
new file mode 100755
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..6ed5fface345dc0330e25526d9b158792c15e5e6
GIT binary patch
literal 2449
zc$@)|32yd@P)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F8000SCNkl<ZScS!x
zdu)~E9mhY<`@HXYFXvL)0;PpQDFs^Y7P$xug#b~=PzTGLx)9xFm{X@&w*8^oOy;s^
z7Pl;JvbkmRid#_el9?GrjkqYFa%rIyXeqtX+i6eFIX$=cwm;faS_^LewI_L#_kGXr
zdA{G@_jh@JNBF+a|8t4)4^~+%q2d`#nN~u$pnzZ~gkk9DhCx76@qHiLcF1Hhq*7@L
z3L@kkFbo4l5#($KRZ4<Elk?{<M1}?i;)8uXB>K7-?)-ET0cFw~-^b47`2Kfp@%QY$
zIpujid>NH|AJ6kxRx|ITpFMELkmq?}-}A0&K9PX$<GBuoX%5`EeJ!_cUTF%!Ip6pB
zGNBq8iod>ee)-yMYia=EzULKRZT|!Uo|9AJJ#GGin(D&*yPE2%s^Q^O=l_E5`##C!
z@Y^-jRXeU<RSm!m+qV+yYU%eJyXs1N#^-<v*xSDME1rAoev;`d0Hs9{9@_f~C+g2+
z!{LzeMLCd2B<mN|R4w`C-8&gbq_7>2X;Xqc@|V|n{DE5l<^$)iM!>JV`F>vB`!GF&
z2@<Icz7Jtbr)EwGzuEUT|Ni(`+B6L-o6SxlkjvSh)UH^x^4?pva48xmk;(uNGIeGY
zMR@qh{XF}~9)MzCU_609aMr5Wt~<YL{@`2N=^ackoX+BUmo+zajfJyI*t`EA4X4hY
z0~Ta586uG|zVDMrBwt&)r259YzP_36Xq;p^J4Q?hLCDl8E(r3AC-(8?pC1KhXb#W@
zAgr?5-@o;*m+o1=WG?R>JI9H$ZD^`GDON#KXZDOD4!m=Oll6^Fj%`<$&z?nld*{mw
z7gp`OeMcP~y@Mo2Js-amMNkm3D4kls`SxD^`uu^zM_zh-?T7-3H7!`S_ygZ_tDk!M
zPxK8Y7>FehVnU0+_kAo=r*c*a?;ozGqqF<nOeWJ@RyO0VZFSeu+SSK!Dl=i95CY%#
znOYd3FcM_XoqNb7qRFZAmTl@j{>CQ&LWat5lkE}UJ)rivw~o@;JHW+`9u!5OD3=Sx
z8?EPsmF3*KtBzzk%M<(Gqc<AEahwUZdHYB>$jp*resuS}WP0oSfGxnuyp1XY7B0kr
zO~A)@?AlrLyJwy!Xc=_(Mv+oZIMi_*PBb=i@Uv19sVwJPJF#thlAZ7SghLiV)8L^W
z|CCH`eFE4z9vndE#noh^XY$V#z<ZI3brlaj@-WR8yXfxj8}m$26g<zv^L--WAg=2%
zoJymJ%Sz={3WY3Ym6h<qGyCW``mzmd0}g&ZKcs3+#ZC9;pJRc-`7dOX16%5w+DbQX
z-a!9AjCeeW<2cy1jpH~twoNjbB9%(xI?mW{xm=EHHixQdluR$?jo03!?b!Q$T4d%{
z&r=TJraq646j~TB8@nt?pde*LrtZrQ$8TuwiIuKjw~E17oKz}}qFk0)h>`2E<Rh{N
z0vcsyC46}3Bib8}M~%p|jh^csbF)dVNMJlTfam&1J(SZ!Q=ZLbG8+^lIOq1ATZs-0
z6N|<1JRcCFfQ;Uce1O8?5OXVL(Rk)O9WBi*ic~jyp4aGRQ#i?9@a;(i)F1x#A6#tj
zA{L9|y6%X?jzcUO%_N6nb*5?fw{BjEuBrUt=>z0)xk(A<x-P!&GktmmyLW8hkLe5-
zo11ScoL<s&;p9<r$tZY}y$4VShY}<bNs@`ggu}9#3|2VuVki{k!Mz7K+0aCMXb34K
z?sx*D-aC%N>C<QV+p8+B>!BOQ^VxKI#gcWKP&Ey0^b!K3lq1RP`KY#S<GS7$u<!f0
zj)P&Euhy=ry~#2SKKSqmuH#@@7E;Pd^_~wwE|=rP$<wS@zKG?uE0&);cA_bp$t-jn
z2iI}PW=B47<10qZ-{gC@JCf0_ty#C`#z;6weM1wPreRsugvONLlMjdIdFXn8T+Zf9
zQwz(NR$~~e7kqN$)3d(sFAzeE*^VDj#$3sJE`&IG-TE~*7DPgvX=+AFiDj8%qnQ>6
zpsFfGMTN|qS&FKvXn_E_VW8_e!Jvf@g8EZU6c-k-cHQdvilQW3$H8^ou|APkTgl&e
zu8UOF`gQBqTx*#IO=nwB6a~{VF--$q4`Ap4G*uFbgxJ1mHMf0r10^L>(Nu|{2hjBZ
zx~^kdCaS8^*wjoYXtDOXRUuW=GULNMrhwzPc{vZ(u3WxEN`(up9V6hTIRZMGKvGIV
zp&(0Z<}s}>Oh8jvyr6=jqA4hff~IK%0vd)Mz%UGi5Hz>65eR5pQ@czDdR)gDQvpEi
zxbN4PhW^jmWec}AU+m)2rCx*(1Oj<bWh{1@rczTihj=nYTW3$bp$B@UR5sUC&8DHL
zmE>@0OkT$sDd}8pr1r~am13DXC+g2!=<DsPR8<v4QBaBs3m*OZWA|<U=GIko_w*x#
z7>TzY7)L^4nFfm&R4|;*&~*M{j}T&eAfRoD4h$V`?dV~}qIncfiHxbGkA}oBbP$5J
z_AZJGBRu+(Z_ll(TX$$|VEOq|uP^WF=|3K{OtRS=(SaD6rlM&Ysyb3~h901Db}6ZJ
zmQzhFQP1=1LLuu^K{!ZvZ`AUA|4`YCX|)UH&g5Kc7qNJ9v^TiewvBB&6c<eaz;Rt%
z*SqcHiG~-Ylqjz2p6KrGTY9qoObVc?vV7DF6-`x%ge(?T&SE%~;cQELpQ@@GrBqI(
z(<8%&5F(|j>c-yw!Ot4bUZiGTIYm<<XsSBqNL6Jyx*nkALK~f(-Mbna&%T%+TofrK
zLWl-cl^Z)R^^(onRL&_wm6A}<WLD`kI(wp=yU^h(in2pdl!hyG)P$7s`k{ET_1NiV
z7S5eXIAozpNkw@nz7H*}9Y`s6r_-5N#<y}sN+mx~995;<+TPjCKrF#Ei|4WKnrbrH
z9DUJPLRIDUiXskQ0X)C@RaI_E4yPMWpKqhGd<GTeGsxLC%@^9yRC$k-^0_hK{ERXF
z1R;1wQIyq#v3Tlh8&+`hSC-P=)z>eCs1rg=8YVu!gb=M#Dr*Oa631-EW$T*7T<VFU
zD9Uar<&&c}6ZT9Vf8l5#pshLZ!SVWOg%Lc@+X@{2Z{XurTvOFL$93xm6R9~;D&LS&
z+3#KD|KXJg05tSQhqiQdM^)gsR1_T7{Sq8VbawY|OAM!LUDw<HMTY+YE*FYiik^<H
P00000NkvXXu0mjfbZfxS

diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -314,19 +314,18 @@ file_editor::request_open_file (const QS
           // really show editor and the current editor tab
           set_focus ();
         }
     }
 }
 
 // open a file from the mru list
 void
-file_editor::request_mru_open_file (void)
+file_editor::request_mru_open_file (QAction *action)
 {
-  QAction *action = qobject_cast<QAction *> (sender ());
   if (action)
     {
       request_open_file (action->data ().toString ());
     }
 }
 
 
 void
@@ -620,16 +619,46 @@ file_editor::handle_file_name_changed (c
               _tab_widget->setTabText (i, fname);
               _tab_widget->setTabToolTip (i, tip);
             }
         }
     }
 }
 
 void
+file_editor::request_close_file (bool)
+{
+  emit fetab_close_request (_tab_widget->currentWidget ());
+}
+
+void
+file_editor::request_close_all_files (bool)
+{
+  int index;
+  while ((index = _tab_widget->currentIndex ()) > -1)
+    emit fetab_close_request (_tab_widget->widget (index));
+}
+
+void
+file_editor::request_close_other_files (bool)
+{
+  int index = 0;
+  QWidget *tabID = _tab_widget->currentWidget ();
+
+  while (_tab_widget->count () > 1)
+    {
+      if (tabID != _tab_widget->widget (index))
+        emit fetab_close_request (_tab_widget->widget (index));
+      else
+        index++;
+    }
+}
+
+
+void
 file_editor::handle_tab_close_request (int index)
 {
   // Signal to the tabs a request to close whomever matches the identifying
   // tag (i.e., unique widget pointer).  The reason for this indirection is
   // that it will enable a file editor widget to toss up a non-static
   // dialog box and later signal that it wants to be removed.
   QWidget *tabID = _tab_widget->widget (index);
   emit fetab_close_request (tabID);
@@ -843,32 +872,50 @@ file_editor::construct (void)
   _tool_bar->addSeparator ();
   _tool_bar->addAction (toggle_breakpoint_action);
   _tool_bar->addAction (next_breakpoint_action);
   _tool_bar->addAction (previous_breakpoint_action);
   _tool_bar->addAction (remove_all_breakpoints_action);
 
   // menu bar
   QMenu *fileMenu = new QMenu (tr ("&File"), _menu_bar);
-  fileMenu->addAction (new_action);
-  fileMenu->addAction (open_action);
-  fileMenu->addAction (save_action);
-  fileMenu->addAction (save_as_action);
-  fileMenu->addSeparator ();
+
   _mru_file_menu = new QMenu (tr ("&Recent Editor Files"), fileMenu);
-
   for (int i = 0; i < MaxMRUFiles; ++i)
     _mru_file_menu->addAction (_mru_file_actions[i]);
 
+  fileMenu->addAction (new_action);
+  fileMenu->addAction (open_action);
   fileMenu->addMenu (_mru_file_menu);
-  _menu_bar->addMenu (fileMenu);
+
+  fileMenu->addSeparator ();
+  fileMenu->addAction (save_action);
+  fileMenu->addAction (save_as_action);
+
+  fileMenu->addSeparator ();
+  fileMenu->addAction (QIcon::fromTheme("window-close",
+                                      QIcon (":/actions/icons/fileclose.png")),
+                       tr ("&Close"),
+                       this, SLOT (request_close_file (bool)),
+                             QKeySequence::Close);
+  fileMenu->addAction (QIcon::fromTheme("window-close",
+                                      QIcon (":/actions/icons/fileclose.png")),
+                       tr ("Close All"),
+                       this, SLOT (request_close_all_files (bool)));
+  fileMenu->addAction (QIcon::fromTheme("window-close",
+                                      QIcon (":/actions/icons/fileclose.png")),
+                       tr ("Close Other Files"),
+                       this, SLOT (request_close_other_files (bool)));
 
   fileMenu->addSeparator ();
   fileMenu->addAction (print_action);
 
+  _menu_bar->addMenu (fileMenu);
+
+
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
   editMenu->addAction (undo_action);
   editMenu->addAction (redo_action);
   editMenu->addSeparator ();
   editMenu->addAction (_copy_action);
   editMenu->addAction (_cut_action);
   editMenu->addAction (paste_action);
   editMenu->addSeparator ();
@@ -901,19 +948,16 @@ file_editor::construct (void)
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->addWidget (_menu_bar);
   vbox_layout->addWidget (_tool_bar);
   vbox_layout->addWidget (_tab_widget);
   vbox_layout->setMargin (0);
   editor_widget->setLayout (vbox_layout);
   setWidget (editor_widget);
 
-  connect (parent (), SIGNAL (settings_changed (const QSettings *)),
-           this, SLOT (notice_settings (const QSettings *)));
-
   connect (parent (), SIGNAL (new_file_signal (const QString&)),
            this, SLOT (request_new_file (const QString&)));
 
   connect (parent (), SIGNAL (open_file_signal (const QString&)),
            this, SLOT (request_open_file (const QString&)));
 
   connect (new_action, SIGNAL (triggered ()),
            this, SLOT (request_new_file ()));
@@ -979,22 +1023,18 @@ file_editor::construct (void)
            this, SLOT (request_uncomment_selected_text ()));
 
   connect (find_action, SIGNAL (triggered ()),
            this, SLOT (request_find ()));
 
   connect (goto_line_action, SIGNAL (triggered ()),
            this, SLOT (request_goto_line ()));
 
-  // The actions of the mru file menu
-  for (int i = 0; i < MaxMRUFiles; ++i)
-    {
-      connect (_mru_file_actions[i], SIGNAL (triggered ()),
-               this, SLOT (request_mru_open_file ()));
-    }
+  connect (_mru_file_menu, SIGNAL (triggered (QAction *)),
+           this, SLOT (request_mru_open_file (QAction *)));
 
   mru_menu_update ();
 
   connect (_tab_widget, SIGNAL (tabCloseRequested (int)),
            this, SLOT (handle_tab_close_request (int)));
 
   connect (_tab_widget, SIGNAL (currentChanged (int)),
            this, SLOT (active_tab_changed (int)));
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #define FILEEDITORMDISUBWINDOW_H
 
 #include <QToolBar>
 #include <QAction>
 #include <QMenuBar>
 #include <QStatusBar>
 #include <QCloseEvent>
 #include <QTabWidget>
-#include <QSettings>
 
 #include <map>
 
 #include "file-editor-interface.h"
 #include "file-editor-tab.h"
 
 class file_editor : public file_editor_interface
 {
@@ -101,17 +100,20 @@ signals:
 public slots:
   void focus (void);
   void handle_visibility (bool visible);
 
   void request_new_file (const QString& commands);
   void request_new_script (const QString& commands);
   void request_new_function (const QString& commands);
   void request_open_file (void);
-  void request_mru_open_file (void);
+  void request_close_file (bool);
+  void request_close_all_files (bool);
+  void request_close_other_files (bool);
+  void request_mru_open_file (QAction *action);
   void request_print_file (void);
 
   void request_undo (void);
   void request_redo (void);
   void request_copy (void);
   void request_cut (void);
   void request_paste (void);
   void request_save_file (void);
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -18,16 +18,17 @@ octave_gui_ICONS = \
   src/icons/db_step_in.png \
   src/icons/db_step_out.png \
   src/icons/db_step.png \
   src/icons/db_stop.png \
   src/icons/editcopy.png \
   src/icons/editcut.png \
   src/icons/editdelete.png \
   src/icons/editpaste.png \
+  src/icons/fileclose.png \
   src/icons/filenew.png \
   src/icons/fileopen.png \
   src/icons/fileprint.png \
   src/icons/filesaveas.png \
   src/icons/filesave.png \
   src/icons/find.png \
   src/icons/gear.png \
   src/icons/folder_new.png \
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -19,41 +19,46 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_dock_widget_h)
 #define octave_dock_widget_h 1
 
 #include <QDockWidget>
+#include <QSettings>
 
 class octave_dock_widget : public QDockWidget
 {
   Q_OBJECT
 
 public:
 
   octave_dock_widget (QWidget *p)
     : QDockWidget (p)
   {
     connect (this, SIGNAL (visibilityChanged (bool)),
              this, SLOT (handle_visibility_changed (bool)));
 
     connect (this, SIGNAL (topLevelChanged (bool)),
              this, SLOT (top_level_changed (bool)));
+
+    connect (p, SIGNAL (settings_changed (const QSettings*)),
+             this, SLOT (notice_settings (const QSettings*)));
   }
 
   virtual ~octave_dock_widget () { }
 
   virtual void connect_visibility_changed (void)
   {
     connect (this, SIGNAL (visibilityChanged (bool)),
              this, SLOT (handle_visibility (bool)));
   }
 
+
 signals:
 
   /** Custom signal that tells whether a user has clicked away
    *  that dock widget, i.e the active dock widget has
    *  changed. */
   void active_changed (bool active);
 
 protected:
@@ -77,16 +82,20 @@ public slots:
   }
 
   virtual void handle_visibility (bool visible)
   {
     if (visible && ! isFloating ())
       focus ();
   }
 
+  virtual void notice_settings (const QSettings*)
+  {
+  }
+
 protected slots:
 
   /** Slot to steer changing visibility from outside. */
   virtual void handle_visibility_changed (bool visible)
   {
     if (visible)
       emit active_changed (true);
   }
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -212,16 +212,34 @@ resource_manager::storage_class_default_
   return QList<QColor> () << QColor(190,255,255)
                           << QColor(220,255,220)
                           << QColor(220,220,255)
                           << QColor(255,255,190)
                           << QColor(255,220,220)
                           << QColor(255,190,255);
 }
 
+QStringList 
+resource_manager::terminal_color_names (void)
+{
+  return QStringList () << QObject::tr ("foreground")
+                        << QObject::tr ("background")
+                        << QObject::tr ("selection")
+                        << QObject::tr ("cursor");
+}
+
+QList<QColor>
+resource_manager::terminal_default_colors (void)
+{
+  return QList<QColor> () << QColor(0,0,0)
+                          << QColor(255,255,255)
+                          << QColor(192,192,192)
+                          << QColor(128,128,128);
+}
+
 const char*
 resource_manager::octave_keywords (void)
 {
   return
       ".nargin. "
       "EDITOR "
       "EXEC_PATH "
       "F_DUPFD "
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -82,16 +82,20 @@ public:
   }
 
   static const char *octave_keywords (void);
   
   static QString storage_class_chars (void) { return "afghip"; }
   static QStringList storage_class_names (void);
   static QList<QColor> storage_class_default_colors (void);
 
+  static QString terminal_color_chars (void) { return "fbsc"; }
+  static QStringList terminal_color_names (void);
+  static QList<QColor> terminal_default_colors (void);
+
 private:
 
   static resource_manager *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   // No copying!
 
diff --git a/libgui/src/resource.qrc b/libgui/src/resource.qrc
--- a/libgui/src/resource.qrc
+++ b/libgui/src/resource.qrc
@@ -1,15 +1,16 @@
 <RCC>
     <qresource prefix="/actions">
         <file>icons/artsbuilderexecute.png</file>
         <file>icons/editcopy.png</file>
         <file>icons/editcut.png</file>
         <file>icons/editdelete.png</file>
         <file>icons/editpaste.png</file>
+        <file>icons/fileclose.png</file>
         <file>icons/filenew.png</file>
         <file>icons/fileopen.png</file>
         <file>icons/filesave.png</file>
         <file>icons/fileprint.png</file>
         <file>icons/folder_new.png</file>
         <file>icons/ok.png</file>
         <file>icons/redo.png</file>
         <file>icons/reload.png</file>
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "resource-manager.h"
 #include "workspace-model.h"
 #include "settings-dialog.h"
 #include "ui-settings-dialog.h"
 #include <QSettings>
 #include <QDir>
 #include <QFileInfo>
+#include <QVector>
 
 #ifdef HAVE_QSCINTILLA
 #include <QScrollArea>
 #include "color-picker.h"
 #include <Qsci/qscilexercpp.h>
 #include <Qsci/qscilexerbash.h>
 #include <Qsci/qscilexerperl.h>
 #include <Qsci/qscilexerbatch.h>
@@ -92,16 +93,17 @@ settings_dialog::settings_dialog (QWidge
   ui->showFileType->setChecked (settings->value ("filesdockwidget/showFileType",false).toBool());
   ui->showLastModified->setChecked (settings->value ("filesdockwidget/showLastModified",false).toBool());
   ui->showHiddenFiles->setChecked (settings->value ("filesdockwidget/showHiddenFiles",false).toBool());
   ui->useAlternatingRowColors->setChecked (settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool());
   ui->sync_octave_directory->setChecked (settings->value ("filesdockwidget/sync_octave_directory",true).toBool());
   ui->useProxyServer->setChecked (settings->value ("useProxyServer",false).toBool ());
   ui->proxyHostName->setText (settings->value ("proxyHostName").toString ());
   ui->terminal_cursorBlinking->setChecked (settings->value ("terminal/cursorBlinking",true).toBool ());
+  ui->terminal_cursorUseForegroundColor->setChecked (settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
 
   QString cursorType = settings->value ("terminal/cursorType","ibeam").toString ();
 
   QStringList items;
   items << QString("0") << QString("1") << QString("2");
   ui->terminal_cursorType->addItems(items);
   ui->terminal_cursorType->setItemText (0, "IBeam Cursor");
   ui->terminal_cursorType->setItemText (1, "Block Cursor");
@@ -124,16 +126,19 @@ settings_dialog::settings_dialog (QWidge
 
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
   ui->proxyPassword->setText (settings->value ("proxyPassword").toString ());
 
   // qorkspace colors
   read_workspace_colors (settings);
 
+  // terminal colors
+  read_terminal_colors (settings);
+
 #ifdef HAVE_QSCINTILLA
   // editor styles: create lexer, read settings, and create dialog elements
   QsciLexer *lexer;
   lexer = new lexer_octave_gui ();
   read_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerCPP ();
   read_lexer_settings (lexer,settings);
@@ -145,17 +150,19 @@ settings_dialog::settings_dialog (QWidge
   read_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerDiff ();
   read_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerBash ();
   read_lexer_settings (lexer,settings);
   delete lexer;
-#endif    
+#endif
+
+  ui->tabWidget->setCurrentIndex (settings->value("settings/last_tab",0).toInt ());
 }
 
 settings_dialog::~settings_dialog ()
 {
   delete ui;
 }
 
 
@@ -176,21 +183,21 @@ settings_dialog::get_valid_lexer_styles 
 
 void
 settings_dialog::read_lexer_settings (QsciLexer *lexer, QSettings *settings)
 {
   lexer->readSettings (*settings);
   int styles[MaxLexerStyles];  // array for saving valid styles (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QGridLayout *style_grid = new QGridLayout ();
-  QLabel *description[max_style];
-  QFontComboBox *select_font[max_style];
-  QSpinBox *font_size[max_style];
-  QCheckBox *attrib_font[3][max_style];
-  color_picker *color[max_style];
+  QVector<QLabel*> description (max_style);
+  QVector<QFontComboBox*> select_font (max_style);
+  QVector<QSpinBox*> font_size (max_style);
+  QVector<QCheckBox*> attrib_font (3 * max_style);
+  QVector<color_picker*> color (max_style);
   int default_size = 10;
   QFont default_font = QFont ();
   for (int i = 0; i < max_style; i++)  // create dialog elements for all styles
     {
       QString actual_name = lexer->description (styles[i]);
       QFont   actual_font = lexer->font (styles[i]);
       description[i] = new QLabel (actual_name);
       description[i]->setWordWrap (true);
@@ -212,58 +219,61 @@ settings_dialog::read_lexer_settings (Qs
         {
           select_font[i]->setCurrentFont (actual_font);
           if (actual_font.family () == default_font.family ())
             select_font[i]->setEditText (lexer->description (0));
           font_size[i]->setRange (-4,4);
           font_size[i]->setValue (actual_font.pointSize ()-default_size);
           font_size[i]->setToolTip ("Difference to the defalt size");
         }
-      attrib_font[0][i] = new QCheckBox (tr("b"));
-      attrib_font[1][i] = new QCheckBox (tr("i"));
-      attrib_font[2][i] = new QCheckBox (tr("u"));
-      attrib_font[0][i]->setChecked(Qt::Checked && actual_font.bold ());
-      attrib_font[0][i]->setObjectName (actual_name+"_bold");
-      attrib_font[1][i]->setChecked(Qt::Checked && actual_font.italic ());
-      attrib_font[1][i]->setObjectName (actual_name+"_italic");
-      attrib_font[2][i]->setChecked(Qt::Checked && actual_font.underline ());
-      attrib_font[2][i]->setObjectName (actual_name+"_underline");
+      attrib_font[0+3*i] = new QCheckBox (tr("b"));
+      attrib_font[1+3*i] = new QCheckBox (tr("i"));
+      attrib_font[2+3*i] = new QCheckBox (tr("u"));
+      attrib_font[0+3*i]->setChecked(Qt::Checked && actual_font.bold ());
+      attrib_font[0+3*i]->setObjectName (actual_name+"_bold");
+      attrib_font[1+3*i]->setChecked(Qt::Checked && actual_font.italic ());
+      attrib_font[1+3*i]->setObjectName (actual_name+"_italic");
+      attrib_font[2+3*i]->setChecked(Qt::Checked && actual_font.underline ());
+      attrib_font[2+3*i]->setObjectName (actual_name+"_underline");
       color[i] = new color_picker (lexer->color (styles[i]));
       color[i]->setObjectName (actual_name+"_color");
       int column = 1;
-      style_grid->addWidget (description[i],   i,column++);
-      style_grid->addWidget (select_font[i],   i,column++);
-      style_grid->addWidget (font_size[i],     i,column++);
-      style_grid->addWidget (attrib_font[0][i],i,column++);
-      style_grid->addWidget (attrib_font[1][i],i,column++);
-      style_grid->addWidget (attrib_font[2][i],i,column++);
-      style_grid->addWidget (color[i],         i,column++);
+      style_grid->addWidget (description[i],     i, column++);
+      style_grid->addWidget (select_font[i],     i, column++);
+      style_grid->addWidget (font_size[i],       i, column++);
+      style_grid->addWidget (attrib_font[0+3*i], i, column++);
+      style_grid->addWidget (attrib_font[1+3*i], i, column++);
+      style_grid->addWidget (attrib_font[2+3*i], i, column++);
+      style_grid->addWidget (color[i],           i, column++);
     }
   // place grid with elements into the tab
   QScrollArea *scroll_area = new QScrollArea ();
   QWidget *scroll_area_contents = new QWidget ();
   scroll_area_contents->setObjectName (QString (lexer->language ())+"_styles");
   scroll_area_contents->setLayout (style_grid);
   scroll_area->setWidget (scroll_area_contents);
   ui->tabs_editor_styles->addTab (scroll_area,lexer->language ());
+
+  ui->tabs_editor_styles->setCurrentIndex (
+          settings->value("settings/last_editor_styles_tab",0).toInt ());
 }
 #endif  
 
 void
 settings_dialog::read_workspace_colors (QSettings *settings)
 {
 
   QList<QColor> default_colors = resource_manager::storage_class_default_colors ();
   QStringList class_names = resource_manager::storage_class_names ();
   QString class_chars = resource_manager::storage_class_chars ();
   int nr_of_classes = class_chars.length ();
 
   QGridLayout *style_grid = new QGridLayout ();
-  QLabel *description[nr_of_classes];
-  color_picker *color[nr_of_classes];
+  QVector<QLabel*> description (nr_of_classes);
+  QVector<color_picker*> color (nr_of_classes);
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel (class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
@@ -280,16 +290,53 @@ settings_dialog::read_workspace_colors (
           column = 0;
         }
     }
 
   // place grid with elements into the tab
   ui->workspace_colors_box->setLayout (style_grid);
 }
 
+void
+settings_dialog::read_terminal_colors (QSettings *settings)
+{
+
+  QList<QColor> default_colors = resource_manager::terminal_default_colors ();
+  QStringList class_names = resource_manager::terminal_color_names ();
+  QString class_chars = resource_manager::terminal_color_chars ();
+  int nr_of_classes = class_chars.length ();
+
+  QGridLayout *style_grid = new QGridLayout ();
+  QVector<QLabel*> description (nr_of_classes);
+  QVector<color_picker*> color (nr_of_classes);
+
+  int column = 0;
+  int row = 0;
+  for (int i = 0; i < nr_of_classes; i++)
+    {
+      description[i] = new QLabel (class_names.at (i));
+      description[i]->setAlignment (Qt::AlignRight);
+      QVariant default_var = default_colors.at (i);
+      QColor setting_color = settings->value ("terminal/color_"+class_chars.mid (i,1),
+                                              default_var).value<QColor> ();
+      color[i] = new color_picker (setting_color);
+      color[i]->setObjectName ("terminal_color_"+class_chars.mid (i,1));
+      color[i]->setMinimumSize (30,10);
+      style_grid->addWidget (description[i], row,2*column);
+      style_grid->addWidget (color[i],       row,2*column+1);
+      if (++column == 2)
+        {
+          row++;
+          column = 0;
+        }
+    }
+
+  // place grid with elements into the tab
+  ui->terminal_colors_box->setLayout (style_grid);
+}
 
 void
 settings_dialog::write_changed_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
   // FIXME -- what should happen if settings is 0?
 
   // the icon set
@@ -325,16 +372,17 @@ settings_dialog::write_changed_settings 
   settings->setValue ("filesdockwidget/sync_octave_directory", ui->sync_octave_directory->isChecked ());
   settings->setValue ("useProxyServer", ui->useProxyServer->isChecked ());
   settings->setValue ("proxyType", ui->proxyType->currentText ());
   settings->setValue ("proxyHostName", ui->proxyHostName->text ());
   settings->setValue ("proxyPort", ui->proxyPort->text ());
   settings->setValue ("proxyUserName", ui->proxyUserName->text ());
   settings->setValue ("proxyPassword", ui->proxyPassword->text ());
   settings->setValue ("terminal/cursorBlinking", ui->terminal_cursorBlinking->isChecked ());
+  settings->setValue ("terminal/cursorUseForegroundColor", ui->terminal_cursorUseForegroundColor->isChecked ());
 
   // the cursor
   QString cursorType;
   switch (ui->terminal_cursorType->currentIndex ())
     {
     case 0: cursorType = "ibeam"; break;
     case 1: cursorType = "block"; break;
     case 2: cursorType = "underline";  break;
@@ -361,16 +409,20 @@ settings_dialog::write_changed_settings 
   write_lexer_settings (lexer,settings);
   delete lexer;
   lexer = new QsciLexerBash ();
   write_lexer_settings (lexer,settings);
   delete lexer;
 #endif
 
   write_workspace_colors (settings);
+
+  write_terminal_colors (settings);
+
+  settings->setValue("settings/last_tab",ui->tabWidget->currentIndex ());
 }
 
 #ifdef HAVE_QSCINTILLA
 void
 settings_dialog::write_lexer_settings (QsciLexer *lexer, QSettings *settings)
 {
   QWidget *tab = ui->tabs_editor_styles->
             findChild <QWidget *>(QString (lexer->language ())+"_styles");
@@ -419,16 +471,19 @@ settings_dialog::write_lexer_settings (Q
         new_font.setUnderline (attrib_font[2]->isChecked ());
       lexer->setFont (new_font,styles[i]);
       if (styles[i] == 0)
         lexer->setDefaultFont (new_font);
       if (color)
         lexer->setColor (color->color (),styles[i]);
     }
   lexer->writeSettings (*settings);
+
+  settings->setValue (
+    "settings/last_editor_styles_tab",ui->tabs_editor_styles->currentIndex ());
 }
 #endif
 
 void
 settings_dialog::write_workspace_colors (QSettings *settings)
 {
 
   QString class_chars = resource_manager::storage_class_chars ();
@@ -439,8 +494,25 @@ settings_dialog::write_workspace_colors 
       color = ui->workspace_colors_box->findChild <color_picker *>(
                             "color_"+class_chars.mid (i,1));
       if (color)
         settings->setValue ("workspaceview/color_"+class_chars.mid (i,1),
                             color->color ());
     }
   settings->sync ();
 }
+
+void
+settings_dialog::write_terminal_colors (QSettings *settings)
+{
+  QString class_chars = resource_manager::terminal_color_chars ();
+  color_picker *color;
+
+  for (int i = 0; i < class_chars.length (); i++)
+    {
+      color = ui->terminal_colors_box->findChild <color_picker *>(
+                            "terminal_color_"+class_chars.mid (i,1));
+      if (color)
+        settings->setValue ("terminal/color_"+class_chars.mid (i,1),
+                            color->color ());
+    }
+  settings->sync ();
+}
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -47,11 +47,14 @@ private:
   void write_lexer_settings (QsciLexer *lexer, QSettings *settings);
   int  get_valid_lexer_styles (QsciLexer *lexer, int styles[]);
   enum { MaxLexerStyles = 64,
          MaxStyleNumber = 128 };
 #endif
 
   void read_workspace_colors (QSettings *settings);
   void write_workspace_colors (QSettings *settings);
+
+  void read_terminal_colors (QSettings *settings);
+  void write_terminal_colors (QSettings *settings);
 };
 
 #endif // SETTINGSDIALOG_H
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -27,17 +27,17 @@
   </property>
   <property name="windowTitle">
    <string>Settings</string>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QTabWidget" name="tabWidget">
      <property name="currentIndex">
-      <number>0</number>
+      <number>3</number>
      </property>
      <widget class="QWidget" name="tab_4">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <attribute name="title">
        <string>General</string>
       </attribute>
@@ -312,136 +312,177 @@
         </rect>
        </property>
       </widget>
      </widget>
      <widget class="QWidget" name="tab_5">
       <attribute name="title">
        <string>Terminal</string>
       </attribute>
-      <layout class="QVBoxLayout" name="verticalLayout">
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_5">
-         <item>
-          <widget class="QLabel" name="label_11">
-           <property name="text">
-            <string>Font</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QFontComboBox" name="terminal_fontName">
-           <property name="editable">
-            <bool>false</bool>
-           </property>
-           <property name="fontFilters">
-            <set>QFontComboBox::MonospacedFonts</set>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="label_12">
-           <property name="text">
-            <string>Font Size</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QSpinBox" name="terminal_fontSize">
-           <property name="minimum">
-            <number>2</number>
-           </property>
-           <property name="maximum">
-            <number>96</number>
-           </property>
-           <property name="value">
-            <number>10</number>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <spacer name="horizontalSpacer_5">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-        </layout>
-       </item>
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_3">
-         <item>
-          <widget class="QLabel" name="label">
-           <property name="text">
-            <string>Cursor type:</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QComboBox" name="terminal_cursorType"/>
-         </item>
-         <item>
-          <spacer name="horizontalSpacer">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-        </layout>
-       </item>
-       <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_2">
-         <item>
-          <widget class="QCheckBox" name="terminal_cursorBlinking">
-           <property name="text">
-            <string>Cursor blinking</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <spacer name="horizontalSpacer_2">
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-           <property name="sizeHint" stdset="0">
-            <size>
-             <width>40</width>
-             <height>20</height>
-            </size>
-           </property>
-          </spacer>
-         </item>
-        </layout>
-       </item>
-       <item>
-        <spacer name="verticalSpacer_3">
-         <property name="orientation">
-          <enum>Qt::Vertical</enum>
-         </property>
-         <property name="sizeHint" stdset="0">
-          <size>
-           <width>20</width>
-           <height>321</height>
-          </size>
-         </property>
-        </spacer>
-       </item>
-      </layout>
+      <widget class="QWidget" name="horizontalLayoutWidget">
+       <property name="geometry">
+        <rect>
+         <x>10</x>
+         <y>50</y>
+         <width>631</width>
+         <height>31</height>
+        </rect>
+       </property>
+       <layout class="QHBoxLayout" name="horizontalLayout_3">
+        <item>
+         <widget class="QLabel" name="label">
+          <property name="text">
+           <string>Cursor type:</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QComboBox" name="terminal_cursorType"/>
+        </item>
+        <item>
+         <spacer name="horizontalSpacer">
+          <property name="orientation">
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" stdset="0">
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+        <item>
+         <widget class="QCheckBox" name="terminal_cursorBlinking">
+          <property name="text">
+           <string>Cursor blinking</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QCheckBox" name="terminal_cursorUseForegroundColor">
+          <property name="text">
+           <string>Use Foreground Color</string>
+          </property>
+         </widget>
+        </item>
+       </layout>
+      </widget>
+      <widget class="QWidget" name="verticalLayoutWidget_2">
+       <property name="geometry">
+        <rect>
+         <x>10</x>
+         <y>90</y>
+         <width>631</width>
+         <height>164</height>
+        </rect>
+       </property>
+       <layout class="QVBoxLayout" name="verticalLayout">
+        <item>
+         <widget class="QGroupBox" name="terminal_colors_box">
+          <property name="minimumSize">
+           <size>
+            <width>0</width>
+            <height>162</height>
+           </size>
+          </property>
+          <property name="title">
+           <string>Terminal Colors</string>
+          </property>
+         </widget>
+        </item>
+       </layout>
+      </widget>
+      <widget class="QWidget" name="verticalLayoutWidget_3">
+       <property name="geometry">
+        <rect>
+         <x>10</x>
+         <y>260</y>
+         <width>631</width>
+         <height>121</height>
+        </rect>
+       </property>
+       <layout class="QVBoxLayout" name="verticalLayout_8">
+        <item>
+         <spacer name="verticalSpacer_3">
+          <property name="orientation">
+           <enum>Qt::Vertical</enum>
+          </property>
+          <property name="sizeHint" stdset="0">
+           <size>
+            <width>20</width>
+            <height>40</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </widget>
+      <widget class="QWidget" name="layoutWidget">
+       <property name="geometry">
+        <rect>
+         <x>10</x>
+         <y>10</y>
+         <width>631</width>
+         <height>30</height>
+        </rect>
+       </property>
+       <layout class="QHBoxLayout" name="horizontalLayout_5">
+        <item>
+         <widget class="QLabel" name="label_11">
+          <property name="text">
+           <string>Font</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QFontComboBox" name="terminal_fontName">
+          <property name="editable">
+           <bool>false</bool>
+          </property>
+          <property name="fontFilters">
+           <set>QFontComboBox::MonospacedFonts</set>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QLabel" name="label_12">
+          <property name="text">
+           <string>Font Size</string>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <widget class="QSpinBox" name="terminal_fontSize">
+          <property name="minimum">
+           <number>2</number>
+          </property>
+          <property name="maximum">
+           <number>96</number>
+          </property>
+          <property name="value">
+           <number>10</number>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <spacer name="horizontalSpacer_5">
+          <property name="orientation">
+           <enum>Qt::Horizontal</enum>
+          </property>
+          <property name="sizeHint" stdset="0">
+           <size>
+            <width>40</width>
+            <height>20</height>
+           </size>
+          </property>
+         </spacer>
+        </item>
+       </layout>
+      </widget>
      </widget>
      <widget class="QWidget" name="tab_2">
       <attribute name="title">
        <string>File Browser</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <item>
         <widget class="QCheckBox" name="showFileSize">
@@ -508,16 +549,22 @@
        <property name="geometry">
         <rect>
          <x>19</x>
          <y>19</y>
          <width>631</width>
          <height>81</height>
         </rect>
        </property>
+       <property name="minimumSize">
+        <size>
+         <width>0</width>
+         <height>81</height>
+        </size>
+       </property>
        <property name="title">
         <string>Storage Class Colors</string>
        </property>
       </widget>
      </widget>
      <widget class="QWidget" name="tab_3">
       <attribute name="title">
        <string>Network</string>
diff --git a/libgui/src/terminal-dock-widget.cc b/libgui/src/terminal-dock-widget.cc
--- a/libgui/src/terminal-dock-widget.cc
+++ b/libgui/src/terminal-dock-widget.cc
@@ -33,19 +33,16 @@ terminal_dock_widget::terminal_dock_widg
   terminal->setObjectName ("OctaveTerminal");
   terminal->setFocusPolicy (Qt::StrongFocus);
 
   setObjectName ("TerminalDockWidget");
   setWindowIcon (QIcon(":/actions/icons/logo.png"));
   setWindowTitle (tr ("Command Window"));
   setWidget (terminal);
 
-  connect (parent (), SIGNAL (settings_changed (const QSettings *)),
-           this, SLOT (notice_settings (const QSettings *)));
-
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility (bool)));
 
   // Forward signals to QTerminal widget.
 
   connect (this, SIGNAL (notice_settings_signal (const QSettings *)),
            terminal, SLOT (notice_settings (const QSettings *)));
 
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -73,19 +73,16 @@ workspace_view::workspace_view (QWidget 
   // Connect signals and slots.
 
   connect (view, SIGNAL (customContextMenuRequested (const QPoint&)),
            this, SLOT(contextmenu_requested (const QPoint&)));
 
   connect (this, SIGNAL (command_requested (const QString&)),
            p, SLOT (execute_command_in_terminal (const QString&)));
 
-  connect (parent (), SIGNAL (settings_changed (const QSettings *)),
-           this, SLOT (notice_settings (const QSettings *)));
-
 }
 
 workspace_view::~workspace_view (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   settings->setValue("workspaceview/column_state",
                      view->horizontalHeader ()->saveState ());
diff --git a/libinterp/interpfcn/debug.cc b/libinterp/interpfcn/debug.cc
--- a/libinterp/interpfcn/debug.cc
+++ b/libinterp/interpfcn/debug.cc
@@ -311,42 +311,100 @@ bp_table::do_add_breakpoint (const std::
   intmap retval;
 
   octave_user_code *dbg_fcn = get_user_code (fname);
 
   if (dbg_fcn)
     {
       if (! do_add_breakpoint_1 (dbg_fcn, fname, line, retval))
         {
-          typedef std::map<std::string, octave_value>::const_iterator
-            subfunction_map_const_iterator;
+          // Search subfunctions in the order they appear in the file.
+
+          const std::list<std::string> subfcn_names
+            = dbg_fcn->subfunction_names ();
 
           std::map<std::string, octave_value> subfcns
             = dbg_fcn->subfunctions ();
 
-          for (subfunction_map_const_iterator p = subfcns.begin ();
-               p != subfcns.end (); p++)
+          for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
+               p != subfcn_names.end (); p++)
             {
-              octave_user_code *dbg_subfcn = p->second.user_code_value ();
+              std::map<std::string, octave_value>::const_iterator
+                q = subfcns.find (*p);
 
-              if (do_add_breakpoint_1 (dbg_subfcn, fname, line, retval))
-                break;
+              if (q != subfcns.end ())
+                {
+                  octave_user_code *dbg_subfcn = q->second.user_code_value ();
+
+                  if (do_add_breakpoint_1 (dbg_subfcn, fname, line, retval))
+                    break;
+                }
             }
         }
     }
   else
     error ("add_breakpoint: unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 int
+bp_table::do_remove_breakpoint_1 (octave_user_code *fcn,
+                                  const std::string& fname,
+                                  const bp_table::intmap& line)
+{
+  int retval = 0;
+
+  std::string file = fcn->fcn_file_name ();
+
+  tree_statement_list *cmds = fcn->body ();
+
+  // FIXME -- move the operation on cmds to the
+  // tree_statement_list class?
+
+  if (cmds)
+    {
+      octave_value_list results = cmds->list_breakpoints ();
+
+      if (results.length () > 0)
+        {
+          octave_idx_type len = line.size ();
+
+          for (int i = 0; i < len; i++)
+            {
+              const_intmap_iterator p = line.find (i);
+
+              if (p != line.end ())
+                {
+                  int lineno = p->second;
+
+                  cmds->delete_breakpoint (lineno);
+
+                  if (! file.empty ())
+                    octave_link::update_breakpoint (false, file, lineno);
+                }
+            }
+
+          results = cmds->list_breakpoints ();
+
+          bp_set_iterator it = bp_set.find (fname);
+          if (results.length () == 0 && it != bp_set.end ())
+            bp_set.erase (it);
+        }
+
+      retval = results.length ();
+    }
+
+  return retval;
+}
+
+int
 bp_table::do_remove_breakpoint (const std::string& fname,
                                 const bp_table::intmap& line)
 {
   int retval = 0;
 
   octave_idx_type len = line.size ();
 
   if (len == 0)
@@ -355,84 +413,99 @@ bp_table::do_remove_breakpoint (const st
       retval = results.size ();
     }
   else
     {
       octave_user_code *dbg_fcn = get_user_code (fname);
 
       if (dbg_fcn)
         {
-          std::string file = dbg_fcn->fcn_file_name ();
+          retval = do_remove_breakpoint_1 (dbg_fcn, fname, line);
 
-          tree_statement_list *cmds = dbg_fcn->body ();
+          // Search subfunctions in the order they appear in the file.
 
-          // FIXME -- move the operation on cmds to the
-          // tree_statement_list class?
-          if (cmds)
-            {
-              octave_value_list results = cmds->list_breakpoints ();
+          const std::list<std::string> subfcn_names
+            = dbg_fcn->subfunction_names ();
 
-              if (results.length () > 0)
-                {
-                  for (int i = 0; i < len; i++)
-                    {
-                      const_intmap_iterator p = line.find (i);
+          std::map<std::string, octave_value> subfcns
+            = dbg_fcn->subfunctions ();
 
-                      if (p != line.end ())
-                        {
-                          int lineno = p->second;
-
-                          cmds->delete_breakpoint (lineno);
+          for (std::list<std::string>::const_iterator p = subfcn_names.begin ();
+               p != subfcn_names.end (); p++)
+            {
+              std::map<std::string, octave_value>::const_iterator
+                q = subfcns.find (*p);
 
-                          if (! file.empty ())
-                            octave_link::update_breakpoint (false, file, lineno);
-                        }
-                    }
-
-                  results = cmds->list_breakpoints ();
+              if (q != subfcns.end ())
+                {
+                  octave_user_code *dbg_subfcn = q->second.user_code_value ();
 
-                  bp_set_iterator it = bp_set.find (fname);
-                  if (results.length () == 0 && it != bp_set.end ())
-                    bp_set.erase (it);
+                  retval += do_remove_breakpoint_1 (dbg_subfcn, fname, line);
                 }
-
-              retval = results.length ();
             }
         }
       else
         error ("remove_breakpoint: unable to find the requested function\n");
     }
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
+bp_table::intmap
+bp_table::do_remove_all_breakpoints_in_file_1 (octave_user_code *fcn,
+                                               const std::string& fname)
+{
+  intmap retval;
+
+  std::string file = fcn->fcn_file_name ();
+
+  tree_statement_list *cmds = fcn->body ();
+
+  if (cmds)
+    {
+      retval = cmds->remove_all_breakpoints (file);
+
+      bp_set_iterator it = bp_set.find (fname);
+      if (it != bp_set.end ())
+        bp_set.erase (it);
+    }
+
+  return retval;
+}
 
 bp_table::intmap
 bp_table::do_remove_all_breakpoints_in_file (const std::string& fname,
                                              bool silent)
 {
   intmap retval;
 
   octave_user_code *dbg_fcn = get_user_code (fname);
 
   if (dbg_fcn)
     {
-      std::string file = dbg_fcn->fcn_file_name ();
+      retval = do_remove_all_breakpoints_in_file_1 (dbg_fcn, fname);
+
+      // Order is not important here.
 
-      tree_statement_list *cmds = dbg_fcn->body ();
+      typedef std::map<std::string, octave_value>::const_iterator
+        subfcns_const_iterator;
 
-      if (cmds)
+      std::map<std::string, octave_value> subfcns = dbg_fcn->subfunctions ();
+
+      for (subfcns_const_iterator p = subfcns.begin ();
+           p != subfcns.end (); p++)
         {
-          retval = cmds->remove_all_breakpoints (file);
+          octave_user_code *dbg_subfcn = p->second.user_code_value ();
 
-          bp_set_iterator it = bp_set.find (fname);
-          if (it != bp_set.end ())
-            bp_set.erase (it);
+          intmap tmp = do_remove_all_breakpoints_in_file_1 (dbg_subfcn, fname);
+
+          // Merge new list with retval.
+          retval.insert (tmp.begin (), tmp.end ());
         }
     }
   else if (! silent)
     error ("remove_all_breakpoint_in_file: "
            "unable to find the requested function\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
diff --git a/libinterp/interpfcn/debug.h b/libinterp/interpfcn/debug.h
--- a/libinterp/interpfcn/debug.h
+++ b/libinterp/interpfcn/debug.h
@@ -115,18 +115,24 @@ private:
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   bool do_add_breakpoint_1 (octave_user_code *fcn, const std::string& fname,
                             const intmap& line, intmap& retval);
 
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines);
 
+  int do_remove_breakpoint_1 (octave_user_code *fcn, const std::string&,
+                              const intmap& lines);
+
   int do_remove_breakpoint (const std::string&, const intmap& lines);
 
+  intmap do_remove_all_breakpoints_in_file_1 (octave_user_code *fcn,
+                                              const std::string& fname);
+
   intmap do_remove_all_breakpoints_in_file (const std::string& fname,
                                             bool silent);
 
   void do_remove_all_breakpoints (void);
 
   fname_line_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
diff --git a/libinterp/interpfcn/load-save.h b/libinterp/interpfcn/load-save.h
--- a/libinterp/interpfcn/load-save.h
+++ b/libinterp/interpfcn/load-save.h
@@ -78,17 +78,17 @@ read_binary_file_header (std::istream& i
                          bool quiet = false);
 
 extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
          load_save_format format, oct_mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
          const string_vector& argv, int argv_idx, int argc, int nargout);
 
-extern bool is_octave_data_file (const std::string& file);
+extern OCTINTERP_API bool is_octave_data_file (const std::string& file);
 
 extern void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
diff --git a/libinterp/interpfcn/octave-link.h b/libinterp/interpfcn/octave-link.h
--- a/libinterp/interpfcn/octave-link.h
+++ b/libinterp/interpfcn/octave-link.h
@@ -36,17 +36,19 @@ class workspace_element;
 // \class OctaveLink
 // \brief Provides threadsafe access to octave.
 // \author Jacob Dawid
 //
 // This class is a wrapper around octave and provides thread safety by
 // buffering access operations to octave and executing them in the
 // readline event hook, which lives in the octave thread.
 
-class octave_link
+class
+OCTINTERP_API
+octave_link
 {
 protected:
 
   octave_link (void);
 
 public:
 
   virtual ~octave_link (void) { }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -129,16 +129,28 @@ public:
   }
 
   bool islocked (void) const { return locked; }
 
   virtual void lock_subfunctions (void) { }
 
   virtual void unlock_subfunctions (void) { }
 
+  virtual void maybe_relocate_end (void) { }
+
+  // Not valid until after the function is completley parsed.
+  virtual bool has_subfunctions (void) const { return false; }
+
+  virtual void stash_subfunction_names (const std::list<std::string>&) { }
+
+  virtual std::list<std::string> subfunction_names (void) const
+  {
+    return std::list<std::string> ();
+  }
+
   void mark_relative (void) { relative = true; }
 
   bool is_relative (void) const { return relative; }
 
   std::string name (void) const { return my_name; }
 
   void document (const std::string& ds) { doc = ds; }
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -243,16 +243,80 @@ octave_user_function::define_ret_list (t
 }
 
 void
 octave_user_function::stash_fcn_file_name (const std::string& nm)
 {
   file_name = nm;
 }
 
+// If there is no explicit end statement at the end of the function,
+// relocate the no_op that was generated for the end of file condition
+// to appear on the next line after the last statement in the file, or
+// the next line after the function keyword if there are no statements.
+// More precisely, the new location should probably be on the next line
+// after the end of the parameter list, but we aren't tracking that
+// information (yet).
+
+void
+octave_user_function::maybe_relocate_end_internal (void)
+{
+  if (cmd_list && ! cmd_list->empty ())
+    {
+      tree_statement *last_stmt = cmd_list->back ();
+
+      if (last_stmt && last_stmt->is_end_of_fcn_or_script ()
+          && last_stmt->is_end_of_file ())
+        {
+          tree_statement_list::reverse_iterator
+            next_to_last_elt = cmd_list->rbegin ();
+
+          next_to_last_elt++;
+
+          int new_eof_line;
+          int new_eof_col;
+
+          if (next_to_last_elt == cmd_list->rend ())
+            {
+              new_eof_line = beginning_line ();
+              new_eof_col = beginning_column ();
+            }
+          else
+            {
+              tree_statement *next_to_last_stmt = *next_to_last_elt;
+
+              new_eof_line = next_to_last_stmt->line ();
+              new_eof_col = next_to_last_stmt->column ();
+            }
+
+          last_stmt->set_location (new_eof_line + 1, new_eof_col);
+        }
+    }
+}
+
+void
+octave_user_function::maybe_relocate_end (void)
+{
+  std::map<std::string, octave_value> fcns = subfunctions ();
+
+  if (! fcns.empty ())
+    {
+      for (std::map<std::string, octave_value>::iterator p = fcns.begin ();
+           p != fcns.end (); p++)
+        {
+          octave_user_function *f = (p->second).user_function_value ();
+
+          if (f)
+            f->maybe_relocate_end_internal ();
+        }
+    }
+
+  maybe_relocate_end_internal ();
+}
+
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
 
   if (is_inline_function ())
     result << "inline@" << fcn_file_name ()
            << ":" << location_line << ":" << location_column;
@@ -315,16 +379,29 @@ octave_user_function::unlock_subfunction
 }
 
 std::map<std::string, octave_value>
 octave_user_function::subfunctions (void) const
 {
   return symbol_table::subfunctions_defined_in_scope (local_scope);
 }
 
+bool
+octave_user_function::has_subfunctions (void) const
+{
+  return ! subfcn_names.empty ();
+}
+
+void
+octave_user_function::stash_subfunction_names
+  (const std::list<std::string>& names)
+{
+  subfcn_names = names;
+}
+
 octave_value_list
 octave_user_function::all_va_args (const octave_value_list& args)
 {
   octave_value_list retval;
 
   octave_idx_type n = args.length () - num_named_args;
 
   if (n > 0)
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -203,16 +203,30 @@ public:
   void stash_fcn_file_name (const std::string& nm);
 
   void stash_fcn_location (int line, int col)
     {
       location_line = line;
       location_column = col;
     }
 
+  int beginning_line (void) const { return location_line; }
+  int beginning_column (void) const { return location_column; }
+
+  void stash_fcn_end_location (int line, int col)
+    {
+      end_location_line = line;
+      end_location_column = col;
+    }
+
+  int ending_line (void) const { return end_location_line; }
+  int ending_column (void) const { return end_location_column; }
+
+  void maybe_relocate_end (void);
+
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
   void stash_parent_fcn_scope (symbol_table::scope_id ps) { parent_scope = ps; }
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
@@ -261,16 +275,25 @@ public:
     }
 
   void lock_subfunctions (void);
 
   void unlock_subfunctions (void);
 
   std::map<std::string, octave_value> subfunctions (void) const;
 
+  bool has_subfunctions (void) const;
+
+  void stash_subfunction_names (const std::list<std::string>& names);
+
+  std::list<std::string> subfunction_names (void) const
+  {
+    return subfcn_names;
+  }
+
   octave_value_list all_va_args (const octave_value_list& args);
 
   void stash_function_name (const std::string& s) { my_name = s; }
 
   void mark_as_subfunction (void) { subfunction = true; }
 
   bool is_subfunction (void) const { return subfunction; }
 
@@ -401,20 +424,26 @@ private:
   octave_comment_list *trail_comm;
 
   // The name of the file we parsed.
   std::string file_name;
 
   // Location where this function was defined.
   int location_line;
   int location_column;
+  int end_location_line;
+  int end_location_column;
 
   // The name of the parent function, if any.
   std::string parent_name;
 
+  // The list of subfunctions (if any) in the order they appear in the
+  // file.
+  std::list<std::string> subfcn_names;
+
   // The time the file was parsed.
   octave_time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   octave_time t_checked;
 
   // True if this function came from a file that is considered to be a
@@ -453,16 +482,18 @@ private:
 
   // pointer to the current unwind_protect frame of this function.
   unwind_protect *curr_unwind_protect_frame;
 
 #ifdef HAVE_LLVM
   jit_function_info *jit_info;
 #endif
 
+  void maybe_relocate_end_internal (void);
+
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
                             int nargout, const octave_value_list& va_args,
                             const std::list<octave_lvalue> *lvalue_list);
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -214,24 +214,26 @@ make_statement (T *arg)
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
 %token <tok_val> GLOBAL PERSISTENT
 %token <tok_val> FCN_HANDLE
 %token <tok_val> PROPERTIES METHODS EVENTS ENUMERATION
 %token <tok_val> METAQUERY
 %token <tok_val> SUPERCLASSREF
 %token <tok_val> GET SET
+%token <tok_val> FCN
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
-%token FCN INPUT_FILE CLASSDEF
+%token INPUT_FILE CLASSDEF
 // %token VARARGIN VARARGOUT
 
 // Nonterminals we construct.
-%type <comment_type> stash_comment function_beg classdef_beg
+%type <tok_val> function_beg
+%type <comment_type> stash_comment classdef_beg
 %type <comment_type> properties_beg methods_beg events_beg enum_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl nl opt_nl sep opt_sep
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
@@ -1114,48 +1116,50 @@ return_list1    : identifier
 // Script or function file
 // =======================
 
 file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
                     if (! lexer.reading_fcn_file)
                       {
                         tree_statement *end_of_script
-                          = parser.make_end ("endscript",
-                                                  lexer.input_line_number,
-                                                  lexer.current_input_column);
+                          = parser.make_end ("endscript", true,
+                                             lexer.input_line_number,
+                                             lexer.current_input_column);
 
                         parser.make_script ($3, end_of_script);
                       }
 
                     $$ = 0;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
 
-function_beg    : push_fcn_symtab FCN stash_comment
+function_beg    : push_fcn_symtab FCN
                   {
-                    $$ = $3;
+                    $$ = $2;
                     if (lexer.reading_classdef_file
                         || lexer.parsing_classdef)
                       lexer.maybe_classdef_get_set_method = true;
                   }
                 ;
 
-function        : function_beg function1
+function        : function_beg stash_comment function1
                   {
-                    $$ = parser.finish_function (0, $2, $1);
+                    $$ = parser.finish_function (0, $3, $2, $1->line (),
+                                                 $1->column ());
                     parser.recover_from_parsing_function ();
                   }
-                | function_beg return_list '=' function1
+                | function_beg stash_comment return_list '=' function1
                   {
-                    $$ = parser.finish_function ($2, $4, $1);
+                    $$ = parser.finish_function ($3, $5, $2, $1->line (),
+                                                 $1->column ());
                     parser.recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
@@ -1194,17 +1198,18 @@ function2       : param_list opt_sep opt
                 | opt_sep opt_list function_end
                   { $$ = parser.start_function (0, $2, $3); }
                 ;
 
 function_end    : END
                   {
                     parser.endfunction_found = true;
                     if (parser.end_token_ok ($1, token::function_end))
-                      $$ = parser.make_end ("endfunction", $1->line (), $1->column ());
+                      $$ = parser.make_end ("endfunction", false,
+                                            $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (lexer.reading_script_file)
 //                    {
@@ -1228,19 +1233,19 @@ function_end    : END
                       }
 
                     if (lexer.reading_classdef_file)
                       {
                         parser.bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = parser.make_end ("endfunction",
-                                                lexer.input_line_number,
-                                                lexer.current_input_column);
+                    $$ = parser.make_end ("endfunction", true,
+                                          lexer.input_line_number,
+                                          lexer.current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF stash_comment
@@ -1250,17 +1255,18 @@ classdef_beg    : CLASSDEF stash_comment
                   }
                 ;
 
 classdef_end    : END
                   {
                     lexer.parsing_classdef = false;
 
                     if (parser.end_token_ok ($1, token::classdef_end))
-                      $$ = parser.make_end ("endclassdef", $1->line (), $1->column ());
+                      $$ = parser.make_end ("endclassdef", false,
+                                            $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 classdef1       : classdef_beg opt_attr_list identifier opt_superclasses
                   { $$ = 0; }
                 ;
@@ -1489,16 +1495,17 @@ octave_base_parser::reset (void)
   fcn_file_from_relative_lookup = false;
   parsing_subfunctions = false;
   max_fcn_depth = 0;
   curr_fcn_depth = 0;
   primary_fcn_scope = -1;
   curr_class_name = "";
   function_scopes.clear ();
   primary_fcn_ptr  = 0;
+  subfunction_names.clear ();
 
   delete stmt_list;
   stmt_list = 0;
 
   lexer.reset ();
 }
 
 // Error mesages for mismatched end tokens.
@@ -2593,25 +2600,27 @@ octave_base_parser::start_function (tree
     = new octave_user_function (lexer.symtab_context.curr_scope (),
                                 param_list, 0, body);
 
   if (fcn)
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
       fcn->stash_trailing_comment (tc);
+      fcn->stash_fcn_end_location (end_fcn_stmt->line (),
+                                   end_fcn_stmt->column ());
     }
 
   return fcn;
 }
 
 tree_statement *
-octave_base_parser::make_end (const std::string& type, int l, int c)
+octave_base_parser::make_end (const std::string& type, bool eof, int l, int c)
 {
-  return make_statement (new tree_no_op_command (type, l, c));
+  return make_statement (new tree_no_op_command (type, eof, l, c));
 }
 
 // Do most of the work for defining a function.
 
 octave_user_function *
 octave_base_parser::frob_function (const std::string& fname,
                                    octave_user_function *fcn)
 {
@@ -2690,18 +2699,16 @@ octave_base_parser::frob_function (const
            && lexer.reading_script_file
            && lexer.fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), lexer.fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (lexer.input_line_number,
-                           lexer.current_input_column);
 
   if (! lexer.help_text.empty () && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (lexer.help_text);
 
       lexer.help_text = "";
     }
@@ -2711,17 +2718,18 @@ octave_base_parser::frob_function (const
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
 
 tree_function_def *
 octave_base_parser::finish_function (tree_parameter_list *ret_list,
                                      octave_user_function *fcn,
-                                     octave_comment_list *lc)
+                                     octave_comment_list *lc,
+                                     int l, int c)
 {
   tree_function_def *retval = 0;
 
   if (ret_list)
     ret_list->mark_as_formal_parameters ();
 
   if (fcn)
     {
@@ -2737,16 +2745,19 @@ octave_base_parser::finish_function (tre
       if (lc)
         fcn->stash_leading_comment (lc);
 
       fcn->define_ret_list (ret_list);
 
       if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
           fcn->mark_as_subfunction ();
+          fcn->stash_fcn_location (l, c);
+
+          subfunction_names.push_back (nm);
 
           if (endfunction_found && function_scopes.size () > 1)
             {
               symbol_table::scope_id pscope
                 = function_scopes[function_scopes.size ()-2];
 
               symbol_table::install_nestfunction (nm, octave_value (fcn),
                                                   pscope);
@@ -3296,16 +3307,29 @@ parse_fcn_file (const std::string& full_
 
       parser.lexer.fcn_file_name = file;
       parser.lexer.fcn_file_full_name = full_file;
 
       int status = parser.run ();
 
       fcn_ptr = parser.primary_fcn_ptr;
 
+      if (fcn_ptr)
+        {
+          fcn_ptr->maybe_relocate_end ();
+
+          if (parser.parsing_subfunctions)
+            {
+              if (! parser.endfunction_found)
+                parser.subfunction_names.reverse ();
+
+              fcn_ptr->stash_subfunction_names (parser.subfunction_names);
+            }
+        }
+
       if (status != 0)
         error ("parse error while reading file %s", full_file.c_str ());
     }
   else if (require_file)
     error ("no such file, '%s'", full_file.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file '%s'", warn_for.c_str (),
            full_file.c_str ());
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -131,17 +131,17 @@ octave_base_parser
 public:
 
   octave_base_parser (octave_base_lexer& lxr)
     : endfunction_found (false),
       autoloading (false), fcn_file_from_relative_lookup (false),
       parsing_subfunctions (false), max_fcn_depth (0),
       curr_fcn_depth (0), primary_fcn_scope (-1),
       curr_class_name (), function_scopes (), primary_fcn_ptr (0),
-      stmt_list (0),
+      subfunction_names (), stmt_list (0),
       lexer (lxr)
   {
     init ();
   }
 
   ~octave_base_parser (void);
 
   void init (void);
@@ -265,26 +265,27 @@ public:
   void make_script (tree_statement_list *cmds, tree_statement *end_script);
 
   // Begin defining a function.
   octave_user_function *
   start_function (tree_parameter_list *param_list, tree_statement_list *body,
                   tree_statement *end_function);
 
   // Create a no-op statement for end_function.
-  tree_statement *make_end (const std::string& type, int l, int c);
+  tree_statement *make_end (const std::string& type, bool eof, int l, int c);
 
   // Do most of the work for defining a function.
   octave_user_function *
   frob_function (const std::string& fname, octave_user_function *fcn);
 
   // Finish defining a function.
   tree_function_def *
   finish_function (tree_parameter_list *ret_list,
-                   octave_user_function *fcn, octave_comment_list *lc);
+                   octave_user_function *fcn, octave_comment_list *lc,
+                   int l, int c);
 
   // Reset state after parsing function.
   void
   recover_from_parsing_function (void);
 
   // Make an index expression.
   tree_index_expression *
   make_index_expression (tree_expression *expr,
@@ -372,16 +373,21 @@ public:
   // A stack holding the nested function scopes being parsed.
   // We don't use std::stack, because we want the clear method. Also, we
   // must access one from the top
   std::vector<symbol_table::scope_id> function_scopes;
 
   // Pointer to the primary user function or user script function.
   octave_function *primary_fcn_ptr;
 
+  // List of subfunction names, initially in the order they are
+  // installed in the symbol table, then ordered as they appear in the
+  // file.  Eventually stashed in the primary function object.
+  std::list<std::string> subfunction_names;
+
   // Result of parsing input.
   tree_statement_list *stmt_list;
 
   // State of the lexer.
   octave_base_lexer& lexer;
 
 private:
 
diff --git a/libinterp/parse-tree/pt-cmd.cc b/libinterp/parse-tree/pt-cmd.cc
--- a/libinterp/parse-tree/pt-cmd.cc
+++ b/libinterp/parse-tree/pt-cmd.cc
@@ -28,17 +28,18 @@ along with Octave; see the file COPYING.
 #include "pt-walk.h"
 
 // No-op.
 
 tree_command *
 tree_no_op_command::dup (symbol_table::scope_id,
                          symbol_table::context_id) const
 {
-  return new tree_no_op_command (orig_cmd, line (), column ());
+  return new tree_no_op_command (orig_cmd, is_end_of_file (),
+                                 line (), column ());
 }
 
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
 }
 
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -58,28 +58,33 @@ private:
 
 // No-op.
 
 class
 tree_no_op_command : public tree_command
 {
 public:
 
-  tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
-    : tree_command (l, c), eof (cmd == "endfunction" || cmd == "endscript"),
-      orig_cmd (cmd) { }
+  tree_no_op_command (const std::string& cmd = "no_op", bool e = false,
+                      int l = -1, int c = -1)
+    : tree_command (l, c), eof (e), orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
-  bool is_end_of_fcn_or_script (void) const { return eof; }
+  bool is_end_of_fcn_or_script (void) const
+  {
+    return (orig_cmd == "endfunction" || orig_cmd == "endscript");
+  }
+
+  bool is_end_of_file (void) const { return eof; }
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
 
   bool eof;
 
   std::string orig_cmd;
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -102,16 +102,25 @@ tree_statement::line (void) const
 
 int
 tree_statement::column (void) const
 {
   return cmd ? cmd->column () : (expr ? expr->column () : -1);
 }
 
 void
+tree_statement::set_location (int l, int c)
+{
+  if (cmd)
+    cmd->set_location (l, c);
+  else if (expr)
+    expr->set_location (l, c);
+}
+
+void
 tree_statement::echo_code (void)
 {
   tree_print_code tpc (octave_stdout, VPS4);
 
   accept (tpc);
 }
 
 bool
@@ -126,16 +135,33 @@ tree_statement::is_end_of_fcn_or_script 
 
       if (no_op_cmd)
         retval = no_op_cmd->is_end_of_fcn_or_script ();
     }
 
   return retval;
 }
 
+bool
+tree_statement::is_end_of_file (void) const
+{
+  bool retval = false;
+
+  if (cmd)
+    {
+      tree_no_op_command *no_op_cmd
+        = dynamic_cast<tree_no_op_command *> (cmd);
+
+      if (no_op_cmd)
+        retval = no_op_cmd->is_end_of_file ();
+    }
+
+  return retval;
+}
+
 tree_statement *
 tree_statement::dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const
 {
   tree_statement *new_stmt = new tree_statement ();
 
   new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
 
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -69,28 +69,32 @@ public:
 
   void delete_breakpoint (void);
 
   bool is_breakpoint (void) const;
 
   int line (void) const;
   int column (void) const;
 
+  void set_location (int l, int c);
+
   void echo_code (void);
 
   tree_command *command (void) { return cmd; }
 
   tree_expression *expression (void) { return expr; }
 
   octave_comment_list *comment_text (void) { return comm; }
 
   bool is_null_statement (void) const { return ! (cmd || expr || comm); }
 
   bool is_end_of_fcn_or_script (void) const;
 
+  bool is_end_of_file (void) const;
+
   // Allow modification of this statement.  Note that there is no
   // checking.  If you use these, are you sure you knwo what you are
   // doing?
 
   void set_command (tree_command *c) { cmd = c; }
 
   void set_expression (tree_expression *e) { expr = e; }
 
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -45,16 +45,22 @@ public:
   virtual int line (void) const { return line_num; }
 
   virtual int column (void) const { return column_num; }
 
   void line (int l) { line_num = l; }
 
   void column (int c) { column_num = c; }
 
+  void set_location (int l, int c)
+  {
+    line_num = l;
+    column_num = c;
+  }
+
   virtual void set_breakpoint (void) { bp = true; }
 
   virtual void delete_breakpoint (void) { bp = false; }
 
   bool is_breakpoint (void) const { return bp; }
 
   std::string str_print_code (void);
 
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -31,16 +31,19 @@ template <typename elt_type>
 class
 octave_base_list
 {
 public:
 
   typedef typename std::list<elt_type>::iterator iterator;
   typedef typename std::list<elt_type>::const_iterator const_iterator;
 
+  typedef typename std::list<elt_type>::reverse_iterator reverse_iterator;
+  typedef typename std::list<elt_type>::const_reverse_iterator const_reverse_iterator;
+
   bool empty (void) const { return lst.empty (); }
 
   size_t size (void) const { return lst.size (); }
   size_t length (void) const { return size (); }
 
   iterator erase (iterator pos) { return lst.erase (pos); }
 
   template <class P>
@@ -69,16 +72,22 @@ public:
   void clear (void) { lst.clear (); }
 
   iterator begin (void) { return iterator (lst.begin ()); }
   const_iterator begin (void) const { return const_iterator (lst.begin ()); }
 
   iterator end (void) { return iterator (lst.end ()); }
   const_iterator end (void) const { return const_iterator (lst.end ()); }
 
+  reverse_iterator rbegin (void) { return reverse_iterator (lst.rbegin ()); }
+  const_reverse_iterator rbegin (void) const { return const_reverse_iterator (lst.rbegin ()); }
+
+  reverse_iterator rend (void) { return reverse_iterator (lst.rend ()); }
+  const_reverse_iterator rend (void) const { return const_reverse_iterator (lst.rend ()); }
+
   elt_type& front (void) { return lst.front (); }
   elt_type& back (void) { return lst.back (); }
 
   const elt_type& front (void) const { return lst.front (); }
   const elt_type& back (void) const { return lst.back (); }
 
   void push_front (const elt_type& s) { lst.push_front (s); }
   void push_back (const elt_type& s) { lst.push_back (s); }
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -391,16 +391,23 @@ ends_with (const string& s, const string
 static int
 run_command (const string& cmd)
 {
   if (debug)
     cout << cmd << endl;
   return system (cmd.c_str ());
 }
 
+bool
+is_true (const std::string& s)
+{
+  return (s == "yes"
+          || s == "true");
+}
+
 int
 main (int argc, char **argv)
 {
   initialize ();
 
   string file, output_option;
   list<string> cfiles, ccfiles, f77files;
   int result = 0;
@@ -409,17 +416,17 @@ main (int argc, char **argv)
   string libfiles = "";
   string octfile = "";
   string outputfile = "";
   string incflags = "";
   string defs = "";
   string ldflags = "";
   string pass_on_options = "";
   bool strip = false;
-  bool no_oct_file_strip_on_this_platform = %NO_OCT_FILE_STRIP%;
+  bool no_oct_file_strip_on_this_platform = is_true ("%NO_OCT_FILE_STRIP%");
   bool link = true;
   bool link_stand_alone = false;
   string output_ext = ".oct";
   bool depend = false;
   bool compile = true;
 
   if (argc == 1)
     {
