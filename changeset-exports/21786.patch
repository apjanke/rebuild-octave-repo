# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1464396657 14400
#      Fri May 27 20:50:57 2016 -0400
# Node ID df064166f180273261bfae98816cd7793a6b3620
# Parent  c9f8a7f7915ef1a8639715052ec1fcafcb467695
use namespace for lo-specfun.h functions

* lo-specfun.h, lo-specfun.cc (acosh, airy, asinh, atanh, besselh1,
besselh2, besseli, besselj, besselk, bessely, betainc, betaincinv,
biry, cbrt, dawson, ellipj, erf, erfc, erfcinv, erfcx, erfi, erfinv,
expm1, gamma, gammainc, lgamma, log1p, psi, rc_lgamma, rc_log1p):
Define in octave::math namespace.  Deprecated old names.  Change all
uses.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -43,37 +43,37 @@ enum bessel_type
 };
 
 #define DO_BESSEL(type, alpha, x, scaled, ierr, result) \
   do \
     { \
       switch (type) \
         { \
           case BESSEL_J: \
-            result = besselj (alpha, x, scaled, ierr); \
+            result = octave::math::besselj (alpha, x, scaled, ierr); \
             break; \
  \
           case BESSEL_Y: \
-            result = bessely (alpha, x, scaled, ierr); \
+            result = octave::math::bessely (alpha, x, scaled, ierr); \
             break; \
  \
           case BESSEL_I: \
-            result = besseli (alpha, x, scaled, ierr); \
+            result = octave::math::besseli (alpha, x, scaled, ierr); \
             break; \
  \
           case BESSEL_K: \
-            result = besselk (alpha, x, scaled, ierr); \
+            result = octave::math::besselk (alpha, x, scaled, ierr); \
             break; \
  \
           case BESSEL_H1: \
-            result = besselh1 (alpha, x, scaled, ierr); \
+            result = octave::math::besselh1 (alpha, x, scaled, ierr); \
             break; \
  \
           case BESSEL_H2: \
-            result = besselh2 (alpha, x, scaled, ierr); \
+            result = octave::math::besselh2 (alpha, x, scaled, ierr); \
             break; \
  \
           default: \
             break; \
         } \
     } \
   while (0)
 
@@ -530,35 +530,35 @@ return @code{NaN}.\n\
   if (args(idx).is_single_type ())
     {
       FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
 
       Array<octave_idx_type> ierr;
       octave_value result;
 
       if (kind > 1)
-        result = biry (z, kind == 3, scale, ierr);
+        result = octave::math::biry (z, kind == 3, scale, ierr);
       else
-        result = airy (z, kind == 1, scale, ierr);
+        result = octave::math::airy (z, kind == 1, scale, ierr);
 
       retval(0) = result;
       if (nargout > 1)
         retval(1) = NDArray (ierr);
     }
   else
     {
       ComplexNDArray z = args(idx).xcomplex_array_value ("airy: Z must be a complex matrix");
 
       Array<octave_idx_type> ierr;
       octave_value result;
 
       if (kind > 1)
-        result = biry (z, kind == 3, scale, ierr);
+        result = octave::math::biry (z, kind == 3, scale, ierr);
       else
-        result = airy (z, kind == 1, scale, ierr);
+        result = octave::math::airy (z, kind == 1, scale, ierr);
 
       retval(0) = result;
       if (nargout > 1)
         retval(1) = NDArray (ierr);
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -85,79 +85,79 @@ compatible dimensions.\n\
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   float b = b_arg.float_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<float> b = b_arg.float_array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
           else
             {
               Array<float> a = a_arg.float_array_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   float b = b_arg.float_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<float> b = b_arg.float_array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
         }
       else
         {
           Array<float> x = x_arg.float_array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   float b = b_arg.float_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<float> b = b_arg.float_array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
           else
             {
               Array<float> a = a_arg.float_array_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   float b = b_arg.float_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<float> b = b_arg.float_array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
         }
     }
   else
     {
       if (x_arg.is_scalar_type ())
         {
@@ -166,79 +166,79 @@ compatible dimensions.\n\
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   double b = b_arg.double_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<double> b = b_arg.array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
           else
             {
               Array<double> a = a_arg.array_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   double b = b_arg.double_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<double> b = b_arg.array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
         }
       else
         {
           Array<double> x = x_arg.array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   double b = b_arg.double_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<double> b = b_arg.array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
           else
             {
               Array<double> a = a_arg.array_value ();
 
               if (b_arg.is_scalar_type ())
                 {
                   double b = b_arg.double_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
               else
                 {
                   Array<double> b = b_arg.array_value ();
 
-                  retval = betainc (x, a, b);
+                  retval = octave::math::betainc (x, a, b);
                 }
             }
         }
     }
 
   return retval;
 }
 
@@ -314,79 +314,79 @@ The inverse is the value @var{x} such th
       if (a_arg.is_scalar_type ())
         {
           double a = a_arg.double_value ();
 
           if (b_arg.is_scalar_type ())
             {
               double b = b_arg.double_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
           else
             {
               Array<double> b = b_arg.array_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
         }
       else
         {
           Array<double> a = a_arg.array_value ();
 
           if (b_arg.is_scalar_type ())
             {
               double b = b_arg.double_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
           else
             {
               Array<double> b = b_arg.array_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
         }
     }
   else
     {
       Array<double> x = x_arg.array_value ();
 
       if (a_arg.is_scalar_type ())
         {
           double a = a_arg.double_value ();
 
           if (b_arg.is_scalar_type ())
             {
               double b = b_arg.double_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
           else
             {
               Array<double> b = b_arg.array_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
         }
       else
         {
           Array<double> a = a_arg.array_value ();
 
           if (b_arg.is_scalar_type ())
             {
               double b = b_arg.double_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
           else
             {
               Array<double> b = b_arg.array_value ();
 
-              retval = betaincinv (x, a, b);
+              retval = octave::math::betaincinv (x, a, b);
             }
         }
     }
 
   // FIXME: It would be better to have an algorithm for betaincinv which
   // accepted float inputs and returned float outputs.  As it is, we do
   // extra work to calculate betaincinv to double precision and then throw
   // that precision away.
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -85,29 +85,29 @@ and 16.15), Dover, 1965.\n\
           if (u_arg.is_real_type ())
             {
               // u real, m scalar
               double u = args(0).xdouble_value ("ellipj: U must be a scalar or matrix");
 
               double sn, cn, dn;
               double err = 0;
 
-              ellipj (u, m, sn, cn, dn, err);
+              octave::math::ellipj (u, m, sn, cn, dn, err);
 
               return ovl (sn, cn, dn, err);
             }
           else
             {
               // u complex, m scalar
               Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
               Complex sn, cn, dn;
               double err = 0;
 
-              ellipj (u, m, sn, cn, dn, err);
+              octave::math::ellipj (u, m, sn, cn, dn, err);
 
               return ovl (sn, cn, dn, err);
             }
         }
       else
         {
           // u is matrix, m is scalar
           ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
@@ -120,17 +120,17 @@ and 16.15), Dover, 1965.\n\
           const Complex *pu = u.data ();
           Complex *psn = sn.fortran_vec ();
           Complex *pcn = cn.fortran_vec ();
           Complex *pdn = dn.fortran_vec ();
           double *perr = err.fortran_vec ();
           octave_idx_type nel = u.numel ();
 
           for (octave_idx_type i = 0; i < nel; i++)
-            ellipj (pu[i], m, psn[i], pcn[i], pdn[i], perr[i]);
+            octave::math::ellipj (pu[i], m, psn[i], pcn[i], pdn[i], perr[i]);
 
           return ovl (sn, cn, dn, err);
         }
     }
   else
     {
       NDArray m = args(1).xarray_value ("ellipj: M must be a scalar or matrix");
 
@@ -150,17 +150,17 @@ and 16.15), Dover, 1965.\n\
               const double *pm = m.data ();
               double *psn = sn.fortran_vec ();
               double *pcn = cn.fortran_vec ();
               double *pdn = dn.fortran_vec ();
               double *perr = err.fortran_vec ();
               octave_idx_type nel = m.numel ();
 
               for (octave_idx_type i = 0; i < nel; i++)
-                ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+                octave::math::ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
               return ovl (sn, cn, dn, err);
             }
           else
             {
               // u is complex scalar, m is array
               Complex u = u_arg.xcomplex_value ("ellipj: U must be a scalar or matrix");
 
@@ -170,17 +170,17 @@ and 16.15), Dover, 1965.\n\
               const double *pm = m.data ();
               Complex *psn = sn.fortran_vec ();
               Complex *pcn = cn.fortran_vec ();
               Complex *pdn = dn.fortran_vec ();
               double *perr = err.fortran_vec ();
               octave_idx_type nel = m.numel ();
 
               for (octave_idx_type i = 0; i < nel; i++)
-                ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+                octave::math::ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
               return ovl (sn, cn, dn, err);
             }
         }
       else
         {
           // u is array, m is array
           if (u_arg.is_real_type ())
@@ -201,18 +201,17 @@ and 16.15), Dover, 1965.\n\
                   NDArray sn (sz_out), cn (sz_out), dn (sz_out);
                   NDArray err (sz_out);
 
                   const double *pu = u.data ();
                   const double *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
-                              err(i,j));
+                      octave::math::ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
 
                   return ovl (sn, cn, dn, err);
                 }
               else if (sz_m == sz_u)
                 {
                   NDArray sn (sz_m), cn (sz_m), dn (sz_m);
                   NDArray err (sz_m);
 
@@ -220,17 +219,17 @@ and 16.15), Dover, 1965.\n\
                   const double *pm = m.data ();
                   double *psn = sn.fortran_vec ();
                   double *pcn = cn.fortran_vec ();
                   double *pdn = dn.fortran_vec ();
                   double *perr = err.fortran_vec ();
                   octave_idx_type nel = m.numel ();
 
                   for (octave_idx_type i = 0; i < nel; i++)
-                    ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+                    octave::math::ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
                   return ovl (sn, cn, dn, err);
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
           else
             {
@@ -250,18 +249,17 @@ and 16.15), Dover, 1965.\n\
                   ComplexNDArray sn (sz_out), cn (sz_out), dn (sz_out);
                   NDArray err (sz_out);
 
                   const Complex *pu = u.data ();
                   const double  *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
-                              err(i,j));
+                      octave::math::ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
 
                   return ovl (sn, cn, dn, err);
                 }
               else if (sz_m == sz_u)
                 {
                   ComplexNDArray sn (sz_m), cn (sz_m), dn (sz_m);
                   NDArray err (sz_m);
 
@@ -269,17 +267,17 @@ and 16.15), Dover, 1965.\n\
                   const double  *pm = m.data ();
                   Complex *psn = sn.fortran_vec ();
                   Complex *pcn = cn.fortran_vec ();
                   Complex *pdn = dn.fortran_vec ();
                   double *perr = err.fortran_vec ();
                   octave_idx_type nel = m.numel ();
 
                   for (octave_idx_type i = 0; i < nel; i++)
-                    ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
+                    octave::math::ellipj (pu[i], pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
                   return ovl (sn, cn, dn, err);
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
         }
     }  // m matrix
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -109,77 +109,77 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
       if (x_arg.is_scalar_type ())
         {
           float x = x_arg.float_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
             }
         }
       else
         {
           FloatNDArray x = x_arg.float_array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               float a = a_arg.float_value ();
 
-              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
             }
           else
             {
               FloatNDArray a = a_arg.float_array_value ();
 
-              retval = lower ? gammainc (x, a) : 1.0f - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1.0f - octave::math::gammainc (x, a);
             }
         }
     }
   else
     {
       if (x_arg.is_scalar_type ())
         {
           double x = x_arg.double_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
             }
         }
       else
         {
           NDArray x = x_arg.array_value ();
 
           if (a_arg.is_scalar_type ())
             {
               double a = a_arg.double_value ();
 
-              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
             }
           else
             {
               NDArray a = a_arg.array_value ();
 
-              retval = lower ? gammainc (x, a) : 1. - gammainc (x, a);
+              retval = lower ? octave::math::gammainc (x, a) : 1. - octave::math::gammainc (x, a);
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -86,17 +86,17 @@ can have any value real or complex value
         { \
           const A ## NDArray z = oct_z.M ## array_value (); \
           A ## NDArray psi_z (z.dims ()); \
  \
           const E* zv = z.data (); \
           E* psi_zv = psi_z.fortran_vec (); \
           const octave_idx_type n = z.numel (); \
           for (octave_idx_type i = 0; i < n; i++) \
-            *psi_zv++ = psi (*zv++); \
+            *psi_zv++ = octave::math::psi (*zv++); \
  \
           retval = psi_z; \
         }
 
       if (oct_z.is_complex_type ())
         {
           FLOAT_BRANCH(double, Complex, complex_, Complex)
           else FLOAT_BRANCH(single, FloatComplex, float_complex_, FloatComplex)
@@ -127,17 +127,17 @@ can have any value real or complex value
           const E* zv = z.data (); \
           E* psi_zv = psi_z.fortran_vec (); \
           const octave_idx_type n = z.numel (); \
           for (octave_idx_type i = 0; i < n; i++) \
             { \
               if (*zv < 0) \
                 error ("psi: Z must be non-negative for polygamma (K > 0)"); \
  \
-              *psi_zv++ = psi (k, *zv++); \
+              *psi_zv++ = octave::math::psi (k, *zv++); \
             } \
           retval = psi_z; \
         }
 
       FLOAT_BRANCH(double, , , double)
       else FLOAT_BRANCH(single, Float, float_, float)
       else
         error ("psi: Z must be a floating point for polygamma (K > 0)");
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -478,41 +478,41 @@ octave_complex::map (unary_mapper_t umap
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
       SCALAR_MAPPER (acos, octave::math::acos);
-      SCALAR_MAPPER (acosh, xacosh);
+      SCALAR_MAPPER (acosh, octave::math::acosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, octave::math::asin);
-      SCALAR_MAPPER (asinh, xasinh);
+      SCALAR_MAPPER (asinh, octave::math::asinh);
       SCALAR_MAPPER (atan, octave::math::atan);
-      SCALAR_MAPPER (atanh, xatanh);
-      SCALAR_MAPPER (erf, xerf);
-      SCALAR_MAPPER (erfc, xerfc);
-      SCALAR_MAPPER (erfcx, ::erfcx);
-      SCALAR_MAPPER (erfi, ::erfi);
-      SCALAR_MAPPER (dawson, ::dawson);
+      SCALAR_MAPPER (atanh, octave::math::atanh);
+      SCALAR_MAPPER (erf, octave::math::erf);
+      SCALAR_MAPPER (erfc, octave::math::erfc);
+      SCALAR_MAPPER (erfcx, octave::math::erfcx);
+      SCALAR_MAPPER (erfi, octave::math::erfi);
+      SCALAR_MAPPER (dawson, octave::math::dawson);
       SCALAR_MAPPER (ceil, octave::math::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, xexpm1);
+      SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, octave::math::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
       SCALAR_MAPPER (log2, octave::math::log2);
       SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, xlog1p);
+      SCALAR_MAPPER (log1p, octave::math::log1p);
       SCALAR_MAPPER (real, std::real);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -761,39 +761,39 @@ octave_complex_matrix::map (unary_mapper
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, octave::math::acos);
-      ARRAY_MAPPER (acosh, Complex, xacosh);
+      ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, octave::math::asin);
-      ARRAY_MAPPER (asinh, Complex, xasinh);
+      ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
       ARRAY_MAPPER (atan, Complex, octave::math::atan);
-      ARRAY_MAPPER (atanh, Complex, xatanh);
-      ARRAY_MAPPER (erf, Complex, xerf);
-      ARRAY_MAPPER (erfc, Complex, xerfc);
-      ARRAY_MAPPER (erfcx, Complex, ::erfcx);
-      ARRAY_MAPPER (erfi, Complex, ::erfi);
-      ARRAY_MAPPER (dawson, Complex, ::dawson);
+      ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
+      ARRAY_MAPPER (erf, Complex, octave::math::erf);
+      ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
+      ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
       ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, xexpm1);
+      ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
       ARRAY_MAPPER (fix, Complex, octave::math::fix);
       ARRAY_MAPPER (floor, Complex, octave::math::floor);
       ARRAY_MAPPER (log, Complex, std::log);
       ARRAY_MAPPER (log2, Complex, octave::math::log2);
       ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, xlog1p);
+      ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
       ARRAY_MAPPER (round, Complex, octave::math::round);
       ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
       ARRAY_MAPPER (signum, Complex, octave::math::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -914,40 +914,40 @@ octave_sparse_complex_matrix::map (unary
 
       ARRAY_METHOD_MAPPER (abs, abs);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, octave::math::acos);
-      ARRAY_MAPPER (acosh, Complex, xacosh);
+      ARRAY_MAPPER (acosh, Complex, octave::math::acosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, octave::math::asin);
-      ARRAY_MAPPER (asinh, Complex, xasinh);
+      ARRAY_MAPPER (asinh, Complex, octave::math::asinh);
       ARRAY_MAPPER (atan, Complex, octave::math::atan);
-      ARRAY_MAPPER (atanh, Complex, xatanh);
-      ARRAY_MAPPER (erf, Complex, xerf);
-      ARRAY_MAPPER (erfc, Complex, xerfc);
-      ARRAY_MAPPER (erfcx, Complex, ::erfcx);
-      ARRAY_MAPPER (erfi, Complex, ::erfi);
-      ARRAY_MAPPER (dawson, Complex, ::dawson);
+      ARRAY_MAPPER (atanh, Complex, octave::math::atanh);
+      ARRAY_MAPPER (erf, Complex, octave::math::erf);
+      ARRAY_MAPPER (erfc, Complex, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, Complex, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, Complex, octave::math::erfi);
+      ARRAY_MAPPER (dawson, Complex, octave::math::dawson);
       ARRAY_MAPPER (ceil, Complex, octave::math::ceil);
       ARRAY_MAPPER (conj, Complex, std::conj<double>);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
-      ARRAY_MAPPER (expm1, Complex, xexpm1);
+      ARRAY_MAPPER (expm1, Complex, octave::math::expm1);
       ARRAY_MAPPER (fix, Complex, octave::math::fix);
       ARRAY_MAPPER (floor, Complex, octave::math::floor);
       ARRAY_MAPPER (log, Complex, std::log);
       ARRAY_MAPPER (log2, Complex, octave::math::log2);
       ARRAY_MAPPER (log10, Complex, std::log10);
-      ARRAY_MAPPER (log1p, Complex, xlog1p);
+      ARRAY_MAPPER (log1p, Complex, octave::math::log1p);
       ARRAY_MAPPER (round, Complex, octave::math::round);
       ARRAY_MAPPER (roundb, Complex, octave::math::roundb);
       ARRAY_MAPPER (signum, Complex, octave::math::signum);
       ARRAY_MAPPER (sin, Complex, std::sin);
       ARRAY_MAPPER (sinh, Complex, std::sinh);
       ARRAY_MAPPER (sqrt, Complex, std::sqrt);
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -296,40 +296,40 @@ octave_float_scalar::map (unary_mapper_t
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabsf);
       SCALAR_MAPPER (acos, octave::math::rc_acos);
       SCALAR_MAPPER (acosh, octave::math::rc_acosh);
       SCALAR_MAPPER (angle, octave::math::arg);
       SCALAR_MAPPER (asin, octave::math::rc_asin);
-      SCALAR_MAPPER (asinh, xasinh);
+      SCALAR_MAPPER (asinh, octave::math::asinh);
       SCALAR_MAPPER (atan, ::atanf);
       SCALAR_MAPPER (atanh, octave::math::rc_atanh);
-      SCALAR_MAPPER (erf, xerf);
-      SCALAR_MAPPER (erfinv, ::erfinv);
-      SCALAR_MAPPER (erfcinv, ::erfcinv);
-      SCALAR_MAPPER (erfc, xerfc);
-      SCALAR_MAPPER (erfcx, ::erfcx);
-      SCALAR_MAPPER (erfi, ::erfi);
-      SCALAR_MAPPER (dawson, ::dawson);
-      SCALAR_MAPPER (gamma, xgamma);
-      SCALAR_MAPPER (lgamma, rc_lgamma);
-      SCALAR_MAPPER (cbrt, xcbrt);
+      SCALAR_MAPPER (erf, octave::math::erf);
+      SCALAR_MAPPER (erfinv, octave::math::erfinv);
+      SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
+      SCALAR_MAPPER (erfc, octave::math::erfc);
+      SCALAR_MAPPER (erfcx, octave::math::erfcx);
+      SCALAR_MAPPER (erfi, octave::math::erfi);
+      SCALAR_MAPPER (dawson, octave::math::dawson);
+      SCALAR_MAPPER (gamma, octave::math::gamma);
+      SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
+      SCALAR_MAPPER (cbrt, octave::math::cbrt);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
       SCALAR_MAPPER (exp, ::expf);
-      SCALAR_MAPPER (expm1, xexpm1);
+      SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, gnulib::floorf);
       SCALAR_MAPPER (log, octave::math::rc_log);
       SCALAR_MAPPER (log2, octave::math::rc_log2);
       SCALAR_MAPPER (log10, octave::math::rc_log10);
-      SCALAR_MAPPER (log1p, rc_log1p);
+      SCALAR_MAPPER (log1p, octave::math::rc_log1p);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sinf);
       SCALAR_MAPPER (sinh, ::sinhf);
       SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
       SCALAR_MAPPER (tan, ::tanf);
       SCALAR_MAPPER (tanh, ::tanhf);
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -428,41 +428,41 @@ octave_float_complex::map (unary_mapper_
   switch (umap)
     {
 #define SCALAR_MAPPER(UMAP, FCN) \
     case umap_ ## UMAP: \
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, std::abs);
       SCALAR_MAPPER (acos, octave::math::acos);
-      SCALAR_MAPPER (acosh, xacosh);
+      SCALAR_MAPPER (acosh, octave::math::acosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, octave::math::asin);
-      SCALAR_MAPPER (asinh, xasinh);
+      SCALAR_MAPPER (asinh, octave::math::asinh);
       SCALAR_MAPPER (atan, octave::math::atan);
-      SCALAR_MAPPER (atanh, xatanh);
-      SCALAR_MAPPER (erf, xerf);
-      SCALAR_MAPPER (erfc, xerfc);
-      SCALAR_MAPPER (erfcx, ::erfcx);
-      SCALAR_MAPPER (erfi, ::erfi);
-      SCALAR_MAPPER (dawson, ::dawson);
+      SCALAR_MAPPER (atanh, octave::math::atanh);
+      SCALAR_MAPPER (erf, octave::math::erf);
+      SCALAR_MAPPER (erfc, octave::math::erfc);
+      SCALAR_MAPPER (erfcx, octave::math::erfcx);
+      SCALAR_MAPPER (erfi, octave::math::erfi);
+      SCALAR_MAPPER (dawson, octave::math::dawson);
       SCALAR_MAPPER (ceil, octave::math::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
-      SCALAR_MAPPER (expm1, xexpm1);
+      SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, octave::math::floor);
       SCALAR_MAPPER (imag, std::imag);
       SCALAR_MAPPER (log, std::log);
       SCALAR_MAPPER (log2, octave::math::log2);
       SCALAR_MAPPER (log10, std::log10);
-      SCALAR_MAPPER (log1p, xlog1p);
+      SCALAR_MAPPER (log1p, octave::math::log1p);
       SCALAR_MAPPER (real, std::real);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, std::sin);
       SCALAR_MAPPER (sinh, std::sinh);
       SCALAR_MAPPER (sqrt, std::sqrt);
       SCALAR_MAPPER (tan, std::tan);
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -711,39 +711,39 @@ octave_float_complex_matrix::map (unary_
       ARRAY_METHOD_MAPPER (isinf, isinf);
       ARRAY_METHOD_MAPPER (isfinite, isfinite);
 
 #define ARRAY_MAPPER(UMAP, TYPE, FCN) \
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, FloatComplex, octave::math::acos);
-      ARRAY_MAPPER (acosh, FloatComplex, xacosh);
+      ARRAY_MAPPER (acosh, FloatComplex, octave::math::acosh);
       ARRAY_MAPPER (angle, float, std::arg);
       ARRAY_MAPPER (arg, float, std::arg);
       ARRAY_MAPPER (asin, FloatComplex, octave::math::asin);
-      ARRAY_MAPPER (asinh, FloatComplex, xasinh);
+      ARRAY_MAPPER (asinh, FloatComplex, octave::math::asinh);
       ARRAY_MAPPER (atan, FloatComplex, octave::math::atan);
-      ARRAY_MAPPER (atanh, FloatComplex, xatanh);
-      ARRAY_MAPPER (erf, FloatComplex, xerf);
-      ARRAY_MAPPER (erfc, FloatComplex, xerfc);
-      ARRAY_MAPPER (erfcx, FloatComplex, ::erfcx);
-      ARRAY_MAPPER (erfi, FloatComplex, ::erfi);
-      ARRAY_MAPPER (dawson, FloatComplex, ::dawson);
+      ARRAY_MAPPER (atanh, FloatComplex, octave::math::atanh);
+      ARRAY_MAPPER (erf, FloatComplex, octave::math::erf);
+      ARRAY_MAPPER (erfc, FloatComplex, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, FloatComplex, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, FloatComplex, octave::math::erfi);
+      ARRAY_MAPPER (dawson, FloatComplex, octave::math::dawson);
       ARRAY_MAPPER (ceil, FloatComplex, octave::math::ceil);
       ARRAY_MAPPER (cos, FloatComplex, std::cos);
       ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
       ARRAY_MAPPER (exp, FloatComplex, std::exp);
-      ARRAY_MAPPER (expm1, FloatComplex, xexpm1);
+      ARRAY_MAPPER (expm1, FloatComplex, octave::math::expm1);
       ARRAY_MAPPER (fix, FloatComplex, octave::math::fix);
       ARRAY_MAPPER (floor, FloatComplex, octave::math::floor);
       ARRAY_MAPPER (log, FloatComplex, std::log);
       ARRAY_MAPPER (log2, FloatComplex, octave::math::log2);
       ARRAY_MAPPER (log10, FloatComplex, std::log10);
-      ARRAY_MAPPER (log1p, FloatComplex, xlog1p);
+      ARRAY_MAPPER (log1p, FloatComplex, octave::math::log1p);
       ARRAY_MAPPER (round, FloatComplex, octave::math::round);
       ARRAY_MAPPER (roundb, FloatComplex, octave::math::roundb);
       ARRAY_MAPPER (signum, FloatComplex, octave::math::signum);
       ARRAY_MAPPER (sin, FloatComplex, std::sin);
       ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
       ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
       ARRAY_MAPPER (tan, FloatComplex, std::tan);
       ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -743,40 +743,40 @@ octave_float_matrix::map (unary_mapper_t
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
       RC_ARRAY_MAPPER (acos, FloatComplex, octave::math::rc_acos);
       RC_ARRAY_MAPPER (acosh, FloatComplex, octave::math::rc_acosh);
       ARRAY_MAPPER (angle, float, octave::math::arg);
       ARRAY_MAPPER (arg, float,octave::math ::arg);
       RC_ARRAY_MAPPER (asin, FloatComplex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, float, xasinh);
+      ARRAY_MAPPER (asinh, float, octave::math::asinh);
       ARRAY_MAPPER (atan, float, ::atanf);
       RC_ARRAY_MAPPER (atanh, FloatComplex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, float, xerf);
-      ARRAY_MAPPER (erfinv, float, ::erfinv);
-      ARRAY_MAPPER (erfcinv, float, ::erfcinv);
-      ARRAY_MAPPER (erfc, float, xerfc);
-      ARRAY_MAPPER (erfcx, float, ::erfcx);
-      ARRAY_MAPPER (erfi, float, ::erfi);
-      ARRAY_MAPPER (dawson, float, ::dawson);
-      ARRAY_MAPPER (gamma, float, xgamma);
-      RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, float, xcbrt);
+      ARRAY_MAPPER (erf, float, octave::math::erf);
+      ARRAY_MAPPER (erfinv, float, octave::math::erfinv);
+      ARRAY_MAPPER (erfcinv, float, octave::math::erfcinv);
+      ARRAY_MAPPER (erfc, float, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, float, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, float, octave::math::erfi);
+      ARRAY_MAPPER (dawson, float, octave::math::dawson);
+      ARRAY_MAPPER (gamma, float, octave::math::gamma);
+      RC_ARRAY_MAPPER (lgamma, FloatComplex, octave::math::rc_lgamma);
+      ARRAY_MAPPER (cbrt, float, octave::math::cbrt);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
       ARRAY_MAPPER (exp, float, ::expf);
-      ARRAY_MAPPER (expm1, float, xexpm1);
+      ARRAY_MAPPER (expm1, float, octave::math::expm1);
       ARRAY_MAPPER (fix, float, octave::math::fix);
       ARRAY_MAPPER (floor, float, ::floorf);
       RC_ARRAY_MAPPER (log, FloatComplex, octave::math::rc_log);
       RC_ARRAY_MAPPER (log2, FloatComplex, octave::math::rc_log2);
       RC_ARRAY_MAPPER (log10, FloatComplex, octave::math::rc_log10);
-      RC_ARRAY_MAPPER (log1p, FloatComplex, rc_log1p);
+      RC_ARRAY_MAPPER (log1p, FloatComplex, octave::math::rc_log1p);
       ARRAY_MAPPER (round, float, octave::math::round);
       ARRAY_MAPPER (roundb, float, octave::math::roundb);
       ARRAY_MAPPER (signum, float, octave::math::signum);
       ARRAY_MAPPER (sin, float, ::sinf);
       ARRAY_MAPPER (sinh, float, ::sinhf);
       RC_ARRAY_MAPPER (sqrt, FloatComplex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, float, ::tanf);
       ARRAY_MAPPER (tanh, float, ::tanhf);
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -868,40 +868,40 @@ octave_matrix::map (unary_mapper_t umap)
     case umap_ ## UMAP: \
       return do_rc_map (matrix, FCN)
 
       RC_ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
       RC_ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
       ARRAY_MAPPER (angle, double, octave::math::arg);
       ARRAY_MAPPER (arg, double,octave::math ::arg);
       RC_ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, double, xasinh);
+      ARRAY_MAPPER (asinh, double, octave::math::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       RC_ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, double, xerf);
-      ARRAY_MAPPER (erfinv, double, ::erfinv);
-      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
-      ARRAY_MAPPER (erfc, double, xerfc);
-      ARRAY_MAPPER (erfcx, double, ::erfcx);
-      ARRAY_MAPPER (erfi, double, ::erfi);
-      ARRAY_MAPPER (dawson, double, ::dawson);
-      ARRAY_MAPPER (gamma, double, xgamma);
-      RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, xcbrt);
+      ARRAY_MAPPER (erf, double, octave::math::erf);
+      ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
+      ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
+      ARRAY_MAPPER (erfc, double, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, double, octave::math::erfi);
+      ARRAY_MAPPER (dawson, double, octave::math::dawson);
+      ARRAY_MAPPER (gamma, double, octave::math::gamma);
+      RC_ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
+      ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, xexpm1);
+      ARRAY_MAPPER (expm1, double, octave::math::expm1);
       ARRAY_MAPPER (fix, double, octave::math::fix);
       ARRAY_MAPPER (floor, double, ::floor);
       RC_ARRAY_MAPPER (log, Complex, octave::math::rc_log);
       RC_ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
       RC_ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
-      RC_ARRAY_MAPPER (log1p, Complex, rc_log1p);
+      RC_ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
       ARRAY_MAPPER (round, double, octave::math::round);
       ARRAY_MAPPER (roundb, double, octave::math::roundb);
       ARRAY_MAPPER (signum, double, octave::math::signum);
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
       RC_ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -907,40 +907,40 @@ octave_sparse_matrix::map (unary_mapper_
     case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE> (FCN))
 
       ARRAY_MAPPER (acos, Complex, octave::math::rc_acos);
       ARRAY_MAPPER (acosh, Complex, octave::math::rc_acosh);
       ARRAY_MAPPER (angle, double, octave::math::arg);
       ARRAY_MAPPER (arg, double,octave::math ::arg);
       ARRAY_MAPPER (asin, Complex, octave::math::rc_asin);
-      ARRAY_MAPPER (asinh, double, xasinh);
+      ARRAY_MAPPER (asinh, double, octave::math::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       ARRAY_MAPPER (atanh, Complex, octave::math::rc_atanh);
-      ARRAY_MAPPER (erf, double, xerf);
-      ARRAY_MAPPER (erfinv, double, ::erfinv);
-      ARRAY_MAPPER (erfcinv, double, ::erfcinv);
-      ARRAY_MAPPER (erfc, double, xerfc);
-      ARRAY_MAPPER (erfcx, double, ::erfcx);
-      ARRAY_MAPPER (erfi, double, ::erfi);
-      ARRAY_MAPPER (dawson, double, ::dawson);
-      ARRAY_MAPPER (gamma, double, xgamma);
-      ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
-      ARRAY_MAPPER (cbrt, double, xcbrt);
+      ARRAY_MAPPER (erf, double, octave::math::erf);
+      ARRAY_MAPPER (erfinv, double, octave::math::erfinv);
+      ARRAY_MAPPER (erfcinv, double, octave::math::erfcinv);
+      ARRAY_MAPPER (erfc, double, octave::math::erfc);
+      ARRAY_MAPPER (erfcx, double, octave::math::erfcx);
+      ARRAY_MAPPER (erfi, double, octave::math::erfi);
+      ARRAY_MAPPER (dawson, double, octave::math::dawson);
+      ARRAY_MAPPER (gamma, double, octave::math::gamma);
+      ARRAY_MAPPER (lgamma, Complex, octave::math::rc_lgamma);
+      ARRAY_MAPPER (cbrt, double, octave::math::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
-      ARRAY_MAPPER (expm1, double, xexpm1);
+      ARRAY_MAPPER (expm1, double, octave::math::expm1);
       ARRAY_MAPPER (fix, double, octave::math::fix);
       ARRAY_MAPPER (floor, double, ::floor);
       ARRAY_MAPPER (log, Complex, octave::math::rc_log);
       ARRAY_MAPPER (log2, Complex, octave::math::rc_log2);
       ARRAY_MAPPER (log10, Complex, octave::math::rc_log10);
-      ARRAY_MAPPER (log1p, Complex, rc_log1p);
+      ARRAY_MAPPER (log1p, Complex, octave::math::rc_log1p);
       ARRAY_MAPPER (round, double, octave::math::round);
       ARRAY_MAPPER (roundb, double, octave::math::roundb);
       ARRAY_MAPPER (signum, double, octave::math::signum);
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
       ARRAY_MAPPER (sqrt, Complex, octave::math::rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -320,40 +320,40 @@ octave_scalar::map (unary_mapper_t umap)
       return octave_value (FCN (scalar))
 
       SCALAR_MAPPER (abs, ::fabs);
       SCALAR_MAPPER (acos, octave::math::rc_acos);
       SCALAR_MAPPER (acosh, octave::math::rc_acosh);
       SCALAR_MAPPER (angle, octave::math::arg);
       SCALAR_MAPPER (arg,octave::math ::arg);
       SCALAR_MAPPER (asin, octave::math::rc_asin);
-      SCALAR_MAPPER (asinh, xasinh);
+      SCALAR_MAPPER (asinh, octave::math::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, octave::math::rc_atanh);
-      SCALAR_MAPPER (erf, xerf);
-      SCALAR_MAPPER (erfinv, ::erfinv);
-      SCALAR_MAPPER (erfcinv, ::erfcinv);
-      SCALAR_MAPPER (erfc, xerfc);
-      SCALAR_MAPPER (erfcx, ::erfcx);
-      SCALAR_MAPPER (erfi, ::erfi);
-      SCALAR_MAPPER (dawson, ::dawson);
-      SCALAR_MAPPER (gamma, xgamma);
-      SCALAR_MAPPER (lgamma, rc_lgamma);
-      SCALAR_MAPPER (cbrt, xcbrt);
+      SCALAR_MAPPER (erf, octave::math::erf);
+      SCALAR_MAPPER (erfinv, octave::math::erfinv);
+      SCALAR_MAPPER (erfcinv, octave::math::erfcinv);
+      SCALAR_MAPPER (erfc, octave::math::erfc);
+      SCALAR_MAPPER (erfcx, octave::math::erfcx);
+      SCALAR_MAPPER (erfi, octave::math::erfi);
+      SCALAR_MAPPER (dawson, octave::math::dawson);
+      SCALAR_MAPPER (gamma, octave::math::gamma);
+      SCALAR_MAPPER (lgamma, octave::math::rc_lgamma);
+      SCALAR_MAPPER (cbrt, octave::math::cbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
       SCALAR_MAPPER (exp, ::exp);
-      SCALAR_MAPPER (expm1, xexpm1);
+      SCALAR_MAPPER (expm1, octave::math::expm1);
       SCALAR_MAPPER (fix, octave::math::fix);
       SCALAR_MAPPER (floor, gnulib::floor);
       SCALAR_MAPPER (log, octave::math::rc_log);
       SCALAR_MAPPER (log2, octave::math::rc_log2);
       SCALAR_MAPPER (log10, octave::math::rc_log10);
-      SCALAR_MAPPER (log1p, rc_log1p);
+      SCALAR_MAPPER (log1p, octave::math::rc_log1p);
       SCALAR_MAPPER (round, octave::math::round);
       SCALAR_MAPPER (roundb, octave::math::roundb);
       SCALAR_MAPPER (signum, octave::math::signum);
       SCALAR_MAPPER (sin, ::sin);
       SCALAR_MAPPER (sinh, ::sinh);
       SCALAR_MAPPER (sqrt, octave::math::rc_sqrt);
       SCALAR_MAPPER (tan, ::tan);
       SCALAR_MAPPER (tanh, ::tanh);
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -429,17 +429,17 @@ namespace octave
     rc_atanh (double x)
     {
       return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
     }
 
     FloatComplex
     rc_atanh (float x)
     {
-      return fabsf (x) > 1.0f ? xatanh (FloatComplex (x)) : FloatComplex (atanh (x));
+      return fabsf (x) > 1.0f ? atanh (FloatComplex (x)) : FloatComplex (atanh (x));
     }
 
     Complex
     rc_log (double x)
     {
       const double pi = 3.14159265358979323846;
       return x < 0.0 ? Complex (gnulib::log (-x), pi) : Complex (gnulib::log (x));
     }
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -43,22 +43,28 @@ namespace octave
     extern OCTAVE_API bool is_NA (const FloatComplex& x);
 
     extern OCTAVE_API bool is_NaN_or_NA (const Complex& x);
     extern OCTAVE_API bool is_NaN_or_NA (const FloatComplex& x);
 
     extern OCTAVE_API Complex acos (const Complex& x);
     extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
 
+    using std::acos;
+
     extern OCTAVE_API Complex asin (const Complex& x);
     extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
 
+    using std::asin;
+
     extern OCTAVE_API Complex atan (const Complex& x);
     extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
 
+    using std::atan;
+
     inline double arg (double x) { return atan2 (0.0, x); }
     inline float arg (float x) { return atan2f (0.0f, x); }
 
     using std::arg;
 
     inline double conj (double x) { return x; }
     inline float conj (float x) { return x; }
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -193,3730 +193,3898 @@ extern "C"
                            float*, octave_idx_type*, octave_idx_type*);
 
   F77_RET_T
   F77_FUNC (dpsifn, DPSIFN) (const double*, const octave_idx_type&,
                              const octave_idx_type&, const octave_idx_type&,
                              double*, octave_idx_type*, octave_idx_type*);
 }
 
-double
-xacosh (double x)
-{
-#if defined (HAVE_ACOSH)
-  return acosh (x);
-#else
-  double retval;
-  F77_XFCN (xdacosh, XDACOSH, (x, retval));
-  return retval;
-#endif
-}
-
-float
-xacosh (float x)
-{
-#if defined (HAVE_ACOSHF)
-  return acoshf (x);
-#else
-  float retval;
-  F77_XFCN (xacosh, XACOSH, (x, retval));
-  return retval;
-#endif
-}
-
-Complex
-xacosh (const Complex& x)
-{
-  return log (x + sqrt (x + 1.0) * sqrt (x - 1.0));
-}
-
-FloatComplex
-xacosh (const FloatComplex& x)
-{
-  return log (x + sqrt (x + 1.0f) * sqrt (x - 1.0f));
-}
-
-double
-xasinh (double x)
-{
-#if defined (HAVE_ASINH)
-  return asinh (x);
-#else
-  double retval;
-  F77_XFCN (xdasinh, XDASINH, (x, retval));
-  return retval;
-#endif
-}
-
-float
-xasinh (float x)
-{
-#if defined (HAVE_ASINHF)
-  return asinhf (x);
-#else
-  float retval;
-  F77_XFCN (xasinh, XASINH, (x, retval));
-  return retval;
-#endif
-}
-
-Complex
-xasinh (const Complex& x)
+namespace octave
 {
-  return log (x + sqrt (x*x + 1.0));
-}
-
-FloatComplex
-xasinh (const FloatComplex& x)
-{
-  return log (x + sqrt (x*x + 1.0f));
-}
-
-double
-xatanh (double x)
-{
-#if defined (HAVE_ATANH)
-  return atanh (x);
+  namespace math
+  {
+    double
+    acosh (double x)
+    {
+#if defined (HAVE_ACOSH)
+      return ::acosh (x);
 #else
-  double retval;
-  F77_XFCN (xdatanh, XDATANH, (x, retval));
-  return retval;
+      double retval;
+      F77_XFCN (xdacosh, XDACOSH, (x, retval));
+      return retval;
 #endif
-}
-
-float
-xatanh (float x)
-{
-#if defined (HAVE_ATANHF)
-  return atanhf (x);
+    }
+
+    float
+    acosh (float x)
+    {
+#if defined (HAVE_ACOSHF)
+      return acoshf (x);
 #else
-  float retval;
-  F77_XFCN (xatanh, XATANH, (x, retval));
-  return retval;
+      float retval;
+      F77_XFCN (xacosh, XACOSH, (x, retval));
+      return retval;
 #endif
-}
-
-Complex
-xatanh (const Complex& x)
-{
-  return log ((1.0 + x) / (1.0 - x)) / 2.0;
-}
-
-FloatComplex
-xatanh (const FloatComplex& x)
-{
-  return log ((1.0f + x) / (1.0f - x)) / 2.0f;
-}
-
-double
-xerf (double x)
-{
-#if defined (HAVE_ERF)
-  return erf (x);
+    }
+
+    Complex
+    acosh (const Complex& x)
+    {
+      return log (x + sqrt (x + 1.0) * sqrt (x - 1.0));
+    }
+
+    FloatComplex
+    acosh (const FloatComplex& x)
+    {
+      return log (x + sqrt (x + 1.0f) * sqrt (x - 1.0f));
+    }
+
+    double
+    asinh (double x)
+    {
+#if defined (HAVE_ASINH)
+      return ::asinh (x);
 #else
-  double retval;
-  F77_XFCN (xderf, XDERF, (x, retval));
-  return retval;
+      double retval;
+      F77_XFCN (xdasinh, XDASINH, (x, retval));
+      return retval;
 #endif
-}
-
-float
-xerf (float x)
-{
-#if defined (HAVE_ERFF)
-  return erff (x);
+    }
+
+    float
+    asinh (float x)
+    {
+#if defined (HAVE_ASINHF)
+      return asinhf (x);
 #else
-  float retval;
-  F77_XFCN (xerf, XERF, (x, retval));
-  return retval;
+      float retval;
+      F77_XFCN (xasinh, XASINH, (x, retval));
+      return retval;
 #endif
-}
-
-// Complex error function from the Faddeeva package
-Complex
-xerf (const Complex& x)
-{
-  return Faddeeva::erf (x);
-}
-
-FloatComplex
-xerf (const FloatComplex& x)
-{
-  Complex xd (real (x), imag (x));
-  Complex ret = Faddeeva::erf (xd, std::numeric_limits<float>::epsilon ());
-  return FloatComplex (real (ret), imag (ret));
-}
-
-double
-xerfc (double x)
-{
-#if defined (HAVE_ERFC)
-  return erfc (x);
+    }
+
+    Complex
+    asinh (const Complex& x)
+    {
+      return log (x + sqrt (x*x + 1.0));
+    }
+
+    FloatComplex
+    asinh (const FloatComplex& x)
+    {
+      return log (x + sqrt (x*x + 1.0f));
+    }
+
+    double
+    atanh (double x)
+    {
+#if defined (HAVE_ATANH)
+      return ::atanh (x);
 #else
-  double retval;
-  F77_XFCN (xderfc, XDERFC, (x, retval));
-  return retval;
-#endif
-}
-
-float
-xerfc (float x)
-{
-#if defined (HAVE_ERFCF)
-  return erfcf (x);
-#else
-  float retval;
-  F77_XFCN (xerfc, XERFC, (x, retval));
-  return retval;
+      double retval;
+      F77_XFCN (xdatanh, XDATANH, (x, retval));
+      return retval;
 #endif
-}
-
-// Complex complementary error function from the Faddeeva package
-Complex
-xerfc (const Complex& x)
-{
-  return Faddeeva::erfc (x);
-}
-
-FloatComplex
-xerfc (const FloatComplex& x)
-{
-  Complex xd (real (x), imag (x));
-  Complex ret = Faddeeva::erfc (xd, std::numeric_limits<float>::epsilon ());
-  return FloatComplex (real (ret), imag (ret));
-}
-
-// Real and complex scaled complementary error function from Faddeeva package
-float erfcx (float x) { return Faddeeva::erfcx(x); }
-double erfcx (double x) { return Faddeeva::erfcx(x); }
-Complex
-erfcx (const Complex& x)
-{
-  return Faddeeva::erfcx (x);
-}
-FloatComplex
-erfcx (const FloatComplex& x)
-{
-  Complex xd (real (x), imag (x));
-  Complex ret = Faddeeva::erfcx (xd, std::numeric_limits<float>::epsilon ());
-  return FloatComplex (real (ret), imag (ret));
-}
-
-// Real and complex imaginary error function from Faddeeva package
-float erfi (float x) { return Faddeeva::erfi(x); }
-double erfi (double x) { return Faddeeva::erfi(x); }
-Complex
-erfi (const Complex& x)
-{
-  return Faddeeva::erfi (x);
-}
-FloatComplex
-erfi (const FloatComplex& x)
-{
-  Complex xd (real (x), imag (x));
-  Complex ret = Faddeeva::erfi (xd, std::numeric_limits<float>::epsilon ());
-  return FloatComplex (real (ret), imag (ret));
-}
-
-// Real and complex Dawson function (= scaled erfi) from Faddeeva package
-float dawson (float x) { return Faddeeva::Dawson(x); }
-double dawson (double x) { return Faddeeva::Dawson(x); }
-Complex
-dawson (const Complex& x)
-{
-  return Faddeeva::Dawson (x);
-}
-FloatComplex
-dawson (const FloatComplex& x)
-{
-  Complex xd (real (x), imag (x));
-  Complex ret = Faddeeva::Dawson (xd, std::numeric_limits<float>::epsilon ());
-  return FloatComplex (real (ret), imag (ret));
-}
-
-double
-xgamma (double x)
-{
-  double result;
-
-  // Special cases for (near) compatibility with Matlab instead of
-  // tgamma.  Matlab does not have -0.
-
-  if (x == 0)
-    result = (octave::math::negative_sign (x)
-              ? -octave::numeric_limits<double>::Inf ()
-              : octave::numeric_limits<double>::Inf ());
-  else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<double>::Inf ();
-  else if (octave::math::isnan (x))
-    result = octave::numeric_limits<double>::NaN ();
-  else
+    }
+
+    float
+    atanh (float x)
+    {
+#if defined (HAVE_ATANHF)
+      return atanhf (x);
+#else
+      float retval;
+      F77_XFCN (xatanh, XATANH, (x, retval));
+      return retval;
+#endif
+    }
+
+    Complex
+    atanh (const Complex& x)
+    {
+      return log ((1.0 + x) / (1.0 - x)) / 2.0;
+    }
+
+    FloatComplex
+    atanh (const FloatComplex& x)
     {
-#if defined (HAVE_TGAMMA)
-      result = tgamma (x);
+      return log ((1.0f + x) / (1.0f - x)) / 2.0f;
+    }
+
+    double
+    erf (double x)
+    {
+#if defined (HAVE_ERF)
+      return ::erf (x);
 #else
-      F77_XFCN (xdgamma, XDGAMMA, (x, result));
+      double retval;
+      F77_XFCN (xderf, XDERF, (x, retval));
+      return retval;
+#endif
+    }
+
+    float
+    erf (float x)
+    {
+#if defined (HAVE_ERFF)
+      return erff (x);
+#else
+      float retval;
+      F77_XFCN (xerf, XERF, (x, retval));
+      return retval;
 #endif
     }
 
-  return result;
-}
-
-double
-xlgamma (double x)
-{
-#if defined (HAVE_LGAMMA)
-  return lgamma (x);
+    // Complex error function from the Faddeeva package
+    Complex
+    erf (const Complex& x)
+    {
+      return Faddeeva::erf (x);
+    }
+
+    FloatComplex
+    erf (const FloatComplex& x)
+    {
+      Complex xd (real (x), imag (x));
+      Complex ret = Faddeeva::erf (xd, std::numeric_limits<float>::epsilon ());
+      return FloatComplex (real (ret), imag (ret));
+    }
+
+    double
+    erfc (double x)
+    {
+#if defined (HAVE_ERFC)
+      return ::erfc (x);
+#else
+      double retval;
+      F77_XFCN (xderfc, XDERFC, (x, retval));
+      return retval;
+#endif
+    }
+
+    float
+    erfc (float x)
+    {
+#if defined (HAVE_ERFCF)
+      return erfcf (x);
 #else
-  double result;
-  double sgngam;
-
-  if (octave::math::isnan (x))
-    result = x;
-  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<double>::Inf ();
-  else
-    F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
-
-  return result;
+      float retval;
+      F77_XFCN (xerfc, XERFC, (x, retval));
+      return retval;
 #endif
-}
-
-Complex
-rc_lgamma (double x)
-{
-  double result;
+    }
+
+    // Complex complementary error function from the Faddeeva package
+    Complex
+    erfc (const Complex& x)
+    {
+      return Faddeeva::erfc (x);
+    }
+
+    FloatComplex
+    erfc (const FloatComplex& x)
+    {
+      Complex xd (real (x), imag (x));
+      Complex ret = Faddeeva::erfc (xd, std::numeric_limits<float>::epsilon ());
+      return FloatComplex (real (ret), imag (ret));
+    }
+
+    // Real and complex scaled complementary error function from Faddeeva package
+    float erfcx (float x) { return Faddeeva::erfcx(x); }
+    double erfcx (double x) { return Faddeeva::erfcx(x); }
+
+    Complex
+    erfcx (const Complex& x)
+    {
+      return Faddeeva::erfcx (x);
+    }
+
+    FloatComplex
+    erfcx (const FloatComplex& x)
+    {
+      Complex xd (real (x), imag (x));
+      Complex ret = Faddeeva::erfcx (xd, std::numeric_limits<float>::epsilon ());
+      return FloatComplex (real (ret), imag (ret));
+    }
+
+    // Real and complex imaginary error function from Faddeeva package
+    float erfi (float x) { return Faddeeva::erfi(x); }
+    double erfi (double x) { return Faddeeva::erfi(x); }
+
+    Complex
+    erfi (const Complex& x)
+    {
+      return Faddeeva::erfi (x);
+    }
+
+    FloatComplex
+    erfi (const FloatComplex& x)
+    {
+      Complex xd (real (x), imag (x));
+      Complex ret = Faddeeva::erfi (xd, std::numeric_limits<float>::epsilon ());
+      return FloatComplex (real (ret), imag (ret));
+    }
+
+    // Real and complex Dawson function (= scaled erfi) from Faddeeva package
+    float dawson (float x) { return Faddeeva::Dawson(x); }
+    double dawson (double x) { return Faddeeva::Dawson(x); }
+
+    Complex
+    dawson (const Complex& x)
+    {
+      return Faddeeva::Dawson (x);
+    }
+
+    FloatComplex
+    dawson (const FloatComplex& x)
+    {
+      Complex xd (real (x), imag (x));
+      Complex ret = Faddeeva::Dawson (xd, std::numeric_limits<float>::epsilon ());
+      return FloatComplex (real (ret), imag (ret));
+    }
+
+    double
+    gamma (double x)
+    {
+      double result;
+
+      // Special cases for (near) compatibility with Matlab instead of
+      // tgamma.  Matlab does not have -0.
+
+      if (x == 0)
+        result = (octave::math::negative_sign (x)
+                  ? -octave::numeric_limits<double>::Inf ()
+                  : octave::numeric_limits<double>::Inf ());
+      else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<double>::Inf ();
+      else if (octave::math::isnan (x))
+        result = octave::numeric_limits<double>::NaN ();
+      else
+        {
+#if defined (HAVE_TGAMMA)
+          result = tgamma (x);
+#else
+          F77_XFCN (xdgamma, XDGAMMA, (x, result));
+#endif
+        }
+
+      return result;
+    }
+
+    double
+    lgamma (double x)
+    {
+#if defined (HAVE_LGAMMA)
+      return ::lgamma (x);
+#else
+      double result;
+      double sgngam;
+
+      if (octave::math::isnan (x))
+        result = x;
+      else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<double>::Inf ();
+      else
+        F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
+
+      return result;
+#endif
+    }
+
+    Complex
+    rc_lgamma (double x)
+    {
+      double result;
 
 #if defined (HAVE_LGAMMA_R)
-  int sgngam;
-  result = lgamma_r (x, &sgngam);
-#else
-  double sgngam = 0.0;
-
-  if (octave::math::isnan (x))
-    result = x;
-  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<double>::Inf ();
-  else
-    F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
-
-#endif
-
-  if (sgngam < 0)
-    return result + Complex (0., M_PI);
-  else
-    return result;
-}
-
-float
-xgamma (float x)
-{
-  float result;
-
-  // Special cases for (near) compatibility with Matlab instead of
-  // tgamma.  Matlab does not have -0.
-
-  if (x == 0)
-    result = (octave::math::negative_sign (x)
-              ? -octave::numeric_limits<float>::Inf ()
-              : octave::numeric_limits<float>::Inf ());
-  else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<float>::Inf ();
-  else if (octave::math::isnan (x))
-    result = octave::numeric_limits<float>::NaN ();
-  else
-    {
-#if defined (HAVE_TGAMMA)
-      result = tgammaf (x);
+      int sgngam;
+      result = lgamma_r (x, &sgngam);
 #else
-      F77_XFCN (xgamma, XGAMMA, (x, result));
-#endif
-    }
-
-  return result;
-}
-
-float
-xlgamma (float x)
-{
-#if defined (HAVE_LGAMMAF)
-  return lgammaf (x);
-#else
-  float result;
-  float sgngam;
-
-  if (octave::math::isnan (x))
-    result = x;
-  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<float>::Inf ();
-  else
-    F77_XFCN (algams, ALGAMS, (x, result, sgngam));
-
-  return result;
-#endif
-}
-
-FloatComplex
-rc_lgamma (float x)
-{
-  float result;
-
-#if defined (HAVE_LGAMMAF_R)
-  int sgngam;
-  result = lgammaf_r (x, &sgngam);
-#else
-  float sgngam = 0.0f;
-
-  if (octave::math::isnan (x))
-    result = x;
-  else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
-    result = octave::numeric_limits<float>::Inf ();
-  else
-    F77_XFCN (algams, ALGAMS, (x, result, sgngam));
+      double sgngam = 0.0;
+
+      if (octave::math::isnan (x))
+        result = x;
+      else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<double>::Inf ();
+      else
+        F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
 #endif
 
-  if (sgngam < 0)
-    return result + FloatComplex (0., M_PI);
-  else
-    return result;
-}
-
-double
-xexpm1 (double x)
-{
-#if defined (HAVE_EXPM1)
-  return expm1 (x);
-#else
-  double retval;
-
-  double ax = fabs (x);
-
-  if (ax < 0.1)
-    {
-      ax /= 16;
-
-      // use Taylor series to calculate exp(x)-1.
-      double t = ax;
-      double s = 0;
-      for (int i = 2; i < 7; i++)
-        s += (t *= ax/i);
-      s += ax;
-
-      // use the identity (a+1)^2-1 = a*(a+2)
-      double e = s;
-      for (int i = 0; i < 4; i++)
-        {
-          s *= e + 2;
-          e *= e + 2;
-        }
-
-      retval = (x > 0) ? s : -s / (1+s);
+      if (sgngam < 0)
+        return result + Complex (0., M_PI);
+      else
+        return result;
     }
-  else
-    retval = exp (x) - 1;
-
-  return retval;
-#endif
-}
-
-Complex
-xexpm1 (const Complex& x)
-{
-  Complex retval;
-
-  if (std:: abs (x) < 1)
+
+    float
+    gamma (float x)
     {
-      double im = x.imag ();
-      double u = xexpm1 (x.real ());
-      double v = sin (im/2);
-      v = -2*v*v;
-      retval = Complex (u*v + u + v, (u+1) * sin (im));
+      float result;
+
+      // Special cases for (near) compatibility with Matlab instead of
+      // tgamma.  Matlab does not have -0.
+
+      if (x == 0)
+        result = (octave::math::negative_sign (x)
+                  ? -octave::numeric_limits<float>::Inf ()
+                  : octave::numeric_limits<float>::Inf ());
+      else if ((x < 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<float>::Inf ();
+      else if (octave::math::isnan (x))
+        result = octave::numeric_limits<float>::NaN ();
+      else
+        {
+#if defined (HAVE_TGAMMA)
+          result = tgammaf (x);
+#else
+          F77_XFCN (xgamma, XGAMMA, (x, result));
+#endif
+        }
+
+      return result;
     }
-  else
-    retval = std::exp (x) - Complex (1);
-
-  return retval;
-}
-
-float
-xexpm1 (float x)
-{
-#if defined (HAVE_EXPM1F)
-  return expm1f (x);
-#else
-  float retval;
-
-  float ax = fabs (x);
-
-  if (ax < 0.1)
+
+    float
+    lgamma (float x)
     {
-      ax /= 16;
-
-      // use Taylor series to calculate exp(x)-1.
-      float t = ax;
-      float s = 0;
-      for (int i = 2; i < 7; i++)
-        s += (t *= ax/i);
-      s += ax;
-
-      // use the identity (a+1)^2-1 = a*(a+2)
-      float e = s;
-      for (int i = 0; i < 4; i++)
-        {
-          s *= e + 2;
-          e *= e + 2;
-        }
-
-      retval = (x > 0) ? s : -s / (1+s);
-    }
-  else
-    retval = exp (x) - 1;
-
-  return retval;
+#if defined (HAVE_LGAMMAF)
+      return lgammaf (x);
+#else
+      float result;
+      float sgngam;
+
+      if (octave::math::isnan (x))
+        result = x;
+      else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<float>::Inf ();
+      else
+        F77_XFCN (algams, ALGAMS, (x, result, sgngam));
+
+      return result;
 #endif
-}
-
-FloatComplex
-xexpm1 (const FloatComplex& x)
-{
-  FloatComplex retval;
-
-  if (std:: abs (x) < 1)
-    {
-      float im = x.imag ();
-      float u = xexpm1 (x.real ());
-      float v = sin (im/2);
-      v = -2*v*v;
-      retval = FloatComplex (u*v + u + v, (u+1) * sin (im));
     }
-  else
-    retval = std::exp (x) - FloatComplex (1);
-
-  return retval;
-}
-
-double
-xlog1p (double x)
-{
-#if defined (HAVE_LOG1P)
-  return log1p (x);
+
+    FloatComplex
+    rc_lgamma (float x)
+    {
+      float result;
+
+#if defined (HAVE_LGAMMAF_R)
+      int sgngam;
+      result = lgammaf_r (x, &sgngam);
 #else
-  double retval;
-
-  double ax = fabs (x);
-
-  if (ax < 0.2)
-    {
-      // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
-      double u = x / (2 + x), t = 1, s = 0;
-      for (int i = 2; i < 12; i += 2)
-        s += (t *= u*u) / (i+1);
-
-      retval = 2 * (s + 1) * u;
+      float sgngam = 0.0f;
+
+      if (octave::math::isnan (x))
+        result = x;
+      else if ((x <= 0 && octave::math::x_nint (x) == x) || octave::math::isinf (x))
+        result = octave::numeric_limits<float>::Inf ();
+      else
+        F77_XFCN (algams, ALGAMS, (x, result, sgngam));
+
+#endif
+
+      if (sgngam < 0)
+        return result + FloatComplex (0., M_PI);
+      else
+        return result;
     }
-  else
-    retval = gnulib::log (1 + x);
-
-  return retval;
-#endif
-}
-
-Complex
-xlog1p (const Complex& x)
-{
-  Complex retval;
-
-  double r = x.real (), i = x.imag ();
-
-  if (fabs (r) < 0.5 && fabs (i) < 0.5)
-    {
-      double u = 2*r + r*r + i*i;
-      retval = Complex (xlog1p (u / (1+sqrt (u+1))),
-                        atan2 (1 + r, i));
-    }
-  else
-    retval = std::log (Complex (1) + x);
-
-  return retval;
-}
-
-template <typename T>
-T
-xxcbrt (T x)
-{
-  static const T one_third = 0.3333333333333333333f;
-  if (octave::math::finite (x))
+
+    double
+    expm1 (double x)
     {
-      // Use pow.
-      T y = std::pow (std::abs (x), one_third) * signum (x);
-      // Correct for better accuracy.
-      return (x / (y*y) + y + y) / 3;
-    }
-  else
-    return x;
-}
-
-double
-xcbrt (double x)
-{
-#if defined (HAVE_CBRT)
-  return cbrt (x);
-#else
-  return xxcbrt (x);
-#endif
-}
-
-float
-xlog1p (float x)
-{
-#if defined (HAVE_LOG1PF)
-  return log1pf (x);
+#if defined (HAVE_EXPM1)
+      return ::expm1 (x);
 #else
-  float retval;
-
-  float ax = fabs (x);
-
-  if (ax < 0.2)
-    {
-      // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
-      float u = x / (2 + x), t = 1.0f, s = 0;
-      for (int i = 2; i < 12; i += 2)
-        s += (t *= u*u) / (i+1);
-
-      retval = 2 * (s + 1.0f) * u;
-    }
-  else
-    retval = gnulib::logf (1.0f + x);
-
-  return retval;
-#endif
-}
-
-FloatComplex
-xlog1p (const FloatComplex& x)
-{
-  FloatComplex retval;
-
-  float r = x.real (), i = x.imag ();
-
-  if (fabs (r) < 0.5 && fabs (i) < 0.5)
-    {
-      float u = 2*r + r*r + i*i;
-      retval = FloatComplex (xlog1p (u / (1+sqrt (u+1))),
-                             atan2 (1 + r, i));
-    }
-  else
-    retval = std::log (FloatComplex (1) + x);
-
-  return retval;
-}
-
-float
-xcbrt (float x)
-{
-#if defined (HAVE_CBRTF)
-  return cbrtf (x);
-#else
-  return xxcbrt (x);
+      double retval;
+
+      double ax = fabs (x);
+
+      if (ax < 0.1)
+        {
+          ax /= 16;
+
+          // use Taylor series to calculate exp(x)-1.
+          double t = ax;
+          double s = 0;
+          for (int i = 2; i < 7; i++)
+            s += (t *= ax/i);
+          s += ax;
+
+          // use the identity (a+1)^2-1 = a*(a+2)
+          double e = s;
+          for (int i = 0; i < 4; i++)
+            {
+              s *= e + 2;
+              e *= e + 2;
+            }
+
+          retval = (x > 0) ? s : -s / (1+s);
+        }
+      else
+        retval = exp (x) - 1;
+
+      return retval;
 #endif
-}
-
-static inline Complex
-zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
-
-static inline Complex
-bessel_return_value (const Complex& val, octave_idx_type ierr)
-{
-  static const Complex inf_val
-    = Complex (octave::numeric_limits<double>::Inf (),
-               octave::numeric_limits<double>::Inf ());
-
-  static const Complex nan_val
-    = Complex (octave::numeric_limits<double>::NaN (),
-               octave::numeric_limits<double>::NaN ());
-
-  Complex retval;
-
-  switch (ierr)
+    }
+
+    Complex
+    expm1 (const Complex& x)
     {
-    case 0:
-    case 3:
-      retval = val;
-      break;
-
-    case 2:
-      retval = inf_val;
-      break;
-
-    default:
-      retval = nan_val;
-      break;
+      Complex retval;
+
+      if (std:: abs (x) < 1)
+        {
+          double im = x.imag ();
+          double u = expm1 (x.real ());
+          double v = sin (im/2);
+          v = -2*v*v;
+          retval = Complex (u*v + u + v, (u+1) * sin (im));
+        }
+      else
+        retval = std::exp (x) - Complex (1);
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline bool
-is_integer_value (double x)
-{
-  return x == static_cast<double> (static_cast<long> (x));
-}
-
-static inline Complex
-zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
+    float
+    expm1 (float x)
     {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      F77_FUNC (zbesj, ZBESJ) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
-
-      if (kode != 2)
+#if defined (HAVE_EXPM1F)
+      return expm1f (x);
+#else
+      float retval;
+
+      float ax = fabs (x);
+
+      if (ax < 0.1)
         {
-          double expz = exp (std::abs (zi));
-          yr *= expz;
-          yi *= expz;
+          ax /= 16;
+
+          // use Taylor series to calculate exp(x)-1.
+          float t = ax;
+          float s = 0;
+          for (int i = 2; i < 7; i++)
+            s += (t *= ax/i);
+          s += ax;
+
+          // use the identity (a+1)^2-1 = a*(a+2)
+          float e = s;
+          for (int i = 0; i < 4; i++)
+            {
+              s *= e + 2;
+              e *= e + 2;
+            }
+
+          retval = (x > 0) ? s : -s / (1+s);
         }
-
-      if (zi == 0.0 && zr >= 0.0)
-        yi = 0.0;
-
-      retval = bessel_return_value (Complex (yr, yi), ierr);
+      else
+        retval = exp (x) - 1;
+
+      return retval;
+#endif
     }
-  else if (is_integer_value (alpha))
+
+    FloatComplex
+    expm1 (const FloatComplex& x)
     {
-      // zbesy can overflow as z->0, and cause troubles for generic case below
-      alpha = -alpha;
-      Complex tmp = zbesj (z, alpha, kode, ierr);
-      if ((static_cast<long> (alpha)) & 1)
-        tmp = - tmp;
-      retval = bessel_return_value (tmp, ierr);
-    }
-  else
-    {
-      alpha = -alpha;
-
-      Complex tmp = cos (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
+      FloatComplex retval;
+
+      if (std:: abs (x) < 1)
         {
-          tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
-
-          retval = bessel_return_value (tmp, ierr);
+          float im = x.imag ();
+          float u = expm1 (x.real ());
+          float v = sin (im/2);
+          v = -2*v*v;
+          retval = FloatComplex (u*v + u + v, (u+1) * sin (im));
         }
       else
-        retval = Complex (octave::numeric_limits<double>::NaN (),
-                          octave::numeric_limits<double>::NaN ());
+        retval = std::exp (x) - FloatComplex (1);
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline Complex
-zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
+    double
+    log1p (double x)
+    {
+#if defined (HAVE_LOG1P)
+      return ::log1p (x);
+#else
+      double retval;
+
+      double ax = fabs (x);
+
+      if (ax < 0.2)
+        {
+          // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
+          double u = x / (2 + x), t = 1, s = 0;
+          for (int i = 2; i < 12; i += 2)
+            s += (t *= u*u) / (i+1);
+
+          retval = 2 * (s + 1) * u;
+        }
+      else
+        retval = gnulib::log (1 + x);
+
+      return retval;
+#endif
+    }
+
+    Complex
+    log1p (const Complex& x)
     {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double wr, wi;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      ierr = 0;
-
-      if (zr == 0.0 && zi == 0.0)
+      Complex retval;
+
+      double r = x.real (), i = x.imag ();
+
+      if (fabs (r) < 0.5 && fabs (i) < 0.5)
+        {
+          double u = 2*r + r*r + i*i;
+          retval = Complex (log1p (u / (1+sqrt (u+1))),
+                            atan2 (1 + r, i));
+        }
+      else
+        retval = std::log (Complex (1) + x);
+
+      return retval;
+    }
+
+    template <typename T>
+    T
+    xcbrt (T x)
+    {
+      static const T one_third = 0.3333333333333333333f;
+      if (octave::math::finite (x))
         {
-          yr = -octave::numeric_limits<double>::Inf ();
-          yi = 0.0;
+          // Use pow.
+          T y = std::pow (std::abs (x), one_third) * signum (x);
+          // Correct for better accuracy.
+          return (x / (y*y) + y + y) / 3;
+        }
+      else
+        return x;
+    }
+
+    double
+    cbrt (double x)
+    {
+#if defined (HAVE_CBRT)
+      return ::cbrt (x);
+#else
+      return xxcbrt (x);
+#endif
+    }
+
+    float
+    log1p (float x)
+    {
+#if defined (HAVE_LOG1PF)
+      return log1pf (x);
+#else
+      float retval;
+
+      float ax = fabs (x);
+
+      if (ax < 0.2)
+        {
+          // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
+          float u = x / (2 + x), t = 1.0f, s = 0;
+          for (int i = 2; i < 12; i += 2)
+            s += (t *= u*u) / (i+1);
+
+          retval = 2 * (s + 1.0f) * u;
         }
       else
+        retval = gnulib::logf (1.0f + x);
+
+      return retval;
+#endif
+    }
+
+    FloatComplex
+    log1p (const FloatComplex& x)
+    {
+      FloatComplex retval;
+
+      float r = x.real (), i = x.imag ();
+
+      if (fabs (r) < 0.5 && fabs (i) < 0.5)
         {
-          F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
-                                   &wr, &wi, ierr);
+          float u = 2*r + r*r + i*i;
+          retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
+                                 atan2 (1 + r, i));
+        }
+      else
+        retval = std::log (FloatComplex (1) + x);
+
+      return retval;
+    }
+
+    float
+    cbrt (float x)
+    {
+#if defined (HAVE_CBRTF)
+      return cbrtf (x);
+#else
+      return xxcbrt (x);
+#endif
+    }
+
+    static inline Complex
+    zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
+
+    static inline Complex
+    bessel_return_value (const Complex& val, octave_idx_type ierr)
+    {
+      static const Complex inf_val
+        = Complex (octave::numeric_limits<double>::Inf (),
+                   octave::numeric_limits<double>::Inf ());
+
+      static const Complex nan_val
+        = Complex (octave::numeric_limits<double>::NaN (),
+                   octave::numeric_limits<double>::NaN ());
+
+      Complex retval;
+
+      switch (ierr)
+        {
+        case 0:
+        case 3:
+          retval = val;
+          break;
+
+        case 2:
+          retval = inf_val;
+          break;
+
+        default:
+          retval = nan_val;
+          break;
+        }
+
+      return retval;
+    }
+
+    static inline bool
+    is_integer_value (double x)
+    {
+      return x == static_cast<double> (static_cast<long> (x));
+    }
+
+    static inline Complex
+    zbesj (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
+    {
+      Complex retval;
+
+      if (alpha >= 0.0)
+        {
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          F77_FUNC (zbesj, ZBESJ) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
           if (kode != 2)
             {
               double expz = exp (std::abs (zi));
               yr *= expz;
               yi *= expz;
             }
 
           if (zi == 0.0 && zr >= 0.0)
             yi = 0.0;
+
+          retval = bessel_return_value (Complex (yr, yi), ierr);
         }
-
-      return bessel_return_value (Complex (yr, yi), ierr);
+      else if (is_integer_value (alpha))
+        {
+          // zbesy can overflow as z->0, and cause troubles for generic case below
+          alpha = -alpha;
+          Complex tmp = zbesj (z, alpha, kode, ierr);
+          if ((static_cast<long> (alpha)) & 1)
+            tmp = - tmp;
+          retval = bessel_return_value (tmp, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          Complex tmp = cos (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = Complex (octave::numeric_limits<double>::NaN (),
+                              octave::numeric_limits<double>::NaN ());
+        }
+
+      return retval;
     }
-  else if (is_integer_value (alpha - 0.5))
+
+    static inline Complex
+    zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
-      // zbesy can overflow as z->0, and cause troubles for generic case below
-      alpha = -alpha;
-      Complex tmp = zbesj (z, alpha, kode, ierr);
-      if ((static_cast<long> (alpha - 0.5)) & 1)
-        tmp = - tmp;
-      retval = bessel_return_value (tmp, ierr);
+      Complex retval;
+
+      if (alpha >= 0.0)
+        {
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double wr, wi;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          ierr = 0;
+
+          if (zr == 0.0 && zi == 0.0)
+            {
+              yr = -octave::numeric_limits<double>::Inf ();
+              yi = 0.0;
+            }
+          else
+            {
+              F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
+                                       &wr, &wi, ierr);
+
+              if (kode != 2)
+                {
+                  double expz = exp (std::abs (zi));
+                  yr *= expz;
+                  yi *= expz;
+                }
+
+              if (zi == 0.0 && zr >= 0.0)
+                yi = 0.0;
+            }
+
+          return bessel_return_value (Complex (yr, yi), ierr);
+        }
+      else if (is_integer_value (alpha - 0.5))
+        {
+          // zbesy can overflow as z->0, and cause troubles for generic case below
+          alpha = -alpha;
+          Complex tmp = zbesj (z, alpha, kode, ierr);
+          if ((static_cast<long> (alpha - 0.5)) & 1)
+            tmp = - tmp;
+          retval = bessel_return_value (tmp, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          Complex tmp = cos (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = Complex (octave::numeric_limits<double>::NaN (),
+                              octave::numeric_limits<double>::NaN ());
+        }
+
+      return retval;
     }
-  else
+
+    static inline Complex
+    zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
-      alpha = -alpha;
-
-      Complex tmp = cos (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
+      Complex retval;
+
+      if (alpha >= 0.0)
         {
-          tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
-
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          F77_FUNC (zbesi, ZBESI) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
+
+          if (kode != 2)
+            {
+              double expz = exp (std::abs (zr));
+              yr *= expz;
+              yi *= expz;
+            }
+
+          if (zi == 0.0 && zr >= 0.0)
+            yi = 0.0;
+
+          retval = bessel_return_value (Complex (yr, yi), ierr);
+        }
+      else if (is_integer_value (alpha))
+        {
+          // zbesi can overflow as z->0, and cause troubles for generic case below
+          alpha = -alpha;
+          Complex tmp = zbesi (z, alpha, kode, ierr);
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = Complex (octave::numeric_limits<double>::NaN (),
-                          octave::numeric_limits<double>::NaN ());
-    }
-
-  return retval;
-}
-
-static inline Complex
-zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
-    {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      F77_FUNC (zbesi, ZBESI) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
-
-      if (kode != 2)
         {
-          double expz = exp (std::abs (zr));
-          yr *= expz;
-          yi *= expz;
+          alpha = -alpha;
+
+          Complex tmp = zbesi (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
+                * zbesk (z, alpha, kode, ierr);
+
+              if (kode == 2)
+                {
+                  // Compensate for different scaling factor of besk.
+                  tmp2 *= exp (-z - std::abs (z.real ()));
+                }
+
+              tmp += tmp2;
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = Complex (octave::numeric_limits<double>::NaN (),
+                              octave::numeric_limits<double>::NaN ());
         }
 
-      if (zi == 0.0 && zr >= 0.0)
-        yi = 0.0;
-
-      retval = bessel_return_value (Complex (yr, yi), ierr);
+      return retval;
     }
-  else if (is_integer_value (alpha))
-    {
-      // zbesi can overflow as z->0, and cause troubles for generic case below
-      alpha = -alpha;
-      Complex tmp = zbesi (z, alpha, kode, ierr);
-      retval = bessel_return_value (tmp, ierr);
-    }
-  else
+
+    static inline Complex
+    zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
-      alpha = -alpha;
-
-      Complex tmp = zbesi (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
+      Complex retval;
+
+      if (alpha >= 0.0)
         {
-          Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
-                         * zbesk (z, alpha, kode, ierr);
-
-          if (kode == 2)
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          ierr = 0;
+
+          if (zr == 0.0 && zi == 0.0)
+            {
+              yr = octave::numeric_limits<double>::Inf ();
+              yi = 0.0;
+            }
+          else
             {
-              // Compensate for different scaling factor of besk.
-              tmp2 *= exp (-z - std::abs (z.real ()));
+              F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
+
+              if (kode != 2)
+                {
+                  Complex expz = exp (-z);
+
+                  double rexpz = real (expz);
+                  double iexpz = imag (expz);
+
+                  double tmp = yr*rexpz - yi*iexpz;
+
+                  yi = yr*iexpz + yi*rexpz;
+                  yr = tmp;
+                }
+
+              if (zi == 0.0 && zr >= 0.0)
+                yi = 0.0;
             }
 
-          tmp += tmp2;
+          retval = bessel_return_value (Complex (yr, yi), ierr);
+        }
+      else
+        {
+          Complex tmp = zbesk (z, -alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
-      else
-        retval = Complex (octave::numeric_limits<double>::NaN (),
-                          octave::numeric_limits<double>::NaN ());
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline Complex
-zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
+    static inline Complex
+    zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      ierr = 0;
-
-      if (zr == 0.0 && zi == 0.0)
+      Complex retval;
+
+      if (alpha >= 0.0)
         {
-          yr = octave::numeric_limits<double>::Inf ();
-          yi = 0.0;
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 1, 1, &yr, &yi, nz, ierr);
+
+          if (kode != 2)
+            {
+              Complex expz = exp (Complex (0.0, 1.0) * z);
+
+              double rexpz = real (expz);
+              double iexpz = imag (expz);
+
+              double tmp = yr*rexpz - yi*iexpz;
+
+              yi = yr*iexpz + yi*rexpz;
+              yr = tmp;
+            }
+
+          retval = bessel_return_value (Complex (yr, yi), ierr);
         }
       else
         {
-          F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
+          alpha = -alpha;
+
+          static const Complex eye = Complex (0.0, 1.0);
+
+          Complex tmp = exp (M_PI * alpha * eye) * zbesh1 (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
+
+      return retval;
+    }
+
+    static inline Complex
+    zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
+    {
+      Complex retval;
+
+      if (alpha >= 0.0)
+        {
+          double yr = 0.0;
+          double yi = 0.0;
+
+          octave_idx_type nz;
+
+          double zr = z.real ();
+          double zi = z.imag ();
+
+          F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 2, 1, &yr, &yi, nz, ierr);
 
           if (kode != 2)
             {
-              Complex expz = exp (-z);
+              Complex expz = exp (-Complex (0.0, 1.0) * z);
 
               double rexpz = real (expz);
               double iexpz = imag (expz);
 
               double tmp = yr*rexpz - yi*iexpz;
 
               yi = yr*iexpz + yi*rexpz;
               yr = tmp;
             }
 
-          if (zi == 0.0 && zr >= 0.0)
-            yi = 0.0;
+          retval = bessel_return_value (Complex (yr, yi), ierr);
         }
-
-      retval = bessel_return_value (Complex (yr, yi), ierr);
-    }
-  else
-    {
-      Complex tmp = zbesk (z, -alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
+      else
+        {
+          alpha = -alpha;
+
+          static const Complex eye = Complex (0.0, 1.0);
+
+          Complex tmp = exp (-M_PI * alpha * eye) * zbesh2 (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline Complex
-zbesh1 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
-    {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 1, 1, &yr, &yi, nz, ierr);
-
-      if (kode != 2)
-        {
-          Complex expz = exp (Complex (0.0, 1.0) * z);
-
-          double rexpz = real (expz);
-          double iexpz = imag (expz);
-
-          double tmp = yr*rexpz - yi*iexpz;
-
-          yi = yr*iexpz + yi*rexpz;
-          yr = tmp;
-        }
-
-      retval = bessel_return_value (Complex (yr, yi), ierr);
-    }
-  else
+    typedef Complex (*dptr) (const Complex&, double, int, octave_idx_type&);
+
+    static inline Complex
+    do_bessel (dptr f, const char *, double alpha, const Complex& x,
+               bool scaled, octave_idx_type& ierr)
     {
-      alpha = -alpha;
-
-      static const Complex eye = Complex (0.0, 1.0);
-
-      Complex tmp = exp (M_PI * alpha * eye) * zbesh1 (z, alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
+      Complex retval;
+
+      retval = f (x, alpha, (scaled ? 2 : 1), ierr);
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline Complex
-zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  if (alpha >= 0.0)
+    static inline ComplexMatrix
+    do_bessel (dptr f, const char *, double alpha, const ComplexMatrix& x,
+               bool scaled, Array<octave_idx_type>& ierr)
     {
-      double yr = 0.0;
-      double yi = 0.0;
-
-      octave_idx_type nz;
-
-      double zr = z.real ();
-      double zi = z.imag ();
-
-      F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 2, 1, &yr, &yi, nz, ierr);
-
-      if (kode != 2)
-        {
-          Complex expz = exp (-Complex (0.0, 1.0) * z);
-
-          double rexpz = real (expz);
-          double iexpz = imag (expz);
-
-          double tmp = yr*rexpz - yi*iexpz;
-
-          yi = yr*iexpz + yi*rexpz;
-          yr = tmp;
-        }
-
-      retval = bessel_return_value (Complex (yr, yi), ierr);
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      ComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
     }
-  else
+
+    static inline ComplexMatrix
+    do_bessel (dptr f, const char *, const Matrix& alpha, const Complex& x,
+               bool scaled, Array<octave_idx_type>& ierr)
     {
-      alpha = -alpha;
-
-      static const Complex eye = Complex (0.0, 1.0);
-
-      Complex tmp = exp (-M_PI * alpha * eye) * zbesh2 (z, alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
+      octave_idx_type nr = alpha.rows ();
+      octave_idx_type nc = alpha.cols ();
+
+      ComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
     }
 
-  return retval;
-}
-
-typedef Complex (*dptr) (const Complex&, double, int, octave_idx_type&);
-
-static inline Complex
-do_bessel (dptr f, const char *, double alpha, const Complex& x,
-           bool scaled, octave_idx_type& ierr)
-{
-  Complex retval;
-
-  retval = f (x, alpha, (scaled ? 2 : 1), ierr);
-
-  return retval;
-}
-
-static inline ComplexMatrix
-do_bessel (dptr f, const char *, double alpha, const ComplexMatrix& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  ComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline ComplexMatrix
-do_bessel (dptr f, const char *, const Matrix& alpha, const Complex& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = alpha.rows ();
-  octave_idx_type nc = alpha.cols ();
-
-  ComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline ComplexMatrix
-do_bessel (dptr f, const char *fn, const Matrix& alpha,
-           const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr)
-{
-  ComplexMatrix retval;
-
-  octave_idx_type x_nr = x.rows ();
-  octave_idx_type x_nc = x.cols ();
-
-  octave_idx_type alpha_nr = alpha.rows ();
-  octave_idx_type alpha_nc = alpha.cols ();
-
-  if (x_nr != alpha_nr || x_nc != alpha_nc)
-    (*current_liboctave_error_handler)
-      ("%s: the sizes of alpha and x must conform", fn);
-
-  octave_idx_type nr = x_nr;
-  octave_idx_type nc = x_nc;
-
-  retval.resize (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline ComplexNDArray
-do_bessel (dptr f, const char *, double alpha, const ComplexNDArray& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-  ComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline ComplexNDArray
-do_bessel (dptr f, const char *, const NDArray& alpha, const Complex& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = alpha.dims ();
-  octave_idx_type nel = dv.numel ();
-  ComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline ComplexNDArray
-do_bessel (dptr f, const char *fn, const NDArray& alpha,
-           const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = x.dims ();
-  ComplexNDArray retval;
-
-  if (dv != alpha.dims ())
-    (*current_liboctave_error_handler)
-      ("%s: the sizes of alpha and x must conform", fn);
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline ComplexMatrix
-do_bessel (dptr f, const char *, const RowVector& alpha,
-           const ComplexColumnVector& x, bool scaled,
-           Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = x.numel ();
-  octave_idx_type nc = alpha.numel ();
-
-  ComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
+    static inline ComplexMatrix
+    do_bessel (dptr f, const char *fn, const Matrix& alpha,
+               const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr)
+    {
+      ComplexMatrix retval;
+
+      octave_idx_type x_nr = x.rows ();
+      octave_idx_type x_nc = x.cols ();
+
+      octave_idx_type alpha_nr = alpha.rows ();
+      octave_idx_type alpha_nc = alpha.cols ();
+
+      if (x_nr != alpha_nr || x_nc != alpha_nc)
+        (*current_liboctave_error_handler)
+          ("%s: the sizes of alpha and x must conform", fn);
+
+      octave_idx_type nr = x_nr;
+      octave_idx_type nc = x_nc;
+
+      retval.resize (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
+
+    static inline ComplexNDArray
+    do_bessel (dptr f, const char *, double alpha, const ComplexNDArray& x,
+               bool scaled, Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+      ComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline ComplexNDArray
+    do_bessel (dptr f, const char *, const NDArray& alpha, const Complex& x,
+               bool scaled, Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = alpha.dims ();
+      octave_idx_type nel = dv.numel ();
+      ComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline ComplexNDArray
+    do_bessel (dptr f, const char *fn, const NDArray& alpha,
+               const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = x.dims ();
+      ComplexNDArray retval;
+
+      if (dv != alpha.dims ())
+        (*current_liboctave_error_handler)
+          ("%s: the sizes of alpha and x must conform", fn);
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline ComplexMatrix
+    do_bessel (dptr f, const char *, const RowVector& alpha,
+               const ComplexColumnVector& x, bool scaled,
+               Array<octave_idx_type>& ierr)
+    {
+      octave_idx_type nr = x.numel ();
+      octave_idx_type nc = alpha.numel ();
+
+      ComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
 
 #define SS_BESSEL(name, fcn) \
-  Complex \
-  name (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    Complex \
+    name (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define SM_BESSEL(name, fcn) \
-  ComplexMatrix \
-  name (double alpha, const ComplexMatrix& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexMatrix \
+    name (double alpha, const ComplexMatrix& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define MS_BESSEL(name, fcn) \
-  ComplexMatrix \
-  name (const Matrix& alpha, const Complex& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexMatrix \
+    name (const Matrix& alpha, const Complex& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define MM_BESSEL(name, fcn) \
-  ComplexMatrix \
-  name (const Matrix& alpha, const ComplexMatrix& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexMatrix \
+    name (const Matrix& alpha, const ComplexMatrix& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define SN_BESSEL(name, fcn) \
-  ComplexNDArray \
-  name (double alpha, const ComplexNDArray& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexNDArray \
+    name (double alpha, const ComplexNDArray& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define NS_BESSEL(name, fcn) \
-  ComplexNDArray \
-  name (const NDArray& alpha, const Complex& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexNDArray \
+    name (const NDArray& alpha, const Complex& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define NN_BESSEL(name, fcn) \
-  ComplexNDArray \
-  name (const NDArray& alpha, const ComplexNDArray& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexNDArray \
+    name (const NDArray& alpha, const ComplexNDArray& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define RC_BESSEL(name, fcn) \
-  ComplexMatrix \
-  name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
+    ComplexMatrix \
+    name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
 
 #define ALL_BESSEL(name, fcn) \
-  SS_BESSEL (name, fcn) \
-  SM_BESSEL (name, fcn) \
-  MS_BESSEL (name, fcn) \
-  MM_BESSEL (name, fcn) \
-  SN_BESSEL (name, fcn) \
-  NS_BESSEL (name, fcn) \
-  NN_BESSEL (name, fcn) \
-  RC_BESSEL (name, fcn)
-
-ALL_BESSEL (besselj, zbesj)
-ALL_BESSEL (bessely, zbesy)
-ALL_BESSEL (besseli, zbesi)
-ALL_BESSEL (besselk, zbesk)
-ALL_BESSEL (besselh1, zbesh1)
-ALL_BESSEL (besselh2, zbesh2)
+    SS_BESSEL (name, fcn) \
+    SM_BESSEL (name, fcn) \
+    MS_BESSEL (name, fcn) \
+    MM_BESSEL (name, fcn) \
+    SN_BESSEL (name, fcn) \
+    NS_BESSEL (name, fcn) \
+    NN_BESSEL (name, fcn) \
+    RC_BESSEL (name, fcn)
+
+    ALL_BESSEL (besselj, zbesj)
+    ALL_BESSEL (bessely, zbesy)
+    ALL_BESSEL (besseli, zbesi)
+    ALL_BESSEL (besselk, zbesk)
+    ALL_BESSEL (besselh1, zbesh1)
+    ALL_BESSEL (besselh2, zbesh2)
+
+#undef ALL_BESSEL
+#undef SS_BESSEL
+#undef SM_BESSEL
+#undef MS_BESSEL
+#undef MM_BESSEL
+#undef SN_BESSEL
+#undef NS_BESSEL
+#undef NN_BESSEL
+#undef RC_BESSEL
+
+    static inline FloatComplex
+    cbesj (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    cbesh1 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
+
+    static inline FloatComplex
+    bessel_return_value (const FloatComplex& val, octave_idx_type ierr)
+    {
+      static const FloatComplex inf_val
+        = FloatComplex (octave::numeric_limits<float>::Inf (),
+                        octave::numeric_limits<float>::Inf ());
+
+      static const FloatComplex nan_val
+        = FloatComplex (octave::numeric_limits<float>::NaN (),
+                        octave::numeric_limits<float>::NaN ());
+
+      FloatComplex retval;
+
+      switch (ierr)
+        {
+        case 0:
+        case 3:
+          retval = val;
+          break;
+
+        case 2:
+          retval = inf_val;
+          break;
+
+        default:
+          retval = nan_val;
+          break;
+        }
+
+      return retval;
+    }
+
+    static inline bool
+    is_integer_value (float x)
+    {
+      return x == static_cast<float> (static_cast<long> (x));
+    }
+
+    static inline FloatComplex
+    cbesj (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          F77_FUNC (cbesj, CBESJ) (z, alpha, 2, 1, &y, nz, ierr);
+
+          if (kode != 2)
+            {
+              float expz = exp (std::abs (imag (z)));
+              y *= expz;
+            }
+
+          if (imag (z) == 0.0 && real (z) >= 0.0)
+            y = FloatComplex (y.real (), 0.0);
+
+          retval = bessel_return_value (y, ierr);
+        }
+      else if (is_integer_value (alpha))
+        {
+          // zbesy can overflow as z->0, and cause troubles for generic case below
+          alpha = -alpha;
+          FloatComplex tmp = cbesj (z, alpha, kode, ierr);
+          if ((static_cast<long> (alpha)) & 1)
+            tmp = - tmp;
+          retval = bessel_return_value (tmp, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
+            * cbesj (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              tmp -= sinf (static_cast<float> (M_PI) * alpha)
+                * cbesy (z, alpha, kode, ierr);
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                                   octave::numeric_limits<float>::NaN ());
+        }
+
+      return retval;
+    }
+
+    static inline FloatComplex
+    cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          FloatComplex w;
+
+          ierr = 0;
+
+          if (real (z) == 0.0 && imag (z) == 0.0)
+            {
+              y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
+            }
+          else
+            {
+              F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
+
+              if (kode != 2)
+                {
+                  float expz = exp (std::abs (imag (z)));
+                  y *= expz;
+                }
+
+              if (imag (z) == 0.0 && real (z) >= 0.0)
+                y = FloatComplex (y.real (), 0.0);
+            }
+
+          return bessel_return_value (y, ierr);
+        }
+      else if (is_integer_value (alpha - 0.5))
+        {
+          // zbesy can overflow as z->0, and cause troubles for generic case below
+          alpha = -alpha;
+          FloatComplex tmp = cbesj (z, alpha, kode, ierr);
+          if ((static_cast<long> (alpha - 0.5)) & 1)
+            tmp = - tmp;
+          retval = bessel_return_value (tmp, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
+            * cbesy (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              tmp += sinf (static_cast<float> (M_PI) * alpha)
+                * cbesj (z, alpha, kode, ierr);
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                                   octave::numeric_limits<float>::NaN ());
+        }
+
+      return retval;
+    }
+
+    static inline FloatComplex
+    cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          F77_FUNC (cbesi, CBESI) (z, alpha, 2, 1, &y, nz, ierr);
+
+          if (kode != 2)
+            {
+              float expz = exp (std::abs (real (z)));
+              y *= expz;
+            }
+
+          if (imag (z) == 0.0 && real (z) >= 0.0)
+            y = FloatComplex (y.real (), 0.0);
+
+          retval = bessel_return_value (y, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          FloatComplex tmp = cbesi (z, alpha, kode, ierr);
+
+          if (ierr == 0 || ierr == 3)
+            {
+              FloatComplex tmp2 = static_cast<float> (2.0 / M_PI)
+                * sinf (static_cast<float> (M_PI) * alpha)
+                * cbesk (z, alpha, kode, ierr);
+
+              if (kode == 2)
+                {
+                  // Compensate for different scaling factor of besk.
+                  tmp2 *= exp (-z - std::abs (z.real ()));
+                }
+
+              tmp += tmp2;
+
+              retval = bessel_return_value (tmp, ierr);
+            }
+          else
+            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                                   octave::numeric_limits<float>::NaN ());
+        }
+
+      return retval;
+    }
+
+    static inline FloatComplex
+    cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          ierr = 0;
+
+          if (real (z) == 0.0 && imag (z) == 0.0)
+            {
+              y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
+            }
+          else
+            {
+              F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
+
+              if (kode != 2)
+                {
+                  FloatComplex expz = exp (-z);
+
+                  float rexpz = real (expz);
+                  float iexpz = imag (expz);
+
+                  float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+                  float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+                  y = FloatComplex (tmp_r, tmp_i);
+                }
+
+              if (imag (z) == 0.0 && real (z) >= 0.0)
+                y = FloatComplex (y.real (), 0.0);
+            }
+
+          retval = bessel_return_value (y, ierr);
+        }
+      else
+        {
+          FloatComplex tmp = cbesk (z, -alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
+
+      return retval;
+    }
+
+    static inline FloatComplex
+    cbesh1 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          F77_FUNC (cbesh, CBESH) (z, alpha, 2, 1, 1, &y, nz, ierr);
+
+          if (kode != 2)
+            {
+              FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
+
+              float rexpz = real (expz);
+              float iexpz = imag (expz);
+
+              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+              y = FloatComplex (tmp_r, tmp_i);
+            }
+
+          retval = bessel_return_value (y, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          static const FloatComplex eye = FloatComplex (0.0, 1.0);
+
+          FloatComplex tmp = exp (static_cast<float> (M_PI) * alpha * eye)
+            * cbesh1 (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
+
+      return retval;
+    }
+
+    static inline FloatComplex
+    cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      if (alpha >= 0.0)
+        {
+          FloatComplex y = 0.0;
+
+          octave_idx_type nz;
+
+          F77_FUNC (cbesh, CBESH) (z, alpha, 2, 2, 1, &y, nz, ierr);
+
+          if (kode != 2)
+            {
+              FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
+
+              float rexpz = real (expz);
+              float iexpz = imag (expz);
+
+              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
+              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+
+              y = FloatComplex (tmp_r, tmp_i);
+            }
+
+          retval = bessel_return_value (y, ierr);
+        }
+      else
+        {
+          alpha = -alpha;
+
+          static const FloatComplex eye = FloatComplex (0.0, 1.0);
+
+          FloatComplex tmp = exp (-static_cast<float> (M_PI) * alpha * eye)
+            * cbesh2 (z, alpha, kode, ierr);
+
+          retval = bessel_return_value (tmp, ierr);
+        }
+
+      return retval;
+    }
+
+    typedef FloatComplex (*fptr) (const FloatComplex&, float, int,
+                                  octave_idx_type&);
+
+    static inline FloatComplex
+    do_bessel (fptr f, const char *, float alpha, const FloatComplex& x,
+               bool scaled, octave_idx_type& ierr)
+    {
+      FloatComplex retval;
+
+      retval = f (x, alpha, (scaled ? 2 : 1), ierr);
+
+      return retval;
+    }
+
+    static inline FloatComplexMatrix
+    do_bessel (fptr f, const char *, float alpha, const FloatComplexMatrix& x,
+               bool scaled, Array<octave_idx_type>& ierr)
+    {
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      FloatComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
+
+    static inline FloatComplexMatrix
+    do_bessel (fptr f, const char *, const FloatMatrix& alpha,
+               const FloatComplex& x,
+               bool scaled, Array<octave_idx_type>& ierr)
+    {
+      octave_idx_type nr = alpha.rows ();
+      octave_idx_type nc = alpha.cols ();
+
+      FloatComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
+
+    static inline FloatComplexMatrix
+    do_bessel (fptr f, const char *fn, const FloatMatrix& alpha,
+               const FloatComplexMatrix& x, bool scaled,
+               Array<octave_idx_type>& ierr)
+    {
+      FloatComplexMatrix retval;
+
+      octave_idx_type x_nr = x.rows ();
+      octave_idx_type x_nc = x.cols ();
+
+      octave_idx_type alpha_nr = alpha.rows ();
+      octave_idx_type alpha_nc = alpha.cols ();
+
+      if (x_nr != alpha_nr || x_nc != alpha_nc)
+        (*current_liboctave_error_handler)
+          ("%s: the sizes of alpha and x must conform", fn);
+
+      octave_idx_type nr = x_nr;
+      octave_idx_type nc = x_nc;
+
+      retval.resize (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
+
+    static inline FloatComplexNDArray
+    do_bessel (fptr f, const char *, float alpha, const FloatComplexNDArray& x,
+               bool scaled, Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+      FloatComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline FloatComplexNDArray
+    do_bessel (fptr f, const char *, const FloatNDArray& alpha,
+               const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = alpha.dims ();
+      octave_idx_type nel = dv.numel ();
+      FloatComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline FloatComplexNDArray
+    do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
+               const FloatComplexNDArray& x, bool scaled,
+               Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = x.dims ();
+      FloatComplexNDArray retval;
+
+      if (dv != alpha.dims ())
+        (*current_liboctave_error_handler)
+          ("%s: the sizes of alpha and x must conform", fn);
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
+
+      return retval;
+    }
+
+    static inline FloatComplexMatrix
+    do_bessel (fptr f, const char *, const FloatRowVector& alpha,
+               const FloatComplexColumnVector& x, bool scaled,
+               Array<octave_idx_type>& ierr)
+    {
+      octave_idx_type nr = x.numel ();
+      octave_idx_type nc = alpha.numel ();
+
+      FloatComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
+
+      return retval;
+    }
+
+#define SS_BESSEL(name, fcn) \
+    FloatComplex \
+    name (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define SM_BESSEL(name, fcn) \
+    FloatComplexMatrix \
+    name (float alpha, const FloatComplexMatrix& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define MS_BESSEL(name, fcn) \
+    FloatComplexMatrix \
+    name (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define MM_BESSEL(name, fcn) \
+    FloatComplexMatrix \
+    name (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define SN_BESSEL(name, fcn) \
+    FloatComplexNDArray \
+    name (float alpha, const FloatComplexNDArray& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define NS_BESSEL(name, fcn) \
+    FloatComplexNDArray \
+    name (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define NN_BESSEL(name, fcn) \
+    FloatComplexNDArray \
+    name (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define RC_BESSEL(name, fcn) \
+    FloatComplexMatrix \
+    name (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, \
+          Array<octave_idx_type>& ierr) \
+    { \
+      return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
+    }
+
+#define ALL_BESSEL(name, fcn) \
+    SS_BESSEL (name, fcn) \
+    SM_BESSEL (name, fcn) \
+    MS_BESSEL (name, fcn) \
+    MM_BESSEL (name, fcn) \
+    SN_BESSEL (name, fcn) \
+    NS_BESSEL (name, fcn) \
+    NN_BESSEL (name, fcn) \
+    RC_BESSEL (name, fcn)
+
+    ALL_BESSEL (besselj, cbesj)
+    ALL_BESSEL (bessely, cbesy)
+    ALL_BESSEL (besseli, cbesi)
+    ALL_BESSEL (besselk, cbesk)
+    ALL_BESSEL (besselh1, cbesh1)
+    ALL_BESSEL (besselh2, cbesh2)
 
 #undef ALL_BESSEL
 #undef SS_BESSEL
 #undef SM_BESSEL
 #undef MS_BESSEL
 #undef MM_BESSEL
 #undef SN_BESSEL
 #undef NS_BESSEL
 #undef NN_BESSEL
 #undef RC_BESSEL
 
-static inline FloatComplex
-cbesj (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-cbesh1 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
-
-static inline FloatComplex
-bessel_return_value (const FloatComplex& val, octave_idx_type ierr)
-{
-  static const FloatComplex inf_val
-    = FloatComplex (octave::numeric_limits<float>::Inf (),
-                    octave::numeric_limits<float>::Inf ());
-
-  static const FloatComplex nan_val
-    = FloatComplex (octave::numeric_limits<float>::NaN (),
-                    octave::numeric_limits<float>::NaN ());
-
-  FloatComplex retval;
-
-  switch (ierr)
+    Complex
+    airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
-    case 0:
-    case 3:
-      retval = val;
-      break;
-
-    case 2:
-      retval = inf_val;
-      break;
-
-    default:
-      retval = nan_val;
-      break;
-    }
-
-  return retval;
-}
-
-static inline bool
-is_integer_value (float x)
-{
-  return x == static_cast<float> (static_cast<long> (x));
-}
-
-static inline FloatComplex
-cbesj (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
-    {
-      FloatComplex y = 0.0;
-
-      octave_idx_type nz;
-
-      F77_FUNC (cbesj, CBESJ) (z, alpha, 2, 1, &y, nz, ierr);
-
-      if (kode != 2)
-        {
-          float expz = exp (std::abs (imag (z)));
-          y *= expz;
-        }
-
-      if (imag (z) == 0.0 && real (z) >= 0.0)
-        y = FloatComplex (y.real (), 0.0);
-
-      retval = bessel_return_value (y, ierr);
-    }
-  else if (is_integer_value (alpha))
-    {
-      // zbesy can overflow as z->0, and cause troubles for generic case below
-      alpha = -alpha;
-      FloatComplex tmp = cbesj (z, alpha, kode, ierr);
-      if ((static_cast<long> (alpha)) & 1)
-        tmp = - tmp;
-      retval = bessel_return_value (tmp, ierr);
-    }
-  else
-    {
-      alpha = -alpha;
-
-      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
-                         * cbesj (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
-        {
-          tmp -= sinf (static_cast<float> (M_PI) * alpha)
-                 * cbesy (z, alpha, kode, ierr);
-
-          retval = bessel_return_value (tmp, ierr);
-        }
-      else
-        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                               octave::numeric_limits<float>::NaN ());
-    }
-
-  return retval;
-}
-
-static inline FloatComplex
-cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
-    {
-      FloatComplex y = 0.0;
+      double ar = 0.0;
+      double ai = 0.0;
 
       octave_idx_type nz;
 
-      FloatComplex w;
-
-      ierr = 0;
-
-      if (real (z) == 0.0 && imag (z) == 0.0)
-        {
-          y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
-        }
-      else
+      double zr = z.real ();
+      double zi = z.imag ();
+
+      octave_idx_type id = deriv ? 1 : 0;
+
+      F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
+
+      if (! scaled)
         {
-          F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
-
-          if (kode != 2)
-            {
-              float expz = exp (std::abs (imag (z)));
-              y *= expz;
-            }
-
-          if (imag (z) == 0.0 && real (z) >= 0.0)
-            y = FloatComplex (y.real (), 0.0);
+          Complex expz = exp (- 2.0 / 3.0 * z * sqrt (z));
+
+          double rexpz = real (expz);
+          double iexpz = imag (expz);
+
+          double tmp = ar*rexpz - ai*iexpz;
+
+          ai = ar*iexpz + ai*rexpz;
+          ar = tmp;
         }
 
-      return bessel_return_value (y, ierr);
+      if (zi == 0.0 && (! scaled || zr >= 0.0))
+        ai = 0.0;
+
+      return bessel_return_value (Complex (ar, ai), ierr);
     }
-  else if (is_integer_value (alpha - 0.5))
+
+    Complex
+    biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
+    {
+      double ar = 0.0;
+      double ai = 0.0;
+
+      double zr = z.real ();
+      double zi = z.imag ();
+
+      octave_idx_type id = deriv ? 1 : 0;
+
+      F77_FUNC (zbiry, ZBIRY) (zr, zi, id, 2, ar, ai, ierr);
+
+      if (! scaled)
+        {
+          Complex expz = exp (std::abs (real (2.0 / 3.0 * z * sqrt (z))));
+
+          double rexpz = real (expz);
+          double iexpz = imag (expz);
+
+          double tmp = ar*rexpz - ai*iexpz;
+
+          ai = ar*iexpz + ai*rexpz;
+          ar = tmp;
+        }
+
+      if (zi == 0.0 && (! scaled || zr >= 0.0))
+        ai = 0.0;
+
+      return bessel_return_value (Complex (ar, ai), ierr);
+    }
+
+    ComplexMatrix
+    airy (const ComplexMatrix& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      // zbesy can overflow as z->0, and cause troubles for generic case below
-      alpha = -alpha;
-      FloatComplex tmp = cbesj (z, alpha, kode, ierr);
-      if ((static_cast<long> (alpha - 0.5)) & 1)
-        tmp = - tmp;
-      retval = bessel_return_value (tmp, ierr);
+      octave_idx_type nr = z.rows ();
+      octave_idx_type nc = z.cols ();
+
+      ComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
+
+      return retval;
     }
-  else
+
+    ComplexMatrix
+    biry (const ComplexMatrix& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      alpha = -alpha;
-
-      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
-                         * cbesy (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
-        {
-          tmp += sinf (static_cast<float> (M_PI) * alpha)
-                 * cbesj (z, alpha, kode, ierr);
-
-          retval = bessel_return_value (tmp, ierr);
-        }
-      else
-        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                               octave::numeric_limits<float>::NaN ());
+      octave_idx_type nr = z.rows ();
+      octave_idx_type nc = z.cols ();
+
+      ComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
+
+      return retval;
     }
 
-  return retval;
-}
-
-static inline FloatComplex
-cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
+    ComplexNDArray
+    airy (const ComplexNDArray& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      FloatComplex y = 0.0;
+      dim_vector dv = z.dims ();
+      octave_idx_type nel = dv.numel ();
+      ComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = airy (z(i), deriv, scaled, ierr(i));
+
+      return retval;
+    }
+
+    ComplexNDArray
+    biry (const ComplexNDArray& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = z.dims ();
+      octave_idx_type nel = dv.numel ();
+      ComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = biry (z(i), deriv, scaled, ierr(i));
+
+      return retval;
+    }
+
+    FloatComplex
+    airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
+    {
+      float ar = 0.0;
+      float ai = 0.0;
 
       octave_idx_type nz;
 
-      F77_FUNC (cbesi, CBESI) (z, alpha, 2, 1, &y, nz, ierr);
-
-      if (kode != 2)
-        {
-          float expz = exp (std::abs (real (z)));
-          y *= expz;
-        }
-
-      if (imag (z) == 0.0 && real (z) >= 0.0)
-        y = FloatComplex (y.real (), 0.0);
-
-      retval = bessel_return_value (y, ierr);
-    }
-  else
-    {
-      alpha = -alpha;
-
-      FloatComplex tmp = cbesi (z, alpha, kode, ierr);
-
-      if (ierr == 0 || ierr == 3)
+      float zr = z.real ();
+      float zi = z.imag ();
+
+      octave_idx_type id = deriv ? 1 : 0;
+
+      F77_FUNC (cairy, CAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
+
+      if (! scaled)
         {
-          FloatComplex tmp2 = static_cast<float> (2.0 / M_PI)
-                              * sinf (static_cast<float> (M_PI) * alpha)
-                              * cbesk (z, alpha, kode, ierr);
-
-          if (kode == 2)
-            {
-              // Compensate for different scaling factor of besk.
-              tmp2 *= exp (-z - std::abs (z.real ()));
-            }
-
-          tmp += tmp2;
-
-          retval = bessel_return_value (tmp, ierr);
-        }
-      else
-        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                               octave::numeric_limits<float>::NaN ());
-    }
-
-  return retval;
-}
-
-static inline FloatComplex
-cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
-    {
-      FloatComplex y = 0.0;
-
-      octave_idx_type nz;
-
-      ierr = 0;
-
-      if (real (z) == 0.0 && imag (z) == 0.0)
-        {
-          y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
-        }
-      else
-        {
-          F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
-
-          if (kode != 2)
-            {
-              FloatComplex expz = exp (-z);
-
-              float rexpz = real (expz);
-              float iexpz = imag (expz);
-
-              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-              y = FloatComplex (tmp_r, tmp_i);
-            }
-
-          if (imag (z) == 0.0 && real (z) >= 0.0)
-            y = FloatComplex (y.real (), 0.0);
-        }
-
-      retval = bessel_return_value (y, ierr);
-    }
-  else
-    {
-      FloatComplex tmp = cbesk (z, -alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
-    }
-
-  return retval;
-}
-
-static inline FloatComplex
-cbesh1 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
-    {
-      FloatComplex y = 0.0;
-
-      octave_idx_type nz;
-
-      F77_FUNC (cbesh, CBESH) (z, alpha, 2, 1, 1, &y, nz, ierr);
-
-      if (kode != 2)
-        {
-          FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
+          FloatComplex expz = exp (- 2.0f / 3.0f * z * sqrt (z));
 
           float rexpz = real (expz);
           float iexpz = imag (expz);
 
-          float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-          float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-          y = FloatComplex (tmp_r, tmp_i);
+          float tmp = ar*rexpz - ai*iexpz;
+
+          ai = ar*iexpz + ai*rexpz;
+          ar = tmp;
         }
 
-      retval = bessel_return_value (y, ierr);
-    }
-  else
-    {
-      alpha = -alpha;
-
-      static const FloatComplex eye = FloatComplex (0.0, 1.0);
-
-      FloatComplex tmp = exp (static_cast<float> (M_PI) * alpha * eye)
-                         * cbesh1 (z, alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
+      if (zi == 0.0 && (! scaled || zr >= 0.0))
+        ai = 0.0;
+
+      return bessel_return_value (FloatComplex (ar, ai), ierr);
     }
 
-  return retval;
-}
-
-static inline FloatComplex
-cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  if (alpha >= 0.0)
+    FloatComplex
+    biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
-      FloatComplex y = 0.0;
-
-      octave_idx_type nz;
-
-      F77_FUNC (cbesh, CBESH) (z, alpha, 2, 2, 1, &y, nz, ierr);
-
-      if (kode != 2)
+      float ar = 0.0;
+      float ai = 0.0;
+
+      float zr = z.real ();
+      float zi = z.imag ();
+
+      octave_idx_type id = deriv ? 1 : 0;
+
+      F77_FUNC (cbiry, CBIRY) (zr, zi, id, 2, ar, ai, ierr);
+
+      if (! scaled)
         {
-          FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
+          FloatComplex expz = exp (std::abs (real (2.0f / 3.0f * z * sqrt (z))));
 
           float rexpz = real (expz);
           float iexpz = imag (expz);
 
-          float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-          float tmp_i = real (y) * iexpz + imag (y) * rexpz;
-
-          y = FloatComplex (tmp_r, tmp_i);
+          float tmp = ar*rexpz - ai*iexpz;
+
+          ai = ar*iexpz + ai*rexpz;
+          ar = tmp;
         }
 
-      retval = bessel_return_value (y, ierr);
-    }
-  else
-    {
-      alpha = -alpha;
-
-      static const FloatComplex eye = FloatComplex (0.0, 1.0);
-
-      FloatComplex tmp = exp (-static_cast<float> (M_PI) * alpha * eye)
-                         * cbesh2 (z, alpha, kode, ierr);
-
-      retval = bessel_return_value (tmp, ierr);
+      if (zi == 0.0 && (! scaled || zr >= 0.0))
+        ai = 0.0;
+
+      return bessel_return_value (FloatComplex (ar, ai), ierr);
     }
 
-  return retval;
-}
-
-typedef FloatComplex (*fptr) (const FloatComplex&, float, int,
-                              octave_idx_type&);
-
-static inline FloatComplex
-do_bessel (fptr f, const char *, float alpha, const FloatComplex& x,
-           bool scaled, octave_idx_type& ierr)
-{
-  FloatComplex retval;
-
-  retval = f (x, alpha, (scaled ? 2 : 1), ierr);
-
-  return retval;
-}
-
-static inline FloatComplexMatrix
-do_bessel (fptr f, const char *, float alpha, const FloatComplexMatrix& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  FloatComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline FloatComplexMatrix
-do_bessel (fptr f, const char *, const FloatMatrix& alpha,
-           const FloatComplex& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = alpha.rows ();
-  octave_idx_type nc = alpha.cols ();
-
-  FloatComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline FloatComplexMatrix
-do_bessel (fptr f, const char *fn, const FloatMatrix& alpha,
-           const FloatComplexMatrix& x, bool scaled,
-           Array<octave_idx_type>& ierr)
-{
-  FloatComplexMatrix retval;
-
-  octave_idx_type x_nr = x.rows ();
-  octave_idx_type x_nc = x.cols ();
-
-  octave_idx_type alpha_nr = alpha.rows ();
-  octave_idx_type alpha_nc = alpha.cols ();
-
-  if (x_nr != alpha_nr || x_nc != alpha_nc)
-    (*current_liboctave_error_handler)
-      ("%s: the sizes of alpha and x must conform", fn);
-
-  octave_idx_type nr = x_nr;
-  octave_idx_type nc = x_nc;
-
-  retval.resize (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i,j), alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-static inline FloatComplexNDArray
-do_bessel (fptr f, const char *, float alpha, const FloatComplexNDArray& x,
-           bool scaled, Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-  FloatComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline FloatComplexNDArray
-do_bessel (fptr f, const char *, const FloatNDArray& alpha,
-           const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = alpha.dims ();
-  octave_idx_type nel = dv.numel ();
-  FloatComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline FloatComplexNDArray
-do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
-           const FloatComplexNDArray& x, bool scaled,
-           Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = x.dims ();
-  FloatComplexNDArray retval;
-
-  if (dv != alpha.dims ())
-    (*current_liboctave_error_handler)
-      ("%s: the sizes of alpha and x must conform", fn);
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = f (x(i), alpha(i), (scaled ? 2 : 1), ierr(i));
-
-  return retval;
-}
-
-static inline FloatComplexMatrix
-do_bessel (fptr f, const char *, const FloatRowVector& alpha,
-           const FloatComplexColumnVector& x, bool scaled,
-           Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = x.numel ();
-  octave_idx_type nc = alpha.numel ();
-
-  FloatComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (x(i), alpha(j), (scaled ? 2 : 1), ierr(i,j));
-
-  return retval;
-}
-
-#define SS_BESSEL(name, fcn) \
-  FloatComplex \
-  name (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define SM_BESSEL(name, fcn) \
-  FloatComplexMatrix \
-  name (float alpha, const FloatComplexMatrix& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define MS_BESSEL(name, fcn) \
-  FloatComplexMatrix \
-  name (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define MM_BESSEL(name, fcn) \
-  FloatComplexMatrix \
-  name (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define SN_BESSEL(name, fcn) \
-  FloatComplexNDArray \
-  name (float alpha, const FloatComplexNDArray& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define NS_BESSEL(name, fcn) \
-  FloatComplexNDArray \
-  name (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define NN_BESSEL(name, fcn) \
-  FloatComplexNDArray \
-  name (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define RC_BESSEL(name, fcn) \
-  FloatComplexMatrix \
-  name (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, \
-        Array<octave_idx_type>& ierr) \
-  { \
-    return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
-  }
-
-#define ALL_BESSEL(name, fcn) \
-  SS_BESSEL (name, fcn) \
-  SM_BESSEL (name, fcn) \
-  MS_BESSEL (name, fcn) \
-  MM_BESSEL (name, fcn) \
-  SN_BESSEL (name, fcn) \
-  NS_BESSEL (name, fcn) \
-  NN_BESSEL (name, fcn) \
-  RC_BESSEL (name, fcn)
-
-ALL_BESSEL (besselj, cbesj)
-ALL_BESSEL (bessely, cbesy)
-ALL_BESSEL (besseli, cbesi)
-ALL_BESSEL (besselk, cbesk)
-ALL_BESSEL (besselh1, cbesh1)
-ALL_BESSEL (besselh2, cbesh2)
-
-#undef ALL_BESSEL
-#undef SS_BESSEL
-#undef SM_BESSEL
-#undef MS_BESSEL
-#undef MM_BESSEL
-#undef SN_BESSEL
-#undef NS_BESSEL
-#undef NN_BESSEL
-#undef RC_BESSEL
-
-Complex
-airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
-{
-  double ar = 0.0;
-  double ai = 0.0;
-
-  octave_idx_type nz;
-
-  double zr = z.real ();
-  double zi = z.imag ();
-
-  octave_idx_type id = deriv ? 1 : 0;
-
-  F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
-
-  if (! scaled)
+    FloatComplexMatrix
+    airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      Complex expz = exp (- 2.0 / 3.0 * z * sqrt (z));
-
-      double rexpz = real (expz);
-      double iexpz = imag (expz);
-
-      double tmp = ar*rexpz - ai*iexpz;
-
-      ai = ar*iexpz + ai*rexpz;
-      ar = tmp;
-    }
-
-  if (zi == 0.0 && (! scaled || zr >= 0.0))
-    ai = 0.0;
-
-  return bessel_return_value (Complex (ar, ai), ierr);
-}
-
-Complex
-biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr)
-{
-  double ar = 0.0;
-  double ai = 0.0;
-
-  double zr = z.real ();
-  double zi = z.imag ();
-
-  octave_idx_type id = deriv ? 1 : 0;
-
-  F77_FUNC (zbiry, ZBIRY) (zr, zi, id, 2, ar, ai, ierr);
-
-  if (! scaled)
-    {
-      Complex expz = exp (std::abs (real (2.0 / 3.0 * z * sqrt (z))));
-
-      double rexpz = real (expz);
-      double iexpz = imag (expz);
-
-      double tmp = ar*rexpz - ai*iexpz;
-
-      ai = ar*iexpz + ai*rexpz;
-      ar = tmp;
+      octave_idx_type nr = z.rows ();
+      octave_idx_type nc = z.cols ();
+
+      FloatComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
+
+      return retval;
     }
 
-  if (zi == 0.0 && (! scaled || zr >= 0.0))
-    ai = 0.0;
-
-  return bessel_return_value (Complex (ar, ai), ierr);
-}
-
-ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = z.rows ();
-  octave_idx_type nc = z.cols ();
-
-  ComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
-
-  return retval;
-}
-
-ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = z.rows ();
-  octave_idx_type nc = z.cols ();
-
-  ComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
-
-  return retval;
-}
-
-ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = z.dims ();
-  octave_idx_type nel = dv.numel ();
-  ComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = airy (z(i), deriv, scaled, ierr(i));
-
-  return retval;
-}
-
-ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = z.dims ();
-  octave_idx_type nel = dv.numel ();
-  ComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = biry (z(i), deriv, scaled, ierr(i));
-
-  return retval;
-}
-
-FloatComplex
-airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
-{
-  float ar = 0.0;
-  float ai = 0.0;
-
-  octave_idx_type nz;
-
-  float zr = z.real ();
-  float zi = z.imag ();
-
-  octave_idx_type id = deriv ? 1 : 0;
-
-  F77_FUNC (cairy, CAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
-
-  if (! scaled)
+    FloatComplexMatrix
+    biry (const FloatComplexMatrix& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      FloatComplex expz = exp (- 2.0f / 3.0f * z * sqrt (z));
-
-      float rexpz = real (expz);
-      float iexpz = imag (expz);
-
-      float tmp = ar*rexpz - ai*iexpz;
-
-      ai = ar*iexpz + ai*rexpz;
-      ar = tmp;
-    }
-
-  if (zi == 0.0 && (! scaled || zr >= 0.0))
-    ai = 0.0;
-
-  return bessel_return_value (FloatComplex (ar, ai), ierr);
-}
-
-FloatComplex
-biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
-{
-  float ar = 0.0;
-  float ai = 0.0;
-
-  float zr = z.real ();
-  float zi = z.imag ();
-
-  octave_idx_type id = deriv ? 1 : 0;
-
-  F77_FUNC (cbiry, CBIRY) (zr, zi, id, 2, ar, ai, ierr);
-
-  if (! scaled)
-    {
-      FloatComplex expz = exp (std::abs (real (2.0f / 3.0f * z * sqrt (z))));
-
-      float rexpz = real (expz);
-      float iexpz = imag (expz);
-
-      float tmp = ar*rexpz - ai*iexpz;
-
-      ai = ar*iexpz + ai*rexpz;
-      ar = tmp;
+      octave_idx_type nr = z.rows ();
+      octave_idx_type nc = z.cols ();
+
+      FloatComplexMatrix retval (nr, nc);
+
+      ierr.resize (dim_vector (nr, nc));
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
+
+      return retval;
     }
 
-  if (zi == 0.0 && (! scaled || zr >= 0.0))
-    ai = 0.0;
-
-  return bessel_return_value (FloatComplex (ar, ai), ierr);
-}
-
-FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = z.rows ();
-  octave_idx_type nc = z.cols ();
-
-  FloatComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
-
-  return retval;
-}
-
-FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  octave_idx_type nr = z.rows ();
-  octave_idx_type nc = z.cols ();
-
-  FloatComplexMatrix retval (nr, nc);
-
-  ierr.resize (dim_vector (nr, nc));
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
-
-  return retval;
-}
-
-FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = z.dims ();
-  octave_idx_type nel = dv.numel ();
-  FloatComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = airy (z(i), deriv, scaled, ierr(i));
-
-  return retval;
-}
-
-FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr)
-{
-  dim_vector dv = z.dims ();
-  octave_idx_type nel = dv.numel ();
-  FloatComplexNDArray retval (dv);
-
-  ierr.resize (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval(i) = biry (z(i), deriv, scaled, ierr(i));
-
-  return retval;
-}
-
-OCTAVE_NORETURN static void
-err_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
-                             const dim_vector& d3)
-{
-  std::string d1_str = d1.str ();
-  std::string d2_str = d2.str ();
-  std::string d3_str = d3.str ();
-
-  (*current_liboctave_error_handler)
-    ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
-     d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
-}
-
-OCTAVE_NORETURN static void
-err_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
-                                const dim_vector& d3)
-{
-  std::string d1_str = d1.str ();
-  std::string d2_str = d2.str ();
-  std::string d3_str = d3.str ();
-
-  (*current_liboctave_error_handler)
-    ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
-     d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
-}
-
-double
-betainc (double x, double a, double b)
-{
-  double retval;
-  F77_XFCN (xdbetai, XDBETAI, (x, a, b, retval));
-  return retval;
-}
-
-Array<double>
-betainc (double x, double a, const Array<double>& b)
-{
-  dim_vector dv = b.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a, b(i));
-
-  return retval;
-}
-
-Array<double>
-betainc (double x, const Array<double>& a, double b)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a(i), b);
-
-  return retval;
-}
-
-Array<double>
-betainc (double x, const Array<double>& a, const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = a.dims ();
-
-  if (dv != b.dims ())
-    err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a(i), b(i));
-
-  return retval;
-}
-
-Array<double>
-betainc (const Array<double>& x, double a, double b)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a, b);
-
-  return retval;
-}
-
-Array<double>
-betainc (const Array<double>& x, double a, const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != b.dims ())
-    err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a, b(i));
-
-  return retval;
-}
-
-Array<double>
-betainc (const Array<double>& x, const Array<double>& a, double b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims ())
-    err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a(i), b);
-
-  return retval;
-}
-
-Array<double>
-betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims () || dv != b.dims ())
-    err_betainc_nonconformant (dv, a.dims (), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a(i), b(i));
-
-  return retval;
-}
-
-float
-betainc (float x, float a, float b)
-{
-  float retval;
-  F77_XFCN (xbetai, XBETAI, (x, a, b, retval));
-  return retval;
-}
-
-Array<float>
-betainc (float x, float a, const Array<float>& b)
-{
-  dim_vector dv = b.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<float> retval (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a, b(i));
-
-  return retval;
-}
-
-Array<float>
-betainc (float x, const Array<float>& a, float b)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<float> retval (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a(i), b);
-
-  return retval;
-}
-
-Array<float>
-betainc (float x, const Array<float>& a, const Array<float>& b)
-{
-  Array<float> retval;
-  dim_vector dv = a.dims ();
-
-  if (dv != b.dims ())
-    err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x, a(i), b(i));
-
-  return retval;
-}
-
-Array<float>
-betainc (const Array<float>& x, float a, float b)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<float> retval (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a, b);
-
-  return retval;
-}
-
-Array<float>
-betainc (const Array<float>& x, float a, const Array<float>& b)
-{
-  Array<float> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != b.dims ())
-    err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a, b(i));
-
-  return retval;
-}
-
-Array<float>
-betainc (const Array<float>& x, const Array<float>& a, float b)
-{
-  Array<float> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims ())
-    err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a(i), b);
-
-  return retval;
-}
-
-Array<float>
-betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b)
-{
-  Array<float> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims () || dv != b.dims ())
-    err_betainc_nonconformant (dv, a.dims (), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  float *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betainc (x(i), a(i), b(i));
-
-  return retval;
-}
-
-// FIXME: there is still room for improvement here...
-
-double
-gammainc (double x, double a, bool& err)
-{
-  if (a < 0.0 || x < 0.0)
-    (*current_liboctave_error_handler)
-      ("gammainc: A and X must be non-negative");
-
-  err = false;
-
-  double retval;
-
-  F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
-
-  return retval;
-}
-
-Matrix
-gammainc (double x, const Matrix& a)
-{
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  Matrix retval (nr, nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x, a(i,j), err);
-
-        if (err)
-          return Matrix ();
-      }
-
-  return retval;
-}
-
-Matrix
-gammainc (const Matrix& x, double a)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  Matrix retval (nr, nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x(i,j), a, err);
-
-        if (err)
-          return Matrix ();
-      }
-
-  return retval;
-}
-
-Matrix
-gammainc (const Matrix& x, const Matrix& a)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    (*current_liboctave_error_handler)
-      ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
-       nr, nc, a_nr, a_nc);
-
-  Matrix retval (nr, nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x(i,j), a(i,j), err);
-
-        if (err)
-          return Matrix ();
-      }
-
-  return retval;
-}
-
-NDArray
-gammainc (double x, const NDArray& a)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  NDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    FloatComplexNDArray
+    airy (const FloatComplexNDArray& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
+    {
+      dim_vector dv = z.dims ();
+      octave_idx_type nel = dv.numel ();
+      FloatComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = airy (z(i), deriv, scaled, ierr(i));
+
+      return retval;
+    }
+
+    FloatComplexNDArray
+    biry (const FloatComplexNDArray& z, bool deriv, bool scaled,
+          Array<octave_idx_type>& ierr)
     {
-      retval(i) = gammainc (x, a(i), err);
-
-      if (err)
-        return NDArray ();
+      dim_vector dv = z.dims ();
+      octave_idx_type nel = dv.numel ();
+      FloatComplexNDArray retval (dv);
+
+      ierr.resize (dv);
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        retval(i) = biry (z(i), deriv, scaled, ierr(i));
+
+      return retval;
     }
 
-  return retval;
-}
-
-NDArray
-gammainc (const NDArray& x, double a)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  NDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    OCTAVE_NORETURN static void
+    err_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
+                               const dim_vector& d3)
     {
-      retval(i) = gammainc (x(i), a, err);
-
-      if (err)
-        return NDArray ();
+      std::string d1_str = d1.str ();
+      std::string d2_str = d2.str ();
+      std::string d3_str = d3.str ();
+
+      (*current_liboctave_error_handler)
+        ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
+         d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
     }
 
-  return retval;
-}
-
-NDArray
-gammainc (const NDArray& x, const NDArray& a)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  if (dv != a.dims ())
+    OCTAVE_NORETURN static void
+    err_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
+                                  const dim_vector& d3)
     {
-      std::string x_str = dv.str ();
-      std::string a_str = a.dims ().str ();
+      std::string d1_str = d1.str ();
+      std::string d2_str = d2.str ();
+      std::string d3_str = d3.str ();
 
       (*current_liboctave_error_handler)
-        ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-         x_str.c_str (), a_str.c_str ());
+        ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
+         d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
+    }
+
+    double
+    betainc (double x, double a, double b)
+    {
+      double retval;
+      F77_XFCN (xdbetai, XDBETAI, (x, a, b, retval));
+      return retval;
+    }
+
+    Array<double>
+    betainc (double x, double a, const Array<double>& b)
+    {
+      dim_vector dv = b.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a, b(i));
+
+      return retval;
+    }
+
+    Array<double>
+    betainc (double x, const Array<double>& a, double b)
+    {
+      dim_vector dv = a.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a(i), b);
+
+      return retval;
+    }
+
+    Array<double>
+    betainc (double x, const Array<double>& a, const Array<double>& b)
+    {
+      Array<double> retval;
+      dim_vector dv = a.dims ();
+
+      if (dv != b.dims ())
+        err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a(i), b(i));
+
+      return retval;
+    }
+
+    Array<double>
+    betainc (const Array<double>& x, double a, double b)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a, b);
+
+      return retval;
+    }
+
+    Array<double>
+    betainc (const Array<double>& x, double a, const Array<double>& b)
+    {
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != b.dims ())
+        err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a, b(i));
+
+      return retval;
     }
 
-  NDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    Array<double>
+    betainc (const Array<double>& x, const Array<double>& a, double b)
+    {
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims ())
+        err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a(i), b);
+
+      return retval;
+    }
+
+    Array<double>
+    betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b)
+    {
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims () || dv != b.dims ())
+        err_betainc_nonconformant (dv, a.dims (), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a(i), b(i));
+
+      return retval;
+    }
+
+    float
+    betainc (float x, float a, float b)
     {
-      retval(i) = gammainc (x(i), a(i), err);
-
-      if (err)
-        return NDArray ();
+      float retval;
+      F77_XFCN (xbetai, XBETAI, (x, a, b, retval));
+      return retval;
+    }
+
+    Array<float>
+    betainc (float x, float a, const Array<float>& b)
+    {
+      dim_vector dv = b.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<float> retval (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a, b(i));
+
+      return retval;
+    }
+
+    Array<float>
+    betainc (float x, const Array<float>& a, float b)
+    {
+      dim_vector dv = a.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<float> retval (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a(i), b);
+
+      return retval;
+    }
+
+    Array<float>
+    betainc (float x, const Array<float>& a, const Array<float>& b)
+    {
+      Array<float> retval;
+      dim_vector dv = a.dims ();
+
+      if (dv != b.dims ())
+        err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x, a(i), b(i));
+
+      return retval;
     }
 
-  return retval;
-}
-
-float
-gammainc (float x, float a, bool& err)
-{
-  if (a < 0.0 || x < 0.0)
-    (*current_liboctave_error_handler)
-      ("gammainc: A and X must be non-negative");
-
-  err = false;
-
-  float retval;
-
-  F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
-
-  return retval;
-}
-
-FloatMatrix
-gammainc (float x, const FloatMatrix& a)
-{
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  FloatMatrix retval (nr,  nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x, a(i,j), err);
-
-        if (err)
-          return FloatMatrix ();
-      }
-
-  return retval;
-}
-
-FloatMatrix
-gammainc (const FloatMatrix& x, float a)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  FloatMatrix retval (nr, nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x(i,j), a, err);
-
-        if (err)
-          return FloatMatrix ();
-      }
-
-  return retval;
-}
-
-FloatMatrix
-gammainc (const FloatMatrix& x, const FloatMatrix& a)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (nr != a_nr || nc != a_nc)
-    (*current_liboctave_error_handler)
-      ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
-       nr, nc, a_nr, a_nc);
-
-  FloatMatrix retval (nr, nc);
-
-  bool err;
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      {
-        retval(i,j) = gammainc (x(i,j), a(i,j), err);
-
-        if (err)
-          return FloatMatrix ();
-      }
-
-  return retval;
-}
-
-FloatNDArray
-gammainc (float x, const FloatNDArray& a)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  FloatNDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    Array<float>
+    betainc (const Array<float>& x, float a, float b)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<float> retval (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a, b);
+
+      return retval;
+    }
+
+    Array<float>
+    betainc (const Array<float>& x, float a, const Array<float>& b)
+    {
+      Array<float> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != b.dims ())
+        err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a, b(i));
+
+      return retval;
+    }
+
+    Array<float>
+    betainc (const Array<float>& x, const Array<float>& a, float b)
+    {
+      Array<float> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims ())
+        err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a(i), b);
+
+      return retval;
+    }
+
+    Array<float>
+    betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b)
+    {
+      Array<float> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims () || dv != b.dims ())
+        err_betainc_nonconformant (dv, a.dims (), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      float *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betainc (x(i), a(i), b(i));
+
+      return retval;
+    }
+
+    // FIXME: there is still room for improvement here...
+
+    double
+    gammainc (double x, double a, bool& err)
+    {
+      if (a < 0.0 || x < 0.0)
+        (*current_liboctave_error_handler)
+              ("gammainc: A and X must be non-negative");
+
+      err = false;
+
+      double retval;
+
+      F77_XFCN (xgammainc, XGAMMAINC, (a, x, retval));
+
+      return retval;
+    }
+
+    Matrix
+    gammainc (double x, const Matrix& a)
     {
-      retval(i) = gammainc (x, a(i), err);
-
-      if (err)
-        return FloatNDArray ();
+      octave_idx_type nr = a.rows ();
+      octave_idx_type nc = a.cols ();
+
+      Matrix retval (nr, nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x, a(i,j), err);
+
+            if (err)
+              return Matrix ();
+          }
+
+      return retval;
     }
 
-  return retval;
-}
-
-FloatNDArray
-gammainc (const FloatNDArray& x, float a)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  FloatNDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    Matrix
+    gammainc (const Matrix& x, double a)
     {
-      retval(i) = gammainc (x(i), a, err);
-
-      if (err)
-        return FloatNDArray ();
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      Matrix retval (nr, nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x(i,j), a, err);
+
+            if (err)
+              return Matrix ();
+          }
+
+      return retval;
     }
 
-  return retval;
-}
-
-FloatNDArray
-gammainc (const FloatNDArray& x, const FloatNDArray& a)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  if (dv != a.dims ())
+    Matrix
+    gammainc (const Matrix& x, const Matrix& a)
+    {
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      if (nr != a_nr || nc != a_nc)
+        (*current_liboctave_error_handler)
+          ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
+           nr, nc, a_nr, a_nc);
+
+      Matrix retval (nr, nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x(i,j), a(i,j), err);
+
+            if (err)
+              return Matrix ();
+          }
+
+      return retval;
+    }
+
+    NDArray
+    gammainc (double x, const NDArray& a)
     {
-      std::string x_str = dv.str ();
-      std::string a_str = a.dims ().str ();
-
-      (*current_liboctave_error_handler)
-        ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-         x_str.c_str (), a_str.c_str ());
+      dim_vector dv = a.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      NDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x, a(i), err);
+
+          if (err)
+            return NDArray ();
+        }
+
+      return retval;
     }
 
-  FloatNDArray retval (dv);
-
-  bool err;
-
-  for (octave_idx_type i = 0; i < nel; i++)
+    NDArray
+    gammainc (const NDArray& x, double a)
     {
-      retval(i) = gammainc (x(i), a(i), err);
-
-      if (err)
-        return FloatNDArray ();
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      NDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x(i), a, err);
+
+          if (err)
+            return NDArray ();
+        }
+
+      return retval;
     }
 
-  return retval;
-}
-
-
-Complex rc_log1p (double x)
-{
-  const double pi = 3.14159265358979323846;
-  return (x < -1.0
-          ? Complex (gnulib::log (-(1.0 + x)), pi)
-          : Complex (xlog1p (x)));
-}
-
-FloatComplex rc_log1p (float x)
-{
-  const float pi = 3.14159265358979323846f;
-  return (x < -1.0f
-          ? FloatComplex (gnulib::logf (-(1.0f + x)), pi)
-          : FloatComplex (xlog1p (x)));
-}
-
-// This algorithm is due to P. J. Acklam.
-//
-// See http://home.online.no/~pjacklam/notes/invnorm/
-//
-// The rational approximation has relative accuracy 1.15e-9 in the whole
-// region.  For doubles, it is refined by a single step of Halley's 3rd
-// order method.  For single precision, the accuracy is already OK, so
-// we skip it to get faster evaluation.
-
-static double do_erfinv (double x, bool refine)
-{
-  // Coefficients of rational approximation.
-  static const double a[] =
-  {
-    -2.806989788730439e+01,  1.562324844726888e+02,
-    -1.951109208597547e+02,  9.783370457507161e+01,
-    -2.168328665628878e+01,  1.772453852905383e+00
-  };
-  static const double b[] =
-  {
-    -5.447609879822406e+01,  1.615858368580409e+02,
-    -1.556989798598866e+02,  6.680131188771972e+01,
-    -1.328068155288572e+01
-  };
-  static const double c[] =
-  {
-    -5.504751339936943e-03, -2.279687217114118e-01,
-    -1.697592457770869e+00, -1.802933168781950e+00,
-    3.093354679843505e+00,  2.077595676404383e+00
-  };
-  static const double d[] =
-  {
-    7.784695709041462e-03,  3.224671290700398e-01,
-    2.445134137142996e+00,  3.754408661907416e+00
-  };
-
-  static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
-  static const double pbreak = 0.95150;
-  double ax = fabs (x), y;
-
-  // Select case.
-  if (ax <= pbreak)
+    NDArray
+    gammainc (const NDArray& x, const NDArray& a)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      if (dv != a.dims ())
+        {
+          std::string x_str = dv.str ();
+          std::string a_str = a.dims ().str ();
+
+          (*current_liboctave_error_handler)
+            ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
+             x_str.c_str (), a_str.c_str ());
+        }
+
+      NDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x(i), a(i), err);
+
+          if (err)
+            return NDArray ();
+        }
+
+      return retval;
+    }
+
+    float
+    gammainc (float x, float a, bool& err)
     {
-      // Middle region.
-      const double q = 0.5 * x, r = q*q;
-      const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
-      const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
-      y = yn / yd;
+      if (a < 0.0 || x < 0.0)
+        (*current_liboctave_error_handler)
+              ("gammainc: A and X must be non-negative");
+
+      err = false;
+
+      float retval;
+
+      F77_XFCN (xsgammainc, XSGAMMAINC, (a, x, retval));
+
+      return retval;
     }
-  else if (ax < 1.0)
+
+    FloatMatrix
+    gammainc (float x, const FloatMatrix& a)
+    {
+      octave_idx_type nr = a.rows ();
+      octave_idx_type nc = a.cols ();
+
+      FloatMatrix retval (nr,  nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x, a(i,j), err);
+
+            if (err)
+              return FloatMatrix ();
+          }
+
+      return retval;
+    }
+
+    FloatMatrix
+    gammainc (const FloatMatrix& x, float a)
+    {
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      FloatMatrix retval (nr, nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x(i,j), a, err);
+
+            if (err)
+              return FloatMatrix ();
+          }
+
+      return retval;
+    }
+
+    FloatMatrix
+    gammainc (const FloatMatrix& x, const FloatMatrix& a)
     {
-      // Tail region.
-      const double q = sqrt (-2*gnulib::log (0.5*(1-ax)));
-      const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
-      const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
-      y = yn / yd * octave::math::signum (-x);
+      octave_idx_type nr = x.rows ();
+      octave_idx_type nc = x.cols ();
+
+      octave_idx_type a_nr = a.rows ();
+      octave_idx_type a_nc = a.cols ();
+
+      if (nr != a_nr || nc != a_nc)
+        (*current_liboctave_error_handler)
+          ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
+           nr, nc, a_nr, a_nc);
+
+      FloatMatrix retval (nr, nc);
+
+      bool err;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+        for (octave_idx_type i = 0; i < nr; i++)
+          {
+            retval(i,j) = gammainc (x(i,j), a(i,j), err);
+
+            if (err)
+              return FloatMatrix ();
+          }
+
+      return retval;
     }
-  else if (ax == 1.0)
-    return octave::numeric_limits<double>::Inf () * octave::math::signum (x);
-  else
-    return octave::numeric_limits<double>::NaN ();
-
-  if (refine)
+
+    FloatNDArray
+    gammainc (float x, const FloatNDArray& a)
     {
-      // One iteration of Halley's method gives full precision.
-      double u = (erf (y) - x) * spi2 * exp (y*y);
-      y -= u / (1 + y*u);
+      dim_vector dv = a.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      FloatNDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x, a(i), err);
+
+          if (err)
+            return FloatNDArray ();
+        }
+
+      return retval;
     }
 
-  return y;
-}
-
-double erfinv (double x)
-{
-  return do_erfinv (x, true);
-}
-
-float erfinv (float x)
-{
-  return do_erfinv (x, false);
-}
-
-// The algorthim for erfcinv is an adaptation of the erfinv algorithm
-// above from P. J. Acklam.  It has been modified to run over the
-// different input domain of erfcinv.  See the notes for erfinv for an
-// explanation.
-
-static double do_erfcinv (double x, bool refine)
-{
-  // Coefficients of rational approximation.
-  static const double a[] =
-  {
-    -2.806989788730439e+01,  1.562324844726888e+02,
-    -1.951109208597547e+02,  9.783370457507161e+01,
-    -2.168328665628878e+01,  1.772453852905383e+00
-  };
-  static const double b[] =
-  {
-    -5.447609879822406e+01,  1.615858368580409e+02,
-    -1.556989798598866e+02,  6.680131188771972e+01,
-    -1.328068155288572e+01
-  };
-  static const double c[] =
-  {
-    -5.504751339936943e-03, -2.279687217114118e-01,
-    -1.697592457770869e+00, -1.802933168781950e+00,
-    3.093354679843505e+00,  2.077595676404383e+00
-  };
-  static const double d[] =
-  {
-    7.784695709041462e-03,  3.224671290700398e-01,
-    2.445134137142996e+00,  3.754408661907416e+00
-  };
-
-  static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
-  static const double pbreak_lo = 0.04850;  // 1-pbreak
-  static const double pbreak_hi = 1.95150;  // 1+pbreak
-  double y;
-
-  // Select case.
-  if (x >= pbreak_lo && x <= pbreak_hi)
+    FloatNDArray
+    gammainc (const FloatNDArray& x, float a)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      FloatNDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x(i), a, err);
+
+          if (err)
+            return FloatNDArray ();
+        }
+
+      return retval;
+    }
+
+    FloatNDArray
+    gammainc (const FloatNDArray& x, const FloatNDArray& a)
     {
-      // Middle region.
-      const double q = 0.5*(1-x), r = q*q;
-      const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
-      const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
-      y = yn / yd;
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      if (dv != a.dims ())
+        {
+          std::string x_str = dv.str ();
+          std::string a_str = a.dims ().str ();
+
+          (*current_liboctave_error_handler)
+            ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
+             x_str.c_str (), a_str.c_str ());
+        }
+
+      FloatNDArray retval (dv);
+
+      bool err;
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        {
+          retval(i) = gammainc (x(i), a(i), err);
+
+          if (err)
+            return FloatNDArray ();
+        }
+
+      return retval;
+    }
+
+
+    Complex rc_log1p (double x)
+    {
+      const double pi = 3.14159265358979323846;
+      return (x < -1.0
+              ? Complex (gnulib::log (-(1.0 + x)), pi)
+              : Complex (log1p (x)));
+    }
+
+    FloatComplex rc_log1p (float x)
+    {
+      const float pi = 3.14159265358979323846f;
+      return (x < -1.0f
+              ? FloatComplex (gnulib::logf (-(1.0f + x)), pi)
+              : FloatComplex (log1p (x)));
     }
-  else if (x > 0.0 && x < 2.0)
+
+    // This algorithm is due to P. J. Acklam.
+    //
+    // See http://home.online.no/~pjacklam/notes/invnorm/
+    //
+    // The rational approximation has relative accuracy 1.15e-9 in the whole
+    // region.  For doubles, it is refined by a single step of Halley's 3rd
+    // order method.  For single precision, the accuracy is already OK, so
+    // we skip it to get faster evaluation.
+
+    static double do_erfinv (double x, bool refine)
     {
-      // Tail region.
-      const double q = (x < 1
-                        ? sqrt (-2*gnulib::log (0.5*x))
-                        : sqrt (-2*gnulib::log (0.5*(2-x))));
-
-      const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
-
-      const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
-
-      y = yn / yd;
-
-      if (x < pbreak_lo)
-        y = -y;
-    }
-  else if (x == 0.0)
-    return octave::numeric_limits<double>::Inf ();
-  else if (x == 2.0)
-    return -octave::numeric_limits<double>::Inf ();
-  else
-    return octave::numeric_limits<double>::NaN ();
-
-  if (refine)
-    {
-      // One iteration of Halley's method gives full precision.
-      double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
-      y -= u / (1 + y*u);
+      // Coefficients of rational approximation.
+      static const double a[] =
+        {
+          -2.806989788730439e+01,  1.562324844726888e+02,
+          -1.951109208597547e+02,  9.783370457507161e+01,
+          -2.168328665628878e+01,  1.772453852905383e+00
+        };
+      static const double b[] =
+        {
+          -5.447609879822406e+01,  1.615858368580409e+02,
+          -1.556989798598866e+02,  6.680131188771972e+01,
+          -1.328068155288572e+01
+        };
+      static const double c[] =
+        {
+          -5.504751339936943e-03, -2.279687217114118e-01,
+          -1.697592457770869e+00, -1.802933168781950e+00,
+          3.093354679843505e+00,  2.077595676404383e+00
+        };
+      static const double d[] =
+        {
+          7.784695709041462e-03,  3.224671290700398e-01,
+          2.445134137142996e+00,  3.754408661907416e+00
+        };
+
+      static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
+      static const double pbreak = 0.95150;
+      double ax = fabs (x), y;
+
+      // Select case.
+      if (ax <= pbreak)
+        {
+          // Middle region.
+          const double q = 0.5 * x, r = q*q;
+          const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
+          const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
+          y = yn / yd;
+        }
+      else if (ax < 1.0)
+        {
+          // Tail region.
+          const double q = sqrt (-2*gnulib::log (0.5*(1-ax)));
+          const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
+          const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
+          y = yn / yd * octave::math::signum (-x);
+        }
+      else if (ax == 1.0)
+        return octave::numeric_limits<double>::Inf () * octave::math::signum (x);
+      else
+        return octave::numeric_limits<double>::NaN ();
+
+      if (refine)
+        {
+          // One iteration of Halley's method gives full precision.
+          double u = (erf (y) - x) * spi2 * exp (y*y);
+          y -= u / (1 + y*u);
+        }
+
+      return y;
     }
 
-  return y;
-}
-
-double erfcinv (double x)
-{
-  return do_erfcinv (x, true);
-}
-
-float erfcinv (float x)
-{
-  return do_erfcinv (x, false);
-}
-
-//
-//  Incomplete Beta function ratio
-//
-//  Algorithm based on the one by John Burkardt.
-//  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
-//
-//  The original code is distributed under the GNU LGPL v3 license.
-//
-//  Reference:
-//
-//    KL Majumder, GP Bhattacharjee,
-//    Algorithm AS 63:
-//    The incomplete Beta Integral,
-//    Applied Statistics,
-//    Volume 22, Number 3, 1973, pages 409-411.
-//
-double
-betain (double x, double p, double q, double beta, bool& err)
-{
-  double acu = 0.1E-14, ai, cx;
-  bool indx;
-  int ns;
-  double pp, psq, qq, rx, temp, term, value, xx;
-
-  value = x;
-  err = false;
-
-  //  Check the input arguments.
-
-  if ((p <= 0.0 || q <= 0.0) || (x < 0.0 || 1.0 < x))
+    double erfinv (double x)
+    {
+      return do_erfinv (x, true);
+    }
+
+    float erfinv (float x)
+    {
+      return do_erfinv (x, false);
+    }
+
+    // The algorthim for erfcinv is an adaptation of the erfinv algorithm
+    // above from P. J. Acklam.  It has been modified to run over the
+    // different input domain of erfcinv.  See the notes for erfinv for an
+    // explanation.
+
+    static double do_erfcinv (double x, bool refine)
     {
-      err = true;
-      return value;
-    }
-
-  //  Special cases.
-
-  if (x == 0.0 || x == 1.0)
-    {
-      return value;
-    }
-
-  //  Change tail if necessary and determine S.
-
-  psq = p + q;
-  cx = 1.0 - x;
-
-  if (p < psq * x)
-    {
-      xx = cx;
-      cx = x;
-      pp = q;
-      qq = p;
-      indx = true;
-    }
-  else
-    {
-      xx = x;
-      pp = p;
-      qq = q;
-      indx = false;
+      // Coefficients of rational approximation.
+      static const double a[] =
+        {
+          -2.806989788730439e+01,  1.562324844726888e+02,
+          -1.951109208597547e+02,  9.783370457507161e+01,
+          -2.168328665628878e+01,  1.772453852905383e+00
+        };
+      static const double b[] =
+        {
+          -5.447609879822406e+01,  1.615858368580409e+02,
+          -1.556989798598866e+02,  6.680131188771972e+01,
+          -1.328068155288572e+01
+        };
+      static const double c[] =
+        {
+          -5.504751339936943e-03, -2.279687217114118e-01,
+          -1.697592457770869e+00, -1.802933168781950e+00,
+          3.093354679843505e+00,  2.077595676404383e+00
+        };
+      static const double d[] =
+        {
+          7.784695709041462e-03,  3.224671290700398e-01,
+          2.445134137142996e+00,  3.754408661907416e+00
+        };
+
+      static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
+      static const double pbreak_lo = 0.04850;  // 1-pbreak
+      static const double pbreak_hi = 1.95150;  // 1+pbreak
+      double y;
+
+      // Select case.
+      if (x >= pbreak_lo && x <= pbreak_hi)
+        {
+          // Middle region.
+          const double q = 0.5*(1-x), r = q*q;
+          const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
+          const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
+          y = yn / yd;
+        }
+      else if (x > 0.0 && x < 2.0)
+        {
+          // Tail region.
+          const double q = (x < 1
+                            ? sqrt (-2*gnulib::log (0.5*x))
+                            : sqrt (-2*gnulib::log (0.5*(2-x))));
+
+          const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
+
+          const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
+
+          y = yn / yd;
+
+          if (x < pbreak_lo)
+            y = -y;
+        }
+      else if (x == 0.0)
+        return octave::numeric_limits<double>::Inf ();
+      else if (x == 2.0)
+        return -octave::numeric_limits<double>::Inf ();
+      else
+        return octave::numeric_limits<double>::NaN ();
+
+      if (refine)
+        {
+          // One iteration of Halley's method gives full precision.
+          double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
+          y -= u / (1 + y*u);
+        }
+
+      return y;
     }
 
-  term = 1.0;
-  ai = 1.0;
-  value = 1.0;
-  ns = static_cast<int> (qq + cx * psq);
-
-  //  Use the Soper reduction formula.
-
-  rx = xx / cx;
-  temp = qq - ai;
-  if (ns == 0)
+    double erfcinv (double x)
+    {
+      return do_erfcinv (x, true);
+    }
+
+    float erfcinv (float x)
     {
-      rx = xx;
+      return do_erfcinv (x, false);
     }
 
-  for ( ; ; )
+    //
+    //  Incomplete Beta function ratio
+    //
+    //  Algorithm based on the one by John Burkardt.
+    //  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
+    //
+    //  The original code is distributed under the GNU LGPL v3 license.
+    //
+    //  Reference:
+    //
+    //    KL Majumder, GP Bhattacharjee,
+    //    Algorithm AS 63:
+    //    The incomplete Beta Integral,
+    //    Applied Statistics,
+    //    Volume 22, Number 3, 1973, pages 409-411.
+    //
+    double
+    betain (double x, double p, double q, double beta, bool& err)
     {
-      term *= temp * rx / (pp + ai);
-      value += term;
-      temp = fabs (term);
-
-      if (temp <= acu && temp <= acu * value)
+      double acu = 0.1E-14, ai, cx;
+      bool indx;
+      int ns;
+      double pp, psq, qq, rx, temp, term, value, xx;
+
+      value = x;
+      err = false;
+
+      //  Check the input arguments.
+
+      if ((p <= 0.0 || q <= 0.0) || (x < 0.0 || 1.0 < x))
         {
-          value *= exp (pp * gnulib::log (xx)
-                        + (qq - 1.0) * gnulib::log (cx) - beta) / pp;
-
-          if (indx)
-            {
-              value = 1.0 - value;
-            }
-          break;
+          err = true;
+          return value;
+        }
+
+      //  Special cases.
+
+      if (x == 0.0 || x == 1.0)
+        {
+          return value;
         }
 
-      ai += 1.0;
-      ns -= 1;
-
-      if (0 <= ns)
+      //  Change tail if necessary and determine S.
+
+      psq = p + q;
+      cx = 1.0 - x;
+
+      if (p < psq * x)
         {
-          temp = qq - ai;
-          if (ns == 0)
-            {
-              rx = xx;
-            }
+          xx = cx;
+          cx = x;
+          pp = q;
+          qq = p;
+          indx = true;
         }
       else
         {
-          temp = psq;
-          psq += 1.0;
+          xx = x;
+          pp = p;
+          qq = q;
+          indx = false;
         }
-    }
-
-  return value;
-}
-
-//
-//  Inverse of the incomplete Beta function
-//
-//  Algorithm based on the one by John Burkardt.
-//  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
-//
-//  The original code is distributed under the GNU LGPL v3 license.
-//
-//  Reference:
-//
-//    GW Cran, KJ Martin, GE Thomas,
-//    Remark AS R19 and Algorithm AS 109:
-//    A Remark on Algorithms AS 63: The Incomplete Beta Integral
-//    and AS 64: Inverse of the Incomplete Beta Integeral,
-//    Applied Statistics,
-//    Volume 26, Number 1, 1977, pages 111-114.
-//
-double
-betaincinv (double y, double p, double q)
-{
-  double a, acu, adj, fpu, g, h;
-  int iex;
-  bool indx;
-  double pp, prev, qq, r, s, sae = -37.0, sq, t, tx, value, w, xin, ycur, yprev;
-
-  double beta = xlgamma (p) + xlgamma (q) - xlgamma (p + q);
-  bool err = false;
-  fpu = pow (10.0, sae);
-  value = y;
-
-  //  Test for admissibility of parameters.
-
-  if (p <= 0.0 || q <= 0.0)
-    (*current_liboctave_error_handler) ("betaincinv: wrong parameters");
-  if (y < 0.0 || 1.0 < y)
-    (*current_liboctave_error_handler) ("betaincinv: wrong parameter Y");
-
-  if (y == 0.0 || y == 1.0)
-    return value;
-
-  //  Change tail if necessary.
-
-  if (0.5 < y)
-    {
-      a = 1.0 - y;
-      pp = q;
-      qq = p;
-      indx = true;
-    }
-  else
-    {
-      a = y;
-      pp = p;
-      qq = q;
-      indx = false;
-    }
-
-  //  Calculate the initial approximation.
-
-  r = sqrt (- gnulib::log (a * a));
-
-  ycur = r - (2.30753 + 0.27061 * r) / (1.0 + (0.99229 + 0.04481 * r) * r);
-
-  if (1.0 < pp && 1.0 < qq)
-    {
-      r = (ycur * ycur - 3.0) / 6.0;
-      s = 1.0 / (pp + pp - 1.0);
-      t = 1.0 / (qq + qq - 1.0);
-      h = 2.0 / (s + t);
-      w = ycur * sqrt (h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3.0 * h));
-      value = pp / (pp + qq * exp (w + w));
-    }
-  else
-    {
-      r = qq + qq;
-      t = 1.0 / (9.0 * qq);
-      t = r * pow (1.0 - t + ycur * sqrt (t), 3);
-
-      if (t <= 0.0)
+
+      term = 1.0;
+      ai = 1.0;
+      value = 1.0;
+      ns = static_cast<int> (qq + cx * psq);
+
+      //  Use the Soper reduction formula.
+
+      rx = xx / cx;
+      temp = qq - ai;
+      if (ns == 0)
         {
-          value = 1.0 - exp ((gnulib::log ((1.0 - a) * qq) + beta) / qq);
-        }
-      else
-        {
-          t = (4.0 * pp + r - 2.0) / t;
-
-          if (t <= 1.0)
-            {
-              value = exp ((gnulib::log (a * pp) + beta) / pp);
-            }
-          else
-            {
-              value = 1.0 - 2.0 / (t + 1.0);
-            }
+          rx = xx;
         }
-    }
-
-  //  Solve for X by a modified Newton-Raphson method,
-  //  using the function BETAIN.
-
-  r = 1.0 - pp;
-  t = 1.0 - qq;
-  yprev = 0.0;
-  sq = 1.0;
-  prev = 1.0;
-
-  if (value < 0.0001)
-    {
-      value = 0.0001;
-    }
-
-  if (0.9999 < value)
-    {
-      value = 0.9999;
-    }
-
-  iex = std::max (- 5.0 / pp / pp - 1.0 / pow (a, 0.2) - 13.0, sae);
-
-  acu = pow (10.0, iex);
-
-  for ( ; ; )
-    {
-      ycur = betain (value, pp, qq, beta, err);
-
-      if (err)
-        {
-          return value;
-        }
-
-      xin = value;
-      ycur = (ycur - a) * exp (beta + r * gnulib::log (xin)
-                               + t * gnulib::log (1.0 - xin));
-
-      if (ycur * yprev <= 0.0)
-        {
-          prev = std::max (sq, fpu);
-        }
-
-      g = 1.0;
 
       for ( ; ; )
         {
-          for ( ; ; )
+          term *= temp * rx / (pp + ai);
+          value += term;
+          temp = fabs (term);
+
+          if (temp <= acu && temp <= acu * value)
             {
-              adj = g * ycur;
-              sq = adj * adj;
-
-              if (sq < prev)
-                {
-                  tx = value - adj;
-
-                  if (0.0 <= tx && tx <= 1.0)
-                    {
-                      break;
-                    }
-                }
-              g /= 3.0;
-            }
-
-          if (prev <= acu)
-            {
+              value *= exp (pp * gnulib::log (xx)
+                            + (qq - 1.0) * gnulib::log (cx) - beta) / pp;
+
               if (indx)
                 {
                   value = 1.0 - value;
                 }
+              break;
+            }
+
+          ai += 1.0;
+          ns -= 1;
+
+          if (0 <= ns)
+            {
+              temp = qq - ai;
+              if (ns == 0)
+                {
+                  rx = xx;
+                }
+            }
+          else
+            {
+              temp = psq;
+              psq += 1.0;
+            }
+        }
+
+      return value;
+    }
+
+    //
+    //  Inverse of the incomplete Beta function
+    //
+    //  Algorithm based on the one by John Burkardt.
+    //  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
+    //
+    //  The original code is distributed under the GNU LGPL v3 license.
+    //
+    //  Reference:
+    //
+    //    GW Cran, KJ Martin, GE Thomas,
+    //    Remark AS R19 and Algorithm AS 109:
+    //    A Remark on Algorithms AS 63: The Incomplete Beta Integral
+    //    and AS 64: Inverse of the Incomplete Beta Integeral,
+    //    Applied Statistics,
+    //    Volume 26, Number 1, 1977, pages 111-114.
+    //
+    double
+    betaincinv (double y, double p, double q)
+    {
+      double a, acu, adj, fpu, g, h;
+      int iex;
+      bool indx;
+      double pp, prev, qq, r, s, sae = -37.0, sq, t, tx, value, w, xin, ycur, yprev;
+
+      double beta = lgamma (p) + lgamma (q) - lgamma (p + q);
+      bool err = false;
+      fpu = pow (10.0, sae);
+      value = y;
+
+      //  Test for admissibility of parameters.
+
+      if (p <= 0.0 || q <= 0.0)
+        (*current_liboctave_error_handler) ("betaincinv: wrong parameters");
+      if (y < 0.0 || 1.0 < y)
+        (*current_liboctave_error_handler) ("betaincinv: wrong parameter Y");
+
+      if (y == 0.0 || y == 1.0)
+        return value;
+
+      //  Change tail if necessary.
+
+      if (0.5 < y)
+        {
+          a = 1.0 - y;
+          pp = q;
+          qq = p;
+          indx = true;
+        }
+      else
+        {
+          a = y;
+          pp = p;
+          qq = q;
+          indx = false;
+        }
+
+      //  Calculate the initial approximation.
+
+      r = sqrt (- gnulib::log (a * a));
+
+      ycur = r - (2.30753 + 0.27061 * r) / (1.0 + (0.99229 + 0.04481 * r) * r);
+
+      if (1.0 < pp && 1.0 < qq)
+        {
+          r = (ycur * ycur - 3.0) / 6.0;
+          s = 1.0 / (pp + pp - 1.0);
+          t = 1.0 / (qq + qq - 1.0);
+          h = 2.0 / (s + t);
+          w = ycur * sqrt (h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3.0 * h));
+          value = pp / (pp + qq * exp (w + w));
+        }
+      else
+        {
+          r = qq + qq;
+          t = 1.0 / (9.0 * qq);
+          t = r * pow (1.0 - t + ycur * sqrt (t), 3);
+
+          if (t <= 0.0)
+            {
+              value = 1.0 - exp ((gnulib::log ((1.0 - a) * qq) + beta) / qq);
+            }
+          else
+            {
+              t = (4.0 * pp + r - 2.0) / t;
+
+              if (t <= 1.0)
+                {
+                  value = exp ((gnulib::log (a * pp) + beta) / pp);
+                }
+              else
+                {
+                  value = 1.0 - 2.0 / (t + 1.0);
+                }
+            }
+        }
+
+      //  Solve for X by a modified Newton-Raphson method,
+      //  using the function BETAIN.
+
+      r = 1.0 - pp;
+      t = 1.0 - qq;
+      yprev = 0.0;
+      sq = 1.0;
+      prev = 1.0;
+
+      if (value < 0.0001)
+        {
+          value = 0.0001;
+        }
+
+      if (0.9999 < value)
+        {
+          value = 0.9999;
+        }
+
+      iex = std::max (- 5.0 / pp / pp - 1.0 / pow (a, 0.2) - 13.0, sae);
+
+      acu = pow (10.0, iex);
+
+      for ( ; ; )
+        {
+          ycur = betain (value, pp, qq, beta, err);
+
+          if (err)
+            {
               return value;
             }
 
-          if (ycur * ycur <= acu)
+          xin = value;
+          ycur = (ycur - a) * exp (beta + r * gnulib::log (xin)
+                                   + t * gnulib::log (1.0 - xin));
+
+          if (ycur * yprev <= 0.0)
             {
-              if (indx)
+              prev = std::max (sq, fpu);
+            }
+
+          g = 1.0;
+
+          for ( ; ; )
+            {
+              for ( ; ; )
                 {
-                  value = 1.0 - value;
+                  adj = g * ycur;
+                  sq = adj * adj;
+
+                  if (sq < prev)
+                    {
+                      tx = value - adj;
+
+                      if (0.0 <= tx && tx <= 1.0)
+                        {
+                          break;
+                        }
+                    }
+                  g /= 3.0;
                 }
-              return value;
+
+              if (prev <= acu)
+                {
+                  if (indx)
+                    {
+                      value = 1.0 - value;
+                    }
+                  return value;
+                }
+
+              if (ycur * ycur <= acu)
+                {
+                  if (indx)
+                    {
+                      value = 1.0 - value;
+                    }
+                  return value;
+                }
+
+              if (tx != 0.0 && tx != 1.0)
+                {
+                  break;
+                }
+
+              g /= 3.0;
             }
 
-          if (tx != 0.0 && tx != 1.0)
+          if (tx == value)
             {
               break;
             }
 
-          g /= 3.0;
+          value = tx;
+          yprev = ycur;
         }
 
-      if (tx == value)
+      if (indx)
         {
-          break;
+          value = 1.0 - value;
         }
 
-      value = tx;
-      yprev = ycur;
+      return value;
+    }
+
+    Array<double>
+    betaincinv (double x, double a, const Array<double>& b)
+    {
+      dim_vector dv = b.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x, a, b(i));
+
+      return retval;
+    }
+
+    Array<double>
+    betaincinv (double x, const Array<double>& a, double b)
+    {
+      dim_vector dv = a.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x, a(i), b);
+
+      return retval;
     }
 
-  if (indx)
+    Array<double>
+    betaincinv (double x, const Array<double>& a, const Array<double>& b)
     {
-      value = 1.0 - value;
+      Array<double> retval;
+      dim_vector dv = a.dims ();
+
+      if (dv != b.dims ())
+        err_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x, a(i), b(i));
+
+      return retval;
+    }
+
+    Array<double>
+    betaincinv (const Array<double>& x, double a, double b)
+    {
+      dim_vector dv = x.dims ();
+      octave_idx_type nel = dv.numel ();
+
+      Array<double> retval (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a, b);
+
+      return retval;
     }
 
-  return value;
-}
-
-Array<double>
-betaincinv (double x, double a, const Array<double>& b)
-{
-  dim_vector dv = b.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x, a, b(i));
-
-  return retval;
-}
-
-Array<double>
-betaincinv (double x, const Array<double>& a, double b)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x, a(i), b);
-
-  return retval;
-}
-
-Array<double>
-betaincinv (double x, const Array<double>& a, const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = a.dims ();
-
-  if (dv != b.dims ())
-    err_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x, a(i), b(i));
-
-  return retval;
-}
-
-Array<double>
-betaincinv (const Array<double>& x, double a, double b)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  Array<double> retval (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x(i), a, b);
-
-  return retval;
-}
-
-Array<double>
-betaincinv (const Array<double>& x, double a, const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != b.dims ())
-    err_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x(i), a, b(i));
-
-  return retval;
-}
-
-Array<double>
-betaincinv (const Array<double>& x, const Array<double>& a, double b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims ())
-    err_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x(i), a(i), b);
-
-  return retval;
-}
-
-Array<double>
-betaincinv (const Array<double>& x, const Array<double>& a,
-            const Array<double>& b)
-{
-  Array<double> retval;
-  dim_vector dv = x.dims ();
-
-  if (dv != a.dims () && dv != b.dims ())
-    err_betaincinv_nonconformant (dv, a.dims (), b.dims ());
-
-  octave_idx_type nel = dv.numel ();
-
-  retval.resize (dv);
-
-  double *pretval = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    *pretval++ = betaincinv (x(i), a(i), b(i));
-
-  return retval;
-}
-
-void
-ellipj (double u, double m, double& sn, double& cn, double& dn, double& err)
-{
-  static const int Nmax = 16;
-  double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
-  int n, Nn, ii;
-
-  if (m < 0 || m > 1)
+    Array<double>
+    betaincinv (const Array<double>& x, double a, const Array<double>& b)
+    {
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != b.dims ())
+        err_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a, b(i));
+
+      return retval;
+    }
+
+    Array<double>
+    betaincinv (const Array<double>& x, const Array<double>& a, double b)
     {
-      (*current_liboctave_warning_with_id_handler)
-        ("Octave:ellipj-invalid-m", "ellipj: invalid M value, required value 0 <= M <= 1");
-
-      sn = cn = dn = lo_ieee_nan_value ();
-
-      return;
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims ())
+        err_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a(i), b);
+
+      return retval;
     }
 
-  double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
-  if (m < sqrt_eps)
-    {
-      // For small m, (Abramowitz and Stegun, Section 16.13)
-      si_u = sin (u);
-      co_u = cos (u);
-      t = 0.25*m*(u - si_u*co_u);
-      sn = si_u - t * co_u;
-      cn = co_u + t * si_u;
-      dn = 1 - 0.5*m*si_u*si_u;
-    }
-  else if ((1 - m) < sqrt_eps)
+    Array<double>
+    betaincinv (const Array<double>& x, const Array<double>& a,
+                const Array<double>& b)
     {
-      // For m1 = (1-m) small (Abramowitz and Stegun, Section 16.15)
-      m1 = 1 - m;
-      si_u = sinh (u);
-      co_u = cosh (u);
-      ta_u = tanh (u);
-      se_u = 1/co_u;
-      sn = ta_u + 0.25*m1*(si_u*co_u - u)*se_u*se_u;
-      cn = se_u - 0.25*m1*(si_u*co_u - u)*ta_u*se_u;
-      dn = se_u + 0.25*m1*(si_u*co_u + u)*ta_u*se_u;
+      Array<double> retval;
+      dim_vector dv = x.dims ();
+
+      if (dv != a.dims () && dv != b.dims ())
+        err_betaincinv_nonconformant (dv, a.dims (), b.dims ());
+
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a(i), b(i));
+
+      return retval;
     }
-  else
+
+    void
+    ellipj (double u, double m, double& sn, double& cn, double& dn, double& err)
     {
-      // Arithmetic-Geometric Mean (AGM) algorithm
-      //   (Abramowitz and Stegun, Section 16.4)
-      a[0] = 1;
-      b    = sqrt (1 - m);
-      c[0] = sqrt (m);
-      for (n = 1; n < Nmax; ++n)
+      static const int Nmax = 16;
+      double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
+      int n, Nn, ii;
+
+      if (m < 0 || m > 1)
         {
-          a[n] = (a[n - 1] + b)/2;
-          c[n] = (a[n - 1] - b)/2;
-          b = sqrt (a[n - 1]*b);
-          if (c[n]/a[n] < std::numeric_limits<double>::epsilon ()) break;
-        }
-      if (n >= Nmax - 1)
-        {
-          err = 1;
+          (*current_liboctave_warning_with_id_handler)
+            ("Octave:ellipj-invalid-m", "ellipj: invalid M value, required value 0 <= M <= 1");
+
+          sn = cn = dn = lo_ieee_nan_value ();
+
           return;
         }
-      Nn = n;
-      for (ii = 1; n > 0; ii = ii*2, --n) ; // ii = pow(2,Nn)
-      phi = ii*a[Nn]*u;
-      for (n = Nn; n > 0; --n)
+
+      double sqrt_eps = sqrt (std::numeric_limits<double>::epsilon ());
+      if (m < sqrt_eps)
+        {
+          // For small m, (Abramowitz and Stegun, Section 16.13)
+          si_u = sin (u);
+          co_u = cos (u);
+          t = 0.25*m*(u - si_u*co_u);
+          sn = si_u - t * co_u;
+          cn = co_u + t * si_u;
+          dn = 1 - 0.5*m*si_u*si_u;
+        }
+      else if ((1 - m) < sqrt_eps)
+        {
+          // For m1 = (1-m) small (Abramowitz and Stegun, Section 16.15)
+          m1 = 1 - m;
+          si_u = sinh (u);
+          co_u = cosh (u);
+          ta_u = tanh (u);
+          se_u = 1/co_u;
+          sn = ta_u + 0.25*m1*(si_u*co_u - u)*se_u*se_u;
+          cn = se_u - 0.25*m1*(si_u*co_u - u)*ta_u*se_u;
+          dn = se_u + 0.25*m1*(si_u*co_u + u)*ta_u*se_u;
+        }
+      else
         {
-          phi = (asin ((c[n]/a[n])* sin (phi)) + phi)/2;
+          // Arithmetic-Geometric Mean (AGM) algorithm
+          //   (Abramowitz and Stegun, Section 16.4)
+          a[0] = 1;
+          b    = sqrt (1 - m);
+          c[0] = sqrt (m);
+          for (n = 1; n < Nmax; ++n)
+            {
+              a[n] = (a[n - 1] + b)/2;
+              c[n] = (a[n - 1] - b)/2;
+              b = sqrt (a[n - 1]*b);
+              if (c[n]/a[n] < std::numeric_limits<double>::epsilon ()) break;
+            }
+          if (n >= Nmax - 1)
+            {
+              err = 1;
+              return;
+            }
+          Nn = n;
+          for (ii = 1; n > 0; ii = ii*2, --n) ; // ii = pow(2,Nn)
+          phi = ii*a[Nn]*u;
+          for (n = Nn; n > 0; --n)
+            {
+              phi = (asin ((c[n]/a[n])* sin (phi)) + phi)/2;
+            }
+          sn = sin (phi);
+          cn = cos (phi);
+          dn = sqrt (1 - m*sn*sn);
         }
-      sn = sin (phi);
-      cn = cos (phi);
-      dn = sqrt (1 - m*sn*sn);
     }
-}
-
-void
-ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
-        double& err)
-{
-  double m1 = 1 - m, ss1, cc1, dd1;
-
-  ellipj (imag (u), m1, ss1, cc1, dd1, err);
-  if (real (u) == 0)
+
+    void
+    ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
+            double& err)
     {
-      // u is pure imag: Jacoby imag. transf.
-      sn = Complex (0, ss1/cc1);
-      cn = 1/cc1;         //    cn.imag = 0;
-      dn = dd1/cc1;       //    dn.imag = 0;
+      double m1 = 1 - m, ss1, cc1, dd1;
+
+      ellipj (imag (u), m1, ss1, cc1, dd1, err);
+      if (real (u) == 0)
+        {
+          // u is pure imag: Jacoby imag. transf.
+          sn = Complex (0, ss1/cc1);
+          cn = 1/cc1;         //    cn.imag = 0;
+          dn = dd1/cc1;       //    dn.imag = 0;
+        }
+      else
+        {
+          // u is generic complex
+          double ss, cc, dd, ddd;
+
+          ellipj (real (u), m, ss, cc, dd, err);
+          ddd = cc1*cc1 + m*ss*ss*ss1*ss1;
+          sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
+          cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
+          dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
+        }
     }
-  else
+
+    static const double pi = 3.14159265358979323846;
+
+    template <typename T>
+    static inline T
+    xlog (const T& x)
     {
-      // u is generic complex
-      double ss, cc, dd, ddd;
-
-      ellipj (real (u), m, ss, cc, dd, err);
-      ddd = cc1*cc1 + m*ss*ss*ss1*ss1;
-      sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
-      cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
-      dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
+      return log (x);
     }
-}
-
-static const double pi = 3.14159265358979323846;
-
-template <typename T>
-static inline T
-xlog (const T& x)
-{
-  return log (x);
-}
-
-template <>
-inline double
-xlog (const double& x)
-{
-  return gnulib::log (x);
-}
-
-template <>
-inline float
-xlog (const float& x)
-{
-  return gnulib::logf (x);
-}
-
-template <typename T>
-static T
-Lanczos_approximation_psi (const T zc)
-{
-  // Coefficients for C.Lanczos expansion of psi function from XLiFE++
-  // gammaFunctions psi_coef[k] = - (2k+1) * lg_coef[k] (see melina++
-  // gamma functions -1/12, 3/360,-5/1260, 7/1680,-9/1188,
-  // 11*691/360360,-13/156, 15*3617/122400, ? , ?
-  static const T dg_coeff[10] = {
-    -0.83333333333333333e-1, 0.83333333333333333e-2,
-    -0.39682539682539683e-2, 0.41666666666666667e-2,
-    -0.75757575757575758e-2, 0.21092796092796093e-1,
-    -0.83333333333333333e-1, 0.4432598039215686,
-    -0.3053954330270122e+1,  0.125318899521531e+2
-  };
-
-  T overz2  = T (1.0) / (zc * zc);
-  T overz2k = overz2;
-
-  T p = 0;
-  for (octave_idx_type k = 0; k < 10; k++, overz2k *= overz2)
-    p += dg_coeff[k] * overz2k;
-  p += xlog (zc) - T (0.5) / zc;
-  return p;
-}
-
-template <typename T>
-T
-psi (const T& z)
-{
-  static const double euler_mascheroni = 0.577215664901532860606512090082402431042;
-
-  const bool is_int = (octave::math::floor (z) == z);
-
-  T p = 0;
-  if (z <= 0)
+
+    template <>
+    inline double
+    xlog (const double& x)
+    {
+      return gnulib::log (x);
+    }
+
+    template <>
+    inline float
+    xlog (const float& x)
+    {
+      return gnulib::logf (x);
+    }
+
+    template <typename T>
+    static T
+    lanczos_approximation_psi (const T zc)
+    {
+      // Coefficients for C.Lanczos expansion of psi function from XLiFE++
+      // gammaFunctions psi_coef[k] = - (2k+1) * lg_coef[k] (see melina++
+      // gamma functions -1/12, 3/360,-5/1260, 7/1680,-9/1188,
+      // 11*691/360360,-13/156, 15*3617/122400, ? , ?
+      static const T dg_coeff[10] = {
+        -0.83333333333333333e-1, 0.83333333333333333e-2,
+        -0.39682539682539683e-2, 0.41666666666666667e-2,
+        -0.75757575757575758e-2, 0.21092796092796093e-1,
+        -0.83333333333333333e-1, 0.4432598039215686,
+        -0.3053954330270122e+1,  0.125318899521531e+2
+      };
+
+      T overz2  = T (1.0) / (zc * zc);
+      T overz2k = overz2;
+
+      T p = 0;
+      for (octave_idx_type k = 0; k < 10; k++, overz2k *= overz2)
+        p += dg_coeff[k] * overz2k;
+      p += xlog (zc) - T (0.5) / zc;
+      return p;
+    }
+
+    template <typename T>
+    T
+    xpsi (T z)
     {
-      // limits - zeros of the gamma function
-      if (is_int)
-        p = -octave::numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
+      static const double euler_mascheroni = 0.577215664901532860606512090082402431042;
+
+      const bool is_int = (octave::math::floor (z) == z);
+
+      T p = 0;
+      if (z <= 0)
+        {
+          // limits - zeros of the gamma function
+          if (is_int)
+            p = -octave::numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
+          else
+            // Abramowitz and Stegun, page 259, eq 6.3.7
+            p = psi (1 - z) - (pi / tan (pi * z));
+        }
+      else if (is_int)
+        {
+          // Abramowitz and Stegun, page 258, eq 6.3.2
+          p = - euler_mascheroni;
+          for (octave_idx_type k = z - 1; k > 0; k--)
+            p += 1.0 / k;
+        }
+      else if (octave::math::floor (z + 0.5) == z + 0.5)
+        {
+          // Abramowitz and Stegun, page 258, eq 6.3.3 and 6.3.4
+          for (octave_idx_type k = z; k > 0; k--)
+            p += 1.0 / (2 * k - 1);
+
+          p = - euler_mascheroni - 2 * gnulib::log (2) + 2 * (p);
+        }
       else
-        // Abramowitz and Stegun, page 259, eq 6.3.7
-        p = psi (1 - z) - (pi / tan (pi * z));
+        {
+          // adapted from XLiFE++ gammaFunctions
+
+          T zc = z;
+          // Use formula for derivative of LogGamma(z)
+          if (z < 10)
+            {
+              const signed char n = 10 - z;
+              for (signed char k = n - 1; k >= 0; k--)
+                p -= 1.0 / (k + z);
+              zc += n;
+            }
+          p += lanczos_approximation_psi (zc);
+        }
+
+      return p;
     }
-  else if (is_int)
-    {
-      // Abramowitz and Stegun, page 258, eq 6.3.2
-      p = - euler_mascheroni;
-      for (octave_idx_type k = z - 1; k > 0; k--)
-        p += 1.0 / k;
-    }
-  else if (octave::math::floor (z + 0.5) == z + 0.5)
-    {
-      // Abramowitz and Stegun, page 258, eq 6.3.3 and 6.3.4
-      for (octave_idx_type k = z; k > 0; k--)
-        p += 1.0 / (2 * k - 1);
-
-      p = - euler_mascheroni - 2 * gnulib::log (2) + 2 * (p);
-    }
-  else
+
+    // explicit instantiations
+    double psi (double z) { return xpsi (z); }
+    float psi (float z) { return xpsi (z); }
+
+    template <typename T>
+    std::complex<T>
+    xpsi (const std::complex<T>& z)
     {
       // adapted from XLiFE++ gammaFunctions
 
-      T zc = z;
-      // Use formula for derivative of LogGamma(z)
-      if (z < 10)
+      typedef typename std::complex<T>::value_type P;
+
+      P z_r  = z.real ();
+      P z_ra = z_r;
+
+      std::complex<T> dgam (0.0, 0.0);
+      if (z.imag () == 0)
+        dgam = std::complex<T> (psi (z_r), 0.0);
+      else if (z_r < 0)
+        dgam = psi (P (1.0) - z)- (P (pi) / tan (P (pi) * z));
+      else
         {
-          const signed char n = 10 - z;
-          for (signed char k = n - 1; k >= 0; k--)
-            p -= 1.0 / (k + z);
-          zc += n;
+          // Use formula for derivative of LogGamma(z)
+          std::complex<T> z_m = z;
+          if (z_ra < 8)
+            {
+              unsigned char n = 8 - z_ra;
+              z_m = z + std::complex<T> (n, 0.0);
+
+              // Recurrence formula.  For | Re(z) | < 8, use recursively
+              //
+              //   DiGamma(z) = DiGamma(z+1) - 1/z
+              std::complex<T> z_p = z + P (n - 1);
+              for (unsigned char k = n; k > 0; k--, z_p -= 1.0)
+                dgam -= P (1.0) / z_p;
+            }
+
+          // for | Re(z) | > 8, use derivative of C.Lanczos expansion for
+          // LogGamma
+          //
+          //   psi(z) = log(z) - 1/(2z) - 1/12z^2 + 3/360z^4 - 5/1260z^6
+          //     + 7/1680z^8 - 9/1188z^10 + ...
+          //
+          // (Abramowitz&Stegun, page 259, formula 6.3.18
+          dgam += lanczos_approximation_psi (z_m);
         }
-      p += Lanczos_approximation_psi (zc);
+      return dgam;
     }
 
-  return p;
-}
-
-// explicit instantiations
-template double psi<double> (const double& z);
-template float  psi<float> (const float& z);
-
-template <typename T>
-std::complex<T>
-psi (const std::complex<T>& z)
-{
-  // adapted from XLiFE++ gammaFunctions
-
-  typedef typename std::complex<T>::value_type P;
-
-  P z_r  = z.real ();
-  P z_ra = z_r;
-
-  std::complex<T> dgam (0.0, 0.0);
-  if (z.imag () == 0)
-    dgam = std::complex<T> (psi (z_r), 0.0);
-  else if (z_r < 0)
-    dgam = psi (P (1.0) - z)- (P (pi) / tan (P (pi) * z));
-  else
+    // explicit instantiations
+    Complex psi (const Complex& z) { return xpsi (z); }
+    FloatComplex psi (const FloatComplex& z) { return xpsi (z); }
+
+
+    template <typename T>
+    static inline void
+    fortran_psifn (const T z, const octave_idx_type n, T* ans,
+                   octave_idx_type* ierr);
+
+    template <>
+    inline void
+    fortran_psifn<double> (const double z, const octave_idx_type n,
+                           double* ans, octave_idx_type* ierr)
+    {
+      octave_idx_type flag = 0;
+      F77_XFCN (dpsifn, DPSIFN, (&z, n, 1, 1, ans, &flag, ierr));
+    }
+
+    template <>
+    inline void
+    fortran_psifn<float> (const float z, const octave_idx_type n,
+                          float* ans, octave_idx_type* ierr)
     {
-      // Use formula for derivative of LogGamma(z)
-      std::complex<T> z_m = z;
-      if (z_ra < 8)
+      octave_idx_type flag = 0;
+      F77_XFCN (psifn, PSIFN, (&z, n, 1, 1, ans, &flag, ierr));
+    }
+
+    template <typename T>
+    T
+    xpsi (const octave_idx_type n, T z)
+    {
+      T ans;
+      octave_idx_type ierr = 0;
+      fortran_psifn<T> (z, n, &ans, &ierr);
+      if (ierr == 0)
         {
-          unsigned char n = 8 - z_ra;
-          z_m = z + std::complex<T> (n, 0.0);
-
-          // Recurrence formula.  For | Re(z) | < 8, use recursively
-          //
-          //   DiGamma(z) = DiGamma(z+1) - 1/z
-          std::complex<T> z_p = z + P (n - 1);
-          for (unsigned char k = n; k > 0; k--, z_p -= 1.0)
-            dgam -= P (1.0) / z_p;
+          // Remember that psifn and dpsifn return scales values
+          // When n is 1: do nothing since ((-1)**(n+1)/gamma(n+1)) == 1
+          // When n is 0: change sign since ((-1)**(n+1)/gamma(n+1)) == -1
+          if (n > 1)
+            // FIXME: xgamma here is a killer for our precision since it grows
+            //        way too fast.
+            ans = ans / (pow (-1.0, n + 1) / gamma (double (n+1)));
+          else if (n == 0)
+            ans = -ans;
         }
-
-      // for | Re(z) | > 8, use derivative of C.Lanczos expansion for
-      // LogGamma
-      //
-      //   psi(z) = log(z) - 1/(2z) - 1/12z^2 + 3/360z^4 - 5/1260z^6
-      //     + 7/1680z^8 - 9/1188z^10 + ...
-      //
-      // (Abramowitz&Stegun, page 259, formula 6.3.18
-      dgam += Lanczos_approximation_psi (z_m);
+      else if (ierr == 2)
+        ans = - octave::numeric_limits<T>::Inf ();
+      else // we probably never get here
+        ans = octave::numeric_limits<T>::NaN ();
+
+      return ans;
     }
-  return dgam;
-}
-
-// explicit instantiations
-template Complex psi<double> (const Complex& z);
-template FloatComplex psi<float> (const FloatComplex& z);
-
-
-template <typename T>
-static inline void
-fortran_psifn (const T z, const octave_idx_type n, T* ans,
-               octave_idx_type* ierr);
-
-template <>
-inline void
-fortran_psifn<double> (const double z, const octave_idx_type n,
-                       double* ans, octave_idx_type* ierr)
-{
-  octave_idx_type flag = 0;
-  F77_XFCN (dpsifn, DPSIFN, (&z, n, 1, 1, ans, &flag, ierr));
-}
-
-template <>
-inline void
-fortran_psifn<float> (const float z, const octave_idx_type n,
-                      float* ans, octave_idx_type* ierr)
-{
-  octave_idx_type flag = 0;
-  F77_XFCN (psifn, PSIFN, (&z, n, 1, 1, ans, &flag, ierr));
+
+    double psi (octave_idx_type n, double z) { return xpsi (n, z); }
+    float psi (octave_idx_type n, float z) { return xpsi (n, z); }
+  }
 }
 
-template <typename T>
-T
-psi (const octave_idx_type n, const T z)
-{
-  T ans;
-  octave_idx_type ierr = 0;
-  fortran_psifn<T> (z, n, &ans, &ierr);
-  if (ierr == 0)
-    {
-      // Remember that psifn and dpsifn return scales values
-      // When n is 1: do nothing since ((-1)**(n+1)/gamma(n+1)) == 1
-      // When n is 0: change sign since ((-1)**(n+1)/gamma(n+1)) == -1
-      if (n > 1)
-        // FIXME: xgamma here is a killer for our precision since it grows
-        //        way too fast.
-        ans = ans / (pow (-1.0, n + 1) / xgamma (double (n+1)));
-      else if (n == 0)
-        ans = -ans;
-    }
-  else if (ierr == 2)
-    ans = - octave::numeric_limits<T>::Inf ();
-  else // we probably never get here
-    ans = octave::numeric_limits<T>::NaN ();
-
-  return ans;
-}
-
-// explicit instantiations
-template double psi<double> (const octave_idx_type n, const double z);
-template float  psi<float>  (const octave_idx_type n, const float z);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+ComplexMatrix besselj (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexMatrix bessely (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexMatrix besseli (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexMatrix besselk (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexMatrix besselh1 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexMatrix besselh2 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexMatrix besselj (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexMatrix bessely (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexMatrix besseli (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexMatrix besselk (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexMatrix besselh1 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexMatrix besselh2 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexMatrix besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexMatrix bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexMatrix besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexMatrix besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexMatrix besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexMatrix besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexNDArray besselj (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexNDArray bessely (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexNDArray besseli (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexNDArray besselk (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexNDArray besselh1 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexNDArray besselh2 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexNDArray besselj (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexNDArray bessely (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexNDArray besseli (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexNDArray besselk (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexNDArray besselh1 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexNDArray besselh2 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexNDArray besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexNDArray bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexNDArray besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexNDArray besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexNDArray besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexNDArray besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexMatrix besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+ComplexMatrix bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+ComplexMatrix besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+ComplexMatrix besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+ComplexMatrix besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+ComplexMatrix besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexMatrix besselj (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexMatrix bessely (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexMatrix besseli (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselk (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexNDArray besselj (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexNDArray bessely (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexNDArray besseli (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselk (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+FloatComplexMatrix besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+FloatComplexMatrix bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+FloatComplexMatrix besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+FloatComplexMatrix besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
+
+ComplexMatrix airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+ComplexMatrix biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
+
+ComplexNDArray airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+ComplexNDArray biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
+
+FloatComplexMatrix airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+FloatComplexMatrix biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
+
+FloatComplexNDArray airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+FloatComplexNDArray biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
+
+Array<double> betainc (double x, double a, const Array<double>& b) { return octave::math::betainc (x, a, b); }
+Array<double> betainc (double x, const Array<double>& a, double b) { return octave::math::betainc (x, a, b); }
+Array<double> betainc (double x, const Array<double>& a, const Array<double>& b) { return octave::math::betainc (x, a, b); }
+
+Array<double> betainc (const Array<double>& x, double a, double b) { return octave::math::betainc (x, a, b); }
+Array<double> betainc (const Array<double>& x, double a, const Array<double>& b) { return octave::math::betainc (x, a, b); }
+Array<double> betainc (const Array<double>& x, const Array<double>& a, double b) { return octave::math::betainc (x, a, b); }
+Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b) { return octave::math::betainc (x, a, b); }
+
+Array<float> betainc (float x, float a, const Array<float>& b) { return octave::math::betainc (x, a, b); }
+Array<float> betainc (float x, const Array<float>& a, float b) { return octave::math::betainc (x, a, b); }
+Array<float> betainc (float x, const Array<float>& a, const Array<float>& b) { return octave::math::betainc (x, a, b); }
+
+Array<float> betainc (const Array<float>& x, float a, float b) { return octave::math::betainc (x, a, b); }
+Array<float> betainc (const Array<float>& x, float a, const Array<float>& b) { return octave::math::betainc (x, a, b); }
+Array<float> betainc (const Array<float>& x, const Array<float>& a, float b) { return octave::math::betainc (x, a, b); }
+Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b) { return octave::math::betainc (x, a, b); }
+
+Matrix gammainc (double x, const Matrix& a) { return octave::math::gammainc (x, a); }
+Matrix gammainc (const Matrix& x, double a) { return octave::math::gammainc (x, a); }
+Matrix gammainc (const Matrix& x, const Matrix& a) { return octave::math::gammainc (x, a); }
+
+NDArray gammainc (double x, const NDArray& a) { return octave::math::gammainc (x, a); }
+NDArray gammainc (const NDArray& x, double a) { return octave::math::gammainc (x, a); }
+NDArray gammainc (const NDArray& x, const NDArray& a) { return octave::math::gammainc (x, a); }
+
+FloatMatrix gammainc (float x, const FloatMatrix& a) { return octave::math::gammainc (x, a); }
+FloatMatrix gammainc (const FloatMatrix& x, float a) { return octave::math::gammainc (x, a); }
+FloatMatrix gammainc (const FloatMatrix& x, const FloatMatrix& a) { return octave::math::gammainc (x, a); }
+
+FloatNDArray gammainc (float x, const FloatNDArray& a) { return octave::math::gammainc (x, a); }
+FloatNDArray gammainc (const FloatNDArray& x, float a) { return octave::math::gammainc (x, a); }
+FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a) { return octave::math::gammainc (x, a); }
+
+Array<double> betaincinv (double x, double a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
+Array<double> betaincinv (double x, const Array<double>& a, double b) { return octave::math::betaincinv (x, a, b); }
+Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
+
+Array<double> betaincinv (const Array<double>& x, double a, double b) { return octave::math::betaincinv (x, a, b); }
+Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
+Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b) { return octave::math::betaincinv (x, a, b); }
+Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b) { return octave::math::betaincinv (x, a, b); }
+
+#endif
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -38,619 +38,826 @@ class ComplexColumnVector;
 class FloatMatrix;
 class FloatComplexMatrix;
 class FloatNDArray;
 class FloatComplexNDArray;
 class FloatRowVector;
 class FloatComplexColumnVector;
 class Range;
 
-extern OCTAVE_API double xacosh (double);
-extern OCTAVE_API float xacosh (float);
-extern OCTAVE_API Complex xacosh (const Complex& x);
-extern OCTAVE_API FloatComplex xacosh (const FloatComplex& x);
+namespace octave
+{
+  namespace math
+  {
+    extern OCTAVE_API double acosh (double x);
+    extern OCTAVE_API float acosh (float x);
+    extern OCTAVE_API Complex acosh (const Complex& x);
+    extern OCTAVE_API FloatComplex acosh (const FloatComplex& x);
 
-extern OCTAVE_API double xasinh (double);
-extern OCTAVE_API float xasinh (float);
-extern OCTAVE_API Complex xasinh (const Complex& x);
-extern OCTAVE_API FloatComplex xasinh (const FloatComplex& x);
-
-extern OCTAVE_API double xatanh (double);
-extern OCTAVE_API float xatanh (float);
-extern OCTAVE_API Complex xatanh (const Complex& x);
-extern OCTAVE_API FloatComplex xatanh (const FloatComplex& x);
+    extern OCTAVE_API double asinh (double x);
+    extern OCTAVE_API float asinh (float x);
+    extern OCTAVE_API Complex asinh (const Complex& x);
+    extern OCTAVE_API FloatComplex asinh (const FloatComplex& x);
 
-extern OCTAVE_API double xerf (double);
-extern OCTAVE_API float xerf (float);
-extern OCTAVE_API Complex xerf (const Complex& x);
-extern OCTAVE_API FloatComplex xerf (const FloatComplex& x);
+    extern OCTAVE_API double atanh (double x);
+    extern OCTAVE_API float atanh (float x);
+    extern OCTAVE_API Complex atanh (const Complex& x);
+    extern OCTAVE_API FloatComplex atanh (const FloatComplex& x);
+
+    extern OCTAVE_API double erf (double x);
+    extern OCTAVE_API float erf (float x);
+    extern OCTAVE_API Complex erf (const Complex& x);
+    extern OCTAVE_API FloatComplex erf (const FloatComplex& x);
 
-extern OCTAVE_API double xerfc (double);
-extern OCTAVE_API float xerfc (float);
-extern OCTAVE_API Complex xerfc (const Complex& x);
-extern OCTAVE_API FloatComplex xerfc (const FloatComplex& x);
+    extern OCTAVE_API double erfc (double x);
+    extern OCTAVE_API float erfc (float x);
+    extern OCTAVE_API Complex erfc (const Complex& x);
+    extern OCTAVE_API FloatComplex erfc (const FloatComplex& x);
 
-extern OCTAVE_API double xexpm1 (double x);
-extern OCTAVE_API Complex xexpm1 (const Complex& x);
+    extern OCTAVE_API double expm1 (double x);
+    extern OCTAVE_API Complex expm1 (const Complex& x);
 
-extern OCTAVE_API float xexpm1 (float x);
-extern OCTAVE_API FloatComplex xexpm1 (const FloatComplex& x);
+    extern OCTAVE_API float expm1 (float x);
+    extern OCTAVE_API FloatComplex expm1 (const FloatComplex& x);
 
-extern OCTAVE_API double xlog1p (double x);
-extern OCTAVE_API Complex xlog1p (const Complex& x);
+    extern OCTAVE_API double log1p (double x);
+    extern OCTAVE_API Complex log1p (const Complex& x);
 
-extern OCTAVE_API float xlog1p (float x);
-extern OCTAVE_API FloatComplex xlog1p (const FloatComplex& x);
+    extern OCTAVE_API float log1p (float x);
+    extern OCTAVE_API FloatComplex log1p (const FloatComplex& x);
 
-extern OCTAVE_API double xcbrt (double x);
-extern OCTAVE_API float xcbrt (float x);
+    extern OCTAVE_API double cbrt (double x);
+    extern OCTAVE_API float cbrt (float x);
 
-extern OCTAVE_API double xgamma (double x);
-extern OCTAVE_API double xlgamma (double x);
-extern OCTAVE_API Complex rc_lgamma (double x);
+    extern OCTAVE_API double gamma (double x);
+    extern OCTAVE_API double lgamma (double x);
+    extern OCTAVE_API Complex rc_lgamma (double x);
+
+    extern OCTAVE_API float gamma (float x);
+    extern OCTAVE_API float lgamma (float x);
+    extern OCTAVE_API FloatComplex rc_lgamma (float x);
 
-extern OCTAVE_API float xgamma (float x);
-extern OCTAVE_API float xlgamma (float x);
-extern OCTAVE_API FloatComplex rc_lgamma (float x);
-
-extern OCTAVE_API Complex
-besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besseli (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselk (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
-extern OCTAVE_API Complex
-bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-
-extern OCTAVE_API Complex
-besseli (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API Complex
-besselk (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-
-extern OCTAVE_API Complex
-besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API Complex
-besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
-
-extern OCTAVE_API ComplexMatrix
-besselj (double alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-bessely (double alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besseli (double alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselk (double alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexMatrix
-besselh1 (double alpha, const ComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselh2 (double alpha, const ComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselj (const Matrix& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplex besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besseli (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselk (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
-extern OCTAVE_API ComplexMatrix
-bessely (const Matrix& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexMatrix
-besseli (const Matrix& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselk (const Matrix& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselh1 (const Matrix& alpha, const Complex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselh2 (const Matrix& alpha, const Complex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexMatrix
-besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexMatrix
-besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
-extern OCTAVE_API ComplexNDArray
-besselj (double alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexMatrix biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+
+    extern OCTAVE_API ComplexNDArray airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API ComplexNDArray biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexNDArray
-bessely (double alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+    extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
-extern OCTAVE_API ComplexNDArray
-besseli (double alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexMatrix biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+
+    extern OCTAVE_API FloatComplexNDArray airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatComplexNDArray biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexNDArray
-besselk (double alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double betainc (double x, double a, double b);
+    extern OCTAVE_API Array<double> betainc (double x, double a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API ComplexNDArray
-besselh1 (double alpha, const ComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API ComplexNDArray
-besselh2 (double alpha, const ComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API float betainc (float x, float a, float b);
+    extern OCTAVE_API Array<float> betainc (float x, float a, const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, float b);
+    extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, const Array<float>& b);
 
-extern OCTAVE_API ComplexNDArray
-besselj (const NDArray& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, const Array<float>& b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, float b);
+    extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
 
-extern OCTAVE_API ComplexNDArray
-bessely (const NDArray& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double gammainc (double x, double a, bool& err);
+    inline double gammainc (double x, double a)
+    {
+      bool err;
+      return gammainc (x, a, err);
+    }
 
-extern OCTAVE_API ComplexNDArray
-besseli (const NDArray& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API Matrix gammainc (double x, const Matrix& a);
+    extern OCTAVE_API Matrix gammainc (const Matrix& x, double a);
+    extern OCTAVE_API Matrix gammainc (const Matrix& x, const Matrix& a);
 
-extern OCTAVE_API ComplexNDArray
-besselk (const NDArray& alpha, const Complex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API NDArray gammainc (double x, const NDArray& a);
+    extern OCTAVE_API NDArray gammainc (const NDArray& x, double a);
+    extern OCTAVE_API NDArray gammainc (const NDArray& x, const NDArray& a);
 
-extern OCTAVE_API ComplexNDArray
-besselh1 (const NDArray& alpha, const Complex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API float gammainc (float x, float a, bool& err);
+    inline float gammainc (float x, float a)
+    {
+      bool err;
+      return gammainc (x, a, err);
+    }
 
-extern OCTAVE_API ComplexNDArray
-besselh2 (const NDArray& alpha, const Complex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatMatrix gammainc (float x, const FloatMatrix& a);
+    extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, float a);
+    extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, const FloatMatrix& a);
 
-extern OCTAVE_API ComplexNDArray
-besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API FloatNDArray gammainc (float x, const FloatNDArray& a);
+    extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, float a);
+    extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a);
+
+    extern OCTAVE_API Complex rc_log1p (double x);
+    extern OCTAVE_API FloatComplex rc_log1p (float x);
 
-extern OCTAVE_API ComplexNDArray
-bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double erfinv (double x);
+    extern OCTAVE_API float erfinv (float x);
 
-extern OCTAVE_API ComplexNDArray
-besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double erfcinv (double x);
+    extern OCTAVE_API float erfcinv (float x);
 
-extern OCTAVE_API ComplexNDArray
-besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API float erfcx (float x);
+    extern OCTAVE_API double erfcx (double x);
+    extern OCTAVE_API Complex erfcx (const Complex& x);
+    extern OCTAVE_API FloatComplex erfcx (const FloatComplex& x);
 
-extern OCTAVE_API ComplexNDArray
-besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API float erfi (float x);
+    extern OCTAVE_API double erfi (double x);
+    extern OCTAVE_API Complex erfi (const Complex& x);
+    extern OCTAVE_API FloatComplex erfi (const FloatComplex& x);
 
-extern OCTAVE_API ComplexNDArray
-besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+    extern OCTAVE_API float dawson (float x);
+    extern OCTAVE_API double dawson (double x);
+    extern OCTAVE_API Complex dawson (const Complex& x);
+    extern OCTAVE_API FloatComplex dawson (const FloatComplex& x);
 
-extern OCTAVE_API ComplexMatrix
-besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double betaincinv (double x, double a, double b);
+    extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API ComplexMatrix
-bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
+    extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API ComplexMatrix
-besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API void ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
+    extern OCTAVE_API void ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err);
+
+    extern OCTAVE_API double psi (double x);
+    extern OCTAVE_API float psi (float x);
+
+    extern OCTAVE_API Complex psi (const Complex& x);
+    extern OCTAVE_API FloatComplex psi (const FloatComplex& x);
 
-extern OCTAVE_API ComplexMatrix
-besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+    extern OCTAVE_API double psi (octave_idx_type n, double z);
+    extern OCTAVE_API float psi (octave_idx_type n, float z);
+  }
+}
 
-extern OCTAVE_API ComplexMatrix
-besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-extern OCTAVE_API ComplexMatrix
-besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplex
-besselj (float alpha, const FloatComplex& x, bool scaled,
-         octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::acosh' instead")
+inline double xacosh (double x) { return octave::math::acosh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::acosh' instead")
+inline float xacosh (float x) { return octave::math::acosh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::acosh' instead")
+inline Complex xacosh (const Complex& x) { return octave::math::acosh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::acosh' instead")
+inline FloatComplex xacosh (const FloatComplex& x) { return octave::math::acosh (x); }
 
-extern OCTAVE_API FloatComplex
-bessely (float alpha, const FloatComplex& x, bool scaled,
-         octave_idx_type& ierr);
-
-extern OCTAVE_API FloatComplex
-besseli (float alpha, const FloatComplex& x, bool scaled,
-         octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::asinh' instead")
+inline double xasinh (double x) { return octave::math::asinh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::asinh' instead")
+inline float xasinh (float x) { return octave::math::asinh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::asinh' instead")
+inline Complex xasinh (const Complex& x) { return octave::math::asinh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::asinh' instead")
+inline FloatComplex xasinh (const FloatComplex& x) { return octave::math::asinh (x); }
 
-extern OCTAVE_API FloatComplex
-besselk (float alpha, const FloatComplex& x, bool scaled,
-         octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::atanh' instead")
+inline double xatanh (double x) { return octave::math::atanh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::atanh' instead")
+inline float xatanh (float x) { return octave::math::atanh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::atanh' instead")
+inline Complex xatanh (const Complex& x) { return octave::math::atanh (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::atanh' instead")
+inline FloatComplex xatanh (const FloatComplex& x) { return octave::math::atanh (x); }
 
-extern OCTAVE_API FloatComplex
-besselh1 (float alpha, const FloatComplex& x, bool scaled,
-          octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::erf' instead")
+inline double xerf (double x) { return octave::math::erf (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erf' instead")
+inline float xerf (float x) { return octave::math::erf (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erf' instead")
+inline Complex xerf (const Complex& x) { return octave::math::erf (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erf' instead")
+inline FloatComplex xerf (const FloatComplex& x) { return octave::math::erf (x); }
 
-extern OCTAVE_API FloatComplex
-besselh2 (float alpha, const FloatComplex& x, bool scaled,
-          octave_idx_type& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselj (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::erfc' instead")
+inline double xerfc (double x) { return octave::math::erfc (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfc' instead")
+inline float xerfc (float x) { return octave::math::erfc (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfc' instead")
+inline Complex xerfc (const Complex& x) { return octave::math::erfc (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfc' instead")
+inline FloatComplex xerfc (const FloatComplex& x) { return octave::math::erfc (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-bessely (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besseli (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::expm1' instead")
+inline double xexpm1 (double x) { return octave::math::expm1 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::expm1' instead")
+inline Complex xexpm1 (const Complex& x) { return octave::math::expm1 (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselk (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::expm1' instead")
+inline float xexpm1 (float x) { return octave::math::expm1 (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::expm1' instead")
+inline FloatComplex xexpm1 (const FloatComplex& x) { return octave::math::expm1 (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::log1p' instead")
+inline double xlog1p (double x) { return octave::math::log1p (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::log1p' instead")
+inline Complex xlog1p (const Complex& x) { return octave::math::log1p (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::log1p' instead")
+inline float xlog1p (float x) { return octave::math::log1p (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::log1p' instead")
+inline FloatComplex xlog1p (const FloatComplex& x) { return octave::math::log1p (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::cbrt' instead")
+inline double xcbrt (double x) { return octave::math::cbrt (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::cbrt' instead")
+inline float xcbrt (float x) { return octave::math::cbrt (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::gamma' instead")
+inline double xgamma (double x) { return octave::math::gamma (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::lgamma' instead")
+inline double xlgamma (double x) { return octave::math::lgamma (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_lgamma' instead")
+inline Complex rc_lgamma (double x) { return octave::math::rc_lgamma (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::gamma' instead")
+inline float xgamma (float x) { return octave::math::gamma (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::lgamma' instead")
+inline float xlgamma (float x) { return octave::math::lgamma (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_lgamma' instead")
+inline FloatComplex rc_lgamma (float x) { return octave::math::rc_lgamma (x); }
 
-extern OCTAVE_API FloatComplexMatrix
-besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+inline Complex besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+inline Complex bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+inline Complex besseli (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+inline Complex besselk (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+inline Complex besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+inline Complex besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
 
-extern OCTAVE_API FloatComplexMatrix
-bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexMatrix besselj (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexMatrix bessely (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexMatrix besseli (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexMatrix besselk (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexMatrix besselh1 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexMatrix besselh2 (double alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexMatrix
-besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselj (float alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-bessely (float alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besseli (float alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexMatrix besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexMatrix bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexMatrix besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexMatrix besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexMatrix besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexMatrix besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-besselk (float alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexNDArray besselj (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexNDArray bessely (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexNDArray besseli (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexNDArray besselk (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexNDArray besselh1 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexNDArray besselh2 (double alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const Complex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexNDArray besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexNDArray bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexNDArray besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexNDArray besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexNDArray besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexNDArray besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API ComplexMatrix besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API ComplexMatrix bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API ComplexMatrix besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API ComplexMatrix besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API ComplexMatrix besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API ComplexMatrix besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+inline FloatComplex besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselj (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octavh::bessely' instead")
+inline FloatComplex bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::bessely (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octavh::besseli' instead")
+inline FloatComplex besseli (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besseli (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octavh::besselk' instead")
+inline FloatComplex besselk (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselk (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octavh::besselh1' instead")
+inline FloatComplex besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselh1 (alpha, x, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octavh::besselh2' instead")
+inline FloatComplex besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) { return octave::math::besselh2 (alpha, x, scaled, ierr); }
 
-extern OCTAVE_API FloatComplexNDArray
-bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexMatrix besselj (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexMatrix bessely (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexMatrix besseli (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexMatrix besselk (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexMatrix besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexMatrix besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexNDArray
-besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexMatrix
-besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-         bool scaled, Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-         bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexMatrix besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexMatrix bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexMatrix besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexMatrix besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexMatrix
-besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-         bool scaled, Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-         bool scaled, Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-          bool scaled, Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API FloatComplexMatrix
-besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
-          bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexNDArray besselj (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexNDArray bessely (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexNDArray besseli (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexNDArray besselk (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexNDArray besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexNDArray besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API Complex
-airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-
-extern OCTAVE_API Complex
-biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
-
-extern OCTAVE_API ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexNDArray besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexNDArray bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexNDArray besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexNDArray besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexNDArray besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexNDArray besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselj' instead")
+extern OCTAVE_API FloatComplexMatrix besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::bessely' instead")
+extern OCTAVE_API FloatComplexMatrix bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besseli' instead")
+extern OCTAVE_API FloatComplexMatrix besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselk' instead")
+extern OCTAVE_API FloatComplexMatrix besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh1' instead")
+extern OCTAVE_API FloatComplexMatrix besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::besselh2' instead")
+extern OCTAVE_API FloatComplexMatrix besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplex
-airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-
-extern OCTAVE_API FloatComplex
-biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+inline Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+inline Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
 
-extern OCTAVE_API FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+extern OCTAVE_API ComplexMatrix airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+extern OCTAVE_API ComplexMatrix biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+extern OCTAVE_API ComplexNDArray airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+extern OCTAVE_API ComplexNDArray biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+inline FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr) { return octave::math::airy (z, deriv, scaled, ierr); }
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+inline FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr) { return octave::math::biry (z, deriv, scaled, ierr); }
 
-extern OCTAVE_API FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled,
-      Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+extern OCTAVE_API FloatComplexMatrix airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+extern OCTAVE_API FloatComplexMatrix biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+
+OCTAVE_DEPRECATED ("use 'octave::math::airy' instead")
+extern OCTAVE_API FloatComplexNDArray airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+OCTAVE_DEPRECATED ("use 'octave::math::biry' instead")
+extern OCTAVE_API FloatComplexNDArray biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API double
-betainc (double x, double a, double b);
-extern OCTAVE_API Array<double>
-betainc (double x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betainc (double x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double>
-betainc (double x, const Array<double>& a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betainc (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double>
-betainc (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double>
-betainc (const Array<double>& x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betainc (const Array<double>& x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double>
-betainc (const Array<double>& x, const Array<double>& a,
-         const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+inline double betainc (double x, double a, double b) { return octave::math::betainc (x, a, b); }
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (double x, double a, const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, double b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, const Array<double>& b);
+
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+inline float betainc (float x, float a, float b) { return octave::math::betainc (x, a, b); }
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, double b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API float
-betainc (float x, float a, float b);
-extern OCTAVE_API Array<float>
-betainc (float x, float a, const Array<float>& b);
-extern OCTAVE_API Array<float>
-betainc (float x, const Array<float>& a, float b);
-extern OCTAVE_API Array<float>
-betainc (float x, const Array<float>& a, const Array<float>& b);
-extern OCTAVE_API Array<float>
-betainc (const Array<float>& x, float a, float b);
-extern OCTAVE_API Array<float>
-betainc (const Array<float>& x, float a, float b);
-extern OCTAVE_API Array<float>
-betainc (const Array<float>& x, float a, const Array<float>& b);
-extern OCTAVE_API Array<float>
-betainc (const Array<float>& x, const Array<float>& a, float b);
-extern OCTAVE_API Array<float>
-betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API float betainc (float x, float a, float b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (float x, float a, const Array<float>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, float b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, const Array<float>& b);
 
-extern OCTAVE_API double gammainc (double x, double a, bool& err);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, const Array<float>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, float b);
+OCTAVE_DEPRECATED ("use 'octave::math::betainc' instead")
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
+
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
+inline double gammainc (double x, double a, bool& err) { return octave::math::gammainc (x, a, err); }
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
+inline double gammainc (double x, double a) { return octave::math::gammainc (x, a); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
 extern OCTAVE_API Matrix gammainc (double x, const Matrix& a);
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
 extern OCTAVE_API Matrix gammainc (const Matrix& x, double a);
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
 extern OCTAVE_API Matrix gammainc (const Matrix& x, const Matrix& a);
 
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
 extern OCTAVE_API NDArray gammainc (double x, const NDArray& a);
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
 extern OCTAVE_API NDArray gammainc (const NDArray& x, double a);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
 extern OCTAVE_API NDArray gammainc (const NDArray& x, const NDArray& a);
 
-inline double gammainc (double x, double a)
-{
-  bool err;
-  return gammainc (x, a, err);
-}
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
+inline float gammainc (float x, float a, bool& err) { return octave::math::gammainc (x, a, err); }
+OCTAVE_DEPRECATED ("use 'octave::math::gammainc' instead")
+inline float gammainc (float x, float a) { return octave::math::gammainc (x, a); }
 
-extern OCTAVE_API float gammainc (float x, float a, bool& err);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
 extern OCTAVE_API FloatMatrix gammainc (float x, const FloatMatrix& a);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
 extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, float a);
-extern OCTAVE_API FloatMatrix
-gammainc (const FloatMatrix& x, const FloatMatrix& a);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
+extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, const FloatMatrix& a);
 
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
 extern OCTAVE_API FloatNDArray gammainc (float x, const FloatNDArray& a);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
 extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, float a);
-extern OCTAVE_API FloatNDArray
-gammainc (const FloatNDArray& x, const FloatNDArray& a);
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
+extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a);
 
-inline float gammainc (float x, float a)
-{
-  bool err;
-  return gammainc (x, a, err);
-}
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
+inline Complex rc_log1p (double x) { return octave::math::rc_log1p (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::rc_log1p' instead")
+inline FloatComplex rc_log1p (float x) { return octave::math::rc_log1p (x); }
+
+OCTAVE_DEPRECATED ("use 'octave::math::erfinv' instead")
+inline double erfinv (double x) { return octave::math::erfinv (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfinv' instead")
+inline float erfinv (float x) { return octave::math::erfinv (x); }
 
-extern OCTAVE_API Complex rc_log1p (double);
-extern OCTAVE_API FloatComplex rc_log1p (float);
+OCTAVE_DEPRECATED ("use 'octave::math::erfcinv' instead")
+inline double erfcinv (double x) { return octave::math::erfcinv (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfcinv' instead")
+inline float erfcinv (float x) { return octave::math::erfcinv (x); }
 
-extern OCTAVE_API double erfinv (double x);
-extern OCTAVE_API float erfinv (float x);
-
-extern OCTAVE_API double erfcinv (double x);
-extern OCTAVE_API float erfcinv (float x);
+OCTAVE_DEPRECATED ("use 'octave::math::erfcx' instead")
+inline float erfcx (float x) { return octave::math::erfcx (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfcx' instead")
+inline double erfcx (double x) { return octave::math::erfcx (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfcx' instead")
+inline Complex erfcx (const Complex& x) { return octave::math::erfcx (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfcx' instead")
+inline FloatComplex erfcx (const FloatComplex& x) { return octave::math::erfcx (x); }
 
-extern OCTAVE_API float erfcx (float x);
-extern OCTAVE_API double erfcx (double x);
-extern OCTAVE_API Complex erfcx (const Complex& x);
-extern OCTAVE_API FloatComplex erfcx (const FloatComplex& x);
+OCTAVE_DEPRECATED ("use 'octave::math::erfi' instead")
+inline float erfi (float x) { return octave::math::erfi (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfi' instead")
+inline double erfi (double x) { return octave::math::erfi (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfi' instead")
+inline Complex erfi (const Complex& x) { return octave::math::erfi (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::erfi' instead")
+inline FloatComplex erfi (const FloatComplex& x) { return octave::math::erfi (x); }
 
-extern OCTAVE_API float erfi (float x);
-extern OCTAVE_API double erfi (double x);
-extern OCTAVE_API Complex erfi (const Complex& x);
-extern OCTAVE_API FloatComplex erfi (const FloatComplex& x);
+OCTAVE_DEPRECATED ("use 'octave::math::dawson' instead")
+inline float dawson (float x) { return octave::math::dawson (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::dawson' instead")
+inline double dawson (double x) { return octave::math::dawson (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::dawson' instead")
+inline Complex dawson (const Complex& x) { return octave::math::dawson (x); }
+OCTAVE_DEPRECATED ("use 'octave::math::dawson' instead")
+inline FloatComplex dawson (const FloatComplex& x) { return octave::math::dawson (x); }
 
-extern OCTAVE_API float dawson (float x);
-extern OCTAVE_API double dawson (double x);
-extern OCTAVE_API Complex dawson (const Complex& x);
-extern OCTAVE_API FloatComplex dawson (const FloatComplex& x);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+inline double betaincinv (double x, double a, double b) { return octave::math::betaincinv (x, a, b); }
 
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
 extern OCTAVE_API double betaincinv (double x, double a, double b);
-extern OCTAVE_API Array<double>
-betaincinv (double x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betaincinv (double x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double>
-betaincinv (double x, const Array<double>& a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betaincinv (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double>
-betaincinv (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double>
-betaincinv (const Array<double>& x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double>
-betaincinv (const Array<double>& x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double>
-betaincinv (const Array<double>& x, const Array<double>& a,
-            const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
 
-extern OCTAVE_API void
-ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
-extern OCTAVE_API void
-ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
-        double& err);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
+OCTAVE_DEPRECATED ("use 'octave::math::betaincinv' instead")
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+
+OCTAVE_DEPRECATED ("use 'octave::math::ellipj' instead")
+inline void ellipj (double u, double m, double& sn, double& cn, double& dn, double& err) { octave::math::ellipj (u, m, sn, cn, dn, err); }
+OCTAVE_DEPRECATED ("use 'octave::math::ellipj' instead")
+inline void ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err) { octave::math::ellipj (u, m, sn, cn, dn, err); }
 
 //! Digamma function.
 //!
 //! Only defined for double and float.
 template <typename T>
-extern OCTAVE_API T psi (const T& z);
+OCTAVE_DEPRECATED ("use 'octave::math::psi' instead")
+T
+psi (T z);
+
+template <>
+inline double
+psi (double z)
+{
+  return octave::math::psi (z);
+}
+
+template <>
+inline float
+psi (float z)
+{
+  return octave::math::psi (z);
+}
 
 //! Digamma function for complex input.
 //!
 //! Only defined for double and float.
 template <typename T>
-extern OCTAVE_API std::complex<T> psi (const std::complex<T>& z);
+OCTAVE_DEPRECATED ("use 'octave::math::psi' instead")
+std::complex<T>
+psi (const std::complex<T>& z);
+
+template <>
+inline std::complex<double>
+psi (const std::complex<double>& z)
+{
+  return octave::math::psi (z);
+}
+
+template <>
+inline std::complex<float>
+psi (const std::complex<float>& z)
+{
+  return octave::math::psi (z);
+}
 
 //! Polygamma function.
 //!
 //! Only defined for double and float.
 //! @param n must be non-negative.  If zero, the digamma function is computed.
 //! @param z must be real and non-negative.
 template <typename T>
-extern OCTAVE_API T psi (const octave_idx_type n, const T z);
+OCTAVE_DEPRECATED ("use 'octave::math::psi' instead")
+T
+psi (octave_idx_type n, T z);
+
+template<>
+inline double
+psi (octave_idx_type n, double z)
+{
+  return octave::math::psi (n, z);
+}
+
+template<>
+inline float
+psi (octave_idx_type n, float z)
+{
+  return octave::math::psi (n, z);
+}
 
 #endif
+
+#endif
