# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449172770 18000
#      Thu Dec 03 14:59:30 2015 -0500
# Node ID 492738d32c606dd111f76c11ac41475a3f494a6c
# Parent  ba2367658dc8b162ac3813b09fdb3db1a017437b
eliminate return statements after calls to print_usage

* ov-bool-mat.cc, ov-cell.cc, ov-class.cc, ov-classdef.cc,
ov-fcn-handle.cc, ov-fcn-inline.cc, ov-flt-re-mat.cc, ov-java.cc,
ov-null-mat.cc, ov-oncleanup.cc, ov-re-mat.cc, ov-struct.cc,
ov-type-conv.h, ov-typeinfo.cc, ov-usr-fcn.cc, ov.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -567,35 +567,34 @@ will produce an error.\n\
 \n\
 Compatibility Note: Octave accepts complex values as input, whereas\n\
 @sc{matlab} issues an error.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
+  if (args.length () != 1)
+    print_usage ();
+
+  octave_value arg = args(0);
+
+  if (arg.is_bool_type ())
+    retval = arg;
+  else if (arg.is_numeric_type ())
     {
-      octave_value arg = args(0);
-      if (arg.is_bool_type ())
-        retval = arg;
-      else if (arg.is_numeric_type ())
-        {
-          if (arg.is_sparse_type ())
-            retval = arg.sparse_bool_matrix_value ();
-          else if (arg.is_scalar_type ())
-            retval = arg.bool_value ();
-          else
-            retval = arg.bool_array_value ();
-        }
+      if (arg.is_sparse_type ())
+        retval = arg.sparse_bool_matrix_value ();
+      else if (arg.is_scalar_type ())
+        retval = arg.bool_value ();
       else
-        gripe_wrong_type_arg ("logical", arg);
+        retval = arg.bool_array_value ();
     }
   else
-    print_usage ();
+    gripe_wrong_type_arg ("logical", arg);
 
   return retval;
 }
 
 /*
 %!test
 %! m = eye (2) != 0;
 %! s = !0;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1232,24 +1232,20 @@ octave_cell::load_hdf5 (octave_hdf5_id l
 
 DEFUN (iscell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.\n\
 @seealso{ismatrix, isstruct, iscellstr, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_cell ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_cell ());
 }
 
 DEFUN (cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cell (@var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} cell ([@var{m} @var{n} @dots{}])\n\
@@ -1301,24 +1297,20 @@ dimensions.\n\
 DEFUN (iscellstr, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscellstr (@var{cell})\n\
 Return true if every element of the cell array @var{cell} is a character\n\
 string.\n\
 @seealso{ischar}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_cellstr ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_cellstr ());
 }
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
@@ -1331,33 +1323,31 @@ Each row of @var{strmat} becomes an elem
 spaces in a row are deleted before conversion.\n\
 \n\
 To convert back from a cellstr to a character array use @code{char}.\n\
 @seealso{cell, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      octave_value_list tmp = Fiscellstr (args, 1);
+  if (args.length () != 1)
+    print_usage ();
+
+  octave_value_list tmp = Fiscellstr (args, 1);
 
-      if (tmp(0).is_true ())
-        retval = args(0);
-      else
-        {
-          string_vector s = args(0).xall_strings ("cellstr: argument STRING must be a 2-D character array");
+  if (tmp(0).is_true ())
+    retval = args(0);
+  else
+    {
+      string_vector s = args(0).xall_strings ("cellstr: argument STRING must be a 2-D character array");
 
-          retval = (s.is_empty ()
-                    ? Cell (octave_value (std::string ()))
-                    : Cell (s, true));
-        }
+      retval = (s.is_empty ()
+                ? Cell (octave_value (std::string ()))
+                : Cell (s, true));
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
@@ -1387,59 +1377,53 @@ c(2,1,:)(:)\n\
         [3,1] = 3\n\
       @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{cell2struct, fieldnames}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      const octave_map m = args(0).xmap_value ("struct2cell: argument S must be a structure");
-
-      const dim_vector m_dv = m.dims ();
-
-      octave_idx_type num_fields = m.nfields ();
-
-      // The resulting dim_vector should have dimensions:
-      // [numel(fields) size(struct)]
-      // except if the struct is a column vector.
-
-      dim_vector result_dv;
-      if (m_dv(m_dv.length () - 1) == 1)
-        result_dv.resize (m_dv.length ());
-      else
-        result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
-
-      result_dv(0) = num_fields;
-
-      for (int i = 1; i < result_dv.length (); i++)
-        result_dv(i) = m_dv(i-1);
-
-      NoAlias<Cell> c (result_dv);
-
-      octave_idx_type n_elts = m.numel ();
-
-      // Fill c in one sweep. Note that thanks to octave_map structure,
-      // we don't need a key lookup at all.
-      for (octave_idx_type j = 0; j < n_elts; j++)
-        for (octave_idx_type i = 0; i < num_fields; i++)
-          c(i,j) = m.contents(i)(j);
-
-      retval = c;
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  const octave_map m = args(0).xmap_value ("struct2cell: argument S must be a structure");
+
+  const dim_vector m_dv = m.dims ();
+
+  octave_idx_type num_fields = m.nfields ();
+
+  // The resulting dim_vector should have dimensions:
+  // [numel(fields) size(struct)]
+  // except if the struct is a column vector.
+
+  dim_vector result_dv;
+  if (m_dv(m_dv.length () - 1) == 1)
+    result_dv.resize (m_dv.length ());
+  else
+    result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
+
+  result_dv(0) = num_fields;
+
+  for (int i = 1; i < result_dv.length (); i++)
+    result_dv(i) = m_dv(i-1);
+
+  NoAlias<Cell> c (result_dv);
+
+  octave_idx_type n_elts = m.numel ();
+
+  // Fill c in one sweep. Note that thanks to octave_map structure,
+  // we don't need a key lookup at all.
+  for (octave_idx_type j = 0; j < n_elts; j++)
+    for (octave_idx_type i = 0; i < num_fields; i++)
+      c(i,j) = m.contents(i)(j);
+
+  return octave_value (c);
 }
 
 /*
 %!test
 %! keys = cellstr (char (floor (rand (11,10)*24+65)))';
 %! vals = cellfun (@(x) mat2cell (rand (19,1), ones (19,1), 1), ...
 %!          mat2cell ([1:11]', ones (11,1), 1), "uniformoutput", false)';
 %! s = struct ([keys; vals]{:});
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1771,17 +1771,18 @@ is derived.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
-  else if (nargin == 1)
+
+  if (nargin == 1)
     // Called for class of object
     retval = args(0).class_name ();
   else
     {
       // Called as class constructor
       octave_function *fcn = octave_call_stack::caller ();
 
       std::string id = args(1).xstring_value ("class: ID (class name) must be a string");
@@ -1861,20 +1862,17 @@ size is returned, containing true for ea
 belongs to.\n\
 \n\
 @seealso{class, typeinfo}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value obj = args(0);  // not const because of find_parent_class ()
   std::string obj_cls = obj.class_name ();
   Array<std::string> clsnames = args(1).xcellstr_value ("isa: CLASSNAME must be a string or cell array of strings");
 
   boolNDArray matches (clsnames.dims (), false);
   for (octave_idx_type idx = 0; idx < clsnames.numel (); idx++)
     {
@@ -1952,79 +1950,71 @@ belongs to.\n\
 DEFUN (__parent_classes__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __parent_classes__ (@var{x})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval = Cell ();
 
-  if (args.length () == 1)
-    {
-      octave_value arg = args(0);
+  if (args.length () != 1)
+    print_usage ();
 
-      if (arg.is_object ())
-        retval = Cell (arg.parent_class_names ());
-    }
-  else
-    print_usage ();
+  octave_value arg = args(0);
+
+  if (arg.is_object ())
+    retval = Cell (arg.parent_class_names ());
 
   return retval;
 }
 
 DEFUN (isobject, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isobject (@var{x})\n\
 Return true if @var{x} is a class object.\n\
 @seealso{class, typeinfo, isa, ismethod, isprop}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_object ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_object ());
 }
 
 DEFUN (ismethod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ismethod (@var{obj}, @var{method})\n\
 @deftypefnx {Built-in Function} {} ismethod (@var{clsname}, @var{method})\n\
 Return true if the string @var{method} is a valid method of the object\n\
 @var{obj} or of the class @var{clsname}.\n\
 @seealso{isprop, isobject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 2)
-    {
-      octave_value arg = args(0);
+  if (args.length () != 2)
+    print_usage ();
 
-      std::string class_name;
+  octave_value arg = args(0);
+
+  std::string class_name;
 
-      if (arg.is_object ())
-        class_name = arg.class_name ();
-      else if (arg.is_string ())
-        class_name = arg.string_value ();
-      else
-        error ("ismethod: first argument must be object or class name");
+  if (arg.is_object ())
+    class_name = arg.class_name ();
+  else if (arg.is_string ())
+    class_name = arg.string_value ();
+  else
+    error ("ismethod: first argument must be object or class name");
 
-      std::string method = args(1).string_value ();
+  std::string method = args(1).string_value ();
 
-      if (load_path::find_method (class_name, method) != std::string ())
-        retval = true;
-      else
-        retval = false;
-    }
+  if (load_path::find_method (class_name, method) != std::string ())
+    retval = true;
   else
-    print_usage ();
+    retval = false;
 
   return retval;
 }
 
 DEFUN (__methods__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __methods__ (@var{x})\n\
 @deftypefnx {Built-in Function} {} __methods__ (\"classname\")\n\
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3803,26 +3803,22 @@ cdef_manager::do_find_package_symbol (co
 }
 
 //----------------------------------------------------------------------------
 
 DEFUN (__meta_get_package__, args, , "")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
-
-      retval = to_ov (lookup_package (cname));
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
+
+  return to_ov (lookup_package (cname));
 }
 
 DEFUN (__superclass_reference__, args, /* nargout */,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __superclass_reference__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -3838,45 +3834,37 @@ Undocumented internal function.\n\
   octave_value retval;
 
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
             << args(0).string_value () << ")"
             << std::endl;
 #endif
 
-  if (args.length () == 1)
-    {
-      std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
-
-      retval = to_ov (lookup_class (cls));
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
+
+  return to_ov (lookup_class (cls));
 }
 
 DEFUN (metaclass, args, /* nargout */,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} metaclass (obj)\n\
 Returns the meta.class object corresponding to the class of @var{obj}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      cdef_object obj = to_cdef (args(0));
-
-      retval = to_ov (obj.get_class ());
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  cdef_object obj = to_cdef (args(0));
+
+  return to_ov (obj.get_class ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1711,134 +1711,130 @@ fields.\n\
 @strong{Warning:} @code{functions} is provided for debugging purposes only.\n\
 It's behavior may change in the future and programs should not depend on a\n\
 particular output.\n\
 \n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
-
-      octave_function *fcn = fh ? fh->function_value () : 0;
-
-      if (fcn)
-        {
-          octave_scalar_map m;
-
-          std::string fh_nm = fh->fcn_name ();
+  if (args.length () != 1)
+    print_usage ();
 
-          if (fh_nm == octave_fcn_handle::anonymous)
-            {
-              std::ostringstream buf;
-              fh->print_raw (buf);
-              m.setfield ("function", buf.str ());
+  octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
 
-              m.setfield ("type", "anonymous");
-            }
-          else
-            {
-              m.setfield ("function", fh_nm);
+  octave_function *fcn = fh ? fh->function_value () : 0;
 
-              if (fcn->is_subfunction ())
-                {
-                  m.setfield ("type", "subfunction");
-                  Cell parentage (dim_vector (1, 2));
-                  parentage.elem (0) = fh_nm;
-                  parentage.elem (1) = fcn->parent_fcn_name ();
-                  m.setfield ("parentage", octave_value (parentage));
-                }
-              else if (fcn->is_private_function ())
-                m.setfield ("type", "private");
-              else if (fh->is_overloaded ())
-                m.setfield ("type", "overloaded");
-              else
-                m.setfield ("type", "simple");
-            }
+  if (fcn)
+    {
+      octave_scalar_map m;
 
-          std::string nm = fcn->fcn_file_name ();
-
-          if (fh_nm == octave_fcn_handle::anonymous)
-            {
-              m.setfield ("file", nm);
-
-              octave_user_function *fu = fh->user_function_value ();
+      std::string fh_nm = fh->fcn_name ();
 
-              std::list<symbol_table::symbol_record> vars
-                = symbol_table::all_variables (fu->scope (), 0);
-
-              size_t varlen = vars.size ();
+      if (fh_nm == octave_fcn_handle::anonymous)
+        {
+          std::ostringstream buf;
+          fh->print_raw (buf);
+          m.setfield ("function", buf.str ());
 
-              if (varlen > 0)
-                {
-                  octave_scalar_map ws;
-                  for (std::list<symbol_table::symbol_record>::const_iterator
-                         p = vars.begin (); p != vars.end (); p++)
-                    {
-                      ws.assign (p->name (), p->varval (0));
-                    }
-
-                  m.setfield ("workspace", ws);
-                }
-            }
-          else if (fcn->is_user_function () || fcn->is_user_script ())
-            {
-              octave_function *fu = fh->function_value ();
-              m.setfield ("file", fu->fcn_file_name ());
-            }
-          else
-            m.setfield ("file", "");
-
-          retval = m;
+          m.setfield ("type", "anonymous");
         }
       else
-        error ("functions: FCN_HANDLE is not a valid function handle object");
+        {
+          m.setfield ("function", fh_nm);
+
+          if (fcn->is_subfunction ())
+            {
+              m.setfield ("type", "subfunction");
+              Cell parentage (dim_vector (1, 2));
+              parentage.elem (0) = fh_nm;
+              parentage.elem (1) = fcn->parent_fcn_name ();
+              m.setfield ("parentage", octave_value (parentage));
+            }
+          else if (fcn->is_private_function ())
+            m.setfield ("type", "private");
+          else if (fh->is_overloaded ())
+            m.setfield ("type", "overloaded");
+          else
+            m.setfield ("type", "simple");
+        }
+
+      std::string nm = fcn->fcn_file_name ();
+
+      if (fh_nm == octave_fcn_handle::anonymous)
+        {
+          m.setfield ("file", nm);
+
+          octave_user_function *fu = fh->user_function_value ();
+
+          std::list<symbol_table::symbol_record> vars
+            = symbol_table::all_variables (fu->scope (), 0);
+
+          size_t varlen = vars.size ();
+
+          if (varlen > 0)
+            {
+              octave_scalar_map ws;
+              for (std::list<symbol_table::symbol_record>::const_iterator
+                     p = vars.begin (); p != vars.end (); p++)
+                {
+                  ws.assign (p->name (), p->varval (0));
+                }
+
+              m.setfield ("workspace", ws);
+            }
+        }
+      else if (fcn->is_user_function () || fcn->is_user_script ())
+        {
+          octave_function *fu = fh->function_value ();
+          m.setfield ("file", fu->fcn_file_name ());
+        }
+      else
+        m.setfield ("file", "");
+
+      retval = m;
     }
   else
-    print_usage ();
+    error ("functions: FCN_HANDLE is not a valid function handle object");
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by the\n\
 function handle @var{fcn_handle}.\n\
 @seealso{str2func, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      octave_fcn_handle *fh = args(0).fcn_handle_value ("func2str: FCN_HANDLE argument must be a function handle object");
+  if (args.length () != 1)
+    print_usage ();
 
-      if (fh)
-        {
-          std::string fh_nm = fh->fcn_name ();
+  octave_fcn_handle *fh = args(0).fcn_handle_value ("func2str: FCN_HANDLE argument must be a function handle object");
 
-          if (fh_nm == octave_fcn_handle::anonymous)
-            {
-              std::ostringstream buf;
+  if (fh)
+    {
+      std::string fh_nm = fh->fcn_name ();
 
-              fh->print_raw (buf);
+      if (fh_nm == octave_fcn_handle::anonymous)
+        {
+          std::ostringstream buf;
 
-              retval = buf.str ();
-            }
-          else
-            retval = fh_nm;
+          fh->print_raw (buf);
+
+          retval = buf.str ();
         }
       else
-        error ("func2str: FCN_HANDLE must be a valid function handle");
+        retval = fh_nm;
     }
   else
-    print_usage ();
+    error ("func2str: FCN_HANDLE must be a valid function handle");
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
@@ -1847,34 +1843,32 @@ Return a function handle constructed fro
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  std::string nm = args(0).xstring_value ("str2func: FCN_NAME must be a string");
 
-      if (nm[0] == '@')
-        {
-          int parse_status;
-          octave_value anon_fcn_handle =
-            eval_string (nm, true, parse_status);
+  if (nm[0] == '@')
+    {
+      int parse_status;
+      octave_value anon_fcn_handle =
+        eval_string (nm, true, parse_status);
 
-          if (parse_status == 0)
-            retval = anon_fcn_handle;
-        }
-      else
-        retval = make_fcn_handle (nm, nargin != 2);
+      if (parse_status == 0)
+        retval = anon_fcn_handle;
     }
   else
-    print_usage ();
+    retval = make_fcn_handle (nm, nargin != 2);
 
   return retval;
 }
 
 /*
 %!test
 %! f = str2func ("<");
 %! assert (class (f), "function_handle");
@@ -1908,26 +1902,22 @@ functions are ignored in the lookup.\n\
 
 DEFUN (is_function_handle, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class, functions}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1)
-    retval = args(0).is_function_handle ();
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_function_handle ());
 }
 
 /*
 %!shared fh
 %! fh = @(x) x;
 
 %!assert (is_function_handle (fh))
 %!assert (! is_function_handle ({fh}))
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -674,159 +674,155 @@ functions from strings is through the us
 (@pxref{Anonymous Functions}) or @code{str2func}.\n\
 @seealso{argnames, formula, vectorize, str2func}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0)
-    {
-      std::string fun = args(0).xstring_value ("inline: STR argument must be a string");
+  if (nargin == 0)
+    print_usage ();
+
+  std::string fun = args(0).xstring_value ("inline: STR argument must be a string");
+
+  string_vector fargs;
 
-      string_vector fargs;
+  if (nargin == 1)
+    {
+      bool is_arg = false;
+      bool in_string = false;
+      std::string tmp_arg;
+      size_t i = 0;
+      size_t fun_length = fun.length ();
 
-      if (nargin == 1)
+      while (i < fun_length)
         {
-          bool is_arg = false;
-          bool in_string = false;
-          std::string tmp_arg;
-          size_t i = 0;
-          size_t fun_length = fun.length ();
+          bool terminate_arg = false;
+          char c = fun[i++];
 
-          while (i < fun_length)
+          if (in_string)
             {
-              bool terminate_arg = false;
-              char c = fun[i++];
+              if (c == '\'' || c == '\"')
+                in_string = false;
+            }
+          else if (c == '\'' || c == '\"')
+            {
+              in_string = true;
+              if (is_arg)
+                terminate_arg = true;
+            }
+          else if (! isalpha (c) && c != '_')
+            if (! is_arg)
+              continue;
+            else if (isdigit (c))
+              tmp_arg.append (1, c);
+            else
+              {
+                // Before we do anything remove trailing whitespaces.
+                while (i < fun_length && isspace (c))
+                  c = fun[i++];
 
-              if (in_string)
-                {
-                  if (c == '\'' || c == '\"')
-                    in_string = false;
-                }
-              else if (c == '\'' || c == '\"')
-                {
-                  in_string = true;
-                  if (is_arg)
-                    terminate_arg = true;
-                }
-              else if (! isalpha (c) && c != '_')
-                if (! is_arg)
-                  continue;
-                else if (isdigit (c))
-                  tmp_arg.append (1, c);
+                // Do we have a variable or a function?
+                if (c != '(')
+                  terminate_arg = true;
                 else
                   {
-                    // Before we do anything remove trailing whitespaces.
-                    while (i < fun_length && isspace (c))
-                      c = fun[i++];
-
-                    // Do we have a variable or a function?
-                    if (c != '(')
-                      terminate_arg = true;
-                    else
-                      {
-                        tmp_arg = std::string ();
-                        is_arg = false;
-                      }
+                    tmp_arg = std::string ();
+                    is_arg = false;
                   }
-              else if (! is_arg)
-                {
-                  if (c == 'e' || c == 'E')
-                    {
-                      // possible number in exponent form, not arg
-                      if (isdigit (fun[i])
-                          || fun[i] == '-' || fun[i] == '+')
-                        continue;
-                    }
-                  is_arg = true;
-                  tmp_arg.append (1, c);
-                }
-              else
-                {
-                  tmp_arg.append (1, c);
-                }
-
-              if (terminate_arg || (i == fun_length && is_arg))
+              }
+          else if (! is_arg)
+            {
+              if (c == 'e' || c == 'E')
                 {
-                  bool have_arg = false;
-
-                  for (int j = 0; j < fargs.numel (); j++)
-                    if (tmp_arg == fargs (j))
-                      {
-                        have_arg = true;
-                        break;
-                      }
-
-                  if (! have_arg && tmp_arg != "i" && tmp_arg != "j"
-                      && tmp_arg != "NaN" && tmp_arg != "nan"
-                      && tmp_arg != "Inf" && tmp_arg != "inf"
-                      && tmp_arg != "NA" && tmp_arg != "pi"
-                      && tmp_arg != "e" && tmp_arg != "eps")
-                    fargs.append (tmp_arg);
-
-                  tmp_arg = std::string ();
-                  is_arg = false;
+                  // possible number in exponent form, not arg
+                  if (isdigit (fun[i])
+                      || fun[i] == '-' || fun[i] == '+')
+                    continue;
                 }
-            }
-
-          // Sort the arguments into ascii order.
-          fargs.sort ();
-
-          if (fargs.numel () == 0)
-            fargs.append (std::string ("x"));
-
-        }
-      else if (nargin == 2 && args(1).is_numeric_type ())
-        {
-          if (! args(1).is_scalar_type ())
-            {
-              error ("inline: N must be an integer");
-              return retval;
-            }
-
-          int n = args(1).int_value ("inline: N must be an integer");
-
-          if (n >= 0)
-            {
-              fargs.resize (n+1);
-
-              fargs(0) = "x";
-
-              for (int i = 1; i < n+1; i++)
-                {
-                  std::ostringstream buf;
-                  buf << "P" << i;
-                  fargs(i) = buf.str ();
-                }
+              is_arg = true;
+              tmp_arg.append (1, c);
             }
           else
             {
-              error ("inline: N must be a positive integer or zero");
-              return retval;
+              tmp_arg.append (1, c);
+            }
+
+          if (terminate_arg || (i == fun_length && is_arg))
+            {
+              bool have_arg = false;
+
+              for (int j = 0; j < fargs.numel (); j++)
+                if (tmp_arg == fargs (j))
+                  {
+                    have_arg = true;
+                    break;
+                  }
+
+              if (! have_arg && tmp_arg != "i" && tmp_arg != "j"
+                  && tmp_arg != "NaN" && tmp_arg != "nan"
+                  && tmp_arg != "Inf" && tmp_arg != "inf"
+                  && tmp_arg != "NA" && tmp_arg != "pi"
+                  && tmp_arg != "e" && tmp_arg != "eps")
+                fargs.append (tmp_arg);
+
+              tmp_arg = std::string ();
+              is_arg = false;
+            }
+        }
+
+      // Sort the arguments into ascii order.
+      fargs.sort ();
+
+      if (fargs.numel () == 0)
+        fargs.append (std::string ("x"));
+
+    }
+  else if (nargin == 2 && args(1).is_numeric_type ())
+    {
+      if (! args(1).is_scalar_type ())
+        {
+          error ("inline: N must be an integer");
+          return retval;
+        }
+
+      int n = args(1).int_value ("inline: N must be an integer");
+
+      if (n >= 0)
+        {
+          fargs.resize (n+1);
+
+          fargs(0) = "x";
+
+          for (int i = 1; i < n+1; i++)
+            {
+              std::ostringstream buf;
+              buf << "P" << i;
+              fargs(i) = buf.str ();
             }
         }
       else
         {
-          fargs.resize (nargin - 1);
-
-          for (int i = 1; i < nargin; i++)
-            {
-              std::string s = args(i).xstring_value ("inline: additional arguments must be strings");
-              fargs(i-1) = s;
-            }
+          error ("inline: N must be a positive integer or zero");
+          return retval;
         }
-
-      retval = octave_value (new octave_fcn_inline (fun, fargs));
     }
   else
-    print_usage ();
+    {
+      fargs.resize (nargin - 1);
 
-  return retval;
+      for (int i = 1; i < nargin; i++)
+        {
+          std::string s = args(i).xstring_value ("inline: additional arguments must be strings");
+          fargs(i-1) = s;
+        }
+    }
+
+  return octave_value (new octave_fcn_inline (fun, fargs));
 }
 
 /*
 %!shared fn
 %! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
 %!assert (feval (inline ("sum (x(:))"), [1 2; 3 4]), 10)
@@ -850,27 +846,25 @@ Note that @code{char (@var{fun})} is equ
 @code{formula (@var{fun})}.\n\
 @seealso{char, argnames, inline, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      octave_fcn_inline* fn = args(0).fcn_inline_value (true);
+  if (nargin != 1)
+    print_usage ();
+
+  octave_fcn_inline* fn = args(0).fcn_inline_value (true);
 
-      if (fn)
-        retval = octave_value (fn->fcn_text ());
-      else
-        error ("formula: FUN must be an inline function");
-    }
+  if (fn)
+    retval = octave_value (fn->fcn_text ());
   else
-    print_usage ();
+    error ("formula: FUN must be an inline function");
 
   return retval;
 }
 
 /*
 %!assert (formula (fn), "x.^2 + 1")
 %!assert (formula (fn), char (fn))
 
@@ -887,36 +881,34 @@ Return a cell array of character strings
 arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      octave_fcn_inline *fn = args(0).fcn_inline_value (true);
+  if (nargin != 1)
+    print_usage ();
 
-      if (fn)
-        {
-          string_vector t1 = fn->fcn_arg_names ();
+  octave_fcn_inline *fn = args(0).fcn_inline_value (true);
 
-          Cell t2 (dim_vector (t1.numel (), 1));
-
-          for (int i = 0; i < t1.numel (); i++)
-            t2(i) = t1(i);
+  if (fn)
+    {
+      string_vector t1 = fn->fcn_arg_names ();
 
-          retval = t2;
-        }
-      else
-        error ("argnames: FUN must be an inline function");
+      Cell t2 (dim_vector (t1.numel (), 1));
+
+      for (int i = 0; i < t1.numel (); i++)
+        t2(i) = t1(i);
+
+      retval = t2;
     }
   else
-    print_usage ();
+    error ("argnames: FUN must be an inline function");
 
   return retval;
 }
 
 /*
 %!assert (argnames (fn), {"x"})
 %!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
 %!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
@@ -946,67 +938,65 @@ quadv (fcn, 0, 3)\n\
 @end example\n\
 @seealso{inline, formula, argnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      std::string old_func;
-      octave_fcn_inline* old = 0;
-      bool func_is_string = true;
+  if (nargin != 1)
+    print_usage ();
 
-      if (args(0).is_string ())
-        old_func = args(0).string_value ();
-      else
-        {
-          old = args(0).fcn_inline_value (true);
-          func_is_string = false;
+  std::string old_func;
+  octave_fcn_inline* old = 0;
+  bool func_is_string = true;
 
-          if (old)
-            old_func = old->fcn_text ();
-          else
-            error ("vectorize: FUN must be a string or inline function");
-        }
+  if (args(0).is_string ())
+    old_func = args(0).string_value ();
+  else
+    {
+      old = args(0).fcn_inline_value (true);
+      func_is_string = false;
 
-      std::string new_func;
-      size_t i = 0;
+      if (old)
+        old_func = old->fcn_text ();
+      else
+        error ("vectorize: FUN must be a string or inline function");
+    }
 
-      while (i < old_func.length ())
-        {
-          std::string t1 = old_func.substr (i, 1);
+  std::string new_func;
+  size_t i = 0;
 
-          if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
-            {
-              if (i && old_func.substr (i-1, 1) != ".")
-                new_func.append (".");
+  while (i < old_func.length ())
+    {
+      std::string t1 = old_func.substr (i, 1);
 
-              // Special case for ** operator.
-              if (t1 == "*" && i < (old_func.length () - 1)
-                  && old_func.substr (i+1, 1) == "*")
-                {
-                  new_func.append ("*");
-                  i++;
-                }
+      if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
+        {
+          if (i && old_func.substr (i-1, 1) != ".")
+            new_func.append (".");
+
+          // Special case for ** operator.
+          if (t1 == "*" && i < (old_func.length () - 1)
+              && old_func.substr (i+1, 1) == "*")
+            {
+              new_func.append ("*");
+              i++;
             }
-          new_func.append (t1);
-          i++;
         }
+      new_func.append (t1);
+      i++;
+    }
 
-      if (func_is_string)
-        retval = octave_value (new_func);
-      else
-        retval = octave_value (new octave_fcn_inline
-                               (new_func, old->fcn_arg_names ()));
-    }
+  if (func_is_string)
+    retval = octave_value (new_func);
   else
-    print_usage ();
+    retval = octave_value (new octave_fcn_inline
+                           (new_func, old->fcn_arg_names ()));
 
   return retval;
 }
 
 /*
 %!assert (char (vectorize (fn)), "x.^2 + 1")
 %!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
 %!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -859,48 +859,46 @@ DEFUN (single, args, ,
 Convert @var{x} to single precision type.\n\
 @seealso{double}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
-  if (args.length () == 1)
+  if (args.length () != 1)
+    print_usage ();
+
+  if (args(0).is_diag_matrix ())
     {
-      if (args(0).is_diag_matrix ())
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix,
-                                      octave_float_complex);
-            }
-          else
-            {
-              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix,
-                                      octave_float_scalar);
-            }
-        }
-      else if (args(0).is_sparse_type ())
-        {
-          error ("single: sparse type does not support single precision");
-        }
-      else if (args(0).is_complex_type ())
-        {
-          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix,
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix,
                                   octave_float_complex);
         }
       else
         {
-          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix,
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix,
                                   octave_float_scalar);
         }
     }
+  else if (args(0).is_sparse_type ())
+    {
+      error ("single: sparse type does not support single precision");
+    }
+  else if (args(0).is_complex_type ())
+    {
+      OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix,
+                              octave_float_complex);
+    }
   else
-    print_usage ();
+    {
+      OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix,
+                              octave_float_scalar);
+    }
 
   return octave_value ();
 }
 
 /*
 %!assert (class (single (1)), "single")
 %!assert (class (single (1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2126,45 +2126,46 @@ example supplies an initial argument to 
 x = javaObject (\"java.lang.StringBuffer\")\n\
 x = javaObject (\"java.lang.StringBuffer\", \"Initial string\")\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{javaMethod, javaArray}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_JAVA
-  octave_value retval;
 
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () > 0)
+  if (args.length () == 0)
+    print_usage ();
+
+  if (args(0).is_string ())
     {
-      if (args(0).is_string ())
-        {
-          std::string classname = args(0).string_value ();
-
-          octave_value_list tmp;
-          for (int i=1; i<args.length (); i++)
-            tmp(i-1) = args(i);
-          retval = octave_java::do_javaObject (current_env, classname, tmp);
-        }
-      else
-        error ("javaObject: CLASSNAME must be a string");
+      std::string classname = args(0).string_value ();
+
+      octave_value_list tmp;
+      for (int i=1; i<args.length (); i++)
+        tmp(i-1) = args(i);
+      retval = octave_java::do_javaObject (current_env, classname, tmp);
     }
   else
-    print_usage ();
+    error ("javaObject: CLASSNAME must be a string");
+
+#else
+
+  error ("javaObject: Octave was not compiled with Java interface");
+
+#endif
 
   return retval;
-#else
-  error ("javaObject: Octave was not compiled with Java interface");
-  return octave_value ();
-#endif
 }
 
 /*
 ## The tests below merely check if javaObject() works at all.  Whether it works
 ## properly, i.e., creates the right values, is a matter of Java itself.
 ## Create a Short and check if it really is a short, i.e., whether it overflows.
 %!testif HAVE_JAVA
 %! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
@@ -2191,57 +2192,58 @@ equivalent\n\
 @end group\n\
 @end example\n\
 \n\
 @code{javaMethod} returns the result of the method invocation.\n\
 \n\
 @seealso{methods, javaObject}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_JAVA
-  octave_value retval;
 
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () > 1)
+  if (args.length () < 2)
+    print_usage ();
+
+  if (args(0).is_string ())
     {
-      if (args(0).is_string ())
+      std::string methodname = args(0).string_value ();
+
+      octave_value_list tmp;
+      for (int i=2; i<args.length (); i++)
+        tmp(i-2) = args(i);
+
+      if (args(1).is_java ())
         {
-          std::string methodname = args(0).string_value ();
-
-          octave_value_list tmp;
-          for (int i=2; i<args.length (); i++)
-            tmp(i-2) = args(i);
-
-          if (args(1).is_java ())
-            {
-              octave_java *jobj = TO_JAVA (args(1));
-              retval = jobj->do_javaMethod (current_env, methodname, tmp);
-            }
-          else if (args(1).is_string ())
-            {
-              std::string cls = args(1).string_value ();
-              retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
-            }
-          else
-            error ("javaMethod: OBJ must be a Java object or a string");
+          octave_java *jobj = TO_JAVA (args(1));
+          retval = jobj->do_javaMethod (current_env, methodname, tmp);
+        }
+      else if (args(1).is_string ())
+        {
+          std::string cls = args(1).string_value ();
+          retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
         }
       else
-        error ("javaMethod: METHODNAME must be a string");
+        error ("javaMethod: OBJ must be a Java object or a string");
     }
   else
-    print_usage ();
+    error ("javaMethod: METHODNAME must be a string");
+
+#else
+
+  error ("javaMethod: Octave was not compiled with Java interface");
+
+#endif
 
   return retval;
-#else
-  error ("javaMethod: Octave was not compiled with Java interface");
-  return octave_value ();
-#endif
 }
 
 /*
 %!testif HAVE_JAVA
 %! ## Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ("getProperty", "java.lang.System", "java.version"), ".");
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
 */
@@ -2263,53 +2265,54 @@ equivalent\n\
   __java_get__ (x, \"field1\")\n\
   x.field1\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_set__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_JAVA
-  octave_value retval;
 
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () == 2)
+  if (args.length () != 2)
+    print_usage ();
+
+  if (args(1).is_string ())
     {
-      if (args(1).is_string ())
+      std::string name = args(1).string_value ();
+
+      if (args(0).is_java ())
         {
-          std::string name = args(1).string_value ();
-
-          if (args(0).is_java ())
-            {
-              octave_java *jobj = TO_JAVA (args(0));
-              retval = jobj->do_java_get (current_env, name);
-            }
-          else if (args(0).is_string ())
-            {
-              std::string cls = args(0).string_value ();
-              retval = octave_java::do_java_get (current_env, cls, name);
-            }
-          else
-            error ("__java_get__: OBJ must be a Java object or a string");
+          octave_java *jobj = TO_JAVA (args(0));
+          retval = jobj->do_java_get (current_env, name);
+        }
+      else if (args(0).is_string ())
+        {
+          std::string cls = args(0).string_value ();
+          retval = octave_java::do_java_get (current_env, cls, name);
         }
       else
-        error ("__java_get__: NAME must be a string");
+        error ("__java_get__: OBJ must be a Java object or a string");
     }
   else
-    print_usage ();
+    error ("__java_get__: NAME must be a string");
+
+#else
+
+  error ("__java_get__: Octave was not compiled with Java interface");
+
+#endif
 
   return retval;
-#else
-  error ("__java_get__: Octave was not compiled with Java interface");
-  return octave_value ();
-#endif
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
 @var{val}.\n\
 \n\
@@ -2325,86 +2328,88 @@ equivalent\n\
   __java_set__ (x, \"field1\", val)\n\
   x.field1 = val\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{__java_get__, javaMethod, javaObject}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_JAVA
-  octave_value retval;
 
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () == 3)
+  if (args.length () != 3)
+    print_usage ();
+
+  if (args(1).is_string ())
     {
-      if (args(1).is_string ())
+      std::string name = args(1).string_value ();
+
+      if (args(0).is_java ())
         {
-          std::string name = args(1).string_value ();
-
-          if (args(0).is_java ())
-            {
-              octave_java *jobj = TO_JAVA (args(0));
-              retval = jobj->do_java_set (current_env, name, args(2));
-            }
-          else if (args(0).is_string ())
-            {
-              std::string cls = args(0).string_value ();
-              retval = octave_java::do_java_set (current_env, cls, name, args(2));
-            }
-          else
-            error ("__java_set__: OBJ must be a Java object or a string");
+          octave_java *jobj = TO_JAVA (args(0));
+          retval = jobj->do_java_set (current_env, name, args(2));
+        }
+      else if (args(0).is_string ())
+        {
+          std::string cls = args(0).string_value ();
+          retval = octave_java::do_java_set (current_env, cls, name, args(2));
         }
       else
-        error ("__java_set__: NAME must be a string");
+        error ("__java_set__: OBJ must be a Java object or a string");
     }
   else
-    print_usage ();
+    error ("__java_set__: NAME must be a string");
+
+#else
+
+  error ("__java_set__: Octave was not compiled with Java interface");
+
+#endif
 
   return retval;
-#else
-  error ("__java_set__: Octave was not compiled with Java interface");
-  return octave_value ();
-#endif
 }
 
 DEFUN (java2mat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} java2mat (@var{javaobj})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
+  octave_value_list retval;
+
 #ifdef HAVE_JAVA
-  octave_value_list retval;
 
   initialize_java ();
 
   JNIEnv *current_env = octave_java::thread_jni_env ();
 
-  if (args.length () == 1)
+  if (args.length () != 1)
+    print_usage ();
+
+  if (args(0).is_java ())
     {
-      if (args(0).is_java ())
-        {
-          octave_java *jobj = TO_JAVA (args(0));
-          retval(0) = box_more (current_env, jobj->to_java (), 0);
-        }
-      else
-        retval(0) = args(0);
+      octave_java *jobj = TO_JAVA (args(0));
+      retval(0) = box_more (current_env, jobj->to_java (), 0);
     }
   else
-    print_usage ();
+    retval(0) = args(0);
+
+#else
+
+  error ("java2mat: Octave was not compiled with Java interface");
+
+#endif
 
   return retval;
-#else
-  error ("java2mat: Octave was not compiled with Java interface");
-  return octave_value ();
-#endif
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
@@ -2413,22 +2418,28 @@ automatically converted to Octave matric
 The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
+  octave_value retval;
+
 #ifdef HAVE_JAVA
-  return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
+
+  retval = SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
+
   error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
-  return octave_value ();
+
 #endif
+
+  return retval;
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
@@ -2478,24 +2489,20 @@ The original variable value is restored 
 // test for the presence of a Java object without having Java installed.
 DEFUN (isjava, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isjava (@var{x})\n\
 Return true if @var{x} is a Java object.\n\
 @seealso{class, typeinfo, isa, javaObject}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
-  else
-    retval = args(0).is_java ();
-
-  return retval;
+
+  return octave_value (args(0).is_java ());
 }
 
 /*
 ## Check automatic conversion of java primitive arrays into octave types.
 %!testif HAVE_JAVA
 %! assert (javaObject ("java.lang.String", "hello").getBytes (),
 %!         int8 ([104 101 108 108 111]'));
 
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -109,26 +109,22 @@ distinguish the cases:\n\
 This should delete elements if @code{I} is nonempty.\n\
 \n\
 @item @code{X = []; A(I) = X}\n\
 This should give an error if @code{I} is nonempty.\n\
 @end table\n\
 @seealso{isempty, isindex}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_defined ())
-    retval = args(0).is_null_value ();
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_null_value ());
 }
 
 /*
 %!assert (isnull ([]), true)
 %!assert (isnull ([1]), false)
 %!assert (isnull (zeros (0,3)), false)
 %!assert (isnull (""), true)
 %!assert (isnull ("A"), false)
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -181,24 +181,20 @@ Create a special object that executes a 
 \n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{function} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = octave_value (new octave_oncleanup (args(0)));
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (new octave_oncleanup (args(0)));
 }
 
 /*
 %!test
 %! old_wstate = warning ("query");
 %! unwind_protect
 %!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
 %!   warning ("off", "__MY_WARNING__");
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -982,60 +982,58 @@ DEFUN (double, args, ,
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
-  if (args.length () == 1)
+  if (args.length () != 1)
+    print_usage ();
+
+  if (args(0).is_perm_matrix ())
     {
-      if (args(0).is_perm_matrix ())
-        {
-          OCTAVE_TYPE_CONV_BODY3 (double, octave_perm_matrix, octave_scalar);
-        }
-      else if (args(0).is_diag_matrix ())
+      OCTAVE_TYPE_CONV_BODY3 (double, octave_perm_matrix, octave_scalar);
+    }
+  else if (args(0).is_diag_matrix ())
+    {
+      if (args(0).is_complex_type ())
         {
-          if (args(0).is_complex_type ())
-            {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix,
-                                      octave_complex);
-            }
-          else
-            {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix,
-                                      octave_scalar);
-            }
-        }
-      else if (args(0).is_sparse_type ())
-        {
-          if (args(0).is_complex_type ())
-            {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix,
-                                      octave_complex);
-            }
-          else
-            {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix,
-                                      octave_scalar);
-            }
-        }
-      else if (args(0).is_complex_type ())
-        {
-          OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix,
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix,
                                   octave_complex);
         }
       else
         {
-          OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix,
+                                  octave_scalar);
         }
     }
+  else if (args(0).is_sparse_type ())
+    {
+      if (args(0).is_complex_type ())
+        {
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix,
+                                  octave_complex);
+        }
+      else
+        {
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix,
+                                  octave_scalar);
+        }
+    }
+  else if (args(0).is_complex_type ())
+    {
+      OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix,
+                              octave_complex);
+    }
   else
-    print_usage ();
+    {
+      OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
+    }
 
   return octave_value ();
 }
 
 /*
 %!assert (class (double (single (1))), "double")
 %!assert (class (double (single (1 + i))), "double")
 %!assert (class (double (int8 (1))), "double")
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Cell.h"
+#include "builtin-defun-decls.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "oct-hdf5.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
@@ -1846,24 +1847,20 @@ produces a struct @strong{array}.\n\
 
 DEFUN (isstruct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_map ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_map ());
 }
 
 DEFUN (__fieldnames__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __fieldnames__ (@var{struct})\n\
 @deftypefnx {Built-in Function} {} __fieldnames__ (@var{obj})\n\
 Internal function.\n\
 \n\
@@ -1899,78 +1896,77 @@ If @var{name} is a cell array of strings
 dimension is returned.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
+  if (nargin != 2)
+    print_usage ();
+
+  retval = false;
+
+  if (args(0).is_map ())
     {
-      retval = false;
-
-      if (args(0).is_map ())
+      octave_map m = args(0).map_value ();
+
+      // FIXME: should this work for all types that can do
+      // structure reference operations?
+
+      if (args(1).is_string ())
         {
-          octave_map m = args(0).map_value ();
-
-          // FIXME: should this work for all types that can do
-          // structure reference operations?
-
-          if (args(1).is_string ())
-            {
-              std::string key = args(1).string_value ();
-
-              retval = m.isfield (key);
-            }
-          else if (args(1).is_cell ())
+          std::string key = args(1).string_value ();
+
+          retval = m.isfield (key);
+        }
+      else if (args(1).is_cell ())
+        {
+          Cell c = args(1).cell_value ();
+          boolNDArray bm (c.dims ());
+          octave_idx_type n = bm.numel ();
+
+          for (octave_idx_type i = 0; i < n; i++)
             {
-              Cell c = args(1).cell_value ();
-              boolNDArray bm (c.dims ());
-              octave_idx_type n = bm.numel ();
-
-              for (octave_idx_type i = 0; i < n; i++)
+              if (c(i).is_string ())
                 {
-                  if (c(i).is_string ())
-                    {
-                      std::string key = c(i).string_value ();
-
-                      bm(i) = m.isfield (key);
-                    }
-                  else
-                    bm(i) = false;
+                  std::string key = c(i).string_value ();
+
+                  bm(i) = m.isfield (key);
                 }
-
-              retval = bm;
+              else
+                bm(i) = false;
             }
+
+          retval = bm;
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (numfields, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} numfields (@var{s})\n\
 Return the number of fields of the structure @var{s}.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 && args(0).is_map ())
-    {
-      retval = static_cast<double> (args(0).nfields ());
-    }
+  if (nargin != 1)
+    print_usage ();
+
+  if (args(0).is_map ())
+    retval = static_cast<double> (args(0).nfields ());
   else
-    print_usage ();
+    error ("numfields: argument must be a struct");
 
   return retval;
 }
 
 /*
 ## test isfield
 %!test
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
@@ -2009,93 +2005,91 @@ A(1)\n\
 @end example\n\
 @seealso{struct2cell, cell2mat, struct}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  if (! args(0).is_cell ())
+    {
+      error ("cell2struct: argument CELL must be of type cell");
+      return retval;
+    }
+
+  if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
     {
-      if (! args(0).is_cell ())
-        {
-          error ("cell2struct: argument CELL must be of type cell");
-          return retval;
-        }
-
-      if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
+      error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
+      return retval;
+    }
+
+  const Cell vals = args(0).cell_value ();
+  const Array<std::string> fields = args(1).cellstr_value ();
+
+  octave_idx_type ext = 0;
+
+  int dim = 0;
+
+  if (nargin == 3)
+    {
+      if (args(2).is_real_scalar ())
+        dim = nargin == 2 ? 0 : args(2).int_value () - 1;
+      else
         {
-          error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
-          return retval;
-        }
-
-      const Cell vals = args(0).cell_value ();
-      const Array<std::string> fields = args(1).cellstr_value ();
-
-      octave_idx_type ext = 0;
-
-      int dim = 0;
-
-      if (nargin == 3)
-        {
-          if (args(2).is_real_scalar ())
-            dim = nargin == 2 ? 0 : args(2).int_value () - 1;
-          else
-            {
-              error ("cell2struct: DIM must be a real scalar");
-              return retval;
-            }
-        }
-
-      if (dim < 0)
-        {
-          error ("cell2struct: DIM must be a valid dimension");
+          error ("cell2struct: DIM must be a real scalar");
           return retval;
         }
-
-      ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
-
-      if (ext != fields.numel ())
-        {
-          error ("cell2struct: number of FIELDS does not match dimension");
-          return retval;
-        }
-
-      int nd = std::max (dim+1, vals.ndims ());
-      // result dimensions.
-      dim_vector rdv = vals.dims ().redim (nd);
-
-      assert (ext == rdv(dim));
-      if (nd == 2)
-        {
-          rdv(0) = rdv(1-dim);
-          rdv(1) = 1;
-        }
-      else
-        {
-          for (int i =  dim + 1; i < nd; i++)
-            rdv(i-1) = rdv(i);
-
-          rdv.resize (nd-1);
-        }
-
-      octave_map map (rdv);
-      Array<idx_vector> ia (dim_vector (nd, 1), idx_vector::colon);
-
-      for (octave_idx_type i = 0; i < ext; i++)
-        {
-          ia(dim) = i;
-          map.setfield (fields(i), vals.index (ia).reshape (rdv));
-        }
-
-      retval = map;
+    }
+
+  if (dim < 0)
+    {
+      error ("cell2struct: DIM must be a valid dimension");
+      return retval;
+    }
+
+  ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
+
+  if (ext != fields.numel ())
+    {
+      error ("cell2struct: number of FIELDS does not match dimension");
+      return retval;
+    }
+
+  int nd = std::max (dim+1, vals.ndims ());
+  // result dimensions.
+  dim_vector rdv = vals.dims ().redim (nd);
+
+  assert (ext == rdv(dim));
+  if (nd == 2)
+    {
+      rdv(0) = rdv(1-dim);
+      rdv(1) = 1;
     }
   else
-    print_usage ();
+    {
+      for (int i =  dim + 1; i < nd; i++)
+        rdv(i-1) = rdv(i);
+
+      rdv.resize (nd-1);
+    }
+
+  octave_map map (rdv);
+  Array<idx_vector> ia (dim_vector (nd, 1), idx_vector::colon);
+
+  for (octave_idx_type i = 0; i < ext; i++)
+    {
+      ia(dim) = i;
+      map.setfield (fields(i), vals.index (ia).reshape (rdv));
+    }
+
+  retval = map;
 
   return retval;
 }
 
 /*
 ## test cell2struct versus struct2cell
 %!test
 %! keys = cellstr (char (floor (rand (100,10)*24+65)))';
@@ -2107,62 +2101,52 @@ A(1)\n\
 %! assert (fieldnames (s), keys');
 
 %!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
 
 %!assert (cell2struct ({}, {"f"}, 3), struct ("f", {}));
 */
 
 
-// So we can call Fcellstr directly.
-extern octave_value_list Fcellstr (const octave_value_list& args, int);
-
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{sout} =} rmfield (@var{s}, \"@var{f}\")\n\
 @deftypefnx {Built-in Function} {@var{sout} =} rmfield (@var{s}, @var{f})\n\
 Return a @emph{copy} of the structure (array) @var{s} with the field @var{f}\n\
 removed.\n\
 \n\
 If @var{f} is a cell array of strings or a character array, remove each of\n\
 the named fields.\n\
 @seealso{orderfields, fieldnames, isfield}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
+  if (nargin != 2)
+    print_usage ();
+
+  octave_map m = args(0).xmap_value ("rmfield: first argument must be a struct");
+
+  octave_value_list fval = Fcellstr (args(1), 1);
+
+  Cell fcell = fval(0).cell_value ();
+
+  for (int i = 0; i < fcell.numel (); i++)
     {
-      octave_map m = args(0).map_value ();
-
-      octave_value_list fval = Fcellstr (args(1), 1);
-
-      Cell fcell = fval(0).cell_value ();
-
-      for (int i = 0; i < fcell.numel (); i++)
-        {
-          std::string key = fcell(i).string_value ();
-
-          if (m.isfield (key))
-            m.rmfield (key);
-          else
-            {
-              error ("rmfield: structure does not contain field %s",
-                     key.c_str ());
-
-              break;
-            }
-        }
-
-      retval = m;
+      std::string key = fcell(i).string_value ();
+
+      if (m.isfield (key))
+        m.rmfield (key);
+      else
+        error ("rmfield: structure does not contain field %s", key.c_str ());
     }
-  else
-    print_usage ();
+
+  retval = m;
 
   return retval;
 }
 
 /*
 ## test rmfield
 %!shared x
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
diff --git a/libinterp/octave-value/ov-type-conv.h b/libinterp/octave-value/ov-type-conv.h
--- a/libinterp/octave-value/ov-type-conv.h
+++ b/libinterp/octave-value/ov-type-conv.h
@@ -75,36 +75,34 @@ octave_type_conv_body (const octave_valu
 
 
 #define OCTAVE_TYPE_CONV_BODY3(NAME, MATRIX_RESULT_T, SCALAR_RESULT_T) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
-  if (nargin == 1) \
-    { \
-      const octave_value arg = args(0); \
+  if (nargin != 1) \
+    print_usage (); \
  \
-      int t_result = MATRIX_RESULT_T::static_type_id (); \
+  const octave_value arg = args(0); \
+ \
+  int t_result = MATRIX_RESULT_T::static_type_id (); \
  \
-      retval = octave_type_conv_body (arg, #NAME, t_result); \
-      if (retval.is_undefined ()) \
-        { \
-          std::string arg_tname = arg.type_name (); \
+  retval = octave_type_conv_body (arg, #NAME, t_result); \
+  if (retval.is_undefined ()) \
+    { \
+      std::string arg_tname = arg.type_name (); \
  \
-          std::string result_tname = arg.numel () == 1 \
-            ? SCALAR_RESULT_T::static_type_name () \
-            : MATRIX_RESULT_T::static_type_name (); \
+      std::string result_tname = arg.numel () == 1 \
+        ? SCALAR_RESULT_T::static_type_name () \
+        : MATRIX_RESULT_T::static_type_name (); \
  \
-          gripe_invalid_conversion (arg_tname, result_tname); \
-        } \
+      gripe_invalid_conversion (arg_tname, result_tname); \
     } \
-  else \
-    print_usage (); \
  \
   return retval
 
 #define OCTAVE_TYPE_CONV_BODY(NAME) \
   OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
                           octave_ ## NAME ## _scalar)
 
 #endif
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -620,22 +620,23 @@ If @var{expr} is omitted, return a cell 
 currently installed data types.\n\
 @seealso{class, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 0)
     retval = Cell (octave_value_typeinfo::installed_type_names ());
-  else if (nargin == 1)
+  else
     retval = args(0).type_name ();
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (iscellstr (typeinfo ()))
 
 %!assert (typeinfo ({"cell"}), "cell")
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -826,16 +826,19 @@ nargin (\"union\")\n\
 Programming Note: @code{nargin} does not work on built-in functions.\n\
 @seealso{nargout, narginchk, varargin, inputname}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
@@ -864,25 +867,23 @@ Programming Note: @code{nargin} does not
               // Matlab gives up for histc,
               // so maybe it's ok that that we give up somtimes too?
               error ("nargin: nargin information not available for built-in functions");
             }
         }
       else
         error ("nargin: FCN must be a string or function handle");
     }
-  else if (nargin == 0)
+  else
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
@@ -936,16 +937,19 @@ Programming Note.  @code{nargout} does n
 returns -1 for all anonymous functions.\n\
 @seealso{nargin, varargout, isargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
@@ -995,30 +999,28 @@ returns -1 for all anonymous functions.\
               // Matlab gives up for histc,
               // so maybe it's ok that we give up somtimes too?
               error ("nargout: nargout information not available for built-in functions.");
             }
         }
       else
         error ("nargout: FCN must be a string or function handle");
     }
-  else if (nargin == 0)
+  else
     {
       if (! symbol_table::at_top_level ())
         {
           retval = symbol_table::varval (".nargout.");
 
           if (retval.is_undefined ())
             retval = 0;
         }
       else
         error ("nargout: invalid call at top level");
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
@@ -1073,51 +1075,49 @@ element-by-element and a logical array i
 @code{isargout} returns an error.\n\
 @seealso{nargout, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      if (! symbol_table::at_top_level ())
-        {
-          int nargout1 = symbol_table::varval (".nargout.").int_value ();
+  if (nargin != 1)
+    print_usage ();
 
-          Matrix ignored;
-          octave_value tmp = symbol_table::varval (".ignored.");
-          if (tmp.is_defined ())
-            ignored = tmp.matrix_value ();
+  if (! symbol_table::at_top_level ())
+    {
+      int nargout1 = symbol_table::varval (".nargout.").int_value ();
 
-          if (args(0).is_scalar_type ())
-            {
-              double k = args(0).double_value ();
+      Matrix ignored;
+      octave_value tmp = symbol_table::varval (".ignored.");
+      if (tmp.is_defined ())
+        ignored = tmp.matrix_value ();
 
-              retval = isargout1 (nargout1, ignored, k);
-            }
-          else if (args(0).is_numeric_type ())
-            {
-              const NDArray ka = args(0).array_value ();
+      if (args(0).is_scalar_type ())
+        {
+          double k = args(0).double_value ();
 
-              boolNDArray r (ka.dims ());
-              for (octave_idx_type i = 0; i < ka.numel (); i++)
-                r(i) = isargout1 (nargout1, ignored, ka(i));
+          retval = isargout1 (nargout1, ignored, k);
+        }
+      else if (args(0).is_numeric_type ())
+        {
+          const NDArray ka = args(0).array_value ();
 
-              retval = r;
-            }
-          else
-            gripe_wrong_type_arg ("isargout", args(0));
+          boolNDArray r (ka.dims ());
+          for (octave_idx_type i = 0; i < ka.numel (); i++)
+            r(i) = isargout1 (nargout1, ignored, ka(i));
+
+          retval = r;
         }
       else
-        error ("isargout: invalid call at top level");
+        gripe_wrong_type_arg ("isargout", args(0));
     }
   else
-    print_usage ();
+    error ("isargout: invalid call at top level");
 
   return retval;
 }
 
 /*
 %!function [x, y] = try_isargout ()
 %!  if (isargout (1))
 %!    if (isargout (2))
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2922,24 +2922,20 @@ install_types (void)
 
 DEFUN (sizeof, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).byte_size ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).byte_size ());
 }
 
 /*
 %!assert (sizeof (uint64 (ones (3))), 72)
 %!assert (sizeof (double (zeros (2,4))), 64)
 %!assert (sizeof ({"foo", "bar", "baaz"}), 10)
 */
 
@@ -3043,32 +3039,30 @@ Note that this is the same as writing @c
 \n\
 If @var{idx} is an empty structure array with fields @samp{type} and\n\
 @samp{subs}, return @var{val}.\n\
 @seealso{subsasgn, substruct}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 2)
-    {
-      std::string type;
-      std::list<octave_value_list> idx;
-
-      decode_subscripts ("subsref", args(1), type, idx);
-
-      octave_value arg0 = args(0);
-
-      if (type.empty ())
-        retval = arg0;
-      else
-        retval = arg0.subsref (type, idx, nargout);
-    }
+  if (args.length () != 2)
+    print_usage ();
+
+  std::string type;
+  std::list<octave_value_list> idx;
+
+  decode_subscripts ("subsref", args(1), type, idx);
+
+  octave_value arg0 = args(0);
+
+  if (type.empty ())
+    retval = arg0;
   else
-    print_usage ();
+    retval = arg0.subsref (type, idx, nargout);
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
 Perform the subscripted assignment operation according to the subscript\n\
@@ -3098,40 +3092,38 @@ Note that this is the same as writing @c
 \n\
 If @var{idx} is an empty structure array with fields @samp{type} and\n\
 @samp{subs}, return @var{rhs}.\n\
 @seealso{subsref, substruct}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 3)
+  if (args.length () != 3)
+    print_usage ();
+
+  std::string type;
+  std::list<octave_value_list> idx;
+
+  decode_subscripts ("subsasgn", args(1), type, idx);
+
+  if (type.empty ())
     {
-      std::string type;
-      std::list<octave_value_list> idx;
-
-      decode_subscripts ("subsasgn", args(1), type, idx);
-
-      if (type.empty ())
-        {
-          // Regularize a null matrix if stored into a variable.
-
-          retval = args(2).storable_value ();
-        }
-      else
-        {
-          octave_value arg0 = args(0);
-
-          arg0.make_unique ();
-
-          retval= arg0.subsasgn (type, idx, args(2));
-        }
+      // Regularize a null matrix if stored into a variable.
+
+      retval = args(2).storable_value ();
     }
   else
-    print_usage ();
+    {
+      octave_value arg0 = args(0);
+
+      arg0.make_unique ();
+
+      retval= arg0.subsasgn (type, idx, args(2));
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! a = reshape ([1:25], 5,5);
 %! idx1 = substruct ("()", {3, 3});
@@ -3200,24 +3192,20 @@ If @var{idx} is an empty structure array
 
 DEFUN (is_sq_string, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_sq_string ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_sq_string ());
 }
 
 /*
 %!assert (is_sq_string ('foo'), true)
 %!assert (is_sq_string ("foo"), false)
 %!assert (is_sq_string (1.0), false)
 %!assert (is_sq_string ({2.0}), false)
 
@@ -3227,24 +3215,20 @@ Return true if @var{x} is a single-quote
 
 DEFUN (is_dq_string, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
 @seealso{is_sq_string, ischar}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    retval = args(0).is_dq_string ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).is_dq_string ());
 }
 
 /*
 %!assert (is_dq_string ("foo"), true)
 %!assert (is_dq_string ('foo'), false)
 %!assert (is_dq_string (1.0), false)
 %!assert (is_dq_string ({2.0}), false)
 
