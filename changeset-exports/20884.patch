# HG changeset patch
# User José Luis García Pallero <jgpallero@gmail.com>
# Date 1450022380 28800
#      Sun Dec 13 07:59:40 2015 -0800
# Node ID f1b2a2dbc0e1b93c194fc7485559ec35e7a8aaa9
# Parent  c7d881aec36ca0dfc8c9b7e626f2418e929c6c7d
2015 Code Sprint: use ovl () in C++ files.

* __dsearchn__.cc, balance.cc, colloc.cc, data.cc, debug.cc, dirfns.cc, eig.cc,
file-io.cc, getgrent.cc, getpwent.cc, givens.cc, help.cc, hess.cc, mgorth.cc,
quad.cc: Replace assignments to retval(?) with calls to ovl().

diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -90,18 +90,17 @@ Undocumented internal function.\n\
               OCTAVE_QUIT;
             }
 
           *pdist++ = d0;
           pidx++;
           pxi += n;
         }
 
-      retval(1) = dist;
-      retval(0) = idx;
+      retval = ovl (idx, dist);
     }
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -153,85 +153,85 @@ Generalized eigenvalue problem balancing
       // balance the AEP
       if (isfloat)
         {
           if (complex_case)
             {
               FloatComplexAEPBALANCE result (fcaa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
-                retval(0) = result.balanced_matrix ();
+                retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 {
-                  retval(1) = result.balanced_matrix ();
-                  retval(0) = result.balancing_matrix ();
+                  retval = ovl (result.balancing_matrix (),
+                                result.balanced_matrix ());
                 }
               else
                 {
-                  retval(2) = result.balanced_matrix ();
-                  retval(1) = result.permuting_vector ();
-                  retval(0) = result.scaling_vector ();
+                  retval = ovl (result.scaling_vector (),
+                                result.permuting_vector (),
+                                result.balanced_matrix ());
                 }
 
             }
           else
             {
               FloatAEPBALANCE result (faa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
-                retval(0) = result.balanced_matrix ();
+                retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 {
-                  retval(1) = result.balanced_matrix ();
-                  retval(0) = result.balancing_matrix ();
+                  retval = ovl (result.balancing_matrix (),
+                                result.balanced_matrix ());
                 }
               else
                 {
-                  retval(2) = result.balanced_matrix ();
-                  retval(1) = result.permuting_vector ();
-                  retval(0) = result.scaling_vector ();
+                  retval = ovl (result.scaling_vector (),
+                                result.permuting_vector (),
+                                result.balanced_matrix ());
                 }
             }
         }
       else
         {
           if (complex_case)
             {
               ComplexAEPBALANCE result (caa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
-                retval(0) = result.balanced_matrix ();
+                retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 {
-                  retval(1) = result.balanced_matrix ();
-                  retval(0) = result.balancing_matrix ();
+                  retval = ovl (result.balancing_matrix (),
+                                result.balanced_matrix ());
                 }
               else
                 {
-                  retval(2) = result.balanced_matrix ();
-                  retval(1) = result.permuting_vector ();
-                  retval(0) = result.scaling_vector ();
+                  retval = ovl (result.scaling_vector (),
+                                result.permuting_vector (),
+                                result.balanced_matrix ());
                 }
             }
           else
             {
               AEPBALANCE result (aa, noperm, noscal);
 
               if (nargout == 0 || nargout == 1)
-                retval(0) = result.balanced_matrix ();
+                retval = ovl (result.balanced_matrix ());
               else if (nargout == 2)
                 {
-                  retval(1) = result.balanced_matrix ();
-                  retval(0) = result.balancing_matrix ();
+                  retval = ovl (result.balancing_matrix (),
+                                result.balanced_matrix ());
                 }
               else
                 {
-                  retval(2) = result.balanced_matrix ();
-                  retval(1) = result.permuting_vector ();
-                  retval(0) = result.scaling_vector ();
+                  retval = ovl (result.scaling_vector (),
+                                result.permuting_vector (),
+                                result.balanced_matrix ());
                 }
             }
         }
     }
   else
     {
       std::string bal_job;
       if (nargout == 1)
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -90,15 +90,12 @@ Reference: @nospell{J. Villadsen}, @nosp
 
   CollocWt wts (ncol, left, right);
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
-  retval(3) = q;
-  retval(2) = B;
-  retval(1) = A;
-  retval(0) = r;
+  retval = ovl (r, A, B, q);
 
   return retval;
 }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -495,59 +495,55 @@ and @var{e} is an integer.  If\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 1)
     print_usage ();
 
   if (nargout < 2)
-    retval(0) = args(0).log2 ();
+    retval = ovl (args(0).log2 ());
   else if (args(0).is_single_type ())
     {
       if (args(0).is_real_type ())
         {
           FloatNDArray f;
           FloatNDArray x = args(0).float_array_value ();
           // FIXME: should E be an int value?
           FloatMatrix e;
           map_2_xlog2 (x, f, e);
-          retval(1) = e;
-          retval(0) = f;
+          retval = ovl (f, e);
         }
       else if (args(0).is_complex_type ())
         {
           FloatComplexNDArray f;
           FloatComplexNDArray x = args(0).float_complex_array_value ();
           // FIXME: should E be an int value?
           FloatNDArray e;
           map_2_xlog2 (x, f, e);
-          retval(1) = e;
-          retval(0) = f;
+          retval = ovl (f, e);
         }
     }
   else if (args(0).is_real_type ())
     {
       NDArray f;
       NDArray x = args(0).array_value ();
       // FIXME: should E be an int value?
       Matrix e;
       map_2_xlog2 (x, f, e);
-      retval(1) = e;
-      retval(0) = f;
+      retval = ovl (f, e);
     }
   else if (args(0).is_complex_type ())
     {
       ComplexNDArray f;
       ComplexNDArray x = args(0).complex_array_value ();
       // FIXME: should E be an int value?
       NDArray e;
       map_2_xlog2 (x, f, e);
-      retval(1) = e;
-      retval(0) = f;
+      retval = ovl (f, e);
     }
   else
     gripe_wrong_type_arg ("log2", args(0));
 
   return retval;
 }
 
 /*
@@ -6373,19 +6369,17 @@ CPU time used is nonzero.\n\
   fraction = ticks % CLOCKS_PER_SEC;
   seconds = ticks / CLOCKS_PER_SEC;
 
   sys = static_cast<double> (seconds) + static_cast<double>(fraction) /
         static_cast<double>(CLOCKS_PER_SEC);
 
 #endif
 
-  retval(2) = sys;
-  retval(1) = usr;
-  retval(0) = sys + usr;
+  retval = ovl (sys + usr, usr, sys);
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
@@ -6450,83 +6444,82 @@ The @code{sort} function may also be use
 of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
 lowercase 'a') of the strings is used.\n\
 \n\
 The algorithm used in @code{sort} is optimized for the sorting of partially\n\
 ordered lists.\n\
 @seealso{sortrows, issorted}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
-  sortmode smode = ASCENDING;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
-  bool return_idx = nargout > 1;
-
+  sortmode smode = ASCENDING;
+  bool return_idx = (nargout > 1);
+  bool have_sortmode = (nargin > 1 && args(1).is_string ()); 
   octave_value arg = args(0);
 
   int dim = 0;
   if (nargin > 1)
     {
-      if (args(1).is_string ())
+      if (have_sortmode)
         {
           std::string mode = args(1).string_value ();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
             error ("sort: MODE must be either \"ascend\" or \"descend\"");
         }
       else
         dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
     {
-      if (args(1).is_string ())
+      if (have_sortmode)
         error ("sort: DIM must be a valid dimension");
 
       std::string mode = args(2).xstring_value ("sort: MODE must be a string");
 
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         error ("sort: MODE must be either \"ascend\" or \"descend\"");
     }
 
   const dim_vector dv = arg.dims ();
-  if (nargin == 1 || args(1).is_string ())
+  if (nargin == 1 || have_sortmode)
     {
-      // Find first non singleton dimension
       dim = dv.first_non_singleton ();
     }
   else
     {
       if (dim < 0)
         error ("sort: DIM must be a valid dimension");
     }
 
+  octave_value_list retval (return_idx ? 2 : 1);
+
   if (return_idx)
     {
-      retval.resize (2);
-
       Array<octave_idx_type> sidx;
 
+      // NOTE: Can not change this to ovl() call because arg.sort changes sidx
+      //       and objects are declared const in ovl prototype.
       retval(0) = arg.sort (sidx, dim, smode);
-      retval(1) = idx_vector (sidx, dv(dim)); // No checking, extent is known.
+      retval(1) = idx_vector (sidx, dv(dim));  // No checking, extent is known.
     }
   else
-    retval(0) = arg.sort (dim, smode);
+    retval = ovl (arg.sort (dim, smode));
 
   return retval;
 }
 
 /*
 ## Double
 %!assert (sort ([NaN, 1, -1, 2, Inf]), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 1), [NaN, 1, -1, 2, Inf])
@@ -6875,18 +6868,18 @@ This function does not support sparse ma
 %!assert (issorted (sv, "either"))
 %!assert (issorted (fliplr (sv), "either"))
 %!assert (issorted (sv', "either"))
 %!assert (issorted (fliplr (sv)', "either"))
 
 %!error <needs a vector> issorted ([])
 
 ## Test input validation
-%!error issorted () 
-%!error issorted (1,2,3,4) 
+%!error issorted ()
+%!error issorted (1,2,3,4)
 %!error <second argument must be a string> issorted (1, 2)
 %!error <second argument must be a string> issorted (1, {"rows"})
 %!error <sparse matrices not yet supported> issorted (sparse ([1 2 3]), "rows")
 %!error <A must be a 2-dimensional object> issorted (rand (2,2,2), "rows")
 %!error <needs a vector> issorted (ones (2,2))
 */
 
 DEFUN (nth_element, args, ,
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1207,18 +1207,18 @@ do_dbstack (const octave_value_list& arg
         }
     }
   else
     {
       octave_map stk = octave_call_stack::backtrace (nskip,
                                                      curr_frame,
                                                      false);
 
-      retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
-      retval(0) = stk;
+      retval = ovl (stk,
+                    curr_frame < 0 ? 1 : curr_frame + 1);
     }
 
   return retval;
 }
 
 // A function that can be easily called from a debugger print the Octave
 // stack.  This can be useful for finding what line of code the
 // interpreter is currently executing when the debugger is stopped in
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -118,17 +118,17 @@ directory is not changed.\n\
 calling formats.\n\
 \n\
 Compatibility Note: When called with no arguments, @sc{matlab} prints the\n\
 present working directory rather than changing to the user's home directory.\n\
 @seealso{pwd, mkdir, rmdir, dir, ls}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
- 
+
   if (nargin > 1)
     print_usage ();
 
   octave_value_list retval;
 
   if (nargout > 0)
     retval = octave_value (octave_env::get_current_directory ());
 
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -148,26 +148,25 @@ The eigenvalues returned by @code{eig} a
               fctmp_b = arg_b.float_complex_matrix_value ();
 
               result = FloatEIG (fctmp_a, fctmp_b, nargout > 1);
             }
         }
 
       if (nargout == 0 || nargout == 1)
         {
-          retval(0) = result.eigenvalues ();
+          retval = ovl (result.eigenvalues ());
         }
       else
         {
           // Blame it on Matlab.
 
           FloatComplexDiagMatrix d (result.eigenvalues ());
 
-          retval(1) = d;
-          retval(0) = result.eigenvectors ();
+          retval = ovl (result.eigenvectors (), d);
         }
     }
   else
     {
       EIG result;
 
       if (nargin == 1)
         {
@@ -199,26 +198,25 @@ The eigenvalues returned by @code{eig} a
               ctmp_b = arg_b.complex_matrix_value ();
 
               result = EIG (ctmp_a, ctmp_b, nargout > 1);
             }
         }
 
       if (nargout == 0 || nargout == 1)
         {
-          retval(0) = result.eigenvalues ();
+          retval = ovl (result.eigenvalues ());
         }
       else
         {
           // Blame it on Matlab.
 
           ComplexDiagMatrix d (result.eigenvalues ());
 
-          retval(1) = d;
-          retval(0) = result.eigenvectors ();
+          retval = ovl (result.eigenvectors (), d);
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (eig ([1, 2; 2, 1]), [-1; 3], sqrt (eps))
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -334,31 +334,29 @@ To read a line and return the terminatin
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval(1) = 0;
-  retval(0) = -1;
+  retval = ovl (-1, 0);
 
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.getl (len_arg, err, who);
 
   if (! err)
     {
-      retval(1) = tmp.length ();
-      retval(0) = tmp;
+      retval = ovl (tmp, tmp.length ());
     }
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{str} =} fgets (@var{fid})\n\
@@ -381,31 +379,29 @@ To read a line and discard the terminati
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval(1) = 0.0;
-  retval(0) = -1.0;
+  retval = ovl (-1.0, 0.0);
 
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.gets (len_arg, err, who);
 
   if (! err)
     {
-      retval(1) = tmp.length ();
-      retval(0) = tmp;
+      retval = ovl (tmp, tmp.length ());
     }
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{nlines} =} fskipl (@var{fid})\n\
@@ -622,17 +618,17 @@ However, conversions are currently only 
 \n\
 When opening a new file that does not yet exist, permissions will be set to\n\
 @code{0666 - @var{umask}}.\n\
 @seealso{fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport, umask}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(0) = -1.0;
+  retval = ovl (-1.0);
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   if (nargin == 1)
     {
@@ -645,19 +641,17 @@ When opening a new file that does not ye
 
           if (nargout < 2 && args(0).string_value () == "all")
             return octave_stream_list::open_file_numbers ();
         }
       else
         {
           string_vector tmp = octave_stream_list::get_info (args(0));
 
-          retval(2) = tmp(2);
-          retval(1) = tmp(1);
-          retval(0) = tmp(0);
+          retval = ovl (tmp(0), tmp(1), tmp(2));
 
           return retval;
         }
     }
 
   octave_value mode = (nargin == 2 || nargin == 3)
                       ? args(1) : octave_value ("r");
 
@@ -665,25 +659,23 @@ When opening a new file that does not ye
                       ? args(2) : octave_value ("native");
 
   int fid = -1;
 
   octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
   if (os)
     {
-      retval(1) = "";
-      retval(0) = octave_stream_list::insert (os);
+      retval = ovl (octave_stream_list::insert (os), "");
     }
   else
     {
       int error_number = 0;
 
-      retval(1) = os.error (false, error_number);
-      retval(0) = -1.0;
+      retval = ovl (-1.0, os.error (false, error_number));
     }
 
   return retval;
 }
 
 DEFUN (freport, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} freport ()\n\
@@ -985,19 +977,17 @@ expanded even when the template string i
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
-  retval(2) = -1.0;
-  retval(1) = "unknown error";
-  retval(0) = "";
+  retval = ovl ("", "unknown error", -1.0);
 
   octave_ostrstream *ostr = new octave_ostrstream ();
 
   octave_stream os (ostr);
 
   if (os.is_valid ())
     {
       octave_value fmt_arg = args(0);
@@ -1092,42 +1082,38 @@ complete description of the syntax of th
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (args(1).is_string ())
-        retval = os.oscanf (args(1), who);
+        retval = ovl (os.oscanf (args(1), who));
       else
         error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     {
-      retval(2) = "unknown error";
-      retval(1) = 0.0;
-      retval(0) = Matrix ();
+      retval = ovl (Matrix (), 0.0, "unknown error");
 
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (args(1).is_string ())
         {
           octave_idx_type count = 0;
 
           Array<double> size = (nargin == 3)
             ? args(2).vector_value ()
             : Array<double> (dim_vector (1, 1),
                              lo_ieee_inf_value ());
 
           octave_value tmp = os.scanf (args(1), size, count, who);
 
-          retval(2) = os.error ();
-          retval(1) = count;
-          retval(0) = tmp;
+          retval = ovl (tmp, count, os.error ());
         }
       else
         error ("%s: format must be a string", who.c_str ());
     }
 
   return retval;
 }
 
@@ -1174,29 +1160,26 @@ character to be read is returned in @var
     {
       std::string data = get_sscanf_data (args(0));
 
       octave_stream os = octave_istrstream::create (data);
 
       if (os.is_valid ())
         {
           if (args(1).is_string ())
-            retval = os.oscanf (args(1), who);
+            retval = ovl (os.oscanf (args(1), who));
           else
             error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
       else
         error ("%s: unable to create temporary input buffer", who.c_str ());
     }
   else
     {
-      retval(3) = -1.0;
-      retval(2) = "unknown error";
-      retval(1) = 0.0;
-      retval(0) = Matrix ();
+      retval = ovl (Matrix (), 0.0, "unknown error", -1.0);
 
       std::string data = get_sscanf_data (args(0));
 
       octave_stream os = octave_istrstream::create (data);
 
       if (os.is_valid ())
         {
           if (args(1).is_string ())
@@ -1210,20 +1193,18 @@ character to be read is returned in @var
 
               octave_value tmp = os.scanf (args(1), size, count, who);
 
               // FIXME: is this the right thing to do?
               // Extract error message first, because getting
               // position will clear it.
               std::string errmsg = os.error ();
 
-              retval(3) = (os.eof () ? data.length () : os.tell ()) + 1;
-              retval(2) = errmsg;
-              retval(1) = count;
-              retval(0) = tmp;
+              retval = ovl (tmp, count, errmsg,
+                            (os.eof () ? data.length () : os.tell ()) + 1);
             }
           else
             error ("%s: format TEMPLATE must be a string",
                    who.c_str ());
         }
       else
         error ("%s: unable to create temporary input buffer",
                who.c_str  ());
@@ -1471,18 +1452,17 @@ The optional return value @var{count} co
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 5)
     print_usage ();
 
-  retval(1) = -1.0;
-  retval(0) = Matrix ();
+  retval = ovl (Matrix (), -1.0);
 
   octave_stream os = octave_stream_list::lookup (args(0), "fread");
 
   octave_value size = lo_ieee_inf_value ();
   octave_value prec = "uchar";
   octave_value skip = 0;
   octave_value arch = "unknown";
 
@@ -1504,18 +1484,17 @@ The optional return value @var{count} co
       arch = skip;
       skip = 0;
     }
 
   octave_idx_type count = -1;
 
   octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
-  retval(1) = count;
-  retval(0) = tmp;
+  retval = ovl (tmp, count);
 
   return retval;
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
@@ -1665,18 +1644,17 @@ whether the next operation will result i
 
       clear = (opt == "clear");
     }
 
   int error_number = 0;
 
   std::string error_message = os.error (clear, error_number);
 
-  retval(1) = error_number;
-  retval(0) = error_message;
+  retval = ovl (error_message, error_number);
 
   return retval;
 }
 
 DEFUNX ("popen", Fpopen, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.\n\
@@ -1858,39 +1836,37 @@ system-dependent error message.\n\
 @seealso{tempname, mkstemp, tempdir, P_tmpdir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () != 0)
     print_usage ();
 
-  retval(1) = std::string ();
-  retval(0) = -1;
+  retval = ovl (-1, std::string ());
 
   FILE *fid = gnulib::tmpfile ();
 
   if (fid)
     {
       std::string nm;
 
       std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
       octave_stream s = octave_stdiostream::create (nm, fid, md);
 
       if (s)
-        retval(0) = octave_stream_list::insert (s);
+        retval = ovl (octave_stream_list::insert (s));
       else
         error ("tmpfile: failed to create octave_stdiostream object");
 
     }
   else
     {
-      retval(1) = gnulib::strerror (errno);
-      retval(0) = -1;
+      retval = ovl (-1, gnulib::strerror (errno));
     }
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\")\n\
@@ -1909,68 +1885,62 @@ If the optional argument @var{delete} is
 be deleted automatically when Octave exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of the\n\
 file, and @var{msg} is an empty string.  Otherwise, @var{fid} is -1,\n\
 @var{name} is empty, and @var{msg} contains a system-dependent error message.\n\
 @seealso{tempname, tempdir, P_tmpdir, tmpfile, fopen}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval(2) = std::string ();
-  retval(1) = std::string ();
-  retval(0) = -1;
+  std::string tmpl8 = args(0).xstring_value ("mkstemp: TEMPLATE argument must be a string");
 
-  std::string tmpl8 = args(0).xstring_value ("mkstemp: TEMPLATE argument must be a string");
+  octave_value_list retval = ovl (-1, "", "");
 
   OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
   strcpy (tmp, tmpl8.c_str ());
 
   int fd = gnulib::mkostemp (tmp, O_BINARY);
 
   if (fd < 0)
     {
+      retval(0) = fd;
       retval(2) = gnulib::strerror (errno);
-      retval(0) = fd;
     }
   else
     {
       const char *fopen_mode = "w+b";
 
       FILE *fid = fdopen (fd, fopen_mode);
 
-      if (fid)
+      if (! fid)
+        {
+          retval(0) = -1;
+          retval(2) = gnulib::strerror (errno);
+        }
+      else
         {
           std::string nm = tmp;
 
           std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
 
           octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-          if (s)
-            {
-              retval(1) = nm;
-              retval(0) = octave_stream_list::insert (s);
+          if (! s)
+            error ("mkstemp: failed to create octave_stdiostream object");
 
-              if (nargin == 2 && args(1).is_true ())
-                mark_for_deletion (nm);
-            }
-          else
-            error ("mkstemp: failed to create octave_stdiostream object");
-        }
-      else
-        {
-          retval(2) = gnulib::strerror (errno);
-          retval(0) = -1;
+          retval(0) = octave_stream_list::insert (s);
+          retval(1) = nm;
+
+          if (nargin == 2 && args(1).is_true ())
+            mark_for_deletion (nm);
         }
     }
 
   return retval;
 }
 
 // FIXME: This routine also exists verbatim in syscalls.cc.
 //        Maybe change to be a general utility routine.
@@ -2038,17 +2008,17 @@ for the new object are @code{@var{mode} 
   else
     {
       int oct_mask = convert (mask, 8, 10);
 
       status = convert (octave_umask (oct_mask), 10, 8);
     }
 
   if (status >= 0)
-    retval(0) = status;
+    retval = ovl (status);
 
   return retval;
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args, int val)
 {
   if (args.length () != 0)
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -49,20 +49,20 @@ mk_gr_map (const octave_group& gr)
     {
       octave_scalar_map m;
 
       m.assign ("name", gr.name ());
       m.assign ("passwd", gr.passwd ());
       m.assign ("gid", static_cast<double> (gr.gid ()));
       m.assign ("mem", octave_value (gr.mem ()));
 
-      retval = m;
+      retval = ovl (m);
     }
   else
-    retval = 0;
+    retval = ovl (0);
 
   return retval;
 }
 
 DEFUN (getgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
@@ -76,18 +76,17 @@ Once the end of data has been reached, @
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::getgrent may set msg.
   octave_value val = mk_gr_map (octave_group::getgrent (msg));
 
-  retval(1) = msg;
-  retval(0) = val;
+  retval = ovl (val, msg);
 
   return retval;
 }
 
 DEFUN (getgrgid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
@@ -108,18 +107,17 @@ If the group ID does not exist in the da
     {
       gid_t gid = static_cast<gid_t> (dval);
 
       std::string msg;
 
       // octave_group::getgrgid may set msg.
       octave_value val = mk_gr_map (octave_group::getgrgid (gid, msg));
 
-      retval(1) = msg;
-      retval(0) = val;
+      retval = ovl (val, msg);
     }
 
   else
     error ("getgrgid: GID must be an integer");
 
   return retval;
 }
 
@@ -140,18 +138,17 @@ If the group name does not exist in the 
 
   std::string s = args(0).string_value ();
 
   std::string msg;
 
   // octave_group::getgrnam may set msg.
   octave_value val = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
 
-  retval(1) = msg;
-  retval(0) = val;
+  retval = ovl (val, msg);
 
   return retval;
 }
 
 DEFUN (setgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
@@ -163,18 +160,17 @@ Return the internal pointer to the begin
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::setgrent may set msg.
   int status = octave_group::setgrent (msg);
 
-  retval(1) = msg;
-  retval(0) = static_cast<double> (status);
+  retval = ovl (static_cast<double> (status), msg);
 
   return retval;
 }
 
 DEFUN (endgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} endgrent ()\n\
 Close the group database.\n\
@@ -186,13 +182,12 @@ Close the group database.\n\
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_group::endgrent may set msg.
   int status = octave_group::endgrent (msg);
 
-  retval(1) = msg;
-  retval(0) = static_cast<double> (status);
+  retval = ovl (static_cast<double> (status), msg);
 
   return retval;
 }
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -52,20 +52,20 @@ mk_pw_map (const octave_passwd& pw)
       m.assign ("name", pw.name ());
       m.assign ("passwd", pw.passwd ());
       m.assign ("uid", static_cast<double> (pw.uid ()));
       m.assign ("gid", static_cast<double> (pw.gid ()));
       m.assign ("gecos", pw.gecos ());
       m.assign ("dir", pw.dir ());
       m.assign ("shell", pw.shell ());
 
-      retval = m;
+      retval = ovl (m);
     }
   else
-    retval = 0;
+    retval = ovl (0);
 
   return retval;
 }
 
 DEFUN (getpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
@@ -80,18 +80,17 @@ Once the end of the data has been reache
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::getpwent may set msg.
   octave_value val = mk_pw_map (octave_passwd::getpwent (msg));
 
-  retval(1) = msg;
-  retval(0) = val;
+  retval = ovl (val, msg);
 
   return retval;
 }
 
 DEFUN (getpwuid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
@@ -112,18 +111,17 @@ If the user ID does not exist in the dat
     {
       uid_t uid = static_cast<uid_t> (dval);
 
       std::string msg;
 
       // octave_passwd::getpwuid may set msg.
       octave_value val = mk_pw_map (octave_passwd::getpwuid (uid, msg));
 
-      retval(1) = msg;
-      retval(0) = val;
+      retval = ovl (val, msg);
     }
   else
     error ("getpwuid: UID must be an integer");
 
   return retval;
 }
 
 DEFUN (getpwnam, args, ,
@@ -143,18 +141,17 @@ If the user name does not exist in the d
 
   std::string s = args(0).string_value ();
 
   std::string msg;
 
   // octave_passwd::getpwnam may set msg.
   octave_value val = mk_pw_map (octave_passwd::getpwnam (s, msg));
 
-  retval(1) = msg;
-  retval(0) = val;
+  retval = ovl (val, msg);
 
   return retval;
 }
 
 DEFUN (setpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
@@ -166,18 +163,17 @@ Return the internal pointer to the begin
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::setpwent may set msg.
   int status = octave_passwd::setpwent (msg);
 
-  retval(1) = msg;
-  retval(0) = static_cast<double> (status);
+  retval = ovl (static_cast<double> (status), msg);
 
   return retval;
 }
 
 DEFUN (endpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} endpwent ()\n\
 Close the password database.\n\
@@ -189,13 +185,12 @@ Close the password database.\n\
   if (args.length () != 0)
     print_usage ();
 
   std::string msg;
 
   // octave_passwd::endpwent may set msg.
   int status = octave_passwd::endpwent (msg);
 
-  retval(1) = msg;
-  retval(0) = static_cast<double> (status);
+  retval = ovl (static_cast<double> (status), msg);
 
   return retval;
 }
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -87,42 +87,40 @@ givens (1, 1)\n\
           FloatComplex cy = args(1).float_complex_value ();
 
           FloatComplexMatrix result = Givens (cx, cy);
 
           switch (nargout)
             {
             case 0:
             case 1:
-              retval(0) = result;
+              retval = ovl (result);
               break;
 
             case 2:
-              retval(1) = result (0, 1);
-              retval(0) = result (0, 0);
+              retval = ovl (result(0, 0), result(0, 1));
               break;
             }
         }
       else
         {
           float x = args(0).float_value ();
           float y = args(1).float_value ();
 
           FloatMatrix result = Givens (x, y);
 
           switch (nargout)
             {
             case 0:
             case 1:
-              retval(0) = result;
+              retval = ovl (result);
               break;
 
             case 2:
-              retval(1) = result (0, 1);
-              retval(0) = result (0, 0);
+              retval = ovl (result(0, 0), result(0, 1));
               break;
             }
         }
     }
   else
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
@@ -130,42 +128,40 @@ givens (1, 1)\n\
           Complex cy = args(1).complex_value ();
 
           ComplexMatrix result = Givens (cx, cy);
 
           switch (nargout)
             {
             case 0:
             case 1:
-              retval(0) = result;
+              retval = ovl (result);
               break;
 
             case 2:
-              retval(1) = result (0, 1);
-              retval(0) = result (0, 0);
+              retval = ovl (result(0, 0), result(0, 1));
               break;
             }
         }
       else
         {
           double x = args(0).double_value ();
           double y = args(1).double_value ();
 
           Matrix result = Givens (x, y);
 
           switch (nargout)
             {
             case 0:
             case 1:
-              retval(0) = result;
+              retval = ovl (result);
               break;
 
             case 2:
-              retval(1) = result (0, 1);
-              retval(0) = result (0, 0);
+              retval = ovl (result(0, 0), result(0, 1));
               break;
             }
         }
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1096,18 +1096,17 @@ The format is a string which is one of @
 
   const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
 
   std::string text;
   std::string format;
 
   do_get_help_text (name, text, format);
 
-  retval(1) = format;
-  retval(0) = text;
+  retval = ovl (text, format);
 
   return retval;
 }
 
 static void
 do_get_help_text_from_file (const std::string& fname, std::string& text,
                             std::string& format)
 {
@@ -1159,18 +1158,17 @@ The format is a string which is one of @
 
   const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
 
   std::string text;
   std::string format;
 
   do_get_help_text_from_file (fname, text, format);
 
-  retval(1) = format;
-  retval(0) = text;
+  retval = ovl (text, format);
 
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
 // operators.
 
 DEFUN (__operators__, , ,
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -91,66 +91,66 @@ IEEE Transactions on Automatic Control, 
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           FloatHESS result (tmp);
 
           if (nargout <= 1)
-            retval(0) = result.hess_matrix ();
+            retval = ovl (result.hess_matrix ());
           else
             {
-              retval(1) = result.hess_matrix ();
-              retval(0) = result.unitary_hess_matrix ();
+              retval = ovl (result.unitary_hess_matrix (),
+                            result.hess_matrix ());
             }
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           FloatComplexHESS result (ctmp);
 
           if (nargout <= 1)
-            retval(0) = result.hess_matrix ();
+            retval = ovl (result.hess_matrix ());
           else
             {
-              retval(1) = result.hess_matrix ();
-              retval(0) = result.unitary_hess_matrix ();
+              retval = ovl (result.unitary_hess_matrix (),
+                            result.hess_matrix ());
             }
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           Matrix tmp = arg.matrix_value ();
 
           HESS result (tmp);
 
           if (nargout <= 1)
-            retval(0) = result.hess_matrix ();
+            retval = ovl (result.hess_matrix ());
           else
             {
-              retval(1) = result.hess_matrix ();
-              retval(0) = result.unitary_hess_matrix ();
+              retval = ovl (result.unitary_hess_matrix (),
+                            result.hess_matrix ());
             }
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           ComplexHESS result (ctmp);
 
           if (nargout <= 1)
-            retval(0) = result.hess_matrix ();
+            retval = ovl (result.hess_matrix ());
           else
             {
-              retval(1) = result.hess_matrix ();
-              retval(0) = result.unitary_hess_matrix ();
+              retval = ovl (result.unitary_hess_matrix (),
+                            result.hess_matrix ());
             }
         }
       else
         {
           gripe_wrong_type_arg ("hess", arg);
         }
     }
 
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -93,48 +93,44 @@ On exit, @var{y} is a unit vector such t
     {
       if (iscomplex)
         {
           FloatComplexColumnVector x
             = arg_x.float_complex_column_vector_value ();
           FloatComplexMatrix V = arg_v.float_complex_matrix_value ();
           FloatComplexRowVector h;
           do_mgorth (x, V, h);
-          retval(1) = h;
-          retval(0) = x;
+          retval = ovl (x, h);
         }
       else
         {
           FloatColumnVector x = arg_x.float_column_vector_value ();
           FloatMatrix V = arg_v.float_matrix_value ();
           FloatRowVector h;
           do_mgorth (x, V, h);
-          retval(1) = h;
-          retval(0) = x;
+          retval = ovl (x, h);
         }
     }
   else
     {
       if (iscomplex)
         {
           ComplexColumnVector x = arg_x.complex_column_vector_value ();
           ComplexMatrix V = arg_v.complex_matrix_value ();
           ComplexRowVector h;
           do_mgorth (x, V, h);
-          retval(1) = h;
-          retval(0) = x;
+          retval = ovl (x, h);
         }
       else
         {
           ColumnVector x = arg_x.column_vector_value ();
           Matrix V = arg_v.matrix_value ();
           RowVector h;
           do_mgorth (x, V, h);
-          retval(1) = h;
-          retval(0) = x;
+          retval = ovl (x, h);
         }
     }
 
   return retval;
 }
 
 /*
 %!test
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -301,20 +301,17 @@ variable by routines @code{dblquad} and 
             }
           break;
 
         default:
           panic_impossible ();
           break;
         }
 
-      retval(3) = abserr;
-      retval(2) = nfun;
-      retval(1) = ier;
-      retval(0) = val;
+      retval = ovl (val, ier, nfun, abserr);
 
     }
   else
     {
       double a = args(1).xdouble_value ("quad: lower limit of integration A must be a scalar");
       double b = args(2).xdouble_value ("quad: upper limit of integration B must be a scalar");
 
       int indefinite = 0;
@@ -396,20 +393,17 @@ variable by routines @code{dblquad} and 
             }
           break;
 
         default:
           panic_impossible ();
           break;
         }
 
-      retval(3) = abserr;
-      retval(2) = nfun;
-      retval(1) = ier;
-      retval(0) = val;
+      retval = ovl (val, ier, nfun, abserr);
     }
 
   if (fcn_name.length ())
     clear_function (fcn_name);
 
   return retval;
 }
 
