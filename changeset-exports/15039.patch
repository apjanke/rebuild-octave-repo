# HG changeset patch
# User Rik <rik@octave.org>
# Date 1343428500 25200
#      Fri Jul 27 15:35:00 2012 -0700
# Node ID e753177cde93e958d72dd9a1e7acb458d62469c2
# Parent  ab18578c2ade283b9c1c0924451f8d9c0fd90911
maint: Move non-dynamically linked functions from DLD-FUNCTIONS/ to corefcn/ directory

* __contourc__.cc, __dispatch__.cc, __lin_interpn__.cc, __pchip_deriv__.cc,
__qp__.cc, balance.cc, besselj.cc, betainc.cc, bsxfun.cc, cellfun.cc,
colloc.cc, conv2.cc, daspk.cc, dasrt.cc, dassl.cc, det.cc, dlmread.cc, dot.cc,
eig.cc, fft.cc, fft2.cc, fftn.cc, filter.cc, find.cc, gammainc.cc, gcd.cc,
getgrent.cc, getpwent.cc, getrusage.cc, givens.cc, hess.cc, hex2num.cc, inv.cc,
kron.cc, lookup.cc, lsode.cc, lu.cc, luinc.cc, matrix_type.cc, max.cc,
md5sum.cc, mgorth.cc,  nproc.cc, pinv.cc, quad.cc, quadcc.cc, qz.cc,
rand.cc, rcond.cc, regexp.cc, schur.cc, spparms.cc, sqrtm.cc, str2double.cc,
strfind.cc, sub2ind.cc, svd.cc, syl.cc, time.cc, tril.cc, typecast.cc:
Move functions from DLD-FUNCTIONS/ to corefcn/ directory.  Include "defun.h",
not "defun-dld.h".  Change docstring to refer to these as "Built-in Functions".

* build-aux/mk-opts.pl: Generate options code with '#include "defun.h"'.  Change
option docstrings to refer to these as "Built-in Functions".

* corefcn/module.mk: List of functions to build in corefcn/ dir.

* DLD-FUNCTIONS/config-module.awk: Update to new build system.

* DLD-FUNCTIONS/module-files: Remove functions which are now in corefcn/ directory.

* src/Makefile.am: Update to build "convenience library" in corefcn/.  Octave
program now links against all other libraries + corefcn libary.

* src/find-defun-files.sh: Strip $srcdir from filename.

* src/link-deps.mk: Add REGEX and FFTW link dependencies for liboctinterp.

* type.m, which.m: Change failing tests to use 'amd', still a dynamic function,
rather than 'dot', which isn't.

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -508,17 +508,17 @@ sub emit_opt_handler_fcns
 #include <config.h>
 #endif
 
 #include <iomanip>
 #include <iostream>
 
 #include "$header"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "pr-output.h"
 
 #include "oct-obj.h"
 #include "utils.h"
 #include "pager.h"
 
 static $CLASS_NAME $STATIC_OBJECT_NAME;
 
@@ -904,21 +904,21 @@ show_$CLASS_NAME (const std::string& key
     }
 
   return retval;\n}\n\n|;
 }
 
 sub emit_options_function
 {
   print <<"_END_EMIT_OPTIONS_FUNCTION_HDR_";
-DEFUN_DLD ($OPT_FCN_NAME, args, ,
+DEFUN ($OPT_FCN_NAME, args, ,
   "-*- texinfo -*-\\n\\
-\@deftypefn  {Loadable Function} {} $OPT_FCN_NAME ()\\n\\
-\@deftypefnx {Loadable Function} {val =} $OPT_FCN_NAME (\@var{opt})\\n\\
-\@deftypefnx {Loadable Function} {} $OPT_FCN_NAME (\@var{opt}, \@var{val})\\n\\
+\@deftypefn  {Built-in Function} {} $OPT_FCN_NAME ()\\n\\
+\@deftypefnx {Built-in Function} {val =} $OPT_FCN_NAME (\@var{opt})\\n\\
+\@deftypefnx {Built-in Function} {} $OPT_FCN_NAME (\@var{opt}, \@var{val})\\n\\
 $DOC_STRING\\n\\
 \\n\\
 Options include\\n\\
 \\n\\
 \@table \@code\\n\\
 _END_EMIT_OPTIONS_FUNCTION_HDR_
 # FIXME: Add extra newline above
 
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -113,14 +113,14 @@ endfunction
 
 
 %!test
 %! var = 1;
 %! typestr = type ("var");
 %! typestr = typestr{1}(1:17);
 %! assert (typestr, "var is a variable");
 
-%!assert (type ("dot"){1}, "dot is a dynamically-linked function")
+%!assert (type ("amd"){1}, "amd is a dynamically-linked function")
 %!assert (type ("cat"){1}, "cat is a built-in function")
 %!assert (type ("+"){1}, "+ is an operator")
 %!assert (type ("end"){1}, "end is a keyword")
 %!error (type ('NO_NAME'))
  
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -54,13 +54,13 @@ function varargout = which (varargin)
 
 endfunction
 
 
 %!test
 %! str = which ("ls");
 %! assert (str(end-17:end), strcat ("miscellaneous", filesep (), "ls.m"));
 %!test
-%! str = which ("dot");
-%! assert (str(end-6:end), "dot.oct");
+%! str = which ("amd");
+%! assert (str(end-6:end), "amd.oct");
 
 %!assert (which ("_NO_SUCH_NAME_"), "")
 
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -47,17 +47,17 @@ BEGIN {
     print "\t  of=$(<F:.la=.oct) && \\";
     print "\t  cd DLD-FUNCTIONS && \\";
     print "\t  $(LN_S) .libs/`$(SED) -n -e \"s/dlname='\\([^']*\\)'/\\1/p\" < $$la` $$of && \\";
     print "\t  touch $(@F)";
     print "";
   }
   print "else";
   print "";
-  print "noinst_LTLIBRARIES = $(DLD_FUNCTIONS_LIBS)";
+  print "noinst_LTLIBRARIES += $(DLD_FUNCTIONS_LIBS)";
   print "";
   print "endif";
 
   for (i = 1; i <= nfiles; i++) {
     basename = files[i];
     sub (/\.cc$/, "", basename);
     print "";
     printf ("DLD_FUNCTIONS_%s_la_SOURCES = DLD-FUNCTIONS/%s\n",
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -1,83 +1,22 @@
 # FILE|CPPFLAGS|LDFLAGS|LIBRARIES
-__contourc__.cc
+chol.cc
 __delaunayn__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
-__dispatch__.cc
 __dsearchn__.cc
 __fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
 __init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __init_gnuplot__.cc
-__lin_interpn__.cc
 __magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
-__pchip_deriv__.cc
-__qp__.cc
 __voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-balance.cc
-besselj.cc
-betainc.cc
-bsxfun.cc
 ccolamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-cellfun.cc
-chol.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-colloc.cc
-conv2.cc
 convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
-daspk.cc
-dasrt.cc
-dassl.cc
-det.cc
-dlmread.cc
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-dot.cc
-eig.cc
 eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
-fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-filter.cc
-find.cc
-gammainc.cc
-gcd.cc
-getgrent.cc
-getpwent.cc
-getrusage.cc
-givens.cc
-hess.cc
-hex2num.cc
-inv.cc
-kron.cc
-lookup.cc
-lsode.cc
-lu.cc
-luinc.cc
-matrix_type.cc
-max.cc
-md5sum.cc
-mgorth.cc
-nproc.cc
-pinv.cc
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
-quad.cc
-quadcc.cc
-qz.cc|||$(LAPACK_LIBS) $(BLAS_LIBS)
-rand.cc
-rcond.cc
-regexp.cc|$(REGEX_CPPFLAGS)|$(REGEX_LDFLAGS)|$(REGEX_LIBS)
-schur.cc
-spparms.cc
-sqrtm.cc
-strfind.cc
-str2double.cc
-sub2ind.cc
-svd.cc
-syl.cc
 symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-time.cc
-tril.cc
 tsearch.cc
-typecast.cc
 urlwrite.cc|$(CURL_CPPFLAGS)|$(CURL_LDFLAGS)|$(CURL_LIBS)
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -20,16 +20,17 @@
 
 include $(top_srcdir)/build-aux/common.mk
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I../libgnu -I$(top_srcdir)/libgnu \
   -I$(top_srcdir)/libcruft/misc \
   -I../liboctave -I$(top_srcdir)/liboctave \
+  -Icorefcn -I$(srcdir)/corefcn \
   -I. -I$(srcdir) \
   @CPPFLAGS@
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 octlib_LTLIBRARIES = liboctinterp.la
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
@@ -39,17 +40,17 @@ bin_PROGRAMS = \
   octave-config
 
 mkoctfile_SOURCES =
 nodist_mkoctfile_SOURCES = mkoctfile.cc
 mkoctfile_LDADD = ../libgnu/libgnu.la $(LIBS)
 
 octave_config_SOURCES =
 nodist_octave_config_SOURCES = octave-config.cc
-octave_config_LDADD = ../libgnu/libgnu.la $(LIBS)
+octave_config_LDADD = corefcn/libcorefcn.la ../libgnu/libgnu.la $(LIBS)
 
 BUILT_SOURCES_EXTRA = \
   mkoctfile.cc \
   octave-config.cc
 else
 bin_PROGRAMS = \
   octave
 
@@ -410,16 +411,20 @@ PT_SRC = \
   pt.cc
 
 JIT_SRC = \
   jit-util.cc \
   jit-typeinfo.cc \
   jit-ir.cc \
   pt-jit.cc
 
+#noinst_LTLIBRARIES =
+#
+#include corefcn/module.mk
+#
 DIST_SRC = \
   Cell.cc \
   bitfcns.cc \
   c-file-ptr-stream.cc \
   comment-list.cc \
   cutils.c \
   data.cc \
   debug.cc \
@@ -481,20 +486,24 @@ DIST_SRC = \
   unwind-prot.cc \
   utils.cc \
   variables.cc \
   xdiv.cc \
   xgl2ps.c \
   xnorm.cc \
   xpow.cc \
   zfstream.cc \
+  $(corefcn_SRC) \
   $(OV_SRC) \
   $(PT_SRC) \
   $(JIT_SRC)
 
+noinst_LTLIBRARIES =
+
+include corefcn/module.mk
 include DLD-FUNCTIONS/module.mk
 
 $(srcdir)/DLD-FUNCTIONS/module.mk: $(srcdir)/DLD-FUNCTIONS/config-module.sh $(srcdir)/DLD-FUNCTIONS/config-module.awk $(srcdir)/DLD-FUNCTIONS/module-files
 	$(srcdir)/DLD-FUNCTIONS/config-module.sh $(top_srcdir)
 
 include OPERATORS/module.mk
 include TEMPLATE-INST/module.mk
 
@@ -543,16 +552,19 @@ liboctinterp_version_info = $(liboctinte
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTINTERP_LINK_OPTS)
 
 display.df display.lo: CPPFLAGS += $(X11_FLAGS)
 
+## FIXME: Does this rule need to be uncommented?
+#fft.df fft.lo fft2.df fft2.lo fftn.df fftn.lo: CPPFLAGS += $(FFTW_XCPPFLAGS)
+
 octave_SOURCES = main.c
 
 octave_LDADD = \
   liboctinterp.la \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
   $(OCTAVE_LINK_DEPS)
 
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/corefcn/__contourc__.cc
rename from src/DLD-FUNCTIONS/__contourc__.cc
rename to src/corefcn/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/corefcn/__contourc__.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 static Matrix this_contour;
 static Matrix contourc;
 static int elem;
 
 // This is the quanta in which we increase this_contour.
@@ -294,19 +294,19 @@ cntr (const RowVector& X, const RowVecto
     }
 
   for (unsigned int r = 0; r < nr - 1; r++)
     for (unsigned int c = 0; c < nc - 1; c++)
       if (mark (r, c) > 0)
         drawcn (X, Y, Z, lvl, r, c, 0.0, 0.0, 255, true, mark);
 }
 
-DEFUN_DLD (__contourc__, args, ,
+DEFUN (__contourc__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
+@deftypefn {Built-in Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 4)
     {
       RowVector X = args (0).row_vector_value ();
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/corefcn/__dispatch__.cc
rename from src/DLD-FUNCTIONS/__dispatch__.cc
rename to src/corefcn/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/corefcn/__dispatch__.cc
@@ -25,26 +25,26 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <list>
 #include <map>
 #include <string>
 
 #include "Cell.h"
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "ov.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
-DEFUN_DLD (__dispatch__, args, nargout,
+DEFUN (__dispatch__, args, nargout,
   "Undocumented internal function")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   std::string f, r, t;
 
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/corefcn/__lin_interpn__.cc
rename from src/DLD-FUNCTIONS/__lin_interpn__.cc
rename to src/corefcn/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/corefcn/__lin_interpn__.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-ieee.h"
 #include "dNDArray.h"
 #include "oct-locbuf.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // equivalent to isvector.m
 
 template <class T>
 bool
 isvector (const T& array)
@@ -262,19 +262,19 @@ lin_interpn (int n, M *X, const M V, M *
 // @var{x1}, @var{x2}, @dots{}, @var{xn} are either @var{n}-dimensional
 // arrays of the same size as the array @var{v} in the \"ndgrid\" format
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
-DEFUN_DLD (__lin_interpn__, args, ,
+DEFUN (__lin_interpn__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
+@deftypefn {Built-in Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 ||  nargin % 2 == 0)
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/corefcn/__pchip_deriv__.cc
rename from src/DLD-FUNCTIONS/__pchip_deriv__.cc
rename to src/corefcn/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/corefcn/__pchip_deriv__.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
@@ -45,19 +45,19 @@ extern "C"
                            const float *f, float *d,
                            const octave_idx_type& incfd,
                            octave_idx_type *ierr);
 }
 
 // Wrapper for SLATEC/PCHIP function DPCHIM to calculate the derivates
 // for piecewise polynomials.
 
-DEFUN_DLD (__pchip_deriv__, args, ,
+DEFUN (__pchip_deriv__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {Built-in Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
   bool rows = (nargin == 3 && args (2).uint_value () == 2);
 
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/corefcn/__qp__.cc
rename from src/DLD-FUNCTIONS/__qp__.cc
rename to src/corefcn/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/corefcn/__qp__.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <cfloat>
 
 #include "dbleCHOL.h"
 #include "dbleSVD.h"
 #include "mx-m-dm.h"
 #include "EIG.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 
 static Matrix
 null (const Matrix& A, octave_idx_type& rank)
@@ -474,19 +474,19 @@ qp (const Matrix& H, const ColumnVector&
               break;
             }
         }
     }
 
   return info;
 }
 
-DEFUN_DLD (__qp__, args, ,
+DEFUN (__qp__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 8)
     {
       const ColumnVector x0  (args(0) . vector_value ());
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/corefcn/balance.cc
rename from src/DLD-FUNCTIONS/balance.cc
rename to src/corefcn/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/corefcn/balance.cc
@@ -34,30 +34,30 @@ along with Octave; see the file COPYING.
 #include "dbleAEPBAL.h"
 #include "floatAEPBAL.h"
 #include "CmplxGEPBAL.h"
 #include "fCmplxGEPBAL.h"
 #include "dbleGEPBAL.h"
 #include "floatGEPBAL.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (balance, args, nargout,
+DEFUN (balance, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{AA} =} balance (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{AA} =} balance (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
 \n\
 Compute @code{@var{AA} = @var{DD} \\ @var{A} * @var{DD}} in which @var{AA}\n\
 is a matrix whose row and column norms are roughly equal in magnitude, and\n\
 @code{@var{DD} = @var{P} * @var{D}}, in which @var{P} is a permutation\n\
 matrix and @var{D} is a diagonal matrix of powers of two.  This allows the\n\
 equilibration to be computed without round-off.  Results of eigenvalue\n\
 calculation are typically improved by balancing first.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/corefcn/besselj.cc
rename from src/DLD-FUNCTIONS/besselj.cc
rename to src/corefcn/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/corefcn/besselj.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum bessel_type
 {
   BESSEL_J,
@@ -371,23 +371,23 @@ do_bessel (enum bessel_type type, const 
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (besselj, args, nargout,
+DEFUN (besselj, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn  {Built-in Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item bessely\n\
@@ -445,46 +445,46 @@ Complete loss of significance by argumen
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_J, "besselj", args, nargout);
 }
 
-DEFUN_DLD (bessely, args, nargout,
+DEFUN (bessely, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_Y, "bessely", args, nargout);
 }
 
-DEFUN_DLD (besseli, args, nargout,
+DEFUN (besseli, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_I, "besseli", args, nargout);
 }
 
-DEFUN_DLD (besselk, args, nargout,
+DEFUN (besselk, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_K, "besselk", args, nargout);
 }
 
-DEFUN_DLD (besselh, args, nargout,
+DEFUN (besselh, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
@@ -516,19 +516,19 @@ See besselj.\n\
         error ("besselh: invalid value of K");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (airy, args, nargout,
+DEFUN (airy, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/corefcn/betainc.cc
rename from src/DLD-FUNCTIONS/betainc.cc
rename to src/corefcn/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/corefcn/betainc.cc
@@ -21,26 +21,26 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // FIXME: These functions do not need to be dynamically loaded.  They should
 //        be placed elsewhere in the Octave code hierarchy.
 
-DEFUN_DLD (betainc, args, ,
+DEFUN (betainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the regularized incomplete Beta function,\n\
 @tex\n\
 $$\n\
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
@@ -324,17 +324,17 @@ compatible dimensions.\n\
 %! assert (v3, v4, sqrt (eps ("single")));
 
 %!error betainc ()
 %!error betainc (1)
 %!error betainc (1,2)
 %!error betainc (1,2,3,4)
 */
 
-DEFUN_DLD (betaincinv, args, ,
+DEFUN (betaincinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
 Compute the inverse of the incomplete Beta function, i.e., @var{x} such that\n\
 \n\
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b}) \n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/corefcn/bsxfun.cc
rename from src/DLD-FUNCTIONS/bsxfun.cc
rename to src/corefcn/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/corefcn/bsxfun.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <vector>
 #include <list>
 
 #include "lo-mappers.h"
 
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
 #include "ov-fcn-handle.h"
 
 // Optimized bsxfun operations
 enum bsxfun_builtin_op
@@ -304,19 +304,19 @@ update_index (Array<int>& idx, const dim
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
-DEFUN_DLD (bsxfun, args, ,
+DEFUN (bsxfun, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
+@deftypefn {Built-in Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 The binary singleton expansion function applier performs broadcasting,\n\
 that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
 and a scalar.\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/corefcn/cellfun.cc
rename from src/DLD-FUNCTIONS/cellfun.cc
rename to src/corefcn/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/corefcn/cellfun.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include <memory>
 
 #include "caseless-str.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
 #include "ov-class.h"
@@ -244,26 +244,26 @@ get_mapper_fun_options (const octave_val
         }
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
-DEFUN_DLD (cellfun, args, nargout,
+DEFUN (cellfun, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{C})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
-@deftypefnx {Loadable Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
+@deftypefn  {Built-in Function} {} cellfun (@var{name}, @var{C})\n\
+@deftypefnx {Built-in Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
+@deftypefnx {Built-in Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
+@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C})\n\
+@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
+@deftypefnx {Built-in Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
+@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
+@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{C}.  Elements in @var{C} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
@@ -1009,17 +1009,17 @@ v = cellfun (@@det, a); # faster\n\
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
-DEFUN_DLD (arrayfun, args, nargout,
+DEFUN (arrayfun, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})\n\
 @deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"UniformOutput\", @var{val})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
 \n\
@@ -1800,20 +1800,20 @@ do_object2cell (const octave_value& obj,
   else
     {
       error ("num2cell (A, dim) not implemented for class objects");
     }
 
   return retval;
 }
 
-DEFUN_DLD (num2cell, args, ,
+DEFUN (num2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} num2cell (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
+@deftypefn  {Built-in Function} {@var{C} =} num2cell (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
 defined, the value @var{C} is of dimension 1 in this dimension and the\n\
 elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2cell ([1,2;3,4])\n\
    @result{}\n\
@@ -2129,21 +2129,21 @@ do_mat2cell (octave_value& a, const Arra
         break;
 
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
-DEFUN_DLD (mat2cell, args, ,
+DEFUN (mat2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
-@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
+@deftypefn  {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
+@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
 Convert the matrix @var{A} to a cell array.  If @var{A} is 2-D, then\n\
 it is required that @code{sum (@var{m}) == size (@var{A}, 1)} and\n\
 @code{sum (@var{n}) == size (@var{A}, 2)}.  Similarly, if @var{A} is\n\
 multi-dimensional and the number of dimensional arguments is equal\n\
 to the dimensions of @var{A}, then it is required that @code{sum (@var{di})\n\
 == size (@var{A}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
@@ -2299,19 +2299,19 @@ do_cellslices_nda (const NDA& array,
           idx(dim) = idx_vector (lb(i) - 1, ub(i));
           retval(i) = array.index (idx);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (cellslices, args, ,
+DEFUN (cellslices, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
+@deftypefn {Built-in Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
 Given an array @var{x}, this function produces a cell array of slices from\n\
 the array determined by the index vectors @var{lb}, @var{ub}, for lower and\n\
 upper bounds, respectively.  In other words, it is equivalent to the\n\
 following code:\n\
 \n\
 @example\n\
 @group\n\
 n = length (lb);\n\
@@ -2420,19 +2420,19 @@ slicing is done along the first non-sing
 
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
 
-DEFUN_DLD (cellindexmat, args, ,
+DEFUN (cellindexmat, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
+@deftypefn {Built-in Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
 Y = cell (size (X));\n\
 for i = 1:numel (X)\n\
   Y@{i@} = X@{i@}(varargin@{:@});\n\
 endfor\n\
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/corefcn/colloc.cc
rename from src/DLD-FUNCTIONS/colloc.cc
rename to src/corefcn/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/corefcn/colloc.cc
@@ -24,24 +24,24 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 
 #include "CollocWt.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (colloc, args, ,
+DEFUN (colloc, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
+@deftypefn {Built-in Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
 Compute derivative and integral weight matrices for orthogonal\n\
 collocation using the subroutines given in J. Villadsen and\n\
 M. L. Michelsen, @cite{Solution of Differential Equation Models by\n\
 Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/corefcn/conv2.cc
rename from src/DLD-FUNCTIONS/conv2.cc
rename to src/corefcn/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/corefcn/conv2.cc
@@ -22,28 +22,28 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-convn.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
-DEFUN_DLD (conv2, args, ,
+DEFUN (conv2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} conv2 (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
-@deftypefnx {Loadable Function} {} conv2 (@dots{}, @var{shape})\n\
+@deftypefn  {Built-in Function} {} conv2 (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
+@deftypefnx {Built-in Function} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
@@ -278,20 +278,20 @@ When the third argument is a matrix, ret
 %!error conv2 ()
 %!error conv2 (1)
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
-DEFUN_DLD (convn, args, ,
+DEFUN (convn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} convn (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
+@deftypefn  {Built-in Function} {@var{C} =} convn (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/corefcn/daspk.cc
rename from src/DLD-FUNCTIONS/daspk.cc
rename to src/corefcn/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/corefcn/daspk.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASPK.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -165,19 +165,19 @@ daspk_user_jacobian (const ColumnVector&
 #define DASPK_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("daspk: " fmt, arg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (daspk, args, nargout,
+DEFUN (daspk, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/corefcn/dasrt.cc
rename from src/DLD-FUNCTIONS/dasrt.cc
rename to src/corefcn/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/corefcn/dasrt.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 #include <string>
 
 #include "DASRT.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
@@ -201,22 +201,22 @@ dasrt_user_j (const ColumnVector& x, con
 #define DASRT_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
-DEFUN_DLD (dasrt, args, nargout,
+DEFUN (dasrt, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {Built-in Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/corefcn/dassl.cc
rename from src/DLD-FUNCTIONS/dassl.cc
rename to src/corefcn/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/corefcn/dassl.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASSL.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -165,19 +165,19 @@ dassl_user_jacobian (const ColumnVector&
 #define DASSL_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("dassl: " fmt, arg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (dassl, args, nargout,
+DEFUN (dassl, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/corefcn/det.cc
rename from src/DLD-FUNCTIONS/det.cc
rename to src/corefcn/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/corefcn/det.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "DET.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ops.h"
 
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
@@ -42,20 +42,20 @@ along with Octave; see the file COPYING.
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
-DEFUN_DLD (det, args, nargout,
+DEFUN (det, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} det (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
+@deftypefn  {Built-in Function} {} det (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
 Compute the determinant of @var{A}.\n\
 \n\
 Return an estimate of the reciprocal condition number if requested.\n\
 \n\
 Routines from @sc{lapack} are used for full matrices and code from\n\
 @sc{umfpack} is used for sparse matrices.\n\
 \n\
 The determinant should not be used to check a matrix for singularity.\n\
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/corefcn/dlmread.cc
rename from src/DLD-FUNCTIONS/dlmread.cc
rename to src/corefcn/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/corefcn/dlmread.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include <cctype>
 #include <fstream>
 #include <limits>
 
 #include "file-ops.h"
 #include "lo-ieee.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "oct-stream.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 static const octave_idx_type idx_max =  std::numeric_limits<octave_idx_type>::max ();
 
 static bool
@@ -150,23 +150,23 @@ parse_range_spec (const octave_value& ra
       cup = static_cast<octave_idx_type> (range(3));
     }
   else
     stat = false;
 
   return stat;
 }
 
-DEFUN_DLD (dlmread, args, ,
+DEFUN (dlmread, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{data} =} dlmread (@var{file})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
+@deftypefn  {Built-in Function} {@var{data} =} dlmread (@var{file})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
 Read the matrix @var{data} from a text file.  If not defined the separator\n\
 between fields is determined from the file itself.  Otherwise the\n\
 separation character is defined by @var{sep}.\n\
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/corefcn/dot.cc
rename from src/DLD-FUNCTIONS/dot.cc
rename to src/corefcn/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/corefcn/dot.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "f77-fcn.h"
 #include "mx-base.h"
 #include "error.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddot3, DDOT3) (const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const double*,
                            const double*, double*);
@@ -98,19 +98,19 @@ get_red_dims (const dim_vector& x, const
       else
         {
           k = x(i);
           z(i) = 1;
         }
     }
 }
 
-DEFUN_DLD (dot, args, ,
+DEFUN (dot, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {Built-in Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Compute the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first\n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
 This is equivalent to\n\
 @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
 but avoids forming a temporary array and is faster.  When @var{X} and\n\
@@ -244,19 +244,19 @@ but avoids forming a temporary array and
 %! y = [-0.5, 2; 0.5, -2];
 %! assert (dot (x, y), [0 0]);
 
 %!test
 %! x = [1+i, 3-i; 1-i, 3-i];
 %! assert (dot (x, x), [4, 20]);
 */
 
-DEFUN_DLD (blkmm, args, ,
+DEFUN (blkmm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} blkmm (@var{A}, @var{B})\n\
+@deftypefn {Built-in Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/corefcn/eig.cc
rename from src/DLD-FUNCTIONS/eig.cc
rename to src/corefcn/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/corefcn/eig.cc
@@ -22,28 +22,28 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "EIG.h"
 #include "fEIG.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (eig, args, nargout,
+DEFUN (eig, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{lambda} =} eig (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
+@deftypefn  {Built-in Function} {@var{lambda} =} eig (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
 Compute the eigenvalues (and optionally the eigenvectors) of a matrix\n\
 or a pair of matrices\n\
 \n\
 The algorithm used depends on whether there are one or two input\n\
 matrices, if they are real or complex and if they are symmetric\n\
 (Hermitian if complex) or nonsymmetric.\n\
 \n\
 The eigenvalues returned by @code{eig} are not ordered.\n\
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/corefcn/fft.cc
rename from src/DLD-FUNCTIONS/fft.cc
rename to src/corefcn/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/corefcn/fft.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 #if defined (HAVE_FFTW)
 #define FFTSRC "@sc{fftw}"
 #else
@@ -192,21 +192,21 @@ do_fft (const octave_value_list &args, c
 %!assert (fft (single (1)), single (1))
 %!assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
 %!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
 %!error (fft ())
 */
 
 
-DEFUN_DLD (fft, args, ,
+DEFUN (fft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fft (@var{x})\n\
-@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {Built-in Function} {} fft (@var{x})\n\
+@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
 Compute the discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The FFT is calculated along the first non-singleton dimension of the\n\
 array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes the\n\
 FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
@@ -221,21 +221,21 @@ If called with three arguments, @var{dim
 dimension of the matrix along which the FFT is performed\n\
 @seealso{ifft, fft2, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
-DEFUN_DLD (ifft, args, ,
+DEFUN (ifft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifft (@var{x})\n\
-@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {Built-in Function} {} ifft (@var{x})\n\
+@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
 Compute the inverse discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The inverse FFT is calculated along the first non-singleton dimension\n\
 of the array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes\n\
 the inverse FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/corefcn/fft2.cc
rename from src/DLD-FUNCTIONS/fft2.cc
rename to src/corefcn/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/corefcn/fft2.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
@@ -162,20 +162,20 @@ do_fft2 (const octave_value_list &args, 
         {
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (fft2, args, ,
+DEFUN (fft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fft2 (@var{A})\n\
-@deftypefnx {Loadable Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {Built-in Function} {} fft2 (@var{A})\n\
+@deftypefnx {Built-in Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the two-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
@@ -183,20 +183,20 @@ If @var{A} is a multi-dimensional matrix
 of @var{A} is treated separately.\n\
 @seealso {ifft2, fft, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
-DEFUN_DLD (ifft2, args, ,
+DEFUN (ifft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifft2 (@var{A})\n\
-@deftypefnx {Loadable Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {Built-in Function} {} ifft2 (@var{A})\n\
+@deftypefnx {Built-in Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the inverse two-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/corefcn/fftn.cc
rename from src/DLD-FUNCTIONS/fftn.cc
rename to src/corefcn/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/corefcn/fftn.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
@@ -144,39 +144,39 @@ do_fftn (const octave_value_list &args, 
         {
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (fftn, args, ,
+DEFUN (fftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fftn (@var{A})\n\
-@deftypefnx {Loadable Function} {} fftn (@var{A}, @var{size})\n\
+@deftypefn  {Built-in Function} {} fftn (@var{A})\n\
+@deftypefnx {Built-in Function} {} fftn (@var{A}, @var{size})\n\
 Compute the N-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
 @var{A} is truncated prior to performing the FFT@.  Otherwise, if an element\n\
 of @var{size} is larger than the corresponding dimension then @var{A}\n\
 is resized and padded with zeros.\n\
 @seealso{ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
-DEFUN_DLD (ifftn, args, ,
+DEFUN (ifftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifftn (@var{A})\n\
-@deftypefnx {Loadable Function} {} ifftn (@var{A}, @var{size})\n\
+@deftypefn  {Built-in Function} {} ifftn (@var{A})\n\
+@deftypefnx {Built-in Function} {} ifftn (@var{A}, @var{size})\n\
 Compute the inverse N-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
 @var{A} is truncated prior to performing the inverse FFT@.  Otherwise, if an\n\
 element of @var{size} is larger than the corresponding dimension then @var{A}\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/corefcn/filter.cc
rename from src/DLD-FUNCTIONS/filter.cc
rename to src/corefcn/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/corefcn/filter.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 // jwe, Wed Nov  1 19:15:29 1995.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&, int dim);
 
 extern MArray<Complex>
@@ -280,22 +280,22 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
 
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
-DEFUN_DLD (filter, args, nargout,
+DEFUN (filter, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
+@deftypefn  {Built-in Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Return the solution to the following linear, time-invariant difference\n\
 equation:\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/corefcn/find.cc
rename from src/DLD-FUNCTIONS/find.cc
rename to src/corefcn/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/corefcn/find.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 // Find at most N_TO_FIND nonzero elements in NDA.  Search forward if
 // DIRECTION is 1, backward if it is -1.  NARGOUT is the number of
 // output arguments.  If N_TO_FIND is -1, find all nonzero elements.
 
@@ -327,23 +327,23 @@ find_nonzero_elem_idx (const PermMatrix&
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-DEFUN_DLD (find, args, nargout,
+DEFUN (find, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} find (@var{x})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
-@deftypefnx {Loadable Function} {[i, j] =} find (@dots{})\n\
-@deftypefnx {Loadable Function} {[i, j, v] =} find (@dots{})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} find (@var{x})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
+@deftypefnx {Built-in Function} {[i, j] =} find (@dots{})\n\
+@deftypefnx {Built-in Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
 for each matrix element, Octave pretends that the columns of a matrix form\n\
 one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/corefcn/gammainc.cc
rename from src/DLD-FUNCTIONS/gammainc.cc
rename to src/corefcn/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/corefcn/gammainc.cc
@@ -21,23 +21,23 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (gammainc, args, ,
+DEFUN (gammainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
 Compute the normalized incomplete gamma function,\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {1 \\over {\\Gamma (a)}}\\displaystyle{\\int_0^x t^{a-1} e^{-t} dt}\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/corefcn/gcd.cc
rename from src/DLD-FUNCTIONS/gcd.cc
rename to src/corefcn/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/corefcn/gcd.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "fNDArray.h"
 #include "fCNDArray.h"
 #include "lo-mappers.h"
 #include "oct-binmap.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 static double
 simple_gcd (double a, double b)
 {
   if (! xisinteger (a) || ! xisinteger (b))
     (*current_liboctave_error_handler)
@@ -427,20 +427,20 @@ do_extended_gcd (const octave_value& a, 
       retval = retval.float_array_value ();
       x = x.float_array_value ();
       y = y.float_array_value ();
     }
 
   return retval;
 }
 
-DEFUN_DLD (gcd, args, nargout,
+DEFUN (gcd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefnx {Built-in Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
 In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
 units (multiplication by 1, -1, @var{i} or -@var{i}), so an arbitrary\n\
 greatest common divisor amongst four possible is returned.\n\
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/corefcn/getgrent.cc
rename from src/DLD-FUNCTIONS/getgrent.cc
rename to src/corefcn/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/corefcn/getgrent.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-group.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Group file functions.  (Why not?)
@@ -57,19 +57,19 @@ mk_gr_map (const octave_group& gr)
       retval = m;
     }
   else
     retval = 0;
 
   return retval;
 }
 
-DEFUN_DLD (getgrent, args, ,
+DEFUN (getgrent, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = 0;
@@ -84,19 +84,19 @@ Once the end of data has been reached, @
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getgrgid, args, ,
+DEFUN (getgrgid, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.  If the group ID does not exist in the database,\n\
 @code{getgrgid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -124,19 +124,19 @@ Return the first entry from the group da
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getgrnam, args, ,
+DEFUN (getgrnam, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.  If the group name does not exist in the database,\n\
 @code{getgrnam} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -157,19 +157,19 @@ Return the first entry from the group da
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (setgrent, args, ,
+DEFUN (setgrent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} setgrent ()\n\
+@deftypefn {Built-in Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
@@ -183,19 +183,19 @@ Return the internal pointer to the begin
       retval(0) = static_cast<double> (octave_group::setgrent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (endgrent, args, ,
+DEFUN (endgrent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} endgrent ()\n\
+@deftypefn {Built-in Function} {} endgrent ()\n\
 Close the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/corefcn/getpwent.cc
rename from src/DLD-FUNCTIONS/getpwent.cc
rename to src/corefcn/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/corefcn/getpwent.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-passwd.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Password file functions.  (Why not?)
@@ -60,19 +60,19 @@ mk_pw_map (const octave_passwd& pw)
       retval = m;
     }
   else
     retval = 0;
 
   return retval;
 }
 
-DEFUN_DLD (getpwent, args, ,
+DEFUN (getpwent, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwent ()\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary.  Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -88,19 +88,19 @@ opening it if necessary.  Once the end o
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getpwuid, args, ,
+DEFUN (getpwuid, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.  If the user ID does not exist in the\n\
 database, @code{getpwuid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -128,19 +128,19 @@ database, @code{getpwuid} returns 0.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getpwnam, args, ,
+DEFUN (getpwnam, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.  If the user name does not exist in the\n\
 database, @code{getpwname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -161,19 +161,19 @@ database, @code{getpwname} returns 0.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (setpwent, args, ,
+DEFUN (setpwent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} setpwent ()\n\
+@deftypefn {Built-in Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
@@ -187,19 +187,19 @@ Return the internal pointer to the begin
       retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (endpwent, args, ,
+DEFUN (endpwent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} endpwent ()\n\
+@deftypefn {Built-in Function} {} endpwent ()\n\
 Close the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/corefcn/getrusage.cc
rename from src/DLD-FUNCTIONS/getrusage.cc
rename to src/corefcn/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/corefcn/getrusage.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
 
 #if defined (HAVE_SYS_PARAM_H)
 #include <sys/param.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "oct-map.h"
 #include "sysdep.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 #if !defined (HZ)
 #if defined (CLK_TCK)
@@ -54,19 +54,19 @@ along with Octave; see the file COPYING.
 #endif
 
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
-DEFUN_DLD (getrusage, , ,
+DEFUN (getrusage, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} getrusage ()\n\
+@deftypefn {Built-in Function} {} getrusage ()\n\
 Return a structure containing a number of statistics about the current\n\
 Octave process.  Not all fields are available on all systems.  If it is\n\
 not possible to get CPU time statistics, the CPU time slots are set to\n\
 zero.  Other missing data are replaced by NaN@.  The list of possible\n\
 fields is:\n\
 \n\
 @table @code\n\
 @item idrss\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/corefcn/givens.cc
rename from src/DLD-FUNCTIONS/givens.cc
rename to src/corefcn/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/corefcn/givens.cc
@@ -21,24 +21,24 @@ along with Octave; see the file COPYING.
 */
 
 // Originally written by A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
-DEFUN_DLD (givens, args, nargout,
+DEFUN (givens, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{g} =} givens (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {@var{g} =} givens (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
 @tex\n\
 Return a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
 $$\n\
  G \\left[\\matrix{x\\cr y}\\right] = \\left[\\matrix{\\ast\\cr 0}\\right]\n\
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/corefcn/hess.cc
rename from src/DLD-FUNCTIONS/hess.cc
rename to src/corefcn/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/corefcn/hess.cc
@@ -24,26 +24,26 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "CmplxHESS.h"
 #include "dbleHESS.h"
 #include "fCmplxHESS.h"
 #include "floatHESS.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (hess, args, nargout,
+DEFUN (hess, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{H} =} hess (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{H} =} hess (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{A}.\n\
 \n\
 The Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/corefcn/hex2num.cc
rename from src/DLD-FUNCTIONS/hex2num.cc
rename to src/corefcn/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/corefcn/hex2num.cc
@@ -21,25 +21,25 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (hex2num, args, ,
+DEFUN (hex2num, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} hex2num (@var{s})\n\
+@deftypefn {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
@@ -117,19 +117,19 @@ hex2num ([\"4005bf0a8b145769\"; \"402400
 
   return retval;
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 */
 
-DEFUN_DLD (num2hex, args, ,
+DEFUN (num2hex, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
+@deftypefn {Built-in Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2hex ([-1, 1, e, Inf, NaN, NA])\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/corefcn/inv.cc
rename from src/DLD-FUNCTIONS/inv.cc
rename to src/corefcn/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/corefcn/inv.cc
@@ -19,32 +19,32 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
-DEFUN_DLD (inv, args, nargout,
+DEFUN (inv, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{x} =} inv (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{x} =} inv (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
 In general it is best to avoid calculating the inverse of a matrix\n\
 directly.  For example, it is both faster and more accurate to solve\n\
 systems of equations (@var{A}*@math{x} = @math{b}) with\n\
 @code{@var{y} = @var{A} \\ @math{b}}, rather than\n\
@@ -231,20 +231,20 @@ of a sparse matrix if possible.\n\
 %!error inv ([1, 2; 3, 4], 2)
 %!error <argument must be a square matrix> inv ([1, 2; 3, 4; 5, 6])
 */
 
 // FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
-DEFUN_DLD (inverse, args, nargout,
+DEFUN (inverse, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{x} =} inverse (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{x} =} inverse (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.\n\
 \n\
 This is an alias for @code{inv}.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
   return Finv (args, nargout);
 }
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/corefcn/kron.cc
rename from src/DLD-FUNCTIONS/kron.cc
rename to src/corefcn/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/corefcn/kron.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "CDiagMatrix.h"
 #include "fCDiagMatrix.h"
 
 #include "PermMatrix.h"
 
 #include "mx-inlines.cc"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 template <class R, class T>
 static MArray<T>
 kron (const MArray<R>& a, const MArray<T>& b)
 {
   assert (a.ndims () == 2);
@@ -238,19 +238,19 @@ dispatch_kron (const octave_value& a, co
         retval = do_kron<Matrix, ComplexMatrix> (a, b);
       else
         retval = do_kron<Matrix, Matrix> (a, b);
     }
   return retval;
 }
 
 
-DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} kron (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
+DEFUN (kron, args, , "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} kron (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
 Form the Kronecker product of two or more matrices, defined block by \n\
 block as\n\
 \n\
 @example\n\
 x = [ a(i,j)*b ]\n\
 @end example\n\
 \n\
 For example:\n\
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/corefcn/lookup.cc
rename from src/DLD-FUNCTIONS/lookup.cc
rename to src/corefcn/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/corefcn/lookup.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cctype>
 #include <functional>
 #include <algorithm>
 
 #include "dNDArray.h"
 #include "CNDArray.h"
 
 #include "Cell.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 
 static
 bool
 contains_char (const std::string& str, char c)
@@ -181,20 +181,20 @@ do_numeric_lookup (const ArrayT& array, 
         }
     }
   else
     retval = idx;
 
   return retval;
 }
 
-DEFUN_DLD (lookup, args, ,
+DEFUN (lookup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.  Usually used as a prelude to\n\
 interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)}\n\
 within the table.  If @code{y(i) < table(1)} then\n\
 @code{idx(i)} is 0. If @code{y(i) >= table(end)} or @code{isnan (y(i))} then\n\
 @code{idx(i)} is @code{n}.\n\
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/corefcn/lsode.cc
rename from src/DLD-FUNCTIONS/lsode.cc
rename to src/corefcn/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/corefcn/lsode.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "LSODE.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "unwind-prot.h"
@@ -151,20 +151,20 @@ lsode_user_jacobian (const ColumnVector&
 #define LSODE_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("lsode: " fmt, arg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (lsode, args, nargout,
+DEFUN (lsode, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential equations\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/corefcn/lu.cc
rename from src/DLD-FUNCTIONS/lu.cc
rename to src/corefcn/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/corefcn/lu.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxLU.h"
 #include "dbleLU.h"
 #include "fCmplxLU.h"
 #include "floatLU.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <class MT>
@@ -56,25 +56,25 @@ get_lu_u (const base_lu<MT>& fact)
 {
   MT U = fact.U ();
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
-DEFUN_DLD (lu, args, nargout,
+DEFUN (lu, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
-@deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
+@deftypefnx {Built-in Function} {@var{y} =} lu (@dots{})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
 @cindex LU decomposition\n\
 Compute the LU@tie{}decomposition of @var{A}.  If @var{A} is full\n\
 subroutines from\n\
 @sc{lapack} are used and if @var{A} is sparse then @sc{umfpack} is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
 value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
@@ -588,20 +588,20 @@ bool check_lu_dims (const octave_value& 
                     const octave_value& p)
 {
   octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
             && k == std::min (m, n) &&
             (p.is_undefined () || p.rows () == m));
 }
 
-DEFUN_DLD (luupdate, args, ,
+DEFUN (luupdate, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
 @var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization\n\
 of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).\n\
 Optionally, row-pivoted updating can be used by supplying\n\
 a row permutation (pivoting) matrix @var{P};\n\
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/corefcn/luinc.cc
rename from src/DLD-FUNCTIONS/luinc.cc
rename to src/corefcn/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/corefcn/luinc.cc
@@ -19,34 +19,34 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "oct-map.h"
 
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-DEFUN_DLD (luinc, args, nargout,
+DEFUN (luinc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
 Called with a second argument of '0', the zero-level incomplete\n\
 LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
 where the position of the non-zero arguments correspond to the same\n\
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/corefcn/matrix_type.cc
rename from src/DLD-FUNCTIONS/matrix_type.cc
rename to src/corefcn/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/corefcn/matrix_type.cc
@@ -22,33 +22,33 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
-DEFUN_DLD (matrix_type, args, ,
+DEFUN (matrix_type, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
+@deftypefn  {Built-in Function} {@var{type} =} matrix_type (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 more rapid solutions of linear equations involving @var{A} to be performed.\n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
 If the option \"nocompute\" is given, the function will not attempt to guess\n\
 the type if it is still unknown.  This is useful for debugging purposes.\n\
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/corefcn/max.cc
rename from src/DLD-FUNCTIONS/max.cc
rename to src/corefcn/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/corefcn/max.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
@@ -300,23 +300,23 @@ do_minmax_body (const octave_value_list&
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (min, args, nargout,
+DEFUN (min, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} min (@var{x})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
+@deftypefn  {Built-in Function} {} min (@var{x})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, @var{y}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
 should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise minimum.\n\
 Thus,\n\
 \n\
 @example\n\
@@ -371,23 +371,23 @@ minimum value(s).  Thus,\n\
 %! assert (y, [5, 7; 6, 8]);
 %! assert (ndims (i), 2);
 %! assert (i, [2, 2; 2, 2]);
 
 %!error min ()
 %!error min (1, 2, 3, 4)
 */
 
-DEFUN_DLD (max, args, nargout,
+DEFUN (max, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} max (@var{x})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
+@deftypefn  {Built-in Function} {} max (@var{x})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, @var{y}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
 should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise maximum.\n\
 Thus,\n\
 \n\
 @example\n\
@@ -543,21 +543,21 @@ do_cumminmax_body (const octave_value_li
       }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (cummin, args, nargout,
+DEFUN (cummin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cummin (@var{x})\n\
-@deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
+@deftypefn  {Built-in Function} {} cummin (@var{x})\n\
+@deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
    @result{}  5  4  4  2  2  1\n\
 @end group\n\
@@ -585,21 +585,21 @@ endfor\n\
 @noindent\n\
 but computed in a much faster manner.\n\
 @seealso{cummax, min, max}\n\
 @end deftypefn")
 {
   return do_cumminmax_body (args, nargout, true);
 }
 
-DEFUN_DLD (cummax, args, nargout,
+DEFUN (cummax, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cummax (@var{x})\n\
-@deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
+@deftypefn  {Built-in Function} {} cummax (@var{x})\n\
+@deftypefnx {Built-in Function} {} cummax (@var{x}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
    @result{}  1  3  3  6  6  6\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/corefcn/md5sum.cc
rename from src/DLD-FUNCTIONS/md5sum.cc
rename to src/corefcn/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/corefcn/md5sum.cc
@@ -23,28 +23,28 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 #include <vector>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "file-stat.h"
 #include "file-ops.h"
 #include "gripes.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
-DEFUN_DLD (md5sum, args, ,
+DEFUN (md5sum, args, ,
    "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} md5sum (@var{file})\n\
-@deftypefnx {Loadable Function} {} md5sum (@var{str}, @var{opt})\n\
+@deftypefn  {Built-in Function} {} md5sum (@var{file})\n\
+@deftypefnx {Built-in Function} {} md5sum (@var{str}, @var{opt})\n\
 Calculate the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/corefcn/mgorth.cc
rename from src/DLD-FUNCTIONS/mgorth.cc
rename to src/corefcn/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/corefcn/mgorth.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-norm.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 
 template <class ColumnVector, class Matrix, class RowVector>
 static void
 do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h)
 {
   octave_idx_type Vc = V.columns ();
@@ -43,19 +43,19 @@ do_mgorth (ColumnVector& x, const Matrix
       x -= h(j) * Vcj;
     }
 
   h(Vc) = xnorm (x);
   if (real (h(Vc)) > 0)
     x = x / h(Vc);
 }
 
-DEFUN_DLD (mgorth, args, nargout,
+DEFUN (mgorth, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
+@deftypefn {Built-in Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
 Orthogonalize a given column vector @var{x} with respect to a given\n\
 orthonormal basis @var{v} using a modified Gram-Schmidt orthogonalization.  \n\
 On exit, @var{y} is a unit vector such that:\n\
 \n\
 @example\n\
 @group\n\
   norm (@var{y}) = 1\n\
   @var{v}' * @var{y} = 0\n\
diff --git a/src/corefcn/module.mk b/src/corefcn/module.mk
new file mode 100644
--- /dev/null
+++ b/src/corefcn/module.mk
@@ -0,0 +1,70 @@
+EXTRA_DIST += \
+  corefcn/module.mk
+
+corefcn_SRC = \
+  corefcn/__contourc__.cc \
+  corefcn/__dispatch__.cc \
+  corefcn/__lin_interpn__.cc \
+  corefcn/__pchip_deriv__.cc \
+  corefcn/__qp__.cc \
+  corefcn/balance.cc \
+  corefcn/besselj.cc \
+  corefcn/betainc.cc \
+  corefcn/bsxfun.cc \
+  corefcn/cellfun.cc \
+  corefcn/colloc.cc \
+  corefcn/conv2.cc \
+  corefcn/daspk.cc \
+  corefcn/dasrt.cc \
+  corefcn/dassl.cc \
+  corefcn/det.cc \
+  corefcn/dlmread.cc \
+  corefcn/dot.cc \
+  corefcn/eig.cc \
+  corefcn/fft.cc \
+  corefcn/fft2.cc \
+  corefcn/fftn.cc \
+  corefcn/filter.cc \
+  corefcn/find.cc \
+  corefcn/gammainc.cc \
+  corefcn/gcd.cc \
+  corefcn/getgrent.cc \
+  corefcn/getpwent.cc \
+  corefcn/getrusage.cc \
+  corefcn/givens.cc \
+  corefcn/hess.cc \
+  corefcn/hex2num.cc \
+  corefcn/inv.cc \
+  corefcn/kron.cc \
+  corefcn/lookup.cc \
+  corefcn/lsode.cc \
+  corefcn/lu.cc \
+  corefcn/luinc.cc \
+  corefcn/matrix_type.cc \
+  corefcn/max.cc \
+  corefcn/md5sum.cc \
+  corefcn/mgorth.cc \
+  corefcn/nproc.cc \
+  corefcn/pinv.cc \
+  corefcn/quad.cc \
+  corefcn/quadcc.cc \
+  corefcn/qz.cc \
+  corefcn/rand.cc \
+  corefcn/rcond.cc \
+  corefcn/regexp.cc \
+  corefcn/schur.cc \
+  corefcn/spparms.cc \
+  corefcn/sqrtm.cc \
+  corefcn/str2double.cc \
+  corefcn/strfind.cc \
+  corefcn/sub2ind.cc \
+  corefcn/svd.cc \
+  corefcn/syl.cc \
+  corefcn/time.cc \
+  corefcn/tril.cc \
+  corefcn/typecast.cc
+
+noinst_LTLIBRARIES += corefcn/libcorefcn.la
+
+corefcn_libcorefcn_la_SOURCES = $(corefcn_SRC)
+
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/corefcn/nproc.cc
rename from src/DLD-FUNCTIONS/nproc.cc
rename to src/corefcn/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/corefcn/nproc.cc
@@ -19,23 +19,23 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "nproc.h"
 
-DEFUN_DLD (nproc, args, nargout,
+DEFUN (nproc, args, nargout,
    "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} nproc ()\n\
-@deftypefnx {Loadable Function} {} nproc (@var{query})\n\
+@deftypefn  {Built-in Function} {} nproc ()\n\
+@deftypefnx {Built-in Function} {} nproc (@var{query})\n\
 Return the current number of available processors.\n\
 \n\
 If called with the optional argument @var{query}, modify how processors\n\
 are counted as follows:\n\
 \n\
 @table @code\n\
 @item all\n\
 total number of processors.\n\
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/corefcn/pinv.cc
rename from src/DLD-FUNCTIONS/pinv.cc
rename to src/corefcn/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/corefcn/pinv.cc
@@ -19,32 +19,32 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
-DEFUN_DLD (pinv, args, ,
+DEFUN (pinv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} pinv (@var{x})\n\
-@deftypefnx {Loadable Function} {} pinv (@var{x}, @var{tol})\n\
+@deftypefn  {Built-in Function} {} pinv (@var{x})\n\
+@deftypefnx {Built-in Function} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.  Singular values less than\n\
 @var{tol} are ignored.\n\
 \n\
 If the second argument is omitted, it is taken to be\n\
 \n\
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/corefcn/quad.cc
rename from src/DLD-FUNCTIONS/quad.cc
rename to src/corefcn/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/corefcn/quad.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "Quad.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
@@ -167,22 +167,22 @@ quad_float_user_function (float x)
 #define QUAD_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (quad, args, nargout,
+DEFUN (quad, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
-@deftypefnx {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
-@deftypefnx {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
-@deftypefnx {Loadable Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
+@deftypefn  {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
+@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefnx {Built-in Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using\n\
 Fortran routines from @w{@sc{quadpack}}.  @var{f} is a function handle,\n\
 inline function, or a string containing the name of the function to\n\
 evaluate.  The function must have the form @code{y = f (x)} where @var{y} and\n\
 @var{x} are scalars.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both may be infinite.\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/corefcn/quadcc.cc
rename from src/DLD-FUNCTIONS/quadcc.cc
rename to src/corefcn/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/corefcn/quadcc.cc
@@ -19,22 +19,27 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <stdlib.h>
-#include "lo-math.h"
 #include "lo-ieee.h"
-#include "oct.h"
 #include "parse.h"
-#include "ov-fcn-handle.h"
+#include "variables.h"
+
+#include "defun.h"
+#include "error.h"
+#include "oct-obj.h"
+#include "utils.h"
+
+//#include "oct.h"
+//#include "defun.h"
 
 /* Define the size of the interval heap. */
 #define cquad_heapsize                  200
 
 
 /* Data of a single interval */
 typedef struct
 {
@@ -1464,17 +1469,17 @@ downdate (double *c, int n, int d, int *
       n--;
     }
 
 }
 
 
 /* The actual integration routine.  */
 
-DEFUN_DLD (quadcc, args, nargout,
+DEFUN (quadcc, args, nargout,
 "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 @deftypefnx {Function File} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b}\n\
 using the doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet\n\
 in @cite{Increasing the Reliability of Adaptive Quadrature Using Explicit\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/corefcn/qz.cc
rename from src/DLD-FUNCTIONS/qz.cc
rename to src/corefcn/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/corefcn/qz.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxQRP.h"
 #include "CmplxQR.h"
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-math.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
@@ -285,20 +285,20 @@ fout (const octave_idx_type& lsize, cons
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 
 //FIXME: Matlab does not produce lambda as the first output argument.
 //       Compatibility problem?
-DEFUN_DLD (qz, args, nargout,
+DEFUN (qz, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
 QZ@tie{}decomposition of the generalized eigenvalue problem\n\
 (@math{A x = s B x}).  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
 \n\
 Computes the generalized eigenvalues\n\
 @tex\n\
 $\\lambda$\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/corefcn/rand.cc
rename from src/DLD-FUNCTIONS/rand.cc
rename to src/corefcn/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/corefcn/rand.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #endif
 #include <string>
 
 #include "f77-fcn.h"
 #include "lo-mappers.h"
 #include "oct-rand.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
@@ -358,29 +358,29 @@ do_rand (const octave_value_list& args, 
               return m;
             }
         }
       else
         return octave_rand::nd_array (dims);
     }
 }
 
-DEFUN_DLD (rand, args, ,
+DEFUN (rand, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rand (@var{n})\n\
-@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} rand ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} rand (\"state\")\n\
-@deftypefnx {Loadable Function} {} rand (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rand (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} rand (\"seed\")\n\
-@deftypefnx {Loadable Function} {} rand (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rand (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rand (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} rand (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} rand (@var{n})\n\
+@deftypefnx {Built-in Function} {} rand (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rand ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} rand (\"state\")\n\
+@deftypefnx {Built-in Function} {} rand (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rand (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} rand (\"seed\")\n\
+@deftypefnx {Built-in Function} {} rand (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rand (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} rand (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} rand (@dots{}, \"double\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
 for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the\n\
 form\n\
 \n\
 @example\n\
@@ -530,29 +530,29 @@ or \"single\" argument.  These are the o
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 */
 
 static std::string current_distribution = octave_rand::distribution ();
 
-DEFUN_DLD (randn, args, ,
+DEFUN (randn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randn (@var{n})\n\
-@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randn ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
-@deftypefnx {Loadable Function} {} randn (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randn (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randn (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randn (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randn (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randn (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randn (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randn (@var{n})\n\
+@deftypefnx {Built-in Function} {} randn (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randn ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
+@deftypefnx {Built-in Function} {} randn (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randn (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randn (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randn (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randn (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randn (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randn (@dots{}, \"double\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
@@ -601,29 +601,29 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
-DEFUN_DLD (rande, args, ,
+DEFUN (rande, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rande (@var{n})\n\
-@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} rande ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} rande (\"state\")\n\
-@deftypefnx {Loadable Function} {} rande (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rande (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} rande (\"seed\")\n\
-@deftypefnx {Loadable Function} {} rande (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rande (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rande (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} rande (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} rande (@var{n})\n\
+@deftypefnx {Built-in Function} {} rande (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rande ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} rande (\"state\")\n\
+@deftypefnx {Built-in Function} {} rande (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rande (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} rande (\"seed\")\n\
+@deftypefnx {Built-in Function} {} rande (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rande (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} rande (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to an exponential distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
 or \"single\" argument.  These are the only valid classes.\n\
@@ -673,29 +673,29 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (min (x)>0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
-DEFUN_DLD (randg, args, ,
+DEFUN (randg, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randg (@var{n})\n\
-@deftypefnx {Loadable Function} {} randg (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randg ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
-@deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randg (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randg (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randg (@var{n})\n\
+@deftypefnx {Built-in Function} {} randg (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randg ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randg (\"state\")\n\
+@deftypefnx {Built-in Function} {} randg (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randg (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randg (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randg (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randg (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randg (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randg (@dots{}, \"double\")\n\
 Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
@@ -944,29 +944,29 @@ or \"single\" argument.  These are the o
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
-DEFUN_DLD (randp, args, ,
+DEFUN (randp, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randp (@var{l}, @var{n})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
-@deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randp (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randp (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randp (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randp (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randp (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randp (@var{l}, @var{n})\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randp (\"state\")\n\
+@deftypefnx {Built-in Function} {} randp (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randp (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randp (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randp (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randp (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randp (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randp (@dots{}, \"double\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
 \n\
@@ -1091,20 +1091,20 @@ or \"single\" argument.  These are the o
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 */
 
-DEFUN_DLD (randperm, args, ,
+DEFUN (randperm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randperm (@var{n})\n\
-@deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
+@deftypefn  {Built-in Function} {} randperm (@var{n})\n\
+@deftypefnx {Built-in Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
 O(@var{m}) memory is used as well.  The randomization is performed using\n\
 rand().  All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/corefcn/rcond.cc
rename from src/DLD-FUNCTIONS/rcond.cc
rename to src/corefcn/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/corefcn/rcond.cc
@@ -19,25 +19,25 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (rcond, args, ,
+DEFUN (rcond, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{c} =} rcond (@var{A})\n\
+@deftypefn {Built-in Function} {@var{c} =} rcond (@var{A})\n\
 Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
 @seealso{cond, condest}\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/corefcn/regexp.cc
rename from src/DLD-FUNCTIONS/regexp.cc
rename to src/corefcn/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/corefcn/regexp.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <pcre.h>
 
 #include "base-list.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "regexp.h"
 #include "str-vec.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "Cell.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Replace backslash escapes in a string with the real values.  We need
@@ -531,20 +531,20 @@ octcellregexp (const octave_value_list &
     }
   else
     retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
-DEFUN_DLD (regexp, args, nargout,
+DEFUN (regexp, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 Regular expression string matching.  Search for @var{pat} in @var{str} and\n\
 return the positions and substrings of any matches, or empty values if there\n\
 are none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
 \n\
 @table @code\n\
@@ -1011,20 +1011,20 @@ zero or more 'b' characters at positions
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
 %!assert (regexp ("\n", '\n'), 1);
 %!assert (regexp ("\n", "\n"), 1);
 */
 
-DEFUN_DLD (regexpi, args, nargout,
+DEFUN (regexpi, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Search for @var{pat} in\n\
 @var{str} and return the positions and substrings of any matches, or empty\n\
 values if there are none.  @xref{doc-regexp,,regexp}, for details on the\n\
 syntax of the search pattern.\n\
 @seealso{regexp}\n\
 @end deftypefn")
 {
@@ -1223,20 +1223,20 @@ octregexprep (const octave_value_list &a
   bool extra_args = false;
   parse_options (options, regexpargs, who, 0, extra_args);
   if (error_state)
     return retval;
 
   return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
-DEFUN_DLD (regexprep, args, ,
+DEFUN (regexprep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
-@deftypefnx {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
+@deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{doc-regexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  For example,\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/corefcn/schur.cc
rename from src/DLD-FUNCTIONS/schur.cc
rename to src/corefcn/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/corefcn/schur.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "CmplxSCHUR.h"
 #include "dbleSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "floatSCHUR.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 template <class Matrix>
 static octave_value
 mark_upper_triangular (const Matrix& a)
@@ -52,23 +52,23 @@ mark_upper_triangular (const Matrix& a)
     if (a(i,i) == zero)
       return retval;
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
-DEFUN_DLD (schur, args, nargout,
+DEFUN (schur, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{S} =} schur (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, \"real\")\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}] =} schur (@var{A}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{S} =} schur (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"real\")\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}] =} schur (@var{A}, @dots{})\n\
 @cindex Schur decomposition\n\
 Compute the Schur@tie{}decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  S = U^T A U\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -287,17 +287,17 @@ Riccati equations in control (see @code{
 
 %!test
 %! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
-DEFUN_DLD (rsf2csf, args, nargout,
+DEFUN (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
 Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
 upper triangular Schur@tie{}form @var{T}.\n\
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/corefcn/spparms.cc
rename from src/DLD-FUNCTIONS/spparms.cc
rename to src/corefcn/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/corefcn/spparms.cc
@@ -20,34 +20,34 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "ov.h"
 #include "pager.h"
 #include "error.h"
 #include "gripes.h"
 
 #include "oct-spparms.h"
 
-DEFUN_DLD (spparms, args, nargout,
+DEFUN (spparms, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} { } spparms ()\n\
-@deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
-@deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
-@deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
-@deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
-@deftypefnx {Loadable Function} { } spparms (\"defaults\")\n\
-@deftypefnx {Loadable Function} { } spparms (\"tight\")\n\
-@deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
+@deftypefn  {Built-in Function} { } spparms ()\n\
+@deftypefnx {Built-in Function} {@var{vals} =} spparms ()\n\
+@deftypefnx {Built-in Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
+@deftypefnx {Built-in Function} {@var{val} =} spparms (@var{key})\n\
+@deftypefnx {Built-in Function} { } spparms (@var{vals})\n\
+@deftypefnx {Built-in Function} { } spparms (\"defaults\")\n\
+@deftypefnx {Built-in Function} { } spparms (\"tight\")\n\
+@deftypefnx {Built-in Function} { } spparms (@var{key}, @var{val})\n\
 Query or set the parameters used by the sparse solvers and factorization\n\
 functions.  The first four calls above get information about the current\n\
 settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
 @table @samp\n\
 @item spumoni\n\
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/corefcn/sqrtm.cc
rename from src/DLD-FUNCTIONS/sqrtm.cc
rename to src/corefcn/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/corefcn/sqrtm.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <float.h>
 
 #include "CmplxSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-norm.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "utils.h"
 #include "xnorm.h"
 
 template <class Matrix>
 static void
 sqrtm_utri_inplace (Matrix& T)
@@ -194,20 +194,20 @@ do_sqrtm (const octave_value& arg)
           }
           break;
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (sqrtm, args, nargout,
+DEFUN (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} sqrtm (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{s} =} sqrtm (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
 Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: N.J. Higham.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/corefcn/str2double.cc
rename from src/DLD-FUNCTIONS/str2double.cc
rename to src/corefcn/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/corefcn/str2double.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cctype>
 #include <sstream>
 #include <algorithm>
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "gripes.h"
 #include "utils.h"
 
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static std::istringstream&
@@ -289,17 +289,17 @@ str2double1 (const std::string& str_arg)
           else
             set_component (val, num, i2);
         }
     }
 
   return val;
 }
 
-DEFUN_DLD (str2double, args, ,
+DEFUN (str2double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2double (@var{s})\n\
 Convert a string to a real or complex number.\n\
 \n\
 The string must be in one of the following formats where\n\
 a and b are real numbers and the complex unit is 'i' or 'j':\n\
 \n\
 @itemize\n\
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/corefcn/strfind.cc
rename from src/DLD-FUNCTIONS/strfind.cc
rename to src/corefcn/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/corefcn/strfind.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <climits>
 #include <algorithm>
 #include <deque>
 
 #include "Cell.h"
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
 // This allows safe indexing with char. In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
 #define TABSIZE (UCHAR_MAX + 1)
 
@@ -140,20 +140,20 @@ qs_search (const Array<char>& needle,
        iter != accum.end (); iter++)
     {
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
-DEFUN_DLD (strfind, args, ,
+DEFUN (strfind, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
 \n\
 If a cell array of strings @var{cellstr} is specified\n\
 then @var{idx} is a cell array of vectors, as specified\n\
 above.  Examples:\n\
@@ -314,20 +314,20 @@ qs_replace (const Array<char>& str, cons
 
           std::copy (src + k, src + siz, dest);
         }
     }
 
   return ret;
 }
 
-DEFUN_DLD (strrep, args, ,
+DEFUN (strrep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
-@deftypefnx {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
+@deftypefn  {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
+@deftypefnx {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
 Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
 with the string @var{rep} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
     @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/corefcn/sub2ind.cc
rename from src/DLD-FUNCTIONS/sub2ind.cc
rename to src/corefcn/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/corefcn/sub2ind.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 
 static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
@@ -56,17 +56,17 @@ get_dim_vector (const octave_value& val,
               break;
             }
         }
     }
 
   return dv;
 }
 
-DEFUN_DLD (sub2ind, args, ,
+DEFUN (sub2ind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
 @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
 Convert subscripts to a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional\n\
 index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix\n\
 is linearly indexed moving from one column to next, filling up\n\
@@ -162,17 +162,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 %!error <all subscripts .* same size> sub2ind ([10 10], ones (1,2), ones (2,1))
 
 ## Test input validation
 %!error <dimension vector> sub2ind ([10 10.5], 1, 1)
 %!error <subscript indices> sub2ind ([10 10], 1.5, 1)
 %!error <subscript indices> sub2ind ([10 10], 1, 1.5)
 */
 
-DEFUN_DLD (ind2sub, args, nargout,
+DEFUN (ind2sub, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/corefcn/svd.cc
rename from src/DLD-FUNCTIONS/svd.cc
rename to src/corefcn/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/corefcn/svd.cc
@@ -24,31 +24,31 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "CmplxSVD.h"
 #include "dbleSVD.h"
 #include "fCmplxSVD.h"
 #include "floatSVD.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
-DEFUN_DLD (svd, args, nargout,
+DEFUN (svd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} svd (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
+@deftypefn  {Built-in Function} {@var{s} =} svd (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  A = U S V^{\\dagger}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -397,21 +397,21 @@ decomposition, eliminating the unnecessa
 %! assert (size (s), [0, 0]);
 %! assert (size (v), [0, 0]);
 
 %!error svd ()
 %!error svd ([1, 2; 4, 5], 2, 3)
 %!error [u, v] = svd ([1, 2; 3, 4])
 */
 
-DEFUN_DLD (svd_driver, args, nargout,
+DEFUN (svd_driver, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{val} =} svd_driver ()\n\
-@deftypefnx {Loadable Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
-@deftypefnx {Loadable Function} {} svd_driver (@var{new_val}, \"local\")\n\
+@deftypefn  {Built-in Function} {@var{val} =} svd_driver ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
 Currently recognized values are \"gesvd\" and \"gesdd\".  The default\n\
 is \"gesvd\".\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{svd}\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/corefcn/syl.cc
rename from src/DLD-FUNCTIONS/syl.cc
rename to src/corefcn/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/corefcn/syl.cc
@@ -21,25 +21,25 @@ along with Octave; see the file COPYING.
 */
 
 // Author: A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (syl, args, nargout,
+DEFUN (syl, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
+@deftypefn {Built-in Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/corefcn/time.cc
rename from src/DLD-FUNCTIONS/time.cc
rename to src/corefcn/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/corefcn/time.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-map.h"
 #include "oct-time.h"
 #include "ov.h"
 #include "oct-obj.h"
 
 // Date and time functions.
 
@@ -96,19 +96,19 @@ extract_tm (const octave_scalar_map& m)
   tm.wday (intfield (m, "wday"));
   tm.yday (intfield (m, "yday"));
   tm.isdst (intfield (m, "isdst"));
   tm.zone (stringfield (m, "zone"));
 
   return tm;
 }
 
-DEFUN_DLD (time, args, ,
+DEFUN (time, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{seconds} =} time ()\n\
+@deftypefn {Built-in Function} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.  The\n\
 epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the\n\
 value returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -120,19 +120,19 @@ value returned by @code{time} was 856163
 
   return retval;
 }
 
 /*
 %!assert (time () > 0)
 */
 
-DEFUN_DLD (gmtime, args, ,
+DEFUN (gmtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tm_struct} =} gmtime (@var{t})\n\
+@deftypefn {Built-in Function} {@var{tm_struct} =} gmtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to CUT (Coordinated Universal Time).\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
      @result{} @{\n\
@@ -182,19 +182,19 @@ gmtime (time ())\n\
 %! assert (isfield (ts, "hour"));
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error gmtime ()
 %!error gmtime (1, 2)
 */
 
-DEFUN_DLD (localtime, args, ,
+DEFUN (localtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tm_struct} =} localtime (@var{t})\n\
+@deftypefn {Built-in Function} {@var{tm_struct} =} localtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
@@ -243,19 +243,19 @@ localtime (time ())\n\
 %! assert (isfield (ts, "hour"));
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error localtime ()
 %!error localtime (1, 2)
 */
 
-DEFUN_DLD (mktime, args, ,
+DEFUN (mktime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
+@deftypefn {Built-in Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
 of seconds since the epoch.  For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
 @end group\n\
@@ -297,19 +297,19 @@ mktime (localtime (time ()))\n\
 %!assert (datestr (datenum (1969, 1, 1), 0), "01-Jan-1969 00:00:00")
 %!assert (datestr (datenum (1901, 1, 1), 0), "01-Jan-1901 00:00:00")
 %!assert (datestr (datenum (1795, 1, 1), 0), "01-Jan-1795 00:00:00")
 
 %!error mktime ()
 %!error mktime (1, 2, 3)
 */
 
-DEFUN_DLD (strftime, args, ,
+DEFUN (strftime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
+@deftypefn {Built-in Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the\n\
 format string @var{fmt} that contains @samp{%} substitutions\n\
 similar to those in @code{printf}.  Except where noted, substituted\n\
 fields have a fixed size; numeric fields are padded if necessary.\n\
 Padding is with zeros by default; for fields that display a single\n\
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
@@ -492,19 +492,19 @@ Year (1970-).\n\
 %!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
 %!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
 %!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
 
 %!error strftime ()
 %!error strftime ("foo", localtime (time ()), 1)
 */
 
-DEFUN_DLD (strptime, args, ,
+DEFUN (strptime, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
+@deftypefn {Built-in Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/corefcn/tril.cc
rename from src/DLD-FUNCTIONS/tril.cc
rename to src/corefcn/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/corefcn/tril.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 #include "Array.h"
 #include "Sparse.h"
 #include "mx-base.h"
 
 #include "ov.h"
 #include "Cell.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // The bulk of the work.
 template <class T>
 static Array<T>
 do_tril (const Array<T>& a, octave_idx_type k, bool pack)
 {
@@ -334,17 +334,17 @@ do_trilu (const std::string& name,
               }
             }
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (tril, args, ,
+DEFUN (tril, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} tril (@var{A})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k}, @var{pack})\n\
 @deftypefnx {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting the lower (@code{tril})\n\
@@ -390,17 +390,17 @@ If the option \"pack\" is given as third
 are not inserted into a matrix, but rather stacked column-wise one above\n\
 other.\n\
 @seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
-DEFUN_DLD (triu, args, ,
+DEFUN (triu, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 See the documentation for the @code{tril} function (@pxref{tril}).\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/corefcn/typecast.cc
rename from src/DLD-FUNCTIONS/typecast.cc
rename to src/corefcn/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/corefcn/typecast.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-base.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 
 static dim_vector
 get_vec_dims (const dim_vector& old_dims, octave_idx_type n)
 {
@@ -81,19 +81,19 @@ reinterpret_copy (const void *data, octa
   else
     {
       error ("typecast: incorrect number of input values to make output value");
       return ArrayType ();
     }
 }
 
 
-DEFUN_DLD (typecast, args, ,
+DEFUN (typecast, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
+@deftypefn {Built-in Function} {} typecast (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"logical\"\n\
 \"char\"\n\
@@ -266,19 +266,19 @@ do_bitpack (const boolNDArray& bitp)
     }
   else
     {
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
     }
 }
 
-DEFUN_DLD (bitpack, args, ,
+DEFUN (bitpack, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
+@deftypefn {Built-in Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting an array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
 \"int8\"\n\
@@ -375,19 +375,19 @@ do_bitunpack (const ArrayType& array)
       for (int j = 1; j < CHAR_BIT; j++)
         bits[j] = (c >>= 1) & 1;
       bits += CHAR_BIT;
     }
 
   return retval;
 }
 
-DEFUN_DLD (bitunpack, args, ,
+DEFUN (bitunpack, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} bitunpack (@var{x})\n\
+@deftypefn {Built-in Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
 \"int8\"\n\
 \"int16\"\n\
diff --git a/src/find-defun-files.sh b/src/find-defun-files.sh
--- a/src/find-defun-files.sh
+++ b/src/find-defun-files.sh
@@ -16,11 +16,11 @@ shift
 for arg
 do
   if [ -f "$arg" ]; then
     file="$arg"
   else
     file="$srcdir/$arg"
   fi
   if [ "`$EGREP -l "$DEFUN_PATTERN" $file`" ]; then
-    echo "$file" | $SED 's,.*/,,; s/\.cc$/.df/; s/\.ll$/.df/; s/\.yy$/.df/';
+    echo "$file" | $SED "s,\\$srcdir/,," | $SED 's/\.cc$/.df/; s/\.ll$/.df/; s/\.yy$/.df/';
   fi
 done
diff --git a/src/link-deps.mk b/src/link-deps.mk
--- a/src/link-deps.mk
+++ b/src/link-deps.mk
@@ -6,27 +6,30 @@ else
   LIBOCTINTERP_LINK_DEPS = $(DLD_FUNCTIONS_LIBS)
 endif
 
 LIBOCTINTERP_LINK_DEPS += \
   $(GRAPHICS_LIBS) \
   $(FT2_LIBS) \
   $(HDF5_LIBS) \
   $(Z_LIBS) \
+  $(FFTW_XLIBS) \
+  $(REGEX_LIBS) \
   $(OPENGL_LIBS) \
   $(X11_LIBS) \
   $(CARBON_LIBS) \
   $(LLVM_LIBS)
 
 LIBOCTINTERP_LINK_OPTS = \
   $(GRAPHICS_LDFLAGS) \
   $(FT2_LDFLAGS) \
   $(HDF5_LDFLAGS) \
   $(Z_LDFLAGS) \
   $(REGEX_LDFLAGS) \
+  $(FFTW_XLDFLAGS) \
   $(LLVM_LDFLAGS)
 
 OCT_LINK_DEPS =
 
 OCT_LINK_OPTS = $(LDFLAGS)
 
 if AMCOND_LINK_ALL_DEPS
   LIBOCTINTERP_LINK_DEPS += $(LIBOCTAVE_LINK_DEPS)
