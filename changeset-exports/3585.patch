# HG changeset patch
# User jwe
# Date 949984547 0
#      Tue Feb 08 04:35:47 2000 +0000
# Node ID d9803711e047160d513b0ef83a4a3c154845c352
# Parent  aa31644d9779128f2d3e438675483d4a136ac634
[project @ 2000-02-08 04:35:39 by jwe]

diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -39,17 +39,18 @@ class idx_vector;
 #ifndef HEAVYWEIGHT_INDEXING
 #define HEAVYWEIGHT_INDEXING 1
 #endif
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
-class Array
+class
+Array
 {
 protected:
 
 // The real representation of all arrays.
 
   class ArrayRep
   {
   public:
@@ -59,17 +60,17 @@ protected:
     int count;
 
     ArrayRep& operator = (const ArrayRep& a);
 
     ArrayRep (T *d, int l) : data (d), len (l), count (1) { }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
-    ArrayRep (int n) : data (new T [n]), len (n), count (1) { }
+    explicit ArrayRep (int n) : data (new T [n]), len (n), count (1) { }
 
     ArrayRep (const ArrayRep& a)
       : data (new T [a.len]), len (a.len), count (1)
 	{
 	  for (int i = 0; i < len; i++)
 	    data[i] = a.data[i];
 	}
 
@@ -125,17 +126,17 @@ public:
 
 #ifdef HEAVYWEIGHT_INDEXING
       idx = 0;
       max_indices = 1;
       idx_count = 0;
 #endif
     }
 
-  Array (int n)
+  explicit Array (int n)
     {
       rep = new ArrayRep (n);
 
 #ifdef HEAVYWEIGHT_INDEXING
       idx = 0;
       max_indices = 1;
       idx_count = 0;
 #endif
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -36,17 +36,18 @@ Software Foundation, 59 Temple Place - S
 #include "Array.h"
 #include "lo-error.h"
 
 class idx_vector;
 
 // Two dimensional array class.
 
 template <class T>
-class Array2 : public Array<T>
+class
+Array2 : public Array<T>
 {
 protected:
 
   int get_size (int r, int c) const;
 
   Array2 (T *d, int n, int m) : Array<T> (d, get_size (n, m))
     {
       d1 = n;
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -34,17 +34,18 @@ Software Foundation, 59 Temple Place - S
 #include "Array2.h"
 #include "lo-error.h"
 
 class idx_vector;
 
 // Three dimensional array class.
 
 template <class T>
-class Array3 : public Array2<T>
+class
+Array3 : public Array2<T>
 {
 protected:
 
   int d3;
 
   Array3 (T *d, int n, int m, int k) : Array2<T> (d, n, get_size (m, k))
     {
       d2 = m;
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -435,17 +435,17 @@ product (const ColumnVector& v, const Co
 {
   int len = v.length ();
 
   int a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("product", len, a_len);
-      return ColumnVector ();
+      return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
 }
 
@@ -454,17 +454,17 @@ quotient (const ColumnVector& v, const C
 {
   int len = v.length ();
 
   int a_len = a.length ();
 
   if (len != a_len)
     {
       gripe_nonconformant ("quotient", len, a_len);
-      return ColumnVector ();
+      return ComplexColumnVector ();
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
 
@@ -485,17 +485,17 @@ operator * (const DiagMatrix& m, const C
   int nr = m.rows ();
   int nc = m.cols ();
 
   int a_len = a.length ();
 
   if (nc != a_len)
     {
       gripe_nonconformant ("operator *", nr, nc, a_len, 1);
-      return ColumnVector ();
+      return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (int i = 0; i < a_len; i++)
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -26,29 +26,36 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
-class ComplexColumnVector : public MArray<Complex>
+class
+ComplexColumnVector : public MArray<Complex>
 {
 friend class ComplexMatrix;
 friend class ComplexRowVector;
 
 public:
 
   ComplexColumnVector (void) : MArray<Complex> () { }
-  ComplexColumnVector (int n) : MArray<Complex> (n) { }
-  ComplexColumnVector (int n, const Complex& val) : MArray<Complex> (n, val) { }
-  ComplexColumnVector (const ColumnVector& a);
+
+  explicit ComplexColumnVector (int n) : MArray<Complex> (n) { }
+
+  ComplexColumnVector (int n, const Complex& val)
+    : MArray<Complex> (n, val) { }
+
+  ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
+
   ComplexColumnVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
-  ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
+
+  explicit ComplexColumnVector (const ColumnVector& a);
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexColumnVector& a) const;
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -282,17 +282,17 @@ ComplexDiagMatrix::extract (int r1, int 
 ComplexRowVector
 ComplexDiagMatrix::row (int i) const
 {
   int r = rows ();
   int c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector (); 
+      return ComplexRowVector (); 
     }
 
   ComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
@@ -321,44 +321,44 @@ ComplexDiagMatrix::row (char *s) const
 ComplexColumnVector
 ComplexDiagMatrix::column (int i) const
 {
   int r = rows ();
   int c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ComplexColumnVector (); 
     }
 
   ComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ComplexColumnVector (); 
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ComplexColumnVector (); 
     }
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
@@ -367,17 +367,17 @@ ComplexDiagMatrix::inverse (void) const
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (int& info) const
 {
   int r = rows ();
   int c = cols ();
   if (r != c)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
-      return DiagMatrix ();
+      return ComplexDiagMatrix ();
     }
 
   ComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (int i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0)
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -31,35 +31,47 @@ Software Foundation, 59 Temple Place - S
 
 #include "dRowVector.h"
 #include "CRowVector.h"
 #include "dColVector.h"
 #include "CColVector.h"
 
 #include "mx-defs.h"
 
-class ComplexDiagMatrix : public MDiagArray2<Complex>
+class
+ComplexDiagMatrix : public MDiagArray2<Complex>
 {
 public:
 
   ComplexDiagMatrix (void) : MDiagArray2<Complex> () { }
+
   ComplexDiagMatrix (int r, int c) : MDiagArray2<Complex> (r, c) { }
+
   ComplexDiagMatrix (int r, int c, const Complex& val)
     : MDiagArray2<Complex> (r, c, val) { }
-  ComplexDiagMatrix (const RowVector& a)
+
+  explicit ComplexDiagMatrix (const RowVector& a)
     : MDiagArray2<Complex> (ComplexRowVector (a)) { }
-  ComplexDiagMatrix (const ComplexRowVector& a) : MDiagArray2<Complex> (a) { }
-  ComplexDiagMatrix (const ColumnVector& a)
+
+  explicit ComplexDiagMatrix (const ComplexRowVector& a)
+    : MDiagArray2<Complex> (a) { }
+
+  explicit ComplexDiagMatrix (const ColumnVector& a)
     : MDiagArray2<Complex> (ComplexColumnVector (a)) { }
-  ComplexDiagMatrix (const ComplexColumnVector& a)
+
+  explicit ComplexDiagMatrix (const ComplexColumnVector& a)
     : MDiagArray2<Complex> (a) { }
-  ComplexDiagMatrix (const DiagMatrix& a);
+
+  explicit ComplexDiagMatrix (const DiagMatrix& a);
+
   ComplexDiagMatrix (const MDiagArray2<Complex>& a)
     : MDiagArray2<Complex> (a) { }
-  ComplexDiagMatrix (const ComplexDiagMatrix& a) : MDiagArray2<Complex> (a) { }
+
+  ComplexDiagMatrix (const ComplexDiagMatrix& a)
+    : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
     {
       MDiagArray2<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexDiagMatrix& a) const;
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1345,16 +1345,44 @@ ComplexMatrix::solve (const ComplexMatri
 	    }
 	}
     }
 
   return retval;
 }
 
 ComplexColumnVector
+ComplexMatrix::solve (const ColumnVector& b) const
+{
+  int info;
+  double rcond;
+  return solve (ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (const ColumnVector& b, int& info) const
+{
+  double rcond;
+  return solve (ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond) const
+{
+  return solve (ComplexColumnVector (b), info, rcond, 0);
+}
+
+ComplexColumnVector
+ComplexMatrix::solve (const ColumnVector& b, int& info, double& rcond,
+		      solve_singularity_handler sing_handler) const
+{
+  return solve (ComplexColumnVector (b), info, rcond, sing_handler);
+}
+
+ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   int info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
@@ -1430,16 +1458,37 @@ ComplexMatrix::solve (const ComplexColum
 	    }
 	}
     }
 
   return retval;
 }
 
 ComplexMatrix
+ComplexMatrix::lssolve (const Matrix& b) const
+{
+  int info;
+  int rank;
+  return lssolve (ComplexMatrix (b), info, rank);
+}
+
+ComplexMatrix
+ComplexMatrix::lssolve (const Matrix& b, int& info) const
+{
+  int rank;
+  return lssolve (ComplexMatrix (b), info, rank);
+}
+
+ComplexMatrix
+ComplexMatrix::lssolve (const Matrix& b, int& info, int& rank) const
+{
+  return lssolve (ComplexMatrix (b), info, rank);
+}
+
+ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b) const
 {
   int info;
   int rank;
   return lssolve (b, info, rank);
 }
 
 ComplexMatrix
@@ -1512,16 +1561,37 @@ ComplexMatrix::lssolve (const ComplexMat
 	      retval.elem (i, j) = result.elem (i, j);
 	}
     }
 
   return retval;
 }
 
 ComplexColumnVector
+ComplexMatrix::lssolve (const ColumnVector& b) const
+{
+  int info;
+  int rank;
+  return lssolve (ComplexColumnVector (b), info, rank);
+}
+
+ComplexColumnVector
+ComplexMatrix::lssolve (const ColumnVector& b, int& info) const
+{
+  int rank;
+  return lssolve (ComplexColumnVector (b), info, rank);
+}
+
+ComplexColumnVector
+ComplexMatrix::lssolve (const ColumnVector& b, int& info, int& rank) const
+{
+  return lssolve (ComplexColumnVector (b), info, rank);
+}
+
+ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
   int info;
   int rank;
   return lssolve (b, info, rank);
 }
 
 ComplexColumnVector
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -29,39 +29,51 @@ Software Foundation, 59 Temple Place - S
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 #include "oct-cmplx.h"
 
-class ComplexMatrix : public MArray2<Complex>
+class
+ComplexMatrix : public MArray2<Complex>
 {
 public:
  
   typedef void (*solve_singularity_handler) (double rcond);
 
   ComplexMatrix (void) : MArray2<Complex> () { }
+
   ComplexMatrix (int r, int c) : MArray2<Complex> (r, c) { }
+
   ComplexMatrix (int r, int c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
-  ComplexMatrix (const Matrix& a);
-  ComplexMatrix (const MArray2<Complex>& a) : MArray2<Complex> (a) { }
+
   ComplexMatrix (const ComplexMatrix& a) : MArray2<Complex> (a) { }
-  ComplexMatrix (const RowVector& rv);
-  ComplexMatrix (const ColumnVector& cv);
-  ComplexMatrix (const DiagMatrix& a);
-  //  ComplexMatrix (const MDiagArray2<Complex>& a) : MArray2<Complex> (a) { }
-  ComplexMatrix (const ComplexRowVector& rv);
-  ComplexMatrix (const ComplexColumnVector& cv);
-  ComplexMatrix (const ComplexDiagMatrix& a);
+
+  ComplexMatrix (const MArray2<Complex>& a) : MArray2<Complex> (a) { }
+
+  explicit ComplexMatrix (const Matrix& a);
+
+  explicit ComplexMatrix (const RowVector& rv);
+
+  explicit ComplexMatrix (const ColumnVector& cv);
 
-  ComplexMatrix (const boolMatrix& a);
-  ComplexMatrix (const charMatrix& a);
+  explicit ComplexMatrix (const DiagMatrix& a);
+
+  explicit ComplexMatrix (const ComplexRowVector& rv);
+
+  explicit ComplexMatrix (const ComplexColumnVector& cv);
+
+  explicit ComplexMatrix (const ComplexDiagMatrix& a);
+
+  explicit ComplexMatrix (const boolMatrix& a);
+
+  explicit ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
     {
       MArray2<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexMatrix& a) const;
@@ -147,29 +159,45 @@ public:
 		       solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, int& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, int& info, double& rcond,
 		       solve_singularity_handler sing_handler) const;
 
+  ComplexColumnVector solve (const ColumnVector& b) const;
+  ComplexColumnVector solve (const ColumnVector& b, int& info) const;
+  ComplexColumnVector solve (const ColumnVector& b, int& info,
+			     double& rcond) const;
+  ComplexColumnVector solve (const ColumnVector& b, int& info, double& rcond,
+			     solve_singularity_handler sing_handler) const;
+
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
 			     double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, int& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
+  ComplexMatrix lssolve (const Matrix& b) const;
+  ComplexMatrix lssolve (const Matrix& b, int& info) const;
+  ComplexMatrix lssolve (const Matrix& b, int& info, int& rank) const;
+
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, int& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
 			 int& rank) const;
 
+  ComplexColumnVector lssolve (const ColumnVector& b) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, int& info) const;
+  ComplexColumnVector lssolve (const ColumnVector& b, int& info,
+			       int& rank) const;
+
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
 			       int& rank) const;
 
   ComplexMatrix expm (void) const;
 
   // column vector by row vector -> matrix operations
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -26,28 +26,34 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
-class ComplexRowVector : public MArray<Complex>
+class
+ComplexRowVector : public MArray<Complex>
 {
 friend class ComplexColumnVector;
 
 public:
 
   ComplexRowVector (void) : MArray<Complex> () { }
-  ComplexRowVector (int n) : MArray<Complex> (n) { }
+
+  explicit ComplexRowVector (int n) : MArray<Complex> (n) { }
+
   ComplexRowVector (int n, const Complex& val) : MArray<Complex> (n, val) { }
-  ComplexRowVector (const RowVector& a);
+
+  ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
+
   ComplexRowVector (const MArray<Complex>& a) : MArray<Complex> (a) { }
-  ComplexRowVector (const ComplexRowVector& a) : MArray<Complex> (a) { }
+
+  explicit ComplexRowVector (const RowVector& a);
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
   bool operator == (const ComplexRowVector& a) const;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,38 @@
+2000-02-07  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* CMatrix.h, CMatrix.cc: Add lssolve methods for real-valued RHS
+	matrix and vector objects.
+
+	* mx-op-defs.h (DMM_BIN_OP): Explicitly request conversion to
+	return type from second arg type.
+	(MDM_BIN_OP): Likewise, for first arg type.
+
+	* dMatrix.cc (Matrix::fourier, Matrix::ifourier,
+	Matrix::fourier2d, Matrix::ifourier2d): Likewise.
+
+	* EIG.cc (EIG::symmetric_init, EIG::hermitian_init): Explicitly
+	request ColumnVector to ComplexColumnVector, and Matrix to
+	ComplexMatrix conversions.
+
+	* CmplxAEPBAL.cc (ComplexAEPBALANCE::init): Give balancing_mat its
+	initial value using ComplexMatrix constructor.
+
+	* CColVector.cc (product, quotient,
+	operator * (const DiagMatrix&, const ComplexColumnVetor&)):
+	Fix type of returned value.
+	* CDiagMatrix.cc (ComplexDiagMatrix::row,
+	ComplexDiagMatrix::column, ComplexDiagMatrix::inverse): Likewise.
+
+	* Array.h, CColVector.h, CDiagMatrix.h, CMatrix.h, CRowVector.h,
+	MArray.h, MDiagArray2.h, dColVector.h, dDiagMatrix.h, dMatrix.h,
+	dRowVector.h: Declare some constructors explicit, to disallow
+	potentially problematic automatic type conversions.
+
 2000-02-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* vx-rv-crv.h, vx-cv-ccv.h, vx-crv-rv.h, vx-ccv-cv.h,
 	vx-rv-crv.cc, vx-cv-ccv.cc, vx-crv-rv.cc, vx-ccv-cv.cc:
 	More new files.
 	* Makefile.in: Add them to the appropriate lists.
 
 	* vx-ccv-s.h, vx-crv-s.h, vx-cs-cv.h, vx-cs-rv.h, vx-cv-cs.h,
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -72,17 +72,17 @@ ComplexAEPBALANCE::init (const ComplexMa
 
   F77_XFCN (zgebal, ZGEBAL, (&job, n, p_balanced_mat, n, ilo, ihi,
 			     pscale, info, 1L, 1L));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
   else
     {
-      balancing_mat = Matrix (n, n, 0.0);
+      balancing_mat = ComplexMatrix (n, n, 0.0);
       for (int i = 0; i < n; i++)
 	balancing_mat.elem (i, i) = 1.0;
 
       Complex *p_balancing_mat = balancing_mat.fortran_vec ();
 
       char side = 'R';
 
       F77_XFCN (zgebak, ZGEBAK, (&job, &side, n, ilo, ihi, pscale, n,
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -45,17 +45,18 @@ class idx_vector;
 // Message-ID: <KANZE.93Nov29151407@slsvhdt.us-es.sel.de>
 // Sender: news@us-es.sel.de
 // Date: 29 Nov 1993 14:14:07 GMT
 // --
 // James Kanze                             email: kanze@us-es.sel.de
 // GABI Software, Sarl., 8 rue du Faisan, F-67000 Strasbourg, France
 
 template <class T>
-class DiagArray2 : public Array<T>
+class
+DiagArray2 : public Array<T>
 {
 private:
 
   T get (int i) { return Array<T>::xelem (i); }
 
   void set (const T& val, int i) { Array<T>::xelem (i) = val; }
 
   class Proxy
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -155,44 +155,37 @@ EIG::symmetric_init (const Matrix& a)
       return -1;
     }
 
   int info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
 
-  Array<double> wr (n);
+  ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   // XXX FIXME XXX -- it might be possible to choose a better value of
   // lwork that would result in more efficient computations.
 
   int lwork = 8*n;
   Array<double> work (lwork);
   double *pwork = work.fortran_vec ();
 
   F77_XFCN (dsyev, DSYEV, ("V", "U", n, tmp_data, n, pwr, pwork,
 			   lwork, info, 1L, 1L));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
+  else if (info > 0)
+    (*current_liboctave_error_handler) ("dsyev failed to converge");
   else
     {
-      if (info > 0)
-	(*current_liboctave_error_handler) ("dsyev failed to converge");
-      else
-	{
-	  lambda.resize (n);
-
-	  for (int j = 0; j < n; j++)
-	    lambda.elem (j) = Complex (wr.elem (j));
-
-	  v = atmp;
-	}
+      lambda = ComplexColumnVector (wr);
+      v = ComplexMatrix (atmp);
     }
 
   return info;
 }
 
 int
 EIG::init (const ComplexMatrix& a)
 {
@@ -259,41 +252,41 @@ EIG::hermitian_init (const ComplexMatrix
       return -1;
     }
 
   int info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
 
-  ColumnVector w (n);
-  double *pw = w.fortran_vec ();
+  ColumnVector wr (n);
+  double *pwr = wr.fortran_vec ();
 
   // XXX FIXME XXX -- it might be possible to choose a better value of
   // lwork that would result in more efficient computations.
 
   int lwork = 8*n;
   Array<Complex> work (lwork);
   Complex *pwork = work.fortran_vec ();
 
   int lrwork = 3*n;
   Array<double> rwork (lrwork);
   double *prwork = rwork.fortran_vec ();
 
-  F77_XFCN (zheev, ZHEEV, ("V", "U", n, tmp_data, n, pw, pwork,
+  F77_XFCN (zheev, ZHEEV, ("V", "U", n, tmp_data, n, pwr, pwork,
 			   lwork, prwork, info, 1L, 1L));
 
   if (f77_exception_encountered || info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zheev");
   else if (info > 0)
     (*current_liboctave_error_handler) ("zheev failed to converge");
   else
     {
-      lambda = w;
-      v = atmp;
+      lambda = ComplexColumnVector (wr);
+      v = ComplexMatrix (atmp);
     }
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/LP.h b/liboctave/LP.h
--- a/liboctave/LP.h
+++ b/liboctave/LP.h
@@ -23,17 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_LP_h)
 #define octave_LP_h 1
 
 #include "dColVector.h"
 #include "Bounds.h"
 #include "LinConst.h"
 #include "base-min.h"
 
-class LP : public base_minimizer
+class
+LP : public base_minimizer
 {
 public:
 
   LP (void)
     : base_minimizer (), c (), bnds (), lc () { }
 
   LP (const ColumnVector& c_arg)
     : base_minimizer (), c (c_arg), bnds (), lc () { }
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -34,29 +34,34 @@ Software Foundation, 59 Temple Place - S
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray)
 
 template <class T>
-class MArray : public Array<T>
+class
+MArray : public Array<T>
 {
 protected:
 
   MArray (T *d, int l) : Array<T> (d, l) { }
 
 public:
   
   MArray (void) : Array<T> () { }
-  MArray (int n) : Array<T> (n) { }
+
+  explicit MArray (int n) : Array<T> (n) { }
+
   MArray (int n, const T& val) : Array<T> (n, val) { }
+
+  MArray (const MArray<T>& a) : Array<T> (a) { }
+
   MArray (const Array<T>& a) : Array<T> (a) { }
-  MArray (const MArray<T>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
     {
       Array<T>::operator = (a);
       return *this;
     }
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -34,29 +34,34 @@ Software Foundation, 59 Temple Place - S
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray2)
 
 template <class T>
-class MArray2 : public Array2<T>
+class
+MArray2 : public Array2<T>
 {
 protected:
 
   MArray2 (T *d, int n, int m) : Array2<T> (d, n, m) { }
 
 public:
 
   MArray2 (void) : Array2<T> () { }
+
   MArray2 (int n, int m) : Array2<T> (n, m) { }
+
   MArray2 (int n, int m, const T& val) : Array2<T> (n, m, val) { }
+
+  MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
+
   MArray2 (const Array2<T>& a) : Array2<T> (a) { }
-  MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
 
   ~MArray2 (void) { }
 
   MArray2<T>& operator = (const MArray2<T>& a)
     {
       Array2<T>::operator = (a);
       return *this;
     }
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -35,30 +35,36 @@ Software Foundation, 59 Temple Place - S
 
 // But first, some preprocessor abuse...
 
 #include "MArray-defs.h"
 
 MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2)
 
 template <class T>
-class MDiagArray2 : public DiagArray2<T>
+class
+MDiagArray2 : public DiagArray2<T>
 {
 protected:
 
   MDiagArray2 (T *d, int r, int c) : DiagArray2<T> (d, r, c) { }
 
 public:
   
   MDiagArray2 (void) : DiagArray2<T> () { }
+
   MDiagArray2 (int r, int c) : DiagArray2<T> (r, c) { }
+
   MDiagArray2 (int r, int c, const T& val) : DiagArray2<T> (r, c, val) { }
-  MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
+
+  MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
+
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
-  MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
+
+  explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -25,17 +25,18 @@ Software Foundation, 59 Temple Place - S
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray.h"
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
-class base_lu
+class
+base_lu
 {
 public:
 
   base_lu (void) { }
 
   base_lu (const base_lu& a) : a_fact (a.a_fact), ipvt (a.ipvt) { }
 
   base_lu& operator = (const base_lu& a)
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -26,25 +26,30 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
-class ColumnVector : public MArray<double>
+class
+ColumnVector : public MArray<double>
 {
 public:
 
   ColumnVector (void) : MArray<double> () { }
-  ColumnVector (int n) : MArray<double> (n) { }
+
+  explicit ColumnVector (int n) : MArray<double> (n) { }
+
   ColumnVector (int n, double val) : MArray<double> (n, val) { }
+
+  ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
+
   ColumnVector (const MArray<double>& a) : MArray<double> (a) { }
-  ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const ColumnVector& a) const;
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -29,30 +29,37 @@ Software Foundation, 59 Temple Place - S
 
 #include "MDiagArray2.h"
 
 #include "dRowVector.h"
 #include "dColVector.h"
 
 #include "mx-defs.h"
 
-class DiagMatrix : public MDiagArray2<double>
+class
+DiagMatrix : public MDiagArray2<double>
 {
 friend class SVD;
 friend class ComplexSVD;
 
 public:
 
   DiagMatrix (void) : MDiagArray2<double> () { }
+
   DiagMatrix (int r, int c) : MDiagArray2<double> (r, c) { }
+
   DiagMatrix (int r, int c, double val) : MDiagArray2<double> (r, c, val) { }
-  DiagMatrix (const RowVector& a) : MDiagArray2<double> (a) { }
-  DiagMatrix (const ColumnVector& a) : MDiagArray2<double> (a) { }
+
+  DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
+
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
-  DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
+
+  explicit DiagMatrix (const RowVector& a) : MDiagArray2<double> (a) { }
+
+  explicit DiagMatrix (const ColumnVector& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
     {
       MDiagArray2<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const DiagMatrix& a) const;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -667,17 +667,17 @@ Matrix::fourier (void) const
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
-  retval = *this;
+  retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
 
   return retval;
@@ -704,17 +704,17 @@ Matrix::ifourier (void) const
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
-  retval = *this;
+  retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
@@ -744,17 +744,17 @@ Matrix::fourier2d (void) const
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
-  retval = *this;
+  retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftf, CFFTF) (npts, &tmp_data[npts*j], pwsave);
 
   npts = nc;
@@ -804,17 +804,17 @@ Matrix::ifourier2d (void) const
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
 
   Array<Complex> wsave (nn);
   Complex *pwsave = wsave.fortran_vec ();
 
-  retval = *this;
+  retval = ComplexMatrix (*this);
   Complex *tmp_data = retval.fortran_vec ();
 
   F77_FCN (cffti, CFFTI) (npts, pwsave);
 
   for (int j = 0; j < nsamples; j++)
     F77_FCN (cfftb, CFFTB) (npts, &tmp_data[npts*j], pwsave);
 
   for (int j = 0; j < npts*nsamples; j++)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -31,34 +31,42 @@ Software Foundation, 59 Temple Place - S
 #include "MDiagArray2.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 
 #include "data-conv.h"
 #include "mach-info.h"
 
-class Matrix : public MArray2<double>
+class
+Matrix : public MArray2<double>
 {
 public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   Matrix (void) : MArray2<double> () { }
+
   Matrix (int r, int c) : MArray2<double> (r, c) { }
+
   Matrix (int r, int c, double val) : MArray2<double> (r, c, val) { }
-  Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
+
   Matrix (const Matrix& a) : MArray2<double> (a) { }
-  Matrix (const RowVector& rv);
-  Matrix (const ColumnVector& cv);
-  //  Matrix (const MDiagArray2<double>& a) : MArray2<double> (a) { }
-  Matrix (const DiagMatrix& a);
+
+  Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
+
+  explicit Matrix (const RowVector& rv);
 
-  Matrix (const boolMatrix& a);
-  Matrix (const charMatrix& a);
+  explicit Matrix (const ColumnVector& cv);
+
+  explicit Matrix (const DiagMatrix& a);
+
+  explicit Matrix (const boolMatrix& a);
+
+  explicit Matrix (const charMatrix& a);
 
   Matrix& operator = (const Matrix& a)
     {
       MArray2<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const Matrix& a) const;
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -26,25 +26,30 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
-class RowVector : public MArray<double>
+class
+RowVector : public MArray<double>
 {
 public:
 
   RowVector (void) : MArray<double> () { }
-  RowVector (int n) : MArray<double> (n) { }
+
+  explicit RowVector (int n) : MArray<double> (n) { }
+
   RowVector (int n, double val) : MArray<double> (n, val) { }
+
+  RowVector (const RowVector& a) : MArray<double> (a) { }
+
   RowVector (const MArray<double>& a) : MArray<double> (a) { }
-  RowVector (const RowVector& a) : MArray<double> (a) { }
 
   RowVector& operator = (const RowVector& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   bool operator == (const RowVector& a) const;
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -564,17 +564,17 @@ OP (const M& m, const DM& dm) \
   if (m_nr != dm_nr || m_nc != dm_nc) \
     gripe_nonconformant (#OP, m_nr, m_nc, dm_nr, dm_nc); \
   else \
     { \
       r.resize (m_nr, m_nc); \
  \
       if (m_nr > 0 && m_nc > 0) \
 	{ \
-	  r = m; \
+	  r = R (m); \
  \
 	  int len = dm.length (); \
  \
 	  for (int i = 0; i < len; i++) \
 	    r.elem(i, i) OPEQ dm.elem(i, i); \
 	} \
     } \
  \
@@ -625,24 +625,22 @@ operator * (const M& m, const DM& dm) \
   MDM_BIN_OP (R, operator -, M, DM, -=) \
   MDM_MULTIPLY_OP (R, M, DM, ZERO)
 
 #define MDM_OP_DECLS(R, M, DM) \
   MDM_BIN_OP_DECLS(R, M, DM)
 
 // diagonal matrix by matrix operations.
 
-// XXX FIXME XXX -- DM - M will not give the correct result.
-
 #define DMM_BIN_OP_DECLS(R, DM, M) \
   BIN_OP_DECL (R, operator +, DM, M); \
   BIN_OP_DECL (R, operator -, DM, M); \
   BIN_OP_DECL (R, operator *, DM, M);
 
-#define DMM_BIN_OP(R, OP, DM, M, OPEQ) \
+#define DMM_BIN_OP(R, OP, DM, M, OPEQ, PREOP) \
 R \
 OP (const DM& dm, const M& m) \
 { \
   R r; \
  \
   int dm_nr = dm.rows (); \
   int dm_nc = dm.cols (); \
  \
@@ -650,17 +648,17 @@ OP (const DM& dm, const M& m) \
   int m_nc = m.cols (); \
  \
   if (dm_nr != m_nr || dm_nc != m_nc) \
     gripe_nonconformant (#OP, dm_nr, dm_nc, m_nr, m_nc); \
   else \
     { \
       if (m_nr > 0 && m_nc > 0) \
 	{ \
-	  r = m; \
+	  r = R (PREOP m); \
  \
 	  int len = dm.length (); \
  \
 	  for (int i = 0; i < len; i++) \
 	    r.elem(i, i) OPEQ dm.elem(i, i); \
 	} \
       else \
 	r.resize (m_nr, m_nc); \
@@ -704,19 +702,19 @@ operator * (const DM& dm, const M& m) \
 	    } \
 	} \
     } \
  \
   return r; \
 }
 
 #define DMM_BIN_OPS(R, DM, M, ZERO) \
-  DMM_BIN_OP (R, operator +, DM, M, +=) \
-  DMM_BIN_OP (R, operator -, DM, M, -=) \
-  DMM_MULTIPLY_OP(R, DM, M, ZERO)
+  DMM_BIN_OP (R, operator +, DM, M, +=, ) \
+  DMM_BIN_OP (R, operator -, DM, M, +=, -) \
+  DMM_MULTIPLY_OP (R, DM, M, ZERO)
 
 #define DMM_OP_DECLS(R, DM, M) \
   DMM_BIN_OP_DECLS(R, DM, M)
 
 // diagonal matrix by diagonal matrix operations.
 
 #define DMDM_BIN_OP_DECLS(R, DM1, DM2) \
   BIN_OP_DECL (R, operator +, DM1, DM2); \
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -39,17 +39,17 @@ str_vec_compare (const void *a_arg, cons
 
 class
 string_vector : public Array<std::string>
 {
 public:
 
   string_vector (void) : Array<std::string> () { }
 
-  string_vector (int n) : Array<std::string> (n) { }
+  explicit string_vector (int n) : Array<std::string> (n) { }
 
   string_vector (const char *s) : Array<std::string> (1, s) { }
 
   string_vector (const std::string& s) : Array<std::string> (1, s) { }
 
   string_vector (const string_vector& s) : Array<std::string> (s) { }
 
   string_vector (const char * const *s);
diff --git a/src/BaseSLList.h b/src/BaseSLList.h
--- a/src/BaseSLList.h
+++ b/src/BaseSLList.h
@@ -31,17 +31,19 @@ struct BaseSLNode
 {
    union {
      struct BaseSLNode *tl;
      double dummy;  /* To force correct alignment */
    };
    void *item() {return (void*)(this+1);} // Return ((SLNode<T>*)this)->hd
 };
 
-class BaseSLList {
+class
+BaseSLList
+{
   protected:
     BaseSLNode *last;
     virtual void delete_node(BaseSLNode*node) = 0;
     virtual BaseSLNode* copy_node(const void* datum) = 0;
     virtual void copy_item(void *dst, void *src) = 0;
     virtual ~BaseSLList() { }
     BaseSLList() { last = 0; }
     void copy(const BaseSLList&);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,14 @@
 2000-02-07  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* error.cc (panic): Turn off buffering of error messages.
+	Don't call flush_octave_stdout here, verror will do it for us.	
+	(verror): Don't call flush_octave_stdout if buffering error messages.
+
 	* pt-except.cc (tree_try_catch_command::eval): Only restore
 	buffer_error_message value (by running the unwind_protect element
 	for it) if it has been saved.
 
 	* help.cc (Ftype): Return value if nargout is NOT equal to zero.
 	Delete unnecessary unwind_protect::begin_frame().
 
 	* toplev.cc (octave_config_info): Stuff lots of new config info in
diff --git a/src/DLList.h b/src/DLList.h
--- a/src/DLList.h
+++ b/src/DLList.h
@@ -30,27 +30,30 @@ Foundation, 59 Temple Place - Suite 330,
 
 struct BaseDLNode {
     BaseDLNode *bk;
     BaseDLNode *fd;
     void *item() {return (void*)(this+1);} //Return ((DLNode<T>*)this)->hd
 };
 
 template<class T>
-class DLNode : public BaseDLNode
+class
+DLNode : public BaseDLNode
 {
   public:
     T hd;
     DLNode() { }
     DLNode(const T& h, DLNode* p = 0, DLNode* n = 0)
         : hd(h) { bk = p; fd = n; }
     ~DLNode() { }
 };
 
-class BaseDLList {
+class
+BaseDLList
+{
   protected:
     BaseDLNode *h;
 
     BaseDLList() { h = 0; }
     void copy(const BaseDLList&);
     BaseDLList& operator= (const BaseDLList& a);
     virtual void delete_node(BaseDLNode*node) = 0;
     virtual BaseDLNode* copy_node(const void* datum) = 0;
@@ -74,17 +77,19 @@ class BaseDLList {
     int                   OK() const;
     void                  del(Pix& p, int dir = 1);
     void                  del_after(Pix& p);
     void                  del_front();
     void                  del_rear();
 };
 
 template <class T>
-class DLList : public BaseDLList {
+class
+DLList : public BaseDLList
+{
     //friend class          <T>DLListTrav;
 
     virtual void delete_node(BaseDLNode *node) { delete (DLNode<T>*)node; }
     virtual BaseDLNode* copy_node(const void *datum)
 	{ return new DLNode<T>(*(const T*)datum); }
     virtual void copy_item(void *dst, void *src) { *(T*)dst = *(T*)src; }
 
   public:
diff --git a/src/Map.h b/src/Map.h
--- a/src/Map.h
+++ b/src/Map.h
@@ -40,17 +40,18 @@ License as published by the Free Softwar
 #pragma interface
 #endif
 
 #include <string>
 
 #include <Pix.h>
 
 template <class C>
-class Map
+class
+Map
 {
 protected:
   int count;
   C def;
 
 public:
   Map (const C& dflt) : def (dflt) { count = 0; }
 
@@ -107,17 +108,18 @@ struct CHNode
     { return (((unsigned long) this) >> 1); }
 };
 
 #ifndef DEFAULT_INITIAL_CAPACITY
 #define DEFAULT_INITIAL_CAPACITY 8
 #endif
 
 template <class C>
-class CHMap : public Map<C>
+class
+CHMap : public Map<C>
 {
 protected:
   CHNode<C> **tab;
   unsigned int size;
 
 public:
   CHMap (const C& dflt, unsigned int sz = DEFAULT_INITIAL_CAPACITY);
 
diff --git a/src/SLList.h b/src/SLList.h
--- a/src/SLList.h
+++ b/src/SLList.h
@@ -23,28 +23,30 @@ Foundation, 59 Temple Place - Suite 330,
 #pragma interface
 #endif
 
 #include <Pix.h>
 
 #include "BaseSLList.h"
 
 template<class T>
-class SLNode : public BaseSLNode
+class
+SLNode : public BaseSLNode
 {
   public:
     T                    hd; // Data part of node
                          SLNode() { }
                          SLNode(const T& h, SLNode* t = 0)
 			     : hd(h) { tl = t; }
                          ~SLNode() { }
 };
 
 template <class T>
-class SLList : public BaseSLList
+class
+SLList : public BaseSLList
 {
   private:
     virtual void delete_node(BaseSLNode *node) { delete (SLNode<T>*)node; }
     virtual BaseSLNode* copy_node(const void *datum)
 	{ return new SLNode<T>(*(const T*)datum); }
     virtual void copy_item(void *dst, void *src) { *(T*)dst = *(T*)src; }
 
 public:
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -77,17 +77,18 @@ vwarning (const char *name, const char *
 
   octave_diary << std::endl;
   std::cerr << std::endl;
 }
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
-  flush_octave_stdout ();
+  if (! buffer_error_messages)
+    flush_octave_stdout ();
 
   bool to_beep_or_not_to_beep_p = Vbeep_on_error && ! error_state;
 
   std::ostrstream output_buf;
 
   if (to_beep_or_not_to_beep_p)
     output_buf << "\a";
   if (name)
@@ -217,20 +218,19 @@ parse_error (const char *fmt, ...)
   va_start (args, fmt);
   error_1 (0, fmt, args);
   va_end (args);
 }
 
 void
 panic (const char *fmt, ...)
 {
-  flush_octave_stdout ();
-
   va_list args;
   va_start (args, fmt);
+  buffer_error_messages = false;
   verror ("panic", fmt, args);
   va_end (args);
   abort ();
 }
 
 typedef void (*error_fun)(const char *, ...);
 
 extern octave_value_list Fsprintf (const octave_value_list&, int);
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -107,17 +107,18 @@ extern void delete_input_buffer (void *b
 
 // See if a function file has extra garbage after the end statement.
 // This needs to be defined in lex.l so that it can use yyinput() but
 // it must be called from parse.y.
 extern void check_for_garbage_after_fcn_def (void);
 
 // For communication between the lexer and parser.
 
-class lexical_feedback
+class
+lexical_feedback
 {
 public:
 
   lexical_feedback (void) { init (); }
 
   ~lexical_feedback (void) { }
 
   void init (void);
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -97,16 +97,19 @@ tree_try_catch_command::eval (void)
       error_state = 0;
 
       // For clearing the do_catch_code cleanup function.
       unwind_protect::discard ();
 
       // For restoring buffer_error_messages.
       if (catch_code)
 	unwind_protect::run ();
+
+      // Also clear the frame marker.
+      unwind_protect::discard ();
     }
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
 }
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -28,16 +28,17 @@ Software Foundation, 59 Temple Place - S
 #include <climits>
 
 #include "CColVector.h"
 #include "CDiagMatrix.h"
 #include "CMatrix.h"
 #include "EIG.h"
 #include "dDiagMatrix.h"
 #include "dMatrix.h"
+#include "mx-cm-cdm.h"
 #include "oct-cmplx.h"
 
 #include "error.h"
 #include "ov.h"
 #include "utils.h"
 #include "xpow.h"
 
 static inline int
