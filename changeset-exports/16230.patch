# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1362810023 18000
#      Sat Mar 09 01:20:23 2013 -0500
# Node ID 4bf907906134c574f8603dd6d137c4d0a83d82df
# Parent  7b7b1e4968e8d6a914d6c633c3379489fc990d2f
use a queue to hold tokens in the lexer

* lex.h, lex.ll (lexical_feedback::token_cache): New class.
(lexical_feedback::tokens): Rename from token_stack.  Declare as
token_cache, not std::stack<token *>.  Change all uses.
(lexical_feedback::reset_token_stack): Delete.

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -18,22 +18,25 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_lex_h)
 #define octave_lex_h 1
 
+#include <deque>
+#include <limits>
 #include <list>
 #include <set>
 #include <stack>
 
 #include "comment-list.h"
 #include "input.h"
+#include "token.h"
 
 extern OCTINTERP_API void cleanup_parser (void);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
 class
 stream_reader
@@ -48,19 +51,16 @@ protected:
 
 private:
 
   // No copying!
   stream_reader (const stream_reader&);
   stream_reader& operator = (const stream_reader&);
 };
 
-// Forward decl for octave_lexer::token_stack.
-class token;
-
 // For communication between the lexer and parser.
 
 class
 lexical_feedback
 {
 public:
 
   // Did eat_whitespace or eat_continuation eat a space or tab, or a
@@ -155,16 +155,77 @@ public:
       while (! context.empty ())
         context.pop ();
     }
 
   private:
 
     std::stack<int> context;
   };
+
+  class token_cache
+  {
+  public:
+
+    // Store an "unlimited" number of tokens.
+    token_cache (size_t sz_arg = std::numeric_limits<size_t>::max ())
+      : buffer (), sz (sz_arg)
+    { }
+
+    void push (token *tok)
+    {
+      if (buffer.size () == sz)
+        pop ();
+
+      buffer.push_front (tok);
+    }
+
+    void pop (void)
+    {
+      if (! empty ())
+        {
+          delete buffer.back ();
+          buffer.pop_back ();
+        }
+    }
+
+    // Direct access.
+    token *at (size_t n) { return buffer.at (n); }
+    const token *at (size_t n) const { return buffer.at (n); }
+
+    // Most recently pushed.
+    token *front (void) { return buffer.front (); }
+    const token *front (void) const { return buffer.front (); }
+
+    token *back (void) { return buffer.back (); }
+    const token *back (void) const { return buffer.back (); }
+
+    // Number of elements currently in the buffer, max of sz.
+    size_t size (void) const { return buffer.size (); }
+
+    bool empty (void) const { return buffer.empty (); }
+
+    void clear (void)
+    {
+      while (! empty ())
+        pop ();
+    }
+
+  private:
+
+    std::deque<token *> buffer;
+
+    size_t sz;
+
+    // No copying!
+
+    token_cache (const token_cache&);
+
+    token_cache& operator = (const token_cache&);
+  };
   
   lexical_feedback (void)
     : end_of_input (false), convert_spaces_to_comma (true),
       do_comma_insert (false), at_beginning_of_statement (true),
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
@@ -176,17 +237,17 @@ public:
       reading_classdef_file (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
       block_comment_nesting_level (0), token_count (0),
       current_input_line (), comment_text (), help_text (),
       fcn_file_name (), fcn_file_full_name (), looking_at_object_index (),
       parsed_function_name (), pending_local_variables (),
-      nesting_level (), token_stack ()
+      nesting_level (), tokens ()
   {
     init ();
   }
 
   ~lexical_feedback (void);
 
   void init (void);
 
@@ -317,25 +378,21 @@ public:
 
   // set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
   // is the closest nesting level a square bracket, squiggly brace or
   // a paren?
   bbp_nesting_level nesting_level;
 
-  // Stack to hold tokens so that we can delete them when the parser is
-  // reset and avoid growing forever just because we are stashing some
-  // information.
-  std::stack <token*> token_stack;
+  // Tokens generated by the lexer.
+  token_cache tokens;
 
 private:
 
-  void reset_token_stack (void);
-
   // No copying!
 
   lexical_feedback (const lexical_feedback&);
 
   lexical_feedback& operator = (const lexical_feedback&);
 };
 
 // octave_lexer inherits from lexical_feedback because we will
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -1334,17 +1334,17 @@ private:
 
   octave_lexer *lexer;
 
   char *buf;
 };
 
 lexical_feedback::~lexical_feedback (void)
 {
-  reset_token_stack ();
+  tokens.clear ();
 }
 
 void
 lexical_feedback::init (void)
 {
   // The closest paren, brace, or bracket nesting is not an object
   // index.
   looking_at_object_index.push_front (false);
@@ -1392,17 +1392,17 @@ lexical_feedback::reset (void)
 
   while (! parsed_function_name.empty ())
     parsed_function_name.pop ();
 
   pending_local_variables.clear ();
 
   nesting_level.reset ();
 
-  reset_token_stack ();
+  tokens.clear ();
 }
 
 static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
   if (! s.empty ())
@@ -1441,29 +1441,16 @@ lexical_feedback::finish_comment (octave
     // FIXME -- this result will be different if the comment follows a
     // continuation token.
     return ';';
   else
     return 0;
 }
 
 void
-lexical_feedback::reset_token_stack (void)
-{
-  // Clear out the stack of token info used to track line and
-  // column numbers.
-
-  while (! token_stack.empty ())
-    {
-      delete token_stack.top ();
-      token_stack.pop ();
-    }
-}
-
-void
 octave_lexer::input_buffer::fill (const std::string& input, bool eof_arg)
 {
   buffer = input;
   chars_left = buffer.length ();
   pos = buffer.c_str ();
   eof = eof_arg;
 }
 
@@ -3369,17 +3356,17 @@ octave_lexer::gripe_matlab_incompatible_
   gripe_matlab_incompatible (t + " used as operator");
 }
 
 void
 octave_lexer::push_token (token *tok)
 {
   YYSTYPE *lval = yyget_lval (scanner);
   lval->tok_val = tok;
-  token_stack.push (tok);
+  tokens.push (tok);
 }
 
 token *
 octave_lexer::current_token (void)
 {
   YYSTYPE *lval = yyget_lval (scanner);
   return lval->tok_val;
 }
