# HG changeset patch
# User Rik <rik@octave.org>
# Date 1393740636 28800
#      Sat Mar 01 22:10:36 2014 -0800
# Branch gui-release
# Node ID 4cf930a64fad701ac706c6160346209494c0a6b4
# Parent  fa58514e73830a83383f538a13dea76dc4302269
# Parent  11de7f82afe217020d7ec4e55b11ddb235e4f981
maint: Periodic merge of stable to gui-release.

diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -80,8 +80,9 @@ 4e50bd2946d8563d3e201cc04b3ba0720c991b06
 608e307b49149b32a6d09c2f06493d04d3af9be4 ss-3-7-5
 3a9efb68272df556dccb84c87933dd8238e88902 ss-3-7-6
 cc13924a4266fb0359f59fabdce11071e6051d48 ss-3-7-7
 d734216aa2b1022c190e6b07d7ccdd59fe15678f rc-3-8-0-1
 f1fa148766d623f7f24cf541ea8b88d8c1b63d33 rc-3-8-0-2
 b72bcf5f78cc2231e9bf2735d3b8d92779fc4dff release-3-8-0
 85d31344fb23725791bc687337295d47416b9c17 rc-3-8-1-2
 02ce68d63fba31cd14ac060c087212a032ae3202 rc-3-8-1-3
+dd669c2ae76c167613f54d6f4db0130fa2124cac rc-3-8-1-4
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -31,49 +31,49 @@ This chapter is dedicated to those who w
 * General Guidelines::
 * Octave Sources (m-files)::
 * C++ Sources::
 * Other Sources::
 @end menu
 
 @node How to Contribute
 @section How to Contribute
-The mailing list for Octave development discussion is
+The mailing list for Octave development discussions is
 @email{maintainers@@octave.org}.  Patches should be submitted to
 @url{https://savannah.gnu.org/patch/?func=additem&group=octave, Octave's patch tracker}.
-This concerns the development of Octave core, i.e., code that goes to Octave
+This concerns the development of Octave core, i.e., code that goes in to Octave
 directly.  You may consider developing and publishing a package instead;
 a great place for this is the allied Octave-Forge project
 (@url{http://octave.sourceforge.net}).  Note that the Octave core
 project is inherently more conservative and follows narrower rules.
 
 @node Building the Development Sources
 @section Building the Development Sources
 
-The directions for building from the Development sources change from
+The directions for building from the development sources change from
 time to time, so you should read the resources for developers on the web
 or in the development sources archive.  Start here:
 @url{http://www.octave.org/get-involved.html}.
 
 @node Basics of Generating a Changeset
 @section Basics of Generating a Changeset
 
-The preferable form of contribution is creating a Mercurial changeset
-and submit it to the @url{http://savannah.gnu.org/bugs/?group=octave, bug} or
+The best way to contribute is to create a Mercurial changeset and submit it to
+the @url{http://savannah.gnu.org/bugs/?group=octave, bug} or
 @url{http://savannah.gnu.org/patch/?func=additem&group=octave, patch}
 trackers@footnote{Please use the patch tracker only for patches which add new
 features.  If you have a patch to submit that fixes a bug, you should use the
 bug tracker instead.}.
 Mercurial is the source code management system currently used to develop
 Octave.  Other forms of contributions (e.g., simple diff patches) are
 also acceptable, but they slow down the review process.  If you want to
 make more contributions, you should really get familiar with Mercurial.
 A good place to start is
 @url{http://www.selenic.com/mercurial/wiki/index.cgi/Tutorial}.  There
-you will also find help how to install Mercurial.
+you will also find help about how to install Mercurial.
 
 A simple contribution sequence could look like this:
 
 @example
 @group
 hg clone http://www.octave.org/hg/octave
                              # make a local copy of the octave
                              # source repository
@@ -85,17 +85,17 @@ hg commit -m "make Octave the coolest so
 hg export -o ../cool.diff tip
                              # export the changeset to a diff
                              # file
 # attach ../cool.diff to your bug report
 @end group
 @end example
 
 You may want to get familiar with Mercurial queues to manage your
-changesets.  For working with queues you have to activate the extension
+changesets.  To work with queues you must activate the extension
 @nospell{mq} with the following entry in Mercurial's configuration file
 @file{.hgrc} (or @file{Mercurial.ini} on Windows):
 
 @example
 @group
 [extensions]
 mq=
 @end group
@@ -162,17 +162,17 @@ status.removed = red bold
 status.deleted = cyan bold
 status.unknown = black  bold
 status.ignored = black bold
 @end group
 @end example
 
 Sometimes a few further improvements for the pager extension are
 necessary.  The following options should not be enabled unless paging
-isn't working correctly:
+is not working correctly.
 
 @example
 @group
 [pager]
 # Some options for the less pager, see less(1) for their meaning.
 pager = LESS='FSRX' less
 
 # Some commands that aren't paged by default; also enable paging
@@ -180,61 +180,59 @@ pager = LESS='FSRX' less
 attend = tags, help, annotate, cat, diff, export, status, \
          outgoing, incoming
 @end group
 @end example
 
 Enabling the described extensions should immediately lead to a difference
 when using the command line version of @nospell{hg}.  Of these options, the
 only one that enables a new command is @nospell{graphlog}.  It is recommanded
-that you use the command @code{hg glog} instead of @code{hg log} for a better
-feel what commits are being based on.
+that to use the command @code{hg glog}, instead of @code{hg log}, for a better
+feel about what commits are being based on.
 
 @node General Guidelines
 @section General Guidelines
 
-All Octave's sources are distributed under the General Public License
+All Octave's sources are distributed under the GNU General Public License
 (GPL).  Currently, Octave uses GPL version 3.  For details about this
 license, see @url{http://www.gnu.org/licenses/gpl.html}.  Therefore,
 whenever you create a new source file, it should have the following
 comment header (use appropriate year, name and comment marks):
 
 @example
 ## Copyright (C) 1996-2013 John W. Eaton <jwe@@octave.org>
 ##
 ## This file is part of Octave.
 ##
-## Octave is free software; you can redistribute it and/or
-## modify it under the terms of the GNU General Public
-## License as published by the Free Software Foundation;
-## either version 3 of the License, or (at your option) any
-## later version.
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
 ##
-## Octave is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied
-## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-## PURPOSE.  See the GNU General Public License for more
-## details.
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
 ##
-## You should have received a copy of the GNU General Public
-## License along with Octave; see the file COPYING.  If not,
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not,
 ## see <http://www.gnu.org/licenses/>.
 @end example
 
 Always include commit messages in changesets.  After making your source
 changes, record and briefly describe the changes in your commit message.
 You should have previously configured your @file{.hgrc} (or
 @file{Mercurial.ini} on Windows) with your name and email, which will
-get automatically added to your commit message.  Your commit message
+be automatically added to your commit message.  Your commit message
 should have a brief one-line explanation of what the commit does.  If you
 are patching a bug, this one-line explanation should mention the bug
-number at the end.  If your change is small and only touches one file,
-this is typically sufficient.  If you are modifying several files or
+number at the end.  If your change is small and only touches one file then
+this is typically sufficient.  If you are modifying several files, or
 several parts of one file, you should enumerate your changes roughly
-following the GNU coding standards on changelogs, like the following
+following the GNU coding standards for changelogs, as in the following
 example:
 
 @example
 @group
 look for methods before constructors
 
 * symtab.cc (symbol_table::fcn_info::fcn_info_rep::find):
 Look for class methods before constructors, contrary to @sc{matlab}
@@ -243,62 +241,63 @@ documentation.
 * test/ctor-vs-method: New directory of test classes.
 * test/test_ctor_vs_method.m: New file.
 * test/Makefile.am: Include ctor-vs-method/module.mk.
 (FCN_FILES): Include test_ctor_vs_method.m in the list.
 @end group
 @end example
 
 @noindent
-In this example, the names of files is mentioned, and in parentheses the
-name of the function in that file that was modified.  There is no need to
-mention the function for m-files that only contain one function.  The
-commit message should describe what is changed, not why.  Any explanation
-of why a change is needed should appear as comments in the code,
-particularly if there is something that might not be obvious to someone
+In this example, the names of the file changed is listed first, and in
+parentheses the name of the function in that file that was modified.  There
+is no need to mention the function for m-files that only contain one function.
+The commit message should describe what was changed, not why it was changed.
+Any explanation for why a change is needed should appear as comments in the
+code, particularly if there is something that might not be obvious to someone
 reading it later.
 
 When submitting code which addresses a known bug on the Octave bug
 tracker (@url{http://bugs.octave.org}), please add '(bug #XXXXX)' to the
 first line of the commit messages.  For example:
 
 @example
 @group
 Fix bug for complex input for gradient (bug #34292).
 @end group
 @end example
 
 The preferred comment mark for places that may need further attention is
-FIXME.
+@code{FIXME:}.
 
 @node Octave Sources (m-files)
 @section Octave Sources (m-files)
 
 Don't use tabs.  Tabs cause trouble.  If you are used to them, set up
 your editor so that it converts tabs to spaces.  Indent the bodies of
-the statement blocks.  Recommended indent is 2 spaces.  When calling
+statement blocks.  The recommended indent is 2 spaces.  When calling
 functions, put spaces after commas and before the calling parentheses,
 like this:
 
 @example
   x = max (sin (y+3), 2);
 @end example
 
 @noindent
-An exception are matrix and vector constructors:
+An exception are matrix or cell constructors:
 
 @example
   [sin(x), cos(x)]
+  @{sin(x), cos(x)@}
 @end example
 
 @noindent
 Here, putting spaces after @code{sin}, @code{cos} would result in a
-parse error.  In indexing expression, do not put a space after the
+parse error.  For an indexing expression, do not put a space after the
 identifier (this differentiates indexing and function calls nicely).
-The space after comma is not necessary if index expressions are simple,
+The space after a comma is not necessary if index expressions are simple,
 i.e., you may write
 
 @example
   A(:,i,j)
 @end example
 
 @noindent
 but
@@ -308,20 +307,20 @@ but
 @end example
 
 Use lowercase names if possible.  Uppercase is acceptable for variable
 names consisting of 1-2 letters.  Do not use mixed case names.  Function
 names must be lowercase.  Function names are global, so choose them
 wisely.
 
 Always use a specific end-of-block statement (like @code{endif},
-@code{endswitch}) rather than generic @code{end}.
+@code{endswitch}) rather than the generic @code{end}.
 
-Enclose the @code{if}, @code{while}, @code{until} and @code{switch}
-conditions in parentheses, like in C:
+Enclose the @code{if}, @code{while}, @code{until}, and @code{switch}
+conditions in parentheses, as in C:
 
 @example
 @group
 if (isvector (a))
   s = sum (a);
 endif
 @end group
 @end example
@@ -354,17 +353,17 @@ matches_patterns (const string_vector& p
 @end example
 
 @noindent
 The function name should start in column 1, and multi-line argument
 lists should be aligned on the first char after the open parenthesis.
 You should put a space before the left open parenthesis and after commas,
 for both function definitions and function calls.
 
-Recommended indent is 2 spaces.  When indenting, indent the statement
+The recommended indent is 2 spaces.  When indenting, indent the statement
 after control structures (like @code{if}, @code{while}, etc.).  If there
 is a compound statement, indent @emph{both} the curly braces and the
 body of the statement (so that the body gets indented by @emph{two}
 indents).  Example:
 
 @example
 @group
 if (have_args)
@@ -390,22 +389,22 @@ innermost braces enclosing the split.  E
 @group
 SVD::type type = ((nargout == 0 || nargout == 1)
                   ? SVD::sigma_only
                   : (nargin == 2) ? SVD::economy : SVD::std);
 @end group
 @end example
 
 @noindent
-Consider putting extra braces around a multiline expression to make it
+Consider putting extra braces around a multi-line expression to make it
 more readable, even if they are not necessary.  Also, do not hesitate to
 put extra braces anywhere if it improves clarity.
 
-Declare variables just before they're needed.  Use local variables of
-blocks---it helps optimization.  Don't write multi-line variable
+Declare variables just before they are needed.  Use local variables of
+blocks---it helps optimization.  Don't write a multi-line variable
 declaration with a single type specification and multiple variables.  If
 the variables don't fit on single line, repeat the type specification.
 Example:
 
 @example
 @group
 octave_value retval;
 
diff --git a/doc/interpreter/external.txi b/doc/interpreter/external.txi
--- a/doc/interpreter/external.txi
+++ b/doc/interpreter/external.txi
@@ -1754,17 +1754,17 @@ Hello Octave world!
   21 22
 $
 @end group
 @end example
 
 Note that the application @code{standalone} will be dynamically linked
 against the Octave libraries and any Octave support libraries.  The above
 allows the Octave math libraries to be used by an application.  It does
-not, however, allow the script files, oct-files, or builtin functions of
+not, however, allow the script files, oct-files, or built-in functions of
 Octave to be used by the application.  To do that the Octave interpreter
 needs to be initialized first.  An example of how to do this can then be
 seen in the code
 
 @example
 @EXAMPLEFILE(embedded.cc)
 @end example
 
@@ -1775,27 +1775,27 @@ which, as before, is compiled and run as
 @group
 $ mkoctfile --link-stand-alone embedded.cc -o embedded
 $ ./embedded
 GCD of [10, 15] is 5
 $
 @end group
 @end example
 
-It is worth noting that, if only builtin functions are to be called from 
+It is worth noting that, if only built-in functions are to be called from 
 a C++ standalone program, then it does not need to initialize the 
-interpreter to do so.  The general rule is that, for a builtin 
+interpreter to do so.  The general rule is that, for a built-in 
 function named @code{function_name} in the interpreter, there will be
 a C++ function named @code{Ffunction_name} (note the prepended capital 
-@code{F}) accessible in the C++ API@.  The declarations for all builtin 
+@code{F}) accessible in the C++ API@.  The declarations for all built-in 
 functions are collected in the header file @code{builtin-defun-decls.h}.
 This feature should be used with care as the list of built-in functions can
 change.  No guarantees can be made that a function that is currently built in
 won't be implemented as a .m file or as a dynamically linked function in the
-future.  An example of how to call builtin functions from C++ can be seen in the
+future.  An example of how to call built-in functions from C++ can be seen in the
 code
 
 @example
 @EXAMPLEFILE(standalonebuiltin.cc)
 @end example
 
 @noindent
 which, again, is compiled and run as a standalone application with
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1128,33 +1128,30 @@ which contains the current function.
 @item Class constructor
 A function that constuctors a user class as defined in chapter 
 @ref{Object Oriented Programming}.
 
 @item Class method
 An overloaded function of a class as in chapter
 @ref{Object Oriented Programming}.
 
-@item Legacy Dispatch
-An overloaded function as defined by @code{dispatch}.
-
 @item Command-line Function
 A function that has been defined on the command-line.
 
 @item Autoload function
 A function that is marked as autoloaded with @xref{XREFautoload,,autoload}.
 
 @item A Function on the Path
 A function that can be found on the users load-path.  There can also be
 Oct-file, mex-file or m-file versions of this function and the precedence
 between these versions are in that order.
 
 @item Built-in function
-A function that is builtin to Octave itself such as @code{numel},
-@code{size}, etc.
+A function that is a part of core Octave such as @code{numel}, @code{size},
+etc.
 @end enumerate
 
 @node Script Files
 @section Script Files
 
 A script file is a file containing (almost) any sequence of Octave
 commands.  It is read and evaluated just as if you had typed each
 command at the Octave prompt, and provides a convenient way to perform a
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -360,18 +360,18 @@ define a function for use in multiple te
 
 @item %!endfunction
 close a function definition
 
 @item %!assert (x, y, tol)
 shorthand for @code{%!test assert (x, y, tol)}
 @end table
 
-You can also create test scripts for builtins and your own C++
-functions.  To do so put a file with the bare function name (no .m
+You can also create test scripts for built-in functions and your own C++
+functions.  To do so, put a file with the bare function name (no .m
 extension) in a directory in the load path and it will be discovered by
 the @code{test} function.  Alternatively, you can embed tests directly in your
 C++ code:
 
 @example
 @group
 /*
 %!test disp ("this is a test")
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3271,17 +3271,17 @@ octave_stream::read (const Array<double>
                   char *input_buf = new char [input_buf_size];
 
                   is.read (input_buf, input_buf_size);
 
                   size_t gcount = is.gcount ();
 
                   char_count += gcount;
 
-                  size_t nel = gcount / input_elt_size;
+                  octave_idx_type nel = gcount / input_elt_size;
 
                   count += nel;
 
                   input_buf_list.push_back (input_buf);
 
                   if (is && skip != 0 && nel == block_size)
                     {
                       // Seek to skip.  If skip would move past EOF,
@@ -3292,32 +3292,37 @@ octave_stream::read (const Array<double>
                       seek (0, SEEK_END);
 
                       off_t eof_pos = tell ();
 
                       // Is it possible for this to fail to return us to
                       // the original position?
                       seek (orig_pos, SEEK_SET);
 
-                      size_t remaining = eof_pos - orig_pos;
+                      off_t remaining = eof_pos - orig_pos;
 
                       if (remaining < skip)
                         seek (0, SEEK_END);
                       else
                         seek (skip, SEEK_CUR);
 
                       if (! is)
                         break;
                     }
                 }
 
               if (read_to_eof)
                 {
                   if (nc < 0)
-                    nc = count / nr + 1;
+                    {
+                      nc = count / nr;
+
+                      if (count % nr != 0)
+                        nc ++;
+                    }
                   else
                     nr = count;
                 }
               else if (count == 0)
                 {
                   nr = 0;
                   nc = 0;
                 }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -544,17 +544,24 @@ octave_bool_matrix::as_mxArray (void) co
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (logical, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} logical (@var{x})\n\
-Convert @var{x} to logical type.\n\
+Convert the numeric object @var{x} to logical type.\n\
+\n\
+Any non-zero values will be converted to true (1) while zero values\n\
+will be converted to false (0).  The non-numeric value NaN cannot be\n\
+converted and will produce an error.\n\
+\n\
+Compatibility Note: Octave accepts complex values as input, whereas\n\
+@sc{matlab} issues an error.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1284,20 +1284,22 @@ Return true if @var{x} is a cell array o
 
 DEFUN (cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cell (@var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} cell ([@var{m} @var{n} @dots{}])\n\
 Create a new cell array object.\n\
+\n\
 If invoked with a single scalar integer argument, return a square\n\
 @nospell{NxN} cell array.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
 the given dimensions.\n\
+@seealso{cellstr, mat2cell, num2cell, struct2cell}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector dims;
 
@@ -1362,19 +1364,25 @@ character string.\n\
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} cellstr (@var{string})\n\
+@deftypefn {Built-in Function} {@var{cstr} =} cellstr (@var{strmat})\n\
 Create a new cell array object from the elements of the string\n\
-array @var{string}.\n\
+array @var{strmat}.\n\
+\n\
+Each row of @var{strmat} becomes an element of @var{cstr}.  Any trailing\n\
+spaces in a row are deleted before conversion.\n\
+\n\
+To convert back from a cellstr to a character array use @code{char}.\n\
+@seealso{cell, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_value_list tmp = Fiscellstr (args, 1);
 
@@ -1395,21 +1403,21 @@ array @var{string}.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
+@deftypefn {Built-in Function} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 If @var{f} is the number of fields in the structure, the resulting\n\
 cell array will have a dimension vector corresponding to\n\
-@code{[@var{F} size(@var{S})]}.  For example:\n\
+@code{[@var{f} size(@var{s})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 s = struct (\"name\", @{\"Peter\", \"Hannah\", \"Robert\"@},\n\
            \"age\", @{23, 16, 3@});\n\
 c = struct2cell (s)\n\
    @result{} c = @{2x1x3 Cell Array@}\n\
 c(1,1,:)(:)\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -2161,17 +2161,17 @@ Return true if @var{x} is a class object
   return retval;
 }
 
 DEFUN (ismethod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismethod (@var{x}, @var{method})\n\
 Return true if @var{x} is a class object and the string @var{method}\n\
 is a method of this class.\n\
-@seealso{isobject}\n\
+@seealso{isprop, isobject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       octave_value arg = args(0);
 
@@ -2263,16 +2263,17 @@ is_built_in_class (const std::string& cn
 
 DEFUN (superiorto, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} superiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a higher precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
+@seealso{inferiorto}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("superiorto: invalid call from outside class constructor");
@@ -2307,16 +2308,17 @@ This function may only be called from a 
 
 DEFUN (inferiorto, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inferiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a lower precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
+@seealso{superiorto}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
   if ((! fcn) || (! fcn->is_class_constructor ()))
     {
       error ("inferiorto: invalid call from outside class constructor");
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1654,19 +1654,59 @@ make_fcn_handle (const std::string& nm, 
 %!      "|", "or"};
 %! for i = 1:rows (x)
 %!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
 DEFUN (functions, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} functions (@var{fcn_handle})\n\
-Return a struct containing information about the function handle\n\
+@deftypefn {Built-in Function} {@var{s} =} functions (@var{fcn_handle})\n\
+Return a structure containing information about the function handle\n\
 @var{fcn_handle}.\n\
+\n\
+The structure @var{s} always contains these 3 fields:\n\
+\n\
+@table @asis\n\
+@item function\n\
+The function name.  For an anonymous function (no name) this will be the\n\
+actual function definition.\n\
+\n\
+@item type\n\
+Type of the function.\n\
+\n\
+@table @asis\n\
+@item anonymous\n\
+The function is anonymous.\n\
+\n\
+@item private\n\
+The function is private.\n\
+\n\
+@item overloaded\n\
+The function overloads an existing function.\n\
+\n\
+@item simple\n\
+The function is a built-in or m-file function.\n\
+\n\
+@item subfunction\n\
+The function is a subfunction within an m-file.\n\
+@end table\n\
+\n\
+@item file\n\
+The m-file that will be called to perform the function.  This field is empty\n\
+for anonymous and built-in functions.\n\
+@end table\n\
+\n\
+In addition, some function types may return more information in additional\n\
+fields.\n\
+\n\
+@strong{Warning:} @code{functions} is provided for debugging purposes only.\n\
+It's behavior may change in the future and programs should not depend on a\n\
+particular output.\n\
+\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_fcn_handle *fh = args(0).fcn_handle_value ();
 
@@ -1755,16 +1795,17 @@ Return a struct containing information a
   return retval;
 }
 
 DEFUN (func2str, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by\n\
 the function handle @var{fcn_handle}.\n\
+@seealso{str2func, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_fcn_handle *fh = args(0).fcn_handle_value ();
 
@@ -1794,16 +1835,17 @@ the function handle @var{fcn_handle}.\n\
 
 DEFUN (str2func, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
+@seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       std::string nm = args(0).string_value ();
@@ -1834,17 +1876,17 @@ functions are ignored in the lookup.\n\
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
 */
 
 DEFUN (is_function_handle, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
-@seealso{isa, typeinfo, class}\n\
+@seealso{isa, typeinfo, class, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     retval = args(0).is_function_handle ();
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -634,31 +634,37 @@ octave_fcn_inline::convert_to_str_intern
 }
 
 DEFUNX ("inline", Finline, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} inline (@var{str})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
+\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself.  The generated\n\
 function arguments will then be in alphabetical order.  It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
 ambiguity between their use as a variable or their use as an inbuilt\n\
 constant.  All arguments followed by a parenthesis are considered\n\
 to be functions.  If no arguments are found, a function taking a single\n\
 argument named @code{x} will be created.\n\
 \n\
 If the second and subsequent arguments are character strings,\n\
 they are the names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
 @qcode{\"x\"}, @qcode{\"P1\"}, @dots{}, @qcode{\"P@var{N}\"}.\n\
-@seealso{argnames, formula, vectorize}\n\
+\n\
+Programming Note: The use of @code{inline} is discouraged and it may be\n\
+removed from a future version of Octave.  The preferred way to create\n\
+functions from strings is through the use of anonymous functions\n\
+(@pxref{Anonymous Functions}) or @code{str2func}.\n\
+@seealso{argnames, formula, vectorize, str2func}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_int16_sc
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
                                      "int16 scalar", "int16");
 
 DEFUN (int16, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
+@seealso{int8, uint8, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
 
 /*
 %!assert (class (int16 (1)), "int16")
 %!assert (int16 (1.25), int16 (1))
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_int32_sc
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
                                      "int32 scalar", "int32");
 
 DEFUN (int32, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
+@seealso{int8, uint8, int16, uint16, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
 
 /*
 %!assert (class (int32 (1)), "int32")
 %!assert (int32 (1.25), int32 (1))
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_int64_sc
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
                                      "int64 scalar", "int64");
 
 DEFUN (int64, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
+@seealso{int8, uint8, int16, uint16, int32, uint32, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
 
 /*
 %!assert (class (int64 (1)), "int64")
 %!assert (int64 (1.25), int64 (1))
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_int8_sca
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
                                      "int8 scalar", "int8");
 
 DEFUN (int8, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
+@seealso{uint8, int16, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
 
 /*
 %!assert (class (int8 (1)), "int8")
 %!assert (int8 (1.25), int8 (1))
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -182,20 +182,20 @@ octave_oncleanup::print_raw (std::ostrea
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN (onCleanup, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{c} =} onCleanup (@var{action})\n\
+@deftypefn {Built-in Function} {@var{obj} =} onCleanup (@var{function})\n\
 Create a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array\n\
-elements) or returned from a function, @var{action} will be executed after\n\
+elements) or returned from a function, @var{function} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1758,22 +1758,24 @@ octave_scalar_struct::fast_elem_insert_s
       return true;
     }
   else
     return false;
 }
 
 DEFUN (struct, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{s} =} struct ()\n\
+@deftypefnx {Built-in Function} {@var{s} =} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
+@deftypefnx {Built-in Function} {@var{s} =} struct (@var{obj})\n\
 \n\
 Create a scalar or array structure and initialize its values.  The\n\
-@var{field1}, @var{field2}, @dots{} variables are strings giving the\n\
+@var{field1}, @var{field2}, @dots{} variables are strings specifying the\n\
 names of the fields and the @var{value1}, @var{value2}, @dots{}\n\
-variables can be any type.\n\
+variables can be of any type.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize\n\
 its values.  The dimensions of each cell array of values must match.\n\
 Singleton cells and non-cell values are repeated so that they fill\n\
 the entire array.  If the cells are empty, create an empty structure\n\
 array with the specified field names.\n\
 \n\
 If the argument is an object, return the underlying struct.\n\
@@ -1798,25 +1800,26 @@ struct (\"foo\", @{ @{@} @})\n\
 struct (\"foo\", @{1, 2, 3@})\n\
   @result{} 1x3 struct array containing the fields:\n\
     foo\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
-The first case is an ordinary scalar struct, one field, one value.  The\n\
+The first case is an ordinary scalar struct---one field, one value.  The\n\
 second produces an empty struct array with one field and no values, since\n\
 s being passed an empty cell array of struct array values.  When the value is\n\
 a cell array containing a single entry, this becomes a scalar struct with\n\
 that single entry as the value of the field.  That single entry happens\n\
 to be an empty cell array.\n\
 \n\
 Finally, if the value is a non-scalar cell array, then @code{struct}\n\
 produces a struct @strong{array}.\n\
+@seealso{cell2struct, fieldnames, orderfields, getfield, setfield, rmfield, structfun}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   // struct ([]) returns an empty struct.
 
@@ -2001,20 +2004,22 @@ Implements @code{fieldnames()} for struc
   else
     retval = Cell (keys);
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} isfield (@var{x}, @var{name})\n\
-Return true if the @var{x} is a structure and it\n\
-includes an element named @var{name}.  If @var{name} is a cell\n\
-array of strings then a logical array of equal dimension is returned.\n\
+@deftypefn  {Built-in Function} {} isfield (@var{x}, \"@var{name}\")\n\
+@deftypefnx {Built-in Function} {} isfield (@var{x}, @var{name})\n\
+Return true if the @var{x} is a structure and it includes an element named\n\
+@var{name}.  If @var{name} is a cell array of strings then a logical array of\n\
+equal dimension is returned.\n\
+@seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
@@ -2060,16 +2065,17 @@ array of strings then a logical array of
 
   return retval;
 }
 
 DEFUN (nfields, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} nfields (@var{s})\n\
 Return the number of fields of the structure @var{s}.\n\
+@seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_map ())
     {
@@ -2090,17 +2096,18 @@ Return the number of fields of the struc
 %!assert (isfield ({1}, "c"), false)
 %!assert (isfield (struct ("a", "1"), 10), false)
 %!assert (isfield (struct ("a", "b"), "a "), false)
 %!assert (isfield (struct ("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
+@deftypefn  {Built-in Function} {} cell2struct (@var{cell}, @var{fields})\n\
+@deftypefnx {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
 If @var{dim} is omitted, a value of 1 is assumed.\n\
 \n\
 @example\n\
 @group\n\
 A = cell2struct (@{\"Peter\", \"Hannah\", \"Robert\";\n\
@@ -2110,16 +2117,17 @@ A(1)\n\
    @result{}\n\
       @{\n\
         Name   = Peter\n\
         Height = 185\n\
       @}\n\
 \n\
 @end group\n\
 @end example\n\
+@seealso{struct2cell, cell2mat, struct}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
@@ -2226,20 +2234,20 @@ A(1)\n\
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} rmfield (@var{s}, \"@var{f}\")\n\
 @deftypefnx {Built-in Function} {@var{s} =} rmfield (@var{s}, @var{f})\n\
-Return a copy of the structure (array) @var{s} with the field @var{f}\n\
+Return a @emph{copy} of the structure (array) @var{s} with the field @var{f}\n\
 removed.  If @var{f} is a cell array of strings or a character array, remove\n\
 each of the named fields.\n\
-@seealso{cellstr, iscellstr, setfield}\n\
+@seealso{orderfields, fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
@@ -2297,32 +2305,36 @@ DEFUN (struct_levels_to_print, args, nar
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
+@seealso{print_struct_array_contents}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
-array contents.  If true, values of struct array elements are printed.\n\
-This variable does not affect scalar structures.  Their elements\n\
-are always printed.  In both cases, however, printing will be limited to\n\
+array contents.\n\
+\n\
+If true, values of struct array elements are printed.\n\
+This variable does not affect scalar structures whose elements are always\n\
+printed.  In both cases, however, printing will be limited to\n\
 the number of levels specified by @var{struct_levels_to_print}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
+@seealso{struct_levels_to_print}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_struct_array_contents);
 }
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -610,18 +610,19 @@ octave_value_typeinfo::do_installed_type
 }
 
 DEFUN (typeinfo, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} typeinfo ()\n\
 @deftypefnx {Built-in Function} {} typeinfo (@var{expr})\n\
 \n\
 Return the type of the expression @var{expr}, as a string.  If\n\
-@var{expr} is omitted, return an cell array of strings containing all the\n\
+@var{expr} is omitted, return a cell array of strings containing all the\n\
 currently installed data types.\n\
+@seealso{class, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = Cell (octave_value_typeinfo::installed_type_names ());
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_uint16_s
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
                                      "uint16 scalar", "uint16");
 
 DEFUN (uint16, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
+@seealso{int8, uint8, int16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
 
 /*
 %!assert (class (uint16 (1)), "uint16")
 %!assert (uint16 (1.25), uint16 (1))
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_uint32_s
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
                                      "uint32 scalar", "uint32");
 
 DEFUN (uint32, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
+@seealso{int8, uint8, int16, uint16, int32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
 
 /*
 %!assert (class (uint32 (1)), "uint32")
 %!assert (uint32 (1.25), uint32 (1))
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_uint64_s
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
                                      "uint64 scalar", "uint64");
 
 DEFUN (uint64, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
+@seealso{int8, uint8, int16, uint16, int32, uint32, int64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
 
 /*
 %!assert (class (uint64 (1)), "uint64")
 %!assert (uint64 (1.25), uint64 (1))
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -72,16 +72,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_uint8_sc
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
                                      "uint8 scalar", "uint8");
 
 DEFUN (uint8, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
+@seealso{int8, int16, uint16, int32, uint32, int64, uint64}\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
 
 /*
 %!assert (class (uint8 (1)), "uint8")
 %!assert (uint8 (1.25), uint8 (1))
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -789,20 +789,34 @@ octave_user_function::restore_warning_st
 DEFUN (nargin, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
 Octave.\n\
 \n\
-If called with the optional argument @var{fcn}, a function name or handle,\n\
+If called with the optional argument @var{fcn}---a function name or handle---\n\
 return the declared number of arguments that the function can accept.\n\
-If the last argument is @var{varargin} the returned value is negative.\n\
-This feature does not work on builtin functions.\n\
+\n\
+If the last argument to @var{fcn} is @var{varargin} the returned value is\n\
+negative.  For example, the function @code{union} for sets is declared as\n\
+\n\
+@example\n\
+@group\n\
+function [y, ia, ib] = union (a, b, varargin)\n\
+\n\
+and\n\
+\n\
+nargin (\"union\")\n\
+@result{} -3\n\
+@end group\n\
+@end example\n\
+\n\
+Programming Note: @code{nargin} does not work on built-in functions.\n\
 @seealso{nargout, varargin, isargout, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -853,18 +867,18 @@ This feature does not work on builtin fu
   return retval;
 }
 
 DEFUN (nargout, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
 Within a function, return the number of values the caller expects to\n\
-receive.  If called with the optional argument @var{fcn}, a function\n\
-name or handle, return the number of declared output values that the\n\
+receive.  If called with the optional argument @var{fcn}---a function\n\
+name or handle---return the number of declared output values that the\n\
 function can produce.  If the final output argument is @var{varargout}\n\
 the returned value is negative.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 f ()\n\
 @end example\n\
@@ -872,38 +886,38 @@ f ()\n\
 @noindent\n\
 will cause @code{nargout} to return 0 inside the function @code{f} and\n\
 \n\
 @example\n\
 [s, t] = f ()\n\
 @end example\n\
 \n\
 @noindent\n\
-will cause @code{nargout} to return 2 inside the function\n\
-@code{f}.\n\
+will cause @code{nargout} to return 2 inside the function @code{f}.\n\
 \n\
 In the second usage,\n\
 \n\
 @example\n\
 nargout (@@histc) \% or nargout (\"histc\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will return 2, because @code{histc} has two outputs, whereas\n\
 \n\
 @example\n\
-nargout (@@deal)\n\
+nargout (@@imread)\n\
 @end example\n\
 \n\
 @noindent\n\
-will return -1, because @code{deal} has a variable number of outputs.\n\
+will return -2, because @code{imread} has two outputs and the second is\n\
+@var{varargout}.\n\
 \n\
-At the top level, @code{nargout} with no argument is undefined.\n\
-@code{nargout} does not work on builtin functions.\n\
-@code{nargout} returns -1 for all anonymous functions.\n\
+At the top level, @code{nargout} with no argument is undefined and will\n\
+produce an error.  @code{nargout} does not work for built-in functions and\n\
+returns -1 for all anonymous functions.\n\
 @seealso{nargin, varargin, isargout, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -981,18 +995,19 @@ At the top level, @code{nargout} with no
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
+\n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
-subsasgn method of a user-defined class.\n\
+the subsasgn method of a user-defined class.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
@@ -1016,17 +1031,17 @@ static bool isargout1 (int nargout, cons
   else
     return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
-@var{k} will be assigned on output to a variable.  If the result is false,\n\
+@var{k} will be assigned to a variable on output.  If the result is false,\n\
 the argument has been ignored during the function call through the use of\n\
 the tilde (~) special output argument.  Functions can use @code{isargout} to\n\
 avoid performing unnecessary calculations for outputs which are unwanted.\n\
 \n\
 If @var{k} is outside the range @code{1:max (nargout)}, the function returns\n\
 false.  @var{k} can also be an array, in which case the function works\n\
 element-by-element and a logical array is returned.  At the top level,\n\
 @code{isargout} returns an error.\n\
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2897,17 +2897,17 @@ Perform the subscripted element selectio
 the subscript specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with\n\
 fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
 are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
-The following example shows how to extract the two first columns of\n\
+The following example shows how to extract the first two columns of\n\
 a matrix\n\
 \n\
 @example\n\
 @group\n\
 val = magic (3)\n\
     @result{} val = [ 8   1   6\n\
                3   5   7\n\
                4   9   2 ]\n\
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -1878,34 +1878,39 @@ strip_trailing_whitespace (char *s)
   return retval;
 }
 
 DEFUN (__display_tokens__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __display_tokens__ ()\n\
 Query or set the internal variable that determines whether Octave's\n\
 lexer displays tokens as they are read.\n\
+@seealso{__lexer_debug_flag__, __token_count__}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (display_tokens);
 }
 
 DEFUN (__token_count__, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __token_count__ ()\n\
-Number of language tokens processed since Octave startup.\n\
+Return the number of language tokens processed since Octave startup.\n\
+@seealso{__lexer_debug_flag__, __display_tokens__}\n\
 @end deftypefn")
 {
   return octave_value (Vtoken_count);
 }
 
 DEFUN (__lexer_debug_flag__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val}))\n\
-Undocumented internal function.\n\
+@deftypefn  {Built-in Function} {@var{val} =} __lexer_debug_flag__ ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} __lexer_debug_flag__ (@var{new_val})\n\
+Query or set the internal flag that determines whether Octave's lexer prints\n\
+debug information as it processes an expression.\n\
+@seealso{__display_tokens__, __token_count__, __parse_debug_flag__}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   retval = set_internal_variable (lexer_debug_flag, args, nargout,
                                   "__lexer_debug_flag__");
 
   return retval;
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3704,48 +3704,49 @@ load_fcn_from_file (const std::string& f
         }
     }
 
   return retval;
 }
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} autoload (@var{function}, @var{file})\n\
-@deftypefnx {Built-in Function} {} autoload (@dots{}, @asis{\"remove\"})\n\
+@deftypefn  {Built-in Function} {@var{autoload_map} =} autoload ()\n\
+@deftypefnx {Built-in Function} {} autoload (@var{function}, @var{file})\n\
+@deftypefnx {Built-in Function} {} autoload (@dots{}, \"remove\")\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
 The second argument, @var{file}, should be an absolute file name or\n\
 a file name in the same directory as the function or script from which\n\
-the autoload command was run.  @var{file} should not depend on the\n\
+the autoload command was run.  @var{file} @emph{should not} depend on the\n\
 Octave load path.\n\
 \n\
 Normally, calls to @code{autoload} appear in PKG_ADD script files that\n\
 are evaluated when a directory is added to Octave's load path.  To\n\
 avoid having to hardcode directory names in @var{file}, if @var{file}\n\
 is in the same directory as the PKG_ADD script then\n\
 \n\
 @example\n\
 autoload (\"foo\", \"bar.oct\");\n\
 @end example\n\
 \n\
 @noindent\n\
 will load the function @code{foo} from the file @code{bar.oct}.  The above\n\
-usage when @code{bar.oct} is not in the same directory or usages such as\n\
+usage when @code{bar.oct} is not in the same directory, or usages such as\n\
 \n\
 @example\n\
 autoload (\"foo\", file_in_loadpath (\"bar.oct\"))\n\
 @end example\n\
 \n\
 @noindent\n\
 are strongly discouraged, as their behavior may be unpredictable.\n\
 \n\
 With no arguments, return a structure containing the current autoload map.\n\
 \n\
-If a third argument @asis{'remove'} is given, the function is cleared and\n\
+If a third argument @qcode{\"remove\"} is given, the function is cleared and\n\
 not loaded anymore during the current Octave session.\n\
 \n\
 @seealso{PKG_ADD}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -3933,21 +3934,22 @@ source_file (const std::string& file_nam
     }
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpathext\")\n\
-Return the name of the currently executing file.  At the top-level,\n\
-return the empty string.  Given the argument @qcode{\"fullpath\"},\n\
-include the directory part of the file name, but not the extension.\n\
-Given the argument @qcode{\"fullpathext\"}, include the directory part\n\
-of the file name and the extension.\n\
+Return the name of the currently executing file.\n\
+\n\
+When called from outside an m-file return the empty string.  Given the\n\
+argument @qcode{\"fullpath\"}, include the directory part of the file name,\n\
+but not the extension.  Given the argument @qcode{\"fullpathext\"}, include\n\
+the directory part of the file name and the extension.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
@@ -3999,19 +4001,21 @@ of the file name and the extension.\n\
     }
 
   return retval;
 }
 
 DEFUN (source, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} source (@var{file})\n\
-Parse and execute the contents of @var{file}.  This is equivalent to\n\
-executing commands from a script file, but without requiring the file to\n\
-be named @file{@var{file}.m}.\n\
+Parse and execute the contents of @var{file}.\n\
+\n\
+This is equivalent to executing commands from a script file, but without\n\
+requiring the file to be named @file{@var{file}.m}.\n\
+@seealso{run}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
@@ -4171,17 +4175,17 @@ instead.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (builtin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@dots{}] =} builtin (@var{f}, @dots{})\n\
+@deftypefn {Built-in Function} {[@dots{}] =} builtin (@var{f}, @dots{})\n\
 Call the base function @var{f} even if @var{f} is overloaded to\n\
 another function for the given type signature.\n\
 \n\
 This is normally useful when doing object-oriented programming and there\n\
 is a requirement to call one of Octave's base functions rather than\n\
 the overloaded one of a new class.\n\
 \n\
 A trivial example which redefines the @code{sin} function to be the\n\
@@ -4338,38 +4342,40 @@ DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} eval (@var{try})\n\
 @deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
-The following example makes the variable @var{A} with the approximate\n\
-value 3.1416 available.\n\
+The following example creates the variable @var{A} with the approximate\n\
+value of 3.1416 in the current workspace.\n\
 \n\
 @example\n\
 eval (\"A = acos(-1);\");\n\
 @end example\n\
 \n\
-If an error occurs during the evaluation of @var{try} the @var{catch}\n\
+If an error occurs during the evaluation of @var{try} then the @var{catch}\n\
 string is evaluated, as the following example shows:\n\
 \n\
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
       'printf (\"This error occurred:\\n%s\\n\", lasterr ());');\n\
      @print{} This error occurred:\n\
         This is a bad example\n\
 @end group\n\
 @end example\n\
 \n\
-Consider using try/catch blocks instead if you are only using @code{eval}\n\
-as an error-capturing mechanism rather than for the execution of arbitrary\n\
-code strings.\n\
+Programming Note: if you are only using @code{eval} as an error-capturing\n\
+mechanism, rather than for the execution of arbitrary code strings,\n\
+Consider using try/catch blocks or unwind_protect/unwind_protect_cleanup\n\
+blocks instead.  These techniques have higher performance and don't introduce\n\
+the security considerations that the evaluation of arbitrary code does.\n\
 @seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
@@ -4570,18 +4576,21 @@ context @var{context}, which may be eith
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__parser_debug_flag__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{old_val} =} __parser_debug_flag__ (@var{new_val}))\n\
-Undocumented internal function.\n\
+@deftypefn  {Built-in Function} {@var{val} =} __parser_debug_flag__ ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} __parser_debug_flag__ (@var{new_val})\n\
+Query or set the internal flag that determines whether Octave's parser prints\n\
+debug information as it processes an expression.\n\
+@seealso{__lexer_debug_flag__}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   bool debug_flag = octave_debug;
 
   retval = set_internal_variable (debug_flag, args, nargout,
                                   "__parser_debug_flag__");
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1369,17 +1369,17 @@ tree_matrix::accept (tree_walker& tw)
 */
 
 DEFUN (string_fill_char, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
-matrix to the same length.  It must be a single character.  The default\n\
+matrix to the same length; It must be a single character.  The default\n\
 value is @qcode{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
       @result{}  \"theseXX\"\n\
           \"areXXXX\"\n\
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
--- a/scripts/general/fieldnames.m
+++ b/scripts/general/fieldnames.m
@@ -28,17 +28,17 @@
 ## of the structure.
 ##
 ## When the input is an Octave object @var{obj}, the names are the public
 ## properties of the object.
 ##
 ## When the input is a Java object @var{javaobj} or Java classname
 ## @var{jclassname} the name are the public data elements of the object or
 ## class.
-## @seealso{struct, methods}
+## @seealso{nfields, isfield, orderfields, struct, methods}
 ## @end deftypefn
 
 function names = fieldnames (obj)
   
   if (nargin != 1)
     print_usage ();
   endif
   
diff --git a/scripts/help/doc_cache_create.m b/scripts/help/doc_cache_create.m
--- a/scripts/help/doc_cache_create.m
+++ b/scripts/help/doc_cache_create.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {} doc_cache_create (@var{out_file}, @var{directory})
 ## Generate documentation caches for all functions in a given directory.
 ##
 ## A documentation cache is generated for all functions in @var{directory}.
 ## The
 ## resulting cache is saved in the file @var{out_file}.
 ## The cache is used to speed up @code{lookfor}.
 ##
-## If no directory is given (or it is the empty matrix), a cache for builtin
+## If no directory is given (or it is the empty matrix), a cache for built-in
 ## operators, etc. is generated.
 ##
 ## @seealso{doc_cache_file, lookfor, path}
 ## @end deftypefn
 
 function doc_cache_create (out_file = "doc-cache", directory = [])
 
   ## Check input
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -178,38 +178,19 @@ function h = __img__ (hax, do_new, x, y,
 
   h = __go_image__ (hax, "cdata", img, "xdata", xdata, "ydata", ydata,
                          "cdatamapping", "direct", varargin{:});
 
   if (do_new && ! ishold (hax))
     ## Set axis properties for new images
 
     if (! isempty (img))
-      px = __image_pixel_size__ (h);
-
-      if (xdata(2) < xdata(1))
-        xdata = fliplr (xdata);
-      elseif (xdata(2) == xdata(1))
-        xdata = xdata(1) + [0, columns(img)-1];
+      if (isscalar (get (hax, "children")))
+        axis (hax, "image")
       endif
-      if (ydata(2) < ydata(1))
-        ydata = fliplr (ydata);
-      elseif (ydata(2) == ydata(1))
-        ydata = ydata(1) + [0, rows(img)-1];
-      endif
-      xlim = xdata + [-px(1), px(1)];
-      ylim = ydata + [-px(2), px(2)];
-
-      ## FIXME -- how can we do this and also get the {x,y}limmode
-      ## properties to remain "auto"?  I suppose this adjustment should
-      ## happen automatically in axes::update_axis_limits instead of
-      ## explicitly setting the values here.  But then what information is
-      ## available to axes::update_axis_limits to determine that the
-      ## adjustment is necessary?
-      set (hax, "xlim", xlim, "ylim", ylim);
 
       if (ndims (img) == 3)
         if (isinteger (img))
           cls = class (img);
           mn = intmin (cls);
           mx = intmax (cls);
           set (hax, "clim", double ([mn, mx]));
         endif
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -171,18 +171,20 @@ function [output, delimiter, header_rows
   header_cols = 0;
     
   ## Work through first few rows line by line until a delimiter is found.
   while (ischar (row = fgetl (fid)))
 
     ## If no delimiter determined yet, make a guess.
     if (isempty (delimiter))
       ## This pattern can be fooled, but mostly does the job just fine.
-      delim = regexp (row, '[+-\d.eE\*ij ]+([^+-\d.ij])[+-\d.ij]',
-                           'tokens', 'once');
+      delim = regexp (row, '[-+\d.eE*ij ]+([^-+\d.ij])[-+\d.ij]',
+                      'tokens', 'once');
+      #delim = regexp (row, '[+-\d.eE\*ij ]+([^+-\d.ij])[+-\d.ij]',
+      #                     'tokens', 'once');
       if (! isempty (delim))
         delimiter = delim{1};
       endif
     endif
 
     if (delimiter == " ")
       row_entries = regexp (strtrim (row), ' +', 'split');
     else
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{val}] =} getfield (@var{s}, @var{field})
 ## @deftypefnx {Function File} {[@var{val}] =} getfield (@var{s}, @var{idx1}, @var{field1}, @var{idx2}, @var{field2}, @dots{})
 ## Extract a field from a structure (or a nested structure).  The syntax
 ## is the same as @code{setfield}, except it omits the final @var{val}
 ## argument, returning this value instead of setting it.
 ##
-## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
+## @seealso{setfield, rmfield, isfield, fieldnames, isstruct, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = getfield (s, varargin)
   if (nargin < 2)
     print_usage ();
   endif
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -90,17 +90,17 @@
 ## Note that the same result as in the above example could be achieved by:
 ##
 ## @example
 ## @group
 ## @var{SA}.foo = 1;
 ## @var{SA}(2).bar(3).baz = 6
 ## @end group
 ## @end example
-## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
+## @seealso{getfield, rmfield, isfield, fieldnames, isstruct, struct}
 ## @end deftypefn
 
 ## Author:  Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = setfield (obj, varargin)
   if (nargin < 3)
     print_usage ();
   endif
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -327,20 +327,34 @@ function lims = __get_tight_lims__ (ca, 
   ## Exclude the redundant hgroup values.
   hg_kids = findobj (kids, "type", "hggroup");
   kids = setdiff (kids, hg_kids);
   if (isempty (kids))
     ## Return the current limits.
     lims = get (ca, strcat (ax, "lim"));
   else
     data = get (kids, strcat (ax, "data"));
+    types = get (kids, "type");
+    
     scale = get (ca, strcat (ax, "scale"));
     if (! iscell (data))
       data = {data};
     endif
+    
+    ## Extend image data one pixel
+    idx = strcmp (types, "image");
+    if (! isempty (idx) && (ax == "x" || ax == "y"))
+      imdata = data(idx);
+      px = arrayfun (@__image_pixel_size__, kids(idx), "uniformoutput", false);
+      ipx = ifelse (ax == "x", 1, 2);
+      imdata = cellfun (@(x,dx) [(min (x) - dx(ipx)), (max (x) + dx(ipx))],
+                        imdata, px, "uniformoutput", false);
+      data(idx) = imdata;
+    endif
+    
     if (strcmp (scale, "log"))
       tmp = data;
       data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
       n = cellfun ("isempty", data);
       data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
     data = cellfun (@(x) x(isfinite (x)), data, "uniformoutput", false);
     data = data(! cellfun ("isempty", data));
diff --git a/scripts/plot/util/isprop.m b/scripts/plot/util/isprop.m
--- a/scripts/plot/util/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{res} =} isprop (@var{h}, "@var{prop}")
 ## Return true if @var{prop} is a property of the object with handle @var{h}.
 ##
 ## @var{h} may also be an array of handles in which case @var{res} will be a
 ## logical array indicating whether each handle has the property @var{prop}.
-## @seealso{get, set}
+## @seealso{get, set, ismethod, isobject}
 ## @end deftypefn
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
 function res = isprop (h, prop)
 
   if (nargin != 2)
     print_usage ();
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -555,22 +555,45 @@
 
 %!test
 %! id = tmpfile ();
 %! fwrite (id, char (0:15));
 %! frewind (id);
 %! [data, count] = fread (id, inf, "2*uint8", 2);
 %! assert (data, [0; 1; 4; 5; 8; 9; 12; 13]);
 %! assert (count, 8);
+%! fclose (id);
+
+%!test
+%! id = tmpfile ();
+%! fwrite (id, char (0:15));
 %! frewind (id);
 %! [data, count] = fread (id, 3, "2*uint8", 3);
 %! assert (data, [0; 1; 5]);
 %! assert (count, 3);
 %! [data, count] = fread (id, 3, "2*uint8", 3);
 %! assert (data, [6; 7; 11]);
 %! assert (count, 3);
 %! [data, count] = fread (id, 3, "2*uint8", 3);
 %! assert (data, [12; 13]);
 %! assert (count, 2);
 %! [data, count] = fread (id, 3, "2*uint8", 3);
 %! assert (data, []);
 %! assert (count, 0);
 %! fclose (id);
+
+%!test
+%! id = tmpfile ();
+%! fwrite (id, char (0:15));
+%! frewind (id);
+%! [data, count] = fread (id, [1, Inf], "4*uint16", 3);
+%! assert (data, [256, 770, 1284, 1798, 3083, 3597]);
+%! assert (count, 6);
+%! fclose (id);
+
+%!test
+%! id = tmpfile ();
+%! fwrite (id, char (0:15));
+%! frewind (id);
+%! [data, count] = fread (id, [3, Inf], "4*uint16", 3);
+%! assert (data, [256, 1798; 770, 3083; 1284, 3597]);
+%! assert (count, 6);
+%! fclose (id);
